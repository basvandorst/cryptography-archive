diff -crN tmp/SSLeay-0.8.1/Makefile SSLeay-0.8.1/Makefile
*** tmp/SSLeay-0.8.1/Makefile	Fri Jul 18 20:18:10 1997
--- SSLeay-0.8.1/Makefile	Tue Nov 18 14:16:07 1997
***************
*** 101,107 ****
  SDIRS=  \
  	md sha mdc2 des rc4 rc2 idea bf bn rsa dsa dh \
  	buffer bio stack lhash rand err objects \
! 	evp pem asn1 x509 conf txt_db pkcs7
  
  # If you change the INSTALLTOP, make sure to also change the values
  # in crypto/location.h
--- 101,107 ----
  SDIRS=  \
  	md sha mdc2 des rc4 rc2 idea bf bn rsa dsa dh \
  	buffer bio stack lhash rand err objects \
! 	evp pem asn1 x509 conf txt_db pkcs7 pkcs12
  
  # If you change the INSTALLTOP, make sure to also change the values
  # in crypto/location.h
diff -crN tmp/SSLeay-0.8.1/Makefile.ssl SSLeay-0.8.1/Makefile.ssl
*** tmp/SSLeay-0.8.1/Makefile.ssl	Fri Jul 18 20:18:10 1997
--- SSLeay-0.8.1/Makefile.ssl	Tue Nov 18 14:16:07 1997
***************
*** 101,107 ****
  SDIRS=  \
  	md sha mdc2 des rc4 rc2 idea bf bn rsa dsa dh \
  	buffer bio stack lhash rand err objects \
! 	evp pem asn1 x509 conf txt_db pkcs7
  
  # If you change the INSTALLTOP, make sure to also change the values
  # in crypto/location.h
--- 101,107 ----
  SDIRS=  \
  	md sha mdc2 des rc4 rc2 idea bf bn rsa dsa dh \
  	buffer bio stack lhash rand err objects \
! 	evp pem asn1 x509 conf txt_db pkcs7 pkcs12
  
  # If you change the INSTALLTOP, make sure to also change the values
  # in crypto/location.h
diff -crN tmp/SSLeay-0.8.1/apps/Makefile SSLeay-0.8.1/apps/Makefile
*** tmp/SSLeay-0.8.1/apps/Makefile	Fri Jul 18 20:18:33 1997
--- SSLeay-0.8.1/apps/Makefile	Tue Nov 18 14:16:07 1997
***************
*** 34,40 ****
  E_EXE=	verify asn1pars req dgst dh enc gendh gendsa errstr ca crl \
  	rsa dsa dsaparam \
  	x509 genrsa s_server s_client speed \
! 	s_time version pkcs7 crl2pkcs7 sess_id ciphers
  
  PROGS= $(SSLEAY).c
  
--- 34,40 ----
  E_EXE=	verify asn1pars req dgst dh enc gendh gendsa errstr ca crl \
  	rsa dsa dsaparam \
  	x509 genrsa s_server s_client speed \
! 	s_time version pkcs7 crl2pkcs7 sess_id ciphers pkcs12
  
  PROGS= $(SSLEAY).c
  
***************
*** 48,54 ****
  	rsa.o dsa.o dsaparam.o \
  	x509.o genrsa.o s_server.o s_client.o speed.o \
  	s_time.o $(A_OBJ) $(S_OBJ) version.o sess_id.o \
! 	ciphers.o
  
  #	pem_mail.o
  
--- 48,54 ----
  	rsa.o dsa.o dsaparam.o \
  	x509.o genrsa.o s_server.o s_client.o speed.o \
  	s_time.o $(A_OBJ) $(S_OBJ) version.o sess_id.o \
! 	ciphers.o pkcs12.o
  
  #	pem_mail.o
  
***************
*** 57,63 ****
  	rsa.c dsa.c dsaparam.c \
  	x509.c genrsa.c s_server.c s_client.c speed.c \
  	s_time.c $(A_SRC) $(S_SRC) version.c sess_id.c \
! 	ciphers.c
  
  #	pem_mail.c
  
--- 57,63 ----
  	rsa.c dsa.c dsaparam.c \
  	x509.c genrsa.c s_server.c s_client.c speed.c \
  	s_time.c $(A_SRC) $(S_SRC) version.c sess_id.c \
! 	ciphers.c pkcs12.c
  
  #	pem_mail.c
  
diff -crN tmp/SSLeay-0.8.1/apps/Makefile.ssl SSLeay-0.8.1/apps/Makefile.ssl
*** tmp/SSLeay-0.8.1/apps/Makefile.ssl	Fri Jul 18 20:18:33 1997
--- SSLeay-0.8.1/apps/Makefile.ssl	Tue Nov 18 14:16:07 1997
***************
*** 34,40 ****
  E_EXE=	verify asn1pars req dgst dh enc gendh gendsa errstr ca crl \
  	rsa dsa dsaparam \
  	x509 genrsa s_server s_client speed \
! 	s_time version pkcs7 crl2pkcs7 sess_id ciphers
  
  PROGS= $(SSLEAY).c
  
--- 34,40 ----
  E_EXE=	verify asn1pars req dgst dh enc gendh gendsa errstr ca crl \
  	rsa dsa dsaparam \
  	x509 genrsa s_server s_client speed \
! 	s_time version pkcs7 crl2pkcs7 sess_id ciphers pkcs12
  
  PROGS= $(SSLEAY).c
  
***************
*** 48,54 ****
  	rsa.o dsa.o dsaparam.o \
  	x509.o genrsa.o s_server.o s_client.o speed.o \
  	s_time.o $(A_OBJ) $(S_OBJ) version.o sess_id.o \
! 	ciphers.o
  
  #	pem_mail.o
  
--- 48,54 ----
  	rsa.o dsa.o dsaparam.o \
  	x509.o genrsa.o s_server.o s_client.o speed.o \
  	s_time.o $(A_OBJ) $(S_OBJ) version.o sess_id.o \
! 	ciphers.o pkcs12.o
  
  #	pem_mail.o
  
***************
*** 57,63 ****
  	rsa.c dsa.c dsaparam.c \
  	x509.c genrsa.c s_server.c s_client.c speed.c \
  	s_time.c $(A_SRC) $(S_SRC) version.c sess_id.c \
! 	ciphers.c
  
  #	pem_mail.c
  
--- 57,63 ----
  	rsa.c dsa.c dsaparam.c \
  	x509.c genrsa.c s_server.c s_client.c speed.c \
  	s_time.c $(A_SRC) $(S_SRC) version.c sess_id.c \
! 	ciphers.c pkcs12.c
  
  #	pem_mail.c
  
diff -crN tmp/SSLeay-0.8.1/apps/mklinks SSLeay-0.8.1/apps/mklinks
*** tmp/SSLeay-0.8.1/apps/mklinks	Fri Jul 18 19:15:56 1997
--- SSLeay-0.8.1/apps/mklinks	Tue Nov 18 14:16:07 1997
***************
*** 1,5 ****
  #!/bin/sh
! for i in verify asn1parse req dgst dh enc gendh gendsa errstr ca crl rsa dsa dsaparam x509 genrsa s_server s_client speed s_time version pkcs7 crl2pkcs7 sess_id ciphers md2 md5 sha sha1 mdc2 base64 des des3 desx idea rc4 rc2 bf des-ecb des-ede des-ede3 des-cbc des-ede-cbc des-ede3-cbc des-cfb des-ede-cfb des-ede3-cfb des-ofb des-ede-ofb des-ede3-ofb idea-cbc idea-ecb idea-cfb idea-ofb rc2-cbc rc2-ecb rc2-cfb rc2-ofb bf-cbc bf-ecb bf-cfb bf-ofb 
  do
  echo making symlink for $i
  /bin/rm -f $i
--- 1,5 ----
  #!/bin/sh
! for i in verify asn1parse req dgst dh enc gendh gendsa errstr ca crl rsa dsa dsaparam x509 genrsa s_server s_client speed s_time version pkcs7 crl2pkcs7 sess_id ciphers pkcs12 md2 md5 sha sha1 mdc2 base64 des des3 desx idea rc4 rc2 bf des-ecb des-ede des-ede3 des-cbc des-ede-cbc des-ede3-cbc des-cfb des-ede-cfb des-ede3-cfb des-ofb des-ede-ofb des-ede3-ofb idea-cbc idea-ecb idea-cfb idea-ofb rc2-cbc rc2-ecb rc2-cfb rc2-ofb bf-cbc bf-ecb bf-cfb bf-ofb 
  do
  echo making symlink for $i
  /bin/rm -f $i
diff -crN tmp/SSLeay-0.8.1/apps/pkcs12.c SSLeay-0.8.1/apps/pkcs12.c
*** tmp/SSLeay-0.8.1/apps/pkcs12.c	Thu Jan  1 01:00:00 1970
--- SSLeay-0.8.1/apps/pkcs12.c	Tue Nov 18 14:16:38 1997
***************
*** 0 ****
--- 1,479 ----
+ /* Copyright Dr Stephen Henson 1997. All rights reserved.
+  * The conditions of use are identical to those of SSLeay except that my
+  * name (in addition to Eric Young or Tim Hudson) must be mentioned
+  * if this software is used in a product and the notice "This product
+  * includes software written by Dr Stephen Henson (shenson@bigfoot.com)"
+  * used.
+  */
+ #include <stdio.h>
+ #include <stdlib.h>
+ #include <bio.h>
+ #include <objects.h>
+ #include <asn1.h>
+ #include <asn1_mac.h>
+ #include <x509.h>
+ #include <pkcs7.h>
+ #include <err.h>
+ #include <crypto.h>
+ #include <sha.h>
+ #include <rc2.h>
+ #include <stack.h>
+ #include <evp.h>
+ #include <rsa.h>
+ #include <pem.h>
+ #include <pkcs12.h>
+ 
+ #ifdef STANDALONE
+ #define MAIN main
+ BIO *bio_err=NULL;
+ #else
+ #include "apps.h"
+ #undef PROG
+ #define PROG pkcs12_main
+ #endif
+ 
+ EVP_CIPHER *enc;
+ 
+ int MAIN(argc, argv)
+ int argc;
+ char **argv;
+ {
+     char *infile=NULL, *outfile=NULL, *keyname = NULL;	
+     char *certfile=NULL;
+     BIO *in=NULL, *out = NULL, *inkey = NULL, *certsin = NULL;
+     char **args;
+     unsigned char *unipass;
+     char *name;
+     int unilen;
+     PKCS12 *p12 = NULL;
+     char pstr[50] ;
+     int export_cert = 0;
+     int noout = 0;
+     int info = 0;
+     int nokeys = 0;
+     int nocerts = 0;
+     int chain = 0;
+     int badarg = 0;
+ #ifndef STANDALONE
+     apps_startup();
+ #endif
+     enc = EVP_des_ede3_cbc();
+     if (bio_err == NULL ) bio_err = BIO_new_fp (stderr, BIO_NOCLOSE);
+ 
+     args = argv + 1;
+ 
+     while (*args) {
+ 	if (*args[0] == '-') {
+ 		if (!strcmp (*args, "-nokeys")) nokeys = 1;
+ 		else if (!strcmp (*args, "-nocerts")) nocerts = 1;
+ 		else if (!strcmp (*args, "-noout")) noout = 1;
+ 		else if (!strcmp (*args, "-info")) info = 1;
+ 		else if (!strcmp (*args, "-chain")) chain = 1;
+ 		else if (!strcmp (*args, "-export")) export_cert = 1;
+ 		else if (!strcmp (*args, "-des")) enc=EVP_des_cbc();
+ 		else if (!strcmp (*args, "-idea")) enc=EVP_idea_cbc();
+ 		else if (!strcmp (*args, "-des3")) enc = EVP_des_ede3_cbc();
+ 		else if (!strcmp (*args, "-nodes")) enc=NULL;
+ 		else if (!strcmp (*args, "-inkey")) {
+ 		    if (args[1]) {
+ 			args++;	
+ 			keyname = *args;
+ 		    } else badarg = 1;
+ 		} else if (!strcmp (*args, "-certfile")) {
+ 		    if (args[1]) {
+ 			args++;	
+ 			certfile = *args;
+ 		    } else badarg = 1;
+ 		} else if (!strcmp (*args, "-name")) {
+ 		    if (args[1]) {
+ 			args++;	
+ 			name = *args;
+ 		    } else badarg = 1;
+ 		} else if (!strcmp (*args, "-in")) {
+ 		    if (args[1]) {
+ 			args++;	
+ 			infile = *args;
+ 		    } else badarg = 1;
+ 		} else if (!strcmp (*args, "-out")) {
+ 		    if (args[1]) {
+ 			args++;	
+ 			outfile = *args;
+ 		    } else badarg = 1;
+ 		} else badarg = 1;
+ 
+ 	} else badarg = 1;
+ 	args++;
+     }
+ 
+     if (badarg) {
+ 	BIO_printf (bio_err, "Usage:\npkcs12 [options]\n");
+ 	BIO_printf (bio_err, "where options are\n");
+ 	BIO_printf (bio_err, "-export       output PKCS12 file\n");
+ 	BIO_printf (bio_err, "-chain        add certificate chain\n");
+ 	BIO_printf (bio_err, "-inkey file   private key if not infile\n");
+ 	BIO_printf (bio_err, "-certfile f   add all certs in f\n");
+ 	BIO_printf (bio_err, "-name \"name\"  use name as friendly name\n");
+ 	BIO_printf (bio_err, "-in  infile   input filename\n");
+ 	BIO_printf (bio_err, "-out outfile  output filename\n");
+ 	BIO_printf (bio_err, "-noout        don't output anything, just verify.\n");
+ 	BIO_printf (bio_err, "-nocerts      don't output certificates.\n");
+ 	BIO_printf (bio_err, "-nokeys       don't output private keys.\n");
+ 	BIO_printf (bio_err, "-info         give info about PKCS#12 structure.\n");
+ 	BIO_printf (bio_err, "-des          encrypt private keys with DES\n");
+ 	BIO_printf (bio_err, "-des3         encrypt private keys with triple DES (default)\n");
+ 	BIO_printf (bio_err, "-idea         encrypt private keys with idea\n");
+ 	BIO_printf (bio_err, "-nodes        don't encrypt private keys\n");
+     	exit (1);
+     }
+ 
+     if (noout) {
+ 	nokeys = 1;
+ 	nocerts = 1;
+     }
+ 
+     ERR_load_crypto_strings();
+ #ifdef STANDALONE
+     SSLeay_add_all_algorithms();
+ #endif
+ 
+ 
+     in = BIO_new (BIO_s_file());
+     out = BIO_new (BIO_s_file());
+ 
+     if (!infile) BIO_set_fp (in, stdin, BIO_NOCLOSE);
+     else {
+ 	if (!keyname) keyname = infile;
+         if (BIO_read_filename (in, infile) <= 0) {
+ 	    perror (infile);
+ 	    exit (1);
+ 	}
+     }
+ 
+    if (certfile) {
+     	certsin = BIO_new (BIO_s_file());
+         if (BIO_read_filename (certsin, certfile) <= 0) {
+ 	    perror (certfile);
+ 	    exit (1);
+ 	}
+     }
+ 
+     if (keyname) {
+     	inkey = BIO_new (BIO_s_file());
+         if (BIO_read_filename (inkey, keyname) <= 0) {
+ 	    perror (keyname);
+ 	    exit (1);
+ 	}
+      }
+ 
+     if (!outfile) BIO_set_fp (out, stdout, BIO_NOCLOSE);
+     else {
+         if (BIO_write_filename (out, outfile) <= 0) {
+ 	    perror (outfile);
+ 	    exit (1);
+ 	}
+     }
+ 
+ if (export_cert) {
+ 	RSA *key;
+ 	STACK *bags, *safes;
+ 	PKCS12_SAFEBAG *bag;
+ 	PKCS8_PRIV_KEY_INFO *p8;
+ 	PKCS7 *authsafe;
+ 	X509 *cert;
+ 	unsigned char *uniname;
+ 	int uninlen;
+ 	unsigned char keyid[] = { 1, 0, 0, 0};
+ 	
+ 	cert = PEM_read_bio_X509(in, NULL, NULL);
+ 
+ 	if (!cert) {
+ 		ERR_print_errors(bio_err);
+ 		exit (1);
+ 	}
+ 
+ 	bags = sk_new (NULL);
+ 	bag = M_PKCS12_x5092certbag (cert);
+ 	if (!bag) {
+ 		ERR_print_errors (bio_err);
+ 		exit (1);
+ 	}
+         if (name) {
+ 		asc2uni (name, &uniname, &uninlen);
+ 		PKCS12_add_friendlyname (bag, uniname, uninlen);
+         } else uniname = NULL;
+ 	PKCS12_add_localkeyid (bag, keyid, 4);
+ 	sk_push (bags, (char *)bag);
+ 	/* If chaining get chain */
+ 	if (chain) {
+         	int vret, i;
+ 		X509 *x509tmp;
+ 		STACK *chain;
+ 		vret = get_cert_chain (cert, &chain);
+ 		if (vret) {
+ 			BIO_printf (bio_err, "Error %s getting chain.\n",
+ 					X509_verify_cert_error_string(vret));
+ 			exit (1);
+ 		}
+ 		/* Exclude verified certificate */
+ 		for (i = 1; i < sk_num (chain) ; i++) {
+ 			x509tmp = sk_value (chain, i);
+ 			bag = M_PKCS12_x5092certbag (x509tmp);
+ 		        sk_push (bags, (char *)bag);
+ 		}
+ 			
+     	}
+ 
+ 	X509_free (cert);
+ 
+ 	/* Add any more certificates asked for */
+ 	if (certsin) {
+ 	    STACK *sk;
+ 	    X509_INFO *xi;
+ 	    sk = PEM_X509_INFO_read_bio (certsin, NULL, NULL);
+ 	    if (sk != NULL) {
+ 		while (sk_num(sk)) {
+ 		    xi = (X509_INFO *)sk_shift(sk);
+ 		    if (xi->x509) {
+ 			bag = M_PKCS12_x5092certbag (xi->x509);
+ 		        sk_push (bags, (char *)bag);
+ 		    }
+ 		    X509_INFO_free (xi);
+ 		}
+ 	    }
+  	}
+ 
+ 	if(EVP_read_pw_string (pstr, 50, "Enter Export Password:", 1)) {
+ 	    BIO_printf (bio_err, "Can't read Password\n");
+ 	    exit (1);
+         }
+     	asc2uni (pstr, &unipass, &unilen);
+ 	/* Turn certbags into encrypted authsafe */
+ 	authsafe = PKCS12_pack_p7encdata (NID_pbe_WithSHA1And40BitRC2_CBC,
+ 			unipass, unilen, NULL, 0, 1, bags);
+ 
+ 	if (!authsafe) {
+ 		ERR_print_errors_fp (stderr);
+ 		exit (3);
+ 	}
+ 
+ 	sk_zero (bags);
+ 	safes = sk_new (NULL);
+ 	sk_push (safes, (char *)authsafe);		
+ 
+ 	key = PEM_read_bio_RSAPrivateKey(inkey ? inkey : in, NULL, NULL);
+ 	if (!key) {
+ 		BIO_printf (bio_err, "Error loading private key\n");
+ 		ERR_print_errors(bio_err);
+ 		exit (1);
+ 	}
+ 
+ 	/* Make a shrouded key bag */
+ 	p8 = rsa2PKCS8 (key);
+ 	bag = PKCS12_MAKE_SHKEYBAG (NID_pbe_WithSHA1And3_Key_TripleDES_CBC,
+ 			unipass, unilen, NULL, 0, 1, p8);
+         if (uniname) PKCS12_add_friendlyname (bag, uniname, uninlen);
+ 	PKCS12_add_localkeyid (bag, keyid, 4);
+ 	sk_push (bags, (char *)bag);
+ 	/* Turn it into unencrypted safe bag */
+ 	authsafe = PKCS12_pack_p7data (bags);
+ 	sk_push (safes, (char *)authsafe);
+ 
+ 	p12 = PKCS12_init (NID_pkcs7_data);
+ 
+ 	M_PKCS12_pack_authsafes (p12, safes);
+ 
+ 	PKCS12_set_mac (p12, unipass, unilen, NULL, 0, 1, NULL);
+ 
+ 	ASN1_i2d_bio (i2d_PKCS12, out, (char *)p12);
+ 
+ 	exit (0);
+ }
+ 
+     p12 = (PKCS12 *) ASN1_d2i_bio ((char *(*)())PKCS12_new,
+ 				 (char *(*)())d2i_PKCS12, in, NULL);
+ 
+     if (!p12) {
+ 	ERR_print_errors(bio_err);
+ 	exit (1);
+     }
+ 
+     if(EVP_read_pw_string (pstr, 50, "Enter Import Password:", 0)) {
+ 	BIO_printf (bio_err, "Can't read Password\n");
+ 	exit (1);
+     }
+ 
+     asc2uni (pstr, &unipass, &unilen);
+ 
+     if (!PKCS12_verify_mac (p12, unipass, unilen)) {
+       BIO_printf (bio_err, "Mac verify errror: invalid password?\n");
+       exit (1);
+      } else BIO_printf (bio_err, "MAC verified OK\n");
+ 
+     if (!dump_certs_keys_p12 (out, p12, unipass, unilen, nocerts, nokeys, info)) {
+ 	ERR_print_errors (bio_err);
+ 	exit (1);
+     }
+ 
+     return (0);
+ }
+ 
+ int dump_cert_text (out, x)
+ BIO *out;
+ X509 *x;
+ {
+ 	char buf[256];
+ 	X509_NAME_oneline(X509_get_subject_name(x),buf,256);
+ 	BIO_puts(out,"subject=");
+ 	BIO_puts(out,buf);
+ 
+ 	X509_NAME_oneline(X509_get_issuer_name(x),buf,256);
+ 	BIO_puts(out,"\nissuer= ");
+ 	BIO_puts(out,buf);
+ 	BIO_puts(out,"\n");
+         return 0;
+ }
+ 
+ int dump_certs_keys_p12 (out, p12, unipass, unilen, nocerts, nokeys, info)
+ BIO *out;
+ PKCS12 *p12;
+ unsigned char *unipass;
+ int unilen;
+ int nocerts;
+ int nokeys;
+ int info;
+ {
+ 	STACK *asafes, *bags;
+ 	int i, bagnid;
+ 	PKCS7 *p7;
+ 	if (!( asafes = M_PKCS12_unpack_authsafes (p12))) return 0;
+ 	for (i = 0; i < sk_num (asafes); i++) {
+ 		p7 = (PKCS7 *) sk_value (asafes, i);
+ 		bagnid = OBJ_obj2nid (p7->type);
+ 		if (bagnid == NID_pkcs7_data) {
+ 			bags = M_PKCS12_unpack_p7data (p7);
+ 			if (info) BIO_printf (bio_err, "PKCS7 Data\n");
+ 		} else if (bagnid == NID_pkcs7_encrypted) {
+ 			if (info) BIO_printf (bio_err,
+ 			 "PKCS7 Encryptyed data %s\n",
+ OBJ_nid2ln(OBJ_obj2nid(p7->d.encrypted->enc_data->algorithm->algorithm)));
+ 			bags = M_PKCS12_unpack_p7encdata (p7, unipass, unilen);
+ 		} else continue;
+ 		if (!bags) return 0;
+ 	    	if (!dump_certs_pkeys_bags (out, bags, unipass, unilen,
+ 					 nocerts, nokeys, info)) return 0;
+ 	}
+ 	return 1;
+ }
+ 
+ int dump_certs_pkeys_bags (out, bags, pass, passlen, nocerts, nokeys, info)
+ BIO *out;
+ STACK *bags;
+ unsigned char *pass;
+ int passlen;
+ int nocerts;
+ int nokeys;
+ int info;
+ {
+ 	int i;
+ 	for (i = 0; i < sk_num (bags); i++) {
+ 		if (!dump_certs_pkeys_bag (out,
+ 			 (PKCS12_SAFEBAG *)sk_value (bags, i), pass, passlen,
+ 					 nocerts, nokeys, info)) return 0;
+ 	}
+ 	return 1;
+ }
+ 
+ int dump_certs_pkeys_bag (out, bag, pass, passlen, nocerts, nokeys, info)
+ BIO *out;
+ PKCS12_SAFEBAG *bag;
+ unsigned char *pass;
+ int passlen;
+ int nocerts;
+ int nokeys;
+ int info;
+ {
+ 	RSA *rsa;
+ 	PKCS8_PRIV_KEY_INFO *p8;
+ 	X509 *x509;
+ 	ASN1_TYPE *attrib;
+ 	int i;
+ 	attrib = PKCS12_get_attr (bag, NID_friendlyName);
+ 	if (attrib) {
+ 		char *name;
+ 		name = uni2asc (attrib->value.bmpstring->data,
+ 					 attrib->value.bmpstring->length);
+ 		BIO_printf (out, "Friendly Name: %s\n", name);
+ 		Free (name);
+ 	}
+ 	attrib = PKCS12_get_attr (bag, NID_localKeyID);
+ 	if (attrib) {
+ 		BIO_printf (out, "Local Key ID: ");
+ 		for (i = 0; i < attrib->value.octet_string->length; i++) {
+ 			BIO_printf (out, "%02X ",
+ 					 attrib->value.octet_string->data[i]);
+ 		}
+ 		BIO_printf (out, "\n");
+ 	}
+ 	
+ 	switch (OBJ_obj2nid (bag->type))
+ 	{
+ 	case NID_keyBag:
+ 		if (info) BIO_printf (bio_err, "Key bag\n");
+ 		if (nokeys) return 1;
+ 		if (!(rsa = M_PKCS12_pkcs82rsa (bag->value.keybag))) return 0;
+ 		PEM_write_bio_RSAPrivateKey (out, rsa, enc, NULL, 0, NULL);
+ 	break;
+ 
+ 	case NID_pkcs8ShroudedKeyBag:
+ 		if (info) BIO_printf (bio_err, "Shrouded Keybag %s\n",
+ 	OBJ_nid2ln(OBJ_obj2nid(bag->value.shkeybag->algor->algorithm)));
+ 		if (nokeys) return 1;
+ 		if (!(p8 = M_PKCS12_decrypt_skey (bag, pass, passlen)))
+ 				return 0;
+ 		if (!(rsa = M_PKCS12_pkcs82rsa (p8))) return 0;
+ 		PEM_write_bio_RSAPrivateKey (out, rsa, enc, NULL, 0, NULL);
+ 	break;
+ 
+ 	case NID_certBag:
+ 		if (info) BIO_printf (bio_err, "Certificate bag\n");
+ 		if (nocerts) return 1;
+ 		if (OBJ_obj2nid (bag->value.bag->type) != NID_x509Certificate)
+ 			return 1;
+ 		if (!(x509 = M_PKCS12_certbag2x509 (bag))) return 0;
+ 		dump_cert_text (out, x509);
+ 		PEM_write_bio_X509 (out, x509);
+ 	break;
+ 
+ 	case NID_safeContentsBag:
+ 		if (info) BIO_printf (bio_err, "Safe Contents bag\n");
+ 		return dump_certs_pkeys_bags (out, bag->value.safes, pass, 
+ 						passlen,nocerts, nokeys);
+ 					
+ 
+ 	default:
+ 		return 1;
+ 	break;
+ 	}
+ 	return 1;
+ }
+ 
+ /* Given a single certificate return a verified chain or NULL if error */
+ 
+ /* Hope this is OK .... */
+ 
+ int get_cert_chain (cert, chain)
+ X509 *cert;
+ STACK **chain;
+ {
+ 	X509_STORE *store;
+ 	X509_STORE_CTX store_ctx;
+ 	store = X509_STORE_new ();
+ 	X509_STORE_set_default_paths (store);
+ 	X509_STORE_CTX_init(&store_ctx, store, cert, NULL);
+ 	if (X509_verify_cert(&store_ctx) <= 0) 
+ 			return X509_STORE_CTX_get_error (&store_ctx);
+ 	*chain =  X509_STORE_CTX_get_chain (&store_ctx);
+ 	return 0;
+ }	
+ 	
+ 
diff -crN tmp/SSLeay-0.8.1/apps/progs.h SSLeay-0.8.1/apps/progs.h
*** tmp/SSLeay-0.8.1/apps/progs.h	Fri Jul 18 19:15:56 1997
--- SSLeay-0.8.1/apps/progs.h	Tue Nov 18 14:16:07 1997
***************
*** 24,29 ****
--- 24,30 ----
  extern int crl2pkcs7_main(int argc,char *argv[]);
  extern int sess_id_main(int argc,char *argv[]);
  extern int ciphers_main(int argc,char *argv[]);
+ extern int pkcs12_main(int argc,char *argv[]);
  #else
  extern int verify_main();
  extern int asn1parse_main();
***************
*** 50,55 ****
--- 51,57 ----
  extern int crl2pkcs7_main();
  extern int sess_id_main();
  extern int ciphers_main();
+ extern int pkcs12_main();
  #endif
  
  #ifdef SSLEAY_SRC
***************
*** 118,123 ****
--- 120,126 ----
  #if !defined(NO_SOCK) && !(defined(NO_SSL2) && defined(O_SSL3))
  	{FUNC_TYPE_GENERAL,"ciphers",ciphers_main},
  #endif
+ 	{FUNC_TYPE_GENERAL,"pkcs12",pkcs12_main},
  	{FUNC_TYPE_MD,"md2",dgst_main},
  	{FUNC_TYPE_MD,"md5",dgst_main},
  	{FUNC_TYPE_MD,"sha",dgst_main},
diff -crN tmp/SSLeay-0.8.1/apps/rmlinks SSLeay-0.8.1/apps/rmlinks
*** tmp/SSLeay-0.8.1/apps/rmlinks	Fri Jul 18 19:15:56 1997
--- SSLeay-0.8.1/apps/rmlinks	Tue Nov 18 14:16:07 1997
***************
*** 1,5 ****
  #!/bin/sh
! for i in verify asn1parse req dgst dh enc gendh gendsa errstr ca crl rsa dsa dsaparam x509 genrsa s_server s_client speed s_time version pkcs7 crl2pkcs7 sess_id ciphers md2 md5 sha sha1 mdc2 base64 des des3 desx idea rc4 rc2 bf des-ecb des-ede des-ede3 des-cbc des-ede-cbc des-ede3-cbc des-cfb des-ede-cfb des-ede3-cfb des-ofb des-ede-ofb des-ede3-ofb idea-cbc idea-ecb idea-cfb idea-ofb rc2-cbc rc2-ecb rc2-cfb rc2-ofb bf-cbc bf-ecb bf-cfb bf-ofb 
  do
  echo removing $i
  /bin/rm -f $i
--- 1,5 ----
  #!/bin/sh
! for i in verify asn1parse req dgst dh enc gendh gendsa errstr ca crl rsa dsa dsaparam x509 genrsa s_server s_client speed s_time version pkcs7 crl2pkcs7 sess_id ciphers pkcs12 md2 md5 sha sha1 mdc2 base64 des des3 desx idea rc4 rc2 bf des-ecb des-ede des-ede3 des-cbc des-ede-cbc des-ede3-cbc des-cfb des-ede-cfb des-ede3-cfb des-ofb des-ede-ofb des-ede3-ofb idea-cbc idea-ecb idea-cfb idea-ofb rc2-cbc rc2-ecb rc2-cfb rc2-ofb bf-cbc bf-ecb bf-cfb bf-ofb 
  do
  echo removing $i
  /bin/rm -f $i
diff -crN tmp/SSLeay-0.8.1/crypto/Makefile SSLeay-0.8.1/crypto/Makefile
*** tmp/SSLeay-0.8.1/crypto/Makefile	Fri Jul 18 20:18:22 1997
--- SSLeay-0.8.1/crypto/Makefile	Tue Nov 18 14:16:07 1997
***************
*** 31,37 ****
  	bn rsa dsa dh \
  	buffer bio stack lhash rand err objects \
  	evp pem x509 \
! 	asn1 conf txt_db pkcs7
  
  GENERAL=Makefile README
  
--- 31,37 ----
  	bn rsa dsa dh \
  	buffer bio stack lhash rand err objects \
  	evp pem x509 \
! 	asn1 conf txt_db pkcs7 pkcs12
  
  GENERAL=Makefile README
  
diff -crN tmp/SSLeay-0.8.1/crypto/Makefile.ssl SSLeay-0.8.1/crypto/Makefile.ssl
*** tmp/SSLeay-0.8.1/crypto/Makefile.ssl	Fri Jul 18 20:18:22 1997
--- SSLeay-0.8.1/crypto/Makefile.ssl	Tue Nov 18 14:16:07 1997
***************
*** 31,37 ****
  	bn rsa dsa dh \
  	buffer bio stack lhash rand err objects \
  	evp pem x509 \
! 	asn1 conf txt_db pkcs7
  
  GENERAL=Makefile README
  
--- 31,37 ----
  	bn rsa dsa dh \
  	buffer bio stack lhash rand err objects \
  	evp pem x509 \
! 	asn1 conf txt_db pkcs7 pkcs12
  
  GENERAL=Makefile README
  
diff -crN tmp/SSLeay-0.8.1/crypto/asn1/Makefile SSLeay-0.8.1/crypto/asn1/Makefile
*** tmp/SSLeay-0.8.1/crypto/asn1/Makefile	Fri Jul 18 20:18:30 1997
--- SSLeay-0.8.1/crypto/asn1/Makefile	Tue Nov 18 14:16:07 1997
***************
*** 23,29 ****
  
  LIB=$(TOP)/libcrypto.a
  LIBSRC=	a_object.c a_bitstr.c a_utctm.c a_int.c a_octet.c a_print.c \
! 	a_type.c a_set.c a_dup.c a_d2i_fp.c a_i2d_fp.c \
  	a_sign.c a_digest.c a_verify.c \
  	x_algor.c x_val.c x_pubkey.c x_sig.c x_req.c x_attrib.c \
  	x_name.c x_cinf.c x_x509.c x_crl.c x_info.c x_spki.c \
--- 23,29 ----
  
  LIB=$(TOP)/libcrypto.a
  LIBSRC=	a_object.c a_bitstr.c a_utctm.c a_int.c a_octet.c a_print.c \
! 	a_type.c a_bmpstr.c a_set.c a_dup.c a_d2i_fp.c a_i2d_fp.c \
  	a_sign.c a_digest.c a_verify.c \
  	x_algor.c x_val.c x_pubkey.c x_sig.c x_req.c x_attrib.c \
  	x_name.c x_cinf.c x_x509.c x_crl.c x_info.c x_spki.c \
***************
*** 35,43 ****
  	p7_dgst.c p7_s_e.c p7_enc.c p7_lib.c \
  	f_int.c f_string.c i2d_dhp.c i2d_dsap.c d2i_dhp.c d2i_dsap.c n_pkey.c \
  	a_hdr.c x_pkey.c a_bool.c x_exten.c \
! 	asn1_par.c asn1_lib.c $(ERRC).c a_meth.c a_bytes.c
  LIBOBJ= a_object.o a_bitstr.o a_utctm.o a_int.o a_octet.o a_print.o \
! 	a_type.o a_set.o a_dup.o a_d2i_fp.o a_i2d_fp.o \
  	a_sign.o a_digest.o a_verify.o \
  	x_algor.o x_val.o x_pubkey.o x_sig.o x_req.o x_attrib.o \
  	x_name.o x_cinf.o x_x509.o x_crl.o x_info.o x_spki.o \
--- 35,44 ----
  	p7_dgst.c p7_s_e.c p7_enc.c p7_lib.c \
  	f_int.c f_string.c i2d_dhp.c i2d_dsap.c d2i_dhp.c d2i_dsap.c n_pkey.c \
  	a_hdr.c x_pkey.c a_bool.c x_exten.c \
! 	asn1_par.c asn1_lib.c $(ERRC).c a_meth.c a_bytes.c \
! 	p12_bags.c p12_lib.c p12_mac.c p12_pbe.c p12_sbag.c p8_pkey.c
  LIBOBJ= a_object.o a_bitstr.o a_utctm.o a_int.o a_octet.o a_print.o \
! 	a_type.o a_bmpstr.o a_set.o a_dup.o a_d2i_fp.o a_i2d_fp.o \
  	a_sign.o a_digest.o a_verify.o \
  	x_algor.o x_val.o x_pubkey.o x_sig.o x_req.o x_attrib.o \
  	x_name.o x_cinf.o x_x509.o x_crl.o x_info.o x_spki.o \
***************
*** 49,55 ****
  	p7_dgst.o p7_s_e.o p7_enc.o p7_lib.o \
  	f_int.o f_string.o i2d_dhp.o i2d_dsap.o d2i_dhp.o d2i_dsap.o n_pkey.o \
  	a_hdr.o x_pkey.o a_bool.o x_exten.o \
! 	asn1_par.o asn1_lib.o $(ERRC).o a_meth.o a_bytes.o
  
  SRC= $(LIBSRC)
  
--- 50,57 ----
  	p7_dgst.o p7_s_e.o p7_enc.o p7_lib.o \
  	f_int.o f_string.o i2d_dhp.o i2d_dsap.o d2i_dhp.o d2i_dsap.o n_pkey.o \
  	a_hdr.o x_pkey.o a_bool.o x_exten.o \
! 	asn1_par.o asn1_lib.o $(ERRC).o a_meth.o a_bytes.o \
! 	p12_bags.o p12_lib.o p12_mac.o p12_pbe.o p12_sbag.o p8_pkey.o
  
  SRC= $(LIBSRC)
  
diff -crN tmp/SSLeay-0.8.1/crypto/asn1/Makefile.ssl SSLeay-0.8.1/crypto/asn1/Makefile.ssl
*** tmp/SSLeay-0.8.1/crypto/asn1/Makefile.ssl	Fri Jul 18 20:18:30 1997
--- SSLeay-0.8.1/crypto/asn1/Makefile.ssl	Tue Nov 18 14:16:07 1997
***************
*** 23,29 ****
  
  LIB=$(TOP)/libcrypto.a
  LIBSRC=	a_object.c a_bitstr.c a_utctm.c a_int.c a_octet.c a_print.c \
! 	a_type.c a_set.c a_dup.c a_d2i_fp.c a_i2d_fp.c \
  	a_sign.c a_digest.c a_verify.c \
  	x_algor.c x_val.c x_pubkey.c x_sig.c x_req.c x_attrib.c \
  	x_name.c x_cinf.c x_x509.c x_crl.c x_info.c x_spki.c \
--- 23,29 ----
  
  LIB=$(TOP)/libcrypto.a
  LIBSRC=	a_object.c a_bitstr.c a_utctm.c a_int.c a_octet.c a_print.c \
! 	a_type.c a_bmpstr.c a_set.c a_dup.c a_d2i_fp.c a_i2d_fp.c \
  	a_sign.c a_digest.c a_verify.c \
  	x_algor.c x_val.c x_pubkey.c x_sig.c x_req.c x_attrib.c \
  	x_name.c x_cinf.c x_x509.c x_crl.c x_info.c x_spki.c \
***************
*** 35,43 ****
  	p7_dgst.c p7_s_e.c p7_enc.c p7_lib.c \
  	f_int.c f_string.c i2d_dhp.c i2d_dsap.c d2i_dhp.c d2i_dsap.c n_pkey.c \
  	a_hdr.c x_pkey.c a_bool.c x_exten.c \
! 	asn1_par.c asn1_lib.c $(ERRC).c a_meth.c a_bytes.c
  LIBOBJ= a_object.o a_bitstr.o a_utctm.o a_int.o a_octet.o a_print.o \
! 	a_type.o a_set.o a_dup.o a_d2i_fp.o a_i2d_fp.o \
  	a_sign.o a_digest.o a_verify.o \
  	x_algor.o x_val.o x_pubkey.o x_sig.o x_req.o x_attrib.o \
  	x_name.o x_cinf.o x_x509.o x_crl.o x_info.o x_spki.o \
--- 35,44 ----
  	p7_dgst.c p7_s_e.c p7_enc.c p7_lib.c \
  	f_int.c f_string.c i2d_dhp.c i2d_dsap.c d2i_dhp.c d2i_dsap.c n_pkey.c \
  	a_hdr.c x_pkey.c a_bool.c x_exten.c \
! 	asn1_par.c asn1_lib.c $(ERRC).c a_meth.c a_bytes.c \
! 	p12_bags.c p12_lib.c p12_mac.c p12_pbe.c p12_sbag.c p8_pkey.c
  LIBOBJ= a_object.o a_bitstr.o a_utctm.o a_int.o a_octet.o a_print.o \
! 	a_type.o a_bmpstr.o a_set.o a_dup.o a_d2i_fp.o a_i2d_fp.o \
  	a_sign.o a_digest.o a_verify.o \
  	x_algor.o x_val.o x_pubkey.o x_sig.o x_req.o x_attrib.o \
  	x_name.o x_cinf.o x_x509.o x_crl.o x_info.o x_spki.o \
***************
*** 49,55 ****
  	p7_dgst.o p7_s_e.o p7_enc.o p7_lib.o \
  	f_int.o f_string.o i2d_dhp.o i2d_dsap.o d2i_dhp.o d2i_dsap.o n_pkey.o \
  	a_hdr.o x_pkey.o a_bool.o x_exten.o \
! 	asn1_par.o asn1_lib.o $(ERRC).o a_meth.o a_bytes.o
  
  SRC= $(LIBSRC)
  
--- 50,57 ----
  	p7_dgst.o p7_s_e.o p7_enc.o p7_lib.o \
  	f_int.o f_string.o i2d_dhp.o i2d_dsap.o d2i_dhp.o d2i_dsap.o n_pkey.o \
  	a_hdr.o x_pkey.o a_bool.o x_exten.o \
! 	asn1_par.o asn1_lib.o $(ERRC).o a_meth.o a_bytes.o \
! 	p12_bags.o p12_lib.o p12_mac.o p12_pbe.o p12_sbag.o p8_pkey.o
  
  SRC= $(LIBSRC)
  
diff -crN tmp/SSLeay-0.8.1/crypto/asn1/a_bmpstr.c SSLeay-0.8.1/crypto/asn1/a_bmpstr.c
*** tmp/SSLeay-0.8.1/crypto/asn1/a_bmpstr.c	Thu Jan  1 01:00:00 1970
--- SSLeay-0.8.1/crypto/asn1/a_bmpstr.c	Tue Nov 18 14:16:07 1997
***************
*** 0 ****
--- 1,90 ----
+ /* crypto/asn1/a_bmpstr.c */
+ /* Copyright (C) 1995-1997 Eric Young (eay@cryptsoft.com)
+  * All rights reserved.
+  *
+  * This package is an SSL implementation written
+  * by Eric Young (eay@cryptsoft.com).
+  * The implementation was written so as to conform with Netscapes SSL.
+  * 
+  * This library is free for commercial and non-commercial use as long as
+  * the following conditions are aheared to.  The following conditions
+  * apply to all code found in this distribution, be it the RC4, RSA,
+  * lhash, DES, etc., code; not just the SSL code.  The SSL documentation
+  * included with this distribution is covered by the same copyright terms
+  * except that the holder is Tim Hudson (tjh@cryptsoft.com).
+  * 
+  * Copyright remains Eric Young's, and as such any Copyright notices in
+  * the code are not to be removed.
+  * If this package is used in a product, Eric Young should be given attribution
+  * as the author of the parts of the library used.
+  * This can be in the form of a textual message at program startup or
+  * in documentation (online or textual) provided with the package.
+  * 
+  * Redistribution and use in source and binary forms, with or without
+  * modification, are permitted provided that the following conditions
+  * are met:
+  * 1. Redistributions of source code must retain the copyright
+  *    notice, this list of conditions and the following disclaimer.
+  * 2. Redistributions in binary form must reproduce the above copyright
+  *    notice, this list of conditions and the following disclaimer in the
+  *    documentation and/or other materials provided with the distribution.
+  * 3. All advertising materials mentioning features or use of this software
+  *    must display the following acknowledgement:
+  *    "This product includes cryptographic software written by
+  *     Eric Young (eay@cryptsoft.com)"
+  *    The word 'cryptographic' can be left out if the rouines from the library
+  *    being used are not cryptographic related :-).
+  * 4. If you include any Windows specific code (or a derivative thereof) from 
+  *    the apps directory (application code) you must include an acknowledgement:
+  *    "This product includes software written by Tim Hudson (tjh@cryptsoft.com)"
+  * 
+  * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND
+  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+  * SUCH DAMAGE.
+  * 
+  * The licence and distribution terms for any publically available version or
+  * derivative of this code cannot be changed.  i.e. this code cannot simply be
+  * copied and put under another distribution licence
+  * [including the GNU Public Licence.]
+  */
+ 
+ #include <stdio.h>
+ #include "cryptlib.h"
+ #include "asn1.h"
+ 
+ /* ASN1err(ASN1_F_D2I_ASN1_BMPSTRING,ASN1_R_EXPECTING_A_BMPSTRING);
+  */
+ 
+ int i2d_ASN1_BMPSTRING(a, pp)
+ ASN1_BMPSTRING *a;
+ unsigned char **pp;
+ 	{
+ 	return(i2d_ASN1_bytes((ASN1_STRING *)a,pp,
+ 		V_ASN1_BMPSTRING,V_ASN1_UNIVERSAL));
+ 	}
+ 
+ ASN1_BMPSTRING *d2i_ASN1_BMPSTRING(a, pp, length)
+ ASN1_BMPSTRING **a;
+ unsigned char **pp;
+ long length;
+ 	{
+ 	ASN1_BMPSTRING *ret=NULL;
+ 
+ 	ret=(ASN1_BMPSTRING *)d2i_ASN1_bytes((ASN1_STRING **)a,
+ 		pp,length,V_ASN1_BMPSTRING,V_ASN1_UNIVERSAL);
+ 	if (ret == NULL)
+ 		{
+ 		ASN1err(ASN1_F_D2I_ASN1_BMPSTRING,ASN1_R_ERROR_STACK);
+ 		return(NULL);
+ 		}
+ 	return(ret);
+ 	}
+ 
diff -crN tmp/SSLeay-0.8.1/crypto/asn1/a_type.c SSLeay-0.8.1/crypto/asn1/a_type.c
*** tmp/SSLeay-0.8.1/crypto/asn1/a_type.c	Fri Jul 18 19:15:59 1997
--- SSLeay-0.8.1/crypto/asn1/a_type.c	Tue Nov 18 14:16:07 1997
***************
*** 115,120 ****
--- 115,123 ----
  	case V_ASN1_UNIVERSALSTRING:
  		r=M_i2d_ASN1_UNIVERSALSTRING(a->value.universalstring,pp);
  		break;
+ 	case V_ASN1_BMPSTRING:
+ 		r=i2d_ASN1_BMPSTRING(a->value.bmpstring,pp);
+ 		break;
  	case V_ASN1_UTCTIME:
  		r=i2d_ASN1_UTCTIME(a->value.utctime,pp);
  		break;
***************
*** 211,216 ****
--- 214,224 ----
  	case V_ASN1_UNIVERSALSTRING:
  		if ((ret->value.universalstring=
  			M_d2i_ASN1_UNIVERSALSTRING(NULL,&p,max-p)) == NULL)
+ 			goto err;
+ 		break;
+ 	case V_ASN1_BMPSTRING:
+ 		if ((ret->value.bmpstring=
+ 			d2i_ASN1_BMPSTRING(NULL,&p,max-p)) == NULL)
  			goto err;
  		break;
  	case V_ASN1_UTCTIME:
diff -crN tmp/SSLeay-0.8.1/crypto/asn1/asn1.h SSLeay-0.8.1/crypto/asn1/asn1.h
*** tmp/SSLeay-0.8.1/crypto/asn1/asn1.h	Fri Jul 18 19:15:59 1997
--- SSLeay-0.8.1/crypto/asn1/asn1.h	Tue Nov 18 14:16:07 1997
***************
*** 103,108 ****
--- 103,109 ----
  #define V_ASN1_VISIBLESTRING		26	/* alias */
  #define V_ASN1_GENERALSTRING		27	/**/
  #define V_ASN1_UNIVERSALSTRING		28	/**/
+ #define V_ASN1_BMPSTRING		30	/**/
  
  /* For use with d2i_ASN1_type_bytes() */
  #define B_ASN1_NUMERICSTRING	0x0001
***************
*** 128,133 ****
--- 129,135 ----
  #define ASN1_UTCTIME		ASN1_STRING
  #define ASN1_GENERALSTRING	ASN1_STRING
  #define ASN1_UNIVERSALSTRING	ASN1_STRING
+ #define ASN1_BMPSTRING		ASN1_STRING
  
  #else
  
***************
*** 187,192 ****
--- 189,201 ----
  	unsigned char *data;
  	} ASN1_UNIVERSALSTRING;
  
+ typedef struct asn1_bmpstring_st
+ 	{
+ 	int length;
+ 	int type;
+ 	unsigned char *data;
+ 	} ASN1_BMPSTRING;
+ 
  typedef struct asn1_utctime_st
  	{
  	int length;
***************
*** 248,253 ****
--- 257,263 ----
  		ASN1_IA5STRING *	ia5string;
  		ASN1_GENERALSTRING *	generalstring;
  		ASN1_UNIVERSALSTRING *	universalstring;
+ 		ASN1_BMPSTRING *	bmpstring;
  		ASN1_UTCTIME *		utctime;
  		/* set and sequence are left complete and still
  		 * contain the set or sequence bytes */
***************
*** 312,317 ****
--- 322,330 ----
  		V_ASN1_OCTET_STRING)
  /* d2i_ASN1_OCTET_STRING() is a function */
  
+ #define ASN1_BMPSTRING_new() (ASN1_BMPSTRING *) ASN1_STRING_new()
+ #define ASN1_BMPSTRING_free(a)	ASN1_STRING_free((ASN1_STRING *)a)
+ 
  #define ASN1_PRINTABLE_new()	ASN1_STRING_type_new(V_ASN1_T61STRING)
  #define ASN1_PRINTABLE_free(a)	ASN1_STRING_free((ASN1_STRING *)a)
  #define M_i2d_ASN1_PRINTABLE(a,pp) i2d_ASN1_bytes((ASN1_STRING *)a,\
***************
*** 423,428 ****
--- 436,445 ----
  ASN1_OCTET_STRING *d2i_ASN1_OCTET_STRING(ASN1_OCTET_STRING **a,
  			unsigned char **pp,long length);
  
+ int		i2d_ASN1_BMPSTRING(ASN1_BMPSTRING *a,unsigned char **pp);
+ ASN1_BMPSTRING *d2i_ASN1_BMPSTRING(ASN1_BMPSTRING **a,
+ 			unsigned char **pp,long length);
+ 
  int i2d_ASN1_PRINTABLE(ASN1_STRING *a,unsigned char **pp);
  ASN1_STRING *d2i_ASN1_PRINTABLE(ASN1_STRING **a,
  	unsigned char **pp, long l);
***************
*** 542,547 ****
--- 559,566 ----
  ASN1_INTEGER *d2i_ASN1_INTEGER();
  int ASN1_UTCTIME_check();
  ASN1_UTCTIME *ASN1_UTCTIME_set();
+ int		i2d_ASN1_BMPSTRING();
+ ASN1_BMPSTRING *d2i_ASN1_BMPSTRING();
  int		i2d_ASN1_OCTET_STRING();
  ASN1_OCTET_STRING *d2i_ASN1_OCTET_STRING();
  int i2d_ASN1_PRINTABLE();
diff -crN tmp/SSLeay-0.8.1/crypto/asn1/asn1_mac.h SSLeay-0.8.1/crypto/asn1/asn1_mac.h
*** tmp/SSLeay-0.8.1/crypto/asn1/asn1_mac.h	Fri Jul 18 19:15:59 1997
--- SSLeay-0.8.1/crypto/asn1/asn1_mac.h	Tue Nov 18 14:16:07 1997
***************
*** 127,132 ****
--- 127,137 ----
  #define M_ASN1_D2I_get_set(r,func) \
  		M_ASN1_D2I_get_imp_set(r,func,V_ASN1_SET,V_ASN1_UNIVERSAL);
  
+ #define M_ASN1_D2I_get_set_opt(r,func) \
+ 	if ((c.slen != 0) && (M_ASN1_next == (V_ASN1_UNIVERSAL| \
+ 		V_ASN1_CONSTRUCTED|V_ASN1_SET)))\
+ 		{ M_ASN1_D2I_get_set(r,func); }
+ 
  #define M_ASN1_D2I_get_IMP_set_opt(b,func,tag) \
  	if ((c.slen != 0) && \
  		(M_ASN1_next == \
***************
*** 221,226 ****
--- 226,235 ----
  #define M_ASN1_I2D_len_SET(a,f) \
  		ret+=i2d_ASN1_SET(a,NULL,f,V_ASN1_SET,V_ASN1_UNIVERSAL);
  
+ #define M_ASN1_I2D_len_SET_opt(a,f) \
+ 		if ((a != NULL) && (sk_num(a) != 0)) \
+ 			M_ASN1_I2D_len_SET(a,f);
+ 
  #define M_ASN1_I2D_len_SEQ(a,f) \
  		ret+=i2d_ASN1_SET(a,NULL,f,V_ASN1_SEQUENCE,V_ASN1_UNIVERSAL);
  
***************
*** 253,267 ****
  #define M_ASN1_I2D_put(a,f)	f(a,&p)
  
  #define M_ASN1_I2D_put_IMP_opt(a,f,t)	\
! 		if (a != NULL) \
! 			{ \
! 			unsigned char *q=p; \
! 			f(a,&p); \
! 			*q=(V_ASN1_CONTEXT_SPECIFIC|t); \
! 			}
  
  #define M_ASN1_I2D_put_SET(a,f) i2d_ASN1_SET(a,&p,f,V_ASN1_SET,\
  			V_ASN1_UNIVERSAL)
  #define M_ASN1_I2D_put_IMP_set(a,f,x) i2d_ASN1_SET(a,&p,f,x,\
  			V_ASN1_CONTEXT_SPECIFIC)
  
--- 262,281 ----
  #define M_ASN1_I2D_put(a,f)	f(a,&p)
  
  #define M_ASN1_I2D_put_IMP_opt(a,f,t)	\
! 	if (a != NULL) \
! 		{ \
! 		unsigned char *q=p; \
! 		f(a,&p); \
! 		*q=(V_ASN1_CONTEXT_SPECIFIC|t|(*q & V_ASN1_CONSTRUCTED)); \
! 		}
  
  #define M_ASN1_I2D_put_SET(a,f) i2d_ASN1_SET(a,&p,f,V_ASN1_SET,\
  			V_ASN1_UNIVERSAL)
+ 
+ #define M_ASN1_I2D_put_SET_opt(a,f) \
+ 		if ((a != NULL) && (sk_num(a) != 0)) \
+ 			M_ASN1_I2D_put_SET(a,f);
+ 
  #define M_ASN1_I2D_put_IMP_set(a,f,x) i2d_ASN1_SET(a,&p,f,x,\
  			V_ASN1_CONTEXT_SPECIFIC)
  
diff -crN tmp/SSLeay-0.8.1/crypto/asn1/asn1_par.c SSLeay-0.8.1/crypto/asn1/asn1_par.c
*** tmp/SSLeay-0.8.1/crypto/asn1/asn1_par.c	Fri Jul 18 19:15:59 1997
--- SSLeay-0.8.1/crypto/asn1/asn1_par.c	Tue Nov 18 14:16:07 1997
***************
*** 144,149 ****
--- 144,151 ----
  		p="GENERALSTRING";
  	else if (tag == V_ASN1_UNIVERSALSTRING)
  		p="UNIVERSALSTRING";
+ 	else if (tag == V_ASN1_BMPSTRING)
+ 		p="BMPSTRING";
  
  	else
  		p2="(unknown)";
***************
*** 184,189 ****
--- 186,192 ----
  	int nl,hl,j,r;
  	ASN1_OBJECT *o=NULL;
  	ASN1_OCTET_STRING *os=NULL;
+ 	ASN1_BMPSTRING *bs=NULL;
  
  	p= *pp;
  	tot=p+length;
***************
*** 298,303 ****
--- 301,343 ----
  						goto end;
  					}
  				BIO_printf(bp,":%d",ii);
+ 				}
+ 			else if (tag == V_ASN1_BMPSTRING)
+ 				{
+ 				int i,printable=1;
+ 
+ 				opp=op;
+ 				bs=d2i_ASN1_BMPSTRING(NULL,&opp,len+hl);
+ 				if (bs != NULL)
+ 					{
+ 					opp=bs->data;
+ 					/* Have we got terminating 00 ? */
+ 					if (!opp[bs->length - 1])
+ 							 bs->length -=2;
+ 					for (i=1; i<bs->length; i+=2)
+ 						{
+ 						if ((	(opp[i] < ' ') &&
+ 							(opp[i] != '\n') &&
+ 							(opp[i] != '\r') &&
+ 							(opp[i] != '\t')) ||
+ 							(opp[i] > '~'))
+ 							{
+ 							printable=0;
+ 							break;
+ 							}
+ 						}
+ 					if (printable && (bs->length > 0))
+ 						{
+ 						if (BIO_write(bp,":",1) <= 0)
+ 							goto end;
+ 						for (i=1; i<bs->length; i+=2)
+ 						if (BIO_write(bp,(char *)opp + i,
+ 							1) <= 0)
+ 							goto end;
+ 						}
+ 					ASN1_BMPSTRING_free(bs);
+ 					bs=NULL;
+ 					}
  				}
  			else if (tag == V_ASN1_OCTET_STRING)
  				{
diff -crN tmp/SSLeay-0.8.1/crypto/asn1/p12_bags.c SSLeay-0.8.1/crypto/asn1/p12_bags.c
*** tmp/SSLeay-0.8.1/crypto/asn1/p12_bags.c	Thu Jan  1 01:00:00 1970
--- SSLeay-0.8.1/crypto/asn1/p12_bags.c	Tue Nov 18 14:16:07 1997
***************
*** 0 ****
--- 1,157 ----
+ /* Copyright Dr Stephen Henson 1997. All rights reserved.
+  * The conditions of use are identical to those of SSLeay except that my
+  * name (in addition to Eric Young or Tim Hudson) must be mentioned
+  * if this software is used in a product and the notice "This product
+  * includes software written by Dr Stephen Henson (shenson@bigfoot.com)"
+  * used.
+  */
+ #include <stdio.h>
+ #include <stdlib.h>
+ #include <objects.h>
+ #include <asn1.h>
+ #include <asn1_mac.h>
+ #include <x509.h>
+ #include <pkcs7.h>
+ #include <err.h>
+ #include <stack.h>
+ #include <crypto.h>
+ #include "pkcs12.h"
+ 
+ /*
+  *ASN1err(ASN1_F_PKCS12_BAGS_NEW,ASN1_R_DECODING_ERROR)
+  *ASN1err(ASN1_F_D2I_PKCS12_BAGS,ASN1_R_DECODING_ERROR)
+  */
+ 
+ int i2d_PKCS12_BAGS(a,pp)
+ PKCS12_BAGS *a;
+ unsigned char **pp;
+ {
+ 	int bagnid, v = 0;
+ 	M_ASN1_I2D_vars(a);
+ 	bagnid = OBJ_obj2nid (a->type);
+ 	M_ASN1_I2D_len (a->type, i2d_ASN1_OBJECT);
+ 	
+ 	switch (bagnid) {
+ 
+ 		case NID_x509Certificate:
+ 			M_ASN1_I2D_len_EXP_opt (a->value.x509cert,
+ 						 i2d_ASN1_OCTET_STRING, 0, v);
+ 		break;
+ 
+ 		case NID_x509Crl:
+ 			M_ASN1_I2D_len_EXP_opt (a->value.x509crl,
+ 						 i2d_ASN1_OCTET_STRING, 0, v);
+ 		break;
+ 
+ 		case NID_sdsiCertificate:
+ 			M_ASN1_I2D_len_EXP_opt (a->value.sdsicert,
+ 						 i2d_ASN1_IA5STRING, 0, v);
+ 		break;
+ 
+ 		default:
+ 			M_ASN1_I2D_len_EXP_opt (a->value.other,
+ 						 i2d_ASN1_TYPE, 0, v);
+ 		break;
+ 	}
+ 
+ 	M_ASN1_I2D_seq_total ();
+ 	
+ 	M_ASN1_I2D_put (a->type, i2d_ASN1_OBJECT);
+ 	
+ 	switch (bagnid) {
+ 
+ 		case NID_x509Certificate:
+ 			M_ASN1_I2D_put_EXP_opt (a->value.x509cert,
+ 						 i2d_ASN1_OCTET_STRING, 0, v);
+ 		break;
+ 
+ 		case NID_x509Crl:
+ 			M_ASN1_I2D_put_EXP_opt (a->value.x509crl,
+ 						 i2d_ASN1_OCTET_STRING, 0, v);
+ 		break;
+ 
+ 		case NID_sdsiCertificate:
+ 			M_ASN1_I2D_put_EXP_opt (a->value.sdsicert,
+ 						 i2d_ASN1_IA5STRING, 0, v);
+ 		break;
+ 
+ 		default:
+ 		M_ASN1_I2D_put_EXP_opt (a->value.other, i2d_ASN1_TYPE, 0, v);
+ 		break;
+ 	}
+ 	M_ASN1_I2D_finish();
+ }
+ 
+ PKCS12_BAGS *PKCS12_BAGS_new()
+ {
+ 	PKCS12_BAGS *ret=NULL;
+ 	M_ASN1_New_Malloc(ret, PKCS12_BAGS);
+ 	ret->type=NULL;
+ 	ret->value.other=NULL;
+ 	return (ret);
+ 	M_ASN1_New_Error(ASN1_F_PKCS12_BAGS_NEW);
+ }
+ 
+ PKCS12_BAGS *d2i_PKCS12_BAGS(a,pp,length)
+ PKCS12_BAGS **a;
+ unsigned char **pp;
+ long length;
+ {
+ 	int bagnid;
+ 	M_ASN1_D2I_vars(a,PKCS12_BAGS *,PKCS12_BAGS_new);
+ 	M_ASN1_D2I_Init();
+ 	M_ASN1_D2I_start_sequence();
+ 	M_ASN1_D2I_get (ret->type, d2i_ASN1_OBJECT);
+ 	bagnid = OBJ_obj2nid (ret->type);
+ 	switch (bagnid) {
+ 
+ 		case NID_x509Certificate:
+ 			M_ASN1_D2I_get_EXP_opt (ret->value.x509cert,
+ 						 d2i_ASN1_OCTET_STRING, 0);
+ 		break;
+ 
+ 		case NID_x509Crl:
+ 			M_ASN1_D2I_get_EXP_opt (ret->value.x509crl,
+ 						 d2i_ASN1_OCTET_STRING, 0);
+ 		break;
+ 
+ 		case NID_sdsiCertificate:
+ 			M_ASN1_D2I_get_EXP_opt (ret->value.sdsicert,
+ 						 d2i_ASN1_IA5STRING, 0);
+ 		break;
+ 
+ 		default:
+ 			M_ASN1_D2I_get_EXP_opt (ret->value.other,
+ 							 d2i_ASN1_TYPE, 0);
+ 		break;
+ 	}
+ 
+ 	M_ASN1_D2I_Finish(a, PKCS12_BAGS_free, ASN1_F_D2I_PKCS12_BAGS);
+ }
+ 
+ void PKCS12_BAGS_free (a)
+ PKCS12_BAGS *a;
+ {
+ 	if (a == NULL) return;
+ 	switch (OBJ_obj2nid (a->type)) {
+ 
+ 		case NID_x509Certificate:
+ 			ASN1_OCTET_STRING_free (a->value.x509cert);
+ 		break;
+ 
+ 		case NID_x509Crl:
+ 			ASN1_OCTET_STRING_free (a->value.x509crl);
+ 		break;
+ 
+ 		case NID_sdsiCertificate:
+ 			ASN1_IA5STRING_free (a->value.sdsicert);
+ 		break;
+ 
+ 		default:
+ 			ASN1_TYPE_free (a->value.other);
+ 		break;
+ 	}
+ 
+ 	ASN1_OBJECT_free (a->type);
+ 	Free ((char *)a);
+ }
diff -crN tmp/SSLeay-0.8.1/crypto/asn1/p12_lib.c SSLeay-0.8.1/crypto/asn1/p12_lib.c
*** tmp/SSLeay-0.8.1/crypto/asn1/p12_lib.c	Thu Jan  1 01:00:00 1970
--- SSLeay-0.8.1/crypto/asn1/p12_lib.c	Tue Nov 18 14:16:07 1997
***************
*** 0 ****
--- 1,77 ----
+ /* Copyright Dr Stephen Henson 1997. All rights reserved.
+  * The conditions of use are identical to those of SSLeay except that my
+  * name (in addition to Eric Young or Tim Hudson) must be mentioned
+  * if this software is used in a product and the notice "This product
+  * includes software written by Dr Stephen Henson (shenson@bigfoot.com)"
+  * used.
+  */
+ #include <stdio.h>
+ #include <stdlib.h>
+ #include <objects.h>
+ #include <asn1.h>
+ #include <asn1_mac.h>
+ #include <x509.h>
+ #include <pkcs7.h>
+ #include <err.h>
+ #include <stack.h>
+ #include <crypto.h>
+ #include "pkcs12.h"
+ 
+ /*
+  *ASN1err(ASN1_F_PKCS12_NEW,ASN1_R_DECODING_ERROR)
+  *ASN1err(ASN1_F_D2I_PKCS12,ASN1_R_DECODING_ERROR)
+  */
+ 
+ int i2d_PKCS12(a,pp)
+ PKCS12 *a;
+ unsigned char **pp;
+ {
+ 	M_ASN1_I2D_vars(a);
+ 
+ 	M_ASN1_I2D_len (a->version, i2d_ASN1_INTEGER);
+ 	M_ASN1_I2D_len (a->authsafes, i2d_PKCS7);
+ 	M_ASN1_I2D_len (a->mac, i2d_PKCS12_MAC_DATA);
+ 
+ 	M_ASN1_I2D_seq_total();
+ 
+ 	M_ASN1_I2D_put (a->version, i2d_ASN1_INTEGER);
+ 	M_ASN1_I2D_put (a->authsafes, i2d_PKCS7);
+ 	M_ASN1_I2D_put (a->mac, i2d_PKCS12_MAC_DATA);
+ 
+ 	M_ASN1_I2D_finish();
+ }
+ 
+ PKCS12 *d2i_PKCS12(a,pp,length)
+ PKCS12 **a;
+ unsigned char **pp;
+ long length;
+ {
+ 	M_ASN1_D2I_vars(a,PKCS12 *,PKCS12_new);
+ 	M_ASN1_D2I_Init();
+ 	M_ASN1_D2I_start_sequence();
+ 	M_ASN1_D2I_get (ret->version, d2i_ASN1_INTEGER);
+ 	M_ASN1_D2I_get (ret->authsafes, d2i_PKCS7);
+ 	M_ASN1_D2I_get_opt (ret->mac, d2i_PKCS12_MAC_DATA, V_ASN1_SEQUENCE);
+ 	M_ASN1_D2I_Finish(a, PKCS12_free, ASN1_F_D2I_PKCS12);
+ }
+ 
+ PKCS12 *PKCS12_new()
+ {
+ 	PKCS12 *ret=NULL;
+ 	M_ASN1_New_Malloc(ret, PKCS12);
+ 	ret->version=NULL;
+ 	ret->mac=NULL;
+ 	ret->authsafes=NULL;
+ 	return (ret);
+ 	M_ASN1_New_Error(ASN1_F_PKCS12_NEW);
+ }
+ 
+ void PKCS12_free (a)
+ PKCS12 *a;
+ {
+ 	if (a == NULL) return;
+ 	ASN1_INTEGER_free (a->version);
+ 	PKCS12_MAC_DATA_free (a->mac);
+ 	PKCS7_free (a->authsafes);
+ 	Free ((char *)a);
+ }
diff -crN tmp/SSLeay-0.8.1/crypto/asn1/p12_mac.c SSLeay-0.8.1/crypto/asn1/p12_mac.c
*** tmp/SSLeay-0.8.1/crypto/asn1/p12_mac.c	Thu Jan  1 01:00:00 1970
--- SSLeay-0.8.1/crypto/asn1/p12_mac.c	Tue Nov 18 14:16:07 1997
***************
*** 0 ****
--- 1,74 ----
+ /* Copyright Dr Stephen Henson 1997. All rights reserved.
+  * The conditions of use are identical to those of SSLeay except that my
+  * name (in addition to Eric Young or Tim Hudson) must be mentioned
+  * if this software is used in a product and the notice "This product
+  * includes software written by Dr Stephen Henson (shenson@bigfoot.com)"
+  * used.
+  */
+ #include <stdio.h>
+ #include <stdlib.h>
+ #include <objects.h>
+ #include <asn1.h>
+ #include <asn1_mac.h>
+ #include <x509.h>
+ #include <pkcs7.h>
+ #include <err.h>
+ #include <stack.h>
+ #include <crypto.h>
+ #include "pkcs12.h"
+ /*
+  *ASN1err(ASN1_F_PKCS12_MAC_DATA_NEW,ASN1_R_DECODING_ERROR)
+  *ASN1err(ASN1_F_D2I_PKCS12_MAC_DATA,ASN1_R_DECODING_ERROR)
+  */
+ 
+ int i2d_PKCS12_MAC_DATA(a,pp)
+ PKCS12_MAC_DATA *a;
+ unsigned char **pp;
+ {
+ 	M_ASN1_I2D_vars(a);
+ 	M_ASN1_I2D_len (a->dinfo, i2d_X509_SIG);
+ 	M_ASN1_I2D_len (a->salt, i2d_ASN1_OCTET_STRING);
+ 	M_ASN1_I2D_len (a->iter, i2d_ASN1_INTEGER);
+ 
+ 	M_ASN1_I2D_seq_total();
+ 
+ 	M_ASN1_I2D_put (a->dinfo, i2d_X509_SIG);
+ 	M_ASN1_I2D_put (a->salt, i2d_ASN1_OCTET_STRING);
+ 	M_ASN1_I2D_put (a->iter, i2d_ASN1_INTEGER);
+ 	M_ASN1_I2D_finish();
+ }
+ 
+ PKCS12_MAC_DATA *PKCS12_MAC_DATA_new()
+ {
+ 	PKCS12_MAC_DATA *ret=NULL;
+ 	M_ASN1_New_Malloc(ret, PKCS12_MAC_DATA);
+ 	ret->dinfo = X509_SIG_new();
+ 	ret->salt = ASN1_OCTET_STRING_new();
+ 	ret->iter = NULL;
+ 	return (ret);
+ 	M_ASN1_New_Error(ASN1_F_PKCS12_MAC_DATA_NEW);
+ }
+ 
+ PKCS12_MAC_DATA *d2i_PKCS12_MAC_DATA(a,pp,length)
+ PKCS12_MAC_DATA **a;
+ unsigned char **pp;
+ long length;
+ {
+ 	M_ASN1_D2I_vars(a,PKCS12_MAC_DATA *,PKCS12_MAC_DATA_new);
+ 	M_ASN1_D2I_Init();
+ 	M_ASN1_D2I_start_sequence();
+ 	M_ASN1_D2I_get (ret->dinfo, d2i_X509_SIG);
+ 	M_ASN1_D2I_get (ret->salt, d2i_ASN1_OCTET_STRING);
+ 	M_ASN1_D2I_get_opt (ret->iter, d2i_ASN1_INTEGER, V_ASN1_INTEGER);
+ 	M_ASN1_D2I_Finish(a, PKCS12_MAC_DATA_free, ASN1_F_D2I_PKCS12_MAC_DATA);
+ }
+ 
+ void PKCS12_MAC_DATA_free (a)
+ PKCS12_MAC_DATA *a;
+ {
+ 	if (a == NULL) return;
+ 	X509_SIG_free (a->dinfo);
+ 	ASN1_OCTET_STRING_free (a->salt);
+ 	ASN1_INTEGER_free (a->iter);
+ 	Free ((char *)a);
+ }
diff -crN tmp/SSLeay-0.8.1/crypto/asn1/p12_pbe.c SSLeay-0.8.1/crypto/asn1/p12_pbe.c
*** tmp/SSLeay-0.8.1/crypto/asn1/p12_pbe.c	Thu Jan  1 01:00:00 1970
--- SSLeay-0.8.1/crypto/asn1/p12_pbe.c	Tue Nov 18 14:16:07 1997
***************
*** 0 ****
--- 1,67 ----
+ /* Copyright Dr Stephen Henson 1997. All rights reserved.
+  * The conditions of use are identical to those of SSLeay except that my
+  * name (in addition to Eric Young or Tim Hudson) must be mentioned
+  * if this software is used in a product and the notice "This product
+  * includes software written by Dr Stephen Henson (shenson@bigfoot.com)"
+  * used.
+  */
+ #include <stdio.h>
+ #include <stdlib.h>
+ #include <asn1.h>
+ #include <asn1_mac.h>
+ #include <err.h>
+ #include <crypto.h>
+ #include "pkcs12.h"
+ 
+ /*
+  *ASN1err(ASN1_F_PBEPARAM_NEW,ASN1_R_DECODING_ERROR)
+  *ASN1err(ASN1_F_D2I_PBEPARAM,ASN1_R_DECODING_ERROR)
+  */
+ 
+ int i2d_PBEPARAM(a, pp)
+ PBEPARAM *a;
+ unsigned char **pp;
+ {
+ 	M_ASN1_I2D_vars(a);
+ 	M_ASN1_I2D_len (a->salt, i2d_ASN1_OCTET_STRING);
+ 	M_ASN1_I2D_len (a->iter, i2d_ASN1_INTEGER);
+ 
+ 	M_ASN1_I2D_seq_total ();
+ 
+ 	M_ASN1_I2D_put (a->salt, i2d_ASN1_OCTET_STRING);
+ 	M_ASN1_I2D_put (a->iter, i2d_ASN1_INTEGER);
+ 	M_ASN1_I2D_finish();
+ }
+ 
+ PBEPARAM *PBEPARAM_new()
+ {
+ 	PBEPARAM *ret=NULL;
+ 	M_ASN1_New_Malloc(ret, PBEPARAM);
+ 	ret->salt = NULL;
+ 	M_ASN1_New(ret->iter,ASN1_INTEGER_new);
+ 	M_ASN1_New(ret->salt,ASN1_OCTET_STRING_new);
+ 	return (ret);
+ 	M_ASN1_New_Error(ASN1_F_PBEPARAM_NEW);
+ }
+ 
+ PBEPARAM *d2i_PBEPARAM(a,pp,length)
+ PBEPARAM **a;
+ unsigned char **pp;
+ long length;
+ {
+ 	M_ASN1_D2I_vars(a,PBEPARAM *,PBEPARAM_new);
+ 	M_ASN1_D2I_Init();
+ 	M_ASN1_D2I_start_sequence();
+ 	M_ASN1_D2I_get (ret->salt, d2i_ASN1_OCTET_STRING);
+ 	M_ASN1_D2I_get (ret->iter, d2i_ASN1_INTEGER);
+ 	M_ASN1_D2I_Finish(a, PBEPARAM_free, ASN1_F_D2I_PBEPARAM);
+ }
+ 
+ void PBEPARAM_free (a)
+ PBEPARAM *a;
+ {
+ 	if(a==NULL) return;
+ 	ASN1_OCTET_STRING_free (a->salt);
+ 	ASN1_INTEGER_free (a->iter);
+ 	Free ((char *)a);
+ }
diff -crN tmp/SSLeay-0.8.1/crypto/asn1/p12_sbag.c SSLeay-0.8.1/crypto/asn1/p12_sbag.c
*** tmp/SSLeay-0.8.1/crypto/asn1/p12_sbag.c	Thu Jan  1 01:00:00 1970
--- SSLeay-0.8.1/crypto/asn1/p12_sbag.c	Tue Nov 18 14:16:07 1997
***************
*** 0 ****
--- 1,190 ----
+ /* Copyright Dr Stephen Henson 1997. All rights reserved.
+  * The conditions of use are identical to those of SSLeay except that my
+  * name (in addition to Eric Young or Tim Hudson) must be mentioned
+  * if this software is used in a product and the notice "This product
+  * includes software written by Dr Stephen Henson (shenson@bigfoot.com)"
+  * used.
+  */
+ #include <stdio.h>
+ #include <stdlib.h>
+ #include <objects.h>
+ #include <asn1.h>
+ #include <asn1_mac.h>
+ #include <x509.h>
+ #include <pkcs7.h>
+ #include <err.h>
+ #include <stack.h>
+ #include <crypto.h>
+ #include "pkcs12.h"
+ 
+ /*
+  *ASN1err(ASN1_F_PKCS12_SAFEBAG_NEW,ASN1_R_DECODING_ERROR)
+  *ASN1err(ASN1_F_D2I_PKCS12_SAFEBAG,ASN1_R_DECODING_ERROR)
+  */
+ 
+ int i2d_PKCS12_SAFEBAG(a,pp)
+ PKCS12_SAFEBAG *a;
+ unsigned char **pp;
+ {
+ 	int bagnid, v = 0;
+ 	M_ASN1_I2D_vars(a);
+ 	bagnid = OBJ_obj2nid (a->type);
+ 	M_ASN1_I2D_len (a->type, i2d_ASN1_OBJECT);
+ 	
+ 	switch (bagnid) {
+ 
+ 		case NID_keyBag:
+ 			M_ASN1_I2D_len_EXP_opt (a->value.keybag,
+ 						 i2d_PKCS8_PRIV_KEY_INFO, 0, v);
+ 		break;
+ 
+ 		case NID_pkcs8ShroudedKeyBag:
+ 			M_ASN1_I2D_len_EXP_opt (a->value.shkeybag,
+ 						 i2d_X509_SIG, 0, v);
+ 		break;
+ 
+ 		case NID_safeContentsBag:
+ 			M_ASN1_I2D_len_EXP_set_opt (a->value.safes,
+ 				 i2d_PKCS12_SAFEBAG, 0, V_ASN1_SEQUENCE, v);
+ 		break;
+ 
+ 		case NID_certBag:
+ 		case NID_crlBag:
+ 		case NID_secretBag:
+ 			M_ASN1_I2D_len_EXP_opt (a->value.bag,
+ 						 i2d_PKCS12_BAGS, 0, v);
+ 		break;
+ 
+ 		default:
+ 			M_ASN1_I2D_len_EXP_opt (a->value.other,
+ 						 i2d_ASN1_TYPE, 0, v);
+ 		break;
+ 	}
+ 
+ 	M_ASN1_I2D_len_SET_opt (a->attrib, i2d_X509_ATTRIBUTE);
+ 
+ 	M_ASN1_I2D_seq_total ();
+ 	
+ 	M_ASN1_I2D_put (a->type, i2d_ASN1_OBJECT);
+ 
+ 	switch (bagnid) {
+ 
+ 		case NID_keyBag:
+ 			M_ASN1_I2D_put_EXP_opt (a->value.keybag,
+ 						 i2d_PKCS8_PRIV_KEY_INFO, 0, v);
+ 		break;
+ 
+ 		case NID_pkcs8ShroudedKeyBag:
+ 			M_ASN1_I2D_put_EXP_opt (a->value.shkeybag,
+ 						 i2d_X509_SIG, 0, v);
+ 		break;
+ 
+ 		case NID_safeContentsBag:
+ 			M_ASN1_I2D_put_EXP_set_opt (a->value.safes,
+ 				 i2d_PKCS12_SAFEBAG, 0, V_ASN1_SEQUENCE, v);
+ 		break;
+ 
+ 		case NID_certBag:
+ 		case NID_crlBag:
+ 		case NID_secretBag:
+ 			M_ASN1_I2D_put_EXP_opt (a->value.bag,
+ 						 i2d_PKCS12_BAGS, 0, v);
+ 		break;
+ 
+ 		default:
+ 			M_ASN1_I2D_put_EXP_opt (a->value.other,
+ 						 i2d_ASN1_TYPE, 0, v);
+ 		break;
+ 	}
+ 
+ 	M_ASN1_I2D_put_SET_opt (a->attrib, i2d_X509_ATTRIBUTE);
+ 
+ 	M_ASN1_I2D_finish();
+ }
+ 
+ PKCS12_SAFEBAG *PKCS12_SAFEBAG_new()
+ {
+ 	PKCS12_SAFEBAG *ret=NULL;
+ 	M_ASN1_New_Malloc(ret, PKCS12_SAFEBAG);
+ 	ret->type=NULL;
+ 	ret->value.other=NULL;
+ 	ret->attrib=NULL;
+ 	ret->rest=NULL;
+ 	return (ret);
+ 	M_ASN1_New_Error(ASN1_F_PKCS12_SAFEBAG_NEW);
+ }
+ 
+ PKCS12_SAFEBAG *d2i_PKCS12_SAFEBAG(a,pp,length)
+ PKCS12_SAFEBAG **a;
+ unsigned char **pp;
+ long length;
+ {
+ 	int bagnid;
+ 	M_ASN1_D2I_vars(a,PKCS12_SAFEBAG *,PKCS12_SAFEBAG_new);
+ 	M_ASN1_D2I_Init();
+ 	M_ASN1_D2I_start_sequence();
+ 	M_ASN1_D2I_get (ret->type, d2i_ASN1_OBJECT);
+ 	bagnid = OBJ_obj2nid (ret->type);
+ 
+ 	switch (bagnid) {
+ 
+ 		case NID_keyBag:
+ 			M_ASN1_D2I_get_EXP_opt (ret->value.keybag,
+ 						 d2i_PKCS8_PRIV_KEY_INFO, 0);
+ 		break;
+ 
+ 		case NID_pkcs8ShroudedKeyBag:
+ 			M_ASN1_D2I_get_EXP_opt (ret->value.shkeybag,
+ 						 	d2i_X509_SIG, 0);
+ 		break;
+ 
+ 		case NID_safeContentsBag:
+ 			M_ASN1_D2I_get_EXP_set_opt (ret->value.safes,
+ 					d2i_PKCS12_SAFEBAG, 0, V_ASN1_SEQUENCE);
+ 		break;
+ 
+ 		case NID_certBag:
+ 		case NID_crlBag:
+ 		case NID_secretBag:
+ 			M_ASN1_D2I_get_EXP_opt (ret->value.bag,
+ 							 d2i_PKCS12_BAGS, 0);
+ 		break;
+ 
+ 		default:
+ 			M_ASN1_D2I_get_EXP_opt (ret->value.other,
+ 							 d2i_ASN1_TYPE, 0);
+ 		break;
+ 	}
+ 	M_ASN1_D2I_get_set_opt (ret->attrib, d2i_X509_ATTRIBUTE);
+ 	M_ASN1_D2I_Finish(a, PKCS12_SAFEBAG_free, ASN1_F_D2I_PKCS12_SAFEBAG);
+ }
+ 
+ void PKCS12_SAFEBAG_free (a)
+ PKCS12_SAFEBAG *a;
+ {
+ 	if (a == NULL) return;
+ 	switch (OBJ_obj2nid (a->type)) {
+ 
+ 		case NID_keyBag:
+ 			PKCS8_PRIV_KEY_INFO_free (a->value.keybag);
+ 		break;
+ 
+ 		case NID_pkcs8ShroudedKeyBag:
+ 			X509_SIG_free (a->value.shkeybag);
+ 		break;
+ 
+ 		case NID_certBag:
+ 		case NID_crlBag:
+ 		case NID_secretBag:
+ 			PKCS12_BAGS_free (a->value.bag);
+ 		break;
+ 
+ 		default:
+ 			ASN1_TYPE_free (a->value.other);
+ 		break;
+ 	}
+ 
+ 	ASN1_OBJECT_free (a->type);
+ 	sk_pop_free (a->attrib, X509_ATTRIBUTE_free);
+ 	Free ((char *)a);
+ }
diff -crN tmp/SSLeay-0.8.1/crypto/asn1/p8_pkey.c SSLeay-0.8.1/crypto/asn1/p8_pkey.c
*** tmp/SSLeay-0.8.1/crypto/asn1/p8_pkey.c	Thu Jan  1 01:00:00 1970
--- SSLeay-0.8.1/crypto/asn1/p8_pkey.c	Tue Nov 18 14:16:07 1997
***************
*** 0 ****
--- 1,83 ----
+ /* Copyright Dr Stephen Henson 1997. All rights reserved.
+  * The conditions of use are identical to those of SSLeay except that my
+  * name (in addition to Eric Young or Tim Hudson) must be mentioned
+  * if this software is used in a product and the notice "This product
+  * includes software written by Dr Stephen Henson (shenson@bigfoot.com)"
+  * used.
+  */
+ #include <stdio.h>
+ #include <stdlib.h>
+ #include <objects.h>
+ #include <asn1.h>
+ #include <asn1_mac.h>
+ #include <x509.h>
+ #include <pkcs7.h>
+ #include <err.h>
+ #include <stack.h>
+ #include <crypto.h>
+ #include "pkcs12.h"
+ 
+ /*
+  *ASN1err(ASN1_F_PKCS8_PRIV_KEY_INFO_NEW,ASN1_R_DECODING_ERROR)
+  *ASN1err(ASN1_F_D2I_PKCS8_PRIV_KEY_INFO,ASN1_R_DECODING_ERROR)
+  */
+ 
+ int i2d_PKCS8_PRIV_KEY_INFO (a,pp)
+ PKCS8_PRIV_KEY_INFO *a;
+ unsigned char **pp;
+ {
+ 
+ 	M_ASN1_I2D_vars(a);
+ 
+ 	M_ASN1_I2D_len (a->version, i2d_ASN1_INTEGER);
+ 	M_ASN1_I2D_len (a->pkeyalg, i2d_X509_ALGOR);
+ 	M_ASN1_I2D_len (a->pkey, i2d_ASN1_OCTET_STRING);
+ 	M_ASN1_I2D_len_IMP_set_opt (a->attributes, i2d_ASN1_TYPE, 0);
+ 	
+ 	M_ASN1_I2D_seq_total ();
+ 
+ 	M_ASN1_I2D_put (a->version, i2d_ASN1_INTEGER);
+ 	M_ASN1_I2D_put (a->pkeyalg, i2d_X509_ALGOR);
+ 	M_ASN1_I2D_put (a->pkey, i2d_ASN1_OCTET_STRING);
+ 	M_ASN1_I2D_put_IMP_set_opt (a->attributes, i2d_ASN1_TYPE, 0);
+ 
+ 	M_ASN1_I2D_finish();
+ }
+ 
+ PKCS8_PRIV_KEY_INFO *PKCS8_PRIV_KEY_INFO_new()
+ {
+ 	PKCS8_PRIV_KEY_INFO *ret=NULL;
+ 	M_ASN1_New_Malloc(ret, PKCS8_PRIV_KEY_INFO);
+ 	M_ASN1_New (ret->version, ASN1_INTEGER_new);
+ 	M_ASN1_New (ret->pkeyalg, X509_ALGOR_new);
+ 	M_ASN1_New (ret->pkey, ASN1_OCTET_STRING_new);
+ 	ret->attributes = NULL;
+ 	return (ret);
+ 	M_ASN1_New_Error(ASN1_F_PKCS8_PRIV_KEY_INFO_NEW);
+ }
+ 
+ PKCS8_PRIV_KEY_INFO *d2i_PKCS8_PRIV_KEY_INFO(a,pp,length)
+ PKCS8_PRIV_KEY_INFO **a;
+ unsigned char **pp;
+ long length;
+ {
+ 	M_ASN1_D2I_vars(a,PKCS8_PRIV_KEY_INFO *,PKCS8_PRIV_KEY_INFO_new);
+ 	M_ASN1_D2I_Init();
+ 	M_ASN1_D2I_start_sequence();
+ 	M_ASN1_D2I_get (ret->version, d2i_ASN1_INTEGER);
+ 	M_ASN1_D2I_get (ret->pkeyalg, d2i_X509_ALGOR);
+ 	M_ASN1_D2I_get (ret->pkey, d2i_ASN1_OCTET_STRING);
+ 	M_ASN1_D2I_get_IMP_set_opt (ret->attributes, d2i_ASN1_TYPE, 0);
+ 	M_ASN1_D2I_Finish(a, PKCS8_PRIV_KEY_INFO_free, ASN1_F_D2I_PKCS8_PRIV_KEY_INFO);
+ }
+ 
+ void PKCS8_PRIV_KEY_INFO_free (a)
+ PKCS8_PRIV_KEY_INFO *a;
+ {
+ 	if (a == NULL) return;
+ 	ASN1_INTEGER_free (a->version);
+ 	X509_ALGOR_free (a->pkeyalg);
+ 	ASN1_OCTET_STRING_free (a->pkey);
+ 	sk_pop_free (a->attributes, ASN1_TYPE_free);
+ 	Free ((char *)a);
+ }
diff -crN tmp/SSLeay-0.8.1/crypto/err/err.h SSLeay-0.8.1/crypto/err/err.h
*** tmp/SSLeay-0.8.1/crypto/err/err.h	Fri Jul 18 19:16:01 1997
--- SSLeay-0.8.1/crypto/err/err.h	Tue Nov 18 14:16:07 1997
***************
*** 110,115 ****
--- 110,116 ----
  #define ERR_LIB_PROXY		31
  #define ERR_LIB_BIO		32
  #define ERR_LIB_PKCS7		33
+ #define ERR_LIB_PKCS12		34
  
  #define ERR_LIB_USER		128
  
***************
*** 134,139 ****
--- 135,141 ----
  #define RSAREFerr(f,r)	ERR_PUT_error(ERR_LIB_RSAREF,(f),(r),ERR_file_name,__LINE__)
  #define PROXYerr(f,r)	ERR_PUT_error(ERR_LIB_PROXY,(f),(r),ERR_file_name,__LINE__)
  #define PKCS7err(f,r)	ERR_PUT_error(ERR_LIB_PKCS7,(f),(r),ERR_file_name,__LINE__)
+ #define PKCS12err(f,r)	ERR_PUT_error(ERR_LIB_PKCS12,(f),(r),ERR_file_name,__LINE__)
  
  /* Borland C seems too stupid to be able to shift and do longs in
   * the pre-processor :-( */
***************
*** 179,184 ****
--- 181,187 ----
  #define ERR_R_PROXY_LIB	ERR_LIB_PROXY
  #define ERR_R_BIO_LIB	ERR_LIB_BIO
  #define ERR_R_PKCS7_LIB	ERR_LIB_PKCS7
+ #define ERR_R_PKCS12_LIB ERR_LIB_PKCS12
  
  /* fatal error */
  #define	ERR_R_MALLOC_FAILURE			(1|ERR_R_FATAL)
diff -crN tmp/SSLeay-0.8.1/crypto/err/err_code.pl SSLeay-0.8.1/crypto/err/err_code.pl
*** tmp/SSLeay-0.8.1/crypto/err/err_code.pl	Fri Jul 18 19:16:01 1997
--- SSLeay-0.8.1/crypto/err/err_code.pl	Tue Nov 18 14:16:07 1997
***************
*** 17,22 ****
--- 17,23 ----
  	"CONF",	"conf/conf.err",
  	"PROXY","proxy/proxy.err",
  	"PKCS7","pkcs7/pkcs7.err",
+ 	"PKCS12","pkcs12/pkcs12.err",
  	"RSAREF","../rsaref/rsaref.err",
  	"SSL",	"../ssl/ssl.err",
  	"SSL2",	"../ssl/ssl2.err",
diff -crN tmp/SSLeay-0.8.1/crypto/evp/e_cbc_r2.c SSLeay-0.8.1/crypto/evp/e_cbc_r2.c
*** tmp/SSLeay-0.8.1/crypto/evp/e_cbc_r2.c	Fri Jul 18 19:16:01 1997
--- SSLeay-0.8.1/crypto/evp/e_cbc_r2.c	Tue Nov 18 14:16:07 1997
***************
*** 81,91 ****
--- 81,104 ----
  	rc2_cbc_cipher,
  	};
  
+ static EVP_CIPHER r2_40_cbc_cipher=
+ 	{
+ 	NID_rc2_cbc,
+ 	8,5,8,
+ 	rc2_cbc_init_key,
+ 	rc2_cbc_cipher,
+ 	};
+ 
  EVP_CIPHER *EVP_rc2_cbc()
  	{
  	return(&r2_cbc_cipher);
  	}
  	
+ EVP_CIPHER *EVP_rc2_40_cbc()
+ 	{
+ 	return(&r2_40_cbc_cipher);
+ 	}
+ 
  static void rc2_cbc_init_key(ctx,key,iv,enc)
  EVP_CIPHER_CTX *ctx;
  unsigned char *key;
***************
*** 96,103 ****
  		memcpy(&(ctx->c.rc2_cbc.oiv[0]),iv,8);
  	memcpy(&(ctx->c.rc2_cbc.iv[0]),&(ctx->c.rc2_cbc.oiv[0]),8);
  	if (key != NULL)
! 		RC2_set_key(&(ctx->c.rc2_cbc.ks),EVP_RC2_KEY_SIZE,key,
! 			EVP_RC2_KEY_SIZE*8);
  	}
  
  static void rc2_cbc_cipher(ctx,out,in,inl)
--- 109,116 ----
  		memcpy(&(ctx->c.rc2_cbc.oiv[0]),iv,8);
  	memcpy(&(ctx->c.rc2_cbc.iv[0]),&(ctx->c.rc2_cbc.oiv[0]),8);
  	if (key != NULL)
! 	    RC2_set_key(&(ctx->c.rc2_cbc.ks),EVP_CIPHER_CTX_key_length(ctx),
! 					key,EVP_CIPHER_CTX_key_length(ctx)*8);
  	}
  
  static void rc2_cbc_cipher(ctx,out,in,inl)
diff -crN tmp/SSLeay-0.8.1/crypto/evp/e_rc4.c SSLeay-0.8.1/crypto/evp/e_rc4.c
*** tmp/SSLeay-0.8.1/crypto/evp/e_rc4.c	Fri Jul 18 19:16:02 1997
--- SSLeay-0.8.1/crypto/evp/e_rc4.c	Tue Nov 18 14:16:07 1997
***************
*** 81,89 ****
--- 81,102 ----
  	rc4_cipher,
  	};
  
+ static EVP_CIPHER r4_40_cipher=
+ 	{
+ 	NID_rc4,
+ 	1,5,0,
+ 	rc4_init_key,
+ 	rc4_cipher,
+ 	};
+ 
  EVP_CIPHER *EVP_rc4()
  	{
  	return(&r4_cipher);
+ 	}
+ 
+ EVP_CIPHER *EVP_rc4_40()
+ 	{
+ 	return(&r4_40_cipher);
  	}
  
  static void rc4_init_key(ctx,key,iv,enc)
diff -crN tmp/SSLeay-0.8.1/crypto/evp/evp.h SSLeay-0.8.1/crypto/evp/evp.h
*** tmp/SSLeay-0.8.1/crypto/evp/evp.h	Fri Jul 18 19:16:02 1997
--- SSLeay-0.8.1/crypto/evp/evp.h	Tue Nov 18 14:16:07 1997
***************
*** 505,516 ****
--- 505,518 ----
  EVP_CIPHER *EVP_des_ede3_cbc(void);
  EVP_CIPHER *EVP_desx_cbc(void);
  EVP_CIPHER *EVP_rc4(void);
+ EVP_CIPHER *EVP_rc4_40(void);
  EVP_CIPHER *EVP_idea_ecb(void);
  EVP_CIPHER *EVP_idea_cfb(void);
  EVP_CIPHER *EVP_idea_ofb(void);
  EVP_CIPHER *EVP_idea_cbc(void);
  EVP_CIPHER *EVP_rc2_ecb(void);
  EVP_CIPHER *EVP_rc2_cbc(void);
+ EVP_CIPHER *EVP_rc2_40_cbc(void);
  EVP_CIPHER *EVP_rc2_cfb(void);
  EVP_CIPHER *EVP_rc2_ofb(void);
  EVP_CIPHER *EVP_bf_ecb(void);
***************
*** 629,640 ****
--- 631,644 ----
  EVP_CIPHER *EVP_des_ede3_cbc();
  EVP_CIPHER *EVP_desx_cbc();
  EVP_CIPHER *EVP_rc4();
+ EVP_CIPHER *EVP_rc4_40();
  EVP_CIPHER *EVP_idea_ecb();
  EVP_CIPHER *EVP_idea_cfb();
  EVP_CIPHER *EVP_idea_ofb();
  EVP_CIPHER *EVP_idea_cbc();
  EVP_CIPHER *EVP_rc2_ecb();
  EVP_CIPHER *EVP_rc2_cbc();
+ EVP_CIPHER *EVP_rc2_40_cbc();
  EVP_CIPHER *EVP_rc2_cfb();
  EVP_CIPHER *EVP_rc2_ofb();
  EVP_CIPHER *EVP_bf_ecb();
diff -crN tmp/SSLeay-0.8.1/crypto/objects/objects.h SSLeay-0.8.1/crypto/objects/objects.h
*** tmp/SSLeay-0.8.1/crypto/objects/objects.h	Fri Jul 18 19:16:09 1997
--- SSLeay-0.8.1/crypto/objects/objects.h	Tue Nov 18 14:16:07 1997
***************
*** 518,523 ****
--- 518,615 ----
  #define NID_mdc2WithRSA			96
  #define OBJ_mdc2WithRSA			2L,5L,8L,3L,100L
  
+ #define LN_pkcs12			"pkcs12"
+ #define NID_pkcs12			97
+ #define OBJ_pkcs12			OBJ_pkcs,12L
+ 
+ #define LN_pkcs12_pbeids		"pkcs12-pbe"
+ #define NID_pkcs12_pbeids		98
+ #define OBJ_pkcs12_pbeids		OBJ_pkcs12, 1
+ 
+ #define LN_pbe_WithSHA1And128BitRC4	"pbeWithSHA1And128BitRC4"
+ #define NID_pbe_WithSHA1And128BitRC4	99
+ #define OBJ_pbe_WithSHA1And128BitRC4	OBJ_pkcs12_pbeids, 1L
+ 
+ #define LN_pbe_WithSHA1And40BitRC4	"pbeWithSHA1And40BitRC4"
+ #define NID_pbe_WithSHA1And40BitRC4	100
+ #define OBJ_pbe_WithSHA1And40BitRC4	OBJ_pkcs12_pbeids, 2L
+ 
+ #define LN_pbe_WithSHA1And3_Key_TripleDES_CBC	"pbeWithSHA1And3-KeyTripleDES-CBC"
+ #define NID_pbe_WithSHA1And3_Key_TripleDES_CBC	101
+ #define OBJ_pbe_WithSHA1And3_Key_TripleDES_CBC	OBJ_pkcs12_pbeids, 3L
+ 
+ #define LN_pbe_WithSHA1And2_Key_TripleDES_CBC	"pbeWithSHA1And2-KeyTripleDES-CBC"
+ #define NID_pbe_WithSHA1And2_Key_TripleDES_CBC	102
+ #define OBJ_pbe_WithSHA1And2_Key_TripleDES_CBC	OBJ_pkcs12_pbeids, 4L
+ 
+ #define LN_pbe_WithSHA1And128BitRC2_CBC		"pbeWithSHA1And128BitRC2-CBC"
+ #define NID_pbe_WithSHA1And128BitRC2_CBC	103
+ #define OBJ_pbe_WithSHA1And128BitRC2_CBC	OBJ_pkcs12_pbeids, 5L
+ 
+ #define LN_pbe_WithSHA1And40BitRC2_CBC	"pbeWithSHA1And40BitRC2-CBC"
+ #define NID_pbe_WithSHA1And40BitRC2_CBC	104
+ #define OBJ_pbe_WithSHA1And40BitRC2_CBC	OBJ_pkcs12_pbeids, 6L
+ 
+ #define LN_pkcs12_Version1	"pkcs12Version1"
+ #define NID_pkcs12_Version1	105
+ #define OBJ_pkcs12_Version1	OBJ_pkcs12, 10L
+ 
+ #define LN_pkcs12_BagIds	"pkcs12Bagids"
+ #define NID_pkcs12_BagIds	106
+ #define OBJ_pkcs12_BagIds	OBJ_pkcs12_Version1, 1L
+ 
+ #define LN_keyBag		"keyBag"
+ #define NID_keyBag		107
+ #define OBJ_keyBag		OBJ_pkcs12_BagIds, 1L
+ 
+ #define LN_pkcs8ShroudedKeyBag	"pkcs8ShroudedKeyBag"
+ #define NID_pkcs8ShroudedKeyBag	108
+ #define OBJ_pkcs8ShroudedKeyBag	OBJ_pkcs12_BagIds, 2L
+ 
+ #define LN_certBag		"certBag"
+ #define NID_certBag		109
+ #define OBJ_certBag		OBJ_pkcs12_BagIds, 3L
+ 
+ #define LN_crlBag		"crlBag"
+ #define NID_crlBag		110
+ #define OBJ_crlBag		OBJ_pkcs12_BagIds, 4L
+ 
+ #define LN_secretBag		"secretBag"
+ #define NID_secretBag		111
+ #define OBJ_secretBag		OBJ_pkcs12_BagIds, 5L
+ 
+ #define LN_safeContentsBag	"safeContentsBag"
+ #define NID_safeContentsBag	112
+ #define OBJ_safeContentsBag	OBJ_pkcs12_BagIds, 6L
+ 
+ #define LN_friendlyName		"friendlyName"
+ #define	NID_friendlyName	113
+ #define OBJ_friendlyName	OBJ_pkcs9, 20L
+ 
+ #define LN_localKeyID		"localKeyID"
+ #define	NID_localKeyID		114
+ #define OBJ_localKeyID		OBJ_pkcs9, 21L
+ 
+ #define LN_certTypes		"certTypes"
+ #define	NID_certTypes		115
+ #define OBJ_certTypes		OBJ_pkcs9, 22L
+ 
+ #define LN_x509Certificate	"x509Certificate"
+ #define	NID_x509Certificate	116
+ #define OBJ_x509Certificate	OBJ_certTypes, 1L
+ 
+ #define LN_sdsiCertificate	"sdsiCertificate"
+ #define	NID_sdsiCertificate	117
+ #define OBJ_sdsiCertificate	OBJ_certTypes, 2L
+ 
+ #define LN_crlTypes		"crlTypes"
+ #define	NID_crlTypes		117
+ #define OBJ_crlTypes		OBJ_pkcs9, 23L
+ 
+ #define LN_x509Crl		"x509Crl"
+ #define	NID_x509Crl		118
+ #define OBJ_x509Crl		OBJ_crlTypes, 1L
+ 
  #include "asn1.h"
  
  #ifndef NOPROTO
diff -crN tmp/SSLeay-0.8.1/crypto/pkcs12/COPYRIGHT SSLeay-0.8.1/crypto/pkcs12/COPYRIGHT
*** tmp/SSLeay-0.8.1/crypto/pkcs12/COPYRIGHT	Thu Jan  1 01:00:00 1970
--- SSLeay-0.8.1/crypto/pkcs12/COPYRIGHT	Tue Nov 18 14:16:07 1997
***************
*** 0 ****
--- 1,7 ----
+ Copyright Dr Stephen Henson 1997. All rights reserved.
+ The conditions of use are identical to those of SSLeay except that my
+ name (in addition to Eric Young or Tim Hudson) must be mentioned
+ if this software is used in a product and the notice "This product
+ includes software written by Dr Stephen Henson (shenson@bigfoot.com)"
+ used.
+ 
diff -crN tmp/SSLeay-0.8.1/crypto/pkcs12/Makefile.ssl SSLeay-0.8.1/crypto/pkcs12/Makefile.ssl
*** tmp/SSLeay-0.8.1/crypto/pkcs12/Makefile.ssl	Thu Jan  1 01:00:00 1970
--- SSLeay-0.8.1/crypto/pkcs12/Makefile.ssl	Tue Nov 18 14:16:07 1997
***************
*** 0 ****
--- 1,88 ----
+ #
+ # SSLeay/crypto/asn1/Makefile
+ #
+ 
+ DIR=	pkcs12
+ TOP=	../..
+ CC=	cc
+ INCLUDES= -I.. -I../../include
+ CFLAG=-g
+ INSTALLTOP=/usr/local/ssl
+ MAKE=		make -f Makefile.ssl
+ MAKEDEPEND=	makedepend -f Makefile.ssl
+ MAKEFILE=	Makefile.ssl
+ AR=		ar r
+ 
+ CFLAGS= $(INCLUDES) $(CFLAG)
+ 
+ ERR=pkcs12
+ ERRC=pkcs12err
+ GENERAL=Makefile README
+ TEST=
+ APPS=
+ 
+ LIB=$(TOP)/libcrypto.a
+ LIBSRC=hmac.c p12_add.c p12_attr.c p12_crpt.c p12_decr.c p12_init.c \
+ p12_key.c p12_mutl.c p12_pack.c p12_utl.c
+ LIBOBJ=hmac.o p12_add.o p12_attr.o p12_crpt.o p12_decr.o p12_init.o \
+ p12_key.o p12_mutl.o p12_pack.o p12_utl.o
+ 
+ SRC= $(LIBSRC)
+ 
+ EXHEADER=  pkcs12.h
+ HEADER=	$(EXHEADER)
+ 
+ ALL=    $(GENERAL) $(SRC) $(HEADER)
+ 
+ top:
+ 	(cd ../..; $(MAKE) DIRS=crypto SDIRS=$(DIR) sub_all)
+ 
+ test:
+ 
+ all:	lib
+ 
+ lib:	$(LIBOBJ)
+ 	$(AR) $(LIB) $(LIBOBJ)
+ 	sh $(TOP)/util/ranlib.sh $(LIB)
+ 	@touch lib
+ 
+ files:
+ 	perl $(TOP)/util/files.pl Makefile.ssl >> $(TOP)/MINFO
+ 
+ links:
+ 	/bin/rm -f Makefile
+ 	$(TOP)/util/point.sh Makefile.ssl Makefile ;
+ 	$(TOP)/util/mklink.sh ../../include $(EXHEADER)
+ 	$(TOP)/util/mklink.sh ../../test $(TEST)
+ 	$(TOP)/util/mklink.sh ../../apps $(APPS)
+ 
+ install:
+ 	@for i in $(EXHEADER) ; \
+ 	do  \
+ 	(cp $$i $(INSTALLTOP)/include/$$i; \
+ 	chmod 644 $(INSTALLTOP)/include/$$i ); \
+ 	done;
+ 
+ tags:
+ 	ctags $(SRC)
+ 
+ tests:
+ 
+ lint:
+ 	lint -DLINT $(INCLUDES) $(SRC)>fluff
+ 
+ depend:
+ 	$(MAKEDEPEND) $(INCLUDES) $(PROGS) $(LIBSRC)
+ 
+ dclean:
+ 	perl -pe 'if (/^# DO NOT DELETE THIS LINE/) {print; exit(0);}' $(MAKEFILE) >Makefile.new
+ 	mv -f Makefile.new $(MAKEFILE)
+ 
+ clean:
+ 	/bin/rm -f *.o *.obj lib tags core .pure .nfs* *.old *.bak fluff
+ 
+ errors:
+ 	perl $(TOP)/util/err-ins.pl $(ERR).err $(ERR).h
+ 	perl ../err/err_genc.pl $(ERR).h $(ERRC).c
+ 
+ # DO NOT DELETE THIS LINE -- make depend depends on it.
diff -crN tmp/SSLeay-0.8.1/crypto/pkcs12/README SSLeay-0.8.1/crypto/pkcs12/README
*** tmp/SSLeay-0.8.1/crypto/pkcs12/README	Thu Jan  1 01:00:00 1970
--- SSLeay-0.8.1/crypto/pkcs12/README	Tue Nov 18 16:45:06 1997
***************
*** 0 ****
--- 1,2 ----
+ This directory contains PKCS#12 support files. See the file pkcs12.doc and
+ pk12api.doc in the docs directory for more info on using the various functions.
diff -crN tmp/SSLeay-0.8.1/crypto/pkcs12/TODO SSLeay-0.8.1/crypto/pkcs12/TODO
*** tmp/SSLeay-0.8.1/crypto/pkcs12/TODO	Thu Jan  1 01:00:00 1970
--- SSLeay-0.8.1/crypto/pkcs12/TODO	Tue Nov 18 14:16:07 1997
***************
*** 0 ****
--- 1,4 ----
+ 1. Code tidy up, better integration.
+ 2. Support for enveloping modes.
+ 3. Cleverer front end. PKCS#12 objects are in some ways like archives, so
+    something like a zip/tar front end might be more appropriate. 
diff -crN tmp/SSLeay-0.8.1/crypto/pkcs12/hmac.c SSLeay-0.8.1/crypto/pkcs12/hmac.c
*** tmp/SSLeay-0.8.1/crypto/pkcs12/hmac.c	Thu Jan  1 01:00:00 1970
--- SSLeay-0.8.1/crypto/pkcs12/hmac.c	Tue Nov 18 14:16:07 1997
***************
*** 0 ****
--- 1,63 ----
+ /* Written by Dr. S N Henson and released into the public domain */
+ #include <stdio.h>
+ #include <stdlib.h>
+ #include <err.h>
+ #include <crypto.h>
+ #include <evp.h>
+ #include <string.h>
+ #include "hmac.h"
+ 
+ /* HMAC routines: these implement the HMAC function as described in RFC2104 */
+ 
+ void HMAC_Init (hctx, key, keylen, md_type)
+ HMAC_CTX *hctx;
+ unsigned char *key;
+ int keylen;
+ EVP_MD *md_type;
+ {
+ 	int blocklen, i;
+ 	unsigned char keytmp[EVP_MAX_MD_BLOCK];
+ 	blocklen = EVP_MD_blocksize (md_type);
+ 	if (keylen > blocklen) {
+ 		hctx->keylen = EVP_MD_size (md_type);
+ 		EVP_DigestInit (&hctx->ctx, hctx->type);
+ 		EVP_DigestUpdate (&hctx->ctx, key, keylen);
+ 		EVP_DigestFinal (&hctx->ctx, hctx->key, NULL);
+ 	} else {
+ 		hctx->keylen = keylen;
+ 		memcpy (hctx->key, key, keylen);
+ 	}
+ 	hctx->type = md_type;
+ 	EVP_DigestInit (&hctx->ctx, hctx->type);
+ 	memset (keytmp, 0, blocklen);
+ 	memcpy (keytmp, hctx->key, hctx->keylen);
+ 	for (i = 0; i < blocklen; i++) keytmp[i] ^=0x36;
+ 	EVP_DigestUpdate (&hctx->ctx, keytmp, blocklen);
+ }
+ 
+ void HMAC_Update (hctx, data, len)
+ HMAC_CTX *hctx;
+ unsigned char *data;
+ unsigned int len;
+ {
+ 	EVP_DigestUpdate (&hctx->ctx, data, len);
+ }
+ 
+ void HMAC_Final (hctx, md, len)
+ HMAC_CTX *hctx;
+ unsigned char *md;
+ unsigned int *len;
+ {
+ 	int blocklen, i, diglen;
+ 	unsigned char digtmp[EVP_MAX_MD_SIZE], keytmp[EVP_MAX_MD_BLOCK];
+ 	blocklen = EVP_MD_blocksize (md_type);
+ 	EVP_DigestFinal (&hctx->ctx, digtmp, &diglen);
+ 	memset (keytmp, 0, blocklen);
+ 	memcpy (keytmp, hctx->key, hctx->keylen);
+ 	for (i = 0; i < blocklen; i++) keytmp[i] ^=0x5c;
+ 	EVP_DigestInit (&hctx->ctx, hctx->type);
+ 	EVP_DigestUpdate (&hctx->ctx, keytmp, blocklen);
+ 	EVP_DigestUpdate (&hctx->ctx, digtmp, diglen);
+ 	EVP_DigestFinal (&hctx->ctx, md, len);
+ }
+ 
diff -crN tmp/SSLeay-0.8.1/crypto/pkcs12/hmac.h SSLeay-0.8.1/crypto/pkcs12/hmac.h
*** tmp/SSLeay-0.8.1/crypto/pkcs12/hmac.h	Thu Jan  1 01:00:00 1970
--- SSLeay-0.8.1/crypto/pkcs12/hmac.h	Tue Nov 18 14:16:07 1997
***************
*** 0 ****
--- 1,23 ----
+ /* Written by Dr. S N Henson and released into the public domain */
+ 
+ 
+ #ifndef EVP_MAX_MD_BLOCK
+ #define EVP_MAX_MD_BLOCK 64
+ #endif
+ #ifndef EVP_MD_blocksize
+ #define EVP_MD_blocksize(a)	64
+ #endif
+ 
+ /* HMAC context structure */
+ 
+ typedef struct {
+ unsigned char key[EVP_MAX_MD_BLOCK];	/* Storage for HMAC key */
+ int keylen;		/* Length of key */
+ EVP_MD_CTX	ctx;	/* Standard digest context */
+ EVP_MD		*type;	/* Type of digest */
+ } HMAC_CTX;
+ 
+ /* hmac.c */
+ void HMAC_Init(HMAC_CTX *hctx, unsigned char *key, int keylen, EVP_MD *md_type);
+ void HMAC_Update(HMAC_CTX *hctx, unsigned char *data, unsigned int len);
+ void HMAC_Final(HMAC_CTX *hctx, unsigned char *md, unsigned int *len);
diff -crN tmp/SSLeay-0.8.1/crypto/pkcs12/p12_add.c SSLeay-0.8.1/crypto/pkcs12/p12_add.c
*** tmp/SSLeay-0.8.1/crypto/pkcs12/p12_add.c	Thu Jan  1 01:00:00 1970
--- SSLeay-0.8.1/crypto/pkcs12/p12_add.c	Tue Nov 18 14:16:07 1997
***************
*** 0 ****
--- 1,191 ----
+ /* Copyright Dr Stephen Henson 1997. All rights reserved.
+  * The conditions of use are identical to those of SSLeay except that my
+  * name (in addition to Eric Young or Tim Hudson) must be mentioned
+  * if this software is used in a product and the notice "This product
+  * includes software written by Dr Stephen Henson (shenson@bigfoot.com)"
+  * used.
+  */
+ #include <stdio.h>
+ #include <stdlib.h>
+ #include <objects.h>
+ #include <asn1.h>
+ #include <asn1_mac.h>
+ #include <x509.h>
+ #include <pkcs7.h>
+ #include <err.h>
+ #include <stack.h>
+ #include <crypto.h>
+ #include <string.h>
+ #include <rsa.h>
+ #include <sha.h>
+ #include <pem.h>
+ #include <rand.h>
+ #include <asn1.h>
+ #include <evp.h>
+ #include "pkcs12.h"
+ 
+ /* Pack an object into an OCTET STRING and turn into a safebag */
+ 
+ PKCS12_SAFEBAG *PKCS12_pack_safebag (obj, i2d, nid1, nid2)
+ char *obj;
+ int (*i2d)();
+ int nid1;
+ int nid2;
+ 
+ {
+ 	PKCS12_BAGS *bag;
+ 	PKCS12_SAFEBAG *safebag;
+ 	if (!(bag = PKCS12_BAGS_new ())) {
+ 		PKCS12err(PKCS12_F_PKCS12_PACK_SAFEBAG, ERR_R_MALLOC_FAILURE);
+ 		return NULL;
+ 	}
+ 	bag->type = OBJ_nid2obj (nid1);
+ 	if (!PKCS12_pack_octet (obj, i2d, &bag->value.octet)) {
+ 		PKCS12err(PKCS12_F_PKCS12_PACK_SAFEBAG, ERR_R_MALLOC_FAILURE);
+ 		return NULL;
+ 	}
+ 	if (!(safebag = PKCS12_SAFEBAG_new ())) {
+ 		PKCS12err(PKCS12_F_PKCS12_PACK_SAFEBAG, ERR_R_MALLOC_FAILURE);
+ 		return NULL;
+ 	}
+ 	safebag->value.bag = bag;
+ 	safebag->type = OBJ_nid2obj (nid2);
+ 	return safebag;
+ }
+ 
+ /* Turn rsa key to PKCS8 object */
+ 
+ PKCS8_PRIV_KEY_INFO *rsa2PKCS8 (rsa)
+ RSA *rsa;
+ {
+ 	PKCS8_PRIV_KEY_INFO *pkey;
+ 
+ 	if(!(pkey = PKCS8_PRIV_KEY_INFO_new ())) {
+ 		PKCS12err(PKCS12_F_RSA2PKCS8, ERR_R_MALLOC_FAILURE);
+ 		return NULL;
+ 	}
+ 	ASN1_INTEGER_set (pkey->version, 0);
+ 	pkey->pkeyalg->algorithm = OBJ_nid2obj (NID_rsaEncryption);
+ 	if (!(pkey->pkeyalg->parameter = ASN1_TYPE_new ())) {
+ 		PKCS12err(PKCS12_F_RSA2PKCS8, ERR_R_MALLOC_FAILURE);
+ 		return NULL;
+ 	}
+ 	pkey->pkeyalg->parameter->type = V_ASN1_NULL;
+ 	if (!PKCS12_pack_octet ((char *)rsa, i2d_RSAPrivateKey, &pkey->pkey)) {
+ 		PKCS12err(PKCS12_F_RSA2PKCS8, ERR_R_MALLOC_FAILURE);
+ 		return NULL;
+ 	}
+ 	RAND_seed (pkey->pkey->data, pkey->pkey->length);
+ 	return pkey;
+ }
+ 
+ /* Turn PKCS8 object into a keybag */
+ 
+ PKCS12_SAFEBAG *PKCS12_MAKE_KEYBAG (p8)
+ PKCS8_PRIV_KEY_INFO *p8;
+ {
+ 	PKCS12_SAFEBAG *bag;
+ 	if (!(bag = PKCS12_SAFEBAG_new())) {
+ 		PKCS12err(PKCS12_F_PKCS12_MAKE_SAFEBAG, ERR_R_MALLOC_FAILURE);
+ 		return NULL;
+ 	}
+ 	bag->type = OBJ_nid2obj (NID_keyBag);
+ 	bag->value.keybag = p8;
+ 	return bag;
+ }
+ 
+ /* Turn PKCS8 object into a shrouded keybag */
+ 
+ PKCS12_SAFEBAG
+ 	 *PKCS12_MAKE_SHKEYBAG (pbe_nid, pass, passlen, salt, saltlen, iter, p8)int pbe_nid;
+ unsigned char *pass;
+ int passlen;
+ unsigned char *salt;
+ int saltlen;
+ int iter;
+ PKCS8_PRIV_KEY_INFO *p8;
+ {
+ 	PKCS12_SAFEBAG *bag;
+ 	X509_ALGOR *pbe;
+ 
+ 	/* Set up the safe bag */
+ 	if (!(bag = PKCS12_SAFEBAG_new ())) {
+ 		PKCS12err(PKCS12_F_PKCS12_MAKE_SHKEYBAG, ERR_R_MALLOC_FAILURE);
+ 		return NULL;
+ 	}
+ 	bag->type = OBJ_nid2obj (NID_pkcs8ShroudedKeyBag);
+ 	if (!(bag->value.shkeybag = X509_SIG_new())) return NULL;
+ 	if (!(pbe = PKCS12_pbe_set (pbe_nid, iter, salt, saltlen))) {
+ 		PKCS12err(PKCS12_F_PKCS12_MAKE_SHKEYBAG, ERR_R_MALLOC_FAILURE);
+ 		return NULL;
+ 	}
+ 	bag->value.shkeybag->algor = pbe;
+ 
+ 	if (!(bag->value.shkeybag->digest = 
+ 	PKCS12_i2d_encrypt (pbe, i2d_PKCS8_PRIV_KEY_INFO, pass, passlen,
+ 						 (char *)p8, 0))) {
+ 		PKCS12err(PKCS12_F_PKCS12_MAKE_SHKEYBAG, PKCS12_R_ENCRYPT_ERROR);
+ 		return NULL;
+ 	}
+ 
+ 	return bag;
+ }
+ 
+ /* Turn a stack of SAFEBAGS into a PKCS#7 data Contentinfo */
+ PKCS7 *PKCS12_pack_p7data (sk)
+ STACK *sk;
+ {
+ 	PKCS7 *p7;
+ 	if (!(p7 = PKCS7_new())) {
+ 		PKCS12err(PKCS12_F_PKCS12_PACK_P7_DATA, ERR_R_MALLOC_FAILURE);
+ 		return NULL;
+ 	}
+ 	PKCS7_set_type (p7, NID_pkcs7_data);
+ 	if (!PKCS12_struct_pack (sk, i2d_PKCS12_SAFEBAG, &p7->d.data->data,
+ 					&p7->d.data->length)) {
+ 		PKCS12err(PKCS12_F_PKCS12_PACK_P7DATA, PKCS12_R_CANT_PACK_STRUCTURE);
+ 		return NULL;
+ 	}
+ 	return p7;
+ }
+ 
+ /* Turn a stack of SAFEBAGS into a PKCS#7 encrypted data ContentInfo */
+ 
+ PKCS7 *PKCS12_pack_p7encdata (pbe_nid, pass, passlen, salt, saltlen, iter,
+ 									 bags)
+ int pbe_nid;
+ unsigned char *pass;
+ int passlen;
+ unsigned char *salt;
+ int saltlen;
+ int iter;
+ STACK *bags;
+ {
+ 	PKCS7 *p7;
+ 	X509_ALGOR *pbe;
+ 	if (!(p7 = PKCS7_new())) {
+ 		PKCS12err(PKCS12_F_PKCS12_PACK_P7ENCDATA, ERR_R_MALLOC_FAILURE);
+ 		return NULL;
+ 	}
+ 	/* The next bit may end up in PKCS7_set_type eventually */
+ 	p7->type = OBJ_nid2obj (NID_pkcs7_encrypted);
+ 	if (!(p7->d.encrypted = PKCS7_ENCRYPT_new ())) {
+ 		PKCS12err(PKCS12_F_PKCS12_PACK_P7ENCDATA, ERR_R_MALLOC_FAILURE);
+ 		return NULL;
+ 	}
+ 	ASN1_INTEGER_set (p7->d.encrypted->version, 0);
+ 	p7->d.encrypted->enc_data->content_type = OBJ_nid2obj (NID_pkcs7_data);
+ 	if (!(pbe = PKCS12_pbe_set (pbe_nid, iter, salt, saltlen))) {
+ 		PKCS12err(PKCS12_F_PKCS12_PACK_P7ENCDATA, ERR_R_MALLOC_FAILURE);
+ 		return NULL;
+ 	}
+ 	p7->d.encrypted->enc_data->algorithm = pbe;
+ 	if (!(p7->d.encrypted->enc_data->enc_data =
+ 	PKCS12_i2d_encrypt (pbe, i2d_PKCS12_SAFEBAG, pass, passlen,
+ 				 (char *)bags, 1))) {
+ 		PKCS12err(PKCS12_F_PKCS12_PACK_P7ENCDATA, PKCS12_R_ENCRYPT_ERROR);
+ 		return NULL;
+ 	}
+ 
+ 	return p7;
+ }
diff -crN tmp/SSLeay-0.8.1/crypto/pkcs12/p12_attr.c SSLeay-0.8.1/crypto/pkcs12/p12_attr.c
*** tmp/SSLeay-0.8.1/crypto/pkcs12/p12_attr.c	Thu Jan  1 01:00:00 1970
--- SSLeay-0.8.1/crypto/pkcs12/p12_attr.c	Tue Nov 18 16:44:51 1997
***************
*** 0 ****
--- 1,134 ----
+ /* Copyright Dr Stephen Henson 1997. All rights reserved.
+  * The conditions of use are identical to those of SSLeay except that my
+  * name (in addition to Eric Young or Tim Hudson) must be mentioned
+  * if this software is used in a product and the notice "This product
+  * includes software written by Dr Stephen Henson (shenson@bigfoot.com)"
+  * used.
+  */
+ #include <stdio.h>
+ #include <stdlib.h>
+ #include <objects.h>
+ #include <asn1.h>
+ #include <asn1_mac.h>
+ #include <x509.h>
+ #include <pkcs7.h>
+ #include <err.h>
+ #include <stack.h>
+ #include <crypto.h>
+ #include <string.h>
+ #include <rsa.h>
+ #include <sha.h>
+ #include <pem.h>
+ #include <rand.h>
+ #include <asn1.h>
+ #include <evp.h>
+ #include "pkcs12.h"
+ 
+ /* Add a local keyid to a safebag */
+ 
+ int PKCS12_add_localkeyid (bag, name, namelen)
+ PKCS12_SAFEBAG *bag;
+ unsigned char *name;
+ int namelen;
+ {
+ 	X509_ATTRIBUTE *attrib;
+ 	ASN1_BMPSTRING *oct;
+ 	ASN1_TYPE *keyid;
+ 	if (!(keyid = ASN1_TYPE_new ())) {
+ 		PKCS12err(PKCS12_F_PKCS12_ADD_LOCALKEYID, ERR_R_MALLOC_FAILURE);
+ 		return 0;
+ 	}
+ 	keyid->type = V_ASN1_OCTET_STRING;
+ 	if (!(oct = ASN1_OCTET_STRING_new())) {
+ 		PKCS12err(PKCS12_F_PKCS12_ADD_LOCALKEYID, ERR_R_MALLOC_FAILURE);
+ 		return 0;
+ 	}
+ 	if (!(oct->data = Malloc (namelen))) {
+ 		PKCS12err(PKCS12_F_PKCS12_ADD_LOCALKEYID, ERR_R_MALLOC_FAILURE);
+ 		return 0;
+ 	}
+ 	memcpy (oct->data, name, namelen);
+ 	oct->length = namelen;
+ 	keyid->value.octet_string = oct;
+ 	if (!(attrib = X509_ATTRIBUTE_new ())) {
+ 		PKCS12err(PKCS12_F_PKCS12_ADD_LOCALKEYID, ERR_R_MALLOC_FAILURE);
+ 		return 0;
+ 	}
+ 	attrib->object = OBJ_nid2obj (NID_localKeyID);
+ 	if (!(attrib->value.set = sk_new(NULL))) {
+ 		PKCS12err(PKCS12_F_PKCS12_ADD_LOCALKEYID, ERR_R_MALLOC_FAILURE);
+ 		return 0;
+ 	}
+ 	sk_push (attrib->value.set, (char *)keyid);
+ 	attrib->set = 1;
+ 	if (!bag->attrib && !(bag->attrib = sk_new (NULL))) {
+ 		PKCS12err(PKCS12_F_PKCS12_ADD_LOCALKEYID, ERR_R_MALLOC_FAILURE);
+ 		return 0;
+ 	}
+ 	sk_push (bag->attrib, (char *)attrib);
+ 	return 1;
+ }
+ 
+ /* Add a friendlyname to a safebag */
+ 
+ int PKCS12_add_friendlyname (bag, name, namelen)
+ PKCS12_SAFEBAG *bag;
+ unsigned char *name;
+ int namelen;
+ {
+ 	X509_ATTRIBUTE *attrib;
+ 	ASN1_BMPSTRING *bmp;
+ 	ASN1_TYPE *fname;
+ 	if (!(fname = ASN1_TYPE_new ())) {
+ 		PKCS12err(PKCS12_F_ADD_FRIENDLYNAME, ERR_R_MALLOC_FAILURE);
+ 		return 0;
+ 	}
+ 	fname->type = V_ASN1_BMPSTRING;
+ 	if (!(bmp = ASN1_BMPSTRING_new())) {
+ 		PKCS12err(PKCS12_F_ADD_FRIENDLYNAME, ERR_R_MALLOC_FAILURE);
+ 		return 0;
+ 	}
+ 	if (!(bmp->data = Malloc (namelen))) {
+ 		PKCS12err(PKCS12_F_ADD_FRIENDLYNAME, ERR_R_MALLOC_FAILURE);
+ 		return 0;
+ 	}
+ 	memcpy (bmp->data, name, namelen);
+ 	bmp->length = namelen;
+ 	fname->value.bmpstring = bmp;
+ 	if (!(attrib = X509_ATTRIBUTE_new ())) {
+ 		PKCS12err(PKCS12_F_ADD_FRIENDLYNAME, ERR_R_MALLOC_FAILURE);
+ 		return 0;
+ 	}
+ 	attrib->object = OBJ_nid2obj (NID_friendlyName);
+ 	if (!(attrib->value.set = sk_new(NULL))) {
+ 		PKCS12err(PKCS12_F_ADD_FRIENDLYNAME, ERR_R_MALLOC_FAILURE);
+ 		return 0;
+ 	}
+ 	sk_push (attrib->value.set, (char *)fname);
+ 	attrib->set = 1;
+ 	if (!bag->attrib && !(bag->attrib = sk_new (NULL))) {
+ 		PKCS12err(PKCS12_F_ADD_FRIENDLYNAME, ERR_R_MALLOC_FAILURE);
+ 		return 0;
+ 	}
+ 	sk_push (bag->attrib, (char *)attrib);
+ 	return PKCS12_OK;
+ }
+ 
+ ASN1_TYPE *PKCS12_get_attr (bag, attr_nid)
+ PKCS12_SAFEBAG *bag;
+ int attr_nid;
+ {
+ 	X509_ATTRIBUTE *attrib;
+ 	int i;
+ 	if (!bag->attrib) return NULL;
+ 	for (i = 0; i < sk_num (bag->attrib); i++) {
+ 		attrib = (X509_ATTRIBUTE *) sk_value (bag->attrib, i);
+ 		if (OBJ_obj2nid (attrib->object) == attr_nid) {
+ 			if (sk_num (attrib->value.set))
+ 				return (ASN1_TYPE *)
+ 					 sk_value (attrib->value.set, 0);
+ 			else return NULL;
+ 		}
+ 	}
+ 	return NULL;
+ }
diff -crN tmp/SSLeay-0.8.1/crypto/pkcs12/p12_crpt.c SSLeay-0.8.1/crypto/pkcs12/p12_crpt.c
*** tmp/SSLeay-0.8.1/crypto/pkcs12/p12_crpt.c	Thu Jan  1 01:00:00 1970
--- SSLeay-0.8.1/crypto/pkcs12/p12_crpt.c	Tue Nov 18 14:16:07 1997
***************
*** 0 ****
--- 1,97 ----
+ /* Copyright Dr Stephen Henson 1997. All rights reserved.
+  * The conditions of use are identical to those of SSLeay except that my
+  * name (in addition to Eric Young or Tim Hudson) must be mentioned
+  * if this software is used in a product and the notice "This product
+  * includes software written by Dr Stephen Henson (shenson@bigfoot.com)"
+  * used.
+  */
+ #include <stdio.h>
+ #include <stdlib.h>
+ #include <objects.h>
+ #include <err.h>
+ #include <crypto.h>
+ #include <stack.h>
+ #include <evp.h>
+ #include <pkcs7.h>
+ #include "pkcs12.h"
+ 
+ /* PBE control routine. Given relevant parameters,
+  * initialise encryption/decryption routine properly.
+  */
+ 
+ static PBECTL pbectl[] = {
+ {NID_pbe_WithSHA1And128BitRC4, EVP_rc4},
+ {NID_pbe_WithSHA1And40BitRC4, EVP_rc4_40},
+ {NID_pbe_WithSHA1And3_Key_TripleDES_CBC, EVP_des_ede3_cbc},
+ {NID_pbe_WithSHA1And2_Key_TripleDES_CBC, EVP_des_ede_cbc},
+ {NID_pbe_WithSHA1And128BitRC2_CBC, EVP_rc2_cbc},
+ {NID_pbe_WithSHA1And40BitRC2_CBC, EVP_rc2_40_cbc},
+ };
+ 
+ int PKCS12_CipherInit (pbe_nid, pass, passlen, salt, saltlen, iter, ctx, en_de)
+ int pbe_nid, passlen, saltlen, iter, en_de;
+ unsigned char *pass, *salt;
+ EVP_CIPHER_CTX *ctx;
+ {
+ 	EVP_MD *md_type;
+ 	EVP_CIPHER *cipher = NULL;
+ 	unsigned char key[EVP_MAX_KEY_LENGTH], iv[EVP_MAX_IV_LENGTH];
+ 	int i;
+ 	md_type = EVP_sha1(); /* They all use SHA-1 at present */
+ 	for (i = 0; i < sizeof(pbectl)/sizeof(PBECTL); i++) {
+ 		if (pbectl[i].pbe_nid == pbe_nid) {
+ 			cipher = (*pbectl[i].cipher)();
+ 			break;
+ 		}
+ 	}
+ 	if (!cipher) {
+ 		PKCS12err(PKCS12_F_PKCS12_CRYPT_INIT, PKCS12_R_UNKNOWN_PBE_ALGORITHM);
+ 		return 0;
+ 	}
+ 	if(!PKCS12_key_gen (pass, passlen, salt, saltlen, PKCS12_KEY_ID, iter,
+ 			 EVP_CIPHER_key_length(cipher), key, md_type)) {
+ 		PKCS12err(PKCS12_F_PKCS12_CIPHERINIT,PKCS12_R_KEY_GEN_ERROR);
+ 		return 0;
+ 	}
+ 	if (!PKCS12_key_gen (pass, passlen, salt, saltlen, PKCS12_IV_ID, iter,
+ 				 EVP_CIPHER_iv_length(cipher), iv, md_type)) {
+ 		PKCS12err(PKCS12_F_PKCS12_CIPHERINIT,PKCS12_R_KEY_GEN_ERROR);
+ 		return 0;
+ 	}
+ 	EVP_CipherInit (ctx, cipher, key, iv, en_de);
+ 	return 1;	
+ }
+ 
+ /* Setup a PBE algorithm but take most parameters from AlgorithmIdentifier */
+ int PKCS12_ALGOR_CipherInit (algor, pass, passlen, ctx, en_de)
+ X509_ALGOR *algor;
+ unsigned char *pass;
+ int passlen;
+ EVP_CIPHER_CTX *ctx;
+ int en_de;
+ {
+ 	PBEPARAM *pbe;
+ 	int pbe_nid, saltlen, iter;
+ 	unsigned char *salt, *pbuf;
+ 
+ 	/* Extract useful info from algor */
+ 	pbuf = (char *) algor->parameter->value.sequence->data;
+ 	if (!(pbe = d2i_PBEPARAM (NULL, &pbuf,
+ 			 algor->parameter->value.sequence->length))) {
+ 		PKCS12err(PKCS12_F_PKCS12_ALGOR_CIPHERINIT, PKCS12_R_DECODE_ERROR);
+ 		return 0;
+ 	}
+ 
+ 	pbe_nid = OBJ_obj2nid (algor->algorithm);
+ 	if (!pbe->iter) iter = 1;
+ 	else iter = ASN1_INTEGER_get (pbe->iter);
+ 	salt = pbe->salt->data;
+ 	saltlen = pbe->salt->length;
+ 
+ 	if (!(PKCS12_CipherInit (pbe_nid, pass, passlen, salt, saltlen,
+ 					iter, ctx, en_de))) {
+ 		PKCS12err(PKCS12_F_PKCS12_ALGOR_CIPHERINIT, PKCS12_R_PKCS12_CIPHERINIT_ERROR);
+ 		return 0;
+ 	}
+ 	return 1;
+ }
diff -crN tmp/SSLeay-0.8.1/crypto/pkcs12/p12_decr.c SSLeay-0.8.1/crypto/pkcs12/p12_decr.c
*** tmp/SSLeay-0.8.1/crypto/pkcs12/p12_decr.c	Thu Jan  1 01:00:00 1970
--- SSLeay-0.8.1/crypto/pkcs12/p12_decr.c	Tue Nov 18 14:16:07 1997
***************
*** 0 ****
--- 1,130 ----
+ /* Copyright Dr Stephen Henson 1997. All rights reserved.
+  * The conditions of use are identical to those of SSLeay except that my
+  * name (in addition to Eric Young or Tim Hudson) must be mentioned
+  * if this software is used in a product and the notice "This product
+  * includes software written by Dr Stephen Henson (shenson@bigfoot.com)"
+  * used.
+  */
+ #include <stdio.h>
+ #include <stdlib.h>
+ #include <objects.h>
+ #include <pkcs7.h>
+ #include <err.h>
+ #include <crypto.h>
+ #include <sha.h>
+ #include <stack.h>
+ #include <evp.h>
+ #include <string.h>
+ #include "hmac.h"
+ #include "pkcs12.h"
+ 
+ 
+ /* Encrypt/Decrypt a buffer based on password and algor, result in a
+  * Malloc'ed buffer
+  */
+ 
+ unsigned char * PKCS12_pbe_crypt (algor, pass, passlen, in, inlen,
+ 						 data, datalen, en_de)
+ X509_ALGOR *algor;
+ unsigned char *pass;
+ int passlen;
+ unsigned char *in;
+ int inlen;
+ unsigned char **data;
+ int *datalen;
+ {
+ 	unsigned char *out;
+ 	int outlen, i;
+ 	EVP_CIPHER_CTX ctx;
+ 
+ 	if(!(out = Malloc (inlen + 8))) {
+ 		PKCS12err(PKCS12_F_PKCS12_PBE_CRYPT,ERR_R_MALLOC_FAILURE);
+ 		return NULL;
+ 	}
+ 
+ 	/* Decrypt data */
+         if (!PKCS12_ALGOR_CipherInit (algor, pass, passlen, &ctx, en_de)) {
+ 		PKCS12err(PKCS12_F_PKCS12_PBE_CRYPT,PKCS12_R_PKCS12_ALGOR_CIPHERINIT_ERROR);
+ 		return NULL;
+ 	}
+ 	EVP_CipherUpdate (&ctx, out, &i, in, inlen);
+ 	outlen = i;
+ 	if(!EVP_CipherFinal (&ctx, out + i, &i)) {
+ 		Free (out);
+ 		PKCS12err(PKCS12_F_PKCS12_PBE_CRYPT,PKCS12_R_PKCS12_CIPHERFINAL_ERROR);
+ 		return NULL;
+ 	}
+ 	outlen += i;
+ 	if (datalen) *datalen = outlen;
+ 	if (data) *data = out;
+ 	return out;
+ 
+ }
+ 
+ /* Decrypt an OCTET STRING and decode ASN1 structure */
+ 
+ char * PKCS12_decrypt_d2i (algor, d2i, pass, passlen, oct, seq)
+ X509_ALGOR *algor;
+ char * (*d2i)();
+ unsigned char *pass;
+ int passlen;
+ ASN1_OCTET_STRING *oct;
+ int seq;
+ {
+ 	unsigned char *out, *p, *ret;
+ 	int outlen;
+ 	if (!PKCS12_pbe_crypt (algor, pass, passlen, oct->data, oct->length,
+ 				 &out, &outlen, 0)) {
+ 		PKCS12err(PKCS12_F_PKCS12_DECRYPT_D2I,PKCS12_R_PKCS12_PBE_CRYPT_ERROR);
+ 		return NULL;
+ 	}
+ 	p = out;
+ 	if (seq) ret = (char *) d2i_ASN1_SET (NULL, &p, outlen, d2i,
+ 					 V_ASN1_SEQUENCE, V_ASN1_UNIVERSAL);
+ 	else ret = d2i(NULL, &p, outlen);
+ 	if(!ret) PKCS12err(PKCS12_F_PKCS12_DECRYPT_D2I,PKCS12_R_DECODE_ERROR);
+ 	Free (out);
+ 	return ret;
+ }
+ 
+ /* Encode ASN1 structure and encrypt, return OCTET STRING 
+  * if 'seq' is non-zero 'obj' is a stack of structures to be encoded
+  * as a sequence
+  */
+ 
+ ASN1_OCTET_STRING *PKCS12_i2d_encrypt (algor, i2d, pass, passlen, obj, seq)
+ X509_ALGOR *algor;
+ int (*i2d)();
+ unsigned char *pass;
+ int passlen;
+ char *obj;
+ int seq;
+ {
+ 	ASN1_OCTET_STRING *oct;
+ 	unsigned char *in, *p;
+ 	int inlen;
+ 	if (!(oct = ASN1_OCTET_STRING_new ())) {
+ 		PKCS12err(PKCS12_F_PKCS12_I2D_ENCRYPT,ERR_R_MALLOC_FAILURE);
+ 		return NULL;
+ 	}
+ 	if (seq) inlen = i2d_ASN1_SET ((STACK *)obj, NULL, i2d, V_ASN1_SEQUENCE,
+ 							V_ASN1_UNIVERSAL);
+ 	else inlen = i2d (obj, NULL);
+ 	if (!inlen) {
+ 		PKCS12err(PKCS12_F_PKCS12_I2D_ENCRYPT,PKCS12_R_ENCODE_ERROR);
+ 		return NULL;
+ 	}
+ 	if (!(in = Malloc (inlen))) {
+ 		PKCS12err(PKCS12_F_PKCS12_I2D_ENCRYPT,ERR_R_MALLOC_FAILURE);
+ 		return NULL;
+ 	}
+ 	p = in;
+ 	if (seq) i2d_ASN1_SET ((STACK *)obj, &p, i2d, V_ASN1_SEQUENCE,
+ 							 V_ASN1_UNIVERSAL);
+ 	else i2d (obj, &p);
+ 	if (!PKCS12_pbe_crypt (algor, pass, passlen, in, inlen, &oct->data,
+ 				 &oct->length, 1))
+ 		PKCS12err(PKCS12_F_PKCS12_I2D_ENCRYPT,PKCS12_R_ENCRYPT_ERROR);
+ 	Free (in);
+ 	return oct;
+ }
diff -crN tmp/SSLeay-0.8.1/crypto/pkcs12/p12_init.c SSLeay-0.8.1/crypto/pkcs12/p12_init.c
*** tmp/SSLeay-0.8.1/crypto/pkcs12/p12_init.c	Thu Jan  1 01:00:00 1970
--- SSLeay-0.8.1/crypto/pkcs12/p12_init.c	Tue Nov 18 14:16:07 1997
***************
*** 0 ****
--- 1,105 ----
+ /* Copyright Dr Stephen Henson 1997. All rights reserved.
+  * The conditions of use are identical to those of SSLeay except that my
+  * name (in addition to Eric Young or Tim Hudson) must be mentioned
+  * if this software is used in a product and the notice "This product
+  * includes software written by Dr Stephen Henson (shenson@bigfoot.com)"
+  * used.
+  */
+ #include <stdio.h>
+ #include <stdlib.h>
+ #include <objects.h>
+ #include <asn1.h>
+ #include <asn1_mac.h>
+ #include <pkcs7.h>
+ #include <err.h>
+ #include <stack.h>
+ #include <crypto.h>
+ #include <rand.h>
+ #include "pkcs12.h"
+ 
+ /* Initialise a PKCS12 structure to take data */
+ 
+ PKCS12 *PKCS12_init (mode)
+ int mode;
+ {
+ 	PKCS12 *pkcs12;
+ 	if (!(pkcs12 = PKCS12_new())) {
+ 		PKCS12err(PKCS12_F_PKCS12_INIT,ERR_R_MALLOC_FAILURE);
+ 		return NULL;
+ 	}
+ 	if (!(pkcs12->version = ASN1_INTEGER_new ())) {
+ 		PKCS12err(PKCS12_F_PKCS12_INIT,ERR_R_MALLOC_FAILURE);
+ 		return NULL;
+ 	}
+ 	ASN1_INTEGER_set (pkcs12->version, 3);
+ 	if (!(pkcs12->authsafes = PKCS7_new())) {
+ 		PKCS12err(PKCS12_F_PKCS12_INIT,ERR_R_MALLOC_FAILURE);
+ 		return NULL;
+ 	}
+ 	PKCS7_set_type (pkcs12->authsafes, mode);
+ 	return pkcs12;
+ }
+ 
+ /* Return an algorithm identifier for a PBE algorithm */
+ 
+ X509_ALGOR *PKCS12_pbe_set(alg, iter, salt, saltlen)
+ int alg;
+ int iter;
+ unsigned char *salt;
+ int saltlen;
+ {
+ 	unsigned char *pdata, *ptmp;
+ 	int plen;
+ 	PBEPARAM *pbe;
+ 	ASN1_OBJECT *al;
+ 	X509_ALGOR *algor;
+ 	ASN1_TYPE *astype;
+ 
+ 	if (!(pbe = PBEPARAM_new ())) {
+ 		PKCS12err(PKCS12_F_PKCS12_PBE_SET,ERR_R_MALLOC_FAILURE);
+ 		return NULL;
+ 	}
+ 	ASN1_INTEGER_set (pbe->iter, iter);
+ 	if (!saltlen) saltlen = PKCS12_SALT_LEN;
+ 	if (!(pbe->salt->data = Malloc (saltlen))) {
+ 		PKCS12err(PKCS12_F_PKCS12_PBE_SET,ERR_R_MALLOC_FAILURE);
+ 		return NULL;
+ 	}
+ 	pbe->salt->length = saltlen;
+ 	if (salt) memcpy (pbe->salt->data, salt, saltlen);
+ 	else RAND_bytes (pbe->salt->data, saltlen);
+ 	if (!(plen = i2d_PBEPARAM (pbe, NULL))) {
+ 		PKCS12err(PKCS12_F_PKCS12_PBE_SET,PKCS12_R_ENCODE_ERROR);
+ 		return NULL;
+ 	}
+ 	if (!(pdata = Malloc (plen))) {
+ 		PKCS12err(PKCS12_F_PKCS12_PBE_SET,ERR_R_MALLOC_FAILURE);
+ 		return NULL;
+ 	}
+ 	ptmp = pdata;
+ 	i2d_PBEPARAM (pbe, &ptmp);
+ 	PBEPARAM_free (pbe);
+ 
+ 	if (!(astype = ASN1_TYPE_new())) {
+ 		PKCS12err(PKCS12_F_PKCS12_PBE_SET,ERR_R_MALLOC_FAILURE);
+ 		return NULL;
+ 	}
+ 
+ 	astype->type = V_ASN1_SEQUENCE;
+ 	if (!(astype->value.sequence=ASN1_STRING_new())) {
+ 		PKCS12err(PKCS12_F_PKCS12_PBE_SET,ERR_R_MALLOC_FAILURE);
+ 		return NULL;
+ 	}
+ 	ASN1_STRING_set (astype->value.sequence, pdata, plen);
+ 	Free (pdata);
+ 	
+ 	al = OBJ_nid2obj (alg);
+ 	if (!(algor = X509_ALGOR_new())) {
+ 		PKCS12err(PKCS12_F_PKCS12_PBE_SET,ERR_R_MALLOC_FAILURE);
+ 		return NULL;
+ 	}
+ 	algor->algorithm = al;
+ 	algor->parameter = astype;
+ 
+ 	return (algor);
+ }
diff -crN tmp/SSLeay-0.8.1/crypto/pkcs12/p12_key.c SSLeay-0.8.1/crypto/pkcs12/p12_key.c
*** tmp/SSLeay-0.8.1/crypto/pkcs12/p12_key.c	Thu Jan  1 01:00:00 1970
--- SSLeay-0.8.1/crypto/pkcs12/p12_key.c	Tue Nov 18 14:16:07 1997
***************
*** 0 ****
--- 1,84 ----
+ #include <stdio.h>
+ #include <string.h>
+ #include <stdlib.h>
+ #include <crypto.h>
+ #include <evp.h>
+ #include <err.h>
+ #include <bn.h>
+ #include <asn1.h>
+ #include <x509.h>
+ #include "pkcs12.h"
+ 
+ /* PKCS12 compatible key/IV generation */
+ #ifndef min
+ #define min(a,b) ((a) < (b) ? (a) : (b))
+ #endif
+ 
+ int PKCS12_key_gen (pass, passlen, salt, saltlen, id, iter, n, out, md_type)
+ unsigned char *pass, *salt, *out;
+ int passlen, saltlen, id, iter, n;
+ EVP_MD *md_type;
+ {
+ 	unsigned char *B, *D, *I, *p, *Ai;
+ 	int Slen, Plen, Ilen;
+ 	int i, j, u, v;
+ 	BIGNUM *Ij, *Bpl1;	/* These hold Ij and B + 1 */
+ 	EVP_MD_CTX ctx;
+ 	v = /*MD_DIG_BLOCK_LENGTH (md_type)*/ 64;
+ 	u = EVP_MD_size (md_type);
+ 	D = Malloc (v);
+ 	Ai = Malloc (u);
+ 	B = Malloc (v + 1);
+ 	for (i = 0; i < v; i++) D[i] = id;
+ 	Slen = v * ((saltlen+v-1)/v);
+ 	Plen = v * ((passlen+v-1)/v);
+ 	Ilen = Slen + Plen;
+ 	I = Malloc (Ilen);
+ 	Ij = BN_new();
+ 	Bpl1 = BN_new();
+ 	if (!D || !Ai || !B || !I || !Ij || !Bpl1) {
+ 		PKCS12err(PKCS12_F_PKCS12_KEY_GEN, ERR_R_MALLOC_FAILURE);
+ 		return 0;
+ 	}
+ 	p = I;
+ 	for (i = 0; i < Slen; i++) *p++ = salt[i % saltlen];
+ 	for (i = 0; i < Plen; i++) *p++ = pass[i % passlen];
+ 	for (;;) {
+ 		EVP_DigestInit (&ctx, md_type);
+ 		EVP_DigestUpdate (&ctx, D, v);
+ 		EVP_DigestUpdate (&ctx, I, Ilen);
+ 		EVP_DigestFinal (&ctx, Ai, NULL);
+ 		for (j = 1; j < iter; j++) {
+ 			EVP_DigestInit (&ctx, md_type);
+ 			EVP_DigestUpdate (&ctx, Ai, u);
+ 			EVP_DigestFinal (&ctx, Ai, NULL);
+ 		}
+ 		memcpy (out, Ai, min (n, u));
+ 		if (u >= n) {
+ 			Free (Ai);
+ 			Free (B);
+ 			Free (D);
+ 			Free (I);
+ 			BN_free (Ij);
+ 			BN_free (Bpl1);
+ 			return 1;	
+ 		}
+ 		n -= u;
+ 		out += u;
+ 		for (j = 0; j < v; j++) B[j] = Ai[j % u];
+ 		/* Work out B + 1 first then can use B as tmp space */
+ 		BN_bin2bn (B, v, Bpl1);
+ 		BN_add_word (Bpl1, 1);
+ 		for (j = 0; j < Ilen ; j+=v) {
+ 			BN_bin2bn (I + j, v, Ij);
+ 			BN_add (Ij, Ij, Bpl1);
+ 			BN_bn2bin (Ij, B);
+ 			/* If more than 2^(v*8) - 1 cut off MSB */
+ 			if (BN_num_bytes (Ij) > v) {
+ 				BN_bn2bin (Ij, B);
+ 				memcpy (I + j, B + 1, v);
+ 			} else BN_bn2bin (Ij, I + j);
+ 		}
+ 	}
+ 	return 0; /* This can't happen */
+ }
diff -crN tmp/SSLeay-0.8.1/crypto/pkcs12/p12_mutl.c SSLeay-0.8.1/crypto/pkcs12/p12_mutl.c
*** tmp/SSLeay-0.8.1/crypto/pkcs12/p12_mutl.c	Thu Jan  1 01:00:00 1970
--- SSLeay-0.8.1/crypto/pkcs12/p12_mutl.c	Tue Nov 18 14:16:07 1997
***************
*** 0 ****
--- 1,141 ----
+ /* Copyright Dr Stephen Henson 1997. All rights reserved.
+  * The conditions of use are identical to those of SSLeay except that my
+  * name (in addition to Eric Young or Tim Hudson) must be mentioned
+  * if this software is used in a product and the notice "This product
+  * includes software written by Dr Stephen Henson (shenson@bigfoot.com)"
+  * used.
+  */
+ #include <stdio.h>
+ #include <stdlib.h>
+ #include <objects.h>
+ #include <pkcs7.h>
+ #include <err.h>
+ #include <crypto.h>
+ #include <sha.h>
+ #include <stack.h>
+ #include <evp.h>
+ #include <string.h>
+ #include <rand.h>
+ #include "hmac.h"
+ #include "pkcs12.h"
+ 
+ /* Generate a MAC */
+ int PKCS12_gen_mac (p12, pass, passlen, mac, maclen)
+ PKCS12 *p12;
+ unsigned char *pass;
+ int passlen;
+ unsigned char *mac;
+ unsigned int *maclen;
+ {
+ 	EVP_MD *md_type;
+ 	HMAC_CTX hmac;
+ 	unsigned char key[PKCS12_MAC_KEY_LENGTH], *salt;
+ 	int saltlen, iter;
+ 	salt = p12->mac->salt->data;
+ 	saltlen = p12->mac->salt->length;
+ 	if (!p12->mac->iter) iter = 1;
+ 	else iter = ASN1_INTEGER_get (p12->mac->iter);
+     	if(!(md_type =
+ 		 EVP_get_digestbyobj (p12->mac->dinfo->algor->algorithm))) {
+ 		PKCS12err(PKCS12_F_PKCS12_GEN_MAC,PKCS12_R_UNKNOWN_DIGEST_ALGORITHM);
+ 		return 0;
+ 	}
+ 	if(!PKCS12_key_gen (pass, passlen, salt, saltlen, PKCS12_MAC_ID, iter,
+ 				 PKCS12_MAC_KEY_LENGTH, key, md_type)) {
+ 		PKCS12err(PKCS12_F_PKCS12_GEN_MAC,PKCS12_R_KEY_GEN_ERROR);
+ 		return 0;
+ 	}
+ 	HMAC_Init (&hmac, key, PKCS12_MAC_KEY_LENGTH, md_type);
+     	HMAC_Update (&hmac, p12->authsafes->d.data->data,
+ 					 p12->authsafes->d.data->length);
+     	HMAC_Final (&hmac, mac, maclen);
+ 	return 1;
+ }
+ 
+ /* Verify the mac */
+ int PKCS12_verify_mac (p12, pass, passlen)
+ PKCS12 *p12;
+ unsigned char *pass;
+ int passlen;
+ {
+ 	unsigned char mac[EVP_MAX_MD_SIZE];
+ 	unsigned int maclen;
+ 	if (!PKCS12_gen_mac (p12, pass, passlen, mac, &maclen)) {
+ 		PKCS12err(PKCS12_F_VERIFY_MAC,PKCS12_R_MAC_GENERATION_ERROR);
+ 		return 0;
+ 	}
+ 	if ((maclen != p12->mac->dinfo->digest->length)
+ 	|| memcmp (mac, p12->mac->dinfo->digest->data, maclen)) {
+ 		PKCS12err(PKCS12_F_VERIFY_MAC,PKCS12_R_MAC_VERIFY_ERROR);
+ 		return 0;
+ 	}
+ 	return 1;
+ }
+ 
+ /* Set a mac */
+ 
+ int PKCS12_set_mac (p12, pass, passlen, salt, saltlen, iter, md_type)
+ PKCS12 *p12;
+ unsigned char *pass;
+ int passlen;
+ unsigned char *salt;
+ int saltlen;
+ int iter;
+ EVP_MD *md_type;
+ {
+ 	unsigned char mac[EVP_MAX_MD_SIZE];
+ 	int maclen;
+ 	if (!md_type) md_type = EVP_sha1();
+ 	if (PKCS12_setup_mac (p12, iter, salt, saltlen, md_type) ==
+ 				 	PKCS12_ERROR) {
+ 		PKCS12err(PKCS12_F_PKCS12_SET_MAC, PKCS12_R_MAC_SETUP_ERROR);
+ 		return 0;
+ 	}
+ 	if (!PKCS12_gen_mac (p12, pass, passlen, mac, &maclen)) {
+ 		PKCS12err(PKCS12_F_PKCS12_SET_MAC, PKCS12_R_MAC_GENERATION_ERROR);
+ 		return 0;
+ 	}
+ 	if (!(p12->mac->dinfo->digest = ASN1_OCTET_STRING_new())) {
+ 		PKCS12err(PKCS12_F_PKCS12_PKCS12_SET_MAC, ERR_R_MALLOC_FAILURE);
+ 		return 0;
+ 	}
+ 	if (!(ASN1_OCTET_STRING_set (p12->mac->dinfo->digest, mac, maclen))) {
+ 		PKCS12err(PKCS12_F_PKCS12_PKCS12_SET_MAC,PKCS12_R_MAC_STRING_SET_ERROR);
+ 						return 0;
+ 	}
+ 	return 1;
+ }
+ 
+ /* Set up a mac structure */
+ int PKCS12_setup_mac (p12, iter, salt, saltlen, md_type)
+ PKCS12 *p12;
+ int iter;
+ unsigned char *salt;
+ int saltlen;
+ EVP_MD *md_type;
+ {
+ 	if (!(p12->mac = PKCS12_MAC_DATA_new ())) return PKCS12_ERROR;
+ 	if (iter > 1) {
+ 		if(!(p12->mac->iter = ASN1_INTEGER_new())) {
+ 			PKCS12err(PKCS12_F_PKCS12_SETUP_MAC, ERR_R_MALLOC_FAILURE);
+ 			return 0;
+ 		}
+ 		ASN1_INTEGER_set (p12->mac->iter, iter);
+ 	}
+ 	if (!saltlen) saltlen = PKCS12_SALT_LEN;
+ 	p12->mac->salt->length = saltlen;
+ 	if (!(p12->mac->salt->data = Malloc (saltlen))) {
+ 		PKCS12err(PKCS12_F_PKCS12_SETUP_MAC, ERR_R_MALLOC_FAILURE);
+ 		return 0;
+ 	}
+ 	if (!salt) RAND_bytes (p12->mac->salt->data, saltlen);
+ 	else memcpy (p12->mac->salt->data, salt, saltlen);
+ 	p12->mac->dinfo->algor->algorithm = OBJ_nid2obj (EVP_MD_type(md_type));
+ 	if (!(p12->mac->dinfo->algor->parameter = ASN1_TYPE_new())) {
+ 		PKCS12err(PKCS12_F_PKCS12_SETUP_MAC, ERR_R_MALLOC_FAILURE);
+ 		return 0;
+ 	}
+ 	p12->mac->dinfo->algor->parameter->type = V_ASN1_NULL;
+ 	
+ 	return 1;
+ }
diff -crN tmp/SSLeay-0.8.1/crypto/pkcs12/p12_pack.c SSLeay-0.8.1/crypto/pkcs12/p12_pack.c
*** tmp/SSLeay-0.8.1/crypto/pkcs12/p12_pack.c	Thu Jan  1 01:00:00 1970
--- SSLeay-0.8.1/crypto/pkcs12/p12_pack.c	Tue Nov 18 14:16:07 1997
***************
*** 0 ****
--- 1,103 ----
+ /* Copyright Dr Stephen Henson 1997. All rights reserved.
+  * The conditions of use are identical to those of SSLeay except that my
+  * name (in addition to Eric Young or Tim Hudson) must be mentioned
+  * if this software is used in a product and the notice "This product
+  * includes software written by Dr Stephen Henson (shenson@bigfoot.com)"
+  * used.
+  */
+ #include <stdio.h>
+ #include <stdlib.h>
+ #include <objects.h>
+ #include <asn1.h>
+ #include <asn1_mac.h>
+ #include <err.h>
+ #include <crypto.h>
+ #include <stack.h>
+ #include "pkcs12.h"
+ 
+ /* Turn an ASN1 encoded sequence into a STACK of structures */
+ 
+ STACK *PKCS12_struct_unpack (buf, len, d2i)
+ unsigned char *buf;
+ int len;
+ char *(*d2i)();
+ {
+     STACK *sk;
+     unsigned char *pbuf;
+     pbuf =  buf;
+     if (!(sk = d2i_ASN1_SET (NULL, &pbuf, len, d2i, V_ASN1_SEQUENCE,
+ 							 V_ASN1_UNIVERSAL)))
+ 		 PKCS12err(PKCS12_F_PKCS12_STRUCT_UNPACK,PKCS12_R_DECODE_ERROR);
+     return sk;
+ }
+ 
+ /* Turn a STACK of structures into an ASN1 encoded sequence */
+ 
+ unsigned char *PKCS12_struct_pack (safes, i2d, buf, len)
+ STACK *safes;
+ int (*i2d)();
+ unsigned char **buf;
+ int *len;
+ {
+ 	int safelen;
+ 	unsigned char *safe, *p;
+ 	if (!(safelen = i2d_ASN1_SET (safes, NULL, i2d, V_ASN1_SEQUENCE,
+ 						 V_ASN1_UNIVERSAL))) {
+ 		PKCS12err(PKCS12_F_PKCS12_STRUCT_PACK,PKCS12_R_ENCODE_ERROR);
+ 		return NULL;
+ 	}
+ 	if (!(safe = Malloc (safelen))) {
+ 		PKCS12err(PKCS12_F_PKCS12_STRUCT_PACK,ERR_R_MALLOC_FAILURE);
+ 		return NULL;
+ 	}
+ 	p = safe;
+ 	i2d_ASN1_SET (safes, &p, i2d, V_ASN1_SEQUENCE, V_ASN1_UNIVERSAL);
+ 	if (len) *len = safelen;
+ 	if (buf) *buf = safe;
+ 	return safe;
+ }
+ 
+ /* Extract an ASN1 object from an OCTET STRING */
+ 
+ char *PKCS12_unpack_octet (oct, d2i)
+ ASN1_OCTET_STRING *oct;
+ char *(*d2i)();
+ {
+ 	unsigned char *p, *ret;
+ 	p = oct->data;
+ 	if(!(ret = d2i(NULL, &p, oct->length)))
+ 		PKCS12err(PKCS12_F_PKCS12_UNPACK_OCTET,PKCS12_R_DECODE_ERROR);
+ 	return ret;
+ }
+ 
+ /* Pack an ASN1 object into an OCTET STRING */
+ 
+ ASN1_OCTET_STRING *PKCS12_pack_octet (obj, i2d, oct)
+ char *obj;
+ int (*i2d)();
+ ASN1_OCTET_STRING **oct;
+ {
+ 	unsigned char *p;
+ 	ASN1_OCTET_STRING *octmp;
+ 
+ 	if (!oct || !*oct) {
+ 		if (!(octmp = ASN1_OCTET_STRING_new ())) {
+ 			PKCS12err(PKCS12_F_PKCS12_PACK_OCTET,ERR_R_MALLOC_FAILURE);
+ 			return NULL;
+ 		}
+ 		if (oct) *oct = octmp;
+ 	} else octmp = *oct;
+ 		
+ 	if (!(octmp->length = i2d(obj, NULL))) {
+ 		PKCS12err(PKCS12_F_PKCS12_PACK_OCTET,PKCS12_R_ENCODE_ERROR);
+ 		return NULL;
+ 	}
+ 	if (!(p = Malloc (octmp->length))) {
+ 		PKCS12err(PKCS12_F_PKCS12_PACK_OCTET,ERR_R_MALLOC_FAILURE);
+ 		return NULL;
+ 	}
+ 	octmp->data = p;
+ 	i2d (obj, &p);
+ 	return octmp;
+ }
+ 
diff -crN tmp/SSLeay-0.8.1/crypto/pkcs12/p12_utl.c SSLeay-0.8.1/crypto/pkcs12/p12_utl.c
*** tmp/SSLeay-0.8.1/crypto/pkcs12/p12_utl.c	Thu Jan  1 01:00:00 1970
--- SSLeay-0.8.1/crypto/pkcs12/p12_utl.c	Tue Nov 18 14:16:07 1997
***************
*** 0 ****
--- 1,55 ----
+ /* Copyright Dr Stephen Henson 1997. All rights reserved.
+  * The conditions of use are identical to those of SSLeay except that my
+  * name (in addition to Eric Young or Tim Hudson) must be mentioned
+  * if this software is used in a product and the notice "This product
+  * includes software written by Dr Stephen Henson (shenson@bigfoot.com)"
+  * used.
+  */
+ #include <stdio.h>
+ #include <stdlib.h>
+ #include <objects.h>
+ #include <asn1.h>
+ #include <asn1_mac.h>
+ #include <x509.h>
+ #include <pkcs7.h>
+ #include <err.h>
+ #include <crypto.h>
+ #include <stack.h>
+ #include <evp.h>
+ #include <rand.h>
+ #include "pkcs12.h"
+ 
+ /* Cheap and nasty Unicode stuff */
+ 
+ unsigned char *asc2uni (asc, uni, unilen)
+ unsigned char *asc, **uni;
+ int *unilen;
+ {
+ 	int ulen, i;
+ 	unsigned char *unitmp;
+ 	ulen = strlen(asc)*2  + 2;
+ 	if (!(unitmp = Malloc (ulen))) return NULL;
+ 	for (i = 0; i < ulen; i+=2) {
+ 		unitmp[i] = 0;
+ 		unitmp[i + 1] = asc[i>>1];
+ 	}
+ 	if (unilen) *unilen = ulen;
+ 	if (uni) *uni = unitmp;
+ 	return unitmp;
+ }
+ 
+ char *uni2asc (uni, unilen)
+ unsigned char *uni;
+ int unilen;
+ {
+ 	int asclen, i;
+ 	char *asctmp;
+ 	asclen = unilen / 2;
+ 	/* If no terminating zero allow for one */
+ 	if (uni[unilen - 1]) asclen++;
+ 	uni++;
+ 	if (!(asctmp = Malloc (asclen))) return NULL;
+ 	for (i = 0; i < unilen; i+=2) asctmp[i>>1] = uni[i];
+ 	asctmp[asclen - 1] = 0;
+ 	return asctmp;
+ }
diff -crN tmp/SSLeay-0.8.1/crypto/pkcs12/pkcs12.h SSLeay-0.8.1/crypto/pkcs12/pkcs12.h
*** tmp/SSLeay-0.8.1/crypto/pkcs12/pkcs12.h	Thu Jan  1 01:00:00 1970
--- SSLeay-0.8.1/crypto/pkcs12/pkcs12.h	Tue Nov 18 14:16:07 1997
***************
*** 0 ****
--- 1,225 ----
+ /* Copyright Dr Stephen Henson 1997. All rights reserved.
+  * The conditions of use are identical to those of SSLeay except that my
+  * name (in addition to Eric Young or Tim Hudson) must be mentioned
+  * if this software is used in a product and the notice "This product
+  * includes software written by Dr Stephen Henson (shenson@bigfoot.com)"
+  * used.
+  */
+ 
+ #ifndef HEADER_PKCS12_H
+ #define HEADER_PKCS12_H
+ 
+ #ifdef __cplusplus
+ extern "C" {
+ #endif
+ 
+ #define PKCS12_KEY_ID	1
+ #define PKCS12_IV_ID	2
+ #define PKCS12_MAC_ID	3
+ 
+ #define PKCS12_MAC_KEY_LENGTH 20
+ 
+ #define PKCS12_SALT_LEN	8
+ 
+ typedef struct {
+ X509_SIG *dinfo;
+ ASN1_OCTET_STRING *salt;
+ ASN1_INTEGER *iter;	/* defaults to 1 */
+ } PKCS12_MAC_DATA;
+ 
+ typedef struct {
+ ASN1_INTEGER *version;
+ PKCS12_MAC_DATA *mac;
+ PKCS7 *authsafes;
+ } PKCS12;
+ 
+ typedef struct {
+ ASN1_OCTET_STRING *salt;
+ ASN1_INTEGER *iter;
+ } PBEPARAM;
+ 
+ typedef struct pkcs8_priv_key_info_st {
+ ASN1_INTEGER *version;
+ X509_ALGOR *pkeyalg;
+ ASN1_OCTET_STRING *pkey;
+ STACK *attributes;
+ } PKCS8_PRIV_KEY_INFO;
+ 
+ typedef struct {
+ ASN1_OBJECT *type;
+ union {
+ 	struct pkcs12_bag_st *bag; /* secret, crl and certbag */
+ 	struct pkcs8_priv_key_info_st	*keybag; /* keybag */
+ 	X509_SIG *shkeybag; /* shrouded key bag */
+ 	STACK /* PKCS12_SAFEBAG */ *safes;
+ 	ASN1_TYPE *other;
+ }value;
+ STACK *attrib;
+ ASN1_TYPE *rest;
+ } PKCS12_SAFEBAG;
+ 
+ typedef struct pkcs12_bag_st {
+ ASN1_OBJECT *type;
+ union {
+ 	ASN1_OCTET_STRING *x509cert;
+ 	ASN1_OCTET_STRING *x509crl;
+ 	ASN1_OCTET_STRING *octet;
+ 	ASN1_IA5STRING *sdsicert;
+ 	ASN1_TYPE *other; /* Secret or other bag */
+ }value;
+ } PKCS12_BAGS;
+ 
+ typedef struct {
+ int pbe_nid;
+ EVP_CIPHER *(*cipher)();
+ } PBECTL;
+ 
+ #define PKCS12_ERROR	0
+ #define PKCS12_OK	1
+ 
+ #define M_PKCS12_x5092certbag(x509) \
+ PKCS12_pack_safebag ((char *)(x509), i2d_X509, NID_x509Certificate, NID_certBag)
+ 
+ #define M_PKCS12_x509crl2certbag(crl) \
+ PKCS12_pack_safebag ((char *)(crl), i2d_X509CRL, NID_x509Crl, NID_crlBag)
+ 
+ #define M_PKCS12_certbag2x509(bag) \
+ (X509 *) PKCS12_unpack_octet ((bag)->value.bag->value.octet, \
+ (char *(*)())d2i_X509)
+ 
+ #define M_PKCS12_certbag2x509crl(bag) \
+ (X509CRL *) PKCS12_unpack_octet ((bag)->value.bag->value.octet, \
+ (char *(*)())d2i_X509CRL)
+ 
+ #define M_PKCS12_pkcs82rsa(p8) \
+ (RSA *) PKCS12_unpack_octet ((p8)->pkey, (char *(*)())d2i_RSAPrivateKey)
+ 
+ #define M_PKCS12_unpack_p7data(p7) \
+ PKCS12_struct_unpack ((p7)->d.data->data, p7->d.data->length, \
+ 					 (char *(*)())d2i_PKCS12_SAFEBAG)
+ 
+ #define M_PKCS12_pack_authsafes(p12, safes) \
+ PKCS12_struct_pack ((safes), (int (*)())i2d_PKCS7,\
+ 	&(p12)->authsafes->d.data->data, &(p12)->authsafes->d.data->length)
+ 
+ #define M_PKCS12_unpack_authsafes(p12) \
+ PKCS12_struct_unpack ((p12)->authsafes->d.data->data, \
+ 		(p12)->authsafes->d.data->length, (char *(*)())d2i_PKCS7)
+ 
+ #define M_PKCS12_unpack_p7encdata(p7, pass, passlen) \
+ (STACK *) PKCS12_decrypt_d2i ((p7)->d.encrypted->enc_data->algorithm,\
+ 			 (char *(*)())d2i_PKCS12_SAFEBAG, (pass), (passlen),\
+ 			(p7)->d.encrypted->enc_data->enc_data, 1)
+ 
+ #define M_PKCS12_decrypt_skey(bag, pass, passlen) \
+ (PKCS8_PRIV_KEY_INFO *) PKCS12_decrypt_d2i ((bag)->value.shkeybag->algor, \
+ (char *(*)())d2i_PKCS8_PRIV_KEY_INFO, (pass), (passlen), \
+ 			 (bag)->value.shkeybag->digest, 0)
+ 
+ #ifndef NOPROTO
+ int i2d_PKCS8_PRIV_KEY_INFO(PKCS8_PRIV_KEY_INFO *a, unsigned char **pp);
+ PKCS8_PRIV_KEY_INFO *PKCS8_PRIV_KEY_INFO_new(void);
+ PKCS8_PRIV_KEY_INFO *d2i_PKCS8_PRIV_KEY_INFO(PKCS8_PRIV_KEY_INFO **a, unsigned char **pp, long length);
+ void PKCS8_PRIV_KEY_INFO_free(PKCS8_PRIV_KEY_INFO *a);
+ PKCS12_SAFEBAG *PKCS12_pack_safebag(char *obj, int (*i2d)(), int nid1, int nid2);
+ PKCS8_PRIV_KEY_INFO *rsa2PKCS8(RSA *rsa);
+ PKCS12_SAFEBAG *PKCS12_MAKE_KEYBAG(PKCS8_PRIV_KEY_INFO *p8);
+ PKCS12_SAFEBAG *PKCS12_MAKE_SHKEYBAG(int pbe_nid, unsigned char *pass, int passlen, unsigned char *salt, int saltlen, int iter, PKCS8_PRIV_KEY_INFO *p8);
+ PKCS7 *PKCS12_pack_p7data(STACK *sk);
+ PKCS7 *PKCS12_pack_p7encdata(int pbe_nid, unsigned char *pass, int passlen, unsigned char *salt, int saltlen, int iter, STACK *bags);
+ int PKCS12_add_localkeyid(PKCS12_SAFEBAG *bag, unsigned char *name, int namelen);
+ int PKCS12_add_friendlyname(PKCS12_SAFEBAG *bag, unsigned char *name, int namelen);
+ ASN1_TYPE *PKCS12_get_attr(PKCS12_SAFEBAG *bag, int attr_nid);
+ int PKCS12_CipherInit(int pbe_nid, unsigned char *pass, int passlen, unsigned char *salt, int saltlen, int iter, EVP_CIPHER_CTX *ctx, int en_de);
+ int PKCS12_ALGOR_CipherInit(X509_ALGOR *algor, unsigned char *pass, int passlen, EVP_CIPHER_CTX *ctx, int en_de);
+ unsigned char *PKCS12_pbe_crypt(X509_ALGOR *algor, unsigned char *pass, int passlen, unsigned char *in, int inlen, unsigned char **data, int *datalen, int en_de);
+ char *PKCS12_decrypt_d2i(X509_ALGOR *algor, char *(*d2i)(), unsigned char *pass, int passlen, ASN1_STRING *oct, int seq);
+ ASN1_STRING *PKCS12_i2d_encrypt(X509_ALGOR *algor, int (*i2d)(), unsigned char *pass, int passlen, char *obj, int seq);
+ PKCS12 *PKCS12_init(int mode);
+ X509_ALGOR *PKCS12_pbe_set(int alg, int iter, unsigned char *salt, int saltlen);
+ int PKCS12_key_gen(unsigned char *pass, int passlen, unsigned char *salt, int saltlen, int id, int iter, int n, unsigned char *out, EVP_MD *md_type);
+ int PKCS12_gen_mac(PKCS12 *p12, unsigned char *pass, int passlen, unsigned char *mac, unsigned int *maclen);
+ int PKCS12_verify_mac(PKCS12 *p12, unsigned char *pass, int passlen);
+ int PKCS12_set_mac(PKCS12 *p12, unsigned char *pass, int passlen, unsigned char *salt, int saltlen, int iter, EVP_MD *md_type);
+ int PKCS12_setup_mac(PKCS12 *p12, int iter, unsigned char *salt, int saltlen, EVP_MD *md_type);
+ STACK *PKCS12_struct_unpack(unsigned char *buf, int len, char *(*d2i)());
+ unsigned char *PKCS12_struct_pack(STACK *safes, int (*i2d)(), unsigned char **buf, int *len);
+ char *PKCS12_unpack_octet(ASN1_STRING *oct, char *(*d2i)());
+ ASN1_STRING *PKCS12_pack_octet(char *obj, int (*i2d)(), ASN1_STRING **oct);
+ unsigned char *asc2uni(unsigned char *asc, unsigned char **uni, int *unilen);
+ char *uni2asc(unsigned char *uni, int unilen);
+ int i2d_PKCS12_BAGS(PKCS12_BAGS *a, unsigned char **pp);
+ PKCS12_BAGS *PKCS12_BAGS_new(void);
+ PKCS12_BAGS *d2i_PKCS12_BAGS(PKCS12_BAGS **a, unsigned char **pp, long length);
+ void PKCS12_BAGS_free(PKCS12_BAGS *a);
+ int i2d_PKCS12(PKCS12 *a, unsigned char **pp);
+ PKCS12 *d2i_PKCS12(PKCS12 **a, unsigned char **pp, long length);
+ PKCS12 *PKCS12_new(void);
+ void PKCS12_free(PKCS12 *a);
+ int i2d_PKCS12_MAC_DATA(PKCS12_MAC_DATA *a, unsigned char **pp);
+ PKCS12_MAC_DATA *PKCS12_MAC_DATA_new(void);
+ PKCS12_MAC_DATA *d2i_PKCS12_MAC_DATA(PKCS12_MAC_DATA **a, unsigned char **pp, long length);
+ void PKCS12_MAC_DATA_free(PKCS12_MAC_DATA *a);
+ int i2d_PBEPARAM(PBEPARAM *a, unsigned char **pp);
+ PBEPARAM *PBEPARAM_new(void);
+ PBEPARAM *d2i_PBEPARAM(PBEPARAM **a, unsigned char **pp, long length);
+ void PBEPARAM_free(PBEPARAM *a);
+ int i2d_PKCS12_SAFEBAG(PKCS12_SAFEBAG *a, unsigned char **pp);
+ PKCS12_SAFEBAG *PKCS12_SAFEBAG_new(void);
+ PKCS12_SAFEBAG *d2i_PKCS12_SAFEBAG(PKCS12_SAFEBAG **a, unsigned char **pp, long length);
+ void PKCS12_SAFEBAG_free(PKCS12_SAFEBAG *a);
+ #else
+ int i2d_PKCS8_PRIV_KEY_INFO();
+ PKCS8_PRIV_KEY_INFO *PKCS8_PRIV_KEY_INFO_new();
+ PKCS8_PRIV_KEY_INFO *d2i_PKCS8_PRIV_KEY_INFO();
+ void PKCS8_PRIV_KEY_INFO_free();
+ PKCS12_SAFEBAG *PKCS12_pack_safebag();
+ PKCS8_PRIV_KEY_INFO *rsa2PKCS8();
+ PKCS12_SAFEBAG *PKCS12_MAKE_KEYBAG();
+ PKCS12_SAFEBAG *PKCS12_MAKE_SHKEYBAG();
+ PKCS7 *PKCS12_pack_p7data();
+ PKCS7 *PKCS12_pack_p7encdata();
+ int PKCS12_add_localkeyid();
+ int PKCS12_add_friendlyname();
+ ASN1_TYPE *PKCS12_get_attr();
+ int PKCS12_CipherInit();
+ int PKCS12_ALGOR_CipherInit();
+ unsigned char *PKCS12_pbe_crypt();
+ char *PKCS12_decrypt_d2i();
+ ASN1_STRING *PKCS12_i2d_encrypt();
+ PKCS12 *PKCS12_init();
+ X509_ALGOR *PKCS12_pbe_set();
+ int PKCS12_key_gen();
+ int PKCS12_gen_mac();
+ int PKCS12_verify_mac();
+ int PKCS12_set_mac();
+ int PKCS12_setup_mac();
+ STACK *PKCS12_struct_unpack();
+ unsigned char *PKCS12_struct_pack();
+ char *PKCS12_unpack_octet();
+ ASN1_STRING *PKCS12_pack_octet();
+ unsigned char *asc2uni();
+ char *uni2asc();
+ int i2d_PKCS12_BAGS();
+ PKCS12_BAGS *PKCS12_BAGS_new();
+ PKCS12_BAGS *d2i_PKCS12_BAGS();
+ void PKCS12_BAGS_free();
+ int i2d_PKCS12();
+ PKCS12 *d2i_PKCS12();
+ PKCS12 *PKCS12_new();
+ void PKCS12_free();
+ int i2d_PKCS12_MAC_DATA();
+ PKCS12_MAC_DATA *PKCS12_MAC_DATA_new();
+ PKCS12_MAC_DATA *d2i_PKCS12_MAC_DATA();
+ void PKCS12_MAC_DATA_free();
+ int i2d_PBEPARAM();
+ PBEPARAM *PBEPARAM_new();
+ PBEPARAM *d2i_PBEPARAM();
+ void PBEPARAM_free();
+ int i2d_PKCS12_SAFEBAG();
+ PKCS12_SAFEBAG *PKCS12_SAFEBAG_new();
+ PKCS12_SAFEBAG *d2i_PKCS12_SAFEBAG();
+ void PKCS12_SAFEBAG_free();
+ #endif
+ 
+ /* BEGIN ERROR CODES */
diff -crN tmp/SSLeay-0.8.1/doc/pk12api.doc SSLeay-0.8.1/doc/pk12api.doc
*** tmp/SSLeay-0.8.1/doc/pk12api.doc	Thu Jan  1 01:00:00 1970
--- SSLeay-0.8.1/doc/pk12api.doc	Tue Nov 18 14:16:07 1997
***************
*** 0 ****
--- 1,181 ----
+ The pkcs12 support has been tested with pre-release files from both Microsoft
+ and Netscape.
+ 
+ Here are a few technical notes about the code, if in doubt try the source :-)
+ apps/pkcs12.c is a good demo application that uses the macros/functions.
+ 
+ PKCS#12 objects can be properly manipulated by using a set of macros and
+ functions without having to delve too much into the low-level stuff.
+ 
+ A PKCS#12 object contains several levels.
+ 
+ At the lowest level is a PKCS12_SAFEBAG this can contain a certificate, a
+ CRL, a private key, encrypted or unencrypted, a set of safebags (so the
+ structure can be nested) or other secrets (not documented at present). 
+ A safebag can optionally have attributes, currently these are: a unicode
+ friendlyName (a Unicode string) or a localKeyID (a string of bytes).
+ 
+ At the next level is an authSafe which is a set of safebags collected into
+ a PKCS#7 ContentInfo. This can be just plain data, or encrypted itself.
+ 
+ At the top level is the PKCS12 structure itself which contains a set of
+ authSafes in an embedded PKCS#7 Contentinfo of type data. In addition it
+ contains a MAC which is a kind of password protected digest to preserve
+ integrity (so any unencrypted stuff below can't be tampered with).
+ 
+ The reason for these levels is so various objects can be encrypted in various
+ ways. For example you might want to encrypt a set of private keys with
+ triple-DES and then include the related certificates either unencrypted or with
+ lower encryption. Yes it's the dreaded ITAR at work again which allows strong
+ encryption on private keys and only weak encryption on other stuff.
+ 
+ So basically to build one of these things you turn all certificates and keys
+ into safebags (with optional attributes). You collect the safebags into (one
+ or more) STACKS and convert these into authsafes (encrypted or unencrypted).
+ The authsafes are collected into a STACK and added to a PKCS12 structure.
+ Finally a MAC inserted.
+ 
+ Pulling one apart is basically the reverse process.
+ 
+ Anyway here are the functions that do the dirty work.
+ 
+ 1. Construction functions.
+ 
+ 1.1 Safebag functions.
+ 
+ M_PKCS12_x5092certbag(x509)
+ 
+ This macro takes an x509 structure and returns a certificate bag.
+ 
+ M_PKCS12_x509crl2certbag(crl)
+ 
+ As above but for a CRL.
+ 
+ PKCS8_PRIV_KEY_INFO *rsa2PKCS8(RSA *rsa)
+ 
+ Take an RSA key and convert it into a PKCS#8 PrivateKeyInfo structure.
+ 
+ PKCS12_SAFEBAG *PKCS12_MAKE_KEYBAG(PKCS8_PRIV_KEY_INFO *p8)
+ 
+ Convert a PKCS8 private key structure into a keybag.
+ 
+ PKCS12_SAFEBAG *PKCS12_MAKE_SHKEYBAG(int pbe_nid, unsigned char *pass, int passlen, unsigned char *salt, int saltlen, int iter, PKCS8_PRIV_KEY_INFO *p8)
+ 
+ Convert a PKCS#8 structure into a shrouded key bag (encrypted).
+ 
+ int PKCS12_add_localkeyid(PKCS12_SAFEBAG *bag, unsigned char *name, int namelen)
+ int PKCS12_add_friendlyname(PKCS12_SAFEBAG *bag, unsigned char *name, int namelen)
+ 
+ Add a local key id or a friendlyname to a safebag.
+ 
+ 1.2 Authsafe functions.
+ 
+ PKCS7 *PKCS12_pack_p7data(STACK *sk)
+ Take a stack of safebags and convert them into an unencrypted authsafe.
+ 
+ PKCS7 *PKCS12_pack_p7encdata(int pbe_nid, unsigned char *pass, int passlen, unsigned char *salt, int saltlen, int iter, STACK *bags);
+ 
+ As above but encrypted.
+ 
+ 1.3 PKC12 functions.
+ 
+ PKCS12 *PKCS12_init(int mode)
+ 
+ Initialise a PKCS12 structure (currently mode should be NID_pkcs7_data).
+ 
+ M_PKCS12_pack_authsafes(p12, safes)
+ 
+ This macro takes a STACK of authsafes and adds them to a PKCS#12 structure.
+ 
+ int PKCS12_set_mac(PKCS12 *p12, unsigned char *pass, int passlen, unsigned char *salt, int saltlen, int iter, EVP_MD *md_type);
+ 
+ Add a MAC to a PKCS12 structure. If EVP_MD is NULL use SHA-1, the spec suggests
+ that SHA-1 should be used.
+ 
+ 2. Extraction Functions.
+ 
+ 2.1 Safebags.
+ 
+ M_PKCS12_certbag2x509(bag)
+ 
+ This macro extracts an X509 certificate from a certificate bag.
+ 
+ M_PKCS12_certbag2x509crl(bag)
+ 
+ As above but for a CRL.
+ 
+ M_PKCS12_pkcs82rsa(p8)
+ 
+ Extract an RSA key from a PKCS8 private key info structure.
+ 
+ M_PKCS12_decrypt_skey(bag, pass, passlen) 
+ 
+ Decrypt a shrouded key bag and return a PKCS8 private key info structure.
+ 
+ 2.2 AuthSafe functions.
+ 
+ M_PKCS12_unpack_p7data(p7)
+ 
+ Extract a STACK of safe bags from a PKCS#7 data ContentInfo.
+ 
+ #define M_PKCS12_unpack_p7encdata(p7, pass, passlen)
+ 
+ As above but for an encrypted content info.
+ 
+ 2.3 PKCS12 functions.
+ 
+ M_PKCS12_unpack_authsafes(p12)
+ 
+ Extract a STACK of authsafes from a PKCS12 structure.
+ 
+ int PKCS12_verify_mac(PKCS12 *p12, unsigned char *pass, int passlen)
+ 
+ Verify a MAC on a PKCS12 structure.
+ 
+ 
+ Notes.
+ 
+ 1. All the function return 0 or NULL on error.
+ 2. Encryption based functions take a common set of parameters. These are
+ described below.
+ 
+ pass, passlen
+ Unicode password and length. The password on the MAC is called the "integrity
+ password" the encryption password is called the "privacy password" in the
+ PKCS#12 documentation. The passwords do not have to be the same.
+ 
+ salt, saltlen
+ A 'salt' if salt is NULL a random salt is used. If saltlen is also zero a
+ default length is used.
+ 
+ iter
+ Iteration count. This is a measure of how many times an internal function is
+ called to encrypt the data. The larger this value is the longer it takes, it
+ makes dictionary attacks on passwords harder. NOTE: Some implementations do
+ not support an iteration count on the MAC. If the password for the MAC and
+ encryption is the same then there is no point in having a high iteration
+ count for encryption if the MAC has no count. The MAC could be attacked
+ and the password used for the main decryption.
+ 
+ pbe_nid
+ This is the NID of the password based encryption method used. The following are
+ supported.
+ NID_pbe_WithSHA1And128BitRC4
+ NID_pbe_WithSHA1And40BitRC4
+ NID_pbe_WithSHA1And3_Key_TripleDES_CBC
+ NID_pbe_WithSHA1And2_Key_TripleDES_CBC
+ NID_pbe_WithSHA1And128BitRC2_CBC
+ NID_pbe_WithSHA1And40BitRC2_CBC
+ 
+ Which you use depends on the implementation you are exporting to. ITAR may mean
+ that "export grade" products cannot support all algorithms. Typically you may
+ be able to use any encryption on shrouded key bags but they must then be placed
+ in an unencrypted authsafe. Other authsafes may only support 40bit encryption.
+ Of course if you are using SSLeay throughout you can strongly encrypt everything
+ and have high iteration counts on everything.
+ 
+ 3. For decryption routines only the password and length are needed.
+ 
+ Steve.
+ 
+ shenson@bigfoot.com
diff -crN tmp/SSLeay-0.8.1/doc/pkcs12.doc SSLeay-0.8.1/doc/pkcs12.doc
*** tmp/SSLeay-0.8.1/doc/pkcs12.doc	Thu Jan  1 01:00:00 1970
--- SSLeay-0.8.1/doc/pkcs12.doc	Tue Nov 18 14:16:38 1997
***************
*** 0 ****
--- 1,64 ----
+ The program "pkcs12" is a utility which uses the PKCS#12 routines. It can
+ be used to pull apart and create PKCS#12 files. In particular it is
+ compatible with MSIE 4.0 and Netscape 4.04 implementations.
+ 
+ Each option is described in more detail below.
+ 
+ -export means output a PKCS#12 file from a key/certificate file being input.
+ -chain  adds all the certificates up to the root in addition to the user
+         certificate (-export only).
+ -name   adds a "friendly name" to a certificate. This is the name that appears
+         in the Netscape list box (-export only).
+ -in	input filename either a PKCS#12 file or certificate/key file (-export).
+ -inkey	private key filename (-export only) if not present use input file.
+ -out    output filename either a PKCS#12 file (-export) or a file where
+         certificates and keys will be dumped.
+ -noout  don't output any certificates/keys just verify MAC/encryption.
+ -nokeys don't output any private keys.
+ -info   print more info about PKCS#12 structure, for example types of bags and
+         the encryption used.
+ -des    encrypt private keys with DES
+ -des3   encrypt private keys with triple DES (default)
+ -idea   encrypt private keys with idea
+ -nodes  don't encrypt private keys (not recommended)
+ -certfile add all certificates in a file as well.
+ 
+ Examples:
+ 
+ 1. Pull apart MSIE/Netscape file.
+ 
+ pkcs12 -in file.p12 -out cert.pem
+ 
+ You are prompted for an import password (same as input when exporting) and
+ a pass phrase to encrypt the private key with.
+ 
+ 2. Generate MSIE/Netscape file.
+ 
+ pkcs12 -export -name "My Certificate File" -in key.pem -out file.p12
+ 
+ You are prompted for a pass phrase if the input private key is encryupted.
+ You are also prompted for an export password (which you supply to MSIE/NS
+ on import).
+ 
+ 3. MSIE/Netscape full chain.
+ pkcs12 -chain -export -name "My Certificate File" -in key.pem -out file.p12
+ 
+ Same as above except more certificates are added.
+ 
+ Notes on implementations.
+ 
+ MSIE uses RC2-40 for all bags including private keys. The local keyid is
+ set at 01 00 00 00 for the key/certificate pair. It will however import
+ PKCS#12 files with triple-DES private keys.
+ 
+ Netscape uses triple-DES for private keys and RC2-40 for everything else.
+ The local keyid is set at the SHA-1 digest of the certificate for the key
+ and certificate pair. 
+ 
+ My pkcs12 application uses triple-DES for private keys and RC2-40 for
+ everything else. The local keyid is 01 00 00 00 and friendlyname is user
+ definable. It will import any algorithm combinations.
+ 
+ Any comments to:
+ 
+ shenson@bigfoot.com
