head	 1.59;
branch   ;
access   ;
symbols  V80:1.13 V76d:1.2;
locks    ; strict;
comment  @ * @;


1.59
date	 94.09.18.22.46.08;  author jcooper;  state Exp;
branches ;
next	 1.58;

1.58
date	 94.09.18.00.14.53;  author jcooper;  state Exp;
branches ;
next	 1.57;

1.57
date	 94.09.06.12.46.21;  author brydon;  state Exp;
branches ;
next	 1.56;

1.56
date	 94.09.02.19.16.32;  author martin;  state Exp;
branches ;
next	 1.55;

1.55
date	 94.08.24.18.40.15;  author mrr;  state Exp;
branches ;
next	 1.54;

1.54
date	 94.08.24.18.00.29;  author jcooper;  state Exp;
branches ;
next	 1.53;

1.53
date	 94.08.23.23.15.34;  author martin;  state Exp;
branches ;
next	 1.52;

1.52
date	 94.08.11.02.25.59;  author dumoulin;  state Exp;
branches ;
next	 1.51;

1.51
date	 94.08.11.00.09.17;  author jcooper;  state Exp;
branches ;
next	 1.50;

1.50
date	 94.08.04.05.49.30;  author dumoulin;  state Exp;
branches ;
next	 1.49;

1.49
date	 94.07.28.21.56.32;  author rushing;  state Exp;
branches ;
next	 1.48;

1.48
date	 94.07.26.18.39.45;  author dumoulin;  state Exp;
branches ;
next	 1.47;

1.47
date	 94.07.26.16.10.51;  author gardnerd;  state Exp;
branches ;
next	 1.46;

1.46
date	 94.07.25.22.41.22;  author pearse_w_r;  state Exp;
branches ;
next	 1.45;

1.45
date	 94.07.25.18.51.48;  author jcooper;  state Exp;
branches ;
next	 1.44;

1.44
date	 94.06.30.16.37.04;  author dumoulin;  state Exp;
branches ;
next	 1.43;

1.43
date	 94.06.08.21.01.45;  author gardnerd;  state Exp;
branches ;
next	 1.42;

1.42
date	 94.06.06.22.06.13;  author gardnerd;  state Exp;
branches ;
next	 1.41;

1.41
date	 94.06.06.21.23.21;  author mrr;  state Exp;
branches ;
next	 1.40;

1.40
date	 94.06.01.19.00.00;  author gardnerd;  state Exp;
branches ;
next	 1.39;

1.39
date	 94.05.23.19.51.51;  author rushing;  state Exp;
branches ;
next	 1.38;

1.38
date	 94.05.23.18.37.00;  author jcooper;  state Exp;
branches ;
next	 1.37;

1.37
date	 94.05.02.20.32.55;  author rushing;  state Exp;
branches ;
next	 1.36;

1.36
date	 94.03.01.19.10.19;  author rushing;  state Exp;
branches ;
next	 1.35;

1.35
date	 94.02.24.21.28.49;  author jcoop;  state Exp;
branches ;
next	 1.34;

1.34
date	 94.02.16.20.59.17;  author rushing;  state Exp;
branches ;
next	 1.33;

1.33
date	 94.02.04.02.19.12;  author rushing;  state Exp;
branches ;
next	 1.32;

1.32
date	 94.01.24.17.39.47;  author jcoop;  state Exp;
branches ;
next	 1.31;

1.31
date	 94.01.17.21.54.58;  author jcoop;  state Exp;
branches ;
next	 1.30;

1.30
date	 94.01.12.19.25.59;  author mrr;  state Exp;
branches ;
next	 1.29;

1.29
date	 94.01.05.22.36.43;  author mrr;  state Exp;
branches ;
next	 1.28;

1.28
date	 93.12.08.20.21.15;  author dumoulin;  state Exp;
branches ;
next	 1.27;

1.27
date	 93.12.08.01.29.07;  author rushing;  state Exp;
branches ;
next	 1.26;

1.26
date	 93.08.25.18.55.19;  author mbretherton;  state Exp;
branches ;
next	 1.25;

1.25
date	 93.08.18.21.49.21;  author rushing;  state Exp;
branches ;
next	 1.24;

1.24
date	 93.08.17.21.48.44;  author dumoulin;  state Exp;
branches ;
next	 1.23;

1.23
date	 93.08.05.20.06.07;  author jcoop;  state Exp;
branches ;
next	 1.22;

1.22
date	 93.07.13.16.03.04;  author riordan;  state Exp;
branches ;
next	 1.21;

1.21
date	 93.07.09.19.13.36;  author rushing;  state Exp;
branches ;
next	 1.20;

1.20
date	 93.07.06.21.09.09;  author cnolan;  state Exp;
branches ;
next	 1.19;

1.19
date	 93.06.28.17.52.17;  author rushing;  state Exp;
branches ;
next	 1.18;

1.18
date	 93.06.25.20.27.10;  author dumoulin;  state Exp;
branches ;
next	 1.17;

1.17
date	 93.06.22.19.08.56;  author rushing;  state Exp;
branches ;
next	 1.16;

1.16
date	 93.06.22.16.43.58;  author bretherton;  state Exp;
branches ;
next	 1.15;

1.15
date	 93.06.22.16.14.21;  author rushing;  state Exp;
branches ;
next	 1.14;

1.14
date	 93.06.14.17.05.16;  author rushing;  state Exp;
branches ;
next	 1.13;

1.13
date	 93.06.11.00.11.26;  author rushing;  state Exp;
branches ;
next	 1.12;

1.12
date	 93.06.10.18.25.40;  author rushing;  state Exp;
branches ;
next	 1.11;

1.11
date	 93.06.01.18.23.17;  author rushing;  state Exp;
branches ;
next	 1.10;

1.10
date	 93.05.29.03.32.30;  author rushing;  state Exp;
branches ;
next	 1.9;

1.9
date	 93.05.28.17.32.11;  author rushing;  state Exp;
branches ;
next	 1.8;

1.8
date	 93.05.28.17.18.00;  author rushing;  state Exp;
branches ;
next	 1.7;

1.7
date	 93.05.24.23.57.22;  author rushing;  state Exp;
branches ;
next	 1.6;

1.6
date	 93.05.18.22.10.45;  author rushing;  state Exp;
branches ;
next	 1.5;

1.5
date	 93.05.13.20.00.38;  author rushing;  state Exp;
branches ;
next	 1.4;

1.4
date	 93.05.13.16.17.45;  author rushing;  state Exp;
branches ;
next	 1.3;

1.3
date	 93.03.30.20.49.30;  author DUMOULIN;  state Exp;
branches ;
next	 1.2;

1.2
date	 93.03.30.17.08.12;  author rushing;  state Exp;
branches ;
next	 1.1;

1.1
date	 93.02.16.20.54.42;  author rushing;  state Exp;
branches ;
next	 ;


desc
@winvn version 0.76 placed into RCS
@


1.59
log
@More cleanup for 92.6.  Added IsBusy to TypTextBlock
@
text
@/*---- Module WVGLOB.H  -------------------------------------------- */
/* WVGLOB.H contains all the global types and variables for WinVN.   */
/* Stylistically, this should probably be separated into several     */
/* header files, but this is what you've got for now.                */
/* cf WVDOC.C -- it describes some of these structures.              */
/*

 * $Id: wvglob.h 1.58 1994/09/18 00:14:53 jcooper Exp $
 */

#ifdef _WIN32
#ifndef WIN32
#define WIN32
#endif
#endif

#ifdef WIN32
#ifndef _WIN32
#define _WIN32
#endif
#endif

/* these are supposed be defined in windowsx.h, but they aren't in mine! */
#ifndef GET_WM_COMMAND_CMD
 #ifdef WIN32
  #define GET_WM_COMMAND_CMD(wp, lp)  HIWORD(wp)
  #define GET_WM_COMMAND_ID(wp, lp)   LOWORD(wp)
  #define GET_WM_COMMAND_HWND(wp, lp) (HWND)lp)
 #else
  #define GET_WM_COMMAND_CMD(wp, lp)  HIWORD(lp)        
  #define GET_WM_COMMAND_ID(wp, lp)   (wp)              
  #define GET_WM_COMMAND_HWND(wp, lp) ((HWND)LOWORD(lp))
 #endif
#endif

#ifdef WIN32
#define huge far
#endif

#define BUFSIZE			1024
#define TEMPBUFSIZE		1240
#define MAXHEADERLINE		256
#define MAXFINDSTRING		80
#define MAXDIALOGSTRING		255

#define MAXFILENAME		75
#define MAXCHARS		80
#define MAXLINES		24

/* this has been increased for XOVER - some lines are *very* long */
#define MAXCOMMLINE		1536 
#define MAXINTERNALLINE		180
#define MAXOUTLINE		255
#define MAXPOSTLENGTH		60000	/* max length for a posting/mail edit window */
#define MAXBOUNDARYLEN		70	/* max length for MIME boundary  */
#define MAXNEWGROUPSASK		200	/* limit of groups in newgroups dialog box */

#include <time.h>
#include <commdlg.h>

typedef long TypLineID;

typedef struct structtextselect
{
  int LineNum;			/* Line number when selecting text -- Line Ord  */
  int CharNum;			/* Character number when selecting text         */
  /* The 1st LineNum in the Doc and the 1st CharNum in the line are 0   */
}
TextSelect;

typedef struct structdoc
{
  HANDLE hFirstBlock;		/* handle to first textblock in doc.        */
  HANDLE hLastBlock;		/* unused.                                  */
  unsigned int TotalLines;	/* total # of lines in doc.                 */
  unsigned int LongestLine;	/* # of bytes in the longest line of doc    */
  unsigned int HeaderLines;	/* total number of lines in header of doc
				   (incl. blank line) */
  unsigned int ActiveLines;	/* # of selected or otherwise active lines  */
  unsigned int CountedLines;	/* # of counted lines, as in subscr. groups */
  unsigned int BlockSize;	/* # of bytes in a textblock                */
  unsigned int SplitSize;	/* textblock split point in bytes           */
  HANDLE hCurAddBlock;		/* hBlock to point at which to add lines.   */
  unsigned int AddOffset;	/* offset in bytes for point to add lines   */
  TypLineID AddLineID;		/* LineID of place to add lines.            */
  HANDLE hCurTopScBlock;	/* hBlock of current top line of window     */
  unsigned int TopScOffset;
  TypLineID TopScLineID;
  unsigned int TopLineOrd;	/* ordinal in doc of top line in window     */
  HANDLE hLastSeenBlock;
  unsigned int LastSeenOffset;
  TypLineID LastSeenLineID;
  HANDLE hFindBlock;		/* location of place to start next search   */
  unsigned int FindOffset;	/* for "SearchStr"                          */
  TypLineID FindLineID;
  unsigned int FindTextOffset;
  char SearchStr[MAXFINDSTRING]; /* Search string for current search    */
  unsigned int ScXOffset;	/* # of chars offset for horizontal scroll  */
  unsigned int ScXChars;	/* # of chars/line for current window size  */
  unsigned int ScYLines;	/* # of lines that fit in current window    */
  unsigned int ScXWidth;	/* current size of client area of window    */
  unsigned int ScYHeight;
  HWND hDocWnd;
  struct structdoc *ParentDoc;	/* pointer to parent document            */
  HANDLE hParentBlock;		/* points to line in parent doc          */
  unsigned int ParentOffset;	/* that corresponds to/describes this    */
  TypLineID ParentLineID;	/* document                              */
  unsigned int OffsetToText;
  BOOL InUse;			/* TRUE if this TypDoc in use.           */
  int DocType;			/* DOCTYPE_xxx                           */
  BOOL TextSelected;		/* Indicates text selected               */
  TextSelect BeginSelect;	/* Line and Char where selection began   */
  TextSelect EndSelect;		/* Line and Char where selection ended   */
}
TypDoc;

typedef struct structblock
{
  HANDLE hPrevBlock;		/* handle of previous block, or 0               */
  HANDLE hNextBlock;		/* handle of next block in document, or 0       */
  HANDLE hCurBlock;		/* handle of this block                         */
  int LWAp1;			/* # of used data bytes in block, inc header    */
  int NumLines;			/* # of lines in this block                     */
  int NumActiveLines;		/* # of active lines in this block.             */
  TypDoc *OwnerDoc;		/* pointer to document this block is in.        */
  int eob;			/* end-of-block; must be just before 1st line.  */
  /* Text lines */
  /* Another EOB marker */
}
TypBlock;

typedef struct structline
{
  int length;			/* Total # of bytes in line, all-inclusive    */
  TypLineID LineID;		/* Unique identifier for this line.           */
  int active;			/* =1 if line should be displayed, else 0     */
  /* Bytes of text */
  /* Another copy of length */
}
TypLine;

typedef struct structtext
{
  int NameLen;			/* # of bytes of text                          */
}
TypText;

typedef struct structgroup
{
  char Subscribed;		/* =TRUE if subscribed to this group.   */
  char Selected;		/* =TRUE if selected                    */
  char Determined;		/* =TRUE if group info has been retrieved */
  int NameLen;			/* # of bytes in group name             */
  TypDoc *SubjDoc;		/* points to doc containing subjs       */
  unsigned long ServerEstNum;	/* est # of arts in server              */
  unsigned long ServerFirst;	/* # of first art that server has.      */
  unsigned long ServerLast;	/* # of last art that server has.       */
  unsigned long HighestPrevSeen; /* # of highest art server had in last  */
  /* session, from "s<num>" newsrc field  */
  HANDLE header_handle;		/* handle to global block of header array mem */
  HANDLE thread_handle;		/* handle to global block of thread ind. pointers */
  long int total_headers;	/* total # of headers in array */
  unsigned int nRanges;		/* # of TypRanges describing seen arts  */
  /* Name of group *//* name of group, zero-terminated       */
  /* Ranges of articles seen *//* array of TypRanges, of seen articles */
}
TypGroup;

typedef struct structarticle
{
  unsigned long Number;		/* Server's number for this article    */
  char Seen;			/* =TRUE if article seen               */
  char Selected;		/* =TRUE if article selected           */
  TypDoc *ArtDoc;		/* points to doc with actual article   */
  int NameLen;			/* # of bytes in subject line */
  /* Subject line of article */
}
TypArticle;

/* the size of this struct *must* be a power of two for win16.  'huge' */
/* arrays require this. */
/* (+ 1 1 1 4 2 4 105 74 30 30 4) => 256 */

#define HEADER_SUBJECT_LENGTH	105
#define HEADER_FROM_LENGTH	74
#define HEADER_MESSAGE_ID_LENGTH 30
#define HEADER_REFERENCES_LENGTH 30

/* Offset used to calculate offset for LongestLine */
#define ARTICLE_SUBJECT_OFFSET	40
#define GROUP_NAME_OFFSET	10

typedef struct
{
  char Seen;
  char Selected;
  char thread_depth;
  char subject[HEADER_SUBJECT_LENGTH];
  unsigned long number;
  unsigned int lines;
  /*   char date[9];     JD 6/25/93  */
  time_t date;
  char from[HEADER_FROM_LENGTH];
  char message_id[HEADER_MESSAGE_ID_LENGTH];
  char references[HEADER_REFERENCES_LENGTH];
  TypDoc *ArtDoc;
}
TypHeader;

typedef TypHeader huge *header_p;

typedef long huge *thread_array;

typedef thread_array huge *thread_array_p;

typedef char huge *char_p;

typedef struct structrange
{
  long int First;
  long int Last;
}
TypRange;

/* TypMRRFile is used to describe a file; I use it because Windows */
/* doesn't provide much in the way of disk I/O support.  */

typedef struct structMRRfile
{
  HFILE hFile;			/* handle to file                            */
  OFSTRUCT of;
  char buf[BUFSIZE];		/* my I/O buffer.                            */
  HANDLE hthis;			/* handle to this structure                  */
  int bufidx;			/* Index to next place in buf                */
  int bytesread;		/* for reads, # of bytes read in last read   */
  int mode;			/* mode in which to open file.               */
  int eofflag;			/* whether we have reached EOF (read)        */
}
TypMRRFile;

#define CtoX(c) (c*CharWidth + SideSpace)
#define LtoY(l) (l*LineHeight + TopSpace)
#define EDITID   1		/* ID of edit box, to identify for return values */
#define MAXMEMONAME 15		/* Number of chars in memo name */
#define MEMONAMECHARS (MAXMEMONAME+2)
#define MAXVIEWS 10
#define END_OF_BLOCK (-1)
#define BLOCK_SIZE  4096
/*  RangeOffset gives the number of bytes from the beginning of
 *  a Group structure to the first Range field, given the length
 *  of the name entry.
 */
#define RangeOffset(nlen) (((nlen+2)/2)*2 + sizeof(TypGroup))

#ifdef WINMAIN
#define DEF
#else
#define DEF extern
#endif

DEF TypDoc NetDoc;
DEF TypDoc DebugCommDoc;

#define MRR_SCROLL_LINEUP    0
#define MRR_SCROLL_LINEDOWN  1
#define MRR_SCROLL_PAGEUP    2
#define MRR_SCROLL_PAGEDOWN  3

/* This structure maps between keystrokes and mouse events.
 * From an idea on p. 137 of Charles Petzold's book.
 * If you change the definition, be sure to update NUMKEYS.
 */
#define NUMKEYS 6
#ifndef MAC
DEF struct
{
  WORD wVirtKey;
  int CtlState;
  int iMessage;
  WORD wRequest;
}
key2scroll[NUMKEYS]
#ifdef WINMAIN
=
{
  VK_PRIOR, 0, WM_VSCROLL, SB_PAGEUP,
  VK_NEXT, 0, WM_VSCROLL, SB_PAGEDOWN,
  VK_UP, 0, WM_VSCROLL, SB_LINEUP,
  VK_DOWN, 0, WM_VSCROLL, SB_LINEDOWN,
  VK_LEFT, 0, WM_HSCROLL, SB_LINEUP,
  VK_RIGHT, 0, WM_HSCROLL, SB_LINEDOWN
  }
#endif
;
#endif

DEF BOOL Initializing;
#define INIT_DONE                0
#define INIT_READING_NEWSRC      1
#define INIT_ESTAB_CONN          2
#define INIT_SCANNING_NETDOC     3
#define INIT_GETTING_LIST        4
#define INIT_NOT_CONNECTED       5
#define INIT_READY               6

#define MAXGROUPWNDS   4
#define MAXARTICLEWNDS 4
#define MAXPOSTWNDS    20
#define MAXMAILWNDS    20

DEF TypDoc GroupDocs[MAXGROUPWNDS];
DEF TypDoc ArticleDocs[MAXARTICLEWNDS];
DEF int NumGroupWnds;
DEF int NumArticleWnds;

typedef struct WndEditStruct
{
  HWND hWnd;
  HWND hWndEdit;
  int dirty;
  TypDoc *Doc;
}
WndEdit;

#define DT_CLEAN 0
#define DT_INITIALISING -1
#define DT_DIRTY 1

DEF WndEdit WndPosts[MAXPOSTWNDS];
DEF WndEdit WndMails[MAXMAILWNDS];
DEF int NumPostWnds;
DEF int NumMailWnds;

#define DOCTYPE_UNKNOWN  0
#define DOCTYPE_NET      1
#define DOCTYPE_GROUP    2
#define DOCTYPE_ARTICLE  4
#define DOCTYPE_POSTING  8
#define DOCTYPE_MAIL     16

/* Variables and constants for handling the FSA used to deal with    */
/* talking to the NNTP server.                                       */

DEF int CommState;		/* current state in comm FSA */
DEF BOOL CommBusy;		/* =TRUE if comm line busy interacting w/ server */
DEF BOOL CommDecoding;		/* =TRUE if comm line busy decoding lines from server */
DEF WndEdit *PostEdit, *MailEdit;	/* set to post/mail window during send */
DEF TypDoc *CommDoc;		/* Document currently receiving lines from server   */
DEF HWND CommWnd;		/* Window containing details of document currently
				   talking to server */
DEF HWND hVerDlgList;		/* Handle to info in the Version Dialog Box */
DEF char CommLineIn[MAXCOMMLINE];	/* current input line being built by FSA   */
DEF char *CommLinePtr;		/* pointer to next place to put char in CommLineIn  */
DEF char *CommLineLWAp1;	/* if we get this far, we're at end of buffer       */
DEF char IgnoreCommCh;		/* char to ignore when reading from server          */
DEF char EOLCommCh;		/* char that indicates end of line upon input       */
DEF TypDoc *ActiveGroupDoc;
DEF TypDoc *ActiveArticleDoc;

#define MAXGROUPNAME 80
DEF char CurrentGroup[MAXGROUPNAME];	/* name of group currently selected on
					   server */

DEF BOOL UsingSocket;		/* =TRUE if using PC/TCP rather than serial I/O     */

DEF BOOL threadp;
DEF BOOL xoverp;
DEF BOOL force_xhdr;

#define MAXNNTPSIZE 40
DEF char NNTPHost[MAXNNTPSIZE];
DEF char NNTPService[MAXNNTPSIZE];
DEF char SMTPHost[MAXNNTPSIZE];
DEF char NNTPUserName[MAXNNTPSIZE];
DEF char NNTPPasswordEncrypted[2 * MAXNNTPSIZE];
DEF BOOL AuthReqPost;		/* TRUE if we may not post at all unless authenticated */
DEF BOOL AuthReqMail;		/* TRUE if we may not send mail unless authenticated */
DEF BOOL Authenticated		/* TRUE if we've been authenticated by NNTP server */
#ifdef WINMAIN
= FALSE
#endif
 ;
/* This is the name that was successfully authenticated by the NNTP server.
 * It might not be the same as NNTPUserName, if the user has changed the
 * username since the beginning of the session.
 */
DEF char AuthenticatedName[MAXNNTPSIZE];

#define MAILLEN 256
DEF char MailAddress[MAILLEN];
DEF char ReplyTo[MAILLEN];
DEF char UserName[MAILLEN];
DEF char Organization[MAILLEN];

DEF char GenSockDLL[MAXFILENAME];
DEF int ConnectAtStartup;

/* States in the FSA that cracks input lines from the server.             */

#define ST_NONE				0
#define ST_ESTABLISH_COMM		1
#define ST_GROUP_RESP			2
#define ST_XHDR_SUBJECT_START		3
#define ST_XHDR_SUBJECT_DATA		4
#define ST_IN_GROUP			5
#define ST_ARTICLE_RESP			6
#define ST_REC_ARTICLE_HEADER		65
#define ST_REC_ARTICLE			7
#define ST_POST_WAIT_PERMISSION		8
#define ST_POST_WAIT_END		9
#define ST_GROUP_REJOIN			10
#define ST_LIST_RESP			11
#define ST_LIST_GROUPLINE		12
#define ST_MAIL_WAIT_PERMISSION		13
#define ST_MAIL_WAIT_END		14
#define ST_CHECK_AUTHINFO_USERNAME	20
#define ST_CHECK_AUTHINFO_PASSWORD	21
#define ST_END_AUTHINFO			22
#define ST_XHDR_FROM_START		50
#define ST_XHDR_FROM_DATA		51
#define ST_XHDR_SUBJ_START		52
#define ST_XHDR_SUBJ_DATA		53
#define ST_XHDR_REF_START		54
#define ST_XHDR_REF_DATA		55
#define ST_XHDR_MID_START		56
#define ST_XHDR_MID_DATA		57
#define ST_XHDR_DATE_START		58
#define ST_XHDR_DATE_DATA		59
#define ST_XHDR_LINES_START		60
#define ST_XHDR_LINES_DATA		61
#define ST_XOVER_START			62
#define ST_XOVER_DATA			63
#define ST_XOVER_CHECK			64
#define ST_CLOSED_COMM			99

#define LFN_HELP "WINVN.HLP"

/* variables used in an ad hoc attempt to optimize updating of windows
 * by the input cracking FSA. */

#define UPDATE_TITLE_FREQ	10
#define UPDATE_ART_FREQ		12
#define MAX_IMMEDIATE_UPDATE	2
#define STATUS_UPDATE_FREQ	20

DEF unsigned int RcvLineCount;
DEF unsigned int TimesWndUpdated;

DEF TypLineID NextLineID	/* LineID to assign to next created line */
#ifdef WINMAIN
= 10664L
#endif
 ;

DEF HINSTANCE hInst;
DEF HWND hWndConf;		/* handle to NetDoc window */
DEF HWND hWndSk;
DEF HWND hDosWnd;
DEF HWND hWndDebugComm;		/* handle to Debug Comm window */

DEF HANDLE hAccel;		/* handle to main accelerator table */
DEF MSG MainMsg;		/* message returned from GetMessage */

DEF int CommDevice;		/* comm device ID, if using serial I/O */

DEF char str[255];		/* general-purpose string buffer */


DEF HCURSOR hSaveCursor;	/* handle to current cursor      */
DEF HCURSOR hHourGlass;		/* handle to hourglass cursor    */


DEF int X, Y;			/* last cursor position          */
DEF int DragMouseAction;	/* mouse action for dragging      */

#define DRAG_NONE                  0
#define DRAG_SELECT                1
#define DRAG_DESELECT              2
#define SEEN_SELECT                3
#define SEEN_DESELECT              4

DEF POINT ptCursor;		/* x and y coordinates of cursor */

DEF DCB DCBComm;
#define MAXCOMMCHARS 40
DEF char szCommString[MAXCOMMCHARS];	/* string describing serial comm port */


DEF int xPos, yPos;

DEF int ViewNew;
DEF int NewArticleWindow;
DEF int SelectAll;
DEF int NViews;
DEF int DoList;
DEF int did_list;
DEF unsigned int article_threshold;
DEF int arts_to_retrieve;
DEF int savingArtIndex;
DEF int numArtsSaved;
DEF int nextBatchIndex;		/* for batch post/mails */

DEF int ConfirmBatchOps;
DEF int ConfirmExit;
DEF int ConfirmReplyTo;
DEF int ShowUnsubscribed;
DEF int ShowReadArticles;
DEF int DebugComm;
DEF int ShowUnreadOnly;
DEF int SaveNewsrc;
DEF int SaveConfig;
DEF char LastArticleTextFind[MAXINTERNALLINE];
DEF char LastArticleHeaderFind[MAXINTERNALLINE];
DEF char LastGroupNameFind[MAXINTERNALLINE];

#define THREAD_COMPLETE    1
#define THREAD_INCOMPLETE  2

/* AskComm says whether to put up the communications dialog box
 * upon starting up.  Options are never, always, and yes, because
 * this is the first time the program has been run.
 */
#define ASK_COMM_NEVER    0
#define ASK_COMM_ALWAYS   1
#define ASK_COMM_INITIAL  2
DEF int AskComm;
DEF BOOL ArticleFixedFont;
DEF BOOL FullNameFrom;

DEF int xScreen, yScreen;
DEF int CaptionHeight;
DEF HFONT hListFont;		/* handle to font used in group/art lists */
DEF HFONT hFontArtNormal;	/* handle to font used in Article window - normal
				   text mode. */
DEF HFONT hFontArtQuote;	/* handle to font used in Article window - 
				   comments == Italics. */
DEF HFONT hFontPrint;		/* handle to font used for printing. */
DEF HFONT hFontPrintB;		/* handle to font used for bold printing. */
DEF HFONT hFontPrintS;		/* handle to font used for printing Subject line. */
DEF HFONT hFontPrintI;		/* handle to font used for printing Quoted lines. */
DEF HFONT hStatusFont;		/* handle to font used in status windows */

DEF int ListFontSize;
DEF int ArticleFontSize;
DEF int PrintFontSize;
DEF int StatusFontSize;

DEF char ListFontFace[32];
DEF char ListFontStyle[32];
DEF char ArticleFontFace[32];
DEF char ArticleFontStyle[32];
DEF char PrintFontFace[32];
DEF char StatusFontFace[32];
DEF char StatusFontStyle[32];

DEF int LineHeight, CharWidth;		/* # of window units for list font */
DEF int ArtLineHeight, ArtCharWidth;	/* # of windows units for article font */
DEF int StatusLineHeight, StatusCharWidth;	/* # of window units for status font */
DEF int TopSpace, SideSpace;	/* # of window units to leave at top and side  */
			   /* of window (for aesthetic purposes)          */
DEF int ArtTopSpace, ArtSideSpace;	/* # of window units to leave at top and side  */
DEF int StartPen;		/* Similar to TopSpace; where to start pen 1st row */
DEF int ScreenYPixels;		/* used in converting points to logical units */
DEF int PrinterYPixels;		/* used in converting points to logical units */
DEF COLORREF OldTextColor, OldBkColor;
DEF COLORREF NetUnSubscribedColor;	/* color to use for unsubscribed groups  */
DEF COLORREF NetSubscribedColor;	/* color to use for subscribed groups  */
DEF COLORREF ArticleSeenColor;	/* color to use for articles that have been seen */
DEF COLORREF ArticleUnSeenColor;	/* color to use for articles that have not been seen */
DEF COLORREF ArticleTextColor;	/* color to use for article/post text */
DEF COLORREF StatusTextColor;	/* Color to use for status text */
DEF COLORREF ListBackgroundColor; /* background color for group/article listings */
DEF COLORREF ArticleBackgroundColor;	/* background color for article/post windows */
DEF COLORREF StatusBackgroundColor;	/* background color for status windows */
DEF COLORREF CustomColors[16];	/* Custom colors definable by user in ChooseColor */
DEF HBRUSH hListBackgroundBrush;
DEF HBRUSH hArticleBackgroundBrush;
DEF HBRUSH hStatusBackgroundBrush;
DEF BOOL LimitedColor;

DEF int ReverseVideo;
DEF BOOL ThumbTrack;

DEF BOOL MailDemandLogon;	/* FALSE = permanent logon
				   TRUE  = logon on send mail */
DEF int MailForceType;		/*  Force Mail Type to valid value where
				   Less then zero means
				   default negotiation */
DEF int MailLog;		/* True means append to log files */
DEF int PostLog;		/* where XXXXLogFile is file name */


DEF char MailLogFile[MAXFILENAME];
DEF char PostLogFile[MAXFILENAME];

DEF int fmtDaysB4Mth;
DEF char fmtDateDelim[2];


#define QuoteLineInd  '>'

DEF DLGPROC lpfnWinVnSaveArtDlg;
DEF DLGPROC lpfnWinVnSaveArtsDlg;
DEF DLGPROC lpfnWinVnFindDlg;
DEF DLGPROC lpfnWinVnGenericDlg;
DEF DLGPROC lpfnWinVnSubjectDlg;
DEF DLGPROC lpfnWinVnCommDlg;
DEF DLGPROC lpfnWinVnAuthDlg;
DEF DLGPROC lpfnWinVnDoListDlg;
DEF DLGPROC lpfnWinVnPersonalInfoDlg;
DEF DLGPROC lpfnWinVnMiscDlg;
DEF DLGPROC lpfnWinVnAppearanceDlg;
DEF DLGPROC lpfnEditSubClass ;
DEF DLGPROC lpfnWinVnThresholdDlg;
DEF DLGPROC lpfnWinVnLogOptDlg;
DEF DLGPROC lpfnWinVnDecodeArtsDlg;
DEF DLGPROC lpfnWinVnAttachDlg;
DEF DLGPROC lpfnWinVnEncodeDlg;
DEF DLGPROC lpfnWinVnSigFileDlg;
DEF DLGPROC lpfnWinVnExitDlg;
DEF DLGPROC lpfnWinVnMailDlg;
DEF DLGPROC lpfnWinVnSmartFilerDlg;
DEF DLGPROC lpfnWinVnSelectPathDlg;
DEF DLGPROC lpfnWinVnVersionListDlg;

DEF char *szAppName;
DEF char szAppProFile[256];
DEF char szNewsSrc[256];

DEF char SaveArtFileName[MAXFILENAME];
DEF char DecodePathName[MAXFILENAME];
DEF char DialogString[MAXDIALOGSTRING];
DEF char SubjectString[MAXDIALOGSTRING];
DEF char AddressString[MAXDIALOGSTRING];
DEF char NameString[MAXDIALOGSTRING];
DEF char CcAddress[MAXDIALOGSTRING];
DEF BOOL CcByMail;
DEF int  SaveArtAppend;
DEF int  ThreadFullSubject;
DEF BOOL GroupMultiSelect;

DEF TypDoc *PostDoc;		/* Used to pass pointer to article being replied to. */
DEF TypDoc *MailDoc;
DEF TypDoc *FindDoc;
DEF char *NewsgroupsPtr;	/* Used to pass pointer to newsgroup of new posting. */

/* For each new group detected, we create an entry in the following
 * array, NewGroupTable.  Each entry contains a far pointer to a
 * dynamically-allocated global data structure containing a line
 * containing information on this group, in the exact same format
 * as used in the NetDoc.
 */
DEF void huge *huge * NewGroupTable;	/* array of pointers to new group lines */
DEF HANDLE hNewGroupTable;	/* Handle to the above array */
DEF int nNewGroups;
DEF HANDLE hNewGroupData;
DEF void huge *NewGroupData;
DEF unsigned int HashTableSize;
DEF unsigned int LinesInRC;

typedef struct structHier
{
  HANDLE hName;
  int Start;
  int NumGroups;
  HANDLE hNext;
}
TypHier;

#define ADD_SUBSCRIBED_END_OF_SUB	0
#define ADD_SUBSCRIBED_TOP_OF_DOC	1

#define LINE_FLAG_SET			0

#define GROUP_ACTION_SUBSCRIBE		0
#define GROUP_ACTION_UNSUBSCRIBE	1
#define GROUP_ACTION_CHECK_ACTIVE	2

#define ARTICLE_ACTION_SAVE		0
#define COMPARE				1
#define NO_COMPARE			0
#define SHOW				1
#define NO_SHOW				0
#define NO_ID				NULL
#define REUSE				1
#define NO_REUSE			0
#define SELECT				1
#define DESELECT			0
#define ENABLE				1
#define DISABLE				0
#define BLOCK_ACTION_SET_ACTIVE		0

DEF int il, ic;
DEF int irow;
DEF int imemo;
DEF int ih;

#define MAXCOMMSPEEDCHARS 7

DEF int CommPortID;		/* IDD_COM1 or IDD_COM2 */
DEF int CommParityID;		/* IDD_7EVEN or IDD_8NONE  */
DEF char pszCommSpeed[MAXCOMMSPEEDCHARS];	/* character version of comm speed */

DEF int idTimer;		/* timer ID            */

#define IncPtr(ptr,byint) (char far *)ptr += byint

/* the next global variable is scoped globally after the main windows is
   created and is only modified at creation during MailInit in wvmail.c */

DEF struct MailCtrlStruct
{
  int MailType;
  int enableMail;
  int enableLogout;
  int enableForward;
  int (*fnMlInit) (HWND hWnd), (*fnMlLogout) (HWND hWnd), (*fnMlClose) (HWND hWnd),
  (*fnMlWinCreate) (HWND hWnd, TypDoc * Doc, int DocType), (*fnMlSend) (HWND hWnd, char *mBuf),
  (*fnMlForward) (HWND hWnd, TypDoc * Doc);
  BOOL (**MailHeaderFuncs) (TypDoc * Doc, char *Buf, long int BufLen);

}
MailCtrl;

#define MT_NONE 0
#define MT_MAPI 1
#define MT_SMTP 2

#define INACTIVE		0 /* values for CodingState      */
#define DECODE_ACTIVE		1 /* values for Decoding must be */
#define DECODE_SKIPPING		2 /* a contiguous range          */
#define DECODE_PROCESSING	3
#define DECODE_GET_TABLE	4
#define ATTACH_PROCESSING	10 /* Encodes must be > decodes   */
#define ATTACH_POSTING		11
#define ATTACH_READFILE		12

#define CODINGTABLESIZE		64

#define BASE_BLOCK_SIZE		4096 /* base size for the huge data */
typedef struct structcoded
{
  char name[MAXFILENAME];	/* original file name from begin line */
  char ident[MAXINTERNALLINE];	/* based on article subject line + author */
  BOOL beginFlag;		/* =TRUE this block is begin of the complete binary */
  BOOL endFlag;			/* =TRUE this block is end of the complete binary */
  int sequence;			/* =-1 if unknown, or # in mult-part file */
  int seqConfidence;		/* confidence of sequence info */
  unsigned long numLines;	/* num lines read so far (for status window */
  unsigned long numBytes;	/* # of bytes used in this coded data block */
  unsigned long maxBytes;	/* max # of bytes in this coded data block */
  char huge *data;		/* the huge data array */
  HWND hParentWnd;		/* handle to group wnd that started this */
}
TypCoded;

typedef struct textBlockStruct
{
  HWND hTextWnd;
  BOOL IsBusy;
  unsigned long numLines;
  unsigned long maxLines;
  unsigned long numBytes;
  unsigned long maxBytes;
  unsigned int maxLineLen;
  char huge *text;		/* big text of all lines */
  unsigned long huge *offset;	/* array of offsets into text array */
}
TypTextBlock;

#define MAX_DECODE_BLOCKS  256	/* max # of parts for a decode file */
#define MAX_DECODE_THREADS 75	/* max # of files in one batch decode */
typedef struct decodeThreadStruct
{
  char name[MAXFILENAME];	/* original file name from begin line */
  char ident[MAXINTERNALLINE];	/* thread ID based on article subject line */
  char dosFileName[MAXFILENAME]; /* workable DOS file name */
  char contentType[80];		/* MIME content type */
  char contentDesc[80];		/* MIME content description */
  char customTable[100];	/* custom coding table (if CODE_CUSTOM) */
  int contentEncoding;		/* MIME content-transfer-encoding */
  int numBlocksWritten;		/* number of blocks written to disk, so far */
  int mode;			/* 2nd field of begin header, don't use in DOS */
  int numBlocks;		/* number of coded blocks used in list */
  int expectedNumBlocks;	/* 0 if unknown, or a # if found in headers */
  unsigned long totalBytes;	/* total # of bytes for entire file */
  TypCoded *codedBlockList[MAX_DECODE_BLOCKS]; /* list of ptrs to decode
						  objects */
  TypTextBlock *statusText;	/* buffers for thread status text window */
}
TypDecodeThread;

#define CODE_BASE64   1
#define CODE_UU       2
#define CODE_XX       3
#define CODE_CUSTOM   4
#define CODE_QP       5
#define CODE_UNKNOWN  6
#define CODE_NONE     0

/* these correspond to the # members in the static arrays of strings */
/* defined in wvattach.c */
#define NUM_ENCODING_TYPES 5
#define NUM_CONTENT_TYPES 10

/* coding and attachment globals  */
DEF char xxMap[128], uuMap[128], base64Map[128], customMap[128];
DEF char *CodingMap[7];		/* N+1 for N coding types */
DEF int CodingState;
DEF TypCoded *currentCoded;
DEF TypTextBlock *CodingStatusText[MAX_DECODE_THREADS];
DEF int NumStatusTexts;
DEF BOOL CodingStatusVerbose;
DEF BOOL BlockCodingStatusAlwaysOnTop;
DEF BOOL DumbDecode;
DEF BOOL ExecuteDecodedFiles;
DEF BOOL KeepArticleHeaderVisible;
DEF BOOL UseSmartFiler;
DEF HWND hCodedBlockWnd;   /* the block coding status window (top center of screen) */
DEF char UserCodingTable[CODINGTABLESIZE+1];
#define STATUSWIDTH (85*StatusCharWidth)
#define STATUSHEIGHT (8*StatusLineHeight)

DEF char EncodingType[MAXINTERNALLINE];
DEF int EncodingTypeNum;
DEF int AttachInNewArt;
DEF char AttachFileName[MAXFILENAME];
DEF char ContentType[MAXINTERNALLINE];
DEF char DefaultContentType[MAXINTERNALLINE];
DEF char SubjectTemplate[MAXINTERNALLINE];
DEF unsigned int ArticleSplitLength;
DEF char MIMEUUType[80];	/* experimental types used in MIME header gen */
DEF char MIMEXXType[80];
DEF char MIMECustomType[80];

DEF BOOL GenerateMIME;
DEF BOOL MIMEUsageSuggestions;
DEF BOOL ReviewAttach;
DEF BOOL BlankBeforeMIME;
DEF char MIMEBoundary[MAXINTERNALLINE];

#define FAIL  -1
#define SUCCESS   0
#define ABORT 2
#define CONTINUE 3

#define MIME_VERSION "1.0"
#define ADD_TO_EDIT 1		/* used for AddEndedLineToBlock  */
#define ADD_TO_POST 2
#define ADD_TO_FILE 3
#define ADD_PLAIN   0

/* Signature File globals */
DEF int EnableSig;
DEF char SigFileName[MAXFILENAME];
DEF TypTextBlock *Signature;
#define BIG_SIG_FILE 40		/* warning if sig file > this many lines */

/* Mail List globals  */
DEF char MailFileName[MAXFILENAME];
DEF TypTextBlock *MailList;
DEF int MailListOrigNum;
#define MAX_MAIL_NAMES 50000;	/* warning if mail file > this many lines */

/* Smart Filer globals */
DEF TypTextBlock *ExtMapSourceList;
DEF TypTextBlock *ExtMapDosList;
DEF int ExtListOrigNum;
DEF BOOL EnableExtensionConversion;
DEF unsigned int MaxFileNameLen;
DEF unsigned int MaxFileExtLen;
DEF int OnDupeName;
DEF int OnNameTooLong;

#define DUPE_AVOID_NONE			0	/* dupe avoidance list.  these numbers */
#define DUPE_AVOID_NUMBER_EXT	1	/* correspond with posn in droplist */
#define DUPE_AVOID_PREPEND_NUM	2
#define DUPE_AVOID_APPEND_NUM	3

#define SHORTEN_NONE			0	/* name shotrening list.  these numbers */
#define SHORTEN_TRUNCATE		1	/* correspond with posn in droplist */
#define SHORTEN_SKIP_VOWELS		2

/* bitmaps */
DEF HBITMAP DiskBitmaps[5];
DEF HBITMAP FolderBitmaps[3];

/*Printing Globals  */

DEF PRINTDLG pd;		/* Global structure to hold printer defaults
				 */

/* macros added by JSC */
/* why is there no uitoa!? */
#define uitoa(x,s,b) ultoa((unsigned long)(x),(s),(b))
#define atoui(s) (unsigned int)atol((s))
#define Decoding (CodingState >= DECODE_ACTIVE && CodingState <= DECODE_GET_TABLE)
#define Attaching (CodingState >= ATTACH_PROCESSING && CodingState <= ATTACH_READFILE)
#define TextBlockLine(b, n) &(b->text[b->offset[n]])

#include <string.h>
#include <stdio.h>		/* sprintf, etc... */

/*--- Last line of WVGLOB.H -------------------------------------------- */
@


1.58
log
@New SmartFiler stuff, and general cleanup for 92.6
@
text
@d8 1
a8 1
 * $Id: wvglob.h 1.57 1994/09/06 12:46:21 brydon Exp $
d313 2
d331 2
d530 4
a533 3
DEF unsigned int xScreen, yScreen;
DEF HANDLE hListFont;		/* handle to font used in group/art lists */
DEF HANDLE hFontArtNormal;	/* handle to font used in Article window - normal
d535 1
a535 1
DEF HANDLE hFontArtQuote;	/* handle to font used in Article window -
d537 5
a541 5
DEF HANDLE hFontPrint;		/* handle to font used for printing. */
DEF HANDLE hFontPrintB;		/* handle to font used for bold printing. */
DEF HANDLE hFontPrintS;		/* handle to font used for printing Subject line. */
DEF HANDLE hFontPrintI;		/* handle to font used for printing Quoted lines. */
DEF HANDLE hStatusFont;		/* handle to font used in status windows */
d547 1
a547 1
//DEF int FontBold;
d556 3
a558 3
DEF unsigned int LineHeight, CharWidth;		/* # of window units for list font */
DEF unsigned int ArtLineHeight, ArtCharWidth;	/* # of windows units for article font */
DEF unsigned int StatusLineHeight, StatusCharWidth;	/* # of window units for status font */
d575 1
a575 2
DEF COLORREF CustomColors[16];	/* Custom colors definable by user in
				   ChooseColor */
d760 1
a808 1
DEF int numFilesDecoded;
d811 2
a812 2
DEF int numStatusTexts;
DEF TypTextBlock *codingStatusText[MAX_DECODE_THREADS];
@


1.57
log
@win32 fixes, comments changed
@
text
@d8 1
a8 1
 * $Id: wvglob.h 1.56 1994/09/02 19:16:32 martin Exp $
d23 13
d46 1
a46 1
#define MAXFILENAME		60
d152 1
d230 1
a230 1
  HANDLE hFile;			/* handle to file                            */
d506 5
a511 2
#define  FAIL  -1
#define SUCCESS   0
d598 22
a619 20
DEF FARPROC lpfnWinVnSaveArtDlg;
DEF FARPROC lpfnWinVnSaveArtsDlg;
DEF FARPROC lpfnWinVnFindDlg;
DEF FARPROC lpfnWinVnGenericDlg;
DEF FARPROC lpfnWinVnSubjectDlg;
DEF FARPROC lpfnWinVnCommDlg;
DEF FARPROC lpfnWinVnAuthDlg;
DEF FARPROC lpfnWinVnDoListDlg;
DEF FARPROC lpfnWinVnPersonalInfoDlg;
DEF FARPROC lpfnWinVnMiscDlg;
DEF FARPROC lpfnWinVnAppearanceDlg;
DEF FARPROC lpfnEditSubClass;
DEF FARPROC lpfnWinVnThresholdDlg;
DEF FARPROC lpfnWinVnLogOptDlg;
DEF FARPROC lpfnWinVnDecodeArtsDlg;
DEF FARPROC lpfnWinVnAttachDlg;
DEF FARPROC lpfnWinVnEncodeDlg;
DEF FARPROC lpfnWinVnSigFileDlg;
DEF FARPROC lpfnWinVnExitDlg;
DEF FARPROC lpfnWinVnMailDlg;
d632 4
a635 2
DEF int SaveArtAppend;
DEF int ThreadFullSubject;
d810 1
d813 4
a816 3
DEF HWND hCodedBlockWnd;	/* the block coding status window (top center of
				   screen) */
DEF char UserCodingTable[CODINGTABLESIZE + 1];
a835 1
DEF BOOL Attaching;		/* TRUE if currently making attachment */
d838 4
a841 2
#define ABORT 1
#define CONTINUE 0
d861 23
d894 1
@


1.56
log
@martin fixes
@
text
@d7 2
a8 2
 *
 * $Id: wvglob.h 1.55 1994/08/24 18:40:15 mrr Exp $
d11 12
d24 1
a24 1
  #define huge far
d27 10
a36 9
#define BUFSIZE   1024
#define TEMPBUFSIZE   1240
#define MAXHEADERLINE 256
#define MAXFINDSTRING  80
#define MAXDIALOGSTRING 255

#define MAXFILENAME 60
#define MAXCHARS 80
#define MAXLINES 24
d38 6
a43 6
#define MAXCOMMLINE      1536
#define MAXINTERNALLINE   180
#define MAXOUTLINE    255
#define MAXPOSTLENGTH  60000  /* max length for a posting/mail edit window */
#define MAXBOUNDARYLEN 70     /* max length for MIME boundary  */
#define MAXNEWGROUPSASK 200     /* limit of groups in newgroups dialog box */
d50 95
a144 84
typedef struct structtextselect {
   int LineNum;          /* Line number when selecting text -- Line Ord  */
   int CharNum;          /* Character number when selecting text         */
   /* The 1st LineNum in the Doc and the 1st CharNum in the line are 0   */ 
} TextSelect;

typedef struct structdoc {
   HANDLE hFirstBlock;        /* handle to first textblock in doc.        */
   HANDLE hLastBlock;         /* unused.                                  */
   unsigned int TotalLines;   /* total # of lines in doc.                 */ 
   unsigned int LongestLine;  /* # of bytes in the longest line of doc    */
   unsigned int HeaderLines;  /* total number of lines in header of doc
                                        (incl. blank line) */
   unsigned int ActiveLines;  /* # of selected or otherwise active lines  */
   unsigned int CountedLines; /* # of counted lines, as in subscr. groups */
   unsigned int BlockSize;    /* # of bytes in a textblock                */
   unsigned int SplitSize;    /* textblock split point in bytes           */
   HANDLE hCurAddBlock;       /* hBlock to point at which to add lines.   */
   unsigned int AddOffset;    /* offset in bytes for point to add lines   */
   TypLineID  AddLineID;      /* LineID of place to add lines.            */
   HANDLE hCurTopScBlock;     /* hBlock of current top line of window     */
   unsigned int TopScOffset;
   TypLineID  TopScLineID;
   unsigned int TopLineOrd;   /* ordinal in doc of top line in window     */
   HANDLE hLastSeenBlock;
   unsigned int LastSeenOffset;
   TypLineID    LastSeenLineID;
   HANDLE hFindBlock;         /* location of place to start next search   */
   unsigned int FindOffset;   /* for "SearchStr"                          */
   TypLineID    FindLineID;
   unsigned int FindTextOffset;
   char SearchStr[MAXFINDSTRING];  /* Search string for current search    */
   unsigned int ScXOffset;    /* # of chars offset for horizontal scroll  */
   unsigned int ScXChars;     /* # of chars/line for current window size  */
   unsigned int ScYLines;     /* # of lines that fit in current window    */
   unsigned int ScXWidth;     /* current size of client area of window    */
   unsigned int ScYHeight;
   HWND hDocWnd;
   struct structdoc *ParentDoc;  /* pointer to parent document            */
   HANDLE hParentBlock;          /* points to line in parent doc          */
   unsigned int ParentOffset;    /* that corresponds to/describes this    */
   TypLineID    ParentLineID;    /* document                              */
   unsigned int OffsetToText;
   BOOL          InUse;          /* TRUE if this TypDoc in use.           */
   int          DocType;         /* DOCTYPE_xxx                           */
   BOOL         TextSelected;    /* Indicates text selected               */ 
   TextSelect   BeginSelect;     /* Line and Char where selection began   */
   TextSelect   EndSelect;       /* Line and Char where selection ended   */
} TypDoc;

typedef struct structblock {
   HANDLE hPrevBlock;     /* handle of previous block, or 0               */
   HANDLE hNextBlock;     /* handle of next block in document, or 0       */
   HANDLE hCurBlock;      /* handle of this block                         */
   int    LWAp1;          /* # of used data bytes in block, inc header    */
   int    NumLines;       /* # of lines in this block                     */
   int    NumActiveLines; /* # of active lines in this block.             */
   TypDoc *OwnerDoc;      /* pointer to document this block is in.        */
   int    eob;            /* end-of-block; must be just before 1st line.  */
   /* Text lines */
   /* Another EOB marker */
} TypBlock;

typedef struct structline {
   int length;              /* Total # of bytes in line, all-inclusive    */
   TypLineID LineID;        /* Unique identifier for this line.           */
   int active;              /* =1 if line should be displayed, else 0     */
   /* Bytes of text */
   /* Another copy of length */
} TypLine;

typedef struct structtext {
   int NameLen;            /* # of bytes of text                          */
} TypText;

typedef struct structgroup {
  char      Subscribed; /* =TRUE if subscribed to this group.   */
  char      Selected;   /* =TRUE if selected                    */
  int    NameLen; /* # of bytes in group name             */
  TypDoc *SubjDoc;   /* points to doc containing subjs       */
  unsigned long   ServerEstNum;  /* est # of arts in server              */
  unsigned long   ServerFirst;   /* # of first art that server has.      */
  unsigned long   ServerLast; /* # of last art that server has.       */
  unsigned long   HighestPrevSeen; /* # of highest art server had in last  */
d146 16
a161 14
  HANDLE header_handle; /* handle to global block of header array mem */
  HANDLE thread_handle; /* handle to global block of thread ind. pointers */
  long int  total_headers; /* total # of headers in array */
  unsigned int  nRanges;   /* # of TypRanges describing seen arts  */
  /* Name of group */            /* name of group, zero-terminated       */
  /* Ranges of articles seen */  /* array of TypRanges, of seen articles */
} TypGroup;

typedef struct structarticle {
  unsigned long   Number;     /* Server's number for this article    */
  char      Seen;    /* =TRUE if article seen               */
  char      Selected;   /* =TRUE if article selected           */
  TypDoc *ArtDoc; /* points to doc with actual article   */
  int    NameLen; /* # of bytes in subject line */
d163 2
a164 1
} TypArticle;
d170 2
a171 2
#define HEADER_SUBJECT_LENGTH    105
#define HEADER_FROM_LENGTH    74
d176 23
a198 2
#define ARTICLE_SUBJECT_OFFSET   40
#define GROUP_NAME_OFFSET        10
d200 1
a200 41
typedef struct {
   char Seen;
   char Selected;
   char thread_depth;
   char subject[HEADER_SUBJECT_LENGTH];
   unsigned long  number;
   unsigned int  lines;
//   char date[9];     JD 6/25/93
   time_t date;
   char from[HEADER_FROM_LENGTH];
   char message_id[HEADER_MESSAGE_ID_LENGTH];
   char references[HEADER_REFERENCES_LENGTH];
   TypDoc * ArtDoc;
} TypHeader;

typedef TypHeader huge * header_p;

typedef long huge * thread_array;

typedef thread_array huge * thread_array_p;

typedef char huge * char_p;

typedef struct structrange {
   long int   First;
   long int   Last;
} TypRange;

/* TypMRRFile is used to describe a file; I use it because Windows  */
/* doesn't provide much in the way of disk I/O support.                   */

typedef struct structMRRfile {
   HANDLE   hFile;           /* handle to file                            */
   OFSTRUCT of;
   char     buf[BUFSIZE];    /* my I/O buffer.                            */
   HANDLE   hthis;           /* handle to this structure                  */
   int      bufidx;          /* Index to next place in buf                */
   int      bytesread;       /* for reads, # of bytes read in last read   */
   int      mode;            /* mode in which to open file.               */
   int      eofflag;         /* whether we have reached EOF (read)        */
} TypMRRFile;
d202 25
d229 2
a230 2
#define EDITID   1      /* ID of edit box, to identify for return values */
#define MAXMEMONAME 15  /* Number of chars in memo name */
d261 8
a268 6
DEF struct {
   WORD wVirtKey;
   int CtlState;
   int iMessage;
   WORD wRequest;
} key2scroll[NUMKEYS]
d271 8
a278 7
{VK_PRIOR, 0, WM_VSCROLL,SB_PAGEUP,
 VK_NEXT,  0, WM_VSCROLL,SB_PAGEDOWN,
 VK_UP,    0, WM_VSCROLL,SB_LINEUP,
 VK_DOWN,  0, WM_VSCROLL,SB_LINEDOWN,
 VK_LEFT,  0, WM_HSCROLL,SB_LINEUP,
 VK_RIGHT, 0, WM_HSCROLL,SB_LINEDOWN
}
d294 1
a294 1
#define MAXPOSTWNDS    20 
d301 7
a307 5
{HWND hWnd ;
 HWND hWndEdit ;
 int dirty ;
 TypDoc * Doc ;
} WndEdit;
d313 2
a314 2
DEF WndEdit  WndPosts[MAXPOSTWNDS];
DEF WndEdit  WndMails[MAXMAILWNDS];
d326 13
a338 12
DEF int CommState;        /* current state in comm FSA                        */
DEF BOOL CommBusy;        /* =TRUE if comm line busy interacting w/ server    */
DEF BOOL CommDecoding;    /* =TRUE if comm line busy decoding lines from server*/
DEF WndEdit *PostEdit, *MailEdit;  /* set to post/mail window during send */
DEF TypDoc *CommDoc;      /* Document currently receiving lines from server   */
DEF HWND CommWnd  ;       /* Window containing details of document currently talking to server */
DEF HWND hVerDlgList;     /* Handle to info in the Version Dialog Box */
DEF char CommLineIn[MAXCOMMLINE];  /* current input line being built by FSA   */
DEF char *CommLinePtr;    /* pointer to next place to put char in CommLineIn  */
DEF char *CommLineLWAp1;  /* if we get this far, we're at end of buffer       */
DEF char IgnoreCommCh;    /* char to ignore when reading from server          */
DEF char EOLCommCh;       /* char that indicates end of line upon input       */
d343 2
a344 1
DEF char CurrentGroup[MAXGROUPNAME]; /* name of group currently selected on server */
d346 1
a346 1
DEF BOOL UsingSocket;     /* =TRUE if using PC/TCP rather than serial I/O     */
d357 4
a360 4
DEF char NNTPPasswordEncrypted[2*MAXNNTPSIZE];      
DEF BOOL AuthReqPost; /* TRUE if we may not post at all unless authenticated */
DEF BOOL AuthReqMail; /* TRUE if we may not send mail unless authenticated */
DEF BOOL Authenticated   /* TRUE if we've been authenticated by NNTP server */
d364 1
a364 1
;                                         
d368 2
a369 2
 */ 
DEF char AuthenticatedName[MAXNNTPSIZE];  
d378 1
a378 1
DEF int  ConnectAtStartup;
d382 35
a416 35
#define ST_NONE                    0
#define ST_ESTABLISH_COMM          1
#define ST_GROUP_RESP              2
#define ST_XHDR_SUBJECT_START      3
#define ST_XHDR_SUBJECT_DATA       4
#define ST_IN_GROUP                5
#define ST_ARTICLE_RESP            6
#define ST_REC_ARTICLE_HEADER      65
#define ST_REC_ARTICLE             7
#define ST_POST_WAIT_PERMISSION    8
#define ST_POST_WAIT_END           9
#define ST_GROUP_REJOIN           10
#define ST_LIST_RESP              11
#define ST_LIST_GROUPLINE         12
#define ST_MAIL_WAIT_PERMISSION   13
#define ST_MAIL_WAIT_END          14
#define ST_CHECK_AUTHINFO_USERNAME 20
#define ST_CHECK_AUTHINFO_PASSWORD 21
#define ST_END_AUTHINFO            22
#define ST_XHDR_FROM_START   50
#define ST_XHDR_FROM_DATA    51
#define ST_XHDR_SUBJ_START   52
#define ST_XHDR_SUBJ_DATA    53
#define ST_XHDR_REF_START    54
#define ST_XHDR_REF_DATA     55
#define ST_XHDR_MID_START    56
#define ST_XHDR_MID_DATA     57
#define ST_XHDR_DATE_START   58
#define ST_XHDR_DATE_DATA    59
#define ST_XHDR_LINES_START     60
#define ST_XHDR_LINES_DATA   61
#define ST_XOVER_START       62
#define ST_XOVER_DATA        63
#define ST_XOVER_CHECK       64
#define ST_CLOSED_COMM            99
d420 2
a421 3
/* variables used in an ad hoc attempt to optimize updating of windows by
 * the input cracking FSA.
 */
d423 4
a426 4
#define UPDATE_TITLE_FREQ    10
#define UPDATE_ART_FREQ    12
#define MAX_IMMEDIATE_UPDATE  2
#define STATUS_UPDATE_FREQ 20
d431 1
a431 1
DEF TypLineID NextLineID  /* LineID to assign to next created line            */
d435 1
a435 1
;
d438 4
a441 4
DEF HWND      hWndConf;       /* handle to NetDoc window     */
DEF HWND      hWndSk;
DEF HWND      hDosWnd;
DEF HWND      hWndDebugComm;  /* handle to Debug Comm window */
d443 2
a444 2
DEF HANDLE hAccel;     /* handle to main accelerator table */
DEF MSG MainMsg;       /* message returned from GetMessage */
d446 1
a446 1
DEF int CommDevice;    /* comm device ID, if using serial I/O                 */
d448 1
a448 1
DEF char str[255];                     /* general-purpose string buffer */
d451 2
a452 2
DEF HCURSOR hSaveCursor;               /* handle to current cursor      */
DEF HCURSOR hHourGlass;                /* handle to hourglass cursor    */
d455 2
a456 2
DEF int X, Y;                          /* last cursor position          */
DEF int DragMouseAction;               /* mouse action for dragging      */
d464 1
a464 1
DEF POINT ptCursor;                    /* x and y coordinates of cursor */
d468 1
a468 1
DEF char szCommString[MAXCOMMCHARS];    /* string describing serial comm port */
d482 3
a484 2
DEF int numArtsSaved;  
DEF int nextBatchIndex;    // for batch post/mails
d510 10
a519 8
DEF HANDLE hListFont;     /* handle to font used in group/art lists */
DEF HANDLE hFontArtNormal;/* handle to font used in Article window - normal text mode. */
DEF HANDLE hFontArtQuote; /* handle to font used in Article window - comments == Italics. */
DEF HANDLE hFontPrint;    /* handle to font used for printing. */
DEF HANDLE hFontPrintB;   /* handle to font used for bold printing. */
DEF HANDLE hFontPrintS;   /* handle to font used for printing Subject line. */
DEF HANDLE hFontPrintI;   /* handle to font used for printing Quoted lines. */
DEF HANDLE hStatusFont;   /* handle to font used in status windows */
d534 9
a542 9
DEF unsigned int LineHeight,CharWidth;  /* # of window units for list font */
DEF unsigned int ArtLineHeight, ArtCharWidth; /* # of windows units for article font */
DEF unsigned int StatusLineHeight,StatusCharWidth;  /* # of window units for status font */
DEF int TopSpace, SideSpace;   /* # of window units to leave at top and side  */
                           /* of window (for aesthetic purposes)          */
DEF int ArtTopSpace, ArtSideSpace;   /* # of window units to leave at top and side  */
DEF int StartPen;      /* Similar to TopSpace; where to start pen 1st row */
DEF int ScreenYPixels;         /* used in converting points to logical units */
DEF int PrinterYPixels;        /* used in converting points to logical units */
d544 14
a557 13
DEF COLORREF NetUnSubscribedColor;  /* color to use for unsubscribed groups  */
DEF COLORREF NetSubscribedColor;    /* color to use for subscribed groups  */
DEF COLORREF ArticleSeenColor;      /* color to use for articles that have been seen */
DEF COLORREF ArticleUnSeenColor;    /* color to use for articles that have not been seen */
DEF COLORREF ArticleTextColor;      /* color to use for article/post text */
DEF COLORREF StatusTextColor;       /* Color to use for status text */
DEF COLORREF ListBackgroundColor;   /* background color for group/article listings */
DEF COLORREF ArticleBackgroundColor;/* background color for article/post windows */
DEF COLORREF StatusBackgroundColor; /* background color for status windows */
DEF COLORREF CustomColors[16];      /* Custom colors definable by user in ChooseColor */
DEF HBRUSH   hListBackgroundBrush;
DEF HBRUSH   hArticleBackgroundBrush;
DEF HBRUSH   hStatusBackgroundBrush;
d563 7
a569 7
DEF BOOL  MailDemandLogon;      /* FALSE = permanent logon
                                   TRUE  = logon on send mail */
DEF int  MailForceType;        /*  Force Mail Type to valid value where
               Less then zero means
                                   default negotiation */
DEF int MailLog ;             /* True means append to log files */
DEF int PostLog ;             /* where XXXXLogFile is file name */ 
d572 2
a573 2
DEF char MailLogFile[MAXFILENAME] ;
DEF char PostLogFile[MAXFILENAME] ;
d575 2
a576 2
DEF int  fmtDaysB4Mth      ;
DEF char fmtDateDelim[2]   ;
d592 1
a592 1
DEF FARPROC lpfnEditSubClass ;
d605 1
a605 1
DEF char szNewsSrc[128];
d613 2
a614 2
DEF int  SaveArtAppend;
DEF int  ThreadFullSubject;
d617 1
a617 1
DEF TypDoc *PostDoc;   /* Used to pass pointer to article being replied to. */
d620 1
a620 1
DEF char *NewsgroupsPtr;  /* Used to pass pointer to newsgroup of new posting. */
d628 2
a629 2
DEF void huge * huge * NewGroupTable;  /* array of pointers to new group lines */
DEF HANDLE hNewGroupTable;     /* Handle to the above array */
d636 13
a648 29
typedef struct structHier {
	HANDLE	 hName;
	int		 Start;
	int		 NumGroups;
	HANDLE	 hNext;
} TypHier;

#define ADD_SUBSCRIBED_END_OF_SUB 0
#define ADD_SUBSCRIBED_TOP_OF_DOC        1

#define LINE_FLAG_SET           0

#define GROUP_ACTION_SUBSCRIBE    0
#define GROUP_ACTION_UNSUBSCRIBE  1
#define GROUP_ACTION_CHECK_ACTIVE 2  

#define ARTICLE_ACTION_SAVE   0
#define COMPARE         1
#define NO_COMPARE      0
#define SHOW         1
#define NO_SHOW         0
#define NO_ID        NULL
#define REUSE        1
#define NO_REUSE     0
#define SELECT       1
#define DESELECT     0
#define ENABLE       1
#define DISABLE         0
#define BLOCK_ACTION_SET_ACTIVE   0
d650 19
a668 1
DEF int il,ic;
d675 3
a677 3
DEF int CommPortID;     /* IDD_COM1 or IDD_COM2 */
DEF int CommParityID;   /* IDD_7EVEN or IDD_8NONE  */
DEF char pszCommSpeed[MAXCOMMSPEEDCHARS];  /* character version of comm speed */
d679 1
a679 1
DEF int idTimer;                           /* timer ID            */
d686 1
a686 1
DEF struct MailCtrlStruct 
d688 8
a695 11
    int MailType   ;
    int enableMail ;
    int enableLogout ;
    int enableForward ;
    int (*fnMlInit)(HWND hWnd),
   (*fnMlLogout)(HWND hWnd),
   (*fnMlClose)(HWND hWnd),
        (*fnMlWinCreate)(HWND hWnd,TypDoc *Doc,int DocType),
        (*fnMlSend)(HWND hWnd, char *mBuf),
        (*fnMlForward)(HWND hWnd, TypDoc * Doc);
    BOOL (**MailHeaderFuncs)(TypDoc * Doc, char *Buf, long int BufLen) ;
d697 2
a698 1
} MailCtrl ;
d704 62
a765 55
#define INACTIVE     0       /* values for CodingState      */
#define DECODE_ACTIVE      1  /* values for Decoding must be */
#define DECODE_SKIPPING    2  /* a contiguous range          */
#define DECODE_PROCESSING       3
#define DECODE_GET_TABLE        4
#define ATTACH_PROCESSING  10 /* Encodes must be > decodes   */
#define ATTACH_POSTING     11
#define ATTACH_READFILE    12

#define CODINGTABLESIZE    64

#define BASE_BLOCK_SIZE    4096  /* base size for the huge data */
typedef struct structcoded {
  char   name[MAXFILENAME];   /* original file name from begin line */
  char   ident[MAXINTERNALLINE]; /* based on article subject line + author */
  BOOL   beginFlag;     /* =TRUE this block is begin of the complete binary */
  BOOL   endFlag;    /* =TRUE this block is end of the complete binary */
  int sequence;      /* =-1 if unknown, or # in mult-part file */
  int seqConfidence;    /* confidence of sequence info */
  unsigned long numLines;  /* num lines read so far (for status window */
  unsigned long   numBytes;       /* # of bytes used in this coded data block */
  unsigned long   maxBytes;       /* max # of bytes in this coded data block */
  char huge *data;      /* the huge data array */
  HWND   hParentWnd;    /* handle to group wnd that started this */
} TypCoded;

typedef struct textBlockStruct {
   HWND hTextWnd;
   unsigned long numLines;
   unsigned long maxLines;
   unsigned long numBytes;
   unsigned long maxBytes;
   unsigned int maxLineLen;
   char huge *text;     /* big text of all lines */
   unsigned long huge *offset;   /* array of offsets into text array */
} TypTextBlock;

#define MAX_DECODE_BLOCKS  256   /* max # of parts for a decode file */
#define MAX_DECODE_THREADS 75 /* max # of files in one batch decode */
typedef struct decodeThreadStruct {
  char   name[MAXFILENAME];   /* original file name from begin line */
  char   ident[MAXINTERNALLINE]; /* thread ID based on article subject line */
  char   dosFileName[MAXFILENAME];/* workable DOS file name */
  char   contentType[80];  /* MIME content type */
  char   contentDesc[80];  /* MIME content description */
  char   customTable[100]; /* custom coding table (if CODE_CUSTOM) */
  int contentEncoding;  /* MIME content-transfer-encoding */
  int numBlocksWritten; /* number of blocks written to disk, so far */
  int mode;       /* 2nd field of begin header, don't use in DOS */
  int numBlocks;     /* number of coded blocks used in list */
  int expectedNumBlocks;   /* 0 if unknown, or a # if found in headers */
  unsigned long totalBytes;   /* total # of bytes for entire file */
  TypCoded *codedBlockList[MAX_DECODE_BLOCKS]; /* list of ptrs to decode objects */
  TypTextBlock *statusText;   /* buffers for thread status text window */
} TypDecodeThread;
d782 1
a782 1
DEF char *CodingMap[7]; /* N+1 for N coding types */
d786 1
a786 1
DEF int  numStatusTexts;
d791 3
a793 2
DEF HWND hCodedBlockWnd;   // the block coding status window (top center of screen)
DEF char UserCodingTable[CODINGTABLESIZE+1];
d797 3
a799 3
DEF char  EncodingType[MAXINTERNALLINE];
DEF int  EncodingTypeNum;
DEF int  AttachInNewArt;
d805 1
a805 1
DEF char MIMEUUType[80];   // experimental types used in MIME header gen
d813 1
a813 1
DEF BOOL Attaching;  /* TRUE if currently making attachment */
d820 1
a820 1
#define ADD_TO_EDIT 1   /* used for AddEndedLineToBlock  */
d829 1
a829 1
#define BIG_SIG_FILE 40 /* warning if sig file > this many lines */
d835 1
a835 1
#define MAX_MAIL_NAMES 50000; /* warning if mail file > this many lines */
d839 2
a840 1
DEF PRINTDLG pd;                /* Global structure to hold printer defaults     */
d843 2
a844 1
#define uitoa(x,s,b) ultoa((unsigned long)(x),(s),(b)) // why is there no uitoa!?
d850 1
a850 1
#include <stdio.h>  /* sprintf, etc...*/
@


1.55
log
@authorization enables post/mail
@
text
@d8 1
a8 1
 * $Id: wvglob.h 1.54 1994/08/24 18:00:29 jcooper Exp $
d585 1
a585 1
DEF void far * far * NewGroupTable;  /* array of pointers to new group lines */
@


1.54
log
@misc encoding/decoding changes
@
text
@d8 1
a8 1
 * $Id: wvglob.h 1.53 1994/08/23 23:15:34 martin Exp $
d28 2
a29 2
#define MAXPOSTLENGTH  60000	/* max length for a posting/mail edit window */
#define MAXBOUNDARYLEN 70    	/* max length for MIME boundary  */
d38 3
a40 3
	int LineNum;          /* Line number when selecting text -- Line Ord  */
	int CharNum;          /* Character number when selecting text         */
	/* The 1st LineNum in the Doc and the 1st CharNum in the line are 0   */ 
d317 13
a329 1
DEF char NNTPPasswordEncrypted[2*MAXNNTPSIZE];
d444 1
a444 1
DEF int nextBatchIndex;		// for batch post/mails
d453 4
a456 4
#define	FAIL	-1
#define SUCCESS	0
#define THREAD_COMPLETE 	1
#define THREAD_INCOMPLETE 	2
d499 2
a500 2
DEF int ScreenYPixels;		    /* used in converting points to logical units */
DEF int PrinterYPixels;		    /* used in converting points to logical units */
a563 2
DEF BOOL Authorized;

d609 12
a620 12
#define ARTICLE_ACTION_SAVE	0
#define COMPARE			1
#define NO_COMPARE		0
#define SHOW			1
#define NO_SHOW			0
#define NO_ID			NULL
#define REUSE			1
#define NO_REUSE		0
#define SELECT			1
#define DESELECT		0
#define ENABLE			1
#define DISABLE			0
d661 3
a663 3
#define INACTIVE		0       /* values for CodingState      */
#define DECODE_ACTIVE		1	/* values for Decoding must be */
#define DECODE_SKIPPING		2	/* a contiguous range          */
d666 3
a668 3
#define ATTACH_PROCESSING	10	/* Encodes must be > decodes   */
#define ATTACH_POSTING		11
#define ATTACH_READFILE		12
d670 1
a670 1
#define CODINGTABLESIZE 	64
d672 1
a672 1
#define BASE_BLOCK_SIZE		4096	/* base size for the huge data */
d674 11
a684 11
  char	name[MAXFILENAME];	/* original file name from begin line */
  char	ident[MAXINTERNALLINE];	/* based on article subject line + author */
  BOOL	beginFlag;		/* =TRUE this block is begin of the complete binary */
  BOOL	endFlag;		/* =TRUE this block is end of the complete binary */
  int	sequence;		/* =-1 if unknown, or # in mult-part file */
  int	seqConfidence;		/* confidence of sequence info */
  unsigned long numLines;	/* num lines read so far (for status window */
  unsigned long	numBytes;       /* # of bytes used in this coded data block */
  unsigned long	maxBytes;       /* max # of bytes in this coded data block */
  char huge *data;		/* the huge data array */
  HWND	hParentWnd;		/* handle to group wnd that started this */
d694 2
a695 2
   char huge *text;		/* big text of all lines */
   unsigned long huge *offset;	/* array of offsets into text array */
d698 2
a699 2
#define MAX_DECODE_BLOCKS	256	/* max # of parts for a decode file */
#define MAX_DECODE_THREADS	75	/* max # of files in one batch decode */
d701 12
a712 12
  char	name[MAXFILENAME];	/* original file name from begin line */
  char	ident[MAXINTERNALLINE];	/* thread ID based on article subject line */
  char	dosFileName[MAXFILENAME];/* workable DOS file name */
  char	contentType[80];	/* MIME content type */
  char	contentDesc[80];	/* MIME content description */
  char	customTable[100];	/* custom coding table (if CODE_CUSTOM) */
  int	contentEncoding;	/* MIME content-transfer-encoding */
  int	numBlocksWritten;	/* number of blocks written to disk, so far */
  int	mode;			/* 2nd field of begin header, don't use in DOS */
  int	numBlocks;		/* number of coded blocks used in list */
  int	expectedNumBlocks;	/* 0 if unknown, or a # if found in headers */
  unsigned long totalBytes;	/* total # of bytes for entire file */
d714 1
a714 1
  TypTextBlock *statusText;	/* buffers for thread status text window */
d732 1
a732 1
DEF char *CodingMap[7];	/* N+1 for N coding types */
d736 1
a736 1
DEF int	numStatusTexts;
d741 1
a741 1
DEF HWND hCodedBlockWnd;	// the block coding status window (top center of screen)
d754 1
a754 1
DEF char MIMEUUType[80];	// experimental types used in MIME header gen
d762 1
a762 1
DEF BOOL Attaching;	/* TRUE if currently making attachment */
d778 1
a778 1
#define BIG_SIG_FILE	40	/* warning if sig file > this many lines */
d784 1
a784 1
#define MAX_MAIL_NAMES 50000;	/* warning if mail file > this many lines */
@


1.53
log
@new group list box & new hash table mechanism
@
text
@d8 1
a8 1
 * $Id: wvglob.h 1.52 1994/08/11 02:25:59 dumoulin Exp $
d749 1
@


1.52
log
@enabled STRICT compile and cleaned up parameter casting
@
text
@d8 1
a8 1
 * $Id: wvglob.h 1.51 1994/08/11 00:09:17 jcooper Exp dumoulin $
d571 3
a573 4
 * dynamically-allocated global data structure containing:
 *  -- Handle to this structure (so we can deallocate later).
 *  -- A line containing information on this group, in the exact
 *     same format as used in the NetDoc.
d576 1
a576 1
DEF HANDLE hNewGroupTable;           /* Handle to the above array */
d578 11
@


1.51
log
@Enhancements to Mime and article encoding/encoding
@
text
@d8 1
a8 1
 * $Id: wvglob.h 1.50 1994/08/04 05:49:30 dumoulin Exp $
d386 5
a390 5
DEF HANDLE hInst;
DEF HWND   hWndConf;   /* handle to NetDoc window                             */
DEF HWND   hWndSk;
DEF HWND   hDosWnd;
DEF HWND   hWndDebugComm;  /*handle to Debug Comm window */
@


1.50
log
@Added support for scrollable version box
@
text
@d8 1
a8 1
 * $Id: wvglob.h 1.49 1994/07/28 21:56:32 rushing Exp dumoulin $
d721 1
a721 1
DEF HWND hCodedBlockWnd;
d734 5
d743 3
@


1.49
log
@mistakenly set arts_to_retrieve as unsigned
@
text
@d8 1
a8 1
 * $Id: wvglob.h 1.48 1994/07/26 18:39:45 dumoulin Exp rushing $
d294 1
d546 1
d549 1
a549 1
DEF char szAppProFile[128];
@


1.48
log
@Added constant for the maximum number of new newsgroups
allowed before new newsgroup dialog box doesn't get called.
@
text
@d8 1
a8 1
 * $Id: wvglob.h 1.47 1994/07/26 16:10:51 gardnerd Exp dumoulin $
d428 1
a428 1
DEF unsigned int arts_to_retrieve;
@


1.47
log
@Added support for article copying to windows clipboard
@
text
@d8 1
a8 1
 * $Id: wvglob.h 1.46 1994/07/25 22:41:22 pearse_w_r Exp $
d11 3
a13 3
#ifdef WIN32         
  #define huge far   
#endif               
d28 3
a30 2
#define MAXPOSTLENGTH  60000	// max length for a posting/mail edit window
#define MAXBOUNDARYLEN 70    	// max length for MIME boundary
d575 1
a575 1
DEF HANDLE hNewGroupTable;     /* Handle to the above array */
d639 3
a641 3
#define INACTIVE		0       // values for CodingState
#define DECODE_ACTIVE		1	// values for Decoding must be
#define DECODE_SKIPPING		2	// a contiguous range
d644 1
a644 1
#define ATTACH_PROCESSING	10	// Encodes must be > decodes
d703 2
a704 1
// these correspond to the # members in the static arrays of strings defined in wvattach.c
d708 1
a708 1
// coding and attachment globals
d710 1
a710 1
DEF char *CodingMap[7];	// N+1 for N coding types
d734 1
a734 1
DEF BOOL Attaching;	// == TRUE if currently making attachment
d738 1
a738 1
#define ADD_TO_EDIT 1   // used for AddEndedLineToBlock
d743 1
a743 1
// Signature File globals
d747 1
a747 1
#define BIG_SIG_FILE	40	// warning if sig file > this many lines
d749 1
a749 1
// Mail List globals
d753 1
a753 1
#define MAX_MAIL_NAMES 50000;	// warning if mail file > this many lines
d755 1
a755 1
// Printing Globals
d759 1
a759 1
// macros added by JSC
d766 1
a766 1
#include <stdio.h>  // sprintf, etc...
@


1.46
log
@ShowUnreadOnly option
@
text
@d8 1
a8 1
 * $Id: wvglob.h 1.45 1994/07/25 18:51:48 jcooper Exp $
d32 1
a32 1
#include <commdlg.h> 
d36 6
d81 3
d139 1
a139 1
/* arrays require this. */  
d146 1
a146 1
                                      
d148 1
a148 1
#define ARTICLE_SUBJECT_OFFSET   40              
d150 1
a150 1
                                      
d435 1
a435 1
DEF int ShowReadArticles;  
d439 1
a439 1
#define	FAIL	-1 
d591 1
a591 1
#define NO_ID			NULL	
d611 1
a611 1
DEF int idTimer;                                          /* timer ID            */
@


1.45
log
@execution of decoded files
@
text
@d8 1
a8 1
 * $Id: wvglob.h 1.44 1994/06/30 16:37:04 dumoulin Exp $
d428 1
@


1.44
log
@Defined global storage for the Print Dialog (pd) function
@
text
@d8 1
a8 1
 * $Id: wvglob.h 1.43 1994/06/08 21:01:45 gardnerd Exp dumoulin $
d418 1
a418 1
DEF int arts_to_retrieve;
d706 1
@


1.43
log
@more scrolling changes...
@
text
@d8 1
a8 1
 * $Id: wvglob.h 1.42 1994/06/06 22:06:13 gardnerd Exp $
d32 1
d741 4
@


1.42
log
@horizontal scrolling support
@
text
@d8 1
a8 1
 * $Id: $
d137 3
a139 2
/* Offset used to calculate LongestLine for an article subject */
#define HEADER_SUBJECT_OFFSET     40
@


1.41
log
@fix subscribed-count bug
@
text
@d8 1
a8 128
 * $Id: wvglob.h 1.40 1994/06/01 19:00:00 gardnerd Exp $
 * $Log: wvglob.h $
 * Revision 1.40  1994/06/01  19:00:00  gardnerd
 * support for horizontal scrolling
 *
 * Revision 1.39  1994/05/23  19:51:51  rushing
 * NNTPPort becomes NNTPService, and it's a string.
 *
 * Revision 1.38  1994/05/23  18:37:00  jcooper
 * new attach code, session [dis]connect
 *
 * Revision 1.37  1994/05/02  20:32:55  rushing
 * changes from jody glasser
 *
 * Revision 1.36  1994/03/01  19:10:19  rushing
 * ThreadFullSubject option added
 *
 * Revision 1.35  1994/02/24  21:28:49  jcoop
 * jcoop changes
 *
 * Revision 1.34  1994/02/16  20:59:17  rushing
 * Added .ini param to force use of XHDR over XOVER
 *
 * Revision 1.33  1994/02/04  02:19:12  rushing
 * added GenSockDLL .ini param
 *
 * Revision 1.32  1994/01/24  17:39:47  jcoop
 * 90.2 changes
 *
 * Revision 1.31  1994/01/17  21:54:58  jcoop
 * New entries for colors/fonts, sig files, attachments, decoding
 *
 * Revision 1.30  1994/01/12  19:25:59  mrr
 * mrr mods 4
 * 
 * Revision 1.29  1994/01/05  22:36:43  mrr
 * BLOCK_SIZE=4096
 *
 * Revision 1.28  1993/12/08  20:21:15  dumoulin
 * Added support for using Shift-Mouse-Left inplace of Mouse-Middle and
 * support for dragging mouse to set article Seen flag
 *
 * Revision 1.27  1993/12/08  01:29:07  rushing
 * new version box and cr lf consistency
 *
 * Revision 1.26  1993/08/25  18:55:19  mbretherton
 * MRB merge, mail & post logging
 *
 *
 * remove vRef (for Macintosh only)
 * include Mail and Post Log variables
 *
 * Revision 1.25  1993/08/18  21:49:21  rushing
 * more 16-bit article number fixes.
 *
 * Revision 1.24  1993/08/17  21:48:44  dumoulin
 * Added variable for Mouse Dragging
 *
 * Revision 1.23  1993/08/05  20:06:07  jcoop
 * save multiple articles changes by jcoop@@oakb2s01.apl.com (John S Cooper)
 *
 * Revision 1.22  1993/07/13  16:03:04  riordan
 * MRR mods
 *
 * Revision 1.21  1993/07/09  19:13:36  rushing
 * alignment problem.  Sigh.
 *
 * Revision 1.20  1993/07/06  21:09:09  cnolan
 * win32 support
 *
 * Revision 1.19  1993/06/28  17:52:17  rushing
 * fixed compiler warnings
 *
 * Revision 1.18  1993/06/25  20:27:10  dumoulin
 * Added StringDate to support POSIX standard numeric dates
 *
 * Revision 1.17  1993/06/22  19:08:56  rushing
 * mail force type selection via dialog
 *
 * Revision 1.16  1993/06/22  16:43:58  bretherton
 * remove mail type MT_POP add enable forward menus seperate from mail
 *
 * Revision 1.15  1993/06/22  16:14:21  rushing
 * unsigned long for article number
 *
 * Revision 1.14  1993/06/14  17:05:16  rushing
 * made the MAILLEN define larger.  48 -> 255
 *
 * Revision 1.13  1993/06/11  00:11:26  rushing
 * second merge from Matt Bretherton sources
 *
 * Revision 1.12  1993/06/10  18:25:40  rushing
 * XOVER support and did_list variable (newsrc&dolist problem fixed)
 *
 * Revision 1.11  1993/06/01  18:23:17  rushing
 * moved header funcs to headarry.c
 *
 * Revision 1.10  1993/05/29  03:32:30  rushing
 * threading support
 *
 * Revision 1.9  1993/05/28  17:32:11  rushing
 * made the #defines for ST_XHDR_SUBJ jive with the other new ones.
 *
 * Revision 1.8  1993/05/28  17:18:00  rushing
 * Added Misc... option to enable threading
 *
 * Revision 1.7  1993/05/24  23:57:22  rushing
 * rot13 merge (MRB)
 *
 * Revision 1.6  1993/05/18  22:10:45  rushing
 * smtp support
 *
 * Revision 1.5  1993/05/13  20:00:38  rushing
 * fancy 'from' in group window
 *
 * Revision 1.4  1993/05/13  16:17:45  rushing
 * article fetch limit support
 *
 * Revision 1.3  1993/03/30  20:49:30  DUMOULIN
 * MAPI
 *
 * Revision 1.2  1993/03/30  17:08:12  rushing
 * Added global handle for printer font.
 *
 * Revision 1.1  1993/02/16  20:54:42  rushing
 * Initial revision
 *
 *
d136 4
a139 1

@


1.40
log
@support for horizontal scrolling
@
text
@d8 1
a8 1
 * $Id: wvglob.h 1.39 1994/05/23 19:51:51 rushing Exp $
d10 3
d170 1
@


1.39
log
@NNTPPort becomes NNTPService, and it's a string.
@
text
@d8 1
a8 1
 * $Id: wvglob.h 1.38 1994/05/23 18:37:00 jcooper Exp rushing $
d10 3
d162 2
a163 1
   unsigned int TotalLines;   /* total # of lines in doc.                 */
d184 1
d334 1
a334 1
#define NUMKEYS 4
d346 4
a349 2
 VK_UP,    1, WM_VSCROLL,SB_LINEUP,
 VK_DOWN,  1, WM_VSCROLL,SB_LINEDOWN
@


1.38
log
@new attach code, session [dis]connect
@
text
@d8 1
a8 1
 * $Id: wvglob.h 1.37 1994/05/02 20:32:55 rushing Exp $
d10 3
d414 1
a414 1
DEF int NNTPPort;
@


1.37
log
@changes from jody glasser
@
text
@d8 1
a8 1
 * $Id: wvglob.h 1.36 1994/03/01 19:10:19 rushing Exp rushing $
d10 3
d351 2
d423 1
d694 2
d800 4
d819 3
a821 2
DEF int  EncodingType;
DEF int  WhenToAttach;	// == IDD_ATTACH_NOW or _NEXT
d824 1
@


1.36
log
@ThreadFullSubject option added
@
text
@d8 1
a8 1
 * $Id: wvglob.h 1.35 1994/02/24 21:28:49 jcoop Exp rushing $
d10 3
d651 1
@


1.35
log
@jcoop changes
@
text
@d8 1
a8 1
 * $Id: wvglob.h 1.34 1994/02/16 20:59:17 rushing Exp $
d10 3
d647 1
@


1.34
log
@Added .ini param to force use of XHDR over XOVER
@
text
@d8 1
a8 1
 * $Id: wvglob.h 1.33 1994/02/04 02:19:12 rushing Exp rushing $
d10 3
d128 1
a128 1
#define MAXDIALOGSTRING 120
d407 1
d422 1
d519 2
d569 1
d587 1
d614 1
d629 1
d765 1
a765 1
  char	codingTable[100];	/* coding table for blocks in this thread */
d776 7
a782 7
#define ENCODE_BASE64   1
#define ENCODE_UU       2
#define ENCODE_XX       3
#define ENCODE_CUSTOM   4
#define ENCODE_QP   	5
#define ENCODE_UNKNOWN	6
#define ENCODE_NONE     0
d785 2
d796 2
d821 6
@


1.33
log
@added GenSockDLL .ini param
@
text
@d8 1
a8 1
 * $Id: wvglob.h 1.32 1994/01/24 17:39:47 jcoop Exp rushing $
d10 3
d393 1
@


1.32
log
@90.2 changes
@
text
@d8 1
a8 1
 * $Id: wvglob.h 1.31 1994/01/17 21:54:58 jcoop Exp $
d10 3
d403 1
@


1.31
log
@New entries for colors/fonts, sig files, attachments, decoding
@
text
@d8 1
a8 1
 * $Id: wvglob.h 1.31 1994/01/17 21:41:20 jcoop Exp $
d10 3
d369 1
d504 2
d801 1
@


1.30
log
@mrr mods 4
@
text
@d8 1
a8 1
 * $Id: wvglob.h 1.29 1994/01/05 22:36:43 mrr Exp $
d10 3
d113 1
d118 10
a272 7
#define MAXFILENAME 60
#define MAXCHARS 80
#define MAXLINES 24
/* this has been increased for XOVER - some lines are *very* long */
#define MAXCOMMLINE      1536
#define MAXINTERNALLINE   180
#define MAXOUTLINE    255
a274 1

a300 1

d333 2
a334 2
#define MAXPOSTWNDS    4
#define MAXMAILWNDS    4
d365 1
a374 1
DEF BOOL SaveNewsrc;      /* =TRUE iff we write NEWSRC upon exit */
d443 2
d504 5
d521 3
a523 3
DEF HANDLE hFont;     /* handle to font used in all windows except article */
DEF HANDLE hFontArtNormal;  /* handle to font used in Article window - normal text mode. */
DEF HANDLE hFontArtQuote;  /* handle to font used in Article window - comments == Italics. */
d528 1
d530 1
a530 2

DEF int FontSize;
d533 4
a536 2
DEF int FontBold;
DEF char FontFace[32];
d538 1
d540 2
d543 1
a543 1
DEF unsigned int LineHeight,CharWidth;  /* # of window units for current font */
d545 1
d549 16
a565 3
DEF DWORD OldTextColor, OldBkColor;
DEF DWORD NetUnSubscribedColor;  /* color to use for unsubscribed groups  */
DEF DWORD GroupSeenColor;        /* color to use for articles that have been seen */
d600 5
d613 1
d645 10
a656 10
#define ARTICLE_ACTION_SAVE   0
#define COMPARE         1
#define NO_COMPARE      0
#define SHOW         1
#define NO_SHOW         0
#define REUSE        1
#define NO_REUSE     0
#define SELECT       1
#define DESELECT     0

d694 103
@


1.29
log
@BLOCK_SIZE=4096
@
text
@d8 1
a8 1
 * $Id: wvglob.h 1.28 1993/12/08 20:21:15 dumoulin Exp mrr $
d10 3
d129 1
a129 1
   TypLineID  AddLineID;      /* LineID of point to add lines.            */
d133 1
a133 1
   unsigned int TopLineOrd;   /* ordinal in doc of line line in window    */
d162 1
d172 1
d182 8
a189 8
  char		Subscribed;	/* =TRUE if subscribed to this group.   */
  char		Selected;	/* =TRUE if selected                    */
  int		NameLen;	/* # of bytes in group name             */
  TypDoc	*SubjDoc;	/* points to doc containing subjs       */
  unsigned long	ServerEstNum;	/* est # of arts in server              */
  unsigned long	ServerFirst;	/* # of first art that server has.      */
  unsigned long	ServerLast;	/* # of last art that server has.       */
  unsigned long	HighestPrevSeen; /* # of highest art server had in last  */
d191 4
a194 4
  HANDLE	header_handle;	/* handle to global block of header array mem */
  HANDLE	thread_handle;	/* handle to global block of thread ind. pointers */
  long int	total_headers;	/* total # of headers in array */
  unsigned int  nRanges;	/* # of TypRanges describing seen arts  */
d200 5
a204 5
  unsigned long	Number;		/* Server's number for this article    */
  char		Seen;		/* =TRUE if article seen               */
  char		Selected;	/* =TRUE if article selected           */
  TypDoc	*ArtDoc;	/* points to doc with actual article   */
  int		NameLen;	/* # of bytes in subject line */
d212 4
a215 4
#define HEADER_SUBJECT_LENGTH		105
#define HEADER_FROM_LENGTH		74
#define HEADER_MESSAGE_ID_LENGTH	30
#define HEADER_REFERENCES_LENGTH	30
d288 1
d408 1
a408 1
#define ST_MAIL_WAIT_END			 14
d411 16
a426 16
#define ST_END_AUTHINFO 			  22
#define ST_XHDR_FROM_START	  50
#define ST_XHDR_FROM_DATA	  51
#define ST_XHDR_SUBJ_START	  52
#define ST_XHDR_SUBJ_DATA	  53
#define ST_XHDR_REF_START	  54
#define ST_XHDR_REF_DATA	  55
#define ST_XHDR_MID_START	  56
#define ST_XHDR_MID_DATA	  57
#define ST_XHDR_DATE_START	  58
#define ST_XHDR_DATE_DATA	  59
#define ST_XHDR_LINES_START	  60
#define ST_XHDR_LINES_DATA	  61
#define ST_XOVER_START		  62
#define ST_XOVER_DATA		  63
#define ST_XOVER_CHECK		  64
d451 1
d492 4
a495 1
DEF int numArtsSaved;
d541 1
a541 1
				   Less then zero means
d606 3
d610 9
a618 9
#define ARTICLE_ACTION_SAVE	0
#define COMPARE			1
#define NO_COMPARE		0
#define SHOW			1
#define NO_SHOW			0
#define REUSE			1
#define NO_REUSE		0
#define SELECT			1
#define DESELECT		0
d645 2
a646 2
	(*fnMlLogout)(HWND hWnd),
	(*fnMlClose)(HWND hWnd),
@



1.28
log
@Added support for using Shift-Mouse-Left inplace of Mouse-Middle and
support for dragging mouse to set article Seen flag
@
text
@d8 1
a8 1
 * $Id: wvglob.h 1.27 1993/12/08 01:29:07 rushing Exp dumoulin $
d10 4
d269 1
a269 1
#define BLOCK_SIZE  1024
@



1.27
log
@new version box and cr lf consistency
@
text
@d8 1
a8 1
 * $Id: wvglob.h 1.26 1993/08/25 18:55:19 mbretherton Exp rushing $
d10 3
d460 2
@



1.26
log
@MRB merge, mail & post logging
@
text
@a0 1

a5 1

d8 1
a8 1
 * $Id: wvglob.h 1.25 1993/08/18 21:49:21 rushing Exp $
d10 3
@



1.25
log
@more 16-bit article number fixes.
@
text
@d10 1
a10 1
 * $Id: wvglob.h 1.24 1993/08/17 21:48:44 dumoulin Exp rushing $
d12 7
d246 1
d319 11
a329 6
DEF TypDoc PostingDocs[MAXPOSTWNDS];
DEF TypDoc MailDocs[MAXMAILWNDS];
DEF HWND  hWndPosts[MAXPOSTWNDS];
DEF HWND  hWndMails[MAXMAILWNDS];
DEF HWND  hWndPostEdits[MAXPOSTWNDS];
DEF HWND  hWndMailEdits[MAXMAILWNDS];
d331 3
d347 1
d523 7
d548 1
a555 1
#define MAXFILENAME 60
a560 1
DEF int  SaveArtvRef;   /* volume ref num used only by Mac */
@



1.24
log
@Added variable for Mouse Dragging
@
text
@d10 1
a10 1
 * $Id: wvglob.h 1.23 1993/08/05 20:06:07 jcoop Exp dumoulin $
d12 3
d162 15
a176 15
   char		Subscribed;	/* =TRUE if subscribed to this group.   */
   char		Selected;	/* =TRUE if selected                    */
   int		NameLen;	/* # of bytes in group name             */
   TypDoc	*SubjDoc;	/* points to doc containing subjs       */
   unsigned int	ServerEstNum;	/* est # of arts in server              */
   long int	ServerFirst;	/* # of first art that server has.      */
   long int	ServerLast;	/* # of last art that server has.       */
   long int	HighestPrevSeen; /* # of highest art server had in last  */
				/* session, from "s<num>" newsrc field  */
   HANDLE	header_handle;	/* handle to global block of header array mem */
   HANDLE	thread_handle;	/* handle to global block of thread ind. pointers */
   long int	total_headers;	/* total # of headers in array */
   unsigned int  nRanges;	/* # of TypRanges describing seen arts  */
   /* Name of group */            /* name of group, zero-terminated       */
   /* Ranges of articles seen */  /* array of TypRanges, of seen articles */
d180 6
a185 6
   long int Number;            /* Server's number for this article    */
   char         Seen;              /* =TRUE if article seen               */
   char         Selected;          /* =TRUE if article selected           */
   TypDoc      *ArtDoc;            /* points to doc with actual article   */
   int         NameLen;       /* # of bytes in subject line */
   /* Subject line of article */
@



1.23
log
@save multiple articles changes by jcoop@@oakb2s01.apl.com (John S Cooper)
@
text
@d1 7
d10 1
a10 1
 * $Id: wvglob.h 1.22 1993/07/13 16:03:04 riordan Exp $
d12 3
a83 6
/*---  This is WVGLOB.H  ------------------------------------------- */
/* WVGLOB.H contains all the global types and variables for WinVN.   */
/* Stylistically, this should probably be separated into several     */
/* header files, but this is what you've got for now.                */
/* cf WVDOC.C -- it describes some of these structures.              */

d101 2
a102 1
   unsigned int HeaderLines;  /* total number of lines in header of doc (incl. blank line) */
d189 5
d198 1
a198 1
   char subject[105];
d203 3
a205 3
   char from[74];
   char message_id[30];
   char references[30];
a311 1
#ifndef MAC
a313 6
#else
DEF TEHandle TEHPosts[MAXPOSTWNDS];
DEF TEHandle TEHCurrent;
DEF ControlHandle    vScroll;
DEF int           linesInFolder;
#endif
d423 1
a423 1
DEF char str[255];                              /* general-purpose string buffer */
d426 2
a427 2
DEF HCURSOR hSaveCursor;                        /* handle to current cursor      */
DEF HCURSOR hHourGlass;                         /* handle to hourglass cursor    */
d430 2
a431 1
DEF int X, Y;                                   /* last cursor position          */
d433 3
d437 1
a437 1
DEF POINT ptCursor;                             /* x and y coordinates of cursor */
@



1.22
log
@MRR mods
@
text
@d3 1
a3 1
 * $Id: wvglob.h 1.21 1993/07/09 19:13:36 rushing Exp $
d5 3
d447 2
d503 1
d549 1
a549 1
#define LINE_FLAG_SET        0
d553 10
@



1.21
log
@alignment problem.  Sigh.
@
text
@d3 1
a3 1
 * $Id: wvglob.h 1.20 1993/07/06 21:09:09 cnolan Exp $
d5 3
d343 2
d368 4
a371 1
#define ST_MAIL_WAIT_END          14
@



1.20
log
@win32 support
@
text
@d3 1
a3 1
 * $Id: wvglob.h 1.19 1993/06/28 17:52:17 rushing Exp $
d5 3
d182 1
a186 1
   char subject[105];
@



1.19
log
@fixed compiler warnings
@
text
@d3 1
a3 1
 * $Id: wvglob.h 1.18 1993/06/25 20:27:10 dumoulin Exp rushing $
d5 3
d70 4
@



1.18
log
@Added StringDate to support POSIX standard numeric dates
@
text
@d3 1
a3 1
 * $Id: wvglob.h 1.17 1993/06/22 19:08:56 rushing Exp dumoulin $
d5 3
d150 1
a150 1
   int  nRanges;		/* # of TypRanges describing seen arts  */
d424 1
a424 1
DEF int article_threshold;
d456 2
a457 2
DEF int LineHeight,CharWidth;  /* # of window units for current font          */
DEF int ArtLineHeight, ArtCharWidth; /* # of windows units for article font */
@



1.17
log
@mail force type selection via dialog
@
text
@d3 1
a3 1
 * $Id: wvglob.h 1.16 1993/06/22 16:43:58 bretherton Exp rushing $
d5 3
d70 2
d163 1
a163 1
/* (+ 1 1 1 4 2 7 102 74 30 30 4) => 256 */
d171 3
a173 2
   char date[7];
   char subject[102];
@



1.16
log
@remove mail type MT_POP add enable forward menus seperate from mail
@
text
@d3 1
a3 1
 * $Id: wvglob.h 1.15 1993/06/22 16:14:21 rushing Exp $
d5 3
d462 1
a462 1
				   Less then or equal to zero means
@



1.15
log
@unsigned long for article number
@
text
@d3 1
a3 1
 * $Id: wvglob.h 1.14 1993/06/14 17:05:16 rushing Exp rushing $
d5 3
d541 1
d554 1
a554 2
#define MT_POP  2
#define MT_SMTP 3
@



1.14
log
@made the MAILLEN define larger.  48 -> 255
@
text
@d3 1
a3 1
 * $Id: wvglob.h 1.13 1993/06/11 00:11:26 rushing Exp rushing $
d5 3
d152 1
a152 1
/* (+ 1 1 1 2 2 6 105 74 30 30 4) => 256 */
d158 1
a158 1
   unsigned int  number;
d161 1
a161 1
   char subject[104];
@



1.13
log
@second merge from Matt Bretherton sources
@
text
@d3 1
a3 1
 * $Id: wvglob.h 1.12 1993/06/10 18:25:40 rushing Exp $
d5 3
d313 1
a313 1
#define MAILLEN 48
@



1.12
log
@XOVER support and did_list variable (newsrc&dolist problem fixed)
@
text
@d3 1
a3 1
 * $Id: wvglob.h 1.11 1993/06/01 18:23:17 rushing Exp rushing $
d5 3
d447 9
d467 1
d469 1
d529 11
a539 8
  int MailType   ;
  int enableMail ;
  int (*fnMlInit)(HWND hWnd),  
      (*fnMlLogout)(HWND hWnd), 
      (*fnMlWinCreate)(HWND hWnd,TypDoc *Doc,int DocType),
      (*fnMlSend)(HWND hWnd, char *mBuf),
      (*fnMlForward)(HWND hWnd, TypDoc * Doc);
  BOOL (**MailHeaderFuncs)(TypDoc * Doc, char *Buf, long int BufLen) ;
@



1.11
log
@moved header funcs to headarry.c
@
text
@d3 1
a3 1
 * $Id: wvglob.h 1.10 1993/05/29 03:32:30 rushing Exp rushing $
d5 3
d151 2
a152 2
   char date[6];
   char subject[105];
d188 2
a189 1
#define MAXCOMMLINE      140
d300 1
d342 3
d399 1
@



1.10
log
@threading support
@
text
@d3 1
a3 1
 * $Id: wvglob.h 1.9 1993/05/28 17:32:11 rushing Exp rushing $
d5 3
d138 4
a141 2
/* this can now obsolete the article struct */
/* #(++,10,#(++,6,#(++,4,#(++,#(++,#(++, 101, 75),30),30)))) */
d145 1
d150 1
a150 1
   char from[75];
d159 4
@



1.9
log
@made the #defines for ST_XHDR_SUBJ jive with the other new ones.
@
text
@d3 1
a3 1
 * $Id: wvglob.h 1.8 1993/05/28 17:18:00 rushing Exp rushing $
d5 3
a13 1
 *
d109 13
a121 12
   char          Subscribed;      /* =TRUE if subscribed to this group.   */
   char          Selected;        /* =TRUE if selected                    */
   int           NameLen;         /* # of bytes in group name             */
   TypDoc        *SubjDoc;        /* points to doc containing subjs       */
   unsigned int  ServerEstNum;    /* est # of arts in server              */
   long int  ServerFirst;     /* # of first art that server has.      */
   long int  ServerLast;      /* # of last art that server has.       */
   long int  HighestPrevSeen;     /* # of highest art server had in last  */
                                  /* session, from "s<num>" newsrc field  */
   HANDLE	header_handle;
   long int	total_headers;    /* total # of headers in array */
   int  nRanges;                  /* # of TypRanges describing seen arts  */
d149 4
@



1.8
log
@Added Misc... option to enable threading
@
text
@d3 1
a3 1
 * $Id: wvglob.h 1.7 1993/05/24 23:57:22 rushing Exp rushing $
d5 3
d296 2
a297 2
#define ST_XHDR_RESP               3
#define ST_XHDR_SUBJ               4
@



1.7
log
@rot13 merge (MRB)
@
text
@d3 1
a3 1
 * $Id: wvglob.h 1.6 1993/05/18 22:10:45 rushing Exp $
d5 2
d8 1
d274 3
@



1.6
log
@smtp support
@
text
@d3 1
a3 1
 * $Id: wvglob.h 1.5 1993/05/13 20:00:38 rushing Exp rushing $
d5 4
d44 1
d381 2
a382 1
DEF HANDLE hFontArt;      /* handle to font used in Article window. */
d409 1
@



1.5
log
@fancy 'from' in group window
@
text
@d3 1
a3 1
 * $Id: wvglob.h 1.4 1993/05/13 16:17:45 rushing Exp rushing $
d5 3
d32 1
a32 1
#define MAXSUBJECTSTRING 120
d269 1
d406 1
a406 1
DEF FARPROC lpfnWinVnSubjectDlg;
d422 5
a426 3
DEF char SubjectString[MAXSUBJECTSTRING];
DEF char AddressString[MAXSUBJECTSTRING];
DEF char NameString[MAXSUBJECTSTRING];DEF int  SaveArtvRef;   /* volume ref num used only by Mac */
d473 8
a480 7
    int MailType   ;
    int enableMail ;
	int (*fnMlInit)(HWND hWnd),  
            (*fnMlLogout)(HWND hWnd), 
	    (*fnMlWinCreate)(HWND hWnd,TypDoc *Doc,int DocType),
            (*fnMlSend)(HWND hWnd, char *mBuf) ;
	BOOL (**MailHeaderFuncs)(TypDoc * Doc, char *Buf, long int BufLen) ;
d485 2
a486 1
#define MT_POP 2
@



1.4
log
@article fetch limit support
@
text
@d3 1
a3 1
 * $Id: wvglob.h 1.3 1993/03/30 20:49:30 DUMOULIN Exp rushing $
d5 3
d368 1
@



1.3
log
@MAPI
@
text
@d3 1
a3 1
 * $Id: wvglob.h 1.2 1993/03/30 17:08:12 rushing Exp $
d5 3
d353 2
d405 1
@



1.2
log
@Added global handle for printer font.
@
text
@d3 5
a7 2
 * $Id: wvglob.h%v 1.1 1993/02/16 20:54:42 rushing Exp rushing $
 * $Log: wvglob.h%v $
d296 1
a296 1

d409 2
a410 1
DEF int  SaveArtvRef;   /* volume ref num used only by Mac */
d451 18
@



1.1
log
@Initial revision
@
text
@d3 4
a6 2
 * $Id$
 * $Log$
d8 1
d364 1
@

