head	 1.69;
branch   ;
access   ;
symbols  V80:1.17 V76d:1.3;
locks    ; strict;
comment  @ * @;


1.69
date	 94.09.18.22.35.49;  author jcooper;  state Exp;
branches ;
next	 1.68;

1.68
date	 94.09.16.01.13.18;  author jcooper;  state Exp;
branches ;
next	 1.67;

1.67
date	 94.08.26.21.08.04;  author dumoulin;  state Exp;
branches ;
next	 1.66;

1.66
date	 94.08.24.18.40.15;  author mrr;  state Exp;
branches ;
next	 1.65;

1.65
date	 94.08.11.02.25.59;  author dumoulin;  state Exp;
branches ;
next	 1.64;

1.64
date	 94.08.11.00.13.22;  author jcooper;  state Exp;
branches ;
next	 1.63;

1.63
date	 94.08.05.21.33.22;  author finken;  state Exp;
branches ;
next	 1.62;

1.62
date	 94.08.04.06.30.36;  author dumoulin;  state Exp;
branches ;
next	 1.61;

1.61
date	 94.07.27.21.34.22;  author pearse_w_r;  state Exp;
branches ;
next	 1.60;

1.60
date	 94.07.27.21.33.47;  author pearse_w_r;  state Exp;
branches ;
next	 1.59;

1.59
date	 94.07.27.20.08.57;  author rushing;  state Exp;
branches ;
next	 1.58;

1.58
date	 94.07.25.23.32.16;  author rushing;  state Exp;
branches ;
next	 1.57;

1.57
date	 94.07.25.22.39.06;  author rushing;  state Exp;
branches ;
next	 1.56;

1.56
date	 94.07.25.18.51.48;  author jcooper;  state Exp;
branches ;
next	 1.55;

1.55
date	 94.06.30.16.34.44;  author dumoulin;  state Exp;
branches ;
next	 1.54;

1.54
date	 94.06.23.23.09.05;  author dumoulin;  state Exp;
branches ;
next	 1.53;

1.53
date	 94.06.17.09.09.30;  author dumoulin;  state Exp;
branches ;
next	 1.52;

1.52
date	 94.06.09.21.47.08;  author rushing;  state Exp;
branches ;
next	 1.51;

1.51
date	 94.06.09.18.39.34;  author rushing;  state Exp;
branches ;
next	 1.50;

1.50
date	 94.06.08.21.01.45;  author gardnerd;  state Exp;
branches ;
next	 1.49;

1.49
date	 94.06.06.22.06.13;  author gardnerd;  state Exp;
branches ;
next	 1.48;

1.48
date	 94.06.02.00.17.07;  author rushing;  state Exp;
branches ;
next	 1.47;

1.47
date	 94.05.27.01.29.29;  author rushing;  state Exp;
branches ;
next	 1.46;

1.46
date	 94.05.26.22.43.06;  author jglasser;  state Exp;
branches ;
next	 1.45;

1.45
date	 94.05.23.18.36.00;  author jcooper;  state Exp;
branches ;
next	 1.44;

1.44
date	 94.05.19.02.02.10;  author rushing;  state Exp;
branches ;
next	 1.43;

1.43
date	 94.05.02.20.33.46;  author rushing;  state Exp;
branches ;
next	 1.42;

1.42
date	 94.03.22.22.44.24;  author rushing;  state Exp;
branches ;
next	 1.41;

1.41
date	 94.02.24.21.35.41;  author jcoop;  state Exp;
branches ;
next	 1.40;

1.40
date	 94.02.16.21.05.33;  author cnolan;  state Exp;
branches ;
next	 1.39;

1.39
date	 94.02.16.20.59.17;  author rushing;  state Exp;
branches ;
next	 1.38;

1.38
date	 94.02.09.18.01.08;  author cnolan;  state Exp;
branches ;
next	 1.37;

1.37
date	 94.01.24.17.40.28;  author jcoop;  state Exp;
branches ;
next	 1.36;

1.36
date	 94.01.17.21.54.16;  author jcoop;  state Exp;
branches ;
next	 1.35;

1.35
date	 94.01.12.19.46.06;  author cedwards;  state Exp;
branches ;
next	 1.34;

1.34
date	 94.01.12.19.27.55;  author mrr;  state Exp;
branches ;
next	 1.33;

1.33
date	 94.01.05.22.36.05;  author rushing;  state Exp;
branches ;
next	 1.32;

1.32
date	 93.12.08.01.28.01;  author rushing;  state Exp;
branches ;
next	 1.31;

1.31
date	 93.12.01.23.24.06;  author rushing;  state Exp;
branches ;
next	 1.30;

1.30
date	 93.11.24.23.07.20;  author rushing;  state Exp;
branches ;
next	 1.29;

1.29
date	 93.11.22.20.30.50;  author rushing;  state Exp;
branches ;
next	 1.28;

1.28
date	 93.08.25.18.53.17;  author mbretherton;  state Exp;
branches ;
next	 1.27;

1.27
date	 93.08.25.17.05.17;  author mbretherton;  state Exp;
branches ;
next	 1.26;

1.26
date	 93.08.18.21.49.21;  author rushing;  state Exp;
branches ;
next	 1.25;

1.25
date	 93.08.05.20.06.07;  author jcoop;  state Exp;
branches ;
next	 1.24;

1.24
date	 93.07.13.16.03.04;  author riordan;  state Exp;
branches ;
next	 1.23;

1.23
date	 93.06.28.17.52.17;  author rushing;  state Exp;
branches ;
next	 1.22;

1.22
date	 93.06.25.20.18.51;  author dumoulin;  state Exp;
branches ;
next	 1.21;

1.21
date	 93.06.22.16.43.03;  author bretherton;  state Exp;
branches ;
next	 1.20;

1.20
date	 93.06.22.14.04.05;  author dumoulin;  state Exp;
branches ;
next	 1.19;

1.19
date	 93.06.19.18.40.17;  author dumoulin;  state Exp;
branches ;
next	 1.18;

1.18
date	 93.06.15.21.16.59;  author rushing;  state Exp;
branches ;
next	 1.17;

1.17
date	 93.06.11.00.10.35;  author rushing;  state Exp;
branches ;
next	 1.16;

1.16
date	 93.06.10.18.25.17;  author rushing;  state Exp;
branches ;
next	 1.15;

1.15
date	 93.06.08.19.42.38;  author rushing;  state Exp;
branches ;
next	 1.14;

1.14
date	 93.06.05.03.18.25;  author rushing;  state Exp;
branches ;
next	 1.13;

1.13
date	 93.06.01.18.22.40;  author rushing;  state Exp;
branches ;
next	 1.12;

1.12
date	 93.05.26.23.59.40;  author rushing;  state Exp;
branches ;
next	 1.11;

1.11
date	 93.05.24.23.56.51;  author rushing;  state Exp;
branches ;
next	 1.10;

1.10
date	 93.05.13.19.58.09;  author SOMEONE;  state Exp;
branches ;
next	 1.9;

1.9
date	 93.05.13.16.16.06;  author rushing;  state Exp;
branches ;
next	 1.8;

1.8
date	 93.05.08.17.11.05;  author rushing;  state Exp;
branches ;
next	 1.7;

1.7
date	 93.04.29.21.42.11;  author rushing;  state Exp;
branches ;
next	 1.6;

1.6
date	 93.04.29.20.24.59;  author rushing;  state Exp;
branches ;
next	 1.5;

1.5
date	 93.04.27.21.03.20;  author rushing;  state Exp;
branches ;
next	 1.4;

1.4
date	 93.04.23.22.10.48;  author rushing;  state Exp;
branches ;
next	 1.3;

1.3
date	 93.02.18.20.34.16;  author rushing;  state Exp;
branches ;
next	 1.2;

1.2
date	 93.02.16.21.20.28;  author rushing;  state Exp;
branches ;
next	 1.1;

1.1
date	 93.02.16.20.54.22;  author rushing;  state Exp;
branches ;
next	 ;


desc
@winvn version 0.76 placed into RCS
@


1.69
log
@New window cascade routines, and cleanup of other batch window ops
@
text
@/*
 * $Id: wvutil.c 1.68 1994/09/16 01:13:18 jcooper Exp $
 *
 */

/*-- WVUTIL.C -- File containing utility routines.
 */

#include <windows.h>
#include <windowsx.h>      // for GlobalFreePtr (JSC)
#include "wvglob.h"
#include "winvn.h"
#pragma hdrstop
#include <commdlg.h>    // for GetOpenFileName dialog (JSC)
#include <ctype.h>
#include <stdlib.h>
#include <time.h>

char far *mylstrcpy (char_p ptr1, char far * ptr2);
char *get_xhdr_line (char *line);
time_t parse_usenet_date (char *date);
void finish_header_retrieval ();
void GenerateFileFilters (HWND hParentWnd, char *filters);

// please update this if you modify XHDR retrieval
// This will now be either 4 or 6, depending on whether threading
// is enabled via 'threadp'.
unsigned int total_xhdrs = 4;

/*--- function GetNum --------------------------------------------
 *
 *  Cracks off a positive integer number from a string.
 *
 *  Entry    *ptr  is the character position to start scanning
 *                 for an integer
 *
 *  Exit     *ptr  is the character position at which we stopped
 *                 scanning (because of a non-digit).
 *           *num  is the cracked off number.
 *           Returns TRUE iff we got a number.
 */
BOOL
GetNum (ptr, num)
     char **ptr;
     long int *num;
{
  BOOL gotit = FALSE;

  /* Skip initial spaces                                            */

  while ((**ptr) && **ptr == ' ')
    (*ptr)++;

  *num = 0;
  while (**ptr && isdigit (**ptr)) {
    *num = 10 * (*num) + (**ptr - '0');
    gotit = TRUE;
    (*ptr)++;
  }
  return (gotit);
}

char *
get_xhdr_line (char *line)
{
  char *cptr;
/* skip past the art # and space */
  for (cptr = line; isdigit (*cptr); cptr++);
  for (; *cptr == ' '; cptr++);
  return (cptr);
}

#if 0
MRB already did this
void
make_neat_from (char far * in, char far * out)
{
  char far *left, far * right;

  /* this is controlled from .ini */
  if (FullNameFrom) {
    left = strchr (in, '(');
    right = strrchr (in, ')');

    if ((left && right) && (left < right)) {
      strncpy (out, left + 1, (size_t) (right - left - 1));
      out[(right - left - 1)] = (char) 0;
    }
    else       /* No name in parens */
      strcpy (out, in);
  }
  else            /* !FullNameFrom */
    strcpy (out, in);
}
#endif

/*-- function StrToRGB -------------------------------------------------
 *
 *  Takes an ASCII string of the form "r,g,b" where r, g, and b are
 *  decimal ASCII numbers, and converts it to an RGB color number.
 */
COLORREF
StrToRGB (cstring)
     char *cstring;
{
  BYTE red, green, blue;
  long int lred, lgreen, lblue;

  GetNum (&cstring, &lred);
  cstring++;
  GetNum (&cstring, &lgreen);
  cstring++;
  GetNum (&cstring, &lblue);
  red = (BYTE) lred;
  green = (BYTE) lgreen;
  blue = (BYTE) lblue;

  return (RGB (red, green, blue));
}

/*-- function RGBToStr -------------------------------------------------
 *
 *  Takes an RGB color ref and converts to a string of the form "r,g,b"
 *  result is placed in buf
 *  (JSC)
 */
char *
RGBToStr (char *buf, DWORD rgbVal)
{
  sprintf (buf, "%u,%u,%u", GetRValue (rgbVal),
      GetGValue (rgbVal),
      GetBValue (rgbVal));
  return (buf);
}

/* This was lifted from ANU news. */

time_t
parse_usenet_date (char *s)
{
  struct tm datetime;
  char *cp, mon[80];
  int dom = 0, yr = 0, hr = 0, mn = 0, sc = 0, mth = 0;
  static char fmtMonthTable[37] = "janfebmaraprmayjunjulaugsepoctnovdec";

  if (!s || !*s)
    return (0);
  if (cp = strchr (s, ','))
    s = ++cp;
  while (isspace (*s))
    s++;
  *mon = '\0';
  if (isdigit (*s)) {
    sscanf (s, "%d %s %d %d:%d:%d", &dom, mon, &yr, &hr, &mn, &sc);
    if (yr < 100)
      yr += 1900;
  }
  else
    sscanf (s, "%*s %s %d %d:%d:%d %d", mon, &dom, &hr, &mn, &sc, &yr);

  if (!dom || !yr || !*(cp = mon))
    return (0);
  if ((dom <= 0) || (dom >= 32))
    return (0);
  if ((yr < 1980) || (yr > 2020))
    return (0);
  if (strlen (mon) > 10)
    return (0);
  if ((hr < 0) || (hr > 23))
    return (0);
  if ((mn < 0) || (mn > 59))
    return (0);
  if ((sc < 0) || (sc > 59))
    return (0);

  for (cp = mon; *cp; cp++)
    *cp = tolower (*cp);

  if (cp = strstr (fmtMonthTable, mon))
    mth = (cp - fmtMonthTable) / 3;

/*  Setup a Posix time structure and calculate time in absolute
   time (seconds since midnight, Jan 1, 1970    JD 06/25/93 */

  datetime.tm_year = yr - 1900;
  datetime.tm_mon = mth;
  datetime.tm_mday = dom;
  datetime.tm_hour = hr;
  datetime.tm_min = mn;
  datetime.tm_sec = sc;

  return (mktime (&datetime));
}

/*-- function StringDate ----------------*/
char *
StringDate (char *s, time_t time)
{
  struct tm *datetime;
  if (time != 0) {
    datetime = localtime (&time);

    if (fmtDaysB4Mth) {
      sprintf (s, "%02d%s%02d", datetime->tm_mday, fmtDateDelim, datetime->tm_mon + 1);
    }
    else {
      sprintf (s, "%02d%s%02d", datetime->tm_mon + 1, fmtDateDelim, datetime->tm_mday);
    }
    return (s);
  }
  else
    return ("-----");
}

/*-- function DoCommInput ---------------------------------------
 *
 *
 */
void
DoCommInput ()
{
  int ch;

  while ((CommState != ST_CLOSED_COMM) && ((ch = MRRReadComm ()) >= 0)) {
    if (ch == IgnoreCommCh) {
    }
    else if (ch == EOLCommCh) {
      *CommLinePtr = '\0';
      DoCommState ();
      CommLinePtr = CommLineIn;
    }
    else {
      *(CommLinePtr++) = (char) ch;
      if (CommLinePtr == CommLineLWAp1)
   CommLinePtr--;
    }
  }
}

void
update_window_title (HWND hwnd,
           char *group_name,
           unsigned long line_number,
           unsigned long total_lines)
{
  char title[200];
  static int prevPercent, newPercent;
  // to avoid flicker, update percent only if it has changed more than 1%

  line_number *= 100;
  if (newPercent < prevPercent)
    prevPercent = 0;

  if ((line_number % UPDATE_TITLE_FREQ) == 0) {
    newPercent = (int) (line_number / total_lines);
    if (newPercent != prevPercent && newPercent - prevPercent > 1) {
      sprintf (title, "Retrieving headers for '%s' : %d%%", group_name, newPercent);
      SetWindowText (hwnd, title);
      prevPercent = newPercent;
    }
  }
}

int
check_server_code (int retcode)
{
  int class = retcode / 100;
  switch (class) {
  case 5:
    MessageBox (hWndConf, "News Server Error", "WinVN", MB_OK | MB_ICONHAND);
    CommBusy = FALSE;
    CommState = ST_NONE;
    return (1);
    break;
  case 4:
    MessageBox (hWndConf, CommLineIn, "WinVN", MB_OK | MB_ICONHAND);
    switch (class) {
    case 400:
      /* service discontinued */
      MRRCloseComm ();
      PostQuitMessage (0);
      break;
    default:
      break;
    }
    CommBusy = FALSE;
    CommState = ST_NONE;
    return (1);
    break;
  }
  return (0);
}

/*  Function sync_artnum

   Normally XREF returns lists of the same length for each header type
   but some servers have errors that could cause these lists to get
   out of sync. This function tries to find the proper location in the
   headers array and returns that location.  If the article number isn't
   found, it returns -1.  JD 6/19/93 */

long
sync_artnum (unsigned long artnum,
        unsigned long activenum,
        header_p headers, TypGroup far * GroupDoc)
{
  long headerloc = CommDoc->ActiveLines;
  if (artnum == activenum)
    return (headerloc);
  else if (artnum < activenum) {
    while ((artnum != activenum) && (headerloc > 0)) {
      headerloc--;
      if ((header_elt (headers, headerloc))->number == artnum)
   return (headerloc);
    }
    return (-1);
  }
  else {
    while ((artnum != activenum) && (headerloc <= GroupDoc->total_headers)) {
      headerloc++;
      if ((header_elt (headers, headerloc))->number == artnum)
   return (headerloc);
    }
    return (-1);
  }
}

char *
get_best_reference (char *refer)
{
  char *bracket1, *bracket2;
  char *end = refer + strlen (refer) - 1; /* points to NULL */
  int bracket_len;

  bracket1 = strrchr (refer, '<');
  if (bracket1) {
    bracket_len = (int) (end - bracket1) + 2;
    if ((bracket_len < 30) && (!strrchr (bracket1, '>'))) {
      *bracket1 = (char) NULL;
      bracket1 = strrchr (refer, '<');
      if (!bracket1)
   bracket_len = 0;
      else {
   bracket2 = strrchr (refer, '>');
   if (bracket2)
     bracket_len = (int) (bracket2 - bracket1) + 1;
      }
    }
  }
  else
    bracket_len = 0;

  if (!bracket_len)
    return (NULL);
  else if (bracket_len > 29)
    bracket_len = 29;

  if ((bracket1 + bracket_len) < end)
    *(bracket1 + bracket_len) = (char) NULL;

  return (bracket1);
}

/*-- function DoCommState ----------------------------------------------
 *
 *  Function to implement an FSA to process incoming lines from
 *  the server.
 *  This function is called once for each line from the server.
 *
 *    Entry    CommLineIn  is a zero-terminated line received from
 *                         the server.
 *             CommState   is the current state of the FSA.
 */
void
DoCommState ()
{
  static BOOL dialog_active = FALSE;
  TypLine far *LinePtr;
  TypBlock far *BlockPtr;
  HANDLE hBlock;
  unsigned int Offset;
  TypLineID MyLineID;
  int retcode;
  int found;
  unsigned long estnum;
  long int first, last, syncnum;
  unsigned long artnum;
  int mylen;
  BOOL done = FALSE;
  BOOL DlgStatus = FALSE;
  BOOL dolist, do_authinfo;
  static char group[MAXINTERNALLINE];
  char mybuf[MAXINTERNALLINE];
  char mybuf2[MAXINTERNALLINE];
  char far *lpsz;
  HANDLE header_handle;
  HANDLE thread_handle;
  header_p headers;
  header_p header;
  TypGroup far *GroupDoc;
  TypRange *RangePtr;

  /* CommDoc is !NULL if retrieving group list, article headers or articles */
  /* CommDecoding is true if retrieving article in decode mode (not to a doc) */
  /* PostEdit !NULL if we are posting (this is from an edit, no doc involved) */
  if (CommDoc || CommDecoding || PostEdit) {

    switch (CommState) {
    case ST_NONE:
      break;

    case ST_ESTABLISH_COMM:
      if (!sscanf (CommLineIn, "%u", &retcode))
   break;
      if (retcode == 200 || retcode == 201) {   /* was 500 from induced error */
   CommBusy = TRUE;
   do_authinfo = FALSE;
   Authenticated = FALSE;
   if (strlen (NNTPUserName)) {
     /* We have the AUTHINFO username.  Do we have the password? */
     if (!strlen (NNTPPasswordEncrypted)) {
       /* Get the news server user password from the user */
       if (DialogBox (hInst, (LPCSTR) "WinVnComm", hWndConf, (DLGPROC) lpfnWinVnCommDlg)
      && strlen (NNTPPasswordEncrypted)) {
         do_authinfo = TRUE;
       }
     }
     else {
       do_authinfo = TRUE;
     }
   }
   if (do_authinfo) {
     sprintf (mybuf, "AUTHINFO user %s", NNTPUserName);
     CommState = ST_CHECK_AUTHINFO_USERNAME;
     PutCommLine (mybuf);
   }
   else {
     goto End_Authinfo;
   }

      }
      else {
   MessageBox (hWndConf, CommLineIn, "Access Problem", MB_OK);
   /*      MRRCloseComm (); */
   /*        PostQuitMessage (0); */
   Initializing = INIT_NOT_CONNECTED;
   InvalidateRect (hWndConf, NULL, TRUE);
      }

      break;

    case ST_CHECK_AUTHINFO_USERNAME:
      retcode = 0;
      sscanf (CommLineIn, "%u", &retcode);
      if (!retcode)
   break;
      if (retcode >= 500) {
   MessageBox (hWndConf, "Error authorizing your username with the News Server.", "WinVN", MB_OK | MB_ICONHAND);
   goto End_Authinfo;
      }
      MRRDecrypt (NNTPPasswordEncrypted, (unsigned char *) mybuf2, MAXINTERNALLINE);
      sprintf (mybuf, "AUTHINFO pass %s", mybuf2);
      CommState = ST_CHECK_AUTHINFO_PASSWORD;
      PutCommLine (mybuf);
      break;

    case ST_CHECK_AUTHINFO_PASSWORD:
      if (dialog_active)
   break;
      retcode = 0;
      if (sscanf (CommLineIn, "%u", &retcode) <= 0)
   break;
      if (retcode < 200 || retcode > 299) {
   dialog_active = TRUE;
   sprintf (mybuf, "Error authorizing your password with the News Server:\n%s.", CommLineIn);
   MessageBox (hWndConf, mybuf, "WinVN", MB_OK | MB_ICONHAND);
   dialog_active = FALSE;
      } else {                                               
         /* Authentication was successful.  Store this fact, and the name under
          * which the user was authenticated.
          */
         Authenticated = TRUE;
         strncpy(AuthenticatedName,NNTPUserName,MAXNNTPSIZE);
      }
      goto End_Authinfo;


    case ST_END_AUTHINFO:
    End_Authinfo:;
      /* now check for the XOVER command */
      CommState = ST_XOVER_CHECK;
      PutCommLine ("XOVER");
      break;

    case ST_XOVER_CHECK:
      retcode = 0;
      sscanf (CommLineIn, "%u", &retcode);
      if (retcode == 412 && !force_xhdr)  /* 412 == 'not in a newsgroup' */
   xoverp = 1;
      else        /* 500 == 'command not understood' */
   xoverp = 0;

      dolist = DoList;
      if (dolist == ID_DOLIST_ASK - ID_DOLIST_BASE)
   if (MessageBox (hWndConf, "Request the latest group list from server?\n(This can be time consuming)",
         "Request LIST from server?", MB_ICONQUESTION | MB_YESNO | MB_DEFBUTTON2) == IDNO)
     dolist = 0;

      if (dolist) {
   StartList ();
   did_list = 1;
      }
      else {
   did_list = 0;
   CommState = ST_NONE;
   CommBusy = FALSE;
   Initializing = INIT_READY;
      }
      InvalidateRect (hWndConf, NULL, FALSE);
      break;

    case ST_LIST_RESP:
      retcode = 0;
      sscanf (CommLineIn, "%u", &retcode);
      if (retcode != 215) {
   check_server_code (retcode);
   break;
      }

      CommState = ST_LIST_GROUPLINE;
      RcvLineCount = 0;
      break;

    case ST_LIST_GROUPLINE:
      if (strcmp (CommLineIn, ".") == 0) {
   CommState = ST_NONE;
   CommBusy = FALSE;
   Initializing = INIT_READY;
   InvalidateRect (hWndConf, NULL, FALSE);

   ProcEndList ();
      }
      else {
   ProcListLine ((unsigned char *) CommLineIn);
      }
      break;

    case ST_GROUP_RESP:
      retcode = 0;
      sscanf (CommLineIn, "%u", &retcode);
      switch (retcode) {
      case 411:
   MessageBox (hWndConf, "No Such Newsgroup", "Error", MB_OK | MB_ICONHAND);
   /* abort the fledgling group window */
   DestroyWindow (CommDoc->hDocWnd);
   CommBusy = FALSE;
   CommState = ST_NONE;
   return;
   break;
      case 502:
   MessageBox (hWndConf, "Restricted Access", "WinVN", MB_OK | MB_ICONHAND);
   /* abort the fledgling group window */
   DestroyWindow (CommDoc->hDocWnd);
   CommBusy = FALSE;
   CommState = ST_NONE;
   return;
   break;
      default:
   if (check_server_code (retcode))
     return;
   break;
      }

      sscanf (CommLineIn, "%u %lu %ld %ld %s", &retcode, &estnum, &first, &last, group);

      LockLine (CommDoc->hParentBlock, CommDoc->ParentOffset,
      CommDoc->ParentLineID, &BlockPtr, &LinePtr);
      GroupDoc = ((TypGroup far *) ((char far *) LinePtr + sizeof (TypLine)));
      RangePtr = (TypRange far *) ((char far *) GroupDoc + RangeOffset (GroupDoc->NameLen));
      GroupDoc->Determined = TRUE;

      /* we don't want to grab *that* many! */
      if (estnum >= article_threshold) {
   if (!ShowUnreadOnly)
     { 
     arts_to_retrieve = (int) estnum;
     DlgStatus = DialogBox (hInst, (LPCSTR) "THRESHOLD", CommDoc->hDocWnd, (DLGPROC) lpfnWinVnThresholdDlg);
          if (DlgStatus == FALSE)
             {             
              DestroyWindow (CommDoc->hDocWnd);
         CommBusy = FALSE;
         CommState = ST_NONE;
         GroupDoc->ServerFirst = GroupDoc->ServerLast;
         GroupDoc->ServerEstNum = estnum;
              return;
              }
          }
   if ((arts_to_retrieve > 0)
       && ((last - arts_to_retrieve) > first)) {
     first = (last - arts_to_retrieve) + 1;
   }
   else if (arts_to_retrieve == -1) /* they clicked 'all of them' */
     arts_to_retrieve = (int) estnum;
   /* added by jlg */
   else if ((arts_to_retrieve == -2)   /* they clicked 'unread' */
       ||(ShowUnreadOnly)) {
     if (GroupDoc->nRanges) {
       first = RangePtr[0].Last + 1;
       arts_to_retrieve = (int) ((last - first) + 1);
       if (arts_to_retrieve < 50) {
         arts_to_retrieve = 50;
         first = last - 49;
       }
     }
     else
       arts_to_retrieve = (int) estnum;
   }
      }
      else {
   if (estnum > 0)
     arts_to_retrieve = (int) estnum;
   else {
     MessageBox (hWndConf, "Empty Newsgroup", "WinVN", MB_OK | MB_ICONHAND);
     /* abort the fledgling group window */
     DestroyWindow (CommDoc->hDocWnd);
     InvalidateRect(hWndConf, NULL, FALSE);
     CommBusy = FALSE;
     CommState = ST_NONE;
     GroupDoc->ServerFirst = GroupDoc->ServerLast;
     GroupDoc->ServerEstNum = 0;
     return;
   }
      }

      CommDoc->TotalLines = arts_to_retrieve;

      if (arts_to_retrieve > 0) {
   header_handle =
     GlobalAlloc (GMEM_MOVEABLE, (long)
             ((sizeof (TypHeader)) *
            (long) (arts_to_retrieve)) + sizeof (thread_array *));

   /* allocate space for the header_array index table */
   thread_handle =
     GlobalAlloc (GMEM_MOVEABLE,
             (long) ((sizeof (long)) * (long) (arts_to_retrieve)));

   GroupDoc->header_handle = header_handle;
   GroupDoc->thread_handle = thread_handle;

      }

      /* stick nulls and 0's, etc.. in case display code get mis-threaded */
      initialize_header_array (header_handle, thread_handle, arts_to_retrieve);

      GroupDoc = (TypGroup far *) ((char far *) LinePtr + sizeof (TypLine));
      GroupDoc->ServerEstNum = estnum;
      GroupDoc->ServerFirst = first;
      GroupDoc->ServerLast = last;

      GlobalUnlock (BlockPtr->hCurBlock);

      if (xoverp) {
   mylen = sprintf (mybuf, "XOVER %ld-%ld", first, last);
   CommState = ST_XOVER_START;
   PutCommLine (mybuf);
      }
      else {
   mylen = sprintf (mybuf, "XHDR from %ld-%ld", first, last);
   CommState = ST_XHDR_FROM_START;
   PutCommLine (mybuf);
      }

      break;

      /* The next few cases handle retrieval of XHDR information for display */
      /* in the group window.  If you change the number of XHDR's retrieved */
      /* (such as adding 'XHDR References' back into the state machine), you */
      /* need to reflect that change in the variable total_xhdrs. */

      /* the current flow is FROM -> DATE -> LINES -> SUBJECT */
      /* (threadp) FROM -> DATE -> LINES -> REF -> ID -> SUBJECT */

      /* this will now be done dynamically, depending on the state of */
      /* the 'threadp' variable */

    case ST_XOVER_START:
      retcode = 0;
      sscanf (CommLineIn, "%d", &retcode);
      if (retcode == 224) {
   CommState = ST_XOVER_DATA;
   CommDoc->ActiveLines = 0;
      }
      else {
   mylen = sprintf (mybuf, "XHDR from %ld-%ld", first, last);
   CommState = ST_XHDR_FROM_START;
   PutCommLine (mybuf);
      }
      break;

    case ST_XOVER_DATA:
      if (strcmp (CommLineIn, ".") == 0) {
   /* this is a yuck way to do this */
   CommState = ST_IN_GROUP;
   CommBusy = FALSE;
   finish_header_retrieval (CommDoc);
   InvalidateRect (CommDoc->hDocWnd, NULL, FALSE);
      }
      else {
   char *this_hop, *next_hop;
   char *reference;

   LockLine (CommDoc->hParentBlock, CommDoc->ParentOffset,
        CommDoc->ParentLineID, &BlockPtr, &LinePtr);
   GroupDoc = ((TypGroup far *) ((char far *) LinePtr + sizeof (TypLine)));
   header_handle = GroupDoc->header_handle;
   thread_handle = GroupDoc->thread_handle;

   GlobalUnlock (BlockPtr->hCurBlock);

   /* Lock the header data */
   headers = lock_headers (header_handle, thread_handle);
   header = header_elt (headers, CommDoc->ActiveLines);

   this_hop = CommLineIn;

   /* article number */
   next_hop = strchr (this_hop, '\t');
   *(next_hop++) = (char) NULL;

   header->number = atol (this_hop);

   /* subject */
   this_hop = next_hop;
   next_hop = strchr (this_hop, '\t');
   *(next_hop++) = (char) NULL;

   mylstrncpy (header->subject, this_hop, HEADER_SUBJECT_LENGTH);
   CommDoc->LongestLine = max (CommDoc->LongestLine,
                ARTICLE_SUBJECT_OFFSET +
                (unsigned) lstrlen (header->subject));
   /* author */
   this_hop = next_hop;
   next_hop = strchr (this_hop, '\t');
   *(next_hop++) = (char) NULL;

   ParseAddress (this_hop,
            AddressString, MAXDIALOGSTRING,
            NameString, MAXDIALOGSTRING);

   if (FullNameFrom)
     mylstrncpy (header->from, NameString, HEADER_FROM_LENGTH);
   else
     mylstrncpy (header->from, this_hop, HEADER_FROM_LENGTH);

   /* date */
   this_hop = next_hop;
   next_hop = strchr (this_hop, '\t');
   *(next_hop++) = (char) NULL;

   header->date = parse_usenet_date (this_hop);

   /* message-id */
   this_hop = next_hop;
   next_hop = strchr (this_hop, '\t');
   *(next_hop++) = (char) NULL;

   mylstrncpy (header->message_id, this_hop, HEADER_MESSAGE_ID_LENGTH);

   /* references */
   this_hop = next_hop;
   next_hop = strchr (this_hop, '\t');
   *(next_hop++) = (char) NULL;

   reference = get_best_reference (this_hop);
   if (reference)
     mylstrncpy (header->references, reference, HEADER_REFERENCES_LENGTH);

   /* bytes (ignored) */
   this_hop = next_hop;
   next_hop = strchr (this_hop, '\t');
   *(next_hop++) = (char) NULL;

   /* lines (last one doesn't have to have the tab */
   this_hop = next_hop;
   header->lines = atoi (this_hop);

   /* set other header fields */
   header->Selected = FALSE;
   header->ArtDoc = (TypDoc *) NULL;
   header->Seen = WasArtSeen (header->number, GroupDoc);

   unlock_headers (header_handle, thread_handle);

   CommDoc->ActiveLines++;

   update_window_title (CommDoc->hDocWnd, group,
              RcvLineCount++,
              CommDoc->TotalLines);
      }

      break;


      /* The next few cases handle retrieval of XHDR information for display */
      /* in the group window.  If you change the number of XHDR's retrieved */
      /* (such as adding 'XHDR References' back into the state machine), you */
      /* need to reflect that change in the variable total_xhdrs. */

      /* the current flow is FROM -> DATE -> LINES -> SUBJECT */
      /* (threadp) FROM -> DATE -> LINES -> REF -> ID -> SUBJECT */

      /* this will now be done dynamically, depending on the state of */
      /* the 'threadp' variable */

    case ST_XHDR_FROM_START:
      retcode = 0;
      sscanf (CommLineIn, "%d", &retcode);
      total_xhdrs = threadp ? 6 : 4;   /* we do this here to allow */
      /* mid-session change-of-mind  */
      if (retcode < 100)
   break;
      CommState = ST_XHDR_FROM_DATA;
      CommDoc->ActiveLines = 0;
      break;

    case ST_XHDR_FROM_DATA:
      if (strcmp (CommLineIn, ".") == 0) {
   LockLine (CommDoc->hParentBlock, CommDoc->ParentOffset,
        CommDoc->ParentLineID, &BlockPtr, &LinePtr);

   GroupDoc = ((TypGroup far *) ((char far *) LinePtr + sizeof (TypLine)));
   GroupDoc->total_headers = CommDoc->ActiveLines;

   first = GroupDoc->ServerFirst;
   last = GroupDoc->ServerLast;

   GlobalUnlock (BlockPtr->hCurBlock);
   CommDoc->ActiveLines = 0;

   /* Now ask for the date lines */
   mylen = sprintf (mybuf, "XHDR date %ld-%ld", first, last);
   CommState = ST_XHDR_DATE_START;
   PutCommLine (mybuf);
      }
      else {
   /*      char neat_from [80]; */
   /* Access the Group struct, get HANDLE for header data */
   LockLine (CommDoc->hParentBlock, CommDoc->ParentOffset,
        CommDoc->ParentLineID, &BlockPtr, &LinePtr);

   GroupDoc = ((TypGroup far *) ((char far *) LinePtr + sizeof (TypLine)));
   header_handle = GroupDoc->header_handle;
   thread_handle = GroupDoc->thread_handle;

   GlobalUnlock (BlockPtr->hCurBlock);

   /* Lock the header data */
   headers = lock_headers (header_handle, thread_handle);

   sscanf (CommLineIn, "%ld", &artnum);
   header = header_elt (headers, CommDoc->ActiveLines);
   header->number = artnum;

   /* now use some of our nice formatting of email addresses */
   ParseAddress (get_xhdr_line (CommLineIn),
            AddressString, MAXDIALOGSTRING,
            NameString, MAXDIALOGSTRING);

   /* copy that into headers[].from */
   if (FullNameFrom)
     mylstrncpy (header->from, NameString, HEADER_FROM_LENGTH);
   else
     mylstrncpy (header->from, AddressString, HEADER_FROM_LENGTH);

   unlock_headers (header_handle, thread_handle);

   CommDoc->ActiveLines++;

   update_window_title (CommDoc->hDocWnd, group,
              RcvLineCount++,
              CommDoc->TotalLines * total_xhdrs);
      }

      break;

    case ST_XHDR_DATE_START:
      retcode = 0;
      sscanf (CommLineIn, "%d", &retcode);
      if (check_server_code (retcode))
   break;
      CommState = ST_XHDR_DATE_DATA;
      CommDoc->ActiveLines = 0;
      break;

    case ST_XHDR_DATE_DATA:
      if (strcmp (CommLineIn, ".") == 0) {
   LockLine (CommDoc->hParentBlock, CommDoc->ParentOffset,
        CommDoc->ParentLineID, &BlockPtr, &LinePtr);

   GroupDoc = ((TypGroup far *) ((char far *) LinePtr + sizeof (TypLine)));
   GroupDoc->total_headers = CommDoc->ActiveLines;

   first = GroupDoc->ServerFirst;
   last = GroupDoc->ServerLast;

   GlobalUnlock (BlockPtr->hCurBlock);
   CommDoc->ActiveLines = 0;

   /* Now ask for the #of lines */
   mylen = sprintf (mybuf, "XHDR lines %ld-%ld", first, last);
   CommState = ST_XHDR_LINES_START;
   PutCommLine (mybuf);
      }
      else {

   /* Access the Group struct, get HANDLE for header data */
   LockLine (CommDoc->hParentBlock, CommDoc->ParentOffset,
        CommDoc->ParentLineID, &BlockPtr, &LinePtr);
   GroupDoc = ((TypGroup far *) ((char far *) LinePtr + sizeof (TypLine)));
   header_handle = GroupDoc->header_handle;
   thread_handle = GroupDoc->thread_handle;

   GlobalUnlock (BlockPtr->hCurBlock);

   /* Lock the header data */
   headers = lock_headers (header_handle, thread_handle);
   syncnum = sync_artnum (atol (CommLineIn),
             (header_elt (headers, CommDoc->ActiveLines))->number,
                headers,
                GroupDoc);
   if (syncnum >= 0)
     (header_elt (headers, syncnum))->date
       = parse_usenet_date (get_xhdr_line (CommLineIn));

   unlock_headers (header_handle, thread_handle);

   CommDoc->ActiveLines++;
   update_window_title (CommDoc->hDocWnd, group,
              RcvLineCount++,
              CommDoc->TotalLines * total_xhdrs);
      }

      break;

    case ST_XHDR_LINES_START:
      retcode = 0;
      sscanf (CommLineIn, "%d", &retcode);
      if (check_server_code (retcode))
   break;
      CommState = ST_XHDR_LINES_DATA;
      CommDoc->ActiveLines = 0;
      break;

    case ST_XHDR_LINES_DATA:
      if (strcmp (CommLineIn, ".") == 0) {
   LockLine (CommDoc->hParentBlock, CommDoc->ParentOffset,
        CommDoc->ParentLineID, &BlockPtr, &LinePtr);

   GroupDoc = ((TypGroup far *) ((char far *) LinePtr + sizeof (TypLine)));
   GroupDoc->total_headers = CommDoc->ActiveLines;

   first = GroupDoc->ServerFirst;
   last = GroupDoc->ServerLast;

   GlobalUnlock (BlockPtr->hCurBlock);
   CommDoc->ActiveLines = 0;

   /* Check for threading option, if enabled, go to REF & ID */
   /* states first */

   if (threadp) {
     CommState = ST_XHDR_REF_START;
     mylen = sprintf (mybuf, "XHDR references %ld-%ld", first, last);
     PutCommLine (mybuf);
   }
   else {
     CommState = ST_XHDR_SUBJECT_START;
     mylen = sprintf (mybuf, "XHDR subject %ld-%ld", first, last);
     PutCommLine (mybuf);
   }
      }

      else {

   /* Access the Group struct, get HANDLE for header data */
   LockLine (CommDoc->hParentBlock, CommDoc->ParentOffset,
        CommDoc->ParentLineID, &BlockPtr, &LinePtr);
   GroupDoc = ((TypGroup far *) ((char far *) LinePtr + sizeof (TypLine)));

   header_handle = GroupDoc->header_handle;
   thread_handle = GroupDoc->thread_handle;

   GlobalUnlock (BlockPtr->hCurBlock);

   /* Lock the header data */
   headers = lock_headers (header_handle, thread_handle);

   syncnum = sync_artnum (atol (CommLineIn),
             (header_elt (headers, CommDoc->ActiveLines))->number,
                headers,
                GroupDoc);
   if (syncnum >= 0)
     sscanf (CommLineIn, "%ld %Fd", &artnum, &((header_elt (headers, syncnum))->lines));

   unlock_headers (header_handle, thread_handle);
   CommDoc->ActiveLines++;
   update_window_title (CommDoc->hDocWnd, group,
              RcvLineCount++,
              CommDoc->TotalLines * total_xhdrs);
      }

      break;

    case ST_XHDR_REF_START:
      retcode = 0;
      sscanf (CommLineIn, "%d", &retcode);
      if (check_server_code (retcode))
   break;
      CommState = ST_XHDR_REF_DATA;
      CommDoc->ActiveLines = 0;
      break;

    case ST_XHDR_REF_DATA:
      if (strcmp (CommLineIn, ".") == 0) {
   LockLine (CommDoc->hParentBlock, CommDoc->ParentOffset,
        CommDoc->ParentLineID, &BlockPtr, &LinePtr);

   GroupDoc = (TypGroup far *) ((char far *) LinePtr + sizeof (TypLine));
   GroupDoc->total_headers = CommDoc->ActiveLines;

   first = GroupDoc->ServerFirst;
   last = GroupDoc->ServerLast;

   GlobalUnlock (BlockPtr->hCurBlock);
   CommDoc->ActiveLines = 0;

   /* Now ask for the message-id lines */
   mylen = sprintf (mybuf, "XHDR message-id %ld-%ld", first, last);
   CommState = ST_XHDR_MID_START;
   PutCommLine (mybuf);
      }
      else {
   char far *refer;  /* , far * end,far * bracket1,far *bracket2; */
   /*      int bracket_len; */

   /* Access the Group struct, get HANDLE for header data */
   LockLine (CommDoc->hParentBlock, CommDoc->ParentOffset,
        CommDoc->ParentLineID, &BlockPtr, &LinePtr);
   GroupDoc = ((TypGroup far *) ((char far *) LinePtr + sizeof (TypLine)));

   header_handle = GroupDoc->header_handle;
   thread_handle = GroupDoc->thread_handle;

   GlobalUnlock (BlockPtr->hCurBlock);

   /* Lock the header data */
   headers = lock_headers (header_handle, thread_handle);

   /* for now, we only pay attention to first (whole) referral */
   refer = get_xhdr_line (CommLineIn);

   refer = get_best_reference (refer);

   if (refer) {
     /* Patch to check for bad info from server JD 6/19/93 */
     syncnum = sync_artnum (atol (CommLineIn),
             (header_elt (headers,
                     CommDoc->ActiveLines))->number,
             headers, GroupDoc);
     if (syncnum >= 0)
       mylstrncpy ((header_elt (headers, syncnum))->references,
         refer, HEADER_REFERENCES_LENGTH);
   }

   unlock_headers (header_handle, thread_handle);

   CommDoc->ActiveLines++;
   update_window_title (CommDoc->hDocWnd, group,
              RcvLineCount++,
              CommDoc->TotalLines * total_xhdrs);

      }

      break;


    case ST_XHDR_MID_START:
      retcode = 0;
      sscanf (CommLineIn, "%d", &retcode);
      if (check_server_code (retcode))
   break;
      CommState = ST_XHDR_MID_DATA;
      CommDoc->ActiveLines = 0;
      break;

    case ST_XHDR_MID_DATA:
      if (strcmp (CommLineIn, ".") == 0) {
   LockLine (CommDoc->hParentBlock, CommDoc->ParentOffset,
        CommDoc->ParentLineID, &BlockPtr, &LinePtr);

   GroupDoc = (TypGroup far *) ((char far *) LinePtr + sizeof (TypLine));

   GroupDoc->total_headers = CommDoc->ActiveLines;

   first = GroupDoc->ServerFirst;
   last = GroupDoc->ServerLast;

   GlobalUnlock (BlockPtr->hCurBlock);
   CommDoc->ActiveLines = 0;

   /* Now ask for the subject lines */
   mylen = sprintf (mybuf, "XHDR subject %ld-%ld", first, last);
   CommState = ST_XHDR_SUBJECT_START;
   PutCommLine (mybuf);
      }
      else {
   /* Access the Group struct, get HANDLE for header data */
   LockLine (CommDoc->hParentBlock, CommDoc->ParentOffset,
        CommDoc->ParentLineID, &BlockPtr, &LinePtr);

   GroupDoc = (TypGroup far *) ((char far *) LinePtr + sizeof (TypLine));

   header_handle = GroupDoc->header_handle;
   thread_handle = GroupDoc->thread_handle;

   GlobalUnlock (BlockPtr->hCurBlock);

   /* Lock the header data */
   headers = lock_headers (header_handle, thread_handle);

   syncnum = sync_artnum (atol (CommLineIn),
             (header_elt (headers, CommDoc->ActiveLines))->number,
                headers,
                GroupDoc);
   if (syncnum >= 0)
     mylstrncpy ((header_elt (headers, syncnum))->message_id,
            (char far *) (get_xhdr_line (CommLineIn)),
            HEADER_MESSAGE_ID_LENGTH); /* bad, hardcoded. */

   unlock_headers (header_handle, thread_handle);

   CommDoc->ActiveLines++;
   update_window_title (CommDoc->hDocWnd, group,
              RcvLineCount++,
              CommDoc->TotalLines * total_xhdrs);

      }

      break;


    case ST_XHDR_SUBJECT_START:
      retcode = 0;
      sscanf (CommLineIn, "%d", &retcode);
      if (check_server_code (retcode))
   break;
      CommState = ST_XHDR_SUBJECT_DATA;
      break;

    case ST_XHDR_SUBJECT_DATA:

      if (strcmp (CommLineIn, ".") == 0) {
   CommState = ST_IN_GROUP;
   CommBusy = FALSE;
   finish_header_retrieval (CommDoc);
   InvalidateRect (CommDoc->hDocWnd, NULL, FALSE);
      }
      else {

   artnum = 0;
   sscanf (CommLineIn, "%ld", &artnum);
   if (artnum) {
     LockLine (CommDoc->hParentBlock, CommDoc->ParentOffset,
          CommDoc->ParentLineID, &BlockPtr, &LinePtr);

     GroupDoc = ((TypGroup far *) ((char far *) LinePtr + sizeof (TypLine)));
     header_handle = GroupDoc->header_handle;
     thread_handle = GroupDoc->thread_handle;
     headers = lock_headers (header_handle, thread_handle);

     /* update the seen thing. */
     syncnum = sync_artnum (atol (CommLineIn),
             (header_elt (headers, CommDoc->ActiveLines))->number,
             headers,
             GroupDoc);
     if (syncnum >= 0)
       header = header_elt (headers, syncnum);
     else
       header = header_elt (headers, CommDoc->ActiveLines);

     header->Selected = FALSE;
     header->ArtDoc = (TypDoc *) NULL;
     header->Seen =
       WasArtSeen (artnum, (TypGroup far *) (((char far *) LinePtr) +
                    sizeof (TypLine)));

     UnlockLine (BlockPtr, LinePtr, &(CommDoc->hParentBlock),
            &(CommDoc->ParentOffset), &(CommDoc->ParentLineID));

     mylstrncpy (header->subject,
            get_xhdr_line (CommLineIn), HEADER_SUBJECT_LENGTH);

     CommDoc->LongestLine = max (CommDoc->LongestLine,
                  ARTICLE_SUBJECT_OFFSET +
                  (unsigned) lstrlen (header->subject));

     unlock_headers (header_handle, thread_handle);
     CommDoc->ActiveLines++;
     update_window_title (CommDoc->hDocWnd, group,
                RcvLineCount++,
                CommDoc->TotalLines * total_xhdrs);

   }
      }

      break;

    case ST_IN_GROUP:
      break;

    case ST_ARTICLE_RESP:
      retcode = 0;
      sscanf (CommLineIn, "%d", &retcode);
      if (check_server_code (retcode)) {
   if (CommDoc->hDocWnd)
     DestroyWindow (CommDoc->hDocWnd);
   break;
      }
      CommState = ST_REC_ARTICLE_HEADER;
      /*      Bossanova = FALSE; */
      break;

    case ST_REC_ARTICLE_HEADER:
      if (strcmp (CommLineIn, ".") == 0) {
   ;        /* error: empty article (end in middle of header) */

      }
      if (IsBlankStr (CommLineIn))  /* headers end in blank line */
   CommState = ST_REC_ARTICLE;
      AddCommLineToDoc (CommLineIn);
      break;

    case ST_REC_ARTICLE:
      if (strcmp (CommLineIn, ".") == 0) {   /* article receive complete */

   CommState = ST_IN_GROUP;
   CommBusy = FALSE;

   if (CommDecoding) {
     SendMessage (currentCoded->hParentWnd, IDM_ARTICLE_RETRIEVE_COMPLETE, 0, 0);
     break;
   }
   else
   {
          SendMessage (CommDoc->ParentDoc->hDocWnd, IDM_ARTICLE_RETRIEVE_COMPLETE, 0, 0);
          SendMessage(CommDoc->hDocWnd, IDM_ARTICLE_RETRIEVE_COMPLETE, 0, 0);
        }

   LockLine (CommDoc->ParentDoc->hParentBlock,
        CommDoc->ParentDoc->ParentOffset,
        CommDoc->ParentDoc->ParentLineID,
        &BlockPtr, &LinePtr);

   GroupDoc = (TypGroup far *) ((char far *) LinePtr + sizeof (TypLine));
   header_handle = GroupDoc->header_handle;
   thread_handle = GroupDoc->thread_handle;

   headers = lock_headers (header_handle, thread_handle);
   lpsz = (char far *) ((header_elt (headers, CommDoc->LastSeenLineID))->subject);
   unlock_headers (header_handle, thread_handle);

   mylstrncpy (group, lpsz, MAXGROUPNAME);
   sprintf (mybuf, "%s (%u lines)", group, CommDoc->TotalLines);
   SetWindowText (CommDoc->hDocWnd, mybuf);
   InvalidateRect (CommDoc->hDocWnd, NULL, FALSE);
   GlobalUnlock (BlockPtr->hCurBlock);

   /* Skip to the first line of the text of the article
    * and make sure it's visible on the screen.  This is
    * so that the user doesn't have to have the first
    * screen filled with a lengthy, worthless header.
    *
    * and save number of header lines (on display)
    * for later (Bretherton)
    */
   TopOfDoc (CommDoc, &BlockPtr, &LinePtr);
   found = FALSE;
   do {
     lpsz = ((char far *) LinePtr + sizeof (TypLine) + sizeof (TypText));
     if (IsLineBlank (lpsz)) {
       found = TRUE;
       CommDoc->HeaderLines = WhatLine (BlockPtr, LinePtr);
       break;
     }
     if (!NextLine (&BlockPtr, &LinePtr))
       break;
   }
   while (!found);
   NextLine (&BlockPtr, &LinePtr);

   /* If the line is in the last screen's worth of lines, back
    * up the pointer so it points to the first line of the last
    * screen.
    */
   if (found && CommDoc->TotalLines > CommDoc->ScYLines &&
       !CommDoc->TopScLineID)
     AdjustTopSc (BlockPtr, LinePtr);

   UnlockLine (BlockPtr, LinePtr, &hBlock, &Offset, &MyLineID);
      }
      else        /* not finished, continue article receive */
   AddCommLineToDoc (CommLineIn);

      break;

    case ST_POST_WAIT_PERMISSION:

      /*      WndPost = getWndEdit(WndPosts,CommWnd,MAXPOSTWNDS) ; */
      /*      found = (WndPost != NULL) ; */

      /* lock out changes */
      SendMessage (PostEdit->hWndEdit, EM_SETREADONLY, TRUE, 0L);

      retcode = 0;
      sscanf (CommLineIn, "%u", &retcode);

      if (retcode == 340) {
   if (Attaching && !ReviewAttach)
     ProcessAttach (CONTINUE);
   else
     PostText (PostEdit);
      }
      else {
   check_server_code (retcode);
   MessageBox (PostEdit->hWnd, CommLineIn + 4, "Cannot Post Article",
          MB_OK | MB_ICONEXCLAMATION);
   CommBusy = FALSE;
   CommState = ST_NONE;

   if (Attaching && !ReviewAttach)
     ProcessAttach (ABORT);   /* cancel attachment */

   else
     /* unlock to allow user modification */
     SendMessage (PostEdit->hWndEdit, EM_SETREADONLY, FALSE, 0L);
      }
      break;

    case ST_POST_WAIT_END:

      /*      WndPost = getWndEdit(WndPosts,CommWnd,MAXPOSTWNDS) ; */
      /*      found = (WndPost != NULL) ; */

      /* no check for failure to find posting documents */
      retcode = 0;
      sscanf (CommLineIn, "%d", &retcode);
      if (retcode == 441 || retcode == 440) {
   CompletePost(PostEdit, FAIL);
   done = TRUE;
   nextBatchIndex = 0;  /* cancel any batch */

   if (Attaching && !ReviewAttach)
     ProcessAttach (ABORT);/* cancel attachment */

      }
      else if (retcode == 240) {
   CompletePost(PostEdit, SUCCESS);
   done = TRUE;
      }
      else if (check_server_code (retcode))
   break;

      if (done) {
   CommBusy = FALSE;
   CommState = ST_NONE;
   PostEdit = (WndEdit *) NULL;

   if (nextBatchIndex)  /* if we're sending a batch, send the next */
     BatchSend (DOCTYPE_POSTING);
      }
      if (Attaching && !ReviewAttach)
   ProcessAttach (CONTINUE);
      break;

      /* the following code is for an MRR-hacked nntp server */

    case ST_GROUP_REJOIN:
      CommState = ST_ARTICLE_RESP;
      break;
    }
  }
}

BOOL
isLineQuotation (char *textptr)
{
  char *loc;
  loc = memchr (textptr, QuoteLineInd, 2);
  if (!loc)
    loc = memchr (textptr, '|', 2);
  if (!loc)
    loc = memchr (textptr, ':', 2);
  return (loc != NULL);
}


/*-- function AddCommLineToDoc ---------------------------------------
 *
 *  Adds the given line to the comm doc
 */
void
AddCommLineToDoc (char *line)
{
  TypLine far *LinePtr;
  TypBlock far *BlockPtr;
  char *cptr, *cdest;
  int col, mylen;
  char artline[MAXINTERNALLINE];

  /* special case for lines starting with '..' */
  if (strncmp (CommLineIn, "..", 2))
    cptr = CommLineIn;
  else
    cptr = CommLineIn + 1;

  if (CommDecoding) {
    DecodeLine (currentCoded, cptr);
    return;
  }
  /* Copy this line into an image of a textblock line,
   * expanding tabs.
   */
  cdest = artline + sizeof (TypLine) + sizeof (TypText);
  for (col = 0;
  *cptr && col < (MAXINTERNALLINE - 3 * sizeof (TypLine) - sizeof (TypText));
       cptr++) {
    if (*cptr == '\t') {
      do {
   *(cdest++) = ' ';
      }
      while (++col & 7);
    }
    else {
      *(cdest++) = *cptr;
      col++;
    }
  }
  *(cdest++) = '\0';

  ((TypLine *) artline)->LineID = NextLineID++;
  LockLine (CommDoc->hCurAddBlock, CommDoc->AddOffset, CommDoc->AddLineID, &BlockPtr, &LinePtr);
  mylen = (cdest - artline) + sizeof (int);
  mylen += mylen % 2;
  ((TypText *) (artline + sizeof (TypLine)))->NameLen =
    (cdest - 1) - (artline + sizeof (TypLine) + sizeof (TypText));
  ((TypLine *) artline)->length = mylen;
  ((TypLine *) artline)->active = TRUE;
  *((int *) (artline + mylen - sizeof (int))) = mylen;
  AddLine ((TypLine *) artline, &BlockPtr, &LinePtr);
  CommDoc->LongestLine = max (CommDoc->LongestLine, (unsigned) mylen);
  CommDoc->ActiveLines++;
  UnlockLine (BlockPtr, LinePtr, &(CommDoc->hCurAddBlock),
         &(CommDoc->AddOffset), &(CommDoc->AddLineID));

  if ((CommDoc->TotalLines % UPDATE_ART_FREQ) == 0)
    InvalidateRect (CommDoc->hDocWnd, NULL, FALSE);
}

/*-- function WasArtSeen ---------------------------------------------
 *
 *  Determines whether (according to the information in a TypGroup entry)
 *  a given article number was seen.
 *
 *  Returns TRUE iff the article has been seen.
 */
BOOL
WasArtSeen (ArtNum, GroupPtr)
     unsigned long ArtNum;
     TypGroup far *GroupPtr;
{
  TypRange far *RangePtr = (TypRange far *) ((char far *)
            GroupPtr + RangeOffset (GroupPtr->NameLen));
  unsigned int nr;

  for (nr = 0; nr < GroupPtr->nRanges; nr++) {
    if (ArtNum >= (unsigned long) RangePtr->First &&
   ArtNum <= (unsigned long) RangePtr->Last) {
      return (TRUE);
    }
    else {
      RangePtr++;
    }
  }
  return (FALSE);
}


/*--- function mylstrncmp -----------------------------------------------
 *
 *   Just like strncmp, except takes long pointers.
 */
int
mylstrncmp (ptr1, ptr2, len)
     char far *ptr1;
     char far *ptr2;
     int len;
{
  for (; len--; ptr1++, ptr2++) {
    if (*ptr1 > *ptr2) {
      return (1);
    }
    else if (*ptr1 < *ptr2) {
      return (-1);
    }
  }
  return (0);
}

/*--- function mylstrncpy -----------------------------------------------
 *
 *   Just like strncpy, except takes long pointers.
 */
char far *
mylstrncpy (ptr1, ptr2, len)
     char far *ptr1;
     char far *ptr2;
     int len;
{
  char far *targ = ptr1;

  for (; --len && *ptr2; ptr1++, ptr2++) {
    *ptr1 = *ptr2;
  }
  *ptr1 = '\0';
  return (targ);
}

/* this is a temporary test... */
char far *
mylstrcpy (ptr1, ptr2)
     char_p ptr1;
     char far *ptr2;
{
  char far *targ = ptr1;
  for (; *ptr2; ptr1++, ptr2++) {
    *ptr1 = *ptr2;
  }
  *ptr1 = '\0';
  return (targ);
}

#if 0
/*--- function lstrcmpnoblank ------------------------------------------
 *
 *   Like strcmp, except takes long pointers and also stops at
 *   the first blank.
 */
int
lstrcmpnoblank (str1, str2)
     char far **str1;
     char far **str2;
{
  register char far *s1 = *str1, far * s2 = *str2;

  for (; *s1 && *s2 && *s1 != ' ' && *s2 != ' '; s1++, s2++) {
    if (*s1 > *s2) {
      return (1);
    }
    else if (*s1 < *s2) {
      return (-1);
    }
  }
  if (*s1 == *s2) {
    return (0);
  }
  else if (*s1) {
    return (1);
  }
  else {
    return (-1);
  }
}
#endif

void
finish_header_retrieval ()
{
  TypLine far *LinePtr;
  TypBlock far *BlockPtr;
  TypGroup far *GroupDoc;
  HANDLE header_handle, thread_handle;
/*  HANDLE hBlock; */
  char far *lpsz;
  char group[MAXGROUPNAME];
  char mybuf[MAXINTERNALLINE];
  header_p headers;

  /* release the mouse that is captured to the usenet window */
  ReleaseCapture ();

  CommDoc->TotalLines = CommDoc->ActiveLines;
  /* Disabled by MRR so that ActiveLines is the number of lines
   * we should display in the Group window.  Eventually, will
   * change it so that ActiveLines will count only unread articles
   * if the user desires.
   */
  /* CommDoc->ActiveLines = 0; */
  /* Fetch this group's line in NetDoc so we can get the
   * group's name for the window's title bar.
   */
  LockLine (CommDoc->hParentBlock, CommDoc->ParentOffset,
       CommDoc->ParentLineID, &BlockPtr, &LinePtr);

  GroupDoc = ((TypGroup far *) ((char far *) LinePtr + sizeof (TypLine)));
  header_handle = GroupDoc->header_handle;
  thread_handle = GroupDoc->thread_handle;
  lock_headers (header_handle, thread_handle);

  if (threadp) {
    SetWindowText (CommDoc->hDocWnd, "sorting headers...");
    sort_by_threads (header_handle, thread_handle, CommDoc->TotalLines);
  }

  unlock_headers (header_handle, thread_handle);

  GroupDoc->total_headers = CommDoc->TotalLines;

  lpsz = (char far *) (((char far *) LinePtr) +
             sizeof (TypLine) + sizeof (TypGroup));

  mylstrncpy (group, lpsz, MAXGROUPNAME);
  sprintf (mybuf, "%s (%u articles)", group, CommDoc->TotalLines);
  SetWindowText (CommDoc->hDocWnd, mybuf);

  /* If we have information from NEWSRC on the highest-
   * numbered article previously seen, position the window
   * so the new articles can be seen without scrolling.
   */
  {
    unsigned int i;

    LockLine (CommDoc->hParentBlock, CommDoc->ParentOffset,
         CommDoc->ParentLineID, &BlockPtr, &LinePtr);

    /* inside the lock, can access the GroupStruct */
    GroupDoc = ((TypGroup far *) ((char far *) LinePtr + sizeof (TypLine)));
    header_handle = GroupDoc->header_handle;
    thread_handle = GroupDoc->thread_handle;
    headers = lock_headers (header_handle, thread_handle);

    if (CommDoc->TotalLines > 0)
      for (i = CommDoc->TotalLines - 1;
      ((i > 0) && ((header_elt (headers, i))->Seen == FALSE));
      i--);
    CommDoc->TopLineOrd = (i > 5) ? i - 4 : 0;

    unlock_headers (header_handle, thread_handle);
  }

  SendMessage (CommDoc->hDocWnd, IDM_RETRIEVE_COMPLETE, 0, 0);
  InvalidateRect (CommDoc->hDocWnd, NULL, FALSE);
}

/*
 * Look through the MAIL or Post edits and return the edit with
 * matching window handle Consider - centralising initial window
 * location in wvmail and wndpost using a single array (save passing
 * structure and size into this module)
 *
 */

WndEdit *
getWndEdit (WndEdit * WndEdits, HWND hWnd, int numEntries)
{
  int ih;

  for (ih = 0; ih < numEntries; ih++) {
    if (WndEdits[ih].hWnd == hWnd) {
      return &WndEdits[ih];
    }
  }

  /*MessageBox(0,"getWndEditFound Nothing","mrb debug", MB_OK | MB_ICONHAND); */

  return (WndEdit *) NULL;
}



/* ------------------------------------------------------------------------
 * Replace any white space at end of string with NULL's
 * JSC 11/1/93
 */
void
RemoveTrailingWhiteSpace (char *str)
{
  register int i;

  for (i = strlen (str) - 1; i > 0 && isspace (str[i]); i--)
    str[i] = '\0';
}

/*------------------------------------------------------------------------------
 * IsBlankStr
 * Returns true if the string is entirely whitespace, else false
 * JSC 12/6/93
 */
BOOL
IsBlankStr (char *temp)
{
  register char *ptr;

  for (ptr = temp; *ptr; ptr++)
    if (!isspace (*ptr))
      return (FALSE);
  return (TRUE);
}

/*------------------------------------------------------------------------------
 * isnumber
 * Returns true if the string is a all digits
 * JSC 12/6/93
 */
BOOL
isnumber (char *str)
{
  char *ptr;

  for (ptr = str; *ptr != '\0'; ptr++)
    if (!isdigit (*ptr))
      return (FALSE);
  return (TRUE);
}

/* ------------------------------------------------------------------------
 *    Open the common font dialog
 *      Place resulting selection name and size in face,style and size
 *      Note: to select a printer font, send style as "Printer"
 *      printer font selection ignores any chosen style
 *      (JSC 1/9/94)
 */
BOOL
AskForFont (HWND hParentWnd, char *face, int *size, char *style)
{
  LOGFONT lf;
  CHOOSEFONT cf;
  HDC hDC;

  memset (&lf, 0, sizeof (LOGFONT));
  strcpy (lf.lfFaceName, face);
  /* convert points to logical units (1 pt = 1/72 inch) */
  /* For printer fonts, use ScreenYPixels here anyway - the choosefont */
  /* dialog appears to require the lfHeight to be in screen units */
  /* we will convert point size to PrinterUnits in InitPrinterFonts() */
  lf.lfHeight = -MulDiv (*size, ScreenYPixels, 72);

  memset (&cf, 0, sizeof (CHOOSEFONT));
  cf.lStructSize = sizeof (CHOOSEFONT);
  cf.hwndOwner = hParentWnd;
  cf.lpLogFont = &lf;
  if (!stricmp (style, "Printer")) {
    cf.nFontType = PRINTER_FONTTYPE;
    hDC = GetPrinterDC (hParentWnd);
    cf.hDC = hDC;
    cf.Flags = CF_PRINTERFONTS | CF_INITTOLOGFONTSTRUCT | CF_FORCEFONTEXIST;
  }
  else {
    cf.nFontType = SCREEN_FONTTYPE;
    cf.Flags = CF_SCREENFONTS | CF_INITTOLOGFONTSTRUCT | CF_USESTYLE | CF_FORCEFONTEXIST;
    cf.lpszStyle = style;
  }
  if (!ChooseFont (&cf))
    return (FAIL);

/*      if (!stricmp (style, "Printer"))      // commented out JD 6/17/94 */
  /*         ReleaseDC (hWndConf, hDC);  */

/*      if (!stricmp (style, "Printer")) */
  /*         DeletePrinterDC (hDC); */

  *size = cf.iPointSize / 10; /* iPointSize is in tenths of a point */

  strcpy (face, lf.lfFaceName);
  return (SUCCESS);
}

/* ------------------------------------------------------------------------
 *    Open the common color dialog
 *      (JSC 1/9/94)
 */
BOOL
AskForColor (HWND hParentWnd, COLORREF * color)
{
  CHOOSECOLOR cc;
  COLORREF nearC;
  HDC hDC;

  memset (&cc, 0, sizeof (CHOOSECOLOR));
  cc.lStructSize = sizeof (CHOOSECOLOR);
  cc.hwndOwner = hParentWnd;
  cc.rgbResult = *color;
  cc.lpCustColors = CustomColors;
  cc.Flags = CC_RGBINIT;

  if (!ChooseColor (&cc))
    return (FAIL);

  /* until we figure out how to deal with dithered colors, force */
  /* the color to the nearest physical color */
  hDC = GetDC (hParentWnd);
  nearC = GetNearestColor (hDC, cc.rgbResult);
  if (cc.rgbResult != nearC)
    MessageBox (hParentWnd, "WinVn does not currently support dithered (non-solid) colors.\nThe nearest physical solid color has been selected.",
      "Sorry", MB_OK | MB_ICONINFORMATION);
  *color = nearC;
  ReleaseDC (hParentWnd, hDC);
  return (SUCCESS);
}

/* ------------------------------------------------------------------------
 * This should be used instead of EM_GETHANDLE on global edit buf
 * Returns a string containing the contents of an edit wnd
 * It is the reponsibility of the caller to GlobalFreePtr the string
 * (JSC)
 */
char *
GetEditText (HWND hWndEdit)
{
  unsigned int size;
  char *newText;

  /* SendMessage (hWndEdit, EM_FMTLINES, TRUE, 0); */

  size = (unsigned int) SendMessage (hWndEdit, WM_GETTEXTLENGTH, 0, 0L) + 1;

  if ((newText = (char *) GlobalAllocPtr (GMEM_MOVEABLE, size * sizeof (char))) == NULL) {
    MessageBox (hWndEdit, "Memory allocation failure", "Edit Text", MB_OK);
    return (NULL);
  }
  if (SendMessage (hWndEdit, WM_GETTEXT, size, (LPARAM) ((LPCSTR) newText)) != (long) (size - 1)) {
    MessageBox (hWndEdit, "Failed to get text", "Edit Text", MB_OK);
    return (NULL);
  }

  return (newText);
}
LRESULT
SetEditText (HWND hWndEdit, char *editMem)
{
  return (SendMessage (hWndEdit, WM_SETTEXT, 0, (LPARAM) (LPCSTR) editMem));
}

/* ------------------------------------------------------------------------
 * To maximize amount of data allowable in posting, allocate a new
 * data segment for this posting from the Global heap, and set the
 * window hInstance to this segment
 * Don't forget you can't use EM_GET/SETHANDLE on an edit buf with
 * a global mem segment
 */
BOOL
CreateEditWnd (WndEdit * NewWnd)
{
#ifndef _WIN32
  GLOBALHANDLE editDS;
  LPVOID lpPtr;
  if ((editDS = GlobalAlloc (GMEM_DDESHARE | GMEM_MOVEABLE | GMEM_ZEROINIT, 1024L)) == NULL) {
    MessageBox (NewWnd->hWnd, "Memory allocation failure", "Edit Buffer", MB_OK);
    editDS = hInst;     /* use local heap instead */

  }
  else {
    lpPtr = GlobalLock (editDS);
    LocalInit (HIWORD ((LONG) lpPtr), 0, (WORD) (GlobalSize (editDS) - 16));
    UnlockSegment (HIWORD ((LONG) lpPtr));   /* we still have a global lock */

  }
  NewWnd->hWndEdit = CreateWindow ((LPCSTR) "edit", (LPCSTR) NULL,
          WS_CHILD | WS_VISIBLE | WS_HSCROLL | WS_VSCROLL | WS_BORDER |
         ES_LEFT | ES_MULTILINE | ES_AUTOHSCROLL | ES_AUTOVSCROLL,
               0, 0, 0, 0,
          NewWnd->hWnd, (HMENU) EDITID, (HINSTANCE) HIWORD ((LONG) lpPtr), NULL);
#else
  NewWnd->hWndEdit = CreateWindow ("edit", (char *) NULL,
          WS_CHILD | WS_VISIBLE | WS_HSCROLL | WS_VSCROLL | WS_BORDER |
         ES_LEFT | ES_MULTILINE | ES_AUTOHSCROLL | ES_AUTOVSCROLL,
               0, 0, 0, 0,
               NewWnd->hWnd, (HMENU) EDITID, hInst, NULL);  /* No problems with Win32 */
#endif
  if (!NewWnd->hWndEdit) {
    MessageBox (NewWnd->hWnd, "Window creation failure", "Edit Buffer", MB_OK);
    return (FAIL);
  }

  SendMessage (NewWnd->hWndEdit, EM_LIMITTEXT, 0, 0L);
  SetHandleBkBrush (NewWnd->hWndEdit, hArticleBackgroundBrush);
  NewWnd->dirty = DT_CLEAN;

  return (SUCCESS);
}
/* ------------------------------------------------------------------------
 *    Write an integer to the private profile
 */
BOOL
WritePrivateProfileInt (lpAppName, lpKeyName, intval, lpProFile)
     char far *lpAppName;
     char far *lpKeyName;
     char far *lpProFile;
     int intval;
{
  char msg[20];

  itoa (intval, msg, 10);
  return (WritePrivateProfileString (lpAppName, lpKeyName, msg, lpProFile));
}

/* ------------------------------------------------------------------------
 *    Write an unsigned integer to the private profile
 *      (JSC 1/8/94)
 */
BOOL
WritePrivateProfileUInt (lpAppName, lpKeyName, intval, lpProFile)
     char far *lpAppName;
     char far *lpKeyName;
     char far *lpProFile;
     unsigned int intval;
{
  char msg[20];

  uitoa (intval, msg, 10);
  return (WritePrivateProfileString (lpAppName, lpKeyName, msg, lpProFile));
}

/* ------------------------------------------------------------------------
 *    Get an unsigned integer to the private profile
 *      (JSC 1/8/94)
 */
unsigned int
GetPrivateProfileUInt (lpAppName, lpKeyName, intval, lpProFile)
     char far *lpAppName;
     char far *lpKeyName;
     char far *lpProFile;
     unsigned int intval;
{
  char buf[20];

  GetPrivateProfileString (lpAppName, lpKeyName, "", buf, 20, lpProFile);

  if (buf[0] == '\0')
    return (intval);
  else
    return (atoui (buf));
}
/* ------------------------------------------------------------------------
 *    Refresh Window functions
 *      Called after a font/color selection has changed to affect all
 *      windows of a certain type (group/article/status)
 *      (JSC 1/9/94)
 */
void
RefreshGroupWnds ()
{
  register int i;
  for (i = 0; i < MAXGROUPWNDS; i++)
    if (GroupDocs[i].InUse && GroupDocs[i].hDocWnd) {
      SetHandleBkBrush (GroupDocs[i].hDocWnd, hListBackgroundBrush);
      SendMessage (GroupDocs[i].hDocWnd, WM_SIZE, 0, 0L);
      InvalidateRect (GroupDocs[i].hDocWnd, NULL, TRUE);
    }
}

void
RefreshArticleWnds ()
{
  register int i;

  for (i = 0; i < MAXARTICLEWNDS; i++)
    if (ArticleDocs[i].InUse && ArticleDocs[i].hDocWnd) {
      SetHandleBkBrush (ArticleDocs[i].hDocWnd, hArticleBackgroundBrush);
      SendMessage (ArticleDocs[i].hDocWnd, WM_SIZE, 0, 0L);
      InvalidateRect (ArticleDocs[i].hDocWnd, NULL, TRUE);
    }

  for (i = 0; i < MAXPOSTWNDS; i++)
    if (WndPosts[i].hWnd) {
      SendMessage (WndPosts[i].hWndEdit, WM_SETFONT, (WPARAM) hFontArtNormal, TRUE);
      SetHandleBkBrush (WndPosts[i].hWndEdit, hArticleBackgroundBrush);
      InvalidateRect (WndPosts[i].hWndEdit, NULL, TRUE);
    }

  for (i = 0; i < MAXMAILWNDS; i++)
    if (WndMails[i].hWnd) {
      SendMessage (WndMails[i].hWndEdit, WM_SETFONT, (WPARAM) hFontArtNormal, TRUE);
      SetHandleBkBrush (WndMails[i].hWndEdit, hArticleBackgroundBrush);
      InvalidateRect (WndMails[i].hWndEdit, NULL, TRUE);
    }

}
void
RefreshStatusWnds ()
{
  register int i;

  for (i = 0; i < NumStatusTexts; i++)
    if (CodingStatusText[i]->hTextWnd) {
      SetHandleBkBrush (CodingStatusText[i]->hTextWnd, hStatusBackgroundBrush);
      SendMessage (CodingStatusText[i]->hTextWnd, WM_SIZE, 0, 0L);
      InvalidateRect (CodingStatusText[i]->hTextWnd, NULL, TRUE);
    }
  if (hCodedBlockWnd) {
    SetHandleBkBrush (hCodedBlockWnd, hStatusBackgroundBrush);
    SendMessage (hCodedBlockWnd, WM_SIZE, 0, 0L);
    InvalidateRect (hCodedBlockWnd, NULL, TRUE);
  }

}
/* ------------------------------------------------------------------------
 *    Close Window functions
 *      Batch operation, close all windows of a certain type
 *      (group/article/status)
 *      (JSC 1/18/94)
 */
void
CloseGroupWnds ()
{
  register int i;
  for (i = 0; i < MAXGROUPWNDS; i++)
    if (GroupDocs[i].InUse && GroupDocs[i].hDocWnd && (!CommBusy || &GroupDocs[i] != CommDoc))
      SendMessage (GroupDocs[i].hDocWnd, WM_CLOSE, 0, 0L);
}

void
CloseArticleWnds ()
{
  register int i;

  for (i = 0; i < MAXARTICLEWNDS; i++)
    if (ArticleDocs[i].InUse && ArticleDocs[i].hDocWnd && (!CommBusy || &ArticleDocs[i] != CommDoc))
      SendMessage (ArticleDocs[i].hDocWnd, WM_CLOSE, 0, 0L);
}
void
CloseStatusWnds ()
{
  /* destroying a coding status text is like popping from a stack */
  /* so we just loop while the top of the stack still exists */
  int numSkipped = 0;
  while (numSkipped < NumStatusTexts && CodingStatusText[numSkipped]->hTextWnd)
    if (!CodingStatusText[numSkipped]->IsBusy)
      SendMessage (CodingStatusText[numSkipped]->hTextWnd, WM_CLOSE, 0, 0L);
    else
      numSkipped++;
#if 0
    if (CodingState) {
      MessageBox (CodingStatusText[0]->hTextWnd,
        "Please wait until en/decoding is complete",
        "Cannot close status window", MB_OK | MB_ICONSTOP);
      break;
    }
    else
      SendMessage (CodingStatusText[0]->hTextWnd, WM_CLOSE, 0, 0L);
#endif
}

/* ------------------------------------------------------------------------
 *    CascadeWindows (and helper CascadeWnd)
 *      cascade em
 *      jsc 9/18/94
 */
HWND
CascadeWnd(HWND hWnd, HWND prevWnd, int nthWnd, int width, int height, int maxX, int maxY)
{
  short x, y;
  
//  if (IsMaximized(hWnd))
//     ShowWindow(hWnd, SW_SHOWNORMAL);

  x = (nthWnd * 12) % maxX;
  y = (nthWnd * (CaptionHeight+2)) % maxY;
  SetWindowPos(hWnd, prevWnd, x, y, width, height, SWP_DRAWFRAME);
  
  return hWnd;
}

void
CascadeWindows()
{
  register int i;
  int nthWnd, width, height, maxX, maxY;
  HWND prevWnd;

  width = (int)(xScreen>>1);
  height = (int)(yScreen>>1);
  maxX = 3 * (width>>1);	/* 3/4 screen width  */
  maxY = 3 * (height>>1);	/* 3/4 screen height */
  
  prevWnd = CascadeWnd(hWndConf, (HWND)NULL, 1, width, height, maxX, maxY);
  nthWnd = 2;
  for (i = 0; i < MAXGROUPWNDS; i++)
    if (GroupDocs[i].InUse && GroupDocs[i].hDocWnd && !IsMinimized(GroupDocs[i].hDocWnd)) {
		prevWnd = CascadeWnd(GroupDocs[i].hDocWnd, prevWnd, nthWnd, width, height, maxX, maxY);
        nthWnd++;
	}
    
  for (i = 0; i < MAXARTICLEWNDS; i++)
    if (ArticleDocs[i].InUse && ArticleDocs[i].hDocWnd && !IsMinimized(ArticleDocs[i].hDocWnd)) {
		prevWnd = CascadeWnd(ArticleDocs[i].hDocWnd, prevWnd, nthWnd, width, height, maxX, maxY);
        nthWnd++;
	}

  for (i = 0; i < MAXPOSTWNDS; i++)
    if (WndPosts[i].hWnd && !IsMinimized(WndPosts[i].hWnd)) {
		prevWnd = CascadeWnd(WndPosts[i].hWnd, prevWnd, nthWnd, width, height, maxX, maxY);
        nthWnd++;
	}

  for (i = 0; i < MAXMAILWNDS; i++)
    if (WndMails[i].hWnd && !IsMinimized(WndMails[i].hWnd)) {
		prevWnd = CascadeWnd(WndMails[i].hWnd, prevWnd, nthWnd, width, height, maxX, maxY);
        nthWnd++;
	}

  for (i = 0; i < NumStatusTexts; i++)
    if (CodingStatusText[i]->hTextWnd && !IsMinimized(CodingStatusText[i]->hTextWnd)) {
		prevWnd = CascadeWnd(CodingStatusText[i]->hTextWnd, prevWnd, nthWnd, width, height, maxX, maxY);
        nthWnd++;
	}

  /* move coded block status window to top center */
  if (hCodedBlockWnd)
    SetWindowPos(hCodedBlockWnd, (HWND)NULL, (xScreen-STATUSWIDTH)>>1, 1, STATUSWIDTH, STATUSHEIGHT, SWP_DRAWFRAME);
  
}
/* ------------------------------------------------------------------------
 *    BatchSend
 *      type is DOCTYPE_MAIL or _POST
 *      Increments nextBatchIndex and initiates mail/post
 *      Note: on entry nextBatchIndex is the index we will use for this send
 *      on exit, nextBatchIndex is either 0 (no more to send) or the index
 *      of the next mail/post to send
 *      (JSC 1/18/94)
 */
void
BatchSend (int type)
{
  int thisSend;
  int maxWnds;
  WndEdit *WndEdits;

  if (type == DOCTYPE_POSTING) {
    WndEdits = WndPosts;
    maxWnds = MAXPOSTWNDS;
  }
  else {
    WndEdits = WndMails;
    maxWnds = MAXMAILWNDS;
  }

  thisSend = nextBatchIndex;
  if (thisSend == 0) {     /* find first in batch (if any) */
    while (thisSend < maxWnds)
      if (WndEdits[thisSend].hWnd)
   break;
      else
   thisSend++;

    if (thisSend == maxWnds)
      return;        /* no open windows.  cancel */

    nextBatchIndex = thisSend;
  }

  /* find next in batch (if any) */
  while (++nextBatchIndex < maxWnds)
    if (WndEdits[nextBatchIndex].hWnd)
      break;

  if (nextBatchIndex == maxWnds)
    nextBatchIndex = 0;    /* no more */

  if (type == DOCTYPE_POSTING)
    StartPost (&WndEdits[thisSend]);
  else
    StartMail (&WndEdits[thisSend]);
}

/* ------------------------------------------------------------------------
 *    Test busy functions
 *      Called to test if a comm or decoding is busy
 *      Returns true if busy, false if not busy
 *      (JSC 1/9/94)
 */
BOOL
TestCommBusy (HWND hParentWnd, char *msg)
{
  if (CommBusy) {
    MessageBox (hParentWnd,
      "Sorry, I am already busy communicating with the server.\n"
      "Try again in a little while.", msg,
      MB_OK | MB_ICONASTERISK);
    return (TRUE);
  }
  else
    return (FALSE);
}

BOOL
TestDecodeBusy (HWND hParentWnd, char *msg)
{
  if (Decoding || CommDecoding) {
    MessageBox (hParentWnd,
        "Sorry, I can only handle one en/decoding session at a time.\n"
      "Try again in a little while.", msg,
      MB_OK | MB_ICONASTERISK);
    return (TRUE);
  }
  else
    return (FALSE);
}

/* ------------------------------------------------------------------------
 *    	Update the mail menus -- called on mail transport change
 *		jsc 9/9/94
 */
void
UpdateAllMailMenus()
{
	register int i;
	
	SetMainMailMenu(hWndConf);
    for (i = 0; i < MAXARTICLEWNDS; i++)
	    if (ArticleDocs[i].hDocWnd) 
	    	SetArticleMailMenu(ArticleDocs[i].hDocWnd);

	for (i = 0; i < MAXGROUPWNDS; i++)
		if (GroupDocs[i].hDocWnd)
	    	SetGroupMailMenu(GroupDocs[i].hDocWnd);
}   	
@


1.68
log
@massive cleanup for 92.6.  moved some code to wvfiler.c
@
text
@d2 1
a2 1
 * $Id: wvutil.c 1.67 1994/08/26 21:08:04 dumoulin Exp $
d1965 1
a1965 1
    if (GroupDocs[i].hDocWnd) {
d1978 1
a1978 1
    if (ArticleDocs[i].hDocWnd) {
d2004 5
a2008 5
  for (i = 0; i < numStatusTexts; i++)
    if (codingStatusText[i]->hTextWnd) {
      SetHandleBkBrush (codingStatusText[i]->hTextWnd, hStatusBackgroundBrush);
      SendMessage (codingStatusText[i]->hTextWnd, WM_SIZE, 0, 0L);
      InvalidateRect (codingStatusText[i]->hTextWnd, NULL, TRUE);
d2028 1
a2028 1
    if (GroupDocs[i].hDocWnd)
d2038 1
a2038 1
    if (ArticleDocs[i].hDocWnd)
d2046 7
a2052 1
  while (numStatusTexts > 0 && codingStatusText[0]->hTextWnd)
d2054 1
a2054 1
      MessageBox (codingStatusText[0]->hTextWnd,
d2060 2
a2061 1
      SendMessage (codingStatusText[0]->hTextWnd, WM_CLOSE, 0, 0L);
d2064 12
d2077 56
d2237 1
a2237 1
}   	@


1.67
log
@fix problem with estimated number of articles in a group
@
text
@d2 1
a2 1
 * $Id: wvutil.c 1.66 1994/08/24 18:40:15 mrr Exp dumoulin $
d9 1
a9 3
#define STRICT
#include "windows.h"
#include <commdlg.h>    // for GetOpenFileName dialog (JSC)
d13 2
a17 1
#include <dos.h>     // _dos_getfileattr
a29 2
#define MAXFILTERLEN 512

a388 1
  int mbcode;
a394 1
  char *cptr;
d580 1
d626 1
d1359 1
a1359 6
   cptr = "Posting Failed";
   mbcode = MB_OK | MB_ICONEXCLAMATION;
   MessageBox (PostEdit->hWnd, CommLineIn + 4, cptr, mbcode);
   /* let 'em fix the post! */
   SendMessage (PostEdit->hWndEdit, EM_SETREADONLY, FALSE, 0L);

d1368 1
a1368 16
   cptr = "Article Posted OK";
   mbcode = MB_OKCANCEL;
   /*      if (MessageBox(hPostEdit,CommLineIn+4,cptr,mbcode) */
   /*           == ID_OK) */
   if (!Attaching || (Attaching && ReviewAttach)) {
     if (PostLog) {
       char *mbuf;
       mbuf = GetEditText (PostEdit->hWndEdit);
       WriteEditLog (PostEdit->hWnd, PostLogFile, mbuf,
           (unsigned int) SendMessage (PostEdit->hWndEdit,
                    WM_GETTEXTLENGTH, 0, 0L));
       GlobalFreePtr (mbuf);
     }
     PostEdit->dirty = DT_CLEAN;
     DestroyWindow (PostEdit->hWnd);
   }
a1690 58
/*------------------------------------------------------------------------------
 * ExtWithoutName
 * Copies into tempName: the extension only
 * i.e. c:\windows\system\xyz.txt returns txt
 * JSC 11/1/93
 */
char *
GetFileExtension (char *tempName, char *fileName)
{
  char *theDot;

  if ((theDot = strrchr (fileName, '.')) == NULL)
    *tempName = '\0';
  else
    strcpy (tempName, &fileName[theDot - fileName + 1]);

  return (tempName);
}

/*------------------------------------------------------------------------------
 * NameWithoutPath
 * Copies into tempName: the name of fileName (chops off the path)
 * i.e. c:\windows\system\xyz.txt returns xyz.txt
 * JSC 11/1/93
 */
char *
NameWithoutPath (char *tempName, char *fileName)
{
  char *lastSlash;

  if ((lastSlash = strrchr (fileName, '\\')) == NULL)
    strcpy (tempName, fileName); /* no path given.  done */
  else
    strcpy (tempName, &fileName[lastSlash - fileName + 1]);

  return (tempName);
}

/*------------------------------------------------------------------------------
 * NameWithoutPath
 * Copies into tempName: the path of fileName (chops off the name)
 * i.e. c:\windows\system\xyz.txt returns c:\windows\system
 * JSC 7/16/94
 */
char *
PathWithoutName (char *tempName, char *fileName)
{
  char *lastSlash;

  if ((lastSlash = strrchr (fileName, '\\')) == NULL)
    strcpy (tempName, fileName); /* no path given.  done */
  else {
    strncpy (tempName, fileName, lastSlash - fileName);
    tempName[lastSlash - fileName] = '\0';
  }
  return (tempName);
}

d1722 1
a1722 1
 * Returns true if the string is a all digits, allowing 1st char to be + or -
d1731 1
a1731 1
    if (!isdigit (*ptr) && (ptr != str || !strchr ("+-", *ptr)))
a1821 221
 *    Asks for a path - uses hook callback to allow just a path (usual
 *      behavior requires the user to enter a filename)
 *
 *      See example MSJ Jan 93, Question&Answers (Fran Finnegan)
 *      JSC 7/17/94
 *      don't forget to add  GETPATHHOOKPROC  to winvn.def and compile with /Gw
 *
 *      Damn! Doesn't work because the the OK msg is only generated if
 *      the user has entered a complete filename.  How to do this then?!
 */
#if 0
extern UINT CALLBACK
GetPathHookProc (HWND hDlg, UINT iMessage, WPARAM wParam, LPARAM lParam)
{
  static LPOPENFILENAME ofn;
  static UINT fileNameMsg;
  unsigned attrib;

  if (iMessage == WM_INITDIALOG) {
    ofn = (LPOPENFILENAME) lParam;
    fileNameMsg = (UINT) LOWORD ((DWORD) ofn->lCustData);
    return TRUE;
  }
  else {
    if (iMessage == fileNameMsg) {  /* Trap the FILEOKSTRING msg */
      /* if it exists and its a directory, then bypass default  */
      /* OK processing */
      if (_dos_getfileattr (ofn->lpstrFile, &attrib) == 0 && (attrib & _A_SUBDIR))
   return TRUE;
    }
  }
  return FALSE;         /* Allow standard processing */

}
#endif

BOOL
AskForFilePath (HWND hParentWnd, char *pathName, char *title)
{
  OPENFILENAME ofn;
  char szFile[MAXFILENAME];
  char filters[MAXFILTERLEN];

  GenerateFileFilters (hParentWnd, filters);

/*      Open dialog to ask user for a new file name */
  memset (&ofn, 0, sizeof (OPENFILENAME));
  szFile[0] = '\0';
  ofn.lpstrTitle = title;
  ofn.lStructSize = sizeof (OPENFILENAME);
  ofn.hwndOwner = hParentWnd;
  ofn.lpstrFilter = filters;
  ofn.nFilterIndex = 1;
  ofn.lpstrFile = szFile;
  ofn.nMaxFile = sizeof (szFile);
  ofn.lpstrFileTitle = NULL;
  ofn.Flags = OFN_SHOWHELP | OFN_PATHMUSTEXIST;

#if 0
  UINT fileNameMsg;
  ofn.Flags = OFN_SHOWHELP | OFN_PATHMUSTEXIST | OFN_ENABLEHOOK;
  ofn.lpfnHook = MakeProcInstance ((FARPROC) GetPathHookProc, (HINSTANCE) hInst);
  /* Register the FILEOKSTRING message */
  fileNameMsg = RegisterWindowMessage ((LPCSTR) FILEOKSTRING);
  /* Pass the FILEOKSTRING message ID in LOWORD of lCustData field */
  ofn.lCustData = MAKELPARAM (fileNameMsg, 0);
#endif

  if (GetOpenFileName (&ofn) == 0)
    return (FAIL);

/*      FreeProcInstance(&ofn.lpfnHook); */
  PathWithoutName (pathName, strlwr (szFile));
  return (SUCCESS);
}


/*      Set up filters */
void
GenerateFileFilters (HWND hParentWnd, char *filters)
{
  register int i;
  int len;
  char chReplace;

  if ((len = LoadString (hInst, IDS_FILTERSTRING, filters, MAXFILTERLEN - 1)) == 0) {
    MessageBox (hParentWnd, "No Filters Available", "String Load Failure", MB_OK);
    *filters = '\0';
  }
  else {
    chReplace = filters[len - 1];   /* grab separator */

    for (i = 0; filters[i] != '\0'; i++)
      if (filters[i] == chReplace)
   filters[i] = '\0';
  }
}

/* ------------------------------------------------------------------------
 *    Asks for a filename which must exist
 *      (JSC)
 */
BOOL
AskForExistingFileName (HWND hParentWnd, char *fileName, char *title)
{
  OPENFILENAME ofn;
  char szFile[MAXFILENAME];
  char filters[MAXFILTERLEN];

  GenerateFileFilters (hParentWnd, filters);

/*      Open dialog to ask user for a new file name */
  memset (&ofn, 0, sizeof (OPENFILENAME));
  szFile[0] = '\0';
  ofn.lpstrTitle = title;
  ofn.lStructSize = sizeof (OPENFILENAME);
  ofn.hwndOwner = hParentWnd;
  ofn.lpstrFilter = filters;
  ofn.nFilterIndex = 1;
  ofn.lpstrFile = szFile;
  ofn.nMaxFile = sizeof (szFile);
  ofn.lpstrFileTitle = NULL;
  ofn.Flags = OFN_SHOWHELP | OFN_FILEMUSTEXIST;

  if (GetOpenFileName (&ofn) == 0)
    return (FAIL);
  strcpy (fileName, strlwr (szFile));
  return (SUCCESS);
}
/* ------------------------------------------------------------------------
 *    Make sure file name is OK for DOS 8.3
 *      Check if file name is OK for DOS.  If not, prompt user new name
 *      Check if file already exists.  If so, prompt user OK to overwrite
 *      If fileName contains a name on entry, check if it's OK, if yes-done
 *      (JSC)
 */
BOOL
AskForNewFileName (HWND hParentWnd, char *fileName, char *startDir)
{
  OFSTRUCT outFileStruct;
  OPENFILENAME ofn;
  HFILE hWriteFile;
  char mybuf[MAXINTERNALLINE];
  char szDirName[256];
  char szFile[256];
  BOOL retcode;
  char filters[MAXFILTERLEN];

  GenerateFileFilters (hParentWnd, filters);
  while (fileName[0] == '\0' ||
    (retcode = VerifyFileName (fileName)) == FAIL ||
    (hWriteFile = OpenFile ((char far *) fileName, &outFileStruct, OF_EXIST)) >= 0) {
    if (fileName[0] != '\0' && retcode == SUCCESS) {
/*      File name ok, but file exists.  Ask user if ok to wipe it */
      sprintf (mybuf, "File %s exists.  OK to overwrite it?", fileName);
      retcode = MessageBox (hParentWnd, mybuf, "File exists",
             MB_YESNO | MB_DEFBUTTON2 | MB_ICONQUESTION);
      if (retcode == IDYES)
   break;
    }

/*      Open dialog to ask user for a new file name */
    memset (&ofn, 0, sizeof (OPENFILENAME));
    if (fileName[0] != '\0')
      sprintf (mybuf, "Invalid file name %s. Select new name", fileName);
    else
      strcpy (mybuf, "Select new file name to create/overwrite");

    ofn.lpstrTitle = mybuf;
    strcpy (szDirName, startDir);
    ofn.lpstrInitialDir = szDirName;
    ofn.lStructSize = sizeof (OPENFILENAME);
    ofn.hwndOwner = hParentWnd;
    ofn.lpstrFilter = filters;
    ofn.nFilterIndex = 1;
    szFile[0] = '\0';
    ofn.lpstrFile = szFile;
    ofn.nMaxFile = sizeof (szFile);
    ofn.lpstrFileTitle = NULL;
    ofn.Flags = OFN_SHOWHELP | OFN_PATHMUSTEXIST;

    if (GetOpenFileName (&ofn) == 0)
      return (FAIL);

    strcpy (fileName, strlwr (ofn.lpstrFile));
  }
  return (SUCCESS);
}
/* ------------------------------------------------------------------------
 *    Make sure file name is OK for DOS 8.3
 *      (JSC)
 */
BOOL
VerifyFileName (char *fileName)
{
  char *beg, *ptr;

  if ((beg = strrchr (fileName, '\\')) == NULL)
    beg = fileName;
  else
    beg++;        /* skip to after path slash */

  if ((ptr = strchr (beg, '.')) == NULL)
    if (strlen (beg) <= 8) /* no extension */
      return (SUCCESS);

  if (ptr - beg > 8)
    return (FAIL);

  beg = ptr + 1;     /* multiple extensions */
  if ((ptr = strchr (beg, '.')) != NULL)
    return (FAIL);

  if (strlen (beg) > 3)    /* extension too long */
    return (FAIL);

  return (SUCCESS);
}


/* ------------------------------------------------------------------------
d2144 19
@



1.66
log
@authorization enables post/mail
@
text
@d2 1
a2 1
 * $Id: wvutil.c 1.65 1994/08/11 02:25:59 dumoulin Exp $
d589 2
a590 1
     {
d593 1
a593 2
             { 
              arts_to_retrieve = (int) estnum;
@



1.65
log
@enabled STRICT compile and cleaned up parameter casting
@
text
@d2 1
a2 1
 * $Id: wvutil.c 1.64 1994/08/11 00:13:22 jcooper Exp dumoulin $
d11 2
a12 2
#include <commdlg.h>		// for GetOpenFileName dialog (JSC)
#include <windowsx.h>		// for GlobalFreePtr (JSC)
d18 1
a18 1
#include <dos.h>		// _dos_getfileattr
d92 1
a92 1
    else			/* No name in parens */
d95 1
a95 1
  else				/* !FullNameFrom */
d134 2
a135 2
	   GetGValue (rgbVal),
	   GetBValue (rgbVal));
d238 1
a238 1
	CommLinePtr--;
d245 3
a247 3
		     char *group_name,
		     unsigned long line_number,
		     unsigned long total_lines)
d307 2
a308 2
	     unsigned long activenum,
	     header_p headers, TypGroup far * GroupDoc)
d317 1
a317 1
	return (headerloc);
d325 1
a325 1
	return (headerloc);
d335 1
a335 1
  char *end = refer + strlen (refer) - 1;	/* points to NULL */
d345 1
a345 1
	bracket_len = 0;
d347 3
a349 3
	bracket2 = strrchr (refer, '>');
	if (bracket2)
	  bracket_len = (int) (bracket2 - bracket1) + 1;
d419 26
a444 25
	break;
      if (retcode == 200 || retcode == 201) {	/* was 500 from induced error */
	CommBusy = TRUE;
	do_authinfo = FALSE;
	if (strlen (NNTPUserName)) {
	  /* We have the AUTHINFO username.  Do we have the password? */
	  if (!strlen (NNTPPasswordEncrypted)) {
	    /* Get the news server user password from the user */
	    if (DialogBox (hInst, (LPCSTR) "WinVnComm", hWndConf, (DLGPROC) lpfnWinVnCommDlg)
		&& strlen (NNTPPasswordEncrypted)) {
	      do_authinfo = TRUE;
	    }
	  }
	  else {
	    do_authinfo = TRUE;
	  }
	}
	if (do_authinfo) {
	  sprintf (mybuf, "AUTHINFO user %s", NNTPUserName);
	  CommState = ST_CHECK_AUTHINFO_USERNAME;
	  PutCommLine (mybuf);
	}
	else {
	  goto End_Authinfo;
	}
d448 5
a452 5
	MessageBox (hWndConf, CommLineIn, "Access Problem", MB_OK);
	/*      MRRCloseComm (); */
	/*        PostQuitMessage (0); */
	Initializing = INIT_NOT_CONNECTED;
	InvalidateRect (hWndConf, NULL, TRUE);
d461 1
a461 1
	break;
d463 2
a464 2
	MessageBox (hWndConf, "Error authorizing your username with the News Server.", "WinVN", MB_OK | MB_ICONHAND);
	goto End_Authinfo;
d474 1
a474 1
	break;
d477 1
a477 1
	break;
d479 10
a488 4
	dialog_active = TRUE;
	sprintf (mybuf, "Error authorizing your password with the News Server:\n%s.", CommLineIn);
	MessageBox (hWndConf, mybuf, "WinVN", MB_OK | MB_ICONHAND);
	dialog_active = FALSE;
d503 4
a506 4
      if (retcode == 412 && !force_xhdr)	/* 412 == 'not in a newsgroup' */
	xoverp = 1;
      else			/* 500 == 'command not understood' */
	xoverp = 0;
d510 3
a512 3
	if (MessageBox (hWndConf, "Request the latest group list from server?\n(This can be time consuming)",
			"Request LIST from server?", MB_ICONQUESTION | MB_YESNO | MB_DEFBUTTON2) == IDNO)
	  dolist = 0;
d515 2
a516 2
	StartList ();
	did_list = 1;
d519 4
a522 4
	did_list = 0;
	CommState = ST_NONE;
	CommBusy = FALSE;
	Initializing = INIT_READY;
d531 2
a532 2
	check_server_code (retcode);
	break;
d541 4
a544 4
	CommState = ST_NONE;
	CommBusy = FALSE;
	Initializing = INIT_READY;
	InvalidateRect (hWndConf, NULL, FALSE);
d546 1
a546 1
	ProcEndList ();
d549 1
a549 1
	ProcListLine ((unsigned char *) CommLineIn);
d558 7
a564 7
	MessageBox (hWndConf, "No Such Newsgroup", "Error", MB_OK | MB_ICONHAND);
	/* abort the fledgling group window */
	DestroyWindow (CommDoc->hDocWnd);
	CommBusy = FALSE;
	CommState = ST_NONE;
	return;
	break;
d566 7
a572 7
	MessageBox (hWndConf, "Restricted Access", "WinVN", MB_OK | MB_ICONHAND);
	/* abort the fledgling group window */
	DestroyWindow (CommDoc->hDocWnd);
	CommBusy = FALSE;
	CommState = ST_NONE;
	return;
	break;
d574 3
a576 3
	if (check_server_code (retcode))
	  return;
	break;
d582 1
a582 1
		CommDoc->ParentLineID, &BlockPtr, &LinePtr);
d588 3
a590 3
	if (!ShowUnreadOnly)
	  {
	  DlgStatus = DialogBox (hInst, (LPCSTR) "THRESHOLD", CommDoc->hDocWnd, (DLGPROC) lpfnWinVnThresholdDlg);
d595 4
a598 4
	      CommBusy = FALSE;
	      CommState = ST_NONE;
	      GroupDoc->ServerFirst = GroupDoc->ServerLast;
	      GroupDoc->ServerEstNum = estnum;
d602 20
a621 20
	if ((arts_to_retrieve > 0)
	    && ((last - arts_to_retrieve) > first)) {
	  first = (last - arts_to_retrieve) + 1;
	}
	else if (arts_to_retrieve == -1)	/* they clicked 'all of them' */
	  arts_to_retrieve = (int) estnum;
	/* added by jlg */
	else if ((arts_to_retrieve == -2)	/* they clicked 'unread' */
		 ||(ShowUnreadOnly)) {
	  if (GroupDoc->nRanges) {
	    first = RangePtr[0].Last + 1;
	    arts_to_retrieve = (int) ((last - first) + 1);
	    if (arts_to_retrieve < 50) {
	      arts_to_retrieve = 50;
	      first = last - 49;
	    }
	  }
	  else
	    arts_to_retrieve = (int) estnum;
	}
d624 12
a635 12
	if (estnum > 0)
	  arts_to_retrieve = (int) estnum;
	else {
	  MessageBox (hWndConf, "Empty Newsgroup", "WinVN", MB_OK | MB_ICONHAND);
	  /* abort the fledgling group window */
	  DestroyWindow (CommDoc->hDocWnd);
	  CommBusy = FALSE;
	  CommState = ST_NONE;
	  GroupDoc->ServerFirst = GroupDoc->ServerLast;
	  GroupDoc->ServerEstNum = 0;
	  return;
	}
d641 9
a649 9
	header_handle =
	  GlobalAlloc (GMEM_MOVEABLE, (long)
		       ((sizeof (TypHeader)) *
		      (long) (arts_to_retrieve)) + sizeof (thread_array *));

	/* allocate space for the header_array index table */
	thread_handle =
	  GlobalAlloc (GMEM_MOVEABLE,
		       (long) ((sizeof (long)) * (long) (arts_to_retrieve)));
d651 2
a652 2
	GroupDoc->header_handle = header_handle;
	GroupDoc->thread_handle = thread_handle;
d667 3
a669 3
	mylen = sprintf (mybuf, "XOVER %ld-%ld", first, last);
	CommState = ST_XOVER_START;
	PutCommLine (mybuf);
d672 3
a674 3
	mylen = sprintf (mybuf, "XHDR from %ld-%ld", first, last);
	CommState = ST_XHDR_FROM_START;
	PutCommLine (mybuf);
d694 2
a695 2
	CommState = ST_XOVER_DATA;
	CommDoc->ActiveLines = 0;
d698 3
a700 3
	mylen = sprintf (mybuf, "XHDR from %ld-%ld", first, last);
	CommState = ST_XHDR_FROM_START;
	PutCommLine (mybuf);
d706 5
a710 5
	/* this is a yuck way to do this */
	CommState = ST_IN_GROUP;
	CommBusy = FALSE;
	finish_header_retrieval (CommDoc);
	InvalidateRect (CommDoc->hDocWnd, NULL, FALSE);
d713 2
a714 2
	char *this_hop, *next_hop;
	char *reference;
d716 87
a802 87
	LockLine (CommDoc->hParentBlock, CommDoc->ParentOffset,
		  CommDoc->ParentLineID, &BlockPtr, &LinePtr);
	GroupDoc = ((TypGroup far *) ((char far *) LinePtr + sizeof (TypLine)));
	header_handle = GroupDoc->header_handle;
	thread_handle = GroupDoc->thread_handle;

	GlobalUnlock (BlockPtr->hCurBlock);

	/* Lock the header data */
	headers = lock_headers (header_handle, thread_handle);
	header = header_elt (headers, CommDoc->ActiveLines);

	this_hop = CommLineIn;

	/* article number */
	next_hop = strchr (this_hop, '\t');
	*(next_hop++) = (char) NULL;

	header->number = atol (this_hop);

	/* subject */
	this_hop = next_hop;
	next_hop = strchr (this_hop, '\t');
	*(next_hop++) = (char) NULL;

	mylstrncpy (header->subject, this_hop, HEADER_SUBJECT_LENGTH);
	CommDoc->LongestLine = max (CommDoc->LongestLine,
				    ARTICLE_SUBJECT_OFFSET +
				    (unsigned) lstrlen (header->subject));
	/* author */
	this_hop = next_hop;
	next_hop = strchr (this_hop, '\t');
	*(next_hop++) = (char) NULL;

	ParseAddress (this_hop,
		      AddressString, MAXDIALOGSTRING,
		      NameString, MAXDIALOGSTRING);

	if (FullNameFrom)
	  mylstrncpy (header->from, NameString, HEADER_FROM_LENGTH);
	else
	  mylstrncpy (header->from, this_hop, HEADER_FROM_LENGTH);

	/* date */
	this_hop = next_hop;
	next_hop = strchr (this_hop, '\t');
	*(next_hop++) = (char) NULL;

	header->date = parse_usenet_date (this_hop);

	/* message-id */
	this_hop = next_hop;
	next_hop = strchr (this_hop, '\t');
	*(next_hop++) = (char) NULL;

	mylstrncpy (header->message_id, this_hop, HEADER_MESSAGE_ID_LENGTH);

	/* references */
	this_hop = next_hop;
	next_hop = strchr (this_hop, '\t');
	*(next_hop++) = (char) NULL;

	reference = get_best_reference (this_hop);
	if (reference)
	  mylstrncpy (header->references, reference, HEADER_REFERENCES_LENGTH);

	/* bytes (ignored) */
	this_hop = next_hop;
	next_hop = strchr (this_hop, '\t');
	*(next_hop++) = (char) NULL;

	/* lines (last one doesn't have to have the tab */
	this_hop = next_hop;
	header->lines = atoi (this_hop);

	/* set other header fields */
	header->Selected = FALSE;
	header->ArtDoc = (TypDoc *) NULL;
	header->Seen = WasArtSeen (header->number, GroupDoc);

	unlock_headers (header_handle, thread_handle);

	CommDoc->ActiveLines++;

	update_window_title (CommDoc->hDocWnd, group,
			     RcvLineCount++,
			     CommDoc->TotalLines);
d822 1
a822 1
      total_xhdrs = threadp ? 6 : 4;	/* we do this here to allow */
d825 1
a825 1
	break;
d832 2
a833 2
	LockLine (CommDoc->hParentBlock, CommDoc->ParentOffset,
		  CommDoc->ParentLineID, &BlockPtr, &LinePtr);
d835 2
a836 2
	GroupDoc = ((TypGroup far *) ((char far *) LinePtr + sizeof (TypLine)));
	GroupDoc->total_headers = CommDoc->ActiveLines;
d838 2
a839 2
	first = GroupDoc->ServerFirst;
	last = GroupDoc->ServerLast;
d841 7
a847 7
	GlobalUnlock (BlockPtr->hCurBlock);
	CommDoc->ActiveLines = 0;

	/* Now ask for the date lines */
	mylen = sprintf (mybuf, "XHDR date %ld-%ld", first, last);
	CommState = ST_XHDR_DATE_START;
	PutCommLine (mybuf);
d850 36
a885 36
	/*      char neat_from [80]; */
	/* Access the Group struct, get HANDLE for header data */
	LockLine (CommDoc->hParentBlock, CommDoc->ParentOffset,
		  CommDoc->ParentLineID, &BlockPtr, &LinePtr);

	GroupDoc = ((TypGroup far *) ((char far *) LinePtr + sizeof (TypLine)));
	header_handle = GroupDoc->header_handle;
	thread_handle = GroupDoc->thread_handle;

	GlobalUnlock (BlockPtr->hCurBlock);

	/* Lock the header data */
	headers = lock_headers (header_handle, thread_handle);

	sscanf (CommLineIn, "%ld", &artnum);
	header = header_elt (headers, CommDoc->ActiveLines);
	header->number = artnum;

	/* now use some of our nice formatting of email addresses */
	ParseAddress (get_xhdr_line (CommLineIn),
		      AddressString, MAXDIALOGSTRING,
		      NameString, MAXDIALOGSTRING);

	/* copy that into headers[].from */
	if (FullNameFrom)
	  mylstrncpy (header->from, NameString, HEADER_FROM_LENGTH);
	else
	  mylstrncpy (header->from, AddressString, HEADER_FROM_LENGTH);

	unlock_headers (header_handle, thread_handle);

	CommDoc->ActiveLines++;

	update_window_title (CommDoc->hDocWnd, group,
			     RcvLineCount++,
			     CommDoc->TotalLines * total_xhdrs);
d894 1
a894 1
	break;
d901 2
a902 2
	LockLine (CommDoc->hParentBlock, CommDoc->ParentOffset,
		  CommDoc->ParentLineID, &BlockPtr, &LinePtr);
d904 2
a905 2
	GroupDoc = ((TypGroup far *) ((char far *) LinePtr + sizeof (TypLine)));
	GroupDoc->total_headers = CommDoc->ActiveLines;
d907 2
a908 2
	first = GroupDoc->ServerFirst;
	last = GroupDoc->ServerLast;
d910 7
a916 7
	GlobalUnlock (BlockPtr->hCurBlock);
	CommDoc->ActiveLines = 0;

	/* Now ask for the #of lines */
	mylen = sprintf (mybuf, "XHDR lines %ld-%ld", first, last);
	CommState = ST_XHDR_LINES_START;
	PutCommLine (mybuf);
d920 25
a944 25
	/* Access the Group struct, get HANDLE for header data */
	LockLine (CommDoc->hParentBlock, CommDoc->ParentOffset,
		  CommDoc->ParentLineID, &BlockPtr, &LinePtr);
	GroupDoc = ((TypGroup far *) ((char far *) LinePtr + sizeof (TypLine)));
	header_handle = GroupDoc->header_handle;
	thread_handle = GroupDoc->thread_handle;

	GlobalUnlock (BlockPtr->hCurBlock);

	/* Lock the header data */
	headers = lock_headers (header_handle, thread_handle);
	syncnum = sync_artnum (atol (CommLineIn),
		       (header_elt (headers, CommDoc->ActiveLines))->number,
			       headers,
			       GroupDoc);
	if (syncnum >= 0)
	  (header_elt (headers, syncnum))->date
	    = parse_usenet_date (get_xhdr_line (CommLineIn));

	unlock_headers (header_handle, thread_handle);

	CommDoc->ActiveLines++;
	update_window_title (CommDoc->hDocWnd, group,
			     RcvLineCount++,
			     CommDoc->TotalLines * total_xhdrs);
d953 1
a953 1
	break;
d960 2
a961 2
	LockLine (CommDoc->hParentBlock, CommDoc->ParentOffset,
		  CommDoc->ParentLineID, &BlockPtr, &LinePtr);
d963 2
a964 2
	GroupDoc = ((TypGroup far *) ((char far *) LinePtr + sizeof (TypLine)));
	GroupDoc->total_headers = CommDoc->ActiveLines;
d966 2
a967 2
	first = GroupDoc->ServerFirst;
	last = GroupDoc->ServerLast;
d969 16
a984 16
	GlobalUnlock (BlockPtr->hCurBlock);
	CommDoc->ActiveLines = 0;

	/* Check for threading option, if enabled, go to REF & ID */
	/* states first */

	if (threadp) {
	  CommState = ST_XHDR_REF_START;
	  mylen = sprintf (mybuf, "XHDR references %ld-%ld", first, last);
	  PutCommLine (mybuf);
	}
	else {
	  CommState = ST_XHDR_SUBJECT_START;
	  mylen = sprintf (mybuf, "XHDR subject %ld-%ld", first, last);
	  PutCommLine (mybuf);
	}
d989 25
a1013 25
	/* Access the Group struct, get HANDLE for header data */
	LockLine (CommDoc->hParentBlock, CommDoc->ParentOffset,
		  CommDoc->ParentLineID, &BlockPtr, &LinePtr);
	GroupDoc = ((TypGroup far *) ((char far *) LinePtr + sizeof (TypLine)));

	header_handle = GroupDoc->header_handle;
	thread_handle = GroupDoc->thread_handle;

	GlobalUnlock (BlockPtr->hCurBlock);

	/* Lock the header data */
	headers = lock_headers (header_handle, thread_handle);

	syncnum = sync_artnum (atol (CommLineIn),
		       (header_elt (headers, CommDoc->ActiveLines))->number,
			       headers,
			       GroupDoc);
	if (syncnum >= 0)
	  sscanf (CommLineIn, "%ld %Fd", &artnum, &((header_elt (headers, syncnum))->lines));

	unlock_headers (header_handle, thread_handle);
	CommDoc->ActiveLines++;
	update_window_title (CommDoc->hDocWnd, group,
			     RcvLineCount++,
			     CommDoc->TotalLines * total_xhdrs);
d1022 1
a1022 1
	break;
d1029 2
a1030 2
	LockLine (CommDoc->hParentBlock, CommDoc->ParentOffset,
		  CommDoc->ParentLineID, &BlockPtr, &LinePtr);
d1032 2
a1033 2
	GroupDoc = (TypGroup far *) ((char far *) LinePtr + sizeof (TypLine));
	GroupDoc->total_headers = CommDoc->ActiveLines;
d1035 2
a1036 2
	first = GroupDoc->ServerFirst;
	last = GroupDoc->ServerLast;
d1038 7
a1044 7
	GlobalUnlock (BlockPtr->hCurBlock);
	CommDoc->ActiveLines = 0;

	/* Now ask for the message-id lines */
	mylen = sprintf (mybuf, "XHDR message-id %ld-%ld", first, last);
	CommState = ST_XHDR_MID_START;
	PutCommLine (mybuf);
d1047 2
a1048 2
	char far *refer;	/* , far * end,far * bracket1,far *bracket2; */
	/*      int bracket_len; */
d1050 35
a1084 35
	/* Access the Group struct, get HANDLE for header data */
	LockLine (CommDoc->hParentBlock, CommDoc->ParentOffset,
		  CommDoc->ParentLineID, &BlockPtr, &LinePtr);
	GroupDoc = ((TypGroup far *) ((char far *) LinePtr + sizeof (TypLine)));

	header_handle = GroupDoc->header_handle;
	thread_handle = GroupDoc->thread_handle;

	GlobalUnlock (BlockPtr->hCurBlock);

	/* Lock the header data */
	headers = lock_headers (header_handle, thread_handle);

	/* for now, we only pay attention to first (whole) referral */
	refer = get_xhdr_line (CommLineIn);

	refer = get_best_reference (refer);

	if (refer) {
	  /* Patch to check for bad info from server JD 6/19/93 */
	  syncnum = sync_artnum (atol (CommLineIn),
				 (header_elt (headers,
					      CommDoc->ActiveLines))->number,
				 headers, GroupDoc);
	  if (syncnum >= 0)
	    mylstrncpy ((header_elt (headers, syncnum))->references,
			refer, HEADER_REFERENCES_LENGTH);
	}

	unlock_headers (header_handle, thread_handle);

	CommDoc->ActiveLines++;
	update_window_title (CommDoc->hDocWnd, group,
			     RcvLineCount++,
			     CommDoc->TotalLines * total_xhdrs);
d1095 1
a1095 1
	break;
d1102 2
a1103 2
	LockLine (CommDoc->hParentBlock, CommDoc->ParentOffset,
		  CommDoc->ParentLineID, &BlockPtr, &LinePtr);
d1105 1
a1105 1
	GroupDoc = (TypGroup far *) ((char far *) LinePtr + sizeof (TypLine));
d1107 1
a1107 1
	GroupDoc->total_headers = CommDoc->ActiveLines;
d1109 2
a1110 2
	first = GroupDoc->ServerFirst;
	last = GroupDoc->ServerLast;
d1112 2
a1113 2
	GlobalUnlock (BlockPtr->hCurBlock);
	CommDoc->ActiveLines = 0;
d1115 4
a1118 4
	/* Now ask for the subject lines */
	mylen = sprintf (mybuf, "XHDR subject %ld-%ld", first, last);
	CommState = ST_XHDR_SUBJECT_START;
	PutCommLine (mybuf);
d1121 29
a1149 29
	/* Access the Group struct, get HANDLE for header data */
	LockLine (CommDoc->hParentBlock, CommDoc->ParentOffset,
		  CommDoc->ParentLineID, &BlockPtr, &LinePtr);

	GroupDoc = (TypGroup far *) ((char far *) LinePtr + sizeof (TypLine));

	header_handle = GroupDoc->header_handle;
	thread_handle = GroupDoc->thread_handle;

	GlobalUnlock (BlockPtr->hCurBlock);

	/* Lock the header data */
	headers = lock_headers (header_handle, thread_handle);

	syncnum = sync_artnum (atol (CommLineIn),
		       (header_elt (headers, CommDoc->ActiveLines))->number,
			       headers,
			       GroupDoc);
	if (syncnum >= 0)
	  mylstrncpy ((header_elt (headers, syncnum))->message_id,
		      (char far *) (get_xhdr_line (CommLineIn)),
		      HEADER_MESSAGE_ID_LENGTH);	/* bad, hardcoded. */

	unlock_headers (header_handle, thread_handle);

	CommDoc->ActiveLines++;
	update_window_title (CommDoc->hDocWnd, group,
			     RcvLineCount++,
			     CommDoc->TotalLines * total_xhdrs);
d1160 1
a1160 1
	break;
d1167 4
a1170 4
	CommState = ST_IN_GROUP;
	CommBusy = FALSE;
	finish_header_retrieval (CommDoc);
	InvalidateRect (CommDoc->hDocWnd, NULL, FALSE);
d1174 42
a1215 42
	artnum = 0;
	sscanf (CommLineIn, "%ld", &artnum);
	if (artnum) {
	  LockLine (CommDoc->hParentBlock, CommDoc->ParentOffset,
		    CommDoc->ParentLineID, &BlockPtr, &LinePtr);

	  GroupDoc = ((TypGroup far *) ((char far *) LinePtr + sizeof (TypLine)));
	  header_handle = GroupDoc->header_handle;
	  thread_handle = GroupDoc->thread_handle;
	  headers = lock_headers (header_handle, thread_handle);

	  /* update the seen thing. */
	  syncnum = sync_artnum (atol (CommLineIn),
		       (header_elt (headers, CommDoc->ActiveLines))->number,
				 headers,
				 GroupDoc);
	  if (syncnum >= 0)
	    header = header_elt (headers, syncnum);
	  else
	    header = header_elt (headers, CommDoc->ActiveLines);

	  header->Selected = FALSE;
	  header->ArtDoc = (TypDoc *) NULL;
	  header->Seen =
	    WasArtSeen (artnum, (TypGroup far *) (((char far *) LinePtr) +
						  sizeof (TypLine)));

	  UnlockLine (BlockPtr, LinePtr, &(CommDoc->hParentBlock),
		      &(CommDoc->ParentOffset), &(CommDoc->ParentLineID));

	  mylstrncpy (header->subject,
		      get_xhdr_line (CommLineIn), HEADER_SUBJECT_LENGTH);

	  CommDoc->LongestLine = max (CommDoc->LongestLine,
				      ARTICLE_SUBJECT_OFFSET +
				      (unsigned) lstrlen (header->subject));

	  unlock_headers (header_handle, thread_handle);
	  CommDoc->ActiveLines++;
	  update_window_title (CommDoc->hDocWnd, group,
			       RcvLineCount++,
			       CommDoc->TotalLines * total_xhdrs);
d1217 1
a1217 1
	}
d1229 3
a1231 3
	if (CommDoc->hDocWnd)
	  DestroyWindow (CommDoc->hDocWnd);
	break;
d1239 1
a1239 1
	;			/* error: empty article (end in middle of header) */
d1242 2
a1243 2
      if (IsBlankStr (CommLineIn))	/* headers end in blank line */
	CommState = ST_REC_ARTICLE;
d1248 1
a1248 1
      if (strcmp (CommLineIn, ".") == 0) {	/* article receive complete */
d1250 2
a1251 2
	CommState = ST_IN_GROUP;
	CommBusy = FALSE;
d1253 6
a1258 6
	if (CommDecoding) {
	  SendMessage (currentCoded->hParentWnd, IDM_ARTICLE_RETRIEVE_COMPLETE, 0, 0);
	  break;
	}
	else
	{
d1263 49
a1311 49
	LockLine (CommDoc->ParentDoc->hParentBlock,
		  CommDoc->ParentDoc->ParentOffset,
		  CommDoc->ParentDoc->ParentLineID,
		  &BlockPtr, &LinePtr);

	GroupDoc = (TypGroup far *) ((char far *) LinePtr + sizeof (TypLine));
	header_handle = GroupDoc->header_handle;
	thread_handle = GroupDoc->thread_handle;

	headers = lock_headers (header_handle, thread_handle);
	lpsz = (char far *) ((header_elt (headers, CommDoc->LastSeenLineID))->subject);
	unlock_headers (header_handle, thread_handle);

	mylstrncpy (group, lpsz, MAXGROUPNAME);
	sprintf (mybuf, "%s (%u lines)", group, CommDoc->TotalLines);
	SetWindowText (CommDoc->hDocWnd, mybuf);
	InvalidateRect (CommDoc->hDocWnd, NULL, FALSE);
	GlobalUnlock (BlockPtr->hCurBlock);

	/* Skip to the first line of the text of the article
	 * and make sure it's visible on the screen.  This is
	 * so that the user doesn't have to have the first
	 * screen filled with a lengthy, worthless header.
	 *
	 * and save number of header lines (on display)
	 * for later (Bretherton)
	 */
	TopOfDoc (CommDoc, &BlockPtr, &LinePtr);
	found = FALSE;
	do {
	  lpsz = ((char far *) LinePtr + sizeof (TypLine) + sizeof (TypText));
	  if (IsLineBlank (lpsz)) {
	    found = TRUE;
	    CommDoc->HeaderLines = WhatLine (BlockPtr, LinePtr);
	    break;
	  }
	  if (!NextLine (&BlockPtr, &LinePtr))
	    break;
	}
	while (!found);
	NextLine (&BlockPtr, &LinePtr);

	/* If the line is in the last screen's worth of lines, back
	 * up the pointer so it points to the first line of the last
	 * screen.
	 */
	if (found && CommDoc->TotalLines > CommDoc->ScYLines &&
	    !CommDoc->TopScLineID)
	  AdjustTopSc (BlockPtr, LinePtr);
d1313 1
a1313 1
	UnlockLine (BlockPtr, LinePtr, &hBlock, &Offset, &MyLineID);
d1315 2
a1316 2
      else			/* not finished, continue article receive */
	AddCommLineToDoc (CommLineIn);
d1332 4
a1335 4
	if (Attaching && !ReviewAttach)
	  ProcessAttach (CONTINUE);
	else
	  PostText (PostEdit);
d1338 12
a1349 12
	check_server_code (retcode);
	MessageBox (PostEdit->hWnd, CommLineIn + 4, "Cannot Post Article",
		    MB_OK | MB_ICONEXCLAMATION);
	CommBusy = FALSE;
	CommState = ST_NONE;

	if (Attaching && !ReviewAttach)
	  ProcessAttach (ABORT);	/* cancel attachment */

	else
	  /* unlock to allow user modification */
	  SendMessage (PostEdit->hWndEdit, EM_SETREADONLY, FALSE, 0L);
d1362 5
a1366 5
	cptr = "Posting Failed";
	mbcode = MB_OK | MB_ICONEXCLAMATION;
	MessageBox (PostEdit->hWnd, CommLineIn + 4, cptr, mbcode);
	/* let 'em fix the post! */
	SendMessage (PostEdit->hWndEdit, EM_SETREADONLY, FALSE, 0L);
d1368 2
a1369 2
	done = TRUE;
	nextBatchIndex = 0;	/* cancel any batch */
d1371 2
a1372 2
	if (Attaching && !ReviewAttach)
	  ProcessAttach (ABORT);/* cancel attachment */
d1376 17
a1392 17
	cptr = "Article Posted OK";
	mbcode = MB_OKCANCEL;
	/*      if (MessageBox(hPostEdit,CommLineIn+4,cptr,mbcode) */
	/*           == ID_OK) */
	if (!Attaching || (Attaching && ReviewAttach)) {
	  if (PostLog) {
	    char *mbuf;
	    mbuf = GetEditText (PostEdit->hWndEdit);
	    WriteEditLog (PostEdit->hWnd, PostLogFile, mbuf,
			  (unsigned int) SendMessage (PostEdit->hWndEdit,
						  WM_GETTEXTLENGTH, 0, 0L));
	    GlobalFreePtr (mbuf);
	  }
	  PostEdit->dirty = DT_CLEAN;
	  DestroyWindow (PostEdit->hWnd);
	}
	done = TRUE;
d1395 1
a1395 1
	break;
d1398 3
a1400 3
	CommBusy = FALSE;
	CommState = ST_NONE;
	PostEdit = (WndEdit *) NULL;
d1402 2
a1403 2
	if (nextBatchIndex)	/* if we're sending a batch, send the next */
	  BatchSend (DOCTYPE_POSTING);
d1406 1
a1406 1
	ProcessAttach (CONTINUE);
d1463 1
a1463 1
	*(cdest++) = ' ';
d1487 1
a1487 1
	      &(CommDoc->AddOffset), &(CommDoc->AddLineID));
d1506 1
a1506 1
				GroupPtr + RangeOffset (GroupPtr->NameLen));
d1511 1
a1511 1
	ArtNum <= (unsigned long) RangePtr->Last) {
d1636 1
a1636 1
	    CommDoc->ParentLineID, &BlockPtr, &LinePtr);
d1653 1
a1653 1
		       sizeof (TypLine) + sizeof (TypGroup));
d1667 1
a1667 1
	      CommDoc->ParentLineID, &BlockPtr, &LinePtr);
d1677 2
a1678 2
	   ((i > 0) && ((header_elt (headers, i))->Seen == FALSE));
	   i--);
d1745 1
a1745 1
    strcpy (tempName, fileName);	/* no path given.  done */
d1764 1
a1764 1
    strcpy (tempName, fileName);	/* no path given.  done */
d1863 1
a1863 1
  *size = cf.iPointSize / 10;	/* iPointSize is in tenths of a point */
d1896 1
a1896 1
		"Sorry", MB_OK | MB_ICONINFORMATION);
d1927 1
a1927 1
    if (iMessage == fileNameMsg) {	/* Trap the FILEOKSTRING msg */
d1931 1
a1931 1
	return TRUE;
d1934 1
a1934 1
  return FALSE;			/* Allow standard processing */
d1993 1
a1993 1
    chReplace = filters[len - 1];	/* grab separator */
d1997 1
a1997 1
	filters[i] = '\0';
d2053 2
a2054 2
	 (retcode = VerifyFileName (fileName)) == FAIL ||
	 (hWriteFile = OpenFile ((char far *) fileName, &outFileStruct, OF_EXIST)) >= 0) {
d2059 1
a2059 1
			    MB_YESNO | MB_DEFBUTTON2 | MB_ICONQUESTION);
d2061 1
a2061 1
	break;
d2103 1
a2103 1
    beg++;			/* skip to after path slash */
d2106 1
a2106 1
    if (strlen (beg) <= 8)	/* no extension */
d2112 1
a2112 1
  beg = ptr + 1;		/* multiple extensions */
d2116 1
a2116 1
  if (strlen (beg) > 3)		/* extension too long */
d2171 1
a2171 1
    editDS = hInst;		/* use local heap instead */
d2177 1
a2177 1
    UnlockSegment (HIWORD ((LONG) lpPtr));	/* we still have a global lock */
d2181 4
a2184 4
	       WS_CHILD | WS_VISIBLE | WS_HSCROLL | WS_VSCROLL | WS_BORDER |
		   ES_LEFT | ES_MULTILINE | ES_AUTOHSCROLL | ES_AUTOVSCROLL,
				   0, 0, 0, 0,
			 NewWnd->hWnd, (HMENU) EDITID, (HINSTANCE) HIWORD ((LONG) lpPtr), NULL);
d2187 4
a2190 4
	       WS_CHILD | WS_VISIBLE | WS_HSCROLL | WS_VSCROLL | WS_BORDER |
		   ES_LEFT | ES_MULTILINE | ES_AUTOHSCROLL | ES_AUTOVSCROLL,
				   0, 0, 0, 0,
				   NewWnd->hWnd, (HMENU) EDITID, hInst, NULL);	/* No problems with Win32 */
d2351 2
a2352 2
		  "Please wait until en/decoding is complete",
		  "Cannot close status window", MB_OK | MB_ICONSTOP);
d2386 1
a2386 1
  if (thisSend == 0) {		/* find first in batch (if any) */
d2389 1
a2389 1
	break;
d2391 1
a2391 1
	thisSend++;
d2394 1
a2394 1
      return;			/* no open windows.  cancel */
d2405 1
a2405 1
    nextBatchIndex = 0;		/* no more */
d2424 3
a2426 3
		"Sorry, I am already busy communicating with the server.\n"
		"Try again in a little while.", msg,
		MB_OK | MB_ICONASTERISK);
d2438 3
a2440 3
	     "Sorry, I can only handle one en/decoding session at a time.\n"
		"Try again in a little while.", msg,
		MB_OK | MB_ICONASTERISK);
@



1.64
log
@bug fixes to message attachments
@
text
@d2 1
a2 1
 * $Id: wvutil.c 1.63 1994/08/05 21:33:22 finken Exp $
d9 1
d427 1
a427 1
	    if (DialogBox (hInst, "WinVnComm", hWndConf, lpfnWinVnCommDlg)
d583 1
a583 1
	  DlgStatus = DialogBox (hInst, "THRESHOLD", CommDoc->hDocWnd, lpfnWinVnThresholdDlg);
d2173 1
a2173 1
  NewWnd->hWndEdit = CreateWindow ("edit", (char *) NULL,
d2177 1
a2177 1
			 NewWnd->hWnd, EDITID, HIWORD ((LONG) lpPtr), NULL);
d2183 1
a2183 1
				   NewWnd->hWnd, EDITID, hInst, NULL);	/* No problems with Win32 */
d2281 1
a2281 1
      SendMessage (WndPosts[i].hWndEdit, WM_SETFONT, hFontArtNormal, TRUE);
d2288 1
a2288 1
      SendMessage (WndMails[i].hWndEdit, WM_SETFONT, hFontArtNormal, TRUE);
@



1.63
log
@Fixed problem with estimated number of articles in a group getting
zeroed after a cancel from the dialog box.
@
text
@d2 1
a2 1
 * $Id: wvutil.c 1.62 1994/08/04 06:30:36 dumoulin Exp finken $
d1246 1
a1246 1
	  SendMessage (currentCoded->hParentWnd, IDM_RETRIEVE_COMPLETE, 0, 0);
d1250 4
a1253 1
	  SendMessage (CommDoc->ParentDoc->hDocWnd, IDM_RETRIEVE_COMPLETE, 0, 0);
d1325 1
a1325 1
	  ProcessAttach (0);
d1337 1
a1337 1
	  ProcessAttach (1);	/* cancel attachment */
d1364 1
a1364 1
	  ProcessAttach (1);	/* cancel attachment */
d1398 1
a1398 1
	ProcessAttach (0);
d1676 1
@



1.62
log
@Fixed bug with improper cleanup if Cancel selected from threshold
dialog box.
@
text
@d2 1
a2 1
 * $Id: wvutil.c 1.61 1994/07/27 21:34:22 pearse_w_r Exp dumoulin $
d584 2
a585 1
             {
d590 1
a590 1
	      GroupDoc->ServerEstNum = 0;
@



1.61
log
@reindent
@
text
@d2 1
a2 1
 * $Id: wvutil.c 1.59 1994/07/27 20:08:57 rushing Exp pearse_w_r $
d393 1
d581 12
a592 1
	  DialogBox (hInst, "THRESHOLD", CommDoc->hDocWnd, lpfnWinVnThresholdDlg);
@



1.60
log
@more showunreadonly stuff
@
text
@d418 1
a418 1
      if (retcode == 200 || retcode == 201) { /* was 500 from induced error */
d494 1
a494 1
      if (retcode == 412 && !force_xhdr) /* 412 == 'not in a newsgroup' */
d569 6
a574 6
      
      sscanf(CommLineIn,"%u %lu %ld %ld %s", &retcode,&estnum,&first,&last,group);
      
      LockLine(CommDoc->hParentBlock,CommDoc->ParentOffset,
	       CommDoc->ParentLineID,&BlockPtr,&LinePtr);
      GroupDoc = ((TypGroup far *) ((char far *) LinePtr + sizeof(TypLine)));
d576 1
a576 1
      
d582 15
a596 3
	    && ((last - arts_to_retrieve) > first))
	  {
	    first = (last - arts_to_retrieve) + 1;
d598 1
a598 2
	else
	  if (arts_to_retrieve == -1) /* they clicked 'all of them' */
d600 1
a600 18
	/* added by jlg */
	  else
	    if ((arts_to_retrieve == -2) /* they clicked 'unread' */
		|| (ShowUnreadOnly))   
	      {
		if (GroupDoc->nRanges)
		  {
		    first = RangePtr[0].Last + 1;
		    arts_to_retrieve = (int) ((last - first) + 1);
		    if (arts_to_retrieve < 50)
		      {
			arts_to_retrieve = 50;
			first = last - 49;
		      }
		  }
		else
		  arts_to_retrieve = (int) estnum;
	      }
d616 1
a616 1
      
d623 1
a623 1
			(long) (arts_to_retrieve)) + sizeof (thread_array *));
d801 1
a801 1
      total_xhdrs = threadp ? 6 : 4; /* we do this here to allow */
d911 1
a911 1
			       (header_elt (headers, CommDoc->ActiveLines))->number,
d982 1
a982 1
			       (header_elt (headers, CommDoc->ActiveLines))->number,
d1115 1
a1115 1
			       (header_elt (headers, CommDoc->ActiveLines))->number,
d1121 1
a1121 1
		      HEADER_MESSAGE_ID_LENGTH); /* bad, hardcoded. */
d1166 1
a1166 1
				 (header_elt (headers, CommDoc->ActiveLines))->number,
d1221 1
a1221 2
      if (IsBlankStr (CommLineIn)) /* headers end in blank line */

d1227 1
a1227 1
      if (strcmp (CommLineIn, ".") == 0) { /* article receive complete */
a1291 1

d1362 1
a1362 1
						      WM_GETTEXTLENGTH, 0, 0L));
a1378 1

d1902 1
a1902 3
    if (iMessage == fileNameMsg)	/* Trap the FILEOKSTRING msg */

    {
d2156 2
a2157 2
	 WS_CHILD | WS_VISIBLE | WS_HSCROLL | WS_VSCROLL | WS_BORDER |
	    ES_LEFT | ES_MULTILINE | ES_AUTOHSCROLL  | ES_AUTOVSCROLL,
d2162 2
a2163 2
	 WS_CHILD | WS_VISIBLE | WS_HSCROLL | WS_VSCROLL | WS_BORDER |
	    ES_LEFT | ES_MULTILINE | ES_AUTOHSCROLL | ES_AUTOVSCROLL,
d2361 1
a2361 3
  if (thisSend == 0)		/* find first in batch (if any) */

  {
@



1.59
log
@removed word wrap <sigh>
@
text
@d2 1
a2 1
 * $Id: wvutil.c 1.58 1994/07/25 23:32:16 rushing Exp rushing $
d406 3
a408 3
  // CommDoc is !NULL if retrieving group list, article headers or articles
  // CommDecoding is true if retrieving article in decode mode (not to a doc)
  // PostEdit !NULL if we are posting (this is from an edit, no doc involved)
d418 1
a418 1
      if (retcode == 200 || retcode == 201) {	/* was 500 from induced error */
d446 2
a447 2
/*      MRRCloseComm (); */
/*        PostQuitMessage (0); */
d494 1
a494 1
      if (retcode == 412 && !force_xhdr)	/* 412 == 'not in a newsgroup' */
d569 6
a574 7

      sscanf (CommLineIn, "%u %lu %ld %ld %s",
	      &retcode, &estnum, &first, &last, group);

      LockLine (CommDoc->hParentBlock, CommDoc->ParentOffset,
		CommDoc->ParentLineID, &BlockPtr, &LinePtr);
      GroupDoc = ((TypGroup far *) ((char far *) LinePtr + sizeof (TypLine)));
d576 1
a576 1

d579 35
a613 3
	arts_to_retrieve = (unsigned int) estnum;
	if (!DialogBox (hInst, "THRESHOLD", CommDoc->hDocWnd, lpfnWinVnThresholdDlg)) {
	  // they clicked cancel.  abort it
a620 32

	if ((arts_to_retrieve > 0) && ((last - arts_to_retrieve) > first)) {
	  first = (last - arts_to_retrieve) + 1;
	}
	else if (arts_to_retrieve == -1)	/* they clicked 'all of them' */
	  arts_to_retrieve = (int) estnum;
	// added by jlg
	else if ((arts_to_retrieve == -2)
		 || (ShowUnreadOnly)) {		/* they clicked 'unread' */
	  if (GroupDoc->nRanges) {
	    first = RangePtr[0].Last + 1;
	    arts_to_retrieve = (int) ((last - first) + 1);
	    if (arts_to_retrieve < 50) {
	      arts_to_retrieve = 50;
	      first = last - 49;
	    }
	  }
	  else
	    arts_to_retrieve = (int) estnum;
	}
      }
      else if (estnum > 0)
	arts_to_retrieve = (int) estnum;
      else {
	MessageBox (hWndConf, "Empty Newsgroup", "WinVN", MB_OK | MB_ICONHAND);
	/* abort the fledgling group window */
	DestroyWindow (CommDoc->hDocWnd);
	CommBusy = FALSE;
	CommState = ST_NONE;
	GroupDoc->ServerFirst = GroupDoc->ServerLast;
	GroupDoc->ServerEstNum = 0;
	return;
d622 1
a622 1

d629 1
a629 1
		      (long) (arts_to_retrieve)) + sizeof (thread_array *));
d807 1
a807 1
      total_xhdrs = threadp ? 6 : 4;	/* we do this here to allow */
d917 1
a917 1
		       (header_elt (headers, CommDoc->ActiveLines))->number,
d988 1
a988 1
		       (header_elt (headers, CommDoc->ActiveLines))->number,
d1032 2
a1033 2
	char far *refer;	// , far * end,far * bracket1,far *bracket2;
	//      int bracket_len;
d1121 1
a1121 1
		       (header_elt (headers, CommDoc->ActiveLines))->number,
d1127 1
a1127 1
		      HEADER_MESSAGE_ID_LENGTH);	/* bad, hardcoded. */
d1172 1
a1172 1
		       (header_elt (headers, CommDoc->ActiveLines))->number,
d1219 1
a1219 1
//      Bossanova = FALSE;
d1224 1
a1224 1
	;			// error: empty article (end in middle of header)
d1227 1
a1227 1
      if (IsBlankStr (CommLineIn))	// headers end in blank line
d1234 1
a1234 1
      if (strcmp (CommLineIn, ".") == 0) {	// article receive complete
d1298 1
a1298 1
      else			// not finished, continue article receive
d1306 2
a1307 2
//      WndPost = getWndEdit(WndPosts,CommWnd,MAXPOSTWNDS) ;
      //      found = (WndPost != NULL) ;
d1309 1
a1309 1
      // lock out changes
d1329 1
a1329 1
	  ProcessAttach (1);	// cancel attachment
d1332 1
a1332 1
	  // unlock to allow user modification
d1339 2
a1340 2
//      WndPost = getWndEdit(WndPosts,CommWnd,MAXPOSTWNDS) ;
      //      found = (WndPost != NULL) ;
d1353 1
a1353 1
	nextBatchIndex = 0;	// cancel any batch
d1356 1
a1356 1
	  ProcessAttach (1);	// cancel attachment
d1362 2
a1363 2
//      if (MessageBox(hPostEdit,CommLineIn+4,cptr,mbcode)
	//           == ID_OK)
d1370 1
a1370 1
						  WM_GETTEXTLENGTH, 0, 0L));
d1386 1
a1386 1
	if (nextBatchIndex)	// if we're sending a batch, send the next
d1601 1
a1601 1
//  HANDLE hBlock;
d1691 1
a1691 1
  //MessageBox(0,"getWndEditFound Nothing","mrb debug", MB_OK | MB_ICONHAND);
d1817 4
a1820 4
  // convert points to logical units (1 pt = 1/72 inch)
  // For printer fonts, use ScreenYPixels here anyway - the choosefont
  // dialog appears to require the lfHeight to be in screen units
  // we will convert point size to PrinterUnits in InitPrinterFonts()
d1841 2
a1842 2
//      if (!stricmp (style, "Printer"))      // commented out JD 6/17/94
  //         ReleaseDC (hWndConf, hDC); 
d1844 2
a1845 2
//      if (!stricmp (style, "Printer"))
  //         DeletePrinterDC (hDC);
d1847 1
a1847 1
  *size = cf.iPointSize / 10;	// iPointSize is in tenths of a point
d1874 2
a1875 2
  // until we figure out how to deal with dithered colors, force
  // the color to the nearest physical color
d1911 1
a1911 1
    if (iMessage == fileNameMsg)	// Trap the FILEOKSTRING msg
d1914 2
a1915 2
      // if it exists and its a directory, then bypass default 
      // OK processing
d1920 1
a1920 1
  return FALSE;			// Allow standard processing
d1934 1
a1934 1
//      Open dialog to ask user for a new file name
d1951 1
a1951 1
  // Register the FILEOKSTRING message
d1953 1
a1953 1
  // Pass the FILEOKSTRING message ID in LOWORD of lCustData field
d1960 1
a1960 1
//      FreeProcInstance(&ofn.lpfnHook);
d1966 1
a1966 1
//      Set up filters
d1979 1
a1979 1
    chReplace = filters[len - 1];	// grab separator
d2000 1
a2000 1
//      Open dialog to ask user for a new file name
d2042 1
a2042 1
//      File name ok, but file exists.  Ask user if ok to wipe it
d2050 1
a2050 1
//      Open dialog to ask user for a new file name
d2157 1
a2157 1
    editDS = hInst;		// use local heap instead
d2163 1
a2163 1
    UnlockSegment (HIWORD ((LONG) lpPtr));	// we still have a global lock
d2176 1
a2176 1
				   NewWnd->hWnd, EDITID, hInst, NULL);	// No problems with Win32
d2332 2
a2333 2
  // destroying a coding status text is like popping from a stack
  // so we just loop while the top of the stack still exists
d2372 1
a2372 1
  if (thisSend == 0)		// find first in batch (if any)
d2382 1
a2382 1
      return;			// no open windows.  cancel
d2387 1
a2387 1
  // find next in batch (if any)
d2393 1
a2393 1
    nextBatchIndex = 0;		// no more
d2400 1
@



1.58
log
@oops.  left of a paren.
@
text
@d2 1
a2 1
 * $Id: wvutil.c 1.57 1994/07/25 22:39:06 rushing Exp $
d2122 1
a2122 1
  SendMessage (hWndEdit, EM_FMTLINES, TRUE, 0);
d2168 2
a2169 2
	 WS_CHILD | WS_VISIBLE | /* WS_HSCROLL | */ WS_VSCROLL | WS_BORDER |
	    ES_LEFT | ES_MULTILINE | /* ES_AUTOHSCROLL  | */ ES_AUTOVSCROLL,
d2174 2
a2175 2
	 WS_CHILD | WS_VISIBLE | /* WS_HSCROLL | */ WS_VSCROLL | WS_BORDER |
	    ES_LEFT | ES_MULTILINE | /* ES_AUTOHSCROLL  | */ ES_AUTOVSCROLL,
@



1.57
log
@unreadonly option from pearse, and reindented.
@
text
@d2 1
a2 1
 * $Id: wvutil.c 1.56 1994/07/25 18:51:48 jcooper Exp $
d598 1
a598 1
		 || (ShowUnreadOnly) {		/* they clicked 'unread' */
@



1.56
log
@execution of decoded files
@
text
@d2 1
a2 1
 * $Id: wvutil.c 1.55 1994/06/30 16:34:44 dumoulin Exp $
d10 2
a11 2
#include <commdlg.h>	// for GetOpenFileName dialog (JSC)
#include <windowsx.h>	// for GlobalFreePtr (JSC)
d17 1
a17 1
#include <dos.h>	// _dos_getfileattr
d19 3
a21 3
char far *mylstrcpy(char_p ptr1, char far *ptr2);
char * get_xhdr_line (char * line);
time_t parse_usenet_date (char * date);
d45 18
a62 17
GetNum(ptr,num)
char **ptr;
long int *num;
{
   BOOL gotit = FALSE;

   /* Skip initial spaces                                            */

   while((**ptr) && **ptr == ' ') (*ptr)++;

   *num = 0;
   while(**ptr && isdigit(**ptr)) {
      *num = 10*(*num) + (**ptr - '0');
      gotit = TRUE;
      (*ptr)++;
   }
   return(gotit);
d65 2
a66 1
char * get_xhdr_line (char *line)
d68 1
a68 1
  char * cptr;
d70 2
a71 2
  for(cptr=line; isdigit(*cptr); cptr++);
  for(;*cptr == ' ';cptr++);
d77 2
a78 1
void make_neat_from (char far *in, char far *out)
d80 1
a80 1
  char far * left, far *right;
d91 1
a91 1
    else                        /* No name in parens */
d94 2
a95 2
  else                          /* !FullNameFrom */
    strcpy (out,in);
d105 2
a106 2
StrToRGB(cstring)
char *cstring;
d108 2
a109 2
   BYTE red, green, blue;
   long int lred, lgreen, lblue;
d111 8
a118 6
   GetNum(&cstring,&lred);
   cstring++;
   GetNum(&cstring,&lgreen);
   cstring++;
   GetNum(&cstring,&lblue);
   red = (BYTE) lred; green = (BYTE) lgreen; blue = (BYTE) lblue;
d120 1
a120 1
   return(RGB(red,green,blue));
d129 2
a130 1
char *RGBToStr(char *buf, DWORD rgbVal)
d132 4
a135 4
	sprintf (buf, "%u,%u,%u", GetRValue (rgbVal),
				  GetGValue (rgbVal),
				  GetBValue (rgbVal));
	return (buf);
d141 1
a141 1
parse_usenet_date(char * s)
d145 1
a145 1
  int dom = 0, yr = 0, hr = 0, mn = 0, sc = 0, mth=0 ;
d148 6
a153 3
  if (!s || !*s) return(0);
  if (cp = strchr(s,',')) s = ++cp;
  while (isspace(*s)) s++;
d155 22
a176 13
  if (isdigit(*s)) {
    sscanf(s,"%d %s %d %d:%d:%d",&dom,mon,&yr,&hr,&mn,&sc);
    if (yr < 100 ) yr += 1900;
    }
  else sscanf(s,"%*s %s %d %d:%d:%d %d",mon,&dom,&hr,&mn,&sc,&yr);

  if (!dom || !yr || !*(cp = mon)) return(0);
  if ((dom <= 0) || (dom >= 32)) return(0);
  if ((yr < 1980) || (yr > 2020)) return(0);
  if (strlen(mon) > 10) return(0);
  if ((hr < 0) || (hr > 23)) return(0);
  if ((mn < 0) || (mn > 59)) return(0);
  if ((sc < 0) || (sc > 59)) return(0);
d178 2
a179 2
  for (cp=mon; *cp; cp++)
    *cp=tolower(*cp);
d181 2
a182 1
  if (cp=strstr(fmtMonthTable,mon)) mth=(cp-fmtMonthTable)/3;
d185 1
a185 1
    time (seconds since midnight, Jan 1, 1970    JD 06/25/93 */
d187 6
a192 6
    datetime.tm_year = yr - 1900;
    datetime.tm_mon = mth;
    datetime.tm_mday = dom;
    datetime.tm_hour = hr;
    datetime.tm_min = mn;
    datetime.tm_sec = sc;
d194 1
a194 1
    return (mktime(&datetime));
d199 1
a199 2
StringDate(char * s,time_t time)

d202 2
a203 3
  if (time != 0)
    {
     datetime = localtime(&time);
d205 2
a206 8
     if (fmtDaysB4Mth)
      {
       sprintf(s,"%02d%s%02d",datetime->tm_mday,fmtDateDelim,datetime->tm_mon+1);
      } else
       {
   sprintf(s,"%02d%s%02d",datetime->tm_mon+1,fmtDateDelim,datetime->tm_mday);
       }
    return(s);
d208 5
d214 1
a214 1
    return("-----");
d222 1
a222 1
DoCommInput()
d224 1
a224 1
   int ch;
d226 14
a239 11
   while((CommState != ST_CLOSED_COMM) && ((ch = MRRReadComm()) >= 0)) {
      if(ch == IgnoreCommCh) {
      } else if(ch == EOLCommCh) {
    *CommLinePtr = '\0';
    DoCommState();
    CommLinePtr = CommLineIn;
      } else {
    *(CommLinePtr++) = (char) ch;
    if(CommLinePtr == CommLineLWAp1) CommLinePtr--;
      }
   }
d244 3
a246 3
          char * group_name,
          unsigned long line_number,
          unsigned long total_lines)
d254 1
a254 1
  	prevPercent = 0;
d256 1
a256 1
  if ((line_number%UPDATE_TITLE_FREQ) == 0) {
d258 4
a261 5
    if (newPercent != prevPercent && newPercent-prevPercent > 1)
    {
    	sprintf (title, "Retrieving headers for '%s' : %d%%", group_name, newPercent);
        SetWindowText(hwnd,title);
        prevPercent = newPercent;
d266 2
a267 1
int check_server_code (int retcode)
d298 10
a307 9
  Normally XREF returns lists of the same length for each header type
  but some servers have errors that could cause these lists to get
  out of sync. This function tries to find the proper location in the
  headers array and returns that location.  If the article number isn't
  found, it returns -1.  JD 6/19/93 */

long sync_artnum (unsigned long artnum,
        unsigned long activenum,
        header_p headers,TypGroup far * GroupDoc)
d310 19
a328 23
  if (artnum == activenum) return(headerloc);
   else
     if (artnum < activenum)
       {
   while((artnum != activenum) && (headerloc > 0))
   {
    headerloc--;
    if ((header_elt(headers,headerloc))->number == artnum)
      return(headerloc);
   }
   return(-1);
       }
     else
       {
   while ((artnum != activenum) && (headerloc <= GroupDoc->total_headers))
   {
    headerloc++;
    if ((header_elt(headers,headerloc))->number == artnum)
      return(headerloc);
   }
   return(-1);
       }
 }
d331 1
a331 1
get_best_reference (char * refer)
d333 2
a334 2
  char * bracket1, * bracket2;
  char * end = refer + strlen(refer) - 1; /* points to NULL */
d340 1
a340 1
    if ((bracket_len < 30) && (!strrchr(bracket1,'>'))) {
d344 1
a344 1
   bracket_len = 0;
d346 3
a348 3
   bracket2 = strrchr (refer, '>');
   if (bracket2)
     bracket_len = (int) (bracket2 - bracket1) + 1;
d360 2
a361 2
  if ((bracket1+bracket_len) < end)
    *(bracket1+bracket_len) = (char) NULL;
d377 1
a377 1
DoCommState()
d379 1
a379 1
  static BOOL dialog_active=FALSE;
d388 1
a388 1
  long int first,last,syncnum;
d392 1
a392 1
  BOOL done=FALSE;
d403 1
a403 1
  TypGroup far * GroupDoc;
d409 1
a409 1
  if(CommDoc || CommDecoding || PostEdit) {
d411 1
a411 1
    switch(CommState) {
d416 26
a441 23
      if(!sscanf(CommLineIn,"%u",&retcode)) break;
      if(retcode == 200 || retcode == 201) { /* was 500 from induced error */
        CommBusy = TRUE;
        do_authinfo = FALSE;
        if(strlen(NNTPUserName)) {
          /* We have the AUTHINFO username.  Do we have the password?*/
          if(!strlen(NNTPPasswordEncrypted)) {
            /* Get the news server user password from the user */
            if (DialogBox (hInst, "WinVnComm", hWndConf, lpfnWinVnCommDlg)
               && strlen(NNTPPasswordEncrypted)) {
              do_authinfo = TRUE;
            }
          } else {
            do_authinfo = TRUE;
          }
        }
        if(do_authinfo) {
          sprintf(mybuf,"AUTHINFO user %s",NNTPUserName);
          CommState = ST_CHECK_AUTHINFO_USERNAME;
          PutCommLine(mybuf);
        } else {
          goto End_Authinfo;
        }
d443 3
a445 2
      } else {
        MessageBox (hWndConf, CommLineIn, "Access Problem", MB_OK);
d456 6
a461 5
      sscanf(CommLineIn,"%u",&retcode);
      if(!retcode) break;
      if(retcode >= 500) {
        MessageBox (hWndConf, "Error authorizing your username with the News Server.", "WinVN", MB_OK | MB_ICONHAND);
        goto End_Authinfo;
d463 2
a464 2
      MRRDecrypt(NNTPPasswordEncrypted,(unsigned char *)mybuf2,MAXINTERNALLINE);
      sprintf(mybuf,"AUTHINFO pass %s",mybuf2);
d466 1
a466 1
      PutCommLine(mybuf);
d469 3
a471 2
   case ST_CHECK_AUTHINFO_PASSWORD:
      if(dialog_active)break;
d473 7
a479 6
      if(sscanf(CommLineIn,"%u",&retcode) <= 0) break;
      if(retcode < 200 || retcode > 299) {
        dialog_active = TRUE;
        sprintf(mybuf,"Error authorizing your password with the News Server:\n%s.",CommLineIn);
        MessageBox (hWndConf,mybuf , "WinVN", MB_OK | MB_ICONHAND);
        dialog_active = FALSE;
d485 1
a485 1
  End_Authinfo:;
d493 2
a494 2
      sscanf(CommLineIn, "%u", &retcode);
      if (retcode == 412 && !force_xhdr) /* 412 == 'not in a newsgroup' */
d496 2
a497 2
      else                      /* 500 == 'command not understood' */
        xoverp = 0;
d500 1
a500 1
      if(dolist == ID_DOLIST_ASK-ID_DOLIST_BASE)
d502 2
a503 2
		"Request LIST from server?", MB_ICONQUESTION|MB_YESNO|MB_DEFBUTTON2) == IDNO)
	   dolist = 0;
d505 3
a507 8
      if(dolist) {
        StartList();
        did_list = 1;
      } else {
        did_list = 0;
        CommState = ST_NONE;
        CommBusy = FALSE;
        Initializing = INIT_READY;
d509 7
a515 1
      InvalidateRect(hWndConf,NULL,FALSE);
d518 1
a518 1
     case ST_LIST_RESP:
d520 4
a523 4
      sscanf(CommLineIn,"%u",&retcode);
      if(retcode != 215) {
   check_server_code (retcode);
   break;
d531 10
a540 9
      if(strcmp(CommLineIn,".") == 0) {
   CommState = ST_NONE;
   CommBusy = FALSE;
   Initializing = INIT_READY;
   InvalidateRect(hWndConf,NULL,FALSE);

   ProcEndList();
      } else {
   ProcListLine((unsigned char *)CommLineIn);
d546 1
a546 1
      sscanf(CommLineIn,"%u",&retcode);
d549 7
a555 7
   MessageBox (hWndConf, "No Such Newsgroup", "Error", MB_OK | MB_ICONHAND);
   /* abort the fledgling group window */
   DestroyWindow (CommDoc->hDocWnd);
   CommBusy = FALSE;
   CommState = ST_NONE;
   return;
   break;
d557 7
a563 7
   MessageBox (hWndConf, "Restricted Access", "WinVN", MB_OK | MB_ICONHAND);
   /* abort the fledgling group window */
   DestroyWindow (CommDoc->hDocWnd);
   CommBusy = FALSE;
   CommState = ST_NONE;
   return;
   break;
d565 3
a567 2
   if (check_server_code(retcode)) return;
   break;
d570 2
a571 2
      sscanf(CommLineIn,"%u %lu %ld %ld %s",
        &retcode,&estnum,&first,&last,group);
d573 3
a575 3
      LockLine(CommDoc->hParentBlock,CommDoc->ParentOffset,
          CommDoc->ParentLineID,&BlockPtr,&LinePtr);
      GroupDoc = ((TypGroup far *) ((char far *) LinePtr + sizeof(TypLine)));
d580 30
a609 33
        arts_to_retrieve = (unsigned int)estnum;
        if (!DialogBox (hInst, "THRESHOLD", CommDoc->hDocWnd, lpfnWinVnThresholdDlg))
        {
          // they clicked cancel.  abort it
          DestroyWindow (CommDoc->hDocWnd);
          CommBusy = FALSE;
          CommState = ST_NONE;
          GroupDoc->ServerFirst = GroupDoc->ServerLast;
          GroupDoc->ServerEstNum = 0;
          return;
        }
   
   if ((arts_to_retrieve > 0) && ((last - arts_to_retrieve) > first)) {
     first = (last - arts_to_retrieve) + 1;
   }
   else
     if (arts_to_retrieve == -1) /* they clicked 'all of them' */
       arts_to_retrieve = (int) estnum;
                  // added by jlg
                  else
                     if (arts_to_retrieve == -2) /* they clicked 'unread' */
                     {
                      if (GroupDoc->nRanges) {
                         first = RangePtr[0].Last + 1;
                         arts_to_retrieve = (int) ((last - first) + 1);
                         if (arts_to_retrieve < 50) {
                           arts_to_retrieve = 50;
                           first = last - 49;
                           }
                         }
                      else
                         arts_to_retrieve = (int) estnum;
                     }
d612 1
a612 1
   arts_to_retrieve = (int) estnum;
d614 8
a621 8
   MessageBox (hWndConf, "Empty Newsgroup", "WinVN", MB_OK | MB_ICONHAND);
   /* abort the fledgling group window */
   DestroyWindow (CommDoc->hDocWnd);
   CommBusy = FALSE;
   CommState = ST_NONE;
   GroupDoc->ServerFirst = GroupDoc->ServerLast;
   GroupDoc->ServerEstNum = 0;
   return;
d626 10
a635 11
      if (arts_to_retrieve > 0)
   {
     header_handle =
       GlobalAlloc (GMEM_MOVEABLE, (long)
          ((sizeof (TypHeader)) *
           (long)(arts_to_retrieve)) + sizeof (thread_array *));

     /* allocate space for the header_array index table */
     thread_handle =
       GlobalAlloc (GMEM_MOVEABLE,
          (long) ((sizeof (long)) * (long) (arts_to_retrieve)));
d637 2
a638 2
     GroupDoc->header_handle = header_handle;
     GroupDoc->thread_handle = thread_handle;
d640 1
a640 1
   }
d645 1
a645 1
      GroupDoc = (TypGroup far *) ((char far *) LinePtr + sizeof(TypLine));
d650 1
a650 1
      GlobalUnlock(BlockPtr->hCurBlock);
d653 3
a655 3
   mylen = sprintf (mybuf, "XOVER %ld-%ld", first, last);
   CommState = ST_XOVER_START;
   PutCommLine(mybuf);
d658 3
a660 3
   mylen = sprintf(mybuf,"XHDR from %ld-%ld",first,last);
   CommState = ST_XHDR_FROM_START;
   PutCommLine(mybuf);
d678 4
a681 4
      sscanf(CommLineIn,"%d",&retcode);
      if(retcode == 224) {
        CommState = ST_XOVER_DATA;
        CommDoc->ActiveLines = 0;
d684 3
a686 3
      	mylen = sprintf(mybuf,"XHDR from %ld-%ld",first,last);
        CommState = ST_XHDR_FROM_START;
        PutCommLine(mybuf);
d691 6
a696 6
      if(strcmp(CommLineIn,".") == 0) {
   /* this is a yuck way to do this */
   CommState = ST_IN_GROUP;
   CommBusy = FALSE;
   finish_header_retrieval (CommDoc);
   InvalidateRect(CommDoc->hDocWnd,NULL,FALSE);
d699 14
a712 2
   char * this_hop, * next_hop;
   char * reference;
d714 75
a788 86
   LockLine(CommDoc->hParentBlock,CommDoc->ParentOffset,
       CommDoc->ParentLineID,&BlockPtr,&LinePtr);
   GroupDoc = ((TypGroup far *) ((char far *) LinePtr + sizeof(TypLine)));
   header_handle = GroupDoc->header_handle;
   thread_handle = GroupDoc->thread_handle;

   GlobalUnlock(BlockPtr->hCurBlock);

   /* Lock the header data */
   headers = lock_headers (header_handle, thread_handle);
   header = header_elt (headers, CommDoc->ActiveLines);

   this_hop=CommLineIn;

   /* article number */
   next_hop = strchr (this_hop, '\t');
   *(next_hop++) = (char) NULL;

   header->number = atol (this_hop);

   /* subject */
   this_hop = next_hop;
   next_hop = strchr (this_hop, '\t');
   *(next_hop++) = (char) NULL;

   mylstrncpy (header->subject, this_hop, HEADER_SUBJECT_LENGTH);
   CommDoc->LongestLine = max(CommDoc->LongestLine,
                              ARTICLE_SUBJECT_OFFSET + 
                                (unsigned)lstrlen(header->subject) );
   /* author */
   this_hop = next_hop;
   next_hop = strchr (this_hop, '\t');
   *(next_hop++) = (char) NULL;

   ParseAddress (this_hop,
            AddressString,MAXDIALOGSTRING,
            NameString,MAXDIALOGSTRING ) ;

   if (FullNameFrom)
     mylstrncpy (header->from, NameString, HEADER_FROM_LENGTH);
   else
     mylstrncpy (header->from, this_hop, HEADER_FROM_LENGTH);

   /* date */
   this_hop = next_hop;
   next_hop = strchr (this_hop, '\t');
   *(next_hop++) = (char) NULL;

   header->date = parse_usenet_date (this_hop);

   /* message-id */
   this_hop = next_hop;
   next_hop = strchr (this_hop, '\t');
   *(next_hop++) = (char) NULL;

   mylstrncpy (header->message_id, this_hop, HEADER_MESSAGE_ID_LENGTH);

   /* references */
   this_hop = next_hop;
   next_hop = strchr (this_hop, '\t');
   *(next_hop++) = (char) NULL;

   reference = get_best_reference (this_hop);
   if (reference) mylstrncpy (header->references, reference, HEADER_REFERENCES_LENGTH);

   /* bytes (ignored) */
   this_hop = next_hop;
   next_hop = strchr (this_hop, '\t');
   *(next_hop++) = (char) NULL;

   /* lines (last one doesn't have to have the tab */
   this_hop = next_hop;
   header->lines = atoi (this_hop);

   /* set other header fields */
   header->Selected= FALSE ;
   header->ArtDoc  = (TypDoc *) NULL;
   header->Seen = WasArtSeen (header->number,GroupDoc);

   unlock_headers (header_handle, thread_handle);

   CommDoc->ActiveLines++;

   update_window_title (CommDoc->hDocWnd, group,
              RcvLineCount++,
              CommDoc->TotalLines);
d807 5
a811 4
      sscanf(CommLineIn,"%d",&retcode);
      total_xhdrs = threadp ? 6 : 4; /* we do this here to allow */
                 /* mid-session change-of-mind  */
      if(retcode < 100) break;
d817 17
a833 17
      if(strcmp(CommLineIn,".") == 0) {
   LockLine(CommDoc->hParentBlock, CommDoc->ParentOffset,
       CommDoc->ParentLineID, &BlockPtr,&LinePtr);

   GroupDoc = ((TypGroup far *) ((char far *) LinePtr + sizeof(TypLine)) );
   GroupDoc->total_headers = CommDoc->ActiveLines;

   first = GroupDoc->ServerFirst;
   last = GroupDoc->ServerLast;

   GlobalUnlock(BlockPtr->hCurBlock);
   CommDoc->ActiveLines = 0;

   /* Now ask for the date lines */
   mylen = sprintf(mybuf,"XHDR date %ld-%ld",first,last);
   CommState = ST_XHDR_DATE_START;
   PutCommLine(mybuf);
d836 36
a871 36
   /*      char neat_from [80]; */
   /* Access the Group struct, get HANDLE for header data */
   LockLine(CommDoc->hParentBlock,CommDoc->ParentOffset,
       CommDoc->ParentLineID,&BlockPtr,&LinePtr);

   GroupDoc = ((TypGroup far *) ((char far *) LinePtr + sizeof(TypLine)) );
   header_handle = GroupDoc->header_handle;
   thread_handle = GroupDoc->thread_handle;

   GlobalUnlock(BlockPtr->hCurBlock);

   /* Lock the header data */
   headers = lock_headers (header_handle, thread_handle);

   sscanf (CommLineIn, "%ld", &artnum);
   header = header_elt (headers, CommDoc->ActiveLines);
   header->number = artnum;

   /* now use some of our nice formatting of email addresses */
   ParseAddress (get_xhdr_line (CommLineIn),
            AddressString,MAXDIALOGSTRING,
            NameString,MAXDIALOGSTRING ) ;

   /* copy that into headers[].from */
   if (FullNameFrom)
     mylstrncpy (header->from, NameString,HEADER_FROM_LENGTH);
   else
     mylstrncpy (header->from, AddressString,HEADER_FROM_LENGTH);

   unlock_headers (header_handle, thread_handle);

   CommDoc->ActiveLines++;

   update_window_title (CommDoc->hDocWnd, group,
              RcvLineCount++,
              CommDoc->TotalLines * total_xhdrs);
d878 3
a880 2
      sscanf(CommLineIn,"%d",&retcode);
      if (check_server_code(retcode)) break;
d886 17
a902 17
      if(strcmp(CommLineIn,".") == 0) {
   LockLine(CommDoc->hParentBlock,CommDoc->ParentOffset,
       CommDoc->ParentLineID,&BlockPtr,&LinePtr);

   GroupDoc = ((TypGroup far *) ((char far *) LinePtr + sizeof(TypLine)) );
   GroupDoc->total_headers = CommDoc->ActiveLines;

   first = GroupDoc->ServerFirst;
   last = GroupDoc->ServerLast;

   GlobalUnlock(BlockPtr->hCurBlock);
   CommDoc->ActiveLines = 0;

   /* Now ask for the #of lines */
   mylen = sprintf(mybuf,"XHDR lines %ld-%ld",first,last);
   CommState = ST_XHDR_LINES_START;
   PutCommLine(mybuf);
d906 25
a930 21
   /* Access the Group struct, get HANDLE for header data */
   LockLine(CommDoc->hParentBlock,CommDoc->ParentOffset,
       CommDoc->ParentLineID,&BlockPtr,&LinePtr);
   GroupDoc = ((TypGroup far *)((char far *)LinePtr+sizeof(TypLine)));
   header_handle = GroupDoc->header_handle;
   thread_handle = GroupDoc->thread_handle;

   GlobalUnlock(BlockPtr->hCurBlock);

   /* Lock the header data */
   headers = lock_headers (header_handle, thread_handle);
   syncnum = sync_artnum(atol (CommLineIn),(header_elt(headers,CommDoc->ActiveLines))->number,headers,GroupDoc);
   if (syncnum >= 0)
     (header_elt(headers,syncnum))->date = parse_usenet_date (get_xhdr_line (CommLineIn));

   unlock_headers (header_handle, thread_handle);

   CommDoc->ActiveLines++;
   update_window_title (CommDoc->hDocWnd, group,
              RcvLineCount++,
              CommDoc->TotalLines * total_xhdrs);
d937 3
a939 2
      sscanf(CommLineIn,"%d",&retcode);
      if (check_server_code(retcode)) break;
d945 26
a970 26
      if(strcmp(CommLineIn,".") == 0) {
   LockLine(CommDoc->hParentBlock,CommDoc->ParentOffset,
       CommDoc->ParentLineID,&BlockPtr,&LinePtr);

   GroupDoc = ((TypGroup far *) ((char far *) LinePtr + sizeof(TypLine)) );
   GroupDoc->total_headers = CommDoc->ActiveLines;

   first = GroupDoc->ServerFirst;
   last = GroupDoc->ServerLast;

   GlobalUnlock(BlockPtr->hCurBlock);
   CommDoc->ActiveLines = 0;

   /* Check for threading option, if enabled, go to REF & ID */
   /* states first */

   if (threadp) {
     CommState = ST_XHDR_REF_START;
     mylen = sprintf(mybuf,"XHDR references %ld-%ld",first,last);
     PutCommLine(mybuf);
   }
   else {
     CommState = ST_XHDR_SUBJECT_START;
     mylen = sprintf(mybuf,"XHDR subject %ld-%ld",first,last);
     PutCommLine(mybuf);
   }
d975 25
a999 22
   /* Access the Group struct, get HANDLE for header data */
   LockLine(CommDoc->hParentBlock,CommDoc->ParentOffset,
       CommDoc->ParentLineID,&BlockPtr,&LinePtr);
   GroupDoc = ((TypGroup far *) ((char far *) LinePtr + sizeof(TypLine)));

   header_handle = GroupDoc->header_handle;
   thread_handle = GroupDoc->thread_handle;

   GlobalUnlock(BlockPtr->hCurBlock);

   /* Lock the header data */
   headers = lock_headers (header_handle, thread_handle);

   syncnum = sync_artnum(atol (CommLineIn),(header_elt(headers,CommDoc->ActiveLines))->number,headers,GroupDoc);
   if (syncnum >= 0)
      sscanf (CommLineIn, "%ld %Fd", &artnum,&((header_elt(headers,syncnum))->lines));

   unlock_headers (header_handle, thread_handle);
   CommDoc->ActiveLines++;
   update_window_title (CommDoc->hDocWnd, group,
              RcvLineCount++,
              CommDoc->TotalLines * total_xhdrs);
d1006 3
a1008 2
      sscanf(CommLineIn,"%d",&retcode);
      if (check_server_code(retcode)) break;
d1014 17
a1030 17
      if(strcmp(CommLineIn,".") == 0) {
   LockLine(CommDoc->hParentBlock,CommDoc->ParentOffset,
       CommDoc->ParentLineID,&BlockPtr,&LinePtr);

   GroupDoc = (TypGroup far *) ((char far *) LinePtr + sizeof(TypLine));
   GroupDoc->total_headers = CommDoc->ActiveLines;

   first = GroupDoc->ServerFirst;
   last = GroupDoc->ServerLast;

   GlobalUnlock(BlockPtr->hCurBlock);
   CommDoc->ActiveLines = 0;

   /* Now ask for the message-id lines */
   mylen = sprintf(mybuf,"XHDR message-id %ld-%ld",first,last);
   CommState = ST_XHDR_MID_START;
   PutCommLine(mybuf);
d1033 31
a1063 2
   char far * refer;    // , far * end,far * bracket1,far *bracket2;
//      int bracket_len;
d1065 6
a1070 36
   /* Access the Group struct, get HANDLE for header data */
   LockLine(CommDoc->hParentBlock,CommDoc->ParentOffset,
       CommDoc->ParentLineID,&BlockPtr,&LinePtr);
   GroupDoc = ((TypGroup far *) ((char far *) LinePtr + sizeof(TypLine)));

   header_handle = GroupDoc->header_handle;
   thread_handle = GroupDoc->thread_handle;

   GlobalUnlock(BlockPtr->hCurBlock);

   /* Lock the header data */
   headers = lock_headers (header_handle, thread_handle);

   /* for now, we only pay attention to first (whole) referral */
   refer = get_xhdr_line(CommLineIn);

   refer = get_best_reference (refer);

   if (refer)
     {
      /* Patch to check for bad info from server JD 6/19/93 */
     syncnum = sync_artnum(atol (CommLineIn),
            (header_elt(headers,
                   CommDoc->ActiveLines))->number,
            headers,GroupDoc);
     if (syncnum >= 0)
            mylstrncpy ((header_elt (headers,syncnum))->references,
         refer,HEADER_REFERENCES_LENGTH);
     }

   unlock_headers (header_handle, thread_handle);

   CommDoc->ActiveLines++;
   update_window_title (CommDoc->hDocWnd, group,
              RcvLineCount++,
              CommDoc->TotalLines * total_xhdrs);
d1079 3
a1081 2
      sscanf(CommLineIn,"%d",&retcode);
      if (check_server_code(retcode)) break;
d1087 3
a1089 3
      if(strcmp(CommLineIn,".") == 0) {
   LockLine(CommDoc->hParentBlock,CommDoc->ParentOffset,
       CommDoc->ParentLineID,&BlockPtr,&LinePtr);
d1091 1
a1091 1
   GroupDoc = (TypGroup far *) ((char far *) LinePtr + sizeof(TypLine));
d1093 1
a1093 1
   GroupDoc->total_headers = CommDoc->ActiveLines;
d1095 2
a1096 2
   first = GroupDoc->ServerFirst;
   last = GroupDoc->ServerLast;
d1098 2
a1099 2
   GlobalUnlock(BlockPtr->hCurBlock);
   CommDoc->ActiveLines = 0;
d1101 4
a1104 4
   /* Now ask for the subject lines */
   mylen = sprintf(mybuf,"XHDR subject %ld-%ld",first,last);
   CommState = ST_XHDR_SUBJECT_START;
   PutCommLine(mybuf);
d1107 3
a1109 3
   /* Access the Group struct, get HANDLE for header data */
   LockLine(CommDoc->hParentBlock,CommDoc->ParentOffset,
       CommDoc->ParentLineID,&BlockPtr,&LinePtr);
d1111 1
a1111 1
   GroupDoc = (TypGroup far *) ((char far *) LinePtr + sizeof(TypLine));
d1113 2
a1114 2
   header_handle = GroupDoc->header_handle;
   thread_handle = GroupDoc->thread_handle;
d1116 1
a1116 1
   GlobalUnlock(BlockPtr->hCurBlock);
d1118 2
a1119 2
   /* Lock the header data */
   headers = lock_headers (header_handle, thread_handle);
d1121 8
a1128 5
   syncnum = sync_artnum(atol (CommLineIn),(header_elt(headers,CommDoc->ActiveLines))->number,headers,GroupDoc);
   if (syncnum >= 0)
     mylstrncpy((header_elt (headers,syncnum))->message_id,
           (char far *) (get_xhdr_line (CommLineIn)),
           HEADER_MESSAGE_ID_LENGTH);         /* bad, hardcoded. */
d1130 1
a1130 1
   unlock_headers (header_handle, thread_handle);
d1132 4
a1135 4
   CommDoc->ActiveLines++;
   update_window_title (CommDoc->hDocWnd, group,
              RcvLineCount++,
              CommDoc->TotalLines * total_xhdrs);
d1144 3
a1146 2
      sscanf(CommLineIn,"%d",&retcode);
      if (check_server_code(retcode)) break;
d1152 5
a1156 5
      if(strcmp(CommLineIn,".") == 0) {
   CommState = ST_IN_GROUP;
   CommBusy = FALSE;
   finish_header_retrieval (CommDoc);
   InvalidateRect(CommDoc->hDocWnd,NULL,FALSE);
d1160 42
a1201 39
   artnum = 0;
   sscanf(CommLineIn,"%ld",&artnum);
   if(artnum) {
     LockLine(CommDoc->hParentBlock,CommDoc->ParentOffset,
         CommDoc->ParentLineID,&BlockPtr,&LinePtr);

     GroupDoc = ((TypGroup far *) ((char far *) LinePtr + sizeof(TypLine)));
     header_handle = GroupDoc->header_handle;
     thread_handle = GroupDoc->thread_handle;
     headers = lock_headers (header_handle, thread_handle);

     /* update the seen thing. */
     syncnum = sync_artnum(atol (CommLineIn),(header_elt(headers,CommDoc->ActiveLines))->number,headers,GroupDoc);
     if (syncnum >= 0)
        header = header_elt (headers, syncnum);
     else
        header = header_elt (headers, CommDoc->ActiveLines);

     header->Selected= FALSE ;
     header->ArtDoc  = (TypDoc *) NULL;
     header->Seen =
       WasArtSeen (artnum,(TypGroup far *)( ((char far *)LinePtr) +
                  sizeof(TypLine) ) );

     UnlockLine(BlockPtr,LinePtr,&(CommDoc->hParentBlock),
           &(CommDoc->ParentOffset),&(CommDoc->ParentLineID));

     mylstrncpy(header->subject,
           get_xhdr_line (CommLineIn), HEADER_SUBJECT_LENGTH);

     CommDoc->LongestLine = max(CommDoc->LongestLine,
                                ARTICLE_SUBJECT_OFFSET + 
                                (unsigned)lstrlen(header->subject));

     unlock_headers (header_handle, thread_handle);
     CommDoc->ActiveLines++;
     update_window_title (CommDoc->hDocWnd, group,
                RcvLineCount++,
                CommDoc->TotalLines * total_xhdrs);
d1203 1
a1203 1
   }
d1213 5
a1217 6
      sscanf(CommLineIn,"%d",&retcode);
      if (check_server_code(retcode))
      {
        if (CommDoc->hDocWnd)
           DestroyWindow (CommDoc->hDocWnd);
      	break;
d1224 3
a1226 2
      if(strcmp(CommLineIn,".") == 0) {
	; // error: empty article (end in middle of header)
d1228 3
a1230 14
      if (IsBlankStr (CommLineIn))  	// headers end in blank line
         CommState = ST_REC_ARTICLE;
/*      else if (!strnicmp (CommLineIn, "MIME-Version:"))
      {
         Bossanova = TRUE;
         // add line to doc or eat it?
         // instantiate new MIME object
         PushMIME (InitMIMEObject());
         AddCommLineToDoc (CommLineIn);
         continue;
      }
      if (Bossanova)
         ProcessMIME (CommLineIn)
*/
d1235 1
a1235 10
      if(strcmp(CommLineIn,".") == 0) {		// article receive complete
        CommState = ST_IN_GROUP;
        CommBusy = FALSE;

	if (CommDecoding)
       	{
       	  SendMessage(currentCoded->hParentWnd, IDM_RETRIEVE_COMPLETE, 0, 0);
 	  break;
	} else
	  SendMessage(CommDoc->ParentDoc->hDocWnd, IDM_RETRIEVE_COMPLETE, 0, 0);
d1237 10
d1260 5
a1264 5
	mylstrncpy(group,lpsz,MAXGROUPNAME);
	sprintf(mybuf,"%s (%u lines)",group,CommDoc->TotalLines);
	SetWindowText(CommDoc->hDocWnd,mybuf);
	InvalidateRect(CommDoc->hDocWnd,NULL,FALSE);
	GlobalUnlock(BlockPtr->hCurBlock);
d1274 1
a1274 1
	TopOfDoc(CommDoc,&BlockPtr,&LinePtr);
d1277 2
a1278 2
  	  lpsz = ((char far *)LinePtr + sizeof(TypLine) + sizeof(TypText));
	  if(IsLineBlank(lpsz)) {
d1280 1
a1280 1
	    CommDoc->HeaderLines=WhatLine (BlockPtr, LinePtr);
d1283 13
a1295 11
	  if(!NextLine(&BlockPtr,&LinePtr)) break;
	} while(!found);
	NextLine(&BlockPtr,&LinePtr);

        /* If the line is in the last screen's worth of lines, back
         * up the pointer so it points to the first line of the last
         * screen.
         */
	if(found && CommDoc->TotalLines > CommDoc->ScYLines &&
	   !CommDoc->TopScLineID)
          AdjustTopSc(BlockPtr,LinePtr);
d1297 1
a1297 1
        UnlockLine(BlockPtr,LinePtr,&hBlock,&Offset,&MyLineID);
d1299 3
a1301 2
      else	// not finished, continue article receive
        AddCommLineToDoc (CommLineIn);
d1308 1
a1308 1
//      found = (WndPost != NULL) ;
d1311 1
a1311 1
      SendMessage(PostEdit->hWndEdit, EM_SETREADONLY, TRUE, 0L);
d1314 1
a1314 1
      sscanf(CommLineIn,"%u",&retcode);
d1316 19
a1334 17
      if(retcode == 340) {
        if (Attaching && !ReviewAttach)
        	ProcessAttach (0);
        else
           PostText(PostEdit);
      } else {
        check_server_code (retcode);
        MessageBox(PostEdit->hWnd,CommLineIn+4,"Cannot Post Article",
                   MB_OK|MB_ICONEXCLAMATION);
        CommBusy = FALSE;
        CommState = ST_NONE;

        if (Attaching && !ReviewAttach)
        	ProcessAttach (1);		// cancel attachment
		 else
        // unlock to allow user modification
	        SendMessage(PostEdit->hWndEdit, EM_SETREADONLY, FALSE, 0L);
d1341 1
a1341 1
//      found = (WndPost != NULL) ;
d1343 1
a1343 1
 /* no check for failure to find posting documents */
d1345 18
a1362 15
      sscanf(CommLineIn,"%d",&retcode);
      if(retcode == 441 || retcode == 440) {
   cptr = "Posting Failed";
   mbcode = MB_OK|MB_ICONEXCLAMATION;
   MessageBox(PostEdit->hWnd,CommLineIn+4,cptr,mbcode);
   /* let 'em fix the post! */
   SendMessage(PostEdit->hWndEdit, EM_SETREADONLY, FALSE, 0L);

   done = TRUE;
   nextBatchIndex = 0;	// cancel any batch
   if (Attaching && !ReviewAttach)
    	ProcessAttach (1);	// cancel attachment
   } else if(retcode == 240) {
   cptr = "Article Posted OK";
   mbcode = MB_OKCANCEL;
d1364 12
a1375 10
//           == ID_OK)
   if (!Attaching || (Attaching && ReviewAttach))
   {
	if (PostLog)
	{
	   char *mbuf ;
	   mbuf = GetEditText (PostEdit->hWndEdit);
	   WriteEditLog(PostEdit->hWnd,PostLogFile,mbuf,
	               (unsigned int) SendMessage (PostEdit->hWndEdit, WM_GETTEXTLENGTH, 0, 0L)) ;
	   GlobalFreePtr (mbuf);
d1377 1
a1377 14
	PostEdit->dirty=DT_CLEAN ;
	DestroyWindow(PostEdit->hWnd) ;
   }
   done = TRUE;
  } else
   if (check_server_code (retcode)) break;

      if(done) {
        CommBusy = FALSE;
        CommState = ST_NONE;
        PostEdit = (WndEdit *) NULL;

        if (nextBatchIndex)	// if we're sending a batch, send the next
          BatchSend (DOCTYPE_POSTING);
d1379 2
a1380 3
      if (Attaching && !ReviewAttach)
        ProcessAttach (0);
      break;
d1382 4
a1385 1
      /* the following code is for an MRR-hacked nntp server */
d1387 1
a1387 3
/* Code not used anywhere
         M Bretherton 14 June 1993
#if 0
d1389 1
a1389 9
    case ST_MAIL_WAIT_PERMISSION:
      for(ih=0,found=FALSE; !found && ih<MAXMAILWNDS; ih++) {
   if( WndMails[ih].hWnd) == CommWnd) {

     hWndPost = WndMails[ih];

     found = TRUE;
     break;
   }
d1391 2
a1392 13
      retcode = 0;
      sscanf(CommLineIn,"%d",&retcode);
      if(retcode <= 0) {
   break;
      } else if(retcode == 350) {
   PostText(ih,DOCTYPE_MAIL);
      } else {
   MessageBox(WndPost->hWnd,CommLineIn+4,"Cannot Mail Message",
         MB_OK|MB_ICONEXCLAMATION);
   CommBusy = FALSE;
   CommState = ST_NONE;
      }

d1395 1
a1395 32
    case ST_POST_WAIT_END:
      for(ih=0,found=FALSE; !found && ih<MAXPOSTWNDS; ih++) {
   if(WbdPosts[ih].hWnd) == CommWnd) {

     WndPost = WndPosts[ih];

     found = TRUE;
     break;
   }
      }
      retcode = 0;
      sscanf(CommLineIn,"%d",&retcode);
      if(retcode == 441 || retcode == 440) {
   cptr = "Posting Failed";
   mbcode = MB_OK|MB_ICONEXCLAMATION;
   MessageBox(WndPost->hWnd,CommLineIn+4,cptr,mbcode);
   done = TRUE;
      } else if(retcode == 240) {
   cptr = "Article Posted OK";
   mbcode = MB_OKCANCEL;
//      if (MessageBox(WndPost->hWnd,CommLineIn+4,cptr,mbcode)
//           == ID_OK)
   DestroyWindow(WndPost->hWnd) ;
   done = TRUE;
      } else
   if (check_server_code (retcode)) break;

      if(done) {
   CommBusy = FALSE;
   CommState = ST_NONE;
      }
      break;
a1396 2
#endif
*/
d1405 1
a1405 1
isLineQuotation(char *textptr)
d1407 7
a1413 5
   char *loc ;
   loc = memchr(textptr,QuoteLineInd,2);
   if (!loc) loc = memchr(textptr,'|',2);
   if (!loc) loc = memchr(textptr,':',2);
   return(loc!=NULL) ;
d1424 11
a1434 11
	TypLine far *LinePtr;
	TypBlock far *BlockPtr;
	char *cptr, *cdest;
	int col, mylen;
	char artline[MAXINTERNALLINE];

	/* special case for lines starting with '..' */
	if (strncmp (CommLineIn, "..", 2))
	  cptr = CommLineIn;
	else
	  cptr = CommLineIn + 1;
d1436 23
a1458 22
	if (CommDecoding)
	{
	  DecodeLine (currentCoded, cptr);
 	  return;
 	}
	/* Copy this line into an image of a textblock line,
	 * expanding tabs.
	 */
	cdest = artline+sizeof(TypLine)+sizeof(TypText);
	for(col=0;
	    *cptr && col<(MAXINTERNALLINE-3*sizeof(TypLine)-sizeof(TypText));
	    cptr++) {
	  if(*cptr == '\t') {
	    do {
	      *(cdest++) = ' ';
	    } while (++col & 7);
	  } else {
	    *(cdest++) = *cptr;
	    col++;
	  }
	}
	*(cdest++) = '\0';
d1460 14
a1473 14
	((TypLine *)artline)->LineID = NextLineID++;
	LockLine(CommDoc->hCurAddBlock,CommDoc->AddOffset,CommDoc->AddLineID,&BlockPtr,&LinePtr);
	mylen = (cdest-artline) + sizeof(int);
	mylen += mylen%2;
	((TypText *)(artline+sizeof(TypLine)))->NameLen =
  	(cdest-1) - (artline+sizeof(TypLine)+sizeof(TypText));
	((TypLine *)artline)->length = mylen;
	((TypLine *)artline)->active = TRUE;
	*( (int *) (artline+mylen-sizeof(int)) ) = mylen;
	AddLine((TypLine *)artline,&BlockPtr,&LinePtr);
	CommDoc->LongestLine = max(CommDoc->LongestLine,(unsigned)mylen);
	CommDoc->ActiveLines++;
	UnlockLine(BlockPtr,LinePtr,&(CommDoc->hCurAddBlock),
		   &(CommDoc->AddOffset),&(CommDoc->AddLineID));
d1475 2
a1476 2
	if ((CommDoc->TotalLines % UPDATE_ART_FREQ) == 0)
	  InvalidateRect(CommDoc->hDocWnd,NULL,FALSE);
d1487 18
a1504 17
WasArtSeen(ArtNum,GroupPtr)
unsigned long ArtNum;
TypGroup far *GroupPtr;
{
   TypRange far *RangePtr = (TypRange far *) ((char far *)
      GroupPtr + RangeOffset(GroupPtr->NameLen));
   unsigned int nr;

   for(nr=0; nr < GroupPtr->nRanges; nr++) {
      if(ArtNum >= (unsigned long) RangePtr->First &&
	 ArtNum <= (unsigned long) RangePtr->Last) {
    return(TRUE);
      } else {
    RangePtr++;
      }
   }
   return(FALSE);
d1513 14
a1526 13
mylstrncmp(ptr1,ptr2,len)
char far *ptr1;
char far *ptr2;
int len;
{
   for(;len--;ptr1++,ptr2++) {
      if(*ptr1 > *ptr2) {
    return(1);
      } else if(*ptr1 < *ptr2) {
    return(-1);
      }
   }
   return(0);
d1534 12
a1545 12
mylstrncpy(ptr1,ptr2,len)
char far *ptr1;
char far *ptr2;
int len;
{
   char far *targ = ptr1;

   for(; --len && *ptr2; ptr1++,ptr2++) {
      *ptr1 = *ptr2;
   }
   *ptr1 = '\0';
   return(targ);
d1551 2
a1552 2
char_p ptr1;
char far *ptr2;
d1556 1
a1556 1
     *ptr1 = *ptr2;
d1569 23
a1591 20
lstrcmpnoblank(str1,str2)
char far **str1;
char far **str2;
{
   register char far *s1=*str1, far *s2=*str2;

   for(;*s1 && *s2 && *s1!=' ' && *s2!=' '; s1++,s2++) {
      if(*s1 > *s2) {
         return (1);
      } else if(*s1 < *s2) {
         return (-1);
      }
   }
   if(*s1 == *s2) {
      return(0);
   } else if(*s1) {
      return(1);
   } else {
      return(-1);
   }
d1600 1
a1600 1
  TypGroup far * GroupDoc;
d1603 1
a1603 1
  char far * lpsz;
d1617 1
a1617 1
  /* CommDoc->ActiveLines = 0;*/
d1621 2
a1622 2
  LockLine(CommDoc->hParentBlock,CommDoc->ParentOffset,
      CommDoc->ParentLineID,&BlockPtr,&LinePtr);
d1624 1
a1624 1
  GroupDoc = ((TypGroup far *) ((char far *) LinePtr + sizeof(TypLine)));
d1638 2
a1639 2
  lpsz = (char far *) ( ((char far *)LinePtr) +
             sizeof(TypLine)+ sizeof(TypGroup) ) ;
d1641 3
a1643 3
  mylstrncpy(group,lpsz,MAXGROUPNAME);
  sprintf(mybuf,"%s (%u articles)",group,CommDoc->TotalLines);
  SetWindowText(CommDoc->hDocWnd,mybuf);
d1652 2
a1653 2
    LockLine(CommDoc->hParentBlock,CommDoc->ParentOffset,
        CommDoc->ParentLineID,&BlockPtr,&LinePtr);
d1656 1
a1656 1
    GroupDoc = ((TypGroup far *) ((char far *) LinePtr + sizeof(TypLine)));
d1661 1
a1661 1
    if (CommDoc->TotalLines >0)
d1663 2
a1664 2
       ((i > 0) && ((header_elt(headers,i))->Seen == FALSE));
       i--) ;
d1670 1
a1670 1
  InvalidateRect(CommDoc->hDocWnd,NULL,FALSE);
d1681 2
a1682 1
WndEdit * getWndEdit(WndEdit * WndEdits,HWND hWnd,int numEntries)
d1684 1
a1684 1
  int ih ;
d1686 3
a1688 6
  for(ih=0; ih<numEntries; ih++)
    {
      if(WndEdits[ih].hWnd == hWnd)
   {
     return & WndEdits[ih] ;
   }
d1690 1
d1694 1
a1694 1
  return(WndEdit *) NULL ;
d1708 1
a1708 1
	char *theDot;
d1710 4
a1713 4
	if ((theDot = strrchr (fileName, '.')) == NULL)
	   *tempName = '\0';
	else
	   strcpy (tempName, &fileName[theDot - fileName + 1]);
d1715 1
a1715 1
	return (tempName);
d1727 1
a1727 1
	char *lastSlash;
d1729 4
a1732 4
	if ((lastSlash = strrchr (fileName, '\\')) == NULL)
	   strcpy (tempName, fileName);		/* no path given.  done */
	else
	   strcpy (tempName, &fileName[lastSlash - fileName + 1]);
d1734 1
a1734 1
	return (tempName);
d1746 1
a1746 1
	char *lastSlash;
d1748 7
a1754 8
	if ((lastSlash = strrchr (fileName, '\\')) == NULL)
	   strcpy (tempName, fileName);               /* no path given.  done */
	else
	{
	   strncpy (tempName, fileName, lastSlash - fileName);
	   tempName[lastSlash - fileName] = '\0';
	}
	return (tempName);
d1764 1
a1764 1
	register int i;
d1766 2
a1767 2
	for (i = strlen(str)-1; i > 0 && isspace (str[i]); i--)
		str[i] = '\0';
d1778 1
a1778 1
	register char *ptr;
d1780 4
a1783 4
	for (ptr = temp; *ptr; ptr++)
		if (!isspace(*ptr))
			return (FALSE);
	return (TRUE);
d1794 1
a1794 1
	char *ptr;
d1796 4
a1799 4
	for (ptr = str; *ptr != '\0'; ptr++)
		if (!isdigit (*ptr) && (ptr != str || !strchr ("+-", *ptr)))
			return (FALSE);
	return (TRUE);
d1803 5
a1807 5
 *	Open the common font dialog
 *	Place resulting selection name and size in face,style and size
 *	Note: to select a printer font, send style as "Printer"
 *	printer font selection ignores any chosen style
 *	(JSC 1/9/94)
d1812 35
a1846 31
	LOGFONT lf;
	CHOOSEFONT cf;
	HDC hDC;

	memset(&lf, 0, sizeof(LOGFONT));
	strcpy (lf.lfFaceName, face);
	// convert points to logical units (1 pt = 1/72 inch)
	// For printer fonts, use ScreenYPixels here anyway - the choosefont
	// dialog appears to require the lfHeight to be in screen units
	// we will convert point size to PrinterUnits in InitPrinterFonts()
	lf.lfHeight = -MulDiv(*size, ScreenYPixels, 72);

	memset(&cf, 0, sizeof(CHOOSEFONT));
	cf.lStructSize = sizeof(CHOOSEFONT);
	cf.hwndOwner = hParentWnd;
	cf.lpLogFont = &lf;
	if (!stricmp (style, "Printer"))
	{
	   cf.nFontType = PRINTER_FONTTYPE;
	   hDC = GetPrinterDC (hParentWnd);
	   cf.hDC = hDC;                                                       
	   cf.Flags = CF_PRINTERFONTS|CF_INITTOLOGFONTSTRUCT|CF_FORCEFONTEXIST;
	}
	else
	{
	   cf.nFontType = SCREEN_FONTTYPE;
	   cf.Flags = CF_SCREENFONTS|CF_INITTOLOGFONTSTRUCT|CF_USESTYLE|CF_FORCEFONTEXIST;
	   cf.lpszStyle = style;
	}
	if (!ChooseFont(&cf))
		return (FAIL);
d1848 1
a1848 2
//	if (!stricmp (style, "Printer"))      // commented out JD 6/17/94
//	   ReleaseDC (hWndConf, hDC); 
d1850 2
a1851 6
// 	if (!stricmp (style, "Printer"))
//	   DeletePrinterDC (hDC);
	   
	*size = cf.iPointSize / 10;	// iPointSize is in tenths of a point
	strcpy (face, lf.lfFaceName);
	return (SUCCESS);
d1855 2
a1856 2
 *	Open the common color dialog
 *	(JSC 1/9/94)
d1859 1
a1859 1
AskForColor (HWND hParentWnd, COLORREF *color)
d1861 24
a1884 24
	CHOOSECOLOR cc;
	COLORREF nearC;
	HDC hDC;

	memset(&cc, 0, sizeof(CHOOSECOLOR));
	cc.lStructSize = sizeof(CHOOSECOLOR);
	cc.hwndOwner = hParentWnd;
	cc.rgbResult = *color;
	cc.lpCustColors = CustomColors;
	cc.Flags = CC_RGBINIT;

	if (!ChooseColor(&cc))
		return (FAIL);

	// until we figure out how to deal with dithered colors, force
	// the color to the nearest physical color
	hDC = GetDC (hParentWnd);
	nearC = GetNearestColor (hDC, cc.rgbResult);
	if (cc.rgbResult != nearC)
		MessageBox (hParentWnd, "WinVn does not currently support dithered (non-solid) colors.\nThe nearest physical solid color has been selected.",
		           "Sorry", MB_OK|MB_ICONINFORMATION);
	*color = nearC;
	ReleaseDC (hParentWnd, hDC);
	return (SUCCESS);
d1888 2
a1889 2
 *	Asks for a path - uses hook callback to allow just a path (usual
 *	behavior requires the user to enter a filename)
d1891 3
a1893 3
 *	See example MSJ Jan 93, Question&Answers (Fran Finnegan)
 *	JSC 7/17/94
 * 	don't forget to add  GETPATHHOOKPROC  to winvn.def and compile with /Gw
d1895 2
a1896 2
 * 	Damn! Doesn't work because the the OK msg is only generated if
 *	the user has entered a complete filename.  How to do this then?!
d1899 2
a1900 1
extern UINT CALLBACK GetPathHookProc (HWND hDlg, UINT iMessage, WPARAM wParam, LPARAM lParam)
d1902 21
a1922 21
	static  LPOPENFILENAME  ofn;
	static  UINT fileNameMsg;
	unsigned attrib;
	
	if (iMessage == WM_INITDIALOG)
	{
	    ofn = (LPOPENFILENAME)lParam;
	    fileNameMsg = (UINT)LOWORD((DWORD)ofn->lCustData);
	    return TRUE;
	}
	else
	{
	    if (iMessage == fileNameMsg)  // Trap the FILEOKSTRING msg
	    {
	        // if it exists and its a directory, then bypass default 
	        // OK processing
	        if (_dos_getfileattr(ofn->lpstrFile, &attrib) == 0 && (attrib&_A_SUBDIR))
	            return TRUE;
	    }
	}
	return FALSE;   // Allow standard processing
d1929 18
a1946 18
	OPENFILENAME ofn;
	char szFile[MAXFILENAME];
	char filters[MAXFILTERLEN];

	GenerateFileFilters (hParentWnd, filters);

//	Open dialog to ask user for a new file name
	memset(&ofn, 0, sizeof(OPENFILENAME));
	szFile[0] = '\0';
	ofn.lpstrTitle = title;
	ofn.lStructSize = sizeof(OPENFILENAME);
	ofn.hwndOwner = hParentWnd;
	ofn.lpstrFilter = filters;
	ofn.nFilterIndex = 1;
	ofn.lpstrFile= szFile;
	ofn.nMaxFile = sizeof(szFile);
	ofn.lpstrFileTitle = NULL;
	ofn.Flags = OFN_SHOWHELP | OFN_PATHMUSTEXIST;
d1949 7
a1955 7
	UINT fileNameMsg;
	ofn.Flags = OFN_SHOWHELP | OFN_PATHMUSTEXIST | OFN_ENABLEHOOK;
	ofn.lpfnHook = MakeProcInstance((FARPROC)GetPathHookProc, (HINSTANCE)hInst);
	// Register the FILEOKSTRING message
	fileNameMsg = RegisterWindowMessage((LPCSTR)FILEOKSTRING);
	// Pass the FILEOKSTRING message ID in LOWORD of lCustData field
	ofn.lCustData = MAKELPARAM (fileNameMsg, 0);
d1958 6
a1963 6
	if (GetOpenFileName(&ofn) == 0)
		return (FAIL);
	
//	FreeProcInstance(&ofn.lpfnHook);
	PathWithoutName (pathName, strlwr(szFile));
	return (SUCCESS);
d1967 1
a1967 1
// 	Set up filters
d1971 10
a1980 12
	register int i;
	int len;
	char chReplace;

	if ((len = LoadString(hInst, IDS_FILTERSTRING, filters, MAXFILTERLEN-1)) == 0)
	{
		MessageBox (hParentWnd, "No Filters Available", "String Load Failure", MB_OK);
		*filters = '\0';
	}
	else
	{
		chReplace = filters[len - 1];		// grab separator
d1982 4
a1985 4
		for (i = 0; filters[i] != '\0'; i++)
			if (filters[i] == chReplace)
				filters[i] = '\0';
	}
d1989 2
a1990 2
 *	Asks for a filename which must exist
 *	(JSC)
d1995 23
a2017 23
	OPENFILENAME ofn;
	char szFile[MAXFILENAME];
	char filters[MAXFILTERLEN];

	GenerateFileFilters (hParentWnd, filters);

//	Open dialog to ask user for a new file name
	memset(&ofn, 0, sizeof(OPENFILENAME));
	szFile[0] = '\0';
	ofn.lpstrTitle = title;
	ofn.lStructSize = sizeof(OPENFILENAME);
	ofn.hwndOwner = hParentWnd;
	ofn.lpstrFilter = filters;
	ofn.nFilterIndex = 1;
	ofn.lpstrFile= szFile;
	ofn.nMaxFile = sizeof(szFile);
	ofn.lpstrFileTitle = NULL;
	ofn.Flags = OFN_SHOWHELP | OFN_FILEMUSTEXIST;

	if (GetOpenFileName(&ofn) == 0)
		return (FAIL);
	strcpy (fileName, strlwr(szFile));
	return (SUCCESS);
d2020 5
a2024 5
 * 	Make sure file name is OK for DOS 8.3
 * 	Check if file name is OK for DOS.  If not, prompt user new name
 *	Check if file already exists.  If so, prompt user OK to overwrite
 *	If fileName contains a name on entry, check if it's OK, if yes-done
 *	(JSC)
d2029 41
a2069 43
	OFSTRUCT outFileStruct;
	OPENFILENAME ofn;
	HFILE 	hWriteFile;
	char mybuf[MAXINTERNALLINE];
	char szDirName[256];
	char szFile[256];
	BOOL retcode;
	char filters[MAXFILTERLEN];

	GenerateFileFilters (hParentWnd, filters);
	while (fileName[0] == '\0' ||
	      (retcode = VerifyFileName (fileName)) == FAIL ||
	      (hWriteFile = OpenFile ((char far *)fileName, &outFileStruct, OF_EXIST)) >= 0)
	{
        	if (fileName[0] != '\0' && retcode == SUCCESS)
		{
//	File name ok, but file exists.  Ask user if ok to wipe it
			sprintf (mybuf, "File %s exists.  OK to overwrite it?", fileName);
		 	retcode = MessageBox(hParentWnd, mybuf, "File exists",
				   MB_YESNO|MB_DEFBUTTON2|MB_ICONQUESTION);
			if (retcode == IDYES)
				break;
		}

//	Open dialog to ask user for a new file name
		memset(&ofn, 0, sizeof(OPENFILENAME));
		if (fileName[0] != '\0')
			sprintf (mybuf, "Invalid file name %s. Select new name", fileName);
		else
			strcpy (mybuf, "Select new file name to create/overwrite");

		ofn.lpstrTitle = mybuf;
		strcpy (szDirName, startDir);
		ofn.lpstrInitialDir = szDirName;
		ofn.lStructSize = sizeof(OPENFILENAME);
		ofn.hwndOwner = hParentWnd;
		ofn.lpstrFilter = filters;
		ofn.nFilterIndex = 1;
		szFile[0] = '\0';
		ofn.lpstrFile= szFile;
		ofn.nMaxFile = sizeof(szFile);
		ofn.lpstrFileTitle = NULL;
		ofn.Flags = OFN_SHOWHELP | OFN_PATHMUSTEXIST;
d2071 2
a2072 2
		if (GetOpenFileName(&ofn) == 0)
			return (FAIL);
d2074 3
a2076 3
		strcpy (fileName, strlwr (ofn.lpstrFile));
	}
	return (SUCCESS);
d2079 2
a2080 2
 * 	Make sure file name is OK for DOS 8.3
 *	(JSC)
d2085 1
a2085 1
	char *beg, *ptr;
d2087 4
a2090 4
	if ((beg = strrchr (fileName, '\\'))==NULL)
		beg = fileName;
	else
		beg++;			/* skip to after path slash */
d2092 3
a2094 3
	if ((ptr = strchr (beg, '.')) == NULL)
		if (strlen (beg) <= 8)	/* no extension */
			return (SUCCESS);
d2096 2
a2097 2
	if (ptr - beg > 8)
		return (FAIL);
d2099 3
a2101 3
	beg = ptr + 1;			/* multiple extensions */
	if ((ptr = strchr (beg, '.')) != NULL)
		return (FAIL);
d2103 2
a2104 2
	if (strlen (beg) > 3)		/* extension too long */
		return (FAIL);
d2106 1
a2106 1
	return (SUCCESS);
d2119 2
a2120 2
	unsigned int size;
	char *newText;
d2122 1
a2122 1
	SendMessage (hWndEdit, EM_FMTLINES, TRUE, 0);
d2124 1
a2124 1
	size = (unsigned int) SendMessage (hWndEdit, WM_GETTEXTLENGTH, 0, 0L) + 1;
d2126 8
a2133 10
	if ((newText = (char *) GlobalAllocPtr (GMEM_MOVEABLE, size*sizeof(char))) == NULL)
	{
		MessageBox (hWndEdit, "Memory allocation failure", "Edit Text", MB_OK);
		return (NULL);
	}
	if (SendMessage (hWndEdit, WM_GETTEXT, size, (LPARAM)((LPCSTR)newText)) != (long)(size-1))
	{
		MessageBox (hWndEdit, "Failed to get text", "Edit Text", MB_OK);
		return (NULL);
	}
d2135 1
a2135 1
	return (newText);
d2140 1
a2140 1
	return (SendMessage (hWndEdit, WM_SETTEXT, 0, (LPARAM)(LPCSTR)editMem));
d2151 1
a2151 1
CreateEditWnd (WndEdit *NewWnd)
d2154 18
a2171 18
      GLOBALHANDLE editDS;
      LPVOID lpPtr;
      if ((editDS = GlobalAlloc (GMEM_DDESHARE|GMEM_MOVEABLE|GMEM_ZEROINIT, 1024L)) == NULL)
      {
	MessageBox (NewWnd->hWnd, "Memory allocation failure", "Edit Buffer", MB_OK);
	editDS = hInst;		// use local heap instead
      }
      else
      {
 	lpPtr = GlobalLock (editDS);
	LocalInit (HIWORD((LONG)lpPtr), 0, (WORD)(GlobalSize (editDS) - 16));
	UnlockSegment (HIWORD((LONG)lpPtr));	// we still have a global lock
      }
      NewWnd->hWndEdit = CreateWindow ("edit", (char *) NULL,
		WS_CHILD | WS_VISIBLE | /* WS_HSCROLL | */ WS_VSCROLL | WS_BORDER |
		ES_LEFT | ES_MULTILINE | /* ES_AUTOHSCROLL  | */  ES_AUTOVSCROLL,
		0, 0, 0, 0,
		NewWnd->hWnd, EDITID, HIWORD((LONG)lpPtr), NULL);
d2173 5
a2177 5
      NewWnd->hWndEdit = CreateWindow ("edit", (char *) NULL,
		WS_CHILD | WS_VISIBLE | /* WS_HSCROLL | */ WS_VSCROLL | WS_BORDER |
		ES_LEFT | ES_MULTILINE |  /* ES_AUTOHSCROLL  | */ ES_AUTOVSCROLL,
		0, 0, 0, 0,
		NewWnd->hWnd, EDITID, hInst, NULL);		// No problems with Win32
d2179 4
a2182 5
      if (!NewWnd->hWndEdit)
      {
	MessageBox (NewWnd->hWnd, "Window creation failure", "Edit Buffer", MB_OK);
	return (FAIL);
      }
d2184 3
a2186 3
      SendMessage (NewWnd->hWndEdit, EM_LIMITTEXT, 0, 0L);
	  SetHandleBkBrush (NewWnd->hWndEdit,   hArticleBackgroundBrush);
      NewWnd->dirty = DT_CLEAN;
d2188 1
a2188 1
      return (SUCCESS);
d2191 1
a2191 1
 * 	Write an integer to the private profile
d2194 1
a2194 1
WritePrivateProfileInt (lpAppName, lpKeyName, intval,lpProFile)
d2207 2
a2208 2
 *	Write an unsigned integer to the private profile
 *	(JSC 1/8/94)
d2211 1
a2211 1
WritePrivateProfileUInt (lpAppName, lpKeyName, intval,lpProFile)
d2224 2
a2225 2
 *	Get an unsigned integer to the private profile
 *	(JSC 1/8/94)
d2228 1
a2228 1
GetPrivateProfileUInt (lpAppName, lpKeyName, intval,lpProFile)
d2239 1
a2239 1
     return (intval);
d2241 1
a2241 1
     return (atoui(buf));
d2244 4
a2247 4
 *	Refresh Window functions
 *	Called after a font/color selection has changed to affect all
 *	windows of a certain type (group/article/status)
 *	(JSC 1/9/94)
d2250 1
a2250 1
RefreshGroupWnds()
d2252 7
a2258 8
	register int i;
	for (i = 0; i < MAXGROUPWNDS; i++)
		if (GroupDocs[i].hDocWnd)
		{
			SetHandleBkBrush ( GroupDocs[i].hDocWnd, hListBackgroundBrush);
		    SendMessage (GroupDocs[i].hDocWnd, WM_SIZE, 0, 0L);
		    InvalidateRect (GroupDocs[i].hDocWnd, NULL, TRUE);
		}
d2262 1
a2262 1
RefreshArticleWnds()
d2264 8
a2271 1
	register int i;
d2273 13
a2285 23
	for (i = 0; i < MAXARTICLEWNDS; i++)
	   if (ArticleDocs[i].hDocWnd)
	   {
	    SetHandleBkBrush(ArticleDocs[i].hDocWnd, hArticleBackgroundBrush);
		SendMessage (ArticleDocs[i].hDocWnd, WM_SIZE, 0, 0L);
		InvalidateRect (ArticleDocs[i].hDocWnd, NULL, TRUE);
	   }

	for (i = 0; i < MAXPOSTWNDS; i++)
	   if (WndPosts[i].hWnd)
		{
		    SendMessage (WndPosts[i].hWndEdit, WM_SETFONT, hFontArtNormal, TRUE);
			SetHandleBkBrush (WndPosts[i].hWndEdit, hArticleBackgroundBrush);
		    InvalidateRect (WndPosts[i].hWndEdit, NULL, TRUE);
		}

	for (i = 0; i < MAXMAILWNDS; i++)
	   if (WndMails[i].hWnd)
		{
		    SendMessage (WndMails[i].hWndEdit, WM_SETFONT, hFontArtNormal, TRUE);
			SetHandleBkBrush (WndMails[i].hWndEdit, hArticleBackgroundBrush);
		    InvalidateRect (WndMails[i].hWndEdit, NULL, TRUE);
		}
d2289 1
a2289 1
RefreshStatusWnds()
d2291 1
a2291 1
	register int i;
d2293 11
a2303 13
	for (i = 0; i < numStatusTexts; i++)
		if (codingStatusText[i]->hTextWnd)
		{
			SetHandleBkBrush (codingStatusText[i]->hTextWnd, hStatusBackgroundBrush);
		    SendMessage (codingStatusText[i]->hTextWnd, WM_SIZE, 0, 0L);
		    InvalidateRect (codingStatusText[i]->hTextWnd, NULL, TRUE);
		}
	if (hCodedBlockWnd)
	{
		SetHandleBkBrush (hCodedBlockWnd, hStatusBackgroundBrush);
	    SendMessage (hCodedBlockWnd, WM_SIZE, 0, 0L);
	    InvalidateRect (hCodedBlockWnd, NULL, TRUE);
	}
d2307 4
a2310 4
 *	Close Window functions
 *	Batch operation, close all windows of a certain type
 *	(group/article/status)
 *	(JSC 1/18/94)
d2313 1
a2313 1
CloseGroupWnds()
d2315 4
a2318 4
	register int i;
	for (i = 0; i < MAXGROUPWNDS; i++)
	   if (GroupDocs[i].hDocWnd)
		SendMessage(GroupDocs[i].hDocWnd, WM_CLOSE, 0, 0L);
d2322 1
a2322 1
CloseArticleWnds()
d2324 1
a2324 1
	register int i;
d2326 3
a2328 3
	for (i = 0; i < MAXARTICLEWNDS; i++)
	   if (ArticleDocs[i].hDocWnd)
		SendMessage(ArticleDocs[i].hDocWnd, WM_CLOSE, 0, 0L);
d2331 1
a2331 1
CloseStatusWnds()
d2333 5
a2337 6
	// destroying a coding status text is like popping from a stack
	// so we just loop while the top of the stack still exists
	while (numStatusTexts > 0 && codingStatusText[0]->hTextWnd)
	    if (CodingState)
	    {
		MessageBox (codingStatusText[0]->hTextWnd,
d2339 5
a2343 5
		  "Cannot close status window", MB_OK|MB_ICONSTOP);
		break;
	    }
	    else
		SendMessage(codingStatusText[0]->hTextWnd, WM_CLOSE, 0, 0L);
d2348 7
a2354 7
 *	BatchSend
 *	type is DOCTYPE_MAIL or _POST
 *	Increments nextBatchIndex and initiates mail/post
 *	Note: on entry nextBatchIndex is the index we will use for this send
 *	on exit, nextBatchIndex is either 0 (no more to send) or the index
 *	of the next mail/post to send
 *	(JSC 1/18/94)
d2359 15
a2373 14
	int thisSend;
	int maxWnds;
	WndEdit *WndEdits;

	if (type == DOCTYPE_POSTING)
	{
	   WndEdits = WndPosts;
	   maxWnds = MAXPOSTWNDS;
	}
	else
	{
	   WndEdits = WndMails;
	   maxWnds = MAXMAILWNDS;
	}
d2375 6
a2380 8
	thisSend = nextBatchIndex;
	if (thisSend == 0)	// find first in batch (if any)
	{
		while (thisSend < maxWnds)
		   if (WndEdits[thisSend].hWnd)
			break;
		   else
		   	thisSend++;
d2382 2
a2383 2
		if (thisSend == maxWnds)
		   return;	// no open windows.  cancel
d2385 2
a2386 2
		nextBatchIndex = thisSend;
	}
d2388 4
a2391 4
	// find next in batch (if any)
        while (++nextBatchIndex < maxWnds)
 		if (WndEdits[nextBatchIndex].hWnd)
		   break;
d2393 2
a2394 2
	if (nextBatchIndex == maxWnds)
	   nextBatchIndex = 0; 		// no more
d2396 4
a2399 4
	if (type == DOCTYPE_POSTING)
	   StartPost (&WndEdits[thisSend]);
	else
	   StartMail (&WndEdits[thisSend]);
d2402 4
a2405 4
 *	Test busy functions
 *	Called to test if a comm or decoding is busy
 *	Returns true if busy, false if not busy
 *	(JSC 1/9/94)
d2410 2
a2411 3
	if (CommBusy)
 	{
 	   MessageBox (hParentWnd,
d2415 4
a2418 4
	   return (TRUE);
	}
	else
	   return (FALSE);
d2424 3
a2426 4
	if (Decoding || CommDecoding)
 	{
 	   MessageBox (hParentWnd,
		"Sorry, I can only handle one en/decoding session at a time.\n"
d2429 4
a2432 4
	   return (TRUE);
	}
	else
	   return (FALSE);
@



1.55
log
@Fix a problem with printer device context getting freed prematurely
@
text
@d2 1
a2 1
 * $Id: wvutil.c 1.54 1994/06/23 23:09:05 dumoulin Exp dumoulin $
d17 1
d23 1
d30 2
d554 12
a565 2
   DialogBox (hInst, "THRESHOLD",
         CommDoc->hDocWnd, lpfnWinVnThresholdDlg);
d1728 3
a1730 1
		return ("\0");
a1731 2
	strcpy (tempName, &fileName[theDot - fileName + 1]);

d1747 21
d1769 2
a1770 2
		strcpy (tempName, fileName);		/* no path given.  done */
		return (tempName);
a1771 2
	strcpy (tempName, &fileName[lastSlash - fileName + 1]);

d1905 1
d1907 9
a1915 2
 *	Asks for a filename which must exist
 *	(JSC)
d1917 27
d1945 1
a1945 1
AskForExistingFileName (HWND hParentWnd, char *fileName, char *title)
d1949 40
a1990 1
	char filters[512];
d1993 2
a1994 2
// 	Set up filters
	if ((len = LoadString(hInst, IDS_FILTERSTRING, filters, sizeof (filters))) == 0)
d1996 2
d2000 1
a2000 1
		chReplace = filters[len - 1];		// retrieve separator
d2006 14
d2056 1
a2056 4
	register int i;
	int len;
	char filters[512];
	char chReplace;
d2058 1
a2070 12
		}

// 	Set up filters
		if ((len = LoadString(hInst, IDS_FILTERSTRING, filters, sizeof (filters))) == 0)
			MessageBox (hParentWnd, "No Filters Available", "String Load Failure", MB_OK);
		else
		{
			chReplace = filters[len - 1];	// retrieve separator

			for (i = 0; filters[i] != '\0'; i++)
				if (filters[i] == chReplace)
					filters[i] = '\0';
@



1.54
log
@fixed error codes and changed call to GetPrinterDC to pass window handle
@
text
@d2 1
a2 1
 * $Id: wvutil.c 1.53 1994/06/17 09:09:30 dumoulin Exp dumoulin $
d1830 1
a1830 1
//	   ReleaseDC (hWndConf, hDC);
d1832 3
@



1.53
log
@Attempts to fix the Unable to Initialize Document printing bug
@
text
@d2 1
a2 1
 * $Id: wvutil.c 1.52 1994/06/09 21:47:08 rushing Exp dumoulin $
d693 2
a694 1
                              ARTICLE_SUBJECT_OFFSET + lstrlen(header->subject) );
d1139 2
a1140 1
                                ARTICLE_SUBJECT_OFFSET+lstrlen(header->subject));
d1816 1
a1816 1
	   hDC = GetPrinterDC (NULL);
@



1.52
log
@handle unexpected disconnect, and smtp mail while disconnected from nntp
@
text
@d2 1
a2 1
 * $Id: wvutil.c 1.51 1994/06/09 18:39:34 rushing Exp $
d1814 2
a1815 2
	   hDC = GetPrinterDC ();
	   cf.hDC = hDC;
d1827 2
a1828 2
	if (!stricmp (style, "Printer"))
	   ReleaseDC (hWndConf, hDC);
@



1.51
log
@word-wrap, dot-doubling, and default port numbers
@
text
@d2 1
a2 1
 * $Id: wvutil.c 1.50 1994/06/08 21:01:45 gardnerd Exp rushing $
d69 1
a69 1
#if 0  
d74 1
a74 1
  
d83 1
a83 1
    } 
d123 1
a123 1
				  GetGValue (rgbVal), 
d125 1
a125 1
	return (buf); 
d147 1
a147 1
  
d154 2
a155 2
  if ((sc < 0) || (sc > 59)) return(0);  
  
d168 1
a168 1
    datetime.tm_min = mn; 
d188 1
a188 1
       { 
d228 1
a228 1
  
d232 1
a232 1
  	
d284 1
a284 1
{ 
d334 1
a334 1
  
d339 1
a339 1
  
d423 3
a425 2
//        PostQuitMessage (0);
		Initializing = INIT_NOT_CONNECTED;
d471 1
a471 1
      
d489 1
a489 1
 
d572 1
a572 1
                     }     
d595 1
a595 1
 
d600 1
a600 1
     
d603 1
a603 1
     
d638 1
a638 1
      /* the 'threadp' variable */ 
d665 1
a665 1
   
d685 1
a685 1
   
d690 1
a690 1
   
d692 1
a692 1
   CommDoc->LongestLine = max(CommDoc->LongestLine, 
d726 1
a726 1
   
d734 1
a734 1
   
d763 1
a763 1
             
d765 1
a765 1
      /* the 'threadp' variable */ 
d801 1
a801 1
   
d860 2
a861 2
   mylen = sprintf(mybuf,"XHDR lines %ld-%ld",first,last); 
   CommState = ST_XHDR_LINES_START; 
d865 1
a865 1
   
d876 1
a876 1
   headers = lock_headers (header_handle, thread_handle); 
d917 2
a918 2
     CommState = ST_XHDR_REF_START;          
     mylen = sprintf(mybuf,"XHDR references %ld-%ld",first,last); 
d922 2
a923 2
     CommState = ST_XHDR_SUBJECT_START; 
     mylen = sprintf(mybuf,"XHDR subject %ld-%ld",first,last); 
d985 1
a985 1
//      int bracket_len; 
d1041 1
a1041 1
   
d1045 1
a1045 1
   
d1115 1
a1115 1
     thread_handle = GroupDoc->thread_handle;        
d1120 1
a1120 1
     if (syncnum >= 0) 
d1157 2
a1158 2
      if (check_server_code(retcode)) 
      { 
d1168 1
a1168 1
      if(strcmp(CommLineIn,".") == 0) {	
d1181 1
a1181 1
      } 
d1183 1
a1183 1
         ProcessMIME (CommLineIn) 
d1186 2
a1187 2
      break;      
    
d1244 1
a1244 1
	if(found && CommDoc->TotalLines > CommDoc->ScYLines && 
d1247 1
a1247 1
    
d1268 1
a1268 1
        	ProcessAttach (0);		   
d1313 1
a1313 1
	{  
d1331 1
a1331 1
        
d1435 1
a1435 1
	
d1445 1
a1445 1
 	  return;                           
d1475 1
a1475 1
	CommDoc->LongestLine = max(CommDoc->LongestLine,(unsigned)mylen); 
d1479 1
a1479 1
	
d1481 1
a1481 1
	  InvalidateRect(CommDoc->hDocWnd,NULL,FALSE);  
d1615 1
a1615 1
   * if the user desires. 
d1626 1
a1626 1
  thread_handle = GroupDoc->thread_handle;        
d1635 1
a1635 1
   
d1658 1
a1658 1
    thread_handle = GroupDoc->thread_handle;      
d1660 1
a1660 1
     
d1682 1
a1682 1
{ 
d1717 1
a1717 1
}               
d1752 1
a1752 1
		
d1762 1
a1762 1
	
d1778 1
a1778 1
	
d1798 1
a1798 1
	        
d1806 1
a1806 1
	
d1812 1
a1812 1
	{	   
d1823 1
a1823 1
	}	
d1852 1
a1852 1
	
d1858 1
a1858 1
	hDC = GetDC (hParentWnd);	
d1863 1
a1863 1
	*color = nearC;		       
d1871 1
a1871 1
BOOL 
d1882 1
a1882 1
	if ((len = LoadString(hInst, IDS_FILTERSTRING, filters, sizeof (filters))) == 0) 
d1885 1
a1885 1
	{		
d1887 1
a1887 1
	
d1895 1
a1895 1
	szFile[0] = '\0';  	
d1918 1
a1918 1
BOOL 
d1933 1
a1933 1
	while (fileName[0] == '\0' || 
d1938 1
a1938 1
		{ 
d1940 1
a1940 1
			sprintf (mybuf, "File %s exists.  OK to overwrite it?", fileName);	
d1948 1
a1948 1
		if ((len = LoadString(hInst, IDS_FILTERSTRING, filters, sizeof (filters))) == 0) 
d1951 1
a1951 1
		{		
d1953 1
a1953 1
		
d1965 1
a1965 1
	
d1981 1
a1981 1
		
d1983 1
a1983 1
	}    
d1994 1
a1994 1
	
d1999 1
a1999 1
			
d2002 2
a2003 2
			return (SUCCESS);	
	
d2006 1
a2006 1
		
d2013 1
a2013 1
	
d2015 1
a2015 1
}	
d2029 1
a2029 1
	
d2031 1
a2031 1
	
d2033 1
a2033 1
		
d2044 1
a2044 1
	
d2046 1
a2046 1
}	
d2084 2
a2085 2
		WS_CHILD | WS_VISIBLE | WS_HSCROLL | WS_VSCROLL | WS_BORDER |
		ES_LEFT | ES_MULTILINE |  ES_AUTOHSCROLL  |  ES_AUTOVSCROLL,
d2093 2
a2094 2
      }	
	
d2148 1
a2148 1
  
d2167 1
a2167 1
			SetHandleBkBrush ( GroupDocs[i].hDocWnd, hListBackgroundBrush); 
d2216 1
a2216 1
	{		
d2225 1
a2225 1
 *	Batch operation, close all windows of a certain type 
d2261 1
a2261 1
		SendMessage(codingStatusText[0]->hTextWnd, WM_CLOSE, 0, 0L);	    
d2291 1
a2291 1
	
d2298 1
a2298 1
		   else 
d2303 1
a2303 1
		   
d2314 1
a2314 1
	   
@



1.50
log
@more scrolling changes...
@
text
@d2 1
a2 1
 * $Id: wvutil.c 1.49 1994/06/06 22:06:13 gardnerd Exp $
d2029 2
d2077 2
a2078 2
		WS_CHILD | WS_VISIBLE | WS_HSCROLL | WS_VSCROLL | WS_BORDER |
		ES_LEFT | ES_MULTILINE |  ES_AUTOHSCROLL  |  ES_AUTOVSCROLL,
@



1.49
log
@horizontal scrolling support
@
text
@d2 1
a2 1
 * $Id: wvutil.c 1.48 1994/06/02 00:17:07 rushing Exp $
d692 1
a692 1
                              HEADER_SUBJECT_OFFSET + strlen(header->subject) );
d1136 2
d1474 1
@



1.48
log
@put id key back in, remove log messages
@
text
@d2 1
a2 1
 * $Id: $
d691 2
a692 1

@



1.47
log
@unnecessary winundoc.h
@
text
@d2 1
a2 143
 *
 * Revision 1.44  1994/05/19  02:02:10  rushing
 * changes for gensock & version 0.91
 *
 * Revision 1.43  1994/05/02  20:33:46  rushing
 * changes from jody glasser
 *
 * Revision 1.42  1994/03/22  22:44:24  rushing
 * handle failure of XOVER command (punt to XHDR).
 *
 * Revision 1.41  1994/02/24  21:35:41  jcoop
 * jcoop changes.
 *
 * Revision 1.40  1994/02/16  21:05:33  cnolan
 * cnolan changes to 90.3
 *
 * Revision 1.39  1994/02/16  20:59:17  rushing
 * Added .ini param to force use of XHDR over XOVER
 *
 * Revision 1.38  1994/02/09  18:01:08  cnolan
 * cnolan 90.2 changes
 *
 * Revision 1.37  1994/01/24  17:40:28  jcoop
 * 90.2 changes
 *
 * Revision 1.36  1994/01/17  21:54:16  jcoop
 * Decoder integration, lots of new utilities (fonts/colors, etc)
 *
 * Revision 1.35  1994/01/12  19:46:06  cedwards
 * fullnamefrom not working with XHDR
 * 
 * Revision 1.34  1994/01/12  19:27:55  mrr
 * mrr mods 4
 *
 * Revision 1.33  1994/01/05  22:36:05  rushing
 * off by one bug in PutCommLine ("XOVER\r", 5) fixed
 * l.
 *
 * Revision 1.32  1993/12/08  01:28:01  rushing
 * new version box and cr lf consistency
 *
 * Revision 1.31  1993/12/01  23:24:06  rushing
 * off by one on date problem shows up dec. 1.
 *
 * Revision 1.30  1993/11/24  23:07:20  rushing
 * let the user know about access trouble
 *
 * Revision 1.29  1993/11/22  20:30:50  rushing
 * handle mixed-case dates
 *
 * Revision 1.28  1993/08/25  18:53:17  mbretherton
 * MRB merge, mail & post logging
 *
 * Revision 1.27  1993/08/25  17:05:17  mbretherton
 * merge from first newsrc.zip
 *
 * Revision 1.26  1993/08/18  21:49:21  rushing
 * more 16-bit article number fixes.
 *
 * Revision 1.25  1993/08/05  20:06:07  jcoop
 * save multiple articles changes by jcoop@@oakb2s01.apl.com (John S Cooper)
 *
 * Revision 1.24  1993/07/13  16:03:04  riordan
 * MRR mods
 *
 * Revision 1.23  1993/06/28  17:52:17  rushing
 * fixed compiler warnings
 *
 * Revision 1.22  1993/06/25  20:18:51  dumoulin
 * Changed Date fields from Strings to Posix standard time format
 *
 * Revision 1.21  1993/06/22  16:43:03  bretherton
 * auto close on posting window
 *
 *
 * Revision 1.20  1993/06/22  14:04:05  dumoulin
 * Fixed problems with article numbers larger than 32K
 *
 * Revision 1.19  1993/06/19  18:40:17  dumoulin
 * Added error routines to handle unsyncd XHDRS from screwed up servers
 *
 * Revision 1.18  1993/06/15  21:16:59  rushing
 * headers-> to header-> in two lines.
 *
 * Revision 1.17  1993/06/11  00:10:35  rushing
 * second merge from Matt Bretherton sources
 *
 * Revision 1.16  1993/06/10  18:25:17  rushing
 * XOVER support.
 *
 * Revision 1.15  1993/06/08  19:42:38  rushing
 * always do the thread_index array so we can sort on other fields.
 *
 * Revision 1.14  1993/06/05  03:18:25  rushing
 * primitive functional threading.
 *
 * Revision 1.13  1993/06/01  18:22:40  rushing
 * moved header funcs to headarry.c
 *
 * Revision 1.12  1993/05/26  23:59:40  rushing
 * reimplemented positioning group window near last read article
 *
 * Revision 1.11  1993/05/24  23:56:51  rushing
 * date formatting for group list window
 * and save header size for article repaing (MRB)
 *
 * Revision 1.10  1993/05/13  19:58:09  SOMEONE
 * fancy 'from' in group window
 *
 * Revision 1.9  1993/05/13  16:16:06  rushing
 * article fetch limit support
 *
 * Revision 1.8  1993/05/08  17:11:05  rushing
 * correct handling of 4XX response codes, and
 * of NNTP data lines beginning with '.'
 *
 * Revision 1.7  1993/04/29  21:42:11  rushing
 * checked for null from parse_usenet_date on bad date.
 *
 * Revision 1.6  1993/04/29  20:24:59  rushing
 * attempted support for WSAAsyncSelect
 *
 * Revision 1.5  1993/04/27  21:03:20  rushing
 * clicking on a group that doesn't exist is correctly handled.
 * the prematurely created group window is destroyed correctly
 * after telling the user it doesn't exist.
 *
 * Revision 1.4  1993/04/23  22:10:48  rushing
 * added function check_server_code and used it
 * to watch for server and other errors, rather
 * than just ignoring and crashing 8^)
 *
 * Revision 1.3  1993/02/18  20:34:16  rushing
 * set CommState to ST_NONE after closing connection.
 *
 * Revision 1.2  1993/02/16  21:20:28  rushing
 * Added a function (initialize_header_array) to ensure
 * valid data in the header array in case a WM_PAINT gets
 * sent to the group window before the retrieval is finished.
 *
 * Revision 1.1  1993/02/16  20:54:22  rushing
 * Initial revision
 *
@



1.46
log
@warnings
@
text
@a155 1
#include "winundoc.h"
@



1.45
log
@new attach code, session [dis]connect
@
text
@d699 1
a699 1
       arts_to_retrieve = estnum;
d706 1
a706 1
                         arts_to_retrieve = (last - first) + 1;
d713 1
a713 1
                         arts_to_retrieve = estnum;
d717 1
a717 1
   arts_to_retrieve = estnum;
d1639 2
a1640 1
      if(ArtNum >= RangePtr->First && ArtNum <= RangePtr->Last) {
@



1.44
log
@changes for gensock & version 0.91
@
text
@d3 3
a5 2
 * $Id: wvutil.c 1.43 1994/05/02 20:33:46 rushing Exp rushing $
 * $Log: wvutil.c $
a403 1
      return (1);
a405 1
      return (1);
d408 3
d566 2
a567 1
        PostQuitMessage (0);
d627 1
a627 1
        Initializing = INIT_DONE;
d648 1
a648 1
   Initializing = INIT_DONE;
d1296 6
a1301 1
      if (check_server_code(retcode)) break;
d1406 4
a1409 1
        PostText(PostEdit);
d1417 3
d1421 1
a1421 1
        SendMessage(PostEdit->hWndEdit, EM_SETREADONLY, FALSE, 0L);
a1422 1

d1442 3
a1444 1
      } else if(retcode == 240) {
d1449 2
d1461 3
a1463 2
	done = TRUE;
      } else
d1474 2
a1475 1
      
@



1.43
log
@changes from jody glasser
@
text
@d3 1
a3 1
 * $Id: wvutil.c 1.42 1994/03/22 22:44:24 rushing Exp $
d5 3
d348 1
a348 1
   while((CommState != ST_CLOSED_COMM) && (ch = MRRReadComm()) >= 0) {
d554 1
a554 1
          sprintf(mybuf,"AUTHINFO user %s\r",NNTPUserName);
d556 1
a556 1
          PutCommLine(mybuf,strlen(mybuf));
d578 1
a578 1
      sprintf(mybuf,"AUTHINFO pass %s\r",mybuf2);
d580 1
a580 1
      PutCommLine(mybuf,strlen(mybuf));
d600 1
a600 1
      PutCommLine ("XOVER\r", 6);
d702 1
a702 1
                         first = RangePtr[GroupDoc->nRanges-1].Last + 1;
d756 1
a756 1
   mylen = sprintf (mybuf, "XOVER %ld-%ld\r", first, last);
d758 1
a758 1
   PutCommLine(mybuf,mylen);
d761 1
a761 1
   mylen = sprintf(mybuf,"XHDR from %ld-%ld\r",first,last);
d763 1
a763 1
   PutCommLine(mybuf,mylen);
d787 1
a787 1
      	mylen = sprintf(mybuf,"XHDR from %ld-%ld\r",first,last);
d789 1
a789 1
        PutCommLine(mybuf,mylen);
d930 1
a930 1
   mylen = sprintf(mybuf,"XHDR date %ld-%ld\r",first,last);
d932 1
a932 1
   PutCommLine(mybuf,mylen);
d998 1
a998 1
   mylen = sprintf(mybuf,"XHDR lines %ld-%ld\r",first,last); 
d1000 1
a1000 1
   PutCommLine(mybuf,mylen);
d1056 2
a1057 2
     mylen = sprintf(mybuf,"XHDR references %ld-%ld\r",first,last); 
     PutCommLine(mybuf,mylen);
d1061 2
a1062 2
     mylen = sprintf(mybuf,"XHDR subject %ld-%ld\r",first,last); 
     PutCommLine(mybuf,mylen);
d1117 1
a1117 1
   mylen = sprintf(mybuf,"XHDR message-id %ld-%ld\r",first,last);
d1119 1
a1119 1
   PutCommLine(mybuf,mylen);
d1191 1
a1191 1
   mylen = sprintf(mybuf,"XHDR subject %ld-%ld\r",first,last);
d1193 1
a1193 1
   PutCommLine(mybuf,mylen);
d1424 3
@



1.42
log
@handle failure of XOVER command (punt to XHDR).
@
text
@d3 1
a3 1
 * $Id: wvutil.c 1.41 1994/02/24 21:35:41 jcoop Exp rushing $
d5 3
d522 1
d679 5
d694 15
d718 2
a724 3
      LockLine(CommDoc->hParentBlock,CommDoc->ParentOffset,
          CommDoc->ParentLineID,&BlockPtr,&LinePtr);

a736 1
     GroupDoc = ((TypGroup far *) ((char far *) LinePtr + sizeof(TypLine)));
@



1.41
log
@jcoop changes.
@
text
@d3 1
a3 1
 * $Id: wvutil.c 1.40 1994/02/16 21:05:33 cnolan Exp $
d5 3
d757 9
a765 3
      if(retcode < 100) break;
      CommState = ST_XOVER_DATA;
      CommDoc->ActiveLines = 0;
@



1.40
log
@cnolan changes to 90.3
@
text
@d3 1
a3 1
 * $Id: wvutil.c 1.39 1994/02/16 20:59:17 rushing Exp $
d5 3
a502 1
  int col;
d509 1
a509 2
  char artline[MAXINTERNALLINE];
  char *cptr, *cdest;
d1260 2
a1261 1
      CommState = ST_REC_ARTICLE;
d1264 21
d1286 3
a1288 3
      if(strcmp(CommLineIn,".") == 0) {
   CommState = ST_IN_GROUP;
   CommBusy = FALSE;
d1337 12
a1348 53
	if(CommDoc->TotalLines > CommDoc->ScYLines
	   && !CommDoc->TopScLineID) {
	  TopOfDoc(CommDoc,&BlockPtr,&LinePtr);
	  found = FALSE;
	  do {
  	    lpsz = ((char far *)LinePtr + sizeof(TypLine) + sizeof(TypText));
	    if(IsLineBlank(lpsz)) {
	      found = TRUE;
	      break;
	    }
	    if(!NextLine(&BlockPtr,&LinePtr)) break;
	  } while(!found);
	  NextLine(&BlockPtr,&LinePtr);

	  /* If the line is in the last screen's worth of lines, back
	   * up the pointer so it points to the first line of the last
	   * screen.
	   */
	  if(found) {
  	    AdjustTopSc(BlockPtr,LinePtr);
	  } else {
	    UnlockLine(BlockPtr,LinePtr,&hBlock,&Offset,&MyLineID);
	  }
	}
      } else {
	/* special case for lines starting with '..' */
	if (strncmp (CommLineIn, "..", 2))
	  cptr = CommLineIn;
	else
	  cptr = CommLineIn + 1;

	if (CommDecoding)
	{
	  DecodeLine (currentCoded, cptr);
 	  break;                           
 	}
	/* Copy this line into an image of a textblock line,
	 * expanding tabs.
	 */
	cdest = artline+sizeof(TypLine)+sizeof(TypText);
	for(col=0;
	    *cptr && col<(MAXINTERNALLINE-3*sizeof(TypLine)-sizeof(TypText));
	    cptr++) {
	  if(*cptr == '\t') {
	    do {
	      *(cdest++) = ' ';
	    } while (++col & 7);
	  } else {
	    *(cdest++) = *cptr;
	    col++;
	  }
	}
	*(cdest++) = '\0';
a1349 15
	((TypLine *)artline)->LineID = NextLineID++;
	LockLine(CommDoc->hCurAddBlock,CommDoc->AddOffset,CommDoc->AddLineID,&BlockPtr,&LinePtr);
	mylen = (cdest-artline) + sizeof(int);
	mylen += mylen%2;
	((TypText *)(artline+sizeof(TypLine)))->NameLen =
  	(cdest-1) - (artline+sizeof(TypLine)+sizeof(TypText));
	((TypLine *)artline)->length = mylen;
	*( (int *) (artline+mylen-sizeof(int)) ) = mylen;
	AddLine((TypLine *)artline,&BlockPtr,&LinePtr);
	UnlockLine(BlockPtr,LinePtr,&(CommDoc->hCurAddBlock),
		   &(CommDoc->AddOffset),&(CommDoc->AddLineID));
	if((CommDoc->TotalLines % UPDATE_ART_FREQ) == 0) {
	  InvalidateRect(CommDoc->hDocWnd,NULL,FALSE);  
	}
      }
d1364 1
a1364 1
   PostText(PostEdit);
d1366 8
a1373 5
   check_server_code (retcode);
   MessageBox(PostEdit->hWnd,CommLineIn+4,"Cannot Post Article",
         MB_OK|MB_ICONEXCLAMATION);
   CommBusy = FALSE;
   CommState = ST_NONE;
d1506 60
d1917 1
a1917 2
 *	Open the common font dialog
 *	Place resulting selection name and size in face and size
d1924 2
d1936 10
a1945 1
	*color = cc.rgbResult;		
@



1.39
log
@Added .ini param to force use of XHDR over XOVER
@
text
@d3 1
a3 1
 * $Id: wvutil.c 1.38 1994/02/09 18:01:08 cnolan Exp rushing $
d5 3
d1531 1
d2102 1
a2104 1

a2112 1
#ifndef _WIN32
a2114 1
#endif
d2118 1
a2118 1
		ES_LEFT | ES_MULTILINE | ES_AUTOHSCROLL | ES_AUTOVSCROLL,
d2121 7
a2127 1

@



1.38
log
@cnolan 90.2 changes
@
text
@d3 1
a3 1
 * $Id: wvutil.c 1.37 1994/01/24 17:40:28 jcoop Exp $
d5 3
d584 1
a584 1
   /* now check for the XOVER command */
d592 2
a593 2
      if (retcode == 412)       /* 412 == 'not in a newsgroup' */
        xoverp = 1;
d596 1
a596 1

@



1.37
log
@90.2 changes
@
text
@d3 1
a3 1
 * $Id: wvutil.c 1.36 1994/01/17 21:54:16 jcoop Exp $
d5 3
d2106 1
d2109 1
d2124 1
a2124 1
      SetClassWord (NewWnd->hWndEdit, GCW_HBRBACKGROUND, hArticleBackgroundBrush);
d2195 1
a2195 1
		    SetClassWord (GroupDocs[i].hDocWnd, GCW_HBRBACKGROUND, hListBackgroundBrush);
d2209 1
a2209 1
		SetClassWord (ArticleDocs[i].hDocWnd, GCW_HBRBACKGROUND, hArticleBackgroundBrush);
d2218 1
a2218 1
		    SetClassWord (WndPosts[i].hWndEdit, GCW_HBRBACKGROUND, hArticleBackgroundBrush);
d2226 1
a2226 1
		    SetClassWord (WndMails[i].hWndEdit, GCW_HBRBACKGROUND, hArticleBackgroundBrush);
d2239 1
a2239 1
		    SetClassWord (codingStatusText[i]->hTextWnd, GCW_HBRBACKGROUND, hStatusBackgroundBrush);
d2245 1
a2245 1
	    SetClassWord (hCodedBlockWnd, GCW_HBRBACKGROUND, hStatusBackgroundBrush);
d2382 1
a2382 1
}@



1.36
log
@Decoder integration, lots of new utilities (fonts/colors, etc)
@
text
@d3 1
a3 1
 * $Id: wvutil.c 1.36 1994/01/17 21:15:46 jcoop Exp $
d5 3
a482 1
  WndEdit * WndPost;
d507 4
a510 1
  if(CommDoc || CommDecoding) {
d1378 5
a1382 2
      WndPost = getWndEdit(WndPosts,CommWnd,MAXPOSTWNDS) ;
      found = (WndPost != NULL) ;
d1388 1
a1388 1
   PostText(WndPost);
d1391 1
a1391 1
   MessageBox(WndPost->hWnd,CommLineIn+4,"Cannot Post Article",
d1401 2
a1402 2
      WndPost = getWndEdit(WndPosts,CommWnd,MAXPOSTWNDS) ;
      found = (WndPost != NULL) ;
d1410 1
a1410 1
   MessageBox(WndPost->hWnd,CommLineIn+4,cptr,mbcode);
d1412 1
d1416 1
a1416 1
//      if (MessageBox(hWndPost,CommLineIn+4,cptr,mbcode)
d1421 3
a1423 3
	   mbuf = GetEditText (WndPost->hWndEdit);
	   WriteEditLog(WndPost->hWnd,PostLogFile,mbuf,
	               (unsigned int) SendMessage (WndPost->hWndEdit, WM_GETTEXTLENGTH, 0, 0L)) ;
d1426 2
a1427 2
	WndPost->dirty=DT_CLEAN ;
	DestroyWindow(WndPost->hWnd) ;
d1433 6
a1438 2
   CommBusy = FALSE;
   CommState = ST_NONE;
d1440 1
d2158 20
d2246 83
d2330 13
d2355 1
a2355 1
		"Sorry, I am already busy retrieving information from the server.\n"
@



1.35
log
@fullnamefrom not working with XHDR
@
text
@a0 1

d3 1
a3 1
 * $Id: wvutil.c 1.34 1994/01/12 19:27:55 mrr Exp cedwards $
d5 3
d127 2
d215 1
a215 1
DWORD
d232 14
d344 3
a346 1

d348 3
a350 1
  
d352 7
a358 3
    sprintf (title, "Retrieving headers for '%s' : %d%%", group_name,
        (int) (line_number / total_lines));
    SetWindowText(hwnd,title);
a361 1

d484 1
a484 1
  int ih, found;
d505 1
a505 1
  if(CommDoc) {
d582 1
a582 1
   xoverp = 1;
d584 1
a584 1
   xoverp = 0;
d587 5
a591 3
      if(dolist == ID_DOLIST_ASK-ID_DOLIST_BASE) {
   dolist = DialogBox(hInst,"WinVnDoList",hWndConf,lpfnWinVnDoListDlg);
      }
d593 2
a594 2
   StartList();
   did_list = 1;
d596 4
a599 4
   did_list = 0;
   CommState = ST_NONE;
   CommBusy = FALSE;
   Initializing = INIT_DONE;
a600 1

a601 1

d603 2
a604 3


    case ST_LIST_RESP:
d1253 6
a1258 4
   LockLine (CommDoc->ParentDoc->hParentBlock,
        CommDoc->ParentDoc->ParentOffset,
        CommDoc->ParentDoc->ParentLineID,
        &BlockPtr, &LinePtr);
d1260 4
a1263 1
   GroupDoc = (TypGroup far *) ((char far *) LinePtr + sizeof (TypLine));
d1265 3
a1267 2
   header_handle = GroupDoc->header_handle;
   thread_handle = GroupDoc->thread_handle;
d1269 3
a1271 3
   headers = lock_headers (header_handle, thread_handle);
   lpsz = (char far *) ((header_elt (headers, CommDoc->LastSeenLineID))->subject);
   unlock_headers (header_handle, thread_handle);
d1273 5
a1277 5
   mylstrncpy(group,lpsz,MAXGROUPNAME);
   sprintf(mybuf,"%s (%u lines)",group,CommDoc->TotalLines);
   SetWindowText(CommDoc->hDocWnd,mybuf);
   InvalidateRect(CommDoc->hDocWnd,NULL,FALSE);
   GlobalUnlock(BlockPtr->hCurBlock);
d1279 20
a1298 1
   SendMessage(CommDoc->ParentDoc->hDocWnd, IDM_RETRIEVE_COMPLETE, 0, 0);
d1300 13
a1312 20
   /* Skip to the first line of the text of the article
    * and make sure it's visible on the screen.  This is
    * so that the user doesn't have to have the first
    * screen filled with a lengthy, worthless header.
    *
    * and save number of header lines (on display)
    * for later (Bretherton)
    */
   TopOfDoc(CommDoc,&BlockPtr,&LinePtr);
   found = FALSE;
   do {
     lpsz = ((char far *)LinePtr + sizeof(TypLine) + sizeof(TypText));
     if(IsLineBlank(lpsz)) {
       found = TRUE;
       CommDoc->HeaderLines=WhatLine (BlockPtr, LinePtr);
       break;
     }
     if(!NextLine(&BlockPtr,&LinePtr)) break;
   } while(!found);
   NextLine(&BlockPtr,&LinePtr);
d1314 10
a1323 25
   if(CommDoc->TotalLines > CommDoc->ScYLines
      && !CommDoc->TopScLineID) {
     TopOfDoc(CommDoc,&BlockPtr,&LinePtr);
     found = FALSE;
     do {
       lpsz = ((char far *)LinePtr + sizeof(TypLine) + sizeof(TypText));
       if(IsLineBlank(lpsz)) {
         found = TRUE;
         break;
       }
       if(!NextLine(&BlockPtr,&LinePtr)) break;
     } while(!found);
     NextLine(&BlockPtr,&LinePtr);

     /* If the line is in the last screen's worth of lines, back
      * up the pointer so it points to the first line of the last
      * screen.
      */
     if(found) {
       AdjustTopSc(BlockPtr,LinePtr);
     } else {
       UnlockLine(BlockPtr,LinePtr,&hBlock,&Offset,&MyLineID);
     }
   }

d1325 5
a1329 4
   /* Copy this line into an image of a textblock line,
    * expanding tabs.
    */
   cdest = artline+sizeof(TypLine)+sizeof(TypText);
d1331 22
a1352 5
   /* special case for lines starting with '..' */
   if (strncmp (CommLineIn, "..", 2))
     cptr = CommLineIn;
   else
     cptr = CommLineIn + 1;
d1354 14
a1367 29
   for(col=0;
       *cptr && col<(MAXINTERNALLINE-3*sizeof(TypLine)-sizeof(TypText));
       cptr++) {
     if(*cptr == '\t') {
       do {
         *(cdest++) = ' ';
       } while (++col & 7);
     } else {
       *(cdest++) = *cptr;
       col++;
     }
   }
   *(cdest++) = '\0';

   mylen = (cdest-artline) + sizeof(int);
   mylen += mylen%2;
   ((TypText *)(artline+sizeof(TypLine)))->NameLen =
     (cdest-1) - (artline+sizeof(TypLine)+sizeof(TypText));
   ((TypLine *)artline)->length = mylen;
   ((TypLine *)artline)->LineID = NextLineID++;
   ((TypLine *)artline)->active = TRUE;
   *( (int *) (artline+mylen-sizeof(int)) ) = mylen;
   LockLine(CommDoc->hCurAddBlock,CommDoc->AddOffset,CommDoc->AddLineID,&BlockPtr,&LinePtr);
   AddLine((TypLine *)artline,&BlockPtr,&LinePtr);
   UnlockLine(BlockPtr,LinePtr,&(CommDoc->hCurAddBlock),
         &(CommDoc->AddOffset),&(CommDoc->AddLineID));
   if((CommDoc->TotalLines % UPDATE_ART_FREQ) == 0) {
     InvalidateRect(CommDoc->hDocWnd,NULL,FALSE);  
   }
a1368 1

d1409 11
a1419 11
   if (PostLog)
   {  HANDLE hEditBuffer ;
      char *mbuf ;
      hEditBuffer = (HANDLE) SendMessage (WndPost->hWndEdit, EM_GETHANDLE, 0, 0L);
      mbuf = LocalLock (hEditBuffer);
      WriteEditLog(WndPost->hWnd,PostLogFile,mbuf) ;
      LocalUnlock (hEditBuffer);
   }
   WndPost->dirty=DT_CLEAN ;
   DestroyWindow(WndPost->hWnd) ;
   done = TRUE;
d1727 10
d1738 2
d1741 1
d1743 505
@



1.34
log
@mrr mods 4
@
text
@d4 1
a4 1
 * $Id: wvutil.c 1.33 1994/01/05 22:36:05 rushing Exp $
d6 3
d862 1
a862 1
//      char neat_from [80];
d886 4
a889 1
   mylstrncpy (header->from, NameString,HEADER_FROM_LENGTH);
@



1.33
log
@off by one bug in PutCommLine ("XOVER\r", 5) fixed
l.
@
text
@d4 1
a4 1
 * $Id: wvutil.c 1.32 1993/12/08 01:28:01 rushing Exp rushing $
d6 4
d286 1
a286 1
	sprintf(s,"%02d%s%02d",datetime->tm_mon+1,fmtDateDelim,datetime->tm_mday);
d306 3
a308 3
	 *CommLinePtr = '\0';
	 DoCommState();
	 CommLinePtr = CommLineIn;
d310 2
a311 2
	 *(CommLinePtr++) = (char) ch;
	 if(CommLinePtr == CommLineLWAp1) CommLinePtr--;
d318 3
a320 3
			 char * group_name,
			 unsigned long line_number,
			 unsigned long total_lines)
d328 1
a328 1
	     (int) (line_number / total_lines));
d371 2
a372 2
		  unsigned long activenum,
		  header_p headers,TypGroup far * GroupDoc)
d379 7
a385 7
	while((artnum != activenum) && (headerloc > 0))
	{
	 headerloc--;
	 if ((header_elt(headers,headerloc))->number == artnum)
	   return(headerloc);
	}
	return(-1);
d389 7
a395 7
	while ((artnum != activenum) && (headerloc <= GroupDoc->total_headers))
	{
	 headerloc++;
	 if ((header_elt(headers,headerloc))->number == artnum)
	   return(headerloc);
	}
	return(-1);
d413 1
a413 1
	bracket_len = 0;
d415 3
a417 3
	bracket2 = strrchr (refer, '>');
	if (bracket2)
	  bracket_len = (int) (bracket2 - bracket1) + 1;
d484 57
a540 57
		if(!sscanf(CommLineIn,"%u",&retcode)) break;
		if(retcode == 200 || retcode == 201) { /* was 500 from induced error */
		  CommBusy = TRUE;
		  do_authinfo = FALSE;
		  if(strlen(NNTPUserName)) {
			 /* We have the AUTHINFO username.	Do we have the password?*/
			 if(!strlen(NNTPPasswordEncrypted)) {
				/* Get the news server user password from the user */
				if (DialogBox (hInst, "WinVnComm", hWndConf, lpfnWinVnCommDlg)
					&& strlen(NNTPPasswordEncrypted)) {
				  do_authinfo = TRUE;
				}
			 } else {
				do_authinfo = TRUE;
			 }
		  }
		  if(do_authinfo) {
			 sprintf(mybuf,"AUTHINFO user %s\r",NNTPUserName);
			 CommState = ST_CHECK_AUTHINFO_USERNAME;
			 PutCommLine(mybuf,strlen(mybuf));
		  } else {
			 goto End_Authinfo;
		  }

		} else {
		  MessageBox (hWndConf, CommLineIn, "Access Problem", MB_OK);
/*		  MRRCloseComm (); */
		  PostQuitMessage (0);
		}

		break;

	 case ST_CHECK_AUTHINFO_USERNAME:
		retcode = 0;
		sscanf(CommLineIn,"%u",&retcode);
		if(!retcode) break;
		if(retcode >= 500) {
		  MessageBox (hWndConf, "Error authorizing your username with the News Server.", "WinVN", MB_OK | MB_ICONHAND);
		  goto End_Authinfo;
		}
		MRRDecrypt(NNTPPasswordEncrypted,(unsigned char *)mybuf2,MAXINTERNALLINE);
		sprintf(mybuf,"AUTHINFO pass %s\r",mybuf2);
		CommState = ST_CHECK_AUTHINFO_PASSWORD;
		PutCommLine(mybuf,strlen(mybuf));
		break;

	case ST_CHECK_AUTHINFO_PASSWORD:
		if(dialog_active)break;
		retcode = 0;
		if(sscanf(CommLineIn,"%u",&retcode) <= 0) break;
		if(retcode < 200 || retcode > 299) {
		  dialog_active = TRUE;
		  sprintf(mybuf,"Error authorizing your password with the News Server:\n%s.",CommLineIn);
		  MessageBox (hWndConf,mybuf , "WinVN", MB_OK | MB_ICONHAND);
		  dialog_active = FALSE;
		}
		goto End_Authinfo;
d543 1
a543 1
	 case ST_END_AUTHINFO:
d545 4
a548 4
	/* now check for the XOVER command */
		CommState = ST_XOVER_CHECK;
		PutCommLine ("XOVER\r", 6);
		break;
d554 1
a554 1
	xoverp = 1;
d556 1
a556 1
	xoverp = 0;
d560 1
a560 1
	dolist = DialogBox(hInst,"WinVnDoList",hWndConf,lpfnWinVnDoListDlg);
d563 2
a564 2
	StartList();
	did_list = 1;
d566 4
a569 4
	did_list = 0;
	CommState = ST_NONE;
	CommBusy = FALSE;
	Initializing = INIT_DONE;
d581 2
a582 2
	check_server_code (retcode);
	break;
d591 4
a594 4
	CommState = ST_NONE;
	CommBusy = FALSE;
	Initializing = INIT_DONE;
	InvalidateRect(hWndConf,NULL,FALSE);
d596 1
a596 1
	ProcEndList();
d598 1
a598 1
	ProcListLine((unsigned char *)CommLineIn);
d607 7
a613 7
	MessageBox (hWndConf, "No Such Newsgroup", "Error", MB_OK | MB_ICONHAND);
	/* abort the fledgling group window */
	DestroyWindow (CommDoc->hDocWnd);
	CommBusy = FALSE;
	CommState = ST_NONE;
	return;
	break;
d615 7
a621 7
	MessageBox (hWndConf, "Restricted Access", "WinVN", MB_OK | MB_ICONHAND);
	/* abort the fledgling group window */
	DestroyWindow (CommDoc->hDocWnd);
	CommBusy = FALSE;
	CommState = ST_NONE;
	return;
	break;
d623 2
a624 2
	if (check_server_code(retcode)) return;
	break;
d628 1
a628 1
	     &retcode,&estnum,&first,&last,group);
d632 8
a639 8
	DialogBox (hInst, "THRESHOLD",
		   CommDoc->hDocWnd, lpfnWinVnThresholdDlg);
	if ((arts_to_retrieve > 0) && ((last - arts_to_retrieve) > first)) {
	  first = (last - arts_to_retrieve) + 1;
	}
	else
	  if (arts_to_retrieve == -1) /* they clicked 'all of them' */
	    arts_to_retrieve = estnum;
d642 1
a642 1
	arts_to_retrieve = estnum;
d644 6
a649 6
	MessageBox (hWndConf, "Empty Newsgroup", "WinVN", MB_OK | MB_ICONHAND);
	/* abort the fledgling group window */
	DestroyWindow (CommDoc->hDocWnd);
	CommBusy = FALSE;
	CommState = ST_NONE;
	return;
d655 1
a655 1
	       CommDoc->ParentLineID,&BlockPtr,&LinePtr);
d658 5
a662 5
	{
	  header_handle =
	    GlobalAlloc (GMEM_MOVEABLE, (long)
			 ((sizeof (TypHeader)) *
			  (long)(arts_to_retrieve)) + sizeof (thread_array *));
d664 10
a673 10
	  /* allocate space for the header_array index table */
	  thread_handle =
	    GlobalAlloc (GMEM_MOVEABLE,
			 (long) ((sizeof (long)) * (long) (arts_to_retrieve)));
	  
	  GroupDoc = ((TypGroup far *) ((char far *) LinePtr + sizeof(TypLine)));
	  GroupDoc->header_handle = header_handle;
	  GroupDoc->thread_handle = thread_handle;
	  
	}
d686 3
a688 3
	mylen = sprintf (mybuf, "XOVER %ld-%ld\r", first, last);
	CommState = ST_XOVER_START;
	PutCommLine(mybuf,mylen);
d691 3
a693 3
	mylen = sprintf(mybuf,"XHDR from %ld-%ld\r",first,last);
	CommState = ST_XHDR_FROM_START;
	PutCommLine(mybuf,mylen);
d719 5
a723 5
	/* this is a yuck way to do this */
	CommState = ST_IN_GROUP;
	CommBusy = FALSE;
	finish_header_retrieval (CommDoc);
	InvalidateRect(CommDoc->hDocWnd,NULL,FALSE);
d726 87
a812 87
	char * this_hop, * next_hop;
	char * reference;
	
	LockLine(CommDoc->hParentBlock,CommDoc->ParentOffset,
		 CommDoc->ParentLineID,&BlockPtr,&LinePtr);
	GroupDoc = ((TypGroup far *) ((char far *) LinePtr + sizeof(TypLine)));
	header_handle = GroupDoc->header_handle;
	thread_handle = GroupDoc->thread_handle;

	GlobalUnlock(BlockPtr->hCurBlock);

	/* Lock the header data */
	headers = lock_headers (header_handle, thread_handle);
	header = header_elt (headers, CommDoc->ActiveLines);

	this_hop=CommLineIn;

	/* article number */
	next_hop = strchr (this_hop, '\t');
	*(next_hop++) = (char) NULL;

	header->number = atol (this_hop);
	
	/* subject */
	this_hop = next_hop;
	next_hop = strchr (this_hop, '\t');
	*(next_hop++) = (char) NULL;
	
	mylstrncpy (header->subject, this_hop, HEADER_SUBJECT_LENGTH);

	/* author */
	this_hop = next_hop;
	next_hop = strchr (this_hop, '\t');
	*(next_hop++) = (char) NULL;

	ParseAddress (this_hop,
		      AddressString,MAXDIALOGSTRING,
		      NameString,MAXDIALOGSTRING ) ;

	if (FullNameFrom)
	  mylstrncpy (header->from, NameString, HEADER_FROM_LENGTH);
	else
	  mylstrncpy (header->from, this_hop, HEADER_FROM_LENGTH);

	/* date */
	this_hop = next_hop;
	next_hop = strchr (this_hop, '\t');
	*(next_hop++) = (char) NULL;

	header->date = parse_usenet_date (this_hop);

	/* message-id */
	this_hop = next_hop;
	next_hop = strchr (this_hop, '\t');
	*(next_hop++) = (char) NULL;

	mylstrncpy (header->message_id, this_hop, HEADER_MESSAGE_ID_LENGTH);

	/* references */
	this_hop = next_hop;
	next_hop = strchr (this_hop, '\t');
	*(next_hop++) = (char) NULL;
	
	reference = get_best_reference (this_hop);
	if (reference) mylstrncpy (header->references, reference, HEADER_REFERENCES_LENGTH);

	/* bytes (ignored) */
	this_hop = next_hop;
	next_hop = strchr (this_hop, '\t');
	*(next_hop++) = (char) NULL;
	
	/* lines (last one doesn't have to have the tab */
	this_hop = next_hop;
	header->lines = atoi (this_hop);

	/* set other header fields */
	header->Selected= FALSE ;
	header->ArtDoc  = (TypDoc *) NULL;
	header->Seen = WasArtSeen (header->number,GroupDoc);

	unlock_headers (header_handle, thread_handle);

	CommDoc->ActiveLines++;

	update_window_title (CommDoc->hDocWnd, group,
			     RcvLineCount++,
			     CommDoc->TotalLines);
d825 1
a825 1
			    
d833 1
a833 1
				     /* mid-session change-of-mind  */
d841 2
a842 2
	LockLine(CommDoc->hParentBlock, CommDoc->ParentOffset,
		 CommDoc->ParentLineID, &BlockPtr,&LinePtr);
d844 2
a845 2
	GroupDoc = ((TypGroup far *) ((char far *) LinePtr + sizeof(TypLine)) );
	GroupDoc->total_headers = CommDoc->ActiveLines;
d847 2
a848 2
	first = GroupDoc->ServerFirst;
	last = GroupDoc->ServerLast;
d850 7
a856 7
	GlobalUnlock(BlockPtr->hCurBlock);
	CommDoc->ActiveLines = 0;

	/* Now ask for the date lines */
	mylen = sprintf(mybuf,"XHDR date %ld-%ld\r",first,last);
	CommState = ST_XHDR_DATE_START;
	PutCommLine(mybuf,mylen);
d860 32
a891 32
	/* Access the Group struct, get HANDLE for header data */
	LockLine(CommDoc->hParentBlock,CommDoc->ParentOffset,
		 CommDoc->ParentLineID,&BlockPtr,&LinePtr);
	
	GroupDoc = ((TypGroup far *) ((char far *) LinePtr + sizeof(TypLine)) );
	header_handle = GroupDoc->header_handle;
	thread_handle = GroupDoc->thread_handle;

	GlobalUnlock(BlockPtr->hCurBlock);

	/* Lock the header data */
	headers = lock_headers (header_handle, thread_handle);

	sscanf (CommLineIn, "%ld", &artnum);
	header = header_elt (headers, CommDoc->ActiveLines);
	header->number = artnum;

	/* now use some of our nice formatting of email addresses */
	ParseAddress (get_xhdr_line (CommLineIn),
		      AddressString,MAXDIALOGSTRING,
		      NameString,MAXDIALOGSTRING ) ;

	/* copy that into headers[].from */
	mylstrncpy (header->from, NameString,HEADER_FROM_LENGTH);

	unlock_headers (header_handle, thread_handle);

	CommDoc->ActiveLines++;

	update_window_title (CommDoc->hDocWnd, group,
			     RcvLineCount++,
			     CommDoc->TotalLines * total_xhdrs);
d906 2
a907 2
	LockLine(CommDoc->hParentBlock,CommDoc->ParentOffset,
		 CommDoc->ParentLineID,&BlockPtr,&LinePtr);
d909 2
a910 2
	GroupDoc = ((TypGroup far *) ((char far *) LinePtr + sizeof(TypLine)) );
	GroupDoc->total_headers = CommDoc->ActiveLines;
d912 2
a913 2
	first = GroupDoc->ServerFirst;
	last = GroupDoc->ServerLast;
d915 7
a921 7
	GlobalUnlock(BlockPtr->hCurBlock);
	CommDoc->ActiveLines = 0;

	/* Now ask for the #of lines */
	mylen = sprintf(mybuf,"XHDR lines %ld-%ld\r",first,last); 
	CommState = ST_XHDR_LINES_START; 
	PutCommLine(mybuf,mylen);
d924 22
a945 22
	
	/* Access the Group struct, get HANDLE for header data */
	LockLine(CommDoc->hParentBlock,CommDoc->ParentOffset,
		 CommDoc->ParentLineID,&BlockPtr,&LinePtr);
	GroupDoc = ((TypGroup far *)((char far *)LinePtr+sizeof(TypLine)));
	header_handle = GroupDoc->header_handle;
	thread_handle = GroupDoc->thread_handle;

	GlobalUnlock(BlockPtr->hCurBlock);

	/* Lock the header data */
	headers = lock_headers (header_handle, thread_handle); 
	syncnum = sync_artnum(atol (CommLineIn),(header_elt(headers,CommDoc->ActiveLines))->number,headers,GroupDoc);
	if (syncnum >= 0)
	  (header_elt(headers,syncnum))->date = parse_usenet_date (get_xhdr_line (CommLineIn));

	unlock_headers (header_handle, thread_handle);

	CommDoc->ActiveLines++;
	update_window_title (CommDoc->hDocWnd, group,
			     RcvLineCount++,
			     CommDoc->TotalLines * total_xhdrs);
d960 2
a961 2
	LockLine(CommDoc->hParentBlock,CommDoc->ParentOffset,
		 CommDoc->ParentLineID,&BlockPtr,&LinePtr);
d963 2
a964 2
	GroupDoc = ((TypGroup far *) ((char far *) LinePtr + sizeof(TypLine)) );
	GroupDoc->total_headers = CommDoc->ActiveLines;
d966 2
a967 2
	first = GroupDoc->ServerFirst;
	last = GroupDoc->ServerLast;
d969 16
a984 16
	GlobalUnlock(BlockPtr->hCurBlock);
	CommDoc->ActiveLines = 0;

	/* Check for threading option, if enabled, go to REF & ID */
	/* states first */

	if (threadp) {
	  CommState = ST_XHDR_REF_START;          
	  mylen = sprintf(mybuf,"XHDR references %ld-%ld\r",first,last); 
	  PutCommLine(mybuf,mylen);
	}
	else {
	  CommState = ST_XHDR_SUBJECT_START; 
	  mylen = sprintf(mybuf,"XHDR subject %ld-%ld\r",first,last); 
	  PutCommLine(mybuf,mylen);
	}
d989 22
a1010 22
	/* Access the Group struct, get HANDLE for header data */
	LockLine(CommDoc->hParentBlock,CommDoc->ParentOffset,
		 CommDoc->ParentLineID,&BlockPtr,&LinePtr);
	GroupDoc = ((TypGroup far *) ((char far *) LinePtr + sizeof(TypLine)));

	header_handle = GroupDoc->header_handle;
	thread_handle = GroupDoc->thread_handle;

	GlobalUnlock(BlockPtr->hCurBlock);

	/* Lock the header data */
	headers = lock_headers (header_handle, thread_handle);

	syncnum = sync_artnum(atol (CommLineIn),(header_elt(headers,CommDoc->ActiveLines))->number,headers,GroupDoc);
	if (syncnum >= 0)
	   sscanf (CommLineIn, "%ld %Fd", &artnum,&((header_elt(headers,syncnum))->lines));

	unlock_headers (header_handle, thread_handle);
	CommDoc->ActiveLines++;
	update_window_title (CommDoc->hDocWnd, group,
			     RcvLineCount++,
			     CommDoc->TotalLines * total_xhdrs);
d1025 2
a1026 2
	LockLine(CommDoc->hParentBlock,CommDoc->ParentOffset,
		 CommDoc->ParentLineID,&BlockPtr,&LinePtr);
d1028 2
a1029 2
	GroupDoc = (TypGroup far *) ((char far *) LinePtr + sizeof(TypLine));
	GroupDoc->total_headers = CommDoc->ActiveLines;
d1031 2
a1032 2
	first = GroupDoc->ServerFirst;
	last = GroupDoc->ServerLast;
d1034 7
a1040 7
	GlobalUnlock(BlockPtr->hCurBlock);
	CommDoc->ActiveLines = 0;

	/* Now ask for the message-id lines */
	mylen = sprintf(mybuf,"XHDR message-id %ld-%ld\r",first,last);
	CommState = ST_XHDR_MID_START;
	PutCommLine(mybuf,mylen);
d1043 1
a1043 1
	char far * refer;    // , far * end,far * bracket1,far *bracket2;
d1046 26
a1071 26
	/* Access the Group struct, get HANDLE for header data */
	LockLine(CommDoc->hParentBlock,CommDoc->ParentOffset,
		 CommDoc->ParentLineID,&BlockPtr,&LinePtr);
	GroupDoc = ((TypGroup far *) ((char far *) LinePtr + sizeof(TypLine)));

	header_handle = GroupDoc->header_handle;
	thread_handle = GroupDoc->thread_handle;

	GlobalUnlock(BlockPtr->hCurBlock);

	/* Lock the header data */
	headers = lock_headers (header_handle, thread_handle);

	/* for now, we only pay attention to first (whole) referral */
	refer = get_xhdr_line(CommLineIn);

	refer = get_best_reference (refer);

	if (refer)
	  {
	   /* Patch to check for bad info from server JD 6/19/93 */
	  syncnum = sync_artnum(atol (CommLineIn),
				(header_elt(headers,
					    CommDoc->ActiveLines))->number,
				headers,GroupDoc);
	  if (syncnum >= 0)
d1073 2
a1074 2
			refer,HEADER_REFERENCES_LENGTH);
	  }
d1076 1
a1076 1
	unlock_headers (header_handle, thread_handle);
d1078 4
a1081 4
	CommDoc->ActiveLines++;
	update_window_title (CommDoc->hDocWnd, group,
			     RcvLineCount++,
			     CommDoc->TotalLines * total_xhdrs);
d1098 17
a1114 17
	LockLine(CommDoc->hParentBlock,CommDoc->ParentOffset,
		 CommDoc->ParentLineID,&BlockPtr,&LinePtr);
	
	GroupDoc = (TypGroup far *) ((char far *) LinePtr + sizeof(TypLine));

	GroupDoc->total_headers = CommDoc->ActiveLines;
	
	first = GroupDoc->ServerFirst;
	last = GroupDoc->ServerLast;

	GlobalUnlock(BlockPtr->hCurBlock);
	CommDoc->ActiveLines = 0;

	/* Now ask for the subject lines */
	mylen = sprintf(mybuf,"XHDR subject %ld-%ld\r",first,last);
	CommState = ST_XHDR_SUBJECT_START;
	PutCommLine(mybuf,mylen);
d1117 3
a1119 3
	/* Access the Group struct, get HANDLE for header data */
	LockLine(CommDoc->hParentBlock,CommDoc->ParentOffset,
		 CommDoc->ParentLineID,&BlockPtr,&LinePtr);
d1121 1
a1121 1
	GroupDoc = (TypGroup far *) ((char far *) LinePtr + sizeof(TypLine));
d1123 2
a1124 2
	header_handle = GroupDoc->header_handle;
	thread_handle = GroupDoc->thread_handle;
d1126 1
a1126 1
	GlobalUnlock(BlockPtr->hCurBlock);
d1128 2
a1129 2
	/* Lock the header data */
	headers = lock_headers (header_handle, thread_handle);
d1131 5
a1135 5
	syncnum = sync_artnum(atol (CommLineIn),(header_elt(headers,CommDoc->ActiveLines))->number,headers,GroupDoc);
	if (syncnum >= 0)
	  mylstrncpy((header_elt (headers,syncnum))->message_id,
		     (char far *) (get_xhdr_line (CommLineIn)),
		     HEADER_MESSAGE_ID_LENGTH);         /* bad, hardcoded. */
d1137 1
a1137 1
	unlock_headers (header_handle, thread_handle);
d1139 4
a1142 4
	CommDoc->ActiveLines++;
	update_window_title (CommDoc->hDocWnd, group,
			     RcvLineCount++,
			     CommDoc->TotalLines * total_xhdrs);
d1159 4
a1162 4
	CommState = ST_IN_GROUP;
	CommBusy = FALSE;
	finish_header_retrieval (CommDoc);
	InvalidateRect(CommDoc->hDocWnd,NULL,FALSE);
d1166 36
a1201 36
	artnum = 0;
	sscanf(CommLineIn,"%ld",&artnum);
	if(artnum) {
	  LockLine(CommDoc->hParentBlock,CommDoc->ParentOffset,
		   CommDoc->ParentLineID,&BlockPtr,&LinePtr);

	  GroupDoc = ((TypGroup far *) ((char far *) LinePtr + sizeof(TypLine)));
	  header_handle = GroupDoc->header_handle;
	  thread_handle = GroupDoc->thread_handle;        
	  headers = lock_headers (header_handle, thread_handle);

	  /* update the seen thing. */
	  syncnum = sync_artnum(atol (CommLineIn),(header_elt(headers,CommDoc->ActiveLines))->number,headers,GroupDoc);
	  if (syncnum >= 0) 
	     header = header_elt (headers, syncnum);
	  else
	     header = header_elt (headers, CommDoc->ActiveLines);

	  header->Selected= FALSE ;
	  header->ArtDoc  = (TypDoc *) NULL;
	  header->Seen =
	    WasArtSeen (artnum,(TypGroup far *)( ((char far *)LinePtr) +
						sizeof(TypLine) ) );

	  UnlockLine(BlockPtr,LinePtr,&(CommDoc->hParentBlock),
		     &(CommDoc->ParentOffset),&(CommDoc->ParentLineID));

	  mylstrncpy(header->subject,
		     get_xhdr_line (CommLineIn), HEADER_SUBJECT_LENGTH);


	  unlock_headers (header_handle, thread_handle);
	  CommDoc->ActiveLines++;
	  update_window_title (CommDoc->hDocWnd, group,
			       RcvLineCount++,
			       CommDoc->TotalLines * total_xhdrs);
d1203 1
a1203 1
	}
d1220 2
a1221 2
	CommState = ST_IN_GROUP;
	CommBusy = FALSE;
d1223 67
a1289 67
	LockLine (CommDoc->ParentDoc->hParentBlock,
		  CommDoc->ParentDoc->ParentOffset,
		  CommDoc->ParentDoc->ParentLineID,
		  &BlockPtr, &LinePtr);

	GroupDoc = (TypGroup far *) ((char far *) LinePtr + sizeof (TypLine));

	header_handle = GroupDoc->header_handle;
	thread_handle = GroupDoc->thread_handle;

	headers = lock_headers (header_handle, thread_handle);
	lpsz = (char far *) ((header_elt (headers, CommDoc->LastSeenLineID))->subject);
	unlock_headers (header_handle, thread_handle);

	mylstrncpy(group,lpsz,MAXGROUPNAME);
	sprintf(mybuf,"%s (%u lines)",group,CommDoc->TotalLines);
	SetWindowText(CommDoc->hDocWnd,mybuf);
	InvalidateRect(CommDoc->hDocWnd,NULL,FALSE);
	GlobalUnlock(BlockPtr->hCurBlock);

	SendMessage(CommDoc->ParentDoc->hDocWnd, IDM_RETRIEVE_COMPLETE, 0, 0);

	/* Skip to the first line of the text of the article
	 * and make sure it's visible on the screen.  This is
	 * so that the user doesn't have to have the first
	 * screen filled with a lengthy, worthless header.
	 *
	 * and save number of header lines (on display)
	 * for later (Bretherton)
	 */
	TopOfDoc(CommDoc,&BlockPtr,&LinePtr);
	found = FALSE;
	do {
	  lpsz = ((char far *)LinePtr + sizeof(TypLine) + sizeof(TypText));
	  if(IsLineBlank(lpsz)) {
	    found = TRUE;
	    CommDoc->HeaderLines=WhatLine (BlockPtr, LinePtr);
	    break;
	  }
	  if(!NextLine(&BlockPtr,&LinePtr)) break;
	} while(!found);
	NextLine(&BlockPtr,&LinePtr);

	if(CommDoc->TotalLines > CommDoc->ScYLines
	   && !CommDoc->TopScLineID) {
	  TopOfDoc(CommDoc,&BlockPtr,&LinePtr);
	  found = FALSE;
	  do {
	    lpsz = ((char far *)LinePtr + sizeof(TypLine) + sizeof(TypText));
	    if(IsLineBlank(lpsz)) {
	      found = TRUE;
	      break;
	    }
	    if(!NextLine(&BlockPtr,&LinePtr)) break;
	  } while(!found);
	  NextLine(&BlockPtr,&LinePtr);

	  /* If the line is in the last screen's worth of lines, back
	   * up the pointer so it points to the first line of the last
	   * screen.
	   */
	  if(found) {
	    AdjustTopSc(BlockPtr,LinePtr);
	  } else {
	    UnlockLine(BlockPtr,LinePtr,&hBlock,&Offset,&MyLineID);
	  }
	}
d1292 40
a1331 39
	/* Copy this line into an image of a textblock line,
	 * expanding tabs.
	 */
	cdest = artline+sizeof(TypLine)+sizeof(TypText);

	/* special case for lines starting with '..' */
	if (strncmp (CommLineIn, "..", 2))
	  cptr = CommLineIn;
	else
	  cptr = CommLineIn + 1;

	for(col=0;
	    *cptr && col<(MAXINTERNALLINE-3*sizeof(TypLine)-sizeof(TypText));
	    cptr++) {
	  if(*cptr == '\t') {
	    do {
	      *(cdest++) = ' ';
	    } while (++col & 7);
	  } else {
	    *(cdest++) = *cptr;
	    col++;
	  }
	}
	*(cdest++) = '\0';

	mylen = (cdest-artline) + sizeof(int);
	mylen += mylen%2;
	((TypText *)(artline+sizeof(TypLine)))->NameLen =
	  (cdest-1) - (artline+sizeof(TypLine)+sizeof(TypText));
	((TypLine *)artline)->length = mylen;
	((TypLine *)artline)->LineID = NextLineID++;
	*( (int *) (artline+mylen-sizeof(int)) ) = mylen;
	LockLine(CommDoc->hCurAddBlock,CommDoc->AddOffset,CommDoc->AddLineID,&BlockPtr,&LinePtr);
	AddLine((TypLine *)artline,&BlockPtr,&LinePtr);
	UnlockLine(BlockPtr,LinePtr,&(CommDoc->hCurAddBlock),
		   &(CommDoc->AddOffset),&(CommDoc->AddLineID));
	if((CommDoc->TotalLines % UPDATE_ART_FREQ) == 0) {
	  InvalidateRect(CommDoc->hDocWnd,NULL,FALSE);  
	}
d1345 1
a1345 1
	PostText(WndPost);
d1347 5
a1351 5
	check_server_code (retcode);
	MessageBox(WndPost->hWnd,CommLineIn+4,"Cannot Post Article",
		   MB_OK|MB_ICONEXCLAMATION);
	CommBusy = FALSE;
	CommState = ST_NONE;
d1365 4
a1368 4
	cptr = "Posting Failed";
	mbcode = MB_OK|MB_ICONEXCLAMATION;
	MessageBox(WndPost->hWnd,CommLineIn+4,cptr,mbcode);
	done = TRUE;
d1370 2
a1371 2
	cptr = "Article Posted OK";
	mbcode = MB_OKCANCEL;
d1374 11
a1384 11
	if (PostLog)
	{  HANDLE hEditBuffer ;
	   char *mbuf ;
	   hEditBuffer = (HANDLE) SendMessage (WndPost->hWndEdit, EM_GETHANDLE, 0, 0L);
	   mbuf = LocalLock (hEditBuffer);
	   WriteEditLog(WndPost->hWnd,PostLogFile,mbuf) ;
	   LocalUnlock (hEditBuffer);
	}
	WndPost->dirty=DT_CLEAN ;
	DestroyWindow(WndPost->hWnd) ;
	done = TRUE;
d1386 1
a1386 1
	if (check_server_code (retcode)) break;
d1389 2
a1390 2
	CommBusy = FALSE;
	CommState = ST_NONE;
d1397 1
a1397 1
			M Bretherton 14 June 1993
d1402 1
a1402 1
	if( WndMails[ih].hWnd) == CommWnd) {
d1404 1
a1404 1
	  hWndPost = WndMails[ih];
d1406 3
a1408 3
	  found = TRUE;
	  break;
	}
d1413 1
a1413 1
	break;
d1415 1
a1415 1
	PostText(ih,DOCTYPE_MAIL);
d1417 4
a1420 4
	MessageBox(WndPost->hWnd,CommLineIn+4,"Cannot Mail Message",
		   MB_OK|MB_ICONEXCLAMATION);
	CommBusy = FALSE;
	CommState = ST_NONE;
d1427 1
a1427 1
	if(WbdPosts[ih].hWnd) == CommWnd) {
d1429 1
a1429 1
	  WndPost = WndPosts[ih];
d1431 3
a1433 3
	  found = TRUE;
	  break;
	}
d1438 4
a1441 4
	cptr = "Posting Failed";
	mbcode = MB_OK|MB_ICONEXCLAMATION;
	MessageBox(WndPost->hWnd,CommLineIn+4,cptr,mbcode);
	done = TRUE;
d1443 2
a1444 2
	cptr = "Article Posted OK";
	mbcode = MB_OKCANCEL;
d1447 2
a1448 2
	DestroyWindow(WndPost->hWnd) ;
	done = TRUE;
d1450 1
a1450 1
	if (check_server_code (retcode)) break;
d1453 2
a1454 2
	CommBusy = FALSE;
	CommState = ST_NONE;
d1495 1
a1495 1
	 return(TRUE);
d1497 1
a1497 1
	 RangePtr++;
d1516 1
a1516 1
	 return(1);
d1518 1
a1518 1
	 return(-1);
d1570 14
a1583 14
	for(;*s1 && *s2 && *s1!=' ' && *s2!=' '; s1++,s2++) {
		if(*s1 > *s2) {
			return (1);
		} else if(*s1 < *s2) {
			return (-1);
		}
	}
	if(*s1 == *s2) {
		return(0);
	} else if(*s1) {
		return(1);
	} else {
		return(-1);
	}
d1604 6
a1609 1
  CommDoc->ActiveLines = 0;
d1614 1
a1614 1
	   CommDoc->ParentLineID,&BlockPtr,&LinePtr);
d1627 1
a1627 1
	
d1631 1
a1631 1
		       sizeof(TypLine)+ sizeof(TypGroup) ) ;
d1645 1
a1645 1
	     CommDoc->ParentLineID,&BlockPtr,&LinePtr);
d1652 1
a1652 1
	  
d1654 3
a1656 3
    	for (i = CommDoc->TotalLines - 1;
		 ((i > 0) && ((header_elt(headers,i))->Seen == FALSE));
		 i--) ;
d1680 3
a1682 3
	{
	  return & WndEdits[ih] ;
	}
@



1.32
log
@new version box and cr lf consistency
@
text
@d4 1
a4 1
 * $Id: wvutil.c 1.31 1993/12/01 23:24:06 rushing Exp rushing $
d6 3
d543 1
a543 1
		PutCommLine ("XOVER\r", 5);
@



1.31
log
@off by one on date problem shows up dec. 1.
@
text
@d1 1
d4 1
a4 1
 * $Id: wvutil.c 1.30 1993/11/24 23:07:20 rushing Exp rushing $
d6 3
d494 1
a494 1
			 sprintf(mybuf,"AUTHINFO user %s",NNTPUserName);
d518 1
a518 1
		sprintf(mybuf,"AUTHINFO pass %s",mybuf2);
d540 1
a540 1
		PutCommLine ("XOVER", 5);
d679 1
a679 1
	mylen = sprintf (mybuf, "XOVER %ld-%ld", first, last);
@



1.30
log
@let the user know about access trouble
@
text
@d3 1
a3 1
 * $Id: wvutil.c 1.29 1993/11/22 20:30:50 rushing Exp rushing $
d5 3
d245 1
a245 1
  if (cp=strstr(fmtMonthTable,mon)) mth=(cp-fmtMonthTable)/3 + 1;
d272 1
a272 1
       sprintf(s,"%02d%s%02d",datetime->tm_mday,fmtDateDelim,datetime->tm_mon);
d275 1
a275 1
	sprintf(s,"%02d%s%02d",datetime->tm_mon,fmtDateDelim,datetime->tm_mday);
@



1.29
log
@handle mixed-case dates
@
text
@d3 1
a3 1
 * $Id: wvutil.c 1.28 1993/08/25 18:53:17 mbretherton Exp rushing $
d5 3
d495 2
a496 1
		  MRRCloseComm ();
d498 1
a498 1
      }
@



1.28
log
@MRB merge, mail & post logging
@
text
@d3 1
a3 1
 * $Id: wvutil.c 1.27 1993/08/25 17:05:17 mbretherton Exp $
d5 3
d216 1
a216 1
  static char fmtMonthTable[37] = "JanFebMarAprMayJunJulAugSepOctNovDec" ;
d227 1
a227 1

d234 4
a237 1
  if ((sc < 0) || (sc > 59)) return(0);
@



1.27
log
@merge from first newsrc.zip
@
text
@d3 1
a3 1
 * $Id: wvutil.c 1.26 1993/08/18 21:49:21 rushing Exp $
d5 3
d835 1
a835 1
//	char neat_from [80];
d900 1
a900 1
        
d913 2
a914 2
        if (syncnum >= 0)
    	  (header_elt(headers,syncnum))->date = parse_usenet_date (get_xhdr_line (CommLineIn));
d978 2
a979 2
        syncnum = sync_artnum(atol (CommLineIn),(header_elt(headers,CommDoc->ActiveLines))->number,headers,GroupDoc);
        if (syncnum >= 0)
d1020 1
a1020 1
//	int bracket_len; 
d1043 4
a1046 1
	  syncnum = sync_artnum(atol (CommLineIn),(header_elt(headers,CommDoc->ActiveLines))->number,headers,GroupDoc);
d1048 2
a1049 1
            mylstrncpy ((header_elt (headers,syncnum))->references, refer,HEADER_REFERENCES_LENGTH);
d1107 2
a1108 2
        syncnum = sync_artnum(atol (CommLineIn),(header_elt(headers,CommDoc->ActiveLines))->number,headers,GroupDoc);
        if (syncnum >= 0)
d1155 1
a1155 1
          if (syncnum >= 0) 
d1157 2
a1158 2
          else
             header = header_elt (headers, CommDoc->ActiveLines);
d1320 1
a1320 1
	PostText(ih,DOCTYPE_POSTING);
d1347 2
a1348 2
//	if (MessageBox(hWndPost,CommLineIn+4,cptr,mbcode)
//	     == ID_OK)
d1353 1
a1353 1
           mbuf = LocalLock (hEditBuffer);
d1420 2
a1421 2
//	if (MessageBox(WndPost->hWnd,CommLineIn+4,cptr,mbcode)
//	     == ID_OK)
d1636 4
a1639 6
 *  Look through the MAIL or Post edits and return the edit with
 *  matching window handle
 Consider - centralising initial window location in wvmail and wndpost
            using a single array (save passing structure and size into this module)


d1643 7
a1649 7
 WndEdit * getWndEdit(WndEdit * WndEdits,HWND hWnd,int numEntries)
 { 
   int ih ;

   for(ih=0; ih<numEntries; ih++)
   {
	if(WndEdits[ih].hWnd == hWnd)
d1652 1
a1652 1
 	}
d1655 9
a1663 1
//   MessageBox(0,"getWndEditFound Nothing","mrb debug", MB_OK | MB_ICONHAND);
a1664 2
   return(WndEdit *) NULL ;
 }@



1.26
log
@more 16-bit article number fixes.
@
text
@d3 1
a3 1
 * $Id: wvutil.c 1.25 1993/08/05 20:06:07 jcoop Exp rushing $
d5 3
d426 1
a426 1
  HWND hWndPost;
a1304 2
      for(ih=0,found=FALSE; !found && ih<MAXPOSTWNDS; ih++) {
	if(&(PostingDocs[ih]) == CommDoc) {
d1306 2
a1307 1
	  hWndPost = hWndPosts[ih];
a1308 4
	  found = TRUE;
	  break;
	}
      }
d1316 1
a1316 1
	MessageBox(hWndPost,CommLineIn+4,"Cannot Post Article",
a1324 2
      for(ih=0,found=FALSE; !found && ih<MAXPOSTWNDS; ih++) {
	if(&(PostingDocs[ih]) == CommDoc) {
d1326 2
a1327 1
	  hWndPost = hWndPosts[ih];
d1329 1
a1329 4
	  found = TRUE;
	  break;
	}
      }
d1335 1
a1335 1
	MessageBox(hWndPost,CommLineIn+4,cptr,mbcode);
d1342 10
a1351 1
        DestroyWindow(hWndPost) ;
d1370 1
a1370 1
	if(&(MailDocs[ih]) == CommDoc) {
d1372 1
a1372 1
	  hWndPost = hWndMails[ih];
d1385 1
a1385 1
	MessageBox(hWndPost,CommLineIn+4,"Cannot Mail Message",
d1395 1
a1395 1
	if(&(PostingDocs[ih]) == CommDoc) {
d1397 1
a1397 1
	  hWndPost = hWndPosts[ih];
d1408 1
a1408 1
	MessageBox(hWndPost,CommLineIn+4,cptr,mbcode);
d1413 1
a1413 1
//	if (MessageBox(hWndPost,CommLineIn+4,cptr,mbcode)
d1415 1
a1415 1
        DestroyWindow(hWndPost) ;
d1627 27
@



1.25
log
@save multiple articles changes by jcoop@@oakb2s01.apl.com (John S Cooper)
@
text
@d3 1
a3 1
 * $Id: wvutil.c 1.24 1993/07/13 16:03:04 riordan Exp $
d5 3
d274 1
a274 1
   while((ch = MRRReadComm()) >= 0) {
d428 1
a428 1
  unsigned int estnum;
d430 1
a430 1
  unsigned int artnum;
d473 1
a474 1
			 CommState = ST_CHECK_AUTHINFO_USERNAME;
d496 1
a497 1
		CommState = ST_CHECK_AUTHINFO_PASSWORD;
d516 1
a517 1
		CommState = ST_XOVER_CHECK;
d597 1
a597 1
      sscanf(CommLineIn,"%u %u %ld %ld %s",
d657 1
a658 1
	CommState = ST_XOVER_START;
d662 1
a663 1
	CommState = ST_XHDR_FROM_START;
d724 1
a724 1
	mylstrcpy (header->subject, this_hop);
d736 1
a736 1
	  mylstrcpy (header->from, NameString);
d738 1
a738 1
	  mylstrcpy (header->from, this_hop);
d752 1
a752 1
	mylstrncpy (header->message_id, this_hop, 30);
d760 1
a760 1
	if (reference) mylstrncpy (header->references, reference, 30);
d825 1
a826 1
	CommState = ST_XHDR_DATE_START;
d853 1
a853 1
	mylstrcpy (header->from, NameString);
d890 1
a891 1
	CommState = ST_XHDR_LINES_START; 
d1009 1
a1010 1
	CommState = ST_XHDR_MID_START;
d1039 1
a1039 1
            mylstrcpy ((header_elt (headers,syncnum))->references, refer);
d1079 1
a1080 1
	CommState = ST_XHDR_SUBJECT_START;
d1100 2
a1101 2
		   (char far *) (get_xhdr_line (CommLineIn)),
		   30);         /* bad, hardcoded. */
d1159 2
a1160 2
	  mylstrcpy(header->subject,
		    get_xhdr_line (CommLineIn));
d1451 1
a1451 1
long int ArtNum;
d1613 4
a1616 3
    for (i = CommDoc->TotalLines - 1;
	 (((header_elt(headers,i))->Seen == FALSE) && (i > 0));
	 i--) ;
@



1.24
log
@MRR mods
@
text
@d3 1
a3 1
 * $Id: wvutil.c 1.23 1993/06/28 17:52:17 rushing Exp $
d5 3
d1205 2
@



1.23
log
@fixed compiler warnings
@
text
@d3 1
a3 1
 * $Id: wvutil.c 1.22 1993/06/25 20:18:51 dumoulin Exp rushing $
d5 3
d413 1
d429 1
a429 1
  BOOL dolist;
d432 1
d449 27
a475 6
      retcode = 0;
      sscanf(CommLineIn,"%u",&retcode);
      if(retcode == 200 || retcode == 201) { /* was 500 from induced error */
	/* now check for the XOVER command */
	PutCommLine ("XOVER", 5);
	CommState = ST_XOVER_CHECK;
d477 29
a505 4
      else {
	MRRCloseComm ();
	PostQuitMessage (0);
      }
d507 6
a512 1
      break;
@



1.22
log
@Changed Date fields from Strings to Posix standard time format
@
text
@d3 1
a3 1
 * $Id: wvutil.c 1.21 1993/06/22 16:43:03 bretherton Exp rushing $
d5 3
d332 3
a334 1
long sync_artnum (long artnum,long activenum,header_p headers,TypGroup far * GroupDoc)
d1392 1
a1392 1
   int nr;
@



1.21
log
@auto close on posting window
@
text
@d3 1
a3 1
 * $Id: wvutil.c 1.20 1993/06/22 14:04:05 dumoulin Exp $
d5 2
d8 1
d89 1
d93 1
a93 1
char * parse_usenet_date (char * date);
d189 1
a189 1
char *
d192 1
a196 1

d215 1
a215 3
/*  while (*cp) { *cp = toupper(*cp); ++cp; } */
/*  sprintf(s,"%d-%s-%d %d:%d:%d",dom,mon,yr,hr,mn,sc); */
/* use international format in date
d217 2
a218 2
  fmtDaysB4Mth  = European format ( windows type 1)
  fmtDateDelim  normally '/' or "."
d220 6
a225 4
  and save a character
	Matthew Bretherton  15/5/93
*/
  if (cp=strstr(fmtMonthTable,mon)) mth=(cp-fmtMonthTable)/3 + 1;
d227 1
a227 9
  if (fmtDaysB4Mth)
  {
      sprintf(s,"%2d%s%-2d",dom,fmtDateDelim,mth);
  } else
  { 
      sprintf(s,"%2d%s%-2d",mth,fmtDateDelim,dom);
  }
 
  return(s);
d230 22
d630 1
a630 1
	char * reference, * parsed_date;
d678 1
a678 3
	parsed_date = parse_usenet_date (this_hop);
	
	mylstrcpy (header->date, parsed_date ? parsed_date : "-----");
d702 1
a702 1
	header->lines = atol (this_hop);
d762 1
a762 1
	char neat_from [80];
a826 1
	char far * parsed_date;
a838 1
	parsed_date = parse_usenet_date (get_xhdr_line (CommLineIn));
d841 1
a841 1
    	  mylstrcpy((header_elt(headers,syncnum))->date,parsed_date ? parsed_date : "-----");
d946 2
a947 2
	char far * refer, far * end,far * bracket1,far *bracket2;
	int bracket_len; 
d1029 1
a1029 1
	  
d1056 1
a1056 1
      
d1095 1
a1095 1
	  
d1490 1
a1490 1
  HANDLE hBlock;
d1533 1
a1533 1
    long i;
@



1.20
log
@Fixed problems with article numbers larger than 32K
@
text
@d3 1
a3 1
 * $Id: wvutil.c 1.19 1993/06/19 18:40:17 dumoulin Exp dumoulin $
d5 4
d390 1
a390 1
  HWND hWndPostEdit;
d1222 1
a1222 1
	  hWndPostEdit = hWndPostEdits[ih];
d1235 1
a1235 1
	MessageBox(hWndPostEdit,CommLineIn+4,"Cannot Post Article",
d1247 1
a1247 1
	  hWndPostEdit = hWndPostEdits[ih];
d1258 1
d1262 4
a1265 1
	mbcode = MB_OK;
a1272 1
	MessageBox(hWndPostEdit,CommLineIn+4,cptr,mbcode);
d1277 3
d1286 1
a1286 1
	  hWndPostEdit = hWndMailEdits[ih];
d1299 1
a1299 1
	MessageBox(hWndPostEdit,CommLineIn+4,"Cannot Mail Message",
d1307 3
a1309 3
    case ST_MAIL_WAIT_END:
      for(ih=0,found=FALSE; !found && ih<MAXMAILWNDS; ih++) {
	if(&(MailDocs[ih]) == CommDoc) {
d1311 1
a1311 1
	  hWndPostEdit = hWndMailEdits[ih];
d1319 2
a1320 2
      if(retcode == 451 || retcode == 450) {
	cptr = "Mailing Failed";
d1322 1
d1324 6
a1329 3
      } else if(retcode == 250) {
	cptr = "Message sent OK";
	mbcode = MB_OK;
d1331 3
a1333 1
      }
a1336 1
	MessageBox(hWndPostEdit,CommLineIn+4,cptr,mbcode);
d1341 1
a1341 1

@



1.19
log
@Added error routines to handle unsyncd XHDRS from screwed up servers
@
text
@d3 1
a3 1
 * $Id: wvutil.c 1.18 1993/06/15 21:16:59 rushing Exp dumoulin $
d5 3
d628 1
a628 1
	header->number = atoi (this_hop);
d682 1
a682 1
	header->lines = atoi (this_hop);
d821 1
a821 1
	syncnum = sync_artnum(atoi (CommLineIn),(header_elt(headers,CommDoc->ActiveLines))->number,headers,GroupDoc);
d887 1
a887 1
        syncnum = sync_artnum(atoi (CommLineIn),(header_elt(headers,CommDoc->ActiveLines))->number,headers,GroupDoc);
d952 1
a952 1
	  syncnum = sync_artnum(atoi (CommLineIn),(header_elt(headers,CommDoc->ActiveLines))->number,headers,GroupDoc);
d1012 1
a1012 1
        syncnum = sync_artnum(atoi (CommLineIn),(header_elt(headers,CommDoc->ActiveLines))->number,headers,GroupDoc);
d1059 1
a1059 1
	  syncnum = sync_artnum(atoi (CommLineIn),(header_elt(headers,CommDoc->ActiveLines))->number,headers,GroupDoc);
@



1.18
log
@headers-> to header-> in two lines.
@
text
@d3 1
a3 1
 * $Id: wvutil.c 1.17 1993/06/11 00:10:35 rushing Exp rushing $
d5 3
d146 1
a146 1
    else			/* No name in parens */
d149 1
a149 1
  else				/* !FullNameFrom */
d240 3
a242 3
         *CommLinePtr = '\0';
         DoCommState();
         CommLinePtr = CommLineIn;
d244 2
a245 2
         *(CommLinePtr++) = (char) ch;
         if(CommLinePtr == CommLineLWAp1) CommLinePtr--;
d252 3
a254 3
                         char * group_name,
                         unsigned long line_number,
                         unsigned long total_lines)
d296 34
d389 1
a389 1
  long int first,last;
d431 1
a431 1
      if (retcode == 412)	/* 412 == 'not in a newsgroup' */
d433 1
a433 1
      else			/* 500 == 'command not understood' */
d536 1
a536 1
      	{
d551 1
a551 1
      	}
d705 1
a705 1

d805 1
d816 1
a816 2
	headers = lock_headers (header_handle, thread_handle);

d818 3
a820 2
	mylstrcpy((header_elt(headers,CommDoc->ActiveLines))->date,
		  parsed_date ? parsed_date : "-----");
d858 1
a858 1
	  CommState = ST_XHDR_REF_START;	  
a870 1

d884 3
a886 2
	sscanf (CommLineIn, "%ld %Fd", &artnum,
		&((header_elt(headers,CommDoc->ActiveLines))->lines));
d926 1
a926 1
	int bracket_len;
d947 6
a952 1
	  mylstrcpy ((header_elt (headers,CommDoc->ActiveLines))->references, refer);
d1008 4
a1011 2

	mylstrncpy((header_elt (headers,CommDoc->ActiveLines))->message_id,
d1013 1
a1013 1
		   30);		/* bad, hardcoded. */
d1052 1
a1052 1
	  thread_handle = GroupDoc->thread_handle;	  
d1056 5
a1060 2

	  header = header_elt (headers, CommDoc->ActiveLines);
d1359 1
a1359 1
         return(TRUE);
d1361 1
a1361 1
         RangePtr++;
d1380 1
a1380 1
         return(1);
d1382 1
a1382 1
         return(-1);
d1477 1
a1477 1
  thread_handle = GroupDoc->thread_handle;	  
d1509 1
a1509 1
    thread_handle = GroupDoc->thread_handle;	  
@



1.17
log
@second merge from Matt Bretherton sources
@
text
@d3 1
a3 1
 * $Id: wvutil.c 1.16 1993/06/10 18:25:17 rushing Exp rushing $
d5 3
d1015 2
a1016 2
	  headers->ArtDoc  = (TypDoc *) NULL;
	  headers->Seen =
@



1.16
log
@XOVER support.
@
text
@d3 1
a3 1
 * $Id: wvutil.c 1.15 1993/06/08 19:42:38 rushing Exp rushing $
d5 3
d176 3
a178 1
  int dom = 0, yr = 0, hr = 0, mn = 0, sc = 0;
d200 4
a203 1
/* use standard Unix format in date
d205 1
a205 2
   could save a character by using win.ini date format
   US = mm.dd and others dd/mm, letting delimiter show type of format
d208 10
a217 1
  sprintf(s,"%2d %s",dom,mon);
@



1.15
log
@always do the thread_index array so we can sort on other fields.
@
text
@d3 1
a3 1
 * $Id: wvutil.c 1.14 1993/06/05 03:18:25 rushing Exp rushing $
d5 3
d69 1
d74 1
d275 36
d361 3
a363 13
	dolist = DoList;
	if(dolist == ID_DOLIST_ASK-ID_DOLIST_BASE) {
	  dolist = DialogBox(hInst,"WinVnDoList",hWndConf,lpfnWinVnDoListDlg);
	}
	if(dolist) {
	  StartList();
	} else {
	  CommState = ST_NONE;
	  CommBusy = FALSE;
	  Initializing = INIT_DONE;
	}

	InvalidateRect(hWndConf,NULL,FALSE);
d372 27
d507 132
a638 4
      mylen = sprintf(mybuf,"XHDR from %ld-%ld\r",first,last);
      PutCommLine(mybuf,mylen);
      CommState = ST_XHDR_FROM_START;
      
d641 1
a885 1
	end = refer + strlen(refer) - 1; /* points to NULL */
d887 1
a887 1
	/* yikes this is ugly */
d889 2
a890 25
	bracket1 = strrchr (refer, '<');
	if (bracket1) {
	  bracket_len = (int) (end - bracket1) + 2;
	  if ((bracket_len < 30) && (!strrchr(bracket1,'>'))) {
	    *bracket1 = (char) NULL;
	    bracket1 = strrchr (refer, '<');
	    if (!bracket1)
	      bracket_len = 0;
	    else {
	      bracket2 = strrchr (refer, '>');
	      if (bracket2)
		bracket_len = (int) (bracket2 - bracket1) + 1;
	    }
	  }
	}
	else
	  bracket_len = 0;
	    
	if (bracket_len > 30)
	  bracket_len = 30;

	if (bracket_len)
	  mylstrncpy((header_elt (headers,CommDoc->ActiveLines))->references,
		     bracket1,
		     bracket_len);
d971 1
d975 1
a975 55

	/* release the mouse that is captured to the usenet window */
	ReleaseCapture ();

	CommDoc->TotalLines = CommDoc->ActiveLines;
	CommDoc->ActiveLines = 0;
	/* Fetch this group's line in NetDoc so we can get the
	 * group's name for the window's title bar.
	 */
	LockLine(CommDoc->hParentBlock,CommDoc->ParentOffset,
		 CommDoc->ParentLineID,&BlockPtr,&LinePtr);

	GroupDoc = ((TypGroup far *) ((char far *) LinePtr + sizeof(TypLine)));
	header_handle = GroupDoc->header_handle;
	thread_handle = GroupDoc->thread_handle;	  
	lock_headers (header_handle, thread_handle);

	if (threadp) {
	  SetWindowText (CommDoc->hDocWnd, "sorting headers...");
	  sort_by_threads (header_handle, thread_handle, CommDoc->TotalLines);
	}

	unlock_headers (header_handle, thread_handle);
	
	lpsz = (char far *) ( ((char far *)LinePtr) +
			     sizeof(TypLine)+ sizeof(TypGroup) ) ;

	mylstrncpy(group,lpsz,MAXGROUPNAME);
	sprintf(mybuf,"%s (%u articles)",group,CommDoc->TotalLines);
	SetWindowText(CommDoc->hDocWnd,mybuf);

	/* If we have information from NEWSRC on the highest-
	 * numbered article previously seen, position the window
	 * so the new articles can be seen without scrolling.
	 */
	{
	  long i;

	  LockLine(CommDoc->hParentBlock,CommDoc->ParentOffset,
		   CommDoc->ParentLineID,&BlockPtr,&LinePtr);

	  /* inside the lock, can access the GroupStruct */
	  GroupDoc = ((TypGroup far *) ((char far *) LinePtr + sizeof(TypLine)));
	  header_handle = GroupDoc->header_handle;
	  thread_handle = GroupDoc->thread_handle;	  
	  headers = lock_headers (header_handle, thread_handle);
	  
	  for (i = CommDoc->TotalLines - 1;
	       (((header_elt(headers,i))->Seen == FALSE) && (i > 0));
		i--) ;
	       CommDoc->TopLineOrd = (i > 5) ? i - 4 : 0;

	  unlock_headers (header_handle, thread_handle);
	}

d977 2
a978 1
      } else {
d1384 15
d1400 52
d1453 2
@



1.14
log
@primitive functional threading.
@
text
@d3 1
a3 1
 * $Id: wvutil.c 1.13 1993/06/01 18:22:40 rushing Exp rushing $
d5 3
d231 2
d234 2
a235 1
    sprintf (title, "Retrieving headers for '%s' : %d%%", group_name, ((line_number *100) / total_lines));
a236 1
    // InvalidateRect (hwnd, NULL, FALSE);
d428 5
a432 10
	  /* if threading is enabled, allocate space for the */
	  /* header_array index table */
	  if (threadp) {
	    thread_handle =
	      GlobalAlloc (GMEM_MOVEABLE,
			   (long) ((sizeof (long)) * (long) (arts_to_retrieve)));
	  }
	  else
	    thread_handle = NULL;

d828 4
a831 2
	/* temporary */
	sort_by_threads (header_handle, thread_handle, CommDoc->TotalLines);
@



1.13
log
@moved header funcs to headarry.c
@
text
@d3 1
a3 1
 * $Id: wvutil.c 1.12 1993/05/26 23:59:40 rushing Exp rushing $
d5 3
d681 3
d697 31
a727 4
	mylstrncpy((header_elt (headers,CommDoc->ActiveLines))->references,
		   (char far *) (get_xhdr_line (CommLineIn)),
		   30);		/* bad, hardcoded. */

@



1.12
log
@reimplemented positioning group window near last read article
@
text
@d3 1
a3 1
 * $Id: wvutil.c 1.11 1993/05/24 23:56:51 rushing Exp rushing $
d5 3
a11 1
 *
d61 1
a61 3

/* temporary test */
char far *mylstrcpy(char huge *ptr1, char far *ptr2);
d66 2
a69 1

a231 23
void
initialize_header_array (HANDLE header_handle, long length)
{
  long i;
  TypHeader huge * headers;

  // Lock the header data
  headers = (TypHeader huge *) (GlobalLock (header_handle) + sizeof(char huge *));

  for (i=0; i < length ; i++) {
    headers[i].Seen = (char) 0;
    headers[i].Selected = (char) 0;
    headers[i].number = 0;
    headers[i].lines = 0;
    headers[i].date[0] = (char) 0;
    headers[i].subject[0] = (char) 0;
    headers[i].from[0] = (char) 0;
    headers[i].message_id[0] = (char) 0;
    headers[i].references[0] = (char) 0;
    headers[i].ArtDoc = NULL;
  }
}

d297 3
a299 1
  TypHeader huge * headers;
d418 11
a428 1
			  (long)(arts_to_retrieve)) + sizeof (char huge *));
d430 4
a433 2
	  (((TypGroup far *) ((char far *) LinePtr + sizeof(TypLine)))
	   ->header_handle) = header_handle;
d437 1
a437 1
      initialize_header_array (header_handle, arts_to_retrieve);
d457 6
d466 2
d475 9
a483 10
	LockLine(CommDoc->hParentBlock,
		 CommDoc->ParentOffset,
		 CommDoc->ParentLineID,
		 &BlockPtr,&LinePtr);
	(((TypGroup far *) ((char far *) LinePtr + sizeof(TypLine)) )
	 ->total_headers) = CommDoc->ActiveLines;
	first = (((TypGroup far *) ((char far *) LinePtr + sizeof(TypLine)))
		 ->ServerFirst );
	last = (((TypGroup far *) ((char far *) LinePtr + sizeof(TypLine)))
		->ServerLast );
d495 7
a501 2
	LockLine(CommDoc->hParentBlock,CommDoc->ParentOffset,CommDoc->ParentLineID,&BlockPtr,&LinePtr);
	header_handle = ((TypGroup far *) ((char far *) LinePtr + sizeof(TypLine)) )->header_handle;
d505 1
a505 1
	headers = (TypHeader huge *) (GlobalLock (header_handle) + sizeof(char huge *));
d508 2
a509 3
	headers[CommDoc->ActiveLines].number = artnum;

	/* use name@@host (This Name) if available */
a510 5
#if 0
	make_neat_from (get_xhdr_line (CommLineIn),
			headers[CommDoc->ActiveLines].from); 
#endif

d517 3
a519 1
	strcpy (headers[CommDoc->ActiveLines].from, NameString);
a520 1
	GlobalUnlock (header_handle);
a541 6
	(((TypGroup far *) ((char far *) LinePtr + sizeof(TypLine)) )->
	 total_headers) = CommDoc->ActiveLines;
	first =
	  (((TypGroup far *) ((char far *) LinePtr + sizeof(TypLine)) ) ->ServerFirst );
	last = (((TypGroup far *)
		 ((char far *) LinePtr + sizeof(TypLine)) ) ->ServerLast );
d543 6
d562 4
a565 2
	header_handle =
	  ((TypGroup far *)((char far *)LinePtr+sizeof(TypLine)))->header_handle;
d569 2
a570 1
	headers = (TypHeader huge *)(GlobalLock (header_handle) + sizeof (char huge *));
d572 2
a573 2
	mylstrcpy(headers[CommDoc->ActiveLines].date,
		  parsed_date ? parsed_date : "no date");
d575 2
a576 1
	GlobalUnlock (header_handle);
d595 5
a599 3
	LockLine(CommDoc->hParentBlock,CommDoc->ParentOffset,CommDoc->ParentLineID,&BlockPtr,&LinePtr);
	(((TypGroup far *) ((char far *) LinePtr + sizeof(TypLine)) )->total_headers) = CommDoc->ActiveLines;
	first = (((TypGroup far *) ((char far *) LinePtr + sizeof(TypLine)) )->ServerFirst );
d601 2
a602 2
	last = (((TypGroup far *)
		 ((char far *) LinePtr + sizeof(TypLine)) )->ServerLast);
d607 13
a619 4
	/* Now ask for the subject headers */
	mylen = sprintf(mybuf,"XHDR subject %ld-%ld\r",first,last); 
	PutCommLine(mybuf,mylen);
	CommState = ST_XHDR_RESP; 
d621 1
d623 2
d626 7
a632 2
	LockLine(CommDoc->hParentBlock,CommDoc->ParentOffset,CommDoc->ParentLineID,&BlockPtr,&LinePtr);
	header_handle = ((TypGroup far *) ((char far *) LinePtr + sizeof(TypLine)) )->header_handle;
d636 1
a636 1
	headers = (TypHeader huge *)(GlobalLock (header_handle) + sizeof (char huge *));
d638 2
a639 1
	sscanf (CommLineIn, "%ld %Fd", &artnum, &(headers[CommDoc->ActiveLines].lines));
d641 1
a641 1
	GlobalUnlock (header_handle);
d660 62
a721 4
	LockLine(CommDoc->hParentBlock,CommDoc->ParentOffset,CommDoc->ParentLineID,&BlockPtr,&LinePtr);
	(((TypGroup far *) ((char far *) LinePtr + sizeof(TypLine)) )->total_headers) = CommDoc->ActiveLines;
	first = (((TypGroup far *)
		  ((char far *) LinePtr + sizeof(TypLine)) )->ServerFirst );
d723 4
a726 2
	last = (((TypGroup far *)
		 ((char far *) LinePtr + sizeof(TypLine)) )->ServerLast );
d734 1
a734 1
	CommState = ST_XHDR_RESP;
d738 8
a745 2
	LockLine(CommDoc->hParentBlock,CommDoc->ParentOffset,CommDoc->ParentLineID,&BlockPtr,&LinePtr);
	header_handle = ((TypGroup far *) ((char far *) LinePtr + sizeof(TypLine)) )->header_handle;
d749 1
a749 1
	headers = (TypHeader huge *)(GlobalLock (header_handle) + sizeof (char huge *));
d751 1
a751 1
	mylstrncpy(headers[CommDoc->ActiveLines].references,
d755 2
a756 1
	GlobalUnlock (header_handle);
d766 2
a767 1
    case ST_XHDR_RESP:
d771 1
a771 1
      CommState = ST_XHDR_SUBJ;
d774 1
a774 1
    case ST_XHDR_SUBJ:
d787 13
a799 1
	LockLine(CommDoc->hParentBlock,CommDoc->ParentOffset,CommDoc->ParentLineID,&BlockPtr,&LinePtr);
d802 1
d818 5
a822 6
	  header_handle =
	    ((TypGroup far *) ((char far *) LinePtr + sizeof(TypLine)) )
	      ->header_handle;
	  headers = (TypHeader huge *) (GlobalLock (header_handle) +
					sizeof(char huge *)) ;

d824 1
a824 1
	       ((headers[i].Seen == FALSE) && (i > 0));
d827 2
d837 2
a838 1
	  LockLine(CommDoc->hParentBlock,CommDoc->ParentOffset,CommDoc->ParentLineID,&BlockPtr,&LinePtr);
d840 4
a843 3
	  /* inside the lock, can access the GroupStruct */
	  header_handle = ((TypGroup far *) ((char far *) LinePtr + sizeof(TypLine)) )->header_handle;
	  headers = (TypHeader huge *) (GlobalLock (header_handle) + sizeof(char huge *)) ;
d847 7
a853 4
	  headers[CommDoc->ActiveLines].Selected= FALSE ;
	  headers[CommDoc->ActiveLines].ArtDoc  = (TypDoc *) NULL;
	  headers[CommDoc->ActiveLines].Seen =
	    WasArtSeen (artnum,(TypGroup far *)( ((char far *)LinePtr) + sizeof(TypLine) ) );
d855 2
a856 1
	  UnlockLine(BlockPtr,LinePtr,&(CommDoc->hParentBlock),&(CommDoc->ParentOffset),&(CommDoc->ParentLineID));
d858 1
a858 1
	  mylstrcpy(headers[CommDoc->ActiveLines].subject,
d861 2
a862 2
	  GlobalUnlock (header_handle);

d896 1
a896 1
	headers = (TypHeader huge *) (GlobalLock (header_handle) + sizeof(char huge *)) ;
d898 3
a900 1
	lpsz = (char far *) headers[CommDoc->LastSeenLineID].subject;
a901 1
	GlobalUnlock (header_handle);
d1197 1
a1197 1
char huge *ptr1;
@



1.11
log
@date formatting for group list window
and save header size for article repaing (MRB)
@
text
@d3 1
a3 1
 * $Id: wvutil.c 1.10 1993/05/13 19:58:09 rushing Exp $
d5 3
d9 1
d707 5
d713 12
a724 1
	/* reinsert this code */
@



1.10
log
@fancy 'from' in group window
@
text
@d3 1
a3 1
 * $Id: wvutil.c 1.9 1993/05/13 16:16:06 rushing Exp SOMEONE $
d5 4
d106 2
a107 1

d127 1
a127 1

d179 7
a185 1
  sprintf(s,"%s %2.2d",mon,dom);
d409 3
d504 1
d507 1
d509 8
d780 3
d784 13
d985 10
@



1.9
log
@article fetch limit support
@
text
@d3 1
a3 1
 * $Id: wvutil.c 1.8 1993/05/08 17:11:05 rushing Exp rushing $
d5 3
d102 22
d410 1
a411 2
      CommDoc->TotalLines = estnum;

d476 1
d488 4
a491 2
	mylstrcpy(headers[CommDoc->ActiveLines].from,
		  (char far *) get_xhdr_line (CommLineIn));
@



1.8
log
@correct handling of 4XX response codes, and
of NNTP data lines beginning with '.'
@
text
@d3 1
a3 1
 * $Id: wvutil.c 1.7 1993/04/29 21:42:11 rushing Exp rushing $
d5 4
d365 21
d391 1
a391 1
      if (estnum > 0)
d393 7
a399 2
	  header_handle = GlobalAlloc (GMEM_MOVEABLE, (long)((sizeof (TypHeader)) * (long)(estnum)) + sizeof (char huge *)); /* How risky is this? */
	  (((TypGroup far *) ((char far *) LinePtr + sizeof(TypLine)) )->header_handle) = header_handle;
d402 2
a403 2
      // stick nulls and 0's, etc.. in case display code get mis-threaded
	initialize_header_array (header_handle, estnum);
d405 17
a421 15
      (((TypGroup far *) ((char far *) LinePtr + sizeof(TypLine)) )->ServerEstNum) = estnum;
      (((TypGroup far *) ((char far *) LinePtr + sizeof(TypLine)) )->ServerFirst ) = first;
      (((TypGroup far *) ((char far *) LinePtr + sizeof(TypLine)) )->ServerLast  ) = last;
      	GlobalUnlock(BlockPtr->hCurBlock);

            mylen = sprintf(mybuf,"XHDR from %ld-%ld\r",first,999999L);
            PutCommLine(mybuf,mylen);
            CommState = ST_XHDR_FROM_START;

            break;

// The next few cases handle retrieval of XHDR information for display
// in the group window.  If you change the number of XHDR's retrieved
  // (such as adding 'XHDR References' back into the state machine), you
    // need to reflect that change in the variable total_xhdrs.
d433 10
a442 3
	LockLine(CommDoc->hParentBlock,CommDoc->ParentOffset,CommDoc->ParentLineID,&BlockPtr,&LinePtr);
	(((TypGroup far *) ((char far *) LinePtr + sizeof(TypLine)) )->total_headers) = CommDoc->ActiveLines;
	first = (((TypGroup far *) ((char far *) LinePtr + sizeof(TypLine)) )->ServerFirst );
d447 1
a447 1
	mylen = sprintf(mybuf,"XHDR date %ld-%ld\r",first,999999L);
d492 3
d499 1
a499 1
	mylen = sprintf(mybuf,"XHDR lines %ld-%ld\r",first,999999L); 
d540 4
d548 1
a548 1
	mylen = sprintf(mybuf,"XHDR subject %ld-%ld\r",first,999999L); 
d584 6
a589 1
	first = (((TypGroup far *) ((char far *) LinePtr + sizeof(TypLine)) )->ServerFirst );
d594 1
a594 1
	mylen = sprintf(mybuf,"XHDR subject %ld-%ld\r",first,999999L);
@



1.7
log
@checked for null from parse_usenet_date on bad date.
@
text
@d3 1
a3 1
 * $Id: wvutil.c 1.6 1993/04/29 20:24:59 rushing Exp rushing $
d5 3
d222 12
a233 4
    MessageBox (hWndConf, "News Server No Longer Available", "WinVN", MB_OK | MB_ICONHAND);
    MRRCloseComm ();
    PostQuitMessage (0);
    return (1);
d709 10
a718 2
	for(col=0,cptr=CommLineIn; *cptr &&
	    col<(MAXINTERNALLINE-3*sizeof(TypLine)-sizeof(TypText)); cptr++) {
@



1.6
log
@attempted support for WSAAsyncSelect
@
text
@d3 1
a3 1
 * $Id: wvutil.c 1.5 1993/04/27 21:03:20 rushing Exp rushing $
d5 3
d242 24
a265 24
   TypLine far *LinePtr;
   TypBlock far *BlockPtr;
   HANDLE hBlock;
   HWND hWndPostEdit;
   unsigned int Offset;
   TypLineID MyLineID;
   int retcode;
   int ih, found;
   unsigned int estnum;
   long int first,last;
   unsigned int artnum;
   int mylen;
   int col;
   int mbcode;
   BOOL done=FALSE;
   BOOL dolist;
   static char group[MAXINTERNALLINE];
   char mybuf[MAXINTERNALLINE];
   char artline[MAXINTERNALLINE];
   char *cptr, *cdest;
   char far *lpsz;
   HANDLE header_handle;
   TypHeader huge * headers;
   TypGroup far * GroupDoc;
d267 1
a267 1
   if(CommDoc) {
d269 19
a287 3
      switch(CommState) {
         case ST_NONE:
            break;
d289 6
a294 22
         case ST_ESTABLISH_COMM:
            retcode = 0;
            sscanf(CommLineIn,"%u",&retcode);
            if(retcode == 200 || retcode == 201) {/* was 500 from induced error */
               dolist = DoList;
               if(dolist == ID_DOLIST_ASK-ID_DOLIST_BASE) {
                  dolist = DialogBox(hInst,"WinVnDoList",hWndConf,lpfnWinVnDoListDlg);
               }
               if(dolist) {
                  StartList();
               } else {
                  CommState = ST_NONE;
                  CommBusy = FALSE;
                  Initializing = INIT_DONE;
               }

               InvalidateRect(hWndConf,NULL,FALSE);
            }
	    else {
              MRRCloseComm ();
              PostQuitMessage (0);
	    }
d296 1
a296 1
            break;
d298 7
a304 7
         case ST_LIST_RESP:
            retcode = 0;
            sscanf(CommLineIn,"%u",&retcode);
            if(retcode != 215) {
	      check_server_code (retcode);
              break;
            }
d306 10
a315 3
            CommState = ST_LIST_GROUPLINE;
            RcvLineCount = 0;
            break;
d317 5
a321 12
         case ST_LIST_GROUPLINE:
            if(strcmp(CommLineIn,".") == 0) {
               CommState = ST_NONE;
               CommBusy = FALSE;
               Initializing = INIT_DONE;
               InvalidateRect(hWndConf,NULL,FALSE);

               ProcEndList();
            } else {
               ProcListLine((unsigned char *)CommLineIn);
            }
            break;
d323 24
a346 24
         case ST_GROUP_RESP:
            retcode = 0;
	    sscanf(CommLineIn,"%u",&retcode);
	    switch (retcode) {
	    case 411:
	      MessageBox (hWndConf, "No Such Newsgroup", "Error", MB_OK | MB_ICONHAND);
	      /* abort the fledgling group window */
	      DestroyWindow (CommDoc->hDocWnd);
	      CommBusy = FALSE;
	      CommState = ST_NONE;
	      return;
	      break;
	    case 502:
	      MessageBox (hWndConf, "Restricted Access", "WinVN", MB_OK | MB_ICONHAND);
	      /* abort the fledgling group window */
	      DestroyWindow (CommDoc->hDocWnd);
	      CommBusy = FALSE;
	      CommState = ST_NONE;
	      return;
	      break;
	    default:
	      if (check_server_code(retcode)) return;
	      break;
	    }
d348 3
a350 3
            sscanf(CommLineIn,"%u %u %ld %ld %s",
		   &retcode,&estnum,&first,&last,group);
	    CommDoc->TotalLines = estnum;
d352 2
a353 2
      	LockLine(CommDoc->hParentBlock,CommDoc->ParentOffset,
		 CommDoc->ParentLineID,&BlockPtr,&LinePtr);
d355 1
a355 1
      	if (estnum > 0)
d357 2
a358 2
      	header_handle = GlobalAlloc (GMEM_MOVEABLE, (long)((sizeof (TypHeader)) * (long)(estnum)) + sizeof (char huge *));  /* How risky is this? */
        (((TypGroup far *) ((char far *) LinePtr + sizeof(TypLine)) )->header_handle) = header_handle;
d361 1
a361 1
	// stick nulls and 0's, etc.. in case display code get mis-threaded
d377 218
a594 2
// (such as adding 'XHDR References' back into the state machine), you
// need to reflect that change in the variable total_xhdrs.
d596 96
a691 179
      	case ST_XHDR_FROM_START:
            retcode = 0;
            sscanf(CommLineIn,"%d",&retcode);
            if(retcode < 100) break;
            CommState = ST_XHDR_FROM_DATA;
	    CommDoc->ActiveLines = 0;
	    break;

	case ST_XHDR_FROM_DATA:
            if(strcmp(CommLineIn,".") == 0) {
               	LockLine(CommDoc->hParentBlock,CommDoc->ParentOffset,CommDoc->ParentLineID,&BlockPtr,&LinePtr);
                (((TypGroup far *) ((char far *) LinePtr + sizeof(TypLine)) )->total_headers) = CommDoc->ActiveLines;
		first = (((TypGroup far *) ((char far *) LinePtr + sizeof(TypLine)) )->ServerFirst );
            	GlobalUnlock(BlockPtr->hCurBlock);
		CommDoc->ActiveLines = 0;

		/* Now ask for the date lines */
                mylen = sprintf(mybuf,"XHDR date %ld-%ld\r",first,999999L);
                PutCommLine(mybuf,mylen);
                CommState = ST_XHDR_DATE_START;
            }
            else {
		/* Access the Group struct, get HANDLE for header data */
               	LockLine(CommDoc->hParentBlock,CommDoc->ParentOffset,CommDoc->ParentLineID,&BlockPtr,&LinePtr);
                header_handle = ((TypGroup far *) ((char far *) LinePtr + sizeof(TypLine)) )->header_handle;
            	GlobalUnlock(BlockPtr->hCurBlock);

		/* Lock the header data */
            	headers = (TypHeader huge *) (GlobalLock (header_handle) + sizeof(char huge *));

		sscanf (CommLineIn, "%ld", &artnum);
            	headers[CommDoc->ActiveLines].number = artnum;

            	mylstrcpy(headers[CommDoc->ActiveLines].from,
                          (char far *) get_xhdr_line (CommLineIn));

		GlobalUnlock (header_handle);
            	CommDoc->ActiveLines++;

		update_window_title (CommDoc->hDocWnd, group,
            	                     RcvLineCount++,
				     CommDoc->TotalLines * total_xhdrs);
            }

	    break;

      	case ST_XHDR_DATE_START:
            retcode = 0;
            sscanf(CommLineIn,"%d",&retcode);
            if (check_server_code(retcode)) break;
            CommState = ST_XHDR_DATE_DATA;
	    CommDoc->ActiveLines = 0;
	    break;

	case ST_XHDR_DATE_DATA:
            if(strcmp(CommLineIn,".") == 0) {
               	LockLine(CommDoc->hParentBlock,CommDoc->ParentOffset,CommDoc->ParentLineID,&BlockPtr,&LinePtr);
                (((TypGroup far *) ((char far *) LinePtr + sizeof(TypLine)) )->total_headers) = CommDoc->ActiveLines;
		first = (((TypGroup far *) ((char far *) LinePtr + sizeof(TypLine)) )->ServerFirst );
            	GlobalUnlock(BlockPtr->hCurBlock);
		CommDoc->ActiveLines = 0;

		/* Now ask for the #of lines */
                mylen = sprintf(mybuf,"XHDR lines %ld-%ld\r",first,999999L); 
                PutCommLine(mybuf,mylen);
                CommState = ST_XHDR_LINES_START; 
            }
            else {
		/* Access the Group struct, get HANDLE for header data */
               	LockLine(CommDoc->hParentBlock,CommDoc->ParentOffset,CommDoc->ParentLineID,&BlockPtr,&LinePtr);
                header_handle = ((TypGroup far *) ((char far *) LinePtr + sizeof(TypLine)) )->header_handle;
            	GlobalUnlock(BlockPtr->hCurBlock);

		/* Lock the header data */
            	headers = (TypHeader huge *)(GlobalLock (header_handle) + sizeof (char huge *));

            	mylstrcpy(headers[CommDoc->ActiveLines].date,
                          (char far *) (parse_usenet_date (get_xhdr_line (CommLineIn))));

		GlobalUnlock (header_handle);
            	CommDoc->ActiveLines++;
		update_window_title (CommDoc->hDocWnd, group,
            	                     RcvLineCount++,
				     CommDoc->TotalLines * total_xhdrs);
            }

	    break;

      	case ST_XHDR_LINES_START:
            retcode = 0;
            sscanf(CommLineIn,"%d",&retcode);
            if (check_server_code(retcode)) break;
            CommState = ST_XHDR_LINES_DATA;
	    CommDoc->ActiveLines = 0;
	    break;

	case ST_XHDR_LINES_DATA:
            if(strcmp(CommLineIn,".") == 0) {
               	LockLine(CommDoc->hParentBlock,CommDoc->ParentOffset,CommDoc->ParentLineID,&BlockPtr,&LinePtr);
                (((TypGroup far *) ((char far *) LinePtr + sizeof(TypLine)) )->total_headers) = CommDoc->ActiveLines;
		first = (((TypGroup far *) ((char far *) LinePtr + sizeof(TypLine)) )->ServerFirst );
            	GlobalUnlock(BlockPtr->hCurBlock);
		CommDoc->ActiveLines = 0;

		/* Now ask for the subject headers */
                mylen = sprintf(mybuf,"XHDR subject %ld-%ld\r",first,999999L); 
                PutCommLine(mybuf,mylen);
                CommState = ST_XHDR_RESP; 
            }
            else {
		/* Access the Group struct, get HANDLE for header data */
               	LockLine(CommDoc->hParentBlock,CommDoc->ParentOffset,CommDoc->ParentLineID,&BlockPtr,&LinePtr);
                header_handle = ((TypGroup far *) ((char far *) LinePtr + sizeof(TypLine)) )->header_handle;
            	GlobalUnlock(BlockPtr->hCurBlock);

		/* Lock the header data */
            	headers = (TypHeader huge *)(GlobalLock (header_handle) + sizeof (char huge *));

		sscanf (CommLineIn, "%ld %Fd", &artnum, &(headers[CommDoc->ActiveLines].lines));

		GlobalUnlock (header_handle);
            	CommDoc->ActiveLines++;
		update_window_title (CommDoc->hDocWnd, group,
            	                     RcvLineCount++,
				     CommDoc->TotalLines * total_xhdrs);
            }

	    break;

      	case ST_XHDR_REF_START:
            retcode = 0;
            sscanf(CommLineIn,"%d",&retcode);
            if (check_server_code(retcode)) break;
            CommState = ST_XHDR_REF_DATA;
	    CommDoc->ActiveLines = 0;
	    break;

	case ST_XHDR_REF_DATA:
            if(strcmp(CommLineIn,".") == 0) {
               	LockLine(CommDoc->hParentBlock,CommDoc->ParentOffset,CommDoc->ParentLineID,&BlockPtr,&LinePtr);
                (((TypGroup far *) ((char far *) LinePtr + sizeof(TypLine)) )->total_headers) = CommDoc->ActiveLines;
		first = (((TypGroup far *) ((char far *) LinePtr + sizeof(TypLine)) )->ServerFirst );
            	GlobalUnlock(BlockPtr->hCurBlock);
		CommDoc->ActiveLines = 0;

		/* Now ask for the subject lines */
                mylen = sprintf(mybuf,"XHDR subject %ld-%ld\r",first,999999L);
                PutCommLine(mybuf,mylen);
                CommState = ST_XHDR_RESP;
            }
            else {
		/* Access the Group struct, get HANDLE for header data */
               	LockLine(CommDoc->hParentBlock,CommDoc->ParentOffset,CommDoc->ParentLineID,&BlockPtr,&LinePtr);
                header_handle = ((TypGroup far *) ((char far *) LinePtr + sizeof(TypLine)) )->header_handle;
            	GlobalUnlock(BlockPtr->hCurBlock);

		/* Lock the header data */
            	headers = (TypHeader huge *)(GlobalLock (header_handle) + sizeof (char huge *));

            	mylstrncpy(headers[CommDoc->ActiveLines].references,
                          (char far *) (get_xhdr_line (CommLineIn)),
                           30);		/* bad, hardcoded. */

		GlobalUnlock (header_handle);
            	CommDoc->ActiveLines++;
		update_window_title (CommDoc->hDocWnd, group,
            	                     RcvLineCount++,
				     CommDoc->TotalLines * total_xhdrs);

            }

	    break;

         case ST_XHDR_RESP:
            retcode = 0;
            sscanf(CommLineIn,"%d",&retcode);
            if (check_server_code(retcode)) break;
            CommState = ST_XHDR_SUBJ;
            break;
d693 33
a725 57
         case ST_XHDR_SUBJ:
            if(strcmp(CommLineIn,".") == 0) {
               CommState = ST_IN_GROUP;
               CommBusy = FALSE;

		/* release the mouse that is captured to the usenet window */
		ReleaseCapture ();

		CommDoc->TotalLines = CommDoc->ActiveLines;
		CommDoc->ActiveLines = 0;
               /* Fetch this group's line in NetDoc so we can get the
                * group's name for the window's title bar.
                */
               LockLine(CommDoc->hParentBlock,CommDoc->ParentOffset,CommDoc->ParentLineID,&BlockPtr,&LinePtr);
               lpsz = (char far *) ( ((char far *)LinePtr) +
                sizeof(TypLine)+ sizeof(TypGroup) ) ;
               mylstrncpy(group,lpsz,MAXGROUPNAME);
               sprintf(mybuf,"%s (%u articles)",group,CommDoc->TotalLines);
               SetWindowText(CommDoc->hDocWnd,mybuf);

               /* If we have information from NEWSRC on the highest-
                * numbered article previously seen, position the window
                * so the new articles can be seen without scrolling.
                */

            	/* reinsert this code */

            	InvalidateRect(CommDoc->hDocWnd,NULL,FALSE);
            } else {

               artnum = 0;
               sscanf(CommLineIn,"%ld",&artnum);
               if(artnum) {
                LockLine(CommDoc->hParentBlock,CommDoc->ParentOffset,CommDoc->ParentLineID,&BlockPtr,&LinePtr);

		/* inside the lock, can access the GroupStruct */
                header_handle = ((TypGroup far *) ((char far *) LinePtr + sizeof(TypLine)) )->header_handle;
               	headers = (TypHeader huge *) (GlobalLock (header_handle) + sizeof(char huge *)) ;

		/* update the seen thing. */

                headers[CommDoc->ActiveLines].Selected= FALSE ;
                headers[CommDoc->ActiveLines].ArtDoc  = (TypDoc *) NULL;
		headers[CommDoc->ActiveLines].Seen =
		   WasArtSeen (artnum,(TypGroup far *)( ((char far *)LinePtr) + sizeof(TypLine) ) );

                UnlockLine(BlockPtr,LinePtr,&(CommDoc->hParentBlock),&(CommDoc->ParentOffset),&(CommDoc->ParentLineID));

            	mylstrcpy(headers[CommDoc->ActiveLines].subject,
                          get_xhdr_line (CommLineIn));

		GlobalUnlock (header_handle);

		CommDoc->ActiveLines++;
		update_window_title (CommDoc->hDocWnd, group,
            	                     RcvLineCount++,
				     CommDoc->TotalLines * total_xhdrs);
d727 1
a727 2
                }
            }
d729 3
a731 1
      	    break;
d733 1
a733 2
         case ST_IN_GROUP:
            break;
d735 6
a740 6
         case ST_ARTICLE_RESP:
            retcode = 0;
            sscanf(CommLineIn,"%d",&retcode);
            if (check_server_code(retcode)) break;
            CommState = ST_REC_ARTICLE;
            break;
d742 9
a750 87
         case ST_REC_ARTICLE:
            if(strcmp(CommLineIn,".") == 0) {
               CommState = ST_IN_GROUP;
               CommBusy = FALSE;

            	LockLine (CommDoc->ParentDoc->hParentBlock,
            	          CommDoc->ParentDoc->ParentOffset,
            	          CommDoc->ParentDoc->ParentLineID,
            	          &BlockPtr, &LinePtr);

            	GroupDoc = (TypGroup far *) ((char far *) LinePtr + sizeof (TypLine));

            	header_handle = GroupDoc->header_handle;
            	headers = (TypHeader huge *) (GlobalLock (header_handle) + sizeof(char huge *)) ;

		lpsz = (char far *) headers[CommDoc->LastSeenLineID].subject;

		GlobalUnlock (header_handle);
               mylstrncpy(group,lpsz,MAXGROUPNAME);
               sprintf(mybuf,"%s (%u lines)",group,CommDoc->TotalLines);
               SetWindowText(CommDoc->hDocWnd,mybuf);
               InvalidateRect(CommDoc->hDocWnd,NULL,FALSE);
               GlobalUnlock(BlockPtr->hCurBlock);

               /* Skip to the first line of the text of the article
                * and make sure it's visible on the screen.  This is
                * so that the user doesn't have to have the first
                * screen filled with a lengthy, worthless header.
                */
               if(CommDoc->TotalLines > CommDoc->ScYLines
                 && !CommDoc->TopScLineID) {
                  TopOfDoc(CommDoc,&BlockPtr,&LinePtr);
                  found = FALSE;
                  do {
                     lpsz = ((char far *)LinePtr + sizeof(TypLine) + sizeof(TypText));
                     if(IsLineBlank(lpsz)) {
                        found = TRUE;
                        break;
                     }
                     if(!NextLine(&BlockPtr,&LinePtr)) break;
                  } while(!found);
                  NextLine(&BlockPtr,&LinePtr);

                  /* If the line is in the last screen's worth of lines, back
                   * up the pointer so it points to the first line of the last
                   * screen.
                   */
                  if(found) {
                     AdjustTopSc(BlockPtr,LinePtr);
                  } else {
                     UnlockLine(BlockPtr,LinePtr,&hBlock,&Offset,&MyLineID);
                  }
               }

            } else {
               /* Copy this line into an image of a textblock line,
                * expanding tabs.
                */
               cdest = artline+sizeof(TypLine)+sizeof(TypText);
               for(col=0,cptr=CommLineIn; *cptr &&
                col<(MAXINTERNALLINE-3*sizeof(TypLine)-sizeof(TypText)); cptr++) {
                  if(*cptr == '\t') {
                     do {
                        *(cdest++) = ' ';
                     } while (++col & 7);
                  } else {
                     *(cdest++) = *cptr;
                     col++;
                  }
               }
               *(cdest++) = '\0';

               mylen = (cdest-artline) + sizeof(int);
               mylen += mylen%2;
               ((TypText *)(artline+sizeof(TypLine)))->NameLen =
                (cdest-1) - (artline+sizeof(TypLine)+sizeof(TypText));
               ((TypLine *)artline)->length = mylen;
               ((TypLine *)artline)->LineID = NextLineID++;
               *( (int *) (artline+mylen-sizeof(int)) ) = mylen;
               LockLine(CommDoc->hCurAddBlock,CommDoc->AddOffset,CommDoc->AddLineID,&BlockPtr,&LinePtr);
               AddLine((TypLine *)artline,&BlockPtr,&LinePtr);
               UnlockLine(BlockPtr,LinePtr,&(CommDoc->hCurAddBlock),
                &(CommDoc->AddOffset),&(CommDoc->AddLineID));
               if((CommDoc->TotalLines % UPDATE_ART_FREQ) == 0) {
            InvalidateRect(CommDoc->hDocWnd,NULL,FALSE);  
               }
            }
d752 1
a752 1
            break;
d754 3
a756 22
         case ST_POST_WAIT_PERMISSION:
            for(ih=0,found=FALSE; !found && ih<MAXPOSTWNDS; ih++) {
              if(&(PostingDocs[ih]) == CommDoc) {

                 hWndPostEdit = hWndPostEdits[ih];

                 found = TRUE;
                 break;
              }
            }
            retcode = 0;
            sscanf(CommLineIn,"%u",&retcode);

            if(retcode == 340) {
               PostText(ih,DOCTYPE_POSTING);
            } else {
	       check_server_code (retcode);
               MessageBox(hWndPostEdit,CommLineIn+4,"Cannot Post Article",
                  MB_OK|MB_ICONEXCLAMATION);
               CommBusy = FALSE;
               CommState = ST_NONE;
            }
d758 1
a758 1
            break;
d760 23
a782 29
         case ST_POST_WAIT_END:
            for(ih=0,found=FALSE; !found && ih<MAXPOSTWNDS; ih++) {
              if(&(PostingDocs[ih]) == CommDoc) {

                 hWndPostEdit = hWndPostEdits[ih];

                 found = TRUE;
                 break;
              }
            }
            retcode = 0;
            sscanf(CommLineIn,"%d",&retcode);
            if(retcode == 441 || retcode == 440) {
               cptr = "Posting Failed";
               mbcode = MB_OK|MB_ICONEXCLAMATION;
               done = TRUE;
            } else if(retcode == 240) {
               cptr = "Article Posted OK";
               mbcode = MB_OK;
               done = TRUE;
            } else
               if (check_server_code (retcode)) break;

            if(done) {
               CommBusy = FALSE;
               CommState = ST_NONE;
               MessageBox(hWndPostEdit,CommLineIn+4,cptr,mbcode);
            }
            break;
d784 1
a784 1
/* the following code is for an MRR-hacked nntp server */
d787 24
a810 22
         case ST_MAIL_WAIT_PERMISSION:
            for(ih=0,found=FALSE; !found && ih<MAXMAILWNDS; ih++) {
              if(&(MailDocs[ih]) == CommDoc) {

                 hWndPostEdit = hWndMailEdits[ih];

                 found = TRUE;
                 break;
              }
            }
            retcode = 0;
            sscanf(CommLineIn,"%d",&retcode);
            if(retcode <= 0) {
               break;
            } else if(retcode == 350) {
               PostText(ih,DOCTYPE_MAIL);
            } else {
               MessageBox(hWndPostEdit,CommLineIn+4,"Cannot Mail Message",
                  MB_OK|MB_ICONEXCLAMATION);
               CommBusy = FALSE;
               CommState = ST_NONE;
            }
d812 5
a816 1
            break;
d818 21
a838 27
         case ST_MAIL_WAIT_END:
            for(ih=0,found=FALSE; !found && ih<MAXMAILWNDS; ih++) {
              if(&(MailDocs[ih]) == CommDoc) {

                 hWndPostEdit = hWndMailEdits[ih];

                 found = TRUE;
                 break;
              }
            }
            retcode = 0;
            sscanf(CommLineIn,"%d",&retcode);
            if(retcode == 451 || retcode == 450) {
               cptr = "Mailing Failed";
               mbcode = MB_OK|MB_ICONEXCLAMATION;
               done = TRUE;
            } else if(retcode == 250) {
               cptr = "Message sent OK";
               mbcode = MB_OK;
               done = TRUE;
            }
            if(done) {
               CommBusy = FALSE;
               CommState = ST_NONE;
               MessageBox(hWndPostEdit,CommLineIn+4,cptr,mbcode);
            }
            break;
d842 5
a846 5
      case ST_GROUP_REJOIN:
         CommState = ST_ARTICLE_RESP;
         break;
      }
   }
@



1.5
log
@clicking on a group that doesn't exist is correctly handled.
the prematurely created group window is destroyed correctly
after telling the user it doesn't exist.
@
text
@d3 1
a3 1
 * $Id: wvutil.c 1.4 1993/04/23 22:10:48 rushing Exp rushing $
d5 5
d153 1
a153 2
   while(    (CommState != ST_NONE)
          && ((ch = MRRReadComm()) >= 0)) {
d209 12
a220 12
    case 5:
      MessageBox (hWndConf, "News Server Error", "WinVN", MB_OK | MB_ICONHAND);
      CommBusy = FALSE;
      CommState = ST_NONE;
      return (1);
      break;
    case 4:
      MessageBox (hWndConf, "News Server No Longer Available", "WinVN", MB_OK | MB_ICONHAND);
      MRRCloseComm ();
      PostQuitMessage (0);
      return (1);
      break;
@



1.4
log
@added function check_server_code and used it
to watch for server and other errors, rather
than just ignoring and crashing 8^)
@
text
@d3 1
a3 1
 * $Id: wvutil.c 1.3 1993/02/18 20:34:16 rushing Exp rushing $
d5 5
d320 19
a338 14
              case 411:
	    	MessageBox (hWndConf, "No Such Newsgroup", "Error", MB_OK | MB_ICONHAND);
	    	CommBusy = FALSE;
	    	CommState = ST_NONE;
		break;
	      case 502:
	    	MessageBox (hWndConf, "Restricted Access", "WinVN", MB_OK | MB_ICONHAND);
	    	CommBusy = FALSE;
	    	CommState = ST_NONE;
	        return;
		break;
              default:
                if (check_server_code(retcode)) return;
	        break;
d341 2
a342 1
            sscanf(CommLineIn,"%u %u %ld %ld %s",&retcode,&estnum,&first,&last,group);
d345 2
a346 1
      	LockLine(CommDoc->hParentBlock,CommDoc->ParentOffset,CommDoc->ParentLineID,&BlockPtr,&LinePtr);
@



1.3
log
@set CommState to ST_NONE after closing connection.
@
text
@d3 5
a7 2
 * $Id: wvutil.c%v 1.2 1993/02/16 21:20:28 rushing Exp DUMOULIN $
 * $Log: wvutil.c%v $
d196 21
d280 2
a281 3
	    	MessageBox (hWndConf, CommLineIn, "Error", MB_OK | MB_ICONHAND);
		MRRCloseComm ();
		PostQuitMessage (0);
d288 6
a293 2
            sscanf(CommLineIn,"%d",&retcode);
            if(retcode != 215) break;
d313 3
a315 3
            sscanf(CommLineIn,"%u %u %ld %ld %s",&retcode,&estnum,&first,&last,group);
	    CommDoc->TotalLines = estnum;
	    if (retcode == 415) {
d320 9
d330 3
a332 1
            if(retcode < 100) break;
d410 1
a410 1
            if(retcode < 100) break;
d452 1
a452 1
            if(retcode < 100) break;
d493 1
a493 1
            if(retcode < 100) break;
d537 1
a537 1
            if(retcode < 100) break;
d610 1
a610 1
            if(retcode < 100) break;
d715 3
a717 4
            sscanf(CommLineIn,"%d",&retcode);
            if(retcode <= 0) {
               break;
            } else if(retcode == 340) {
d720 1
d749 3
a751 1
            }
d759 3
d814 2
@



1.2
log
@Added a function (initialize_header_array) to ensure
valid data in the header array in case a WM_PAINT gets
sent to the group window before the retrieval is finished.
@
text
@d3 1
a3 1
 * $Id: wvutil.c%v 1.1 1993/02/16 20:54:22 rushing Exp rushing $
d5 5
d140 2
a141 2
   while((ch = MRRReadComm()) >= 0) {
      /*   putchar(ch); */  /* debug */
@



1.1
log
@Initial revision
@
text
@d3 4
a6 2
 * $Id$
 * $Log$
d8 1
d164 23
d299 7
a305 4
            (((TypGroup far *) ((char far *) LinePtr + sizeof(TypLine)) )->ServerEstNum) = estnum;
            (((TypGroup far *) ((char far *) LinePtr + sizeof(TypLine)) )->ServerFirst ) = first;
            (((TypGroup far *) ((char far *) LinePtr + sizeof(TypLine)) )->ServerLast  ) = last;
            GlobalUnlock(BlockPtr->hCurBlock);
@

