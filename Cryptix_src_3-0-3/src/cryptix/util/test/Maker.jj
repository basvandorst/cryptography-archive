// $Id: Maker.jj,v 1.5 1998/01/12 04:13:34 hopwood Exp $
//
// $Log: Maker.jj,v $
// Revision 1.5  1998/01/12 04:13:34  hopwood
// + Made engineTest() protected.
//
// Revision 1.4  1997/12/22 15:17:00  raif
// *** empty log message ***
//
// Revision 1.3.1  1997/12/22  raif
// + use BaseTest class and methods to implement the exit() conventions.
// + cosmetics.
//
// Revision 1.3  1997/11/22 07:05:42  raif
// *** empty log message ***
//
// + added support for mds that implement java.security.Parameterized.
//
// Revision 1.2  1997/11/20 19:57:35  hopwood
// + cryptix.util.* name changes.
//
// Revision 1.1.1  1997/11/16  David Hopwood
// + Changed occurrences of
//   "x.length < 33 ? Hex.toString(x) : Hex.dumpString(x)"
//   to "Hex.dumpString(x)". Hex.dumpString has been changed so that
//   this will have the same effect.
//
// Revision 1.1  1997/11/13 04:14:30  raif
// + Original version.
//
// $Endlog$
/*
 * Copyright (c) 1997 Systemics Ltd
 * on behalf of the Cryptix Development Team. All rights reserved.
 */

/**
 * A javaCC input file for Cryptix security provider test interpreter.
 * <p>
 * <b>Copyright</b> &copy; 1997
 * <a href="http://www.systemics.com/">Systemics Ltd</a> on behalf of the
 * <a href="http://www.systemics.com/docs/cryptix/">Cryptix Development Team</a>.
 * <br>All rights reserved.
 * <p>
 * <b>$Revision: 1.5 $</b>
 * @author  Raif S. Naffah
 */
options {
    DEBUG_PARSER = true;
    STATIC =       false;
}


PARSER_BEGIN(Maker)

package cryptix.util.test;

import cryptix.test.BaseTest;
import cryptix.util.core.ArrayUtil;
import cryptix.util.core.Hex;
import cryptix.provider.key.RawSecretKey;

import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.PrintWriter;
import java.security.Cipher;
import java.security.FeedbackCipher;
import java.security.MessageDigest;
import java.security.Mode;
import java.security.Parameterized;
import java.util.Date;
import java.util.Enumeration;
import java.util.Hashtable;
import java.util.StringTokenizer;


public class Maker
extends BaseTest
{
    /** current MessageDigest algorithm implementation being tested */
    private MessageDigest md;
    
    /** current cipher algorithm implementation being tested as a Cipher */
    private Cipher algc;
    
    /** current cipher algorithm implementation being tested as a Mode */
    private Mode algm;

    /** name of the class being tested. */
    private String implementation;

    /** name of the mode in which to run a cipher algorithm. */
    private String mode;

    /** padding scheme to use with the cipher algorithm. */
    private String padding;
    
    /** iv value for the current cipher. */
    private byte[] iv;

    /** algorithm specific property values for this round. */
    private Hashtable properties = new Hashtable();

    /** global counter for all test rounds. */
    private int gCount;

    /** counter for each individual test module. */
    private int count;

    private static final String HEADER =
        "Cryptix security provider algorithm implementation test interpreter\n" +
        "Version: $Revision: 1.5 $\n" +
        "Copyright (c) 1997, Systemics Ltd on behalf of the\n" +
        "Cryptix Development Team. All rights reserved.\n";

    private static final String USAGE =
        "Usage:\n" +
        "\tjava cryptix.util.test.Maker inputfile [ > outputfile ]\n" +
        "\tjava cryptix.util.test.Maker < inputfile [ > outputfile ]\n";

    private static final String SEPARATOR =
        "\n------------------------------------------------------------\n";


    public static void main (String[] args) {
        Maker parser;
        if (args.length == 0) {
            System.out.println(HEADER);
            System.out.println("Parsing standard input...\n");
            parser = new Maker(System.in);
        } else if (args.length == 1) {
            System.out.println(HEADER);
            System.out.println("Parsing " + args[0] + "...\n" );
            try { parser = new Maker(new FileInputStream(args[0])); }
            catch (FileNotFoundException e) {
                System.out.println("File '" + args[0] + "' not found.");
                return;
            }
        } else {
            System.out.println(USAGE);
            return;
        }
        parser.commandline(new String[0]);
/*
        try {
            parser.Specification();
            System.out.println("Done parsing :-)");
        } catch (ParseException e) {
            System.out.println("Failed parsing :-(");
            System.out.println(e.getMessage());
            e.printStackTrace();
        }
*/
    }

    protected void engineTest ()
    throws Exception {
        Specification();
    }
}

PARSER_END(Maker)


// Terminal definitions =====================================================

SKIP:                                                               // Whites
{
    " " | "\t" | "\n" | "\r" | "\f"
}

SPECIAL_TOKEN:                                                    // Comments
{
    <COMMENT: "//" ( ~[ "\n", "\r" ] )* ( "\n" | "\r" | "\r\n" ) >
}

TOKEN:  // Keywords defined as terminals here so they can be easily localised
{
    <MESSAGE_DIGEST:    "md" >
|   <CIPHER:            "cipher" >
|   <PROPERTIES:        "property" | "properties" >
|   <DATA:              "data" >
|   <MODE:              "mode" >
|   <PADDING:           "padding" >
|   <IV:                "iv" >
|   <AUTO:              "auto" >
|   <SPEED:             "speed" >
|   <INCLUDE:           "include" >
}



MORE:                    // Special handling of the hexadecimal literal token
{
    "<" : IN_HEX_LITERAL
}

<IN_HEX_LITERAL>
TOKEN:
{
    <HEX_LITERAL: ">" >
        {
            String h = image.toString();
            // get rid of the enclosing angle brackets
            matchedToken.image = h.substring(1, h.length() - 1);
        }
    : DEFAULT
}

<IN_HEX_LITERAL>
MORE:
{
    < ~[] >
}

TOKEN:
{
    <ID:        ["A"-"Z"] ( <LETTER> | <DIGIT> )* >
|   <PROPERTY:  ["A"-"Z", "a"-"z"] ( <LETTER> | <DIGIT> )* >
|   <#LETTER:   ["A"-"Z", "a"-"z", "-", "#" ] >
|   <#DIGIT:    ["0"-"9" ] >
}


TOKEN:                                                            // Literals
{
    <NUMBER:        ( [ "0"-"9" ] )+ >
|   <STRING_LITERAL:
        "\""
        (   ( ~["\"", "\\", "\n", "\r"] )
          | ( "\\" ( [ "n", "t", "b", "r", "f", "\\", "'", "\""] ) )
        )*
        "\""
    >  
}


// FILE / MODULE SPECIFICATION ==============================================

void Specification(): {
    disable_tracing();
    gCount = 0;
}{
    ( TestModule() )+
    <EOF>
}

void TestModule(): {}{
    MessageDigestTest()
|   CipherTest()
|   IncludedTest()
}


// Message Digest ===========================================================

void MessageDigestTest(): {}
{
    <MESSAGE_DIGEST> implementation = Identifier()
        {
            // set default values and initialise various vars
            algc = null;
            algm = null;
            properties.clear();
            count = 0;
        }
    (   [ MessageDigestProperties() ]
        <DATA>
            {
                String algorithm;
                System.out.println("\n" + (++gCount) + ". " + implementation +
                    " test round #" + (++count) + "...");

                // at this point we can instantiate an md
                try { md = MessageDigest.getInstance(implementation); }
                catch (Throwable e) {
                    e.printStackTrace();
                    throw new Error(e.getMessage());
                }
                // now set algorithm specific properties if any. For this we
                // have to implement a new interface for the MessageDigest
                // classes that offers set/getParameter() methods similar to
                // what java.security.Cipher does. For the time being cripple it
                //
                // as of 22.11.97 we now have java.security.Parameterized.
                // use it if properties is not empty.
                //
                if (properties.isEmpty()) return;
                if (md instanceof Parameterized) {
                    Enumeration keys = properties.keys();
                    String aProperty;
                    Object aValue;
                    while (keys.hasMoreElements()) {
                        aProperty = (String) keys.nextElement();
                        aValue = properties.get(aProperty);
                        System.out.println("  " + aProperty + ":\t" + aValue);
                        try { ((Parameterized) md).setParameter(aProperty, aValue); }
                        catch (Throwable e1) {
                            e1.printStackTrace();
                            throw new Error(e1.getMessage());
                        }
                    }
                } else
                    System.out.println("Message digest " + implementation +
                        " does not implement java.security.Parameterized.\n" +
                        "Will ignore requested property values...");
            }
        ( MessageDigestData() )+
            {
                System.out.println(SEPARATOR);
            }
    )+
}

void MessageDigestProperties(): {}{
    <PROPERTIES>
    ( AlgorithmSpecificProperty() )+
}

void MessageDigestData(): {}
{
    SingleIterationData()
|   MultiIterationData()
}

void SingleIterationData(): {
    Token t;
    byte[] certified;
}{
    t = <STRING_LITERAL>
    certified = HexadecimalData()
        {
            System.out.println("  input:  " + t.image);
            String message = t.image.substring(1, t.image.length() - 1);
            System.out.println(" digest:  " + Hex.toString(certified));

            byte[] computed = md.digest(message.getBytes());
            boolean ok = ArrayUtil.areEqual(certified, computed);
            passIf(ok, "\nDigest operation");
            if (! ok) {
//                System.out.print("\nDigest operation failed... Computed value is: ");
//                System.out.println(Hex.toString(computed));
                System.out.println("Computed value is: " + Hex.toString(computed));
            }
            System.out.println();
        }
}

void MultiIterationData(): {
    Token n, t;
    long limit;
    byte[] certified;
}{
    n = <NUMBER> "*" t = <STRING_LITERAL>
    certified = HexadecimalData()
        {
            limit = new Long(n.image).longValue();
            System.out.println("  input:  " + limit + " times " + t.image);
            String message = t.image.substring(1, t.image.length() - 1);
            System.out.println(" digest:  " + Hex.toString(certified));

            byte[] unit = message.getBytes();
            for (long i = 0; i < limit; i++) md.update(unit);
            byte[] computed = md.digest();
            boolean ok = ArrayUtil.areEqual(certified, computed);
            passIf(ok, "\nDigest operation");
            if (! ok) {
//                System.out.print("\nDigest operation failed... Computed digest is: ");
//                System.out.println(Hex.toString(computed));
                System.out.println("Computed digest is: " + Hex.toString(computed));
            }
            System.out.println();
        }
}


// Cipher ===================================================================

void CipherTest(): {}
{
    <CIPHER> implementation = Identifier()
        {
            // set default values for mode and padding
            mode = "ECB";
            padding = "NONE";
            iv = null;
            md = null;
            properties.clear();
            count = 0;
        }
    (   [ CipherProperties() ]
        <DATA>
            {
                String algorithm;
                System.out.println("\n" + (++gCount) + ". " + implementation +
                    " test round #" + (++count) + "...");
                System.out.println("  mode:\t\t" + mode);
                if (padding != null) {
                    System.out.println("  padding:\t" + padding);
                    algorithm = implementation + "/" + mode + "/" + padding;
                } else
                    algorithm = implementation + "/" + mode;

                // at this point we can instantiate a cipher
                try { algm = (Mode) Cipher.getInstance(algorithm); }
                catch (ClassCastException e1) {
                    // we're running in ECB mode (assuming Cryptix provider)
                    algm = null;
                    try { algc = Cipher.getInstance(algorithm); }
                    catch (Throwable e2) {
                        e2.printStackTrace();
                        throw new Error(e2.getMessage());
                    }
                }
                catch (Throwable e3) {
                    e3.printStackTrace();
                    throw new Error(e3.getMessage());
                }
                if (iv != null) {
                    System.out.println("  iv:\t\t" + Hex.toString(iv));
                    ((FeedbackCipher) algm).setInitializationVector(iv);
                }
                // at this point we won't need algm anymore
                if (algm != null) algc = algm;

                // now set algorithm specific properties if any
                Enumeration keys = properties.keys();
                String aProperty;
                Object aValue;
                while (keys.hasMoreElements()) {
                    aProperty = (String) keys.nextElement();
                    aValue = properties.get(aProperty);
                    System.out.println("  " + aProperty + ":\t" + aValue);
                    try { algc.setParameter(aProperty, aValue); }
                    catch (Throwable e1) {
                        e1.printStackTrace();
                        throw new Error(e1.getMessage());
                    }
                }
            }
        ( CipherData() )+
            {
                System.out.println(SEPARATOR);
            }
    )+
}

void CipherProperties(): {}{
    <PROPERTIES>
    [ <MODE> mode = Identifier() ]
    [ <PADDING> padding = Identifier() ]
    [ <IV> iv = HexadecimalData() ]
    [ ( AlgorithmSpecificProperty() )+ ]
}

void CipherData(): {}
{
    LOOKAHEAD(3) TwoWayTestData()
|   LOOKAHEAD(3) SymmetricTestData()
|   SpeedTestData()
}

void TwoWayTestData(): {
    byte[] k, p, c;
}{
    k = HexadecimalData()    // the key
    p = HexadecimalData()    // the plaintext
    c = HexadecimalData()    // the ciphertext
    {
        try {
            System.out.print("  key:\t\t");
            System.out.println(Hex.dumpString(k));

            System.out.print("  input:\t");
            System.out.println(Hex.dumpString(p));

            System.out.print("  output:\t");
            System.out.println(Hex.dumpString(c));

            RawSecretKey key = new RawSecretKey(implementation, k);

            algc.initEncrypt(key);
            byte[] computed = algc.crypt(p);
            boolean ok = ArrayUtil.areEqual(c, computed);
            passIf(ok, "\nEncryption");
            if (! ok) {
//                System.out.print("\nEncryption failed... Computed output is: ");
//                System.out.println(Hex.dumpString(computed));
                System.out.println("Computed output is: " + Hex.dumpString(computed));
            }
            algc.initDecrypt(key);
            computed = algc.crypt(c);
            ok = ArrayUtil.areEqual(p, computed);
            passIf(ok, "\nDecryption");
            if (! ok) {
//                System.out.print("\nDecryption failed... Computed input is: ");
//                System.out.println(Hex.dumpString(computed));
                System.out.print("Computed input is: " + Hex.dumpString(computed));
            }
            System.out.println();
        }
        catch (Throwable e) {
            e.printStackTrace();
            throw new Error(e.getMessage());
        }
    }
}

void SymmetricTestData(): {
    byte[] k, p;
}{
    k = HexadecimalData()     // the key
    p = HexadecimalData()     // the plaintext
    <AUTO>
    {
        try {
            System.out.print("  key:\t\t");
            System.out.println(Hex.dumpString(k));

            System.out.print("  input:\t");
            System.out.println(Hex.dumpString(p));

            RawSecretKey key = new RawSecretKey(implementation, k);

            algc.initEncrypt(key);
            byte[] computed = algc.crypt(p);

            // now decrypt this result to check if we get the
            // original plaintext
            algc.initDecrypt(key);
            computed = algc.crypt(computed);
            boolean ok = ArrayUtil.areEqual(p, computed);
            passIf(ok, "\nSymmetric operation");
            if (! ok) {
//                System.out.print("\nSymmetric operation failed... Computed input is: ");
//                System.out.println(Hex.dumpString(computed));
                System.out.println("Computed input is: " + Hex.dumpString(computed));
            }
            System.out.println();
        }
        catch (Throwable e) {
            e.printStackTrace();
            throw new Error(e.getMessage());
        }
    }
}

void SpeedTestData(): {
    byte[] k, p;
}{
    k = HexadecimalData()     // the key
    p = HexadecimalData()     // the plaintext
    <SPEED>
    {
        try {
            System.out.print("  key:\t\t");
            System.out.println(Hex.dumpString(k));

            System.out.print("  input:\t");
            System.out.println(Hex.dumpString(p));

            byte[] c = (byte[]) p.clone();
            int inLen = c.length;
            int i, j;

            RawSecretKey key = new RawSecretKey(implementation, k);

            System.out.println("\nSpeed tests over 100,000 * " + inLen + " bytes...\n");

            algc.initEncrypt(key);
            System.out.println("Encryption...");
            System.out.println("  start date/time:  " + new Date().toString());
            for (i = 0; i < 100; i++)
                for (j = 0; j < 1000; j++) algc.update(c, 0, inLen, c, 0);
            System.out.println("  finish date/time: " + new Date().toString());

            algc.initDecrypt(key);
            System.out.println("\nDecryption...");
            System.out.println("  start date/time:  " + new Date().toString());
            for (i = 0; i < 100; i++)
                for (j = 0; j < 1000; j++) algc.update(c, 0, inLen, c, 0);
            System.out.println("  finish date/time: " + new Date().toString());

            boolean ok = ArrayUtil.areEqual(p, c);
            passIf(ok, "\nSymmetric operation");
            if (! ok) {
//                System.out.print("\nSymmetric operation failed... Computed input is: ");
//                System.out.println(Hex.dumpString(c));
                System.out.println("Computed input is: " + Hex.dumpString(c));
            }
            System.out.println();
        }
        catch (Throwable e) {
            e.printStackTrace();
            throw new Error(e.getMessage());
        }
    }
}


// Algorithm specific properties ............................................

void AlgorithmSpecificProperty(): {
    Token p, v;
    String property;
}{
    p = <PROPERTY> "="
        {
            property = p.image;
        }
    (   v = <NUMBER>
            {
                properties.put(property, new Integer(v.image));
            }
    |   v = <STRING_LITERAL>
            {
                // get rid of the surrounding double-quotes
                properties.put(property, v.image.substring(1, v.image.length() - 1));
            }
    )
}


// Special non-terminals ....................................................

String Identifier(): {
    Token t;
}{
    t = <ID>
        {
            return t.image;
        }
}

byte[] HexadecimalData(): {
    Token t;
}{
    t = <HEX_LITERAL>
        {
            String s = t.image;
            // should get rid of delimiter characters in s before
            // passing it to Hex
            String news = "";
            StringTokenizer st = new StringTokenizer(s);
            while (st.hasMoreTokens()) news += st.nextToken();
            return Hex.fromString(news);
        }
}


// Included test ============================================================

void IncludedTest(): {
    Token t;
}{
    <INCLUDE> t = <STRING_LITERAL>
        {
            Maker embedded = null;
            String f = t.image.substring(1, t.image.length() - 1);
            System.out.println("Begin included file " + f + "...\n" );
            try { embedded = new Maker(new FileInputStream(f)); }
            catch (FileNotFoundException e) {
                System.out.println("File '" + f + "' not found...\n");
                System.out.println("End included file " + f + "...\n");
                return;
            }
            try {
                embedded.Specification();
//                System.out.println("Done parsing included file " + f + "...\n");
                pass("Parsing included file " + f);
            } catch (ParseException e) {
//                System.out.println("Failed parsing included file " + f + "...\n");
                fail("Parsing included file " + f);
                System.out.println(e.getMessage());
                e.printStackTrace();
            }
        }
}
