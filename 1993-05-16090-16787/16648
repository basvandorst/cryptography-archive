Path: msuinfo!uwm.edu!ux1.cso.uiuc.edu!howland.reston.ans.net!darwin.sura.net!haven.umd.edu!news.umbc.edu!olson
From: olson@umbc.edu (Bryan G. Olson)
Newsgroups: sci.crypt
Subject: Re: Rubber-hose-resistant crypto file system
Date: 23 May 1993 19:56:43 -0400
Organization: University of Maryland, Baltimore County Campus
Lines: 94
Sender: olson@umbc.edu (Mr. Bryan G. Olson; CMSC (G))
Distribution: world
Message-ID: <1tp2vrINNgve@umbc7.umbc.edu>
References: <1tdjpjINNkk1@hal.com>
NNTP-Posting-Host: umbc7.umbc.edu
X-Auth-User: olson
Keywords: cryptographic file system, notebook computer


I'll quote a lot and delete a lot, so you can just barely follow
Howard Gayle's very clever idea, even if you didn't read his post.

In article <1tdjpjINNkk1@hal.com>, howard@hal.com (Howard Gayle) writes:
|> 
|>       ABSTRACT
|> 
|> I sketch the design of an encrypted file system for a notebook
|> computer.  The system allows for the use of multiple keys.  If
|> only some of the keys are known, then only the files encrypted
|> with those keys are accessible.  Files encrypted with unknown
|> keys are indistinguishable from free space in the file system.
|>
 [...]
|> 
|> When a file system is initialized, it is filled with chunks
|> whose sizes are taken from a random distribution that captures
|> the statistical properties of real files.  Except for the chunk
|> header, each chunk is initialized with random bytes.
|> 
|> To add a file:
 [...] 
|> 5) Pick some free chunk, and replace the random bytes after the
|>    chunk header with the encrypted session key block followed by
|>    the encrypted file block.  The free chunk that is picked must
|>    of course be big enough to hold everything.  Ideally, it
|>    should be picked at random from among those of the right
|>    size.
 [...]
|> 
|>       PLAUSIBLE DENIABILITY
|> 
|> Alice actually used two keys, one for a sanitized version of
|> her notes, and one for the raw notes.  She revealed only the
|> first key.  Bob may suspect that some of the "free space" on
|> the file system is actually encrypted files, but he can not
|> prove this.
|> 

	I like Gayle's system but there are some problems.

	First and formost, to avoid detection the "chunks" of 
space in the file system must not only follow the over all 
distribution of lengths of files, but the files encrypted under 
each individual key must also follow this same distribution.  
If this is not the case an adversary could tell by looking at 
the sizes of chunks used and the sizes of known files they hold, 
that there must have been chunks which were not eligable for use.  
I don't think file sizes are predictable enough.

	As Gayle notes, the user will normally enter all keys,
since writing to the system without all the keys could overwrite 
files.  I think the most practical way to build the system is 
to have a master key to the system which unlocks all the other 
keys, rather than have independent keys.  Of course, given only 
a non-master key, the system must make this key look like the 
master key.

	Suppose we build a crypto-file-system which keeps all 
the data encrypted and fills empty space with random bits.  Now 
we build in an option, available in every system, which adds a 
second key.  

	We now have the true key, and an "alibi" key.  When the
user enters the true key, the system finds the alibi key, and 
two sets of files: those stored under the true key and those 
stored under the alibi key.  

	If someone enters the alibi key, then this key appears 
to be the true key, and the alibi option appears not to be in use.  
All the space taken up by the true files and overhead information 
appears to be empty space on the alibi disk.  

	The user only writes to the alibi disk when using the 
system under the true key.  When alocating space for an alibi file, 
the system simpy uses the next block which is not in use on the 
alibi disk. If this block is in use on the true disk, then the true 
disk's data is moved.  This assures that the distribution of files 
on the alibi disk will be the same as the distribution on a true
disk with no alibi disk in use.  It does mean that the file system
can not depend on any structure being contiguouse across blocks.

	We could, of course, allow multiple alibis under one true 
key, and alibis within alibis.

	Is such a system practical ?  Worth building ?

Bryan Olson
olson@umbc.edu

		

	
