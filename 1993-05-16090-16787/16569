Path: msuinfo!uwm.edu!zaphod.mps.ohio-state.edu!darwin.sura.net!udel!sbcs.sunysb.edu!max.physics.sunysb.edu!hanche
From: hanche@ams.sunysb.edu (Harald Hanche-Olsen)
Newsgroups: sci.crypt
Subject: Re: A different naive question (on RSA)
Date: 18 May 93 12:18:57
Organization: University at Stony Brook, NY
Lines: 26
Message-ID: <HANCHE.93May18121857@ptolemy.ams.sunysb.edu>
References: <DAR.93May17192623@viking.lanl.gov> <1ta1k0INNs89@twain.ucs.umass.edu>
NNTP-Posting-Host: ptolemy.ams.sunysb.edu
In-reply-to: quilty@twain.ucs.umass.edu's message of 18 May 1993 03:01:20 -0400

>>>>> In article <1ta1k0INNs89@twain.ucs.umass.edu>,
>>>>> quilty@twain.ucs.umass.edu (Lulu of the lotus-eaters) writes:

Lulu> I don't actually know how one goes
Lulu> about generating a 256 digit (binary) prime -- so if anyone can tell
Lulu> me really quick, I'd be extremely interested.

The simplest way is to pick large integers at random and then checking
to see whether you found a prime.  You can use deterministic or
stochastic methods (which yield the correct answer with probability
very close to 1) for for the latter.  Of course, more efficient
variations on this theme exist, like picking a suitable interval of
integers and sieving out multiples of small primes before testing the
remaining numbers.

Lulu> I know one has to locate large numbers satisfying:

Lulu> 	de-1 = n [(p-1)(q-1)+1]		; for an integer n

Lulu> But it's not clear to me why it's automatically easy to find such d
Lulu> and e.  I'm sure I'll kick myself after someone explains it, and I see
Lulu> just how simple it is -- but could someone please do this.

Look up Euclid's algorithm.  Then, go kick yourself.  ;-)

- Harald
