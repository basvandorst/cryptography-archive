Newsgroups: sci.crypt
Path: msuinfo!agate!howland.reston.ans.net!gatech!ukma!mont!mizzou1.missouri.edu!C445585
From: C445585@mizzou1.missouri.edu (John Kelsey)
Subject: One-time pads and security
Message-ID: <16BC610308.C445585@mizzou1.missouri.edu>
Sender: news@mont.cs.missouri.edu
Nntp-Posting-Host: mizzou1.missouri.edu
Organization: University of Missouri
Date: Thu, 06 May 93 18:25:12 CDT
Lines: 113

   Several people pointed out the error I made in an earlier post, though
everyone seemed to make spoofing more complicated than it needed to be.  All
Eve had to do was flip the encrypted parity bit when she flipped the encrypted
plaintext bit.  No difficuly at all.
 
   Greg Rose commented that spoofing of one-time-pad-encrypted messages as
discussed wasn't likely to be a real life problem.  However, I think it *is*.
There are quite a few people who use stream ciphers that aren't dependent on
anything but their key ("self-synchronizing," I think).  Any block cipher in
output-feedback mode can be used this way.  The same kind of bit-twiddling
attack can be used on this sort of scheme as on a one-time pad.  (There was
a really good article on using DES in OFB mode in the Crypto '82 procedings,
but I don't recall the article's name.  Similar bit-twiddling attacks were
mentioned in Denning's textbook on Cryptography and Data Security.)
 
   Detlef Lannert (Did I get the name right) came up with the scheme that I
came up with last night after reading netnews--my original idea was basically
workable, but it should have been implemented with AND instead of XOR, and it
shouldn't have sent the pad bit used.  Let me put that into my own notation:
 
   There are 2 ciphertext bytes sent per plaintext byte, and 3 pad bytes used
up.  c(i) is the ith bit of ciphertext, r(i) is the ith bit of shared random
pad, and m(i) is the ith bit of message text.
 
   For i = 0 to length_of_message_text -1:
       c(2*i) = m(i) XOR r(3*i)
       c(2*i+1) = ( m(i) AND r(3*i+1) ) XOR r(3*i+2)
 
   Assuming Eve wants to flip bit m(i), but doesn't know what it is:
She faces two possibilities:
 
   1.  r(3*i+1) = 0:  In this case, she can just flip c(2*i), since
                      anything AND 0 = 0.
 
   2.  r(3*i+1) = 1:  In this case, she can just flip c(2*i) and flip
                      c(2*i+1), since 1 AND anything = anything.
 
   Now, does Eve's knowledge about m(i) give her any help in spoofing a
message?
 
   Eve knows m(i) = 0.  This implies that, regardless of r(3*i+1), she
knows that ( m(i) AND r(3*i+1) ) = 0.  If she wants to flip m(i) to a 1,
she must guess whether r(3*i+1) is a 1 or a 0.  If it's a 1, she must
flip c(2*i+1), because ( 1 AND 1 ) is 1.  If it's a zero, then she must
*not* flip c(2*i+1), because ( 1 AND 0) is 0.  She can't guess r(3*i+1)
with better than probability of 0.5.
   Eve knows m(i) = 1.  This implies that ( m(i) AND r(3*i+1) ) = r(3*i+1).
If Eve could get r(3*i+1), she could decide what to do, but it's encrypted
with another part of the pad, and thus secure.  (This is why it's important
to encrypt ( m(i) AND r(3*i+1) ). )  She wants to flip it to a 0.  She's
faced with the same guess.  If r(3*i+1) = 0, then she must flip c(2*i) alone,
since ( 1 AND 0) = (0 AND 0) = 0.  If r(3*i+1) = 1, then she must flip both
c(2*i) and c(2*i+1), since (1 AND 1) = 1, but (0 AND 1) = 0.
 
   Unless I'm missing something big (as I did last time), this scheme leaves
Eve with Probability(changing q bits without detection) = (1/2)** n, and it
leaves her in no better position to spoof messages she knows than messages
she doesn't know.
 
   Unfortunately, this sort of scheme leaves a rather big hole.  Suppose
Eve knows that Alice is sending Bob an instruction about how much money to
give Eve, and that the dollar amount is in a 32-bit unsigned field.  She
can take a 50/50 chance on flipping the high-order bit, and make an enormous
profit.  (Presumably, she'd have to choose a lower-order bit, since $ 2**32
would probably be a little unusual to send to Eve.  But the idea remains the
same.)  If it's caught, it will probably look suspiscious, but Eve may claim
that she had nothing to do with it--maybe it was a transmission error.
 
   Is there a way to provide provable security equivalant to one-time-pad
encryption against a single-bit change?  *I* don't see one.  Transposing the
bits in the message will drop Eve's probability of a successful bit-flip of
her own field to 1/n (n = length of ciphertext).  Still, if she can disavow
any attacks made, there's no reason for her not to try--what's she got to lose?
If *her* amount field is decreased, she can probably go in and complain.
(Also, if Eve is an enemy of Alice, she may simply delight in causing Alice
and her customers/creditors/employees problems.)
 
   I can see quite a few practical solutions, though none of them provide
provable authenticity.
 
   1.  Assume the existence of a message digest function F(), which calculates
       a hash value of length L bits.  Calculate H = F(X||M), where X is a
       string of pad bits at least L bits long, M is the message string, and
       || represents concatenation.  Encrypt M||H with the one-time pad in
       the normal way.  This is no more secure from spoofing than the message
       digest funtion, but it uses only a small number of extra bits.
 
   2.  If the above scheme isn't strong enough for your tastes, then simply
       encrypt the message twice, using (and discarding) n bits of the pad
       each time (where n = length of the message text).  Form the hash from
       the message digest of the first encrypted message, and then encrypt it
       along with the second encrypted message, and send it.
 
   Both of these look like they at least make Eve's single-bit changes much
harder.  I can't see how to prove security of either one, though #2 seems to
be quite strong--even if Eve knows how to forge signatures using F, she can't
get to the message digest, since it's encrypted with the pad.  She doesn't know
even one bit of the input to F().  (Am I missing something?)  If L (length of
the hash value) is enormously smaller than the length of the message text, then
I don't see how Eve could invert even a very weak hash function to get more
than L bits of the input to F().  Since the input to F() was a perfectly random
stream of bits, it shouldn't be possible to compress more than L bits of it
into the hash value.  (Anyone see a good way of doing in information-theoretic
proof on this?)
 
 
   Obviously, there are dozens of variations on using a message-digest function
to secure a message.
 
   I'll post another message in a second, because I found an article in the
Crypto '85 procedings that discusses exactly this problem.
 
   --John Kelsey, c445585@mizzou1.missouri.edu
