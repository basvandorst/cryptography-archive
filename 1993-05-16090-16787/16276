Path: msuinfo!uwm.edu!cs.utexas.edu!zaphod.mps.ohio-state.edu!saimiri.primate.wisc.edu!usenet.coe.montana.edu!news.uoregon.edu!netnews.nwnet.net!news.u.washington.edu!shelley.u.washington.edu!biffs
From: biffs@shelley.u.washington.edu (Randolf Smith)
Newsgroups: sci.crypt
Subject: Re: One-time pad authentication?
Date: 4 May 1993 08:14:06 GMT
Organization: University of Washington, Seattle
Lines: 58
Message-ID: <1s58keINNbr@news.u.washington.edu>
References: <9304290024.AA02249@pizzabox.demon.co.uk> <strnlghtC6BKwv.19C@netcom.com> <16BC2116C6.C445585@mizzou1.missouri.edu>
NNTP-Posting-Host: shelley.u.washington.edu

In article <16BC2116C6.C445585@mizzou1.missouri.edu> C445585@mizzou1.missouri.edu (John Kelsey) writes:
>
>   I can think of a couple of ways of guaranteeing authenticity in a one-time
>pad encrytped scheme, though I'm not sure how to prove that what kind of
>authenicity they provide.
>  ... 
>   Now, I can see a simple way of doing this that's got to be as secure
>as a one-time pad, at a cost of using 4 times the message length in pad bits.
> 
>   For each message bit, M_i, use one random bit, R_i, and xor them together
>to get X_i.  Now, encrypt the three bits with the one-time pad.  The enemy
>has no way of guessing what R_i is, so he/she can't guess what X_i is, either.
>Any change she makes in the ciphertext stream will have to involve a guess
>of what R_i was.  Is there any way to do this without using so many pad bits?

I'm not quite sure if this would work, at least the way I understand it.  Say
M is the message bit, D1 (data) is the Xor of it and R1 (a bit of the pad).  
The second bit (D2) is Ri xor R2, and seems a bit redundant, because it is
pre-determined by the codebooks.  The last bit, D3, is determined by Ri and 
R3 and D.  D and d3 are still related (not d = not d3), so if d changes, 
all you need to do is change d3.  The other people can't know Ri, R3, R2, or
X_i, but that doesn't matter because they can get d3.

Your idea is along the right track, though.  Generally, the equation for the 
stream would be xor(r1, m), cs(r2, m).  (cs = checksum) The important part 
is that knowing cs(r2, m) and m won't give you r2, and ideally you shouldn't 
get any information about r2 useful in determining cs.  Unfortunately this is 
tough to do.  I think.  Well, here's the bit table I came up with:

Note: 1 message bit, 1 checksum bit, 2 known random bits, 2 identical tables.
m cs|R2    m cs|R2     ||     m R2|cs    m R2|cs
0 0 |00    1 0 |00     ||     0 00|0     1 00|0
0 0 |01    1 0 |10     ||     0 10|1     1 01|1
0 1 |10    1 1 |01     ||     0 01|0     1 10|0
0 1 |11    1 1 |11     ||     0 11|1     1 11|1

Dual Xor looks like: (again, 2 identical tables.)
m cs|R2    m cs|R2     ||     m R2|cs    m R2|cs
0 0 |00    1 0 |01     ||     0 01|1     1 00|1
0 0 |11    1 0 |10     ||     0 10|1     1 11|1
0 1 |01    1 1 |00     ||     0 00|0     1 01|0
0 1 |10    1 1 |11     ||     0 11|0     1 10|0

Don't take the table too seriously (I'm not a cryptographer), but it
shows the idea: while knowing m and cs tell you it's one of two R2's; that
information is useless is determining the cs for the opposite m.  (The
critical operation being determining the CS for not M, knowing cs for m) 
The 2-xor is symmetrical, and so gives the correct cs away.

This leaves a bit stream bloated to twice the normal size, and the codebook
being eaten up at 3 times the normal rate.  However, they have no better 
chance of going unnoticed then without the cleartext and a normal system.
By the way, this idea could also extend to a 'perfect' checksum/signature
system.  Just don't encrypt the plaintext, attach a LONG cs tail, and give 
the checking person a pad twice as long as the plaintext. :-)

Randy Smith (biffs@u.washington.edu)

