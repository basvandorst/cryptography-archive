Newsgroups: sci.crypt
Path: msuinfo!agate!howland.reston.ans.net!gatech!ukma!mont!mizzou1.missouri.edu!C445585
From: C445585@mizzou1.missouri.edu (John Kelsey)
Subject: One-time pad authentication in Crypto '85
Message-ID: <16BC6116CA.C445585@mizzou1.missouri.edu>
Sender: news@mont.cs.missouri.edu
Nntp-Posting-Host: mizzou1.missouri.edu
Organization: University of Missouri
Date: Thu, 06 May 93 19:49:30 CDT
Lines: 74

   The article is "Unconditionally Secure Authentication Schemes and Practical
and Theoretical Consequences," author is Yvo Desmedt, and it appears in the
Crypto '85 procedings, Hugh Williams is the editor.
 
   The author comes up with a definition for unconditional security that I
have some questions about:
 
   Definition 2:  A cryptosystem protects the authenticity unconditionally
                  with a security level P if, the probabilities that an
                  intruder can inject a fraudulent message or that an active
                  eavesdropper can modify a message are less than or equal to
                  1/P, independantly of how much computertime is used.
 
   [P 45]
 
   The author goes on to comment that the security is too low for practical
use if P is too low.  (Presumably, "too low" means different things to
different users, but if you bother to use a one-time pad, it's probably
at least on the order of 2**64.)
 
   The author goes on to describe a "first-attempt" at a scheme that uses too
many pad bits, but makes a lot of intuitive sense to me.  It involves gener-
ating a bit string (from your pad) to code for a one bit, and using the same
length string of all 0's to code for zero.  Each bit (bit 25, bit 26, etc.)
gets its own bit string to code for that bit if it's a one.
 
   To put it in nice notation:
   Generate a set of codewords, w(0) .. w(n-1), each q bits long.  Form them
by taking n*q bits from the one-time pad.  (You may have to occasionally do
some bit twiddling, to ensure that you never get a codeword of all 0 bits.
 
   For each original message bit i:
      IF m(i) = 0 THEN
           Encrypt a q-bit string of zeros with the one-time pad and send it.
      ELSE
           Encrypt the q-bit codeword c(i) with the one-time pad, and send it.
 
   It's pretty easy to see that flipping a bit in this scheme is quite hard--
probability of success = (1/2)**q (** = exponentiation) if she's trying to
inject a zero.  She has a (1/2) ** (q-1) probability of injecting a one.  (Her
chances are better because she knows that at least one bit in w(i) is not a
zero.)  Unfortunately, this scheme eats bits up from the pad *fast*--at a rate
of 2*q*n, n is the length of the original message.  It also expands the
ciphertext to q*n bits.
 
   Desmedt extends the above scheme to one which (if I'm understanding this
right--you should read the article yourself anyway) adds only q bits to the
ciphertext.  The general idea is that you generate a set of codewords as
before, w(0) .. w(n-1) from the pad.  Each codeword is again q bits long.
You maintain an authenticator value, A, which is q bits long and starts as a
string of 0's.  For each message bit, you perform the following:
 
   Authenticator bit k = A(k) = A(k) XOR ( m(k) AND C(i,k) ) for k = 0 to q-1.
 
   (This just means, for each message bit, if it's a 1, then XOR that message
bit's codeword into the authenticator value, otherwise, don't.)
   Although he doesn't say it anywhere I can see, it's clear that the codewords
had better all be different, for this to work.  This makes me think of Kerfu
("Kefru?"), the single-key fast encryption scheme that Merkle came up with,
except that there is one s-box per bit, and the s-boxes are truly random.
Has anyone tried to extend this scheme into a keyed hash function, perhaps
based upon a strong block cipher (like DES) running in output feedback mode?)
 
   This scheme is better in most ways.  Eve has a probability of successfully
changing a bit in the message text of (1/2) ** (q-1).  Unfortunately, while
we don't have to expand the ciphertext much, we have to come up with q*n bits
for authentication, and (q+1) *n bits of pad altogether.
 
   Desmedt develops a better scheme, using up only 2*n bits of pad for
authentication, but I haven't read that far in the article.  After I do,
I may post more.  At any rate, you should read the article if you're inter-
ested.
 
   --John Kelsey
