Path: msuinfo!agate!howland.reston.ans.net!ira.uka.de!Germany.EU.net!unidus.rz.uni-duesseldorf.de!lannert.rz.uni-duesseldorf.de!TSOS
From: TSOS@uni-duesseldorf.de (Detlef Lannert)
Newsgroups: sci.crypt
Subject: Re: One-time pad authentication?
Date: Thu, 6 May 1993 15:28:09 GMT
Organization: Universitaetsrechenzentrum, Heinrich-Heine-Universitaet, Duesseldorf
Lines: 51
Message-ID: <TSOS.406.736702089@uni-duesseldorf.de>
References: <9304290024.AA02249@pizzabox.demon.co.uk> <strnlghtC6BKwv.19C@netcom.com> <16BC2116C6.C445585@mizzou1.missouri.edu> <1s58keINNbr@news.u.washington.edu>
NNTP-Posting-Host: lannert.rz.uni-duesseldorf.de

In article <1s58keINNbr@news.u.washington.edu> biffs@shelley.u.washington.edu (Randolf Smith) writes:

>Your idea is along the right track, though.  Generally, the equation for the 
>stream would be xor(r1, m), cs(r2, m).  (cs = checksum) The important part 
>is that knowing cs(r2, m) and m won't give you r2, and ideally you shouldn't 
>get any information about r2 useful in determining cs.  Unfortunately this is 
>tough to do.  I think.  Well, here's the bit table I came up with:
 [deleted for sake of bandwidth]
>Don't take the table too seriously (I'm not a cryptographer), but it
>shows the idea: while knowing m and cs tell you it's one of two R2's; that
>information is useless is determining the cs for the opposite m.  (The
>critical operation being determining the CS for not M, knowing cs for m) 
>The 2-xor is symmetrical, and so gives the correct cs away.
>
>This leaves a bit stream bloated to twice the normal size, and the codebook
>being eaten up at 3 times the normal rate.  However, they have no better 
>chance of going unnoticed then without the cleartext and a normal system.
>By the way, this idea could also extend to a 'perfect' checksum/signature
>system.  Just don't encrypt the plaintext, attach a LONG cs tail, and give 
>the checking person a pad twice as long as the plaintext. :-)

I'm not quite sure whether I got this right. An at least similar solution 
would be: 
     p[0, 1, ...]    plaintext
     c[0, 1, ...]    ciphertext
     r[0, 1, ...]    random one-time pad

     c[2*i]   = (p[i] &  r[3*i]) ^ r[3*i+1]
     c[2*i+1] = (p[i] & ~r[3*i]) ^ r[3*i+2]
        for i=0, 1, ...

That is, two out of three OTP bits are actually sent, and the third one 
determines which of the two gets xor-ed with the actual message bit. 
As you said, the message length gets doubled and the OTP eaten up three 
times as fast as `normal'. Evil Eve still can perform a `plaintext 
exchange' attack but the probability of being detected is 50% with each 
message bit and thus negligible if only the message is long enough. 

And another variation of this scheme: Let the k next bits of the OTP 
determine the position where a filler (zero) bit is to be inserted within 
the next 2^k-1 message bits. This causes an increase in message length by 
a factor of 2^k/(2^k-1) and an OTP consumption of (k+2^k)/(2^k-1) bits 
per plaintext bit (on average; your mileage may vary ...). The above 
example is an application of this general scheme for k=2.
 
Ok, I'll add this method as #5 to the list I posted yesterday ...
--
Detlef Lannert       DC3EK       E-Mail: tsos@rz.uni-duesseldorf.de
PGP 2.2 key via server or finger lannert@clio.rz.uni-duesseldorf.de
"I am Psmith." - "Oh, you're Smith, are you?" - "With a preliminary
P. Which, however, is not sounded."                   P.G.Wodehouse
