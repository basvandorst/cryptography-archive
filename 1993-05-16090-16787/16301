Path: msuinfo!agate!howland.reston.ans.net!ira.uka.de!Germany.EU.net!unidus.rz.uni-duesseldorf.de!lannert.rz.uni-duesseldorf.de!TSOS
From: TSOS@uni-duesseldorf.de (Detlef Lannert)
Newsgroups: sci.crypt
Subject: Re: Authentication and one-time-pads (was: Re: Advanced one time pad)
Date: Wed, 5 May 1993 08:16:37 GMT
Organization: Universitaetsrechenzentrum, Heinrich-Heine-Universitaet, Duesseldorf
Lines: 53
Message-ID: <TSOS.404.736589797@uni-duesseldorf.de>
References: <1rshgc$d8k@sol.TIS.COM> <38678@optima.cs.arizona.edu> <1s1dbmINNehb@elang05.acslab.umbc.edu> <9312311.1752@mulga.cs.mu.OZ.AU>
NNTP-Posting-Host: lannert.rz.uni-duesseldorf.de

>In article <1s1dbmINNehb@elang05.acslab.umbc.edu> olson@umbc.edu (Bryan Olson; CMSC (G)) writes:
>>The one-time-pad yeilds ideal security, but has a well-known flaw in
>>authentication.  Suppose you use a random bit stream as the pad, and
>>exclusive-or as the encryption operation.  If an adversary knows the 
>>plaintext of a message, he can change it into any other message.  
>>Here's how it works. [...]

I could think of four easy ways to safeguard an OTP-encrypted message 
against such an attack right off-hand: 

1) Use the first n bits of the OTP to determine how many random (or zero, 
which is equivalent here) bytes are inserted _before_ the plain text. 
Trailing bytes are inserted as well so that the total message length does 
not give away the offset. 
Thus Evil Eve won't know the position of the plaintext within the message 
stream. Drawbacks: n + 2^n bytes of the OTP and of bandwidth are wasted; 
therefore the number of possibilities cannot be very large. 
A small n might be sufficient, though, because we assume that Eve has only 
one try and that her attack is revealed if she doesn't get it 100% right. 

2) The plaintext is shuffled by a simple permutation cipher which gets its 
starting parameters from the first n bits of the OTP. This obviously does 
not weaken the OTP cipher. The message length can remain unchanged (except 
for the n bits prefix); there are O(2^n) possible combinations for Eve to 
choose from so she has a pretty bad chance to manipulate the text. 
This solution doesn't require a computerised encryption/decryption as the 
permutation can be done manually, just taking the first OTP bytes as key 
(as column indices for the classical permutation table, for instance). 

3) The first, say, 128 bits of the OTP are used to initialise a secure 
hash algorithm (like MD5). Then the plaintext is hashed and the checksum 
appended to the message. Eve can compute the hash value for her modified 
message but she cannot find out the initialisation value and thus cannot 
send a fitting checksum either. 
This method wastes 2*128 bits of the OTP and 128 bits bandwidth; it's only 
as secure as the hash algorithm is (as far as the `plaintext exchange' 
attack is concerned). 

4) Combine the OTP and the plaintext in a nonlinear way; e.g., use a 
cipher with an n-bit keylength to encode n data bits and take a different 
key value from the OTP for every data block. The difficulty to compute 
the keys from the plaintext (and then to encrypt a different plaintext 
with the same keys) depends on the security of the cipher; since most 
attacks on the usual ciphers require more than one block of plaintext 
and ciphertext, it's _very_ unlikely that this code can be broken. 

These suggestions don't actually provide absolute security against the 
`plaintext exchange' attack; any better ideas?
--
Detlef Lannert       DC3EK       E-Mail: tsos@rz.uni-duesseldorf.de
PGP 2.2 key via server or finger lannert@clio.rz.uni-duesseldorf.de
"I am Psmith." - "Oh, you're Smith, are you?" - "With a preliminary
P. Which, however, is not sounded."                   P.G.Wodehouse
