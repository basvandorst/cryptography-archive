Path: msuinfo!agate!howland.reston.ans.net!noc.near.net!uunet!mcsun!julienas!seti!couchey.inria.fr!doligez
From: doligez@couchey.inria.fr (Planar)
Newsgroups: sci.crypt
Subject: Re: One-time pad authentication
Keywords: authentication, one-time pad
Message-ID: <6340@seti.inria.fr>
Date: 7 May 93 13:32:44 GMT
References: <9304290024.AA02249@pizzabox.demon.co.uk> <strnlghtC6BKwv.19C@netcom.com> <16BC2116C6.C445585@mizzou1.missouri.edu> <6320@seti.inria.fr> <1s58keINNbr@news.u.washington.edu>
Sender: news@seti.inria.fr
Organization: Who cares ?
Lines: 115

In article <1s58keINNbr@news.u.washington.edu>, Randolf Smith writes:

>Your idea is along the right track, though.  Generally, the equation for the 
>stream would be xor(r1, m), cs(r2, m).  (cs = checksum) The important part 
>is that knowing cs(r2, m) and m won't give you r2, and ideally you shouldn't 
>get any information about r2 useful in determining cs.  Unfortunately this is 
>tough to do.  I think.  Well, here's the bit table I came up with:
>
>Note: 1 message bit, 1 checksum bit, 2 known random bits, 2 identical tables.
>m cs|R2    m cs|R2     ||     m R2|cs    m R2|cs
>0 0 |00    1 0 |00     ||     0 00|0     1 00|0
>0 0 |01    1 0 |10     ||     0 10|1     1 01|1
>0 1 |10    1 1 |01     ||     0 01|0     1 10|0
>0 1 |11    1 1 |11     ||     0 11|1     1 11|1

Let me describe this system differently:
For each message bit M, Alice uses two pad bits P1 and P2.  P1 and P2 are used
to choose a function f among the four possible functions from {0,1} to {0,1}.
These four functions are:
x -> x      identity               (R2 = 01)
x -> not x  negation               (R2 = 10)
x -> 0      constant function 0    (R2 = 00)
x -> 1      constant function 1    (R2 = 11)
Alice transmits C = f(M) as the authentication code for M.

Suppose Eve wants to change M to M'.  The only information she has about f
is that F(M) = C.  Eve must find out what C' = f(M') is, in order to transmit
it instead of C.
If F is one of the constant functions, then F(M') = F(M).
If F is one of the other two functions, then F(M') = not F(M).
These two events occur with probability 1/2, assuming the pad is truly random.
Thus the best strategy for Eve is to toss a coin and choose a random C'.

But this is authentication is optimal only for 1-bit messages.

Suppose Alice sends the message "The price is $11000.00", and Eve wants to
change it to "The price is $91000.00".  This is a 1-bit change.  The bit
in question is protected by one bit of authentication code.  Eve replaces
this code bit with a random bit.  The probability of success is 1/2,
which is quite high.
The problem here is that each message bit is authenticated independently of
the others.

Let us generalise a little bit.

The message is an integer M in 1..n (for an N-bit message, n is 2**N).
The authentication code is an integer in 1..m (in Smith's system, n = m).
Alice uses n*log(m) pad bits to choose f from the m**n functions
from 1..n to 1..m, and the authentication code is C = f(M).

How strong is it ?

As above, Eve knows that f(M) = C and she wants to know f(M') for some M' != M.
But there are exactly m**(n-2) functions f such that f(M) = C and f(M') = C'
for each C'.  Since the function f was chosen at random, any C' is just as
likely to be correct as any other.  Thus Eve must choose C' at random, and she
has a probability 1/m of success.
This is interesting because m is a parameter of the system.  The authentication
code can be made arbitrarily strong by choosing a big enough m.
It can even be made stronger than the one-time pad cipher itself, because the
probability of guessing the message is 1/n.  If we choose m > n, then breaking
the authentication is harder than guessing the message.  (But the
authentication code is bigger than the message itself !)

[ In Smith's system, n = m = 2, and the probability of success for the attacker
  is 1/2.  This is optimal for a 1-bit authentication code (and not for a 1-bit
  message as I said above). ]

But this is overkill.

In fact, this scheme is so strong that reusing the same pad bits over and over
only leaves you vulnerable to a replay attack.  Even knowing any number of
authenticated messages, Eve cannot find the authentication code corresponding
to a new message.
To see why this is true, suppose Eve knows p messages M1...Mp and the
corresponding authentication codes C1...Cp.  We have (forall i, Ci = f(Mi)).
For all M' (different from all the Mi) and C', there are m**(n-p-1) functions f
such that f(Mi) = Ci for all i.  So for a given M', every C' is just as likely
as any other.
Of course, the price to pay for this overkill security is a huge number of pad
bits.  If the message and authentication code are both of length N, we need
(N * 2**N) pad bits.

What we really need is only a set F of functions from 1..n to 1..m and
a constant K >= 1 such that
    forall M, C, M', C', card {f in F | f(M) = C and f(M') = C'} = K
The last part of this formula means "the number of functions f that are in F
and map M to C and M' to C' is K".

What is the minimum number of pad bits that we have to use ?

Since pad bits are used to choose one of the elements of F, we have fewer
possibilities (and thus fewer bits) when card(F) is as small as possible.
A lower bound for card(F) can be derived as follows:
Fix a value for M and one for M'.
Enumerate all the possible values of (C, C').  There are m*m of them.
For each one, there are K functions in F such that f(M) = C and f(M') = C'.
Thus there are K*m*m functions in F.  Since the minimum value for K
is 1, we have card(F) >= m*m.
This means we must use at least 2*log(m) pad bits, which translates to
twice as many pad bits as authentication code bits.

I have not found a way of building a small set F for a given (n, m) pair.
This is another problem that I have to leave open.

I have the following results (found by Georges Gonthier):
K = 1   ==>   n <= m**(m*m)
K = 1 and m = 2   ==>   n <= 3
K = 2, m = 2, n = 7  is possible

Note also that, if you have a solution P to the problem in my previous
posting <6320@seti.inria.fr>, with card(P) = n*(n-1), and if you choose m = n,
then you have an optimal solution to this problem with:
    F = P U {fp | forall x, fp(x) = p and p in 1..n}
This was also found by Georges Gonthier.
