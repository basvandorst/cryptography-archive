Path: msuinfo!agate!howland.reston.ans.net!usc!elroy.jpl.nasa.gov!decwrl!hal.com!hal.com!howard
From: howard@hal.com (Howard Gayle)
Newsgroups: sci.crypt,alt.privacy
Subject: Rubber-hose-resistant crypto file system
Followup-To: sci.crypt
Date: 19 May 1993 15:29:55 GMT
Organization: HaL Computer Systems, Inc., Campbell, California
Lines: 220
Message-ID: <1tdjpjINNkk1@hal.com>
Reply-To: howard@hal.com (Howard Gayle)
NNTP-Posting-Host: hasse.hal.com
Summary: Files encrypted with unknown keys indistinguishable from free space.
Keywords: cryptographic file system, notebook computer
Xref: msuinfo sci.crypt:16586 alt.privacy:6978

I set the Followup-To header to sci.crypt.  For non-technical
followups, please change this to an appropriate group.


      ABSTRACT

I sketch the design of an encrypted file system for a notebook
computer.  The system allows for the use of multiple keys.  If
only some of the keys are known, then only the files encrypted
with those keys are accessible.  Files encrypted with unknown
keys are indistinguishable from free space in the file system.
This allows a user to reveal some keys to an opponent, keep
other keys secret, yet claim plausibly to have revealed all
keys.


      BACKGROUND

Alice is a journalist.  Her current assignment is to
investigate human rights abuses in an unnamed country.  She has
interviewed many dissidents, and taken detailed notes.  She
keeps her notes on her notebook computer, encrypted.

Bob is the head of the secret police in the unnamed country.
He would very much like to obtain Alice's notes, get the names
of the dissidents, and arrest them.  He seizes Alice's
notebook, carefully removes its hard disk drive, and attaches
it to another computer.  He discovers that the disk contains
some encrypted files.  He orders Alice to reveal the key.
She does, but when Bob decrypts the files, he finds that none
of the notes actually identify any dissidents.


      REQUIREMENTS

In this section I list the requirements for a notebook
encrypted file system.  I claim that a system that meets these
requirements can withstand the sort of attack described above.

1) A file can be encrypted with one of a number of keys.

2) If only some of the keys are known to an opponent, the files
   encrypted with the unknown keys are indistinguishable from
   ordinary file system "overhead" data structures, such as free
   space.

3) The notebook can be powered off at any time.

4) Once powered off, all cleartext is gone.  In other words,
   cleartext is never stored on disk (even in the swap area) or
   in any other non-volatile memory.

5) Files may be compressed before encryption.  Several
   different compression algorithms may be used.  Not all files
   are compressed.

6) A file system can contain hundreds of encrypted files.  In
   other words, this is a design for a notebook, not a file
   server.

7) Encrypted files on a disk must be protected, even if the
   disk is examined on a different computer.  In other words, it
   is not sufficient to rely on "booby traps" that erase the
   encrypted files unless the system is used in a certain way.

8) The system must work even if the opponents know everything
   about it, except the keys.


      OVERVIEW OF IMPLEMENTATION

In this section I sketch how a file system could be built to
satisfy the above requirements.  I've tried not to assume any
particular operating system.  For clarity, I've omitted many
details that would have to be covered in a real,
industrial-strength implementation.

The file system is a linear sequence of chunks on disk (or a
disk partition).  Each chunk is one or more disk sectors.  Each
chunk starts with a chunk header containing a magic number, the
size of the chunk, and a CRC (checksum) on the chunk header.
When a file system is initialized, it is filled with chunks
whose sizes are taken from a random distribution that captures
the statistical properties of real files.  Except for the chunk
header, each chunk is initialized with random bytes.

To add a file:

1) Compress the file body, if desired.  (Compression is used
   both to save disk space and to reduce encryption/decryption
   time.)

2) Prepend the file name, owner, mode, size, compression
   algorithm, etc. to the (optionally compressed) file body.
   The result is the file block.

3) Pick a random session key, and use it to encrypt the file
   block.

4) Create a block containing two copies of the session key.
   Encrypt this block with one of the user-supplied keys.  The
   result is the encrypted session key block.

5) Pick some free chunk, and replace the random bytes after the
   chunk header with the encrypted session key block followed by
   the encrypted file block.  The free chunk that is picked must
   of course be big enough to hold everything.  Ideally, it
   should be picked at random from among those of the right
   size.

When the file system is mounted, the system does the following:

1) Prompt the user for one or more keys.  Authorized users
   would normally provide all keys.

2) Step sequentially through each chunk, and build up a
   directory structure and a free list structure, both in main
   memory.  The system determines whether or not a chunk is free
   by attempting to decrypt the encrypted session key block from
   step 4 above, trying each user-supplied key in turn.  If the
   block decrypts as two copies of the same session key, the
   chunk is assumed to be in use.  Otherwise, it is assumed to
   be free.

3) Generate a random session key for paging (or swapping).  All
   pages are encrypted with this session key before being
   written to disk.

To remove a file, the part of the chunk after the chunk header
is overwritten with random bytes. 


      PLAUSIBLE DENIABILITY

Alice actually used two keys, one for a sanitized version of
her notes, and one for the raw notes.  She revealed only the
first key.  Bob may suspect that some of the "free space" on
the file system is actually encrypted files, but he can not
prove this.


      RANDOM NOTES

This section contains miscellaneous observations.

For read-only use, it's safe to input only the keys
corresponding to the files to be read.  However, all keys
should be input before new files are created.  Otherwise, the
system may use existing files as free space.

When prompting the user to input the keys, the system should
never suggest that there are any more keys besides the ones
already supplied.

In addition to the usual operating system file creation
interface, the user needs some way to tell the system which key
to use, and which compression algorithm (if any) to use.

The random numbers with which the chunks are initialized, and
with which freed chunks are overwritten, should ideally be
truly random.  If the opponent discovers any pattern in a free
chunk, it may be taken as evidence that the chunk is actually
an encrypted file.  Generating good random numbers on a
notebook could be hard.  An audio chip that samples diode noise
might do the trick.

Although one unreadable disk sector could result in the loss of
all data on the rest of the disk, the chunk headers contain
much redundant information, so it should almost always be
possible to recover all files but the one with the bad sector.

The file system is designed for notebook use.  It favors small
files that are read into memory all at once.  A different
design might be appropriate for larger systems.

Mounting an encrypted file system would take time proportional
to the number of chunks.

A file system should be created with a good distribution of
chunk sizes.  Free chunks can be split, adjacent free chunks
can be coalesced, and files can be moved.

The background story is based on a recent incident in China.
Unfortunately, the real journalist kept her notes in a safe,
which the police forced her to open.

This system is still vulnerable to other attacks, for example
monitoring the user while using the system.  The monitoring
could be done with hidden cameras or interception of
electromagnetic radiation ("Tempest").  The system is also
vulnerable if the notebook can be seized before the user can
power it off.

The system may be vulnerable to sophisticated disk analysis.
For example, a "free" chunk with nothing written "under" it is
probably a true free chunk from when the file system was
initialized, whereas a "free" chunk that overwrites something
else may well be an encrypted file.  Initializing the file
system a few hundred times should stop this sort of attack.

Random bytes may occasionally decrypt to what appears to be a
valid session key block.  The probability of this can be made
arbitrarily low.


      CONCLUSION

No complete solution to the "rubber hose" problem exists,
because it comes down to proving that one does *not* know
something.  The system described in this article does allow for
"plausible deniability."
--
Howard Gayle
HAL Computer Systems, Inc.
1315 Dell Avenue
Campbell, California 95008
USA
howard@hal.com
Phone: +1 408 379 7000 extension 1080
FAX  : +1 408 379 5022
