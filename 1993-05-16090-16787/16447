Newsgroups: sci.crypt
Path: msuinfo!agate!usenet.ins.cwru.edu!magnus.acs.ohio-state.edu!math.ohio-state.edu!zaphod.mps.ohio-state.edu!malgudi.oar.net!news.ans.net!newsgate.watson.ibm.com!hawnews.watson.ibm.com!chaparral.raleigh.ibm.com!friedman
From: friedman@chaparral.raleigh.ibm.com (Perry Friedman)
Subject: Pseudo random, one-time pad
Sender: news@hawnews.watson.ibm.com (NNTP News Poster)
Message-ID: <C6voG0.149t@hawnews.watson.ibm.com>
Date: Tue, 11 May 1993 19:50:23 GMT
Disclaimer: This posting represents the poster's views, not necessarily those of IBM.
Nntp-Posting-Host: chaparral.raleigh.ibm.com
Organization: ibm
Lines: 60



There has been much discussion about one time use random masks...
I was wondering why pseudorandom, but UNKNOWN, isn't simply good enough.
Suppose you use a pseudorandom mask (generated from some key, used once).
Now suppose every possible mask of length X is generatable by some key.
Then any message of length X is provably UNBREAKABLE, since EVERY message
of length X is generatable by some key for any clear text.


Now, that said, I have a question about an algorithm I came up with a
while back and would like to know if anyone sees any weaknesses in it.
 
Suppose you have 11 variables a[0] - a[10].  Now, each one is incremented
by some predetermined value and is then mod'd by some prime number which
is different for each of the 11 variables (the prime numbers and the
increments).  To be even nicer, make the increment about 1/3 to 1/2 of
the modulus so that there is a ncie fluctuation between increases and
decreases of the value of each variable.
Now, make the starting points of each variable be based on the key.
To be simple, let the key be a character array and let a[i] be the sum
of all the i'th characters of the key mod 11.  Thus longer keys (> 11
chars) can become more or less random strings of 11 chars (just to make
it hard for people to just try every, say, printable set of 11 chars...
or just alphanumeric strings of 11 chars... basically, people can then
have easily remember keys which really map to weird 11 char strings...
thus allowing all 256 to the 11th strings to be generatable without
people typing in unprintable characters in keys).
 
Anyhow, from here, you use the sum of all the variables, plus a multiple of
the previous clear text character's value to generate the next crypted
character, and then you increment all the variables again.  Since all the
moduli are relatively prime (and in fact prime), the number of unique
starting points is the product of their values so the sequence should not
repeat prior to that length.  The previous character dependency prevents
easy decryption even in the case of key reuse.
I assert that, from the disccussion at the top, this algorithm is
uncrackable for short messages (say < length X where X is maximum length
for which all possible byte masks are generatable). If we assume that we
are not necessarily even starting with alphanumeric English text to start
with (such as encrypting multiple times for example or sending binary data),
it seems very difficult to crack.
I would like to know if anyone sees flaws in this scheme and how they might
go about cracking it.  Assume that you would have access to the source code
(so you know the moduli and the increments and multiple of the previous
character) and you therefore also have access to the executable to encrypt
text as you wish to generate crypto text and to decrypt crypto text (I
neglected to discuss the decryption simply because it is quite
straightforward).  Also, since encrypt and decrypt are inverses, but not
equal, one could decrypt as method of encryption and encrypt to decrypt,
just to make things harder to crack.  Or messages could be encrypted
with key1, decrypted key2, encrypted key3... and the reverse to get back
the clear text.  If the cracker does not know what combinations of
encrypts and decrypts, it seems even harder to crack.   I'd like to
see discussion about the security of that technique as well.

Thanks
-- 
Perry Friedman
jester@vnet.ibm.com
