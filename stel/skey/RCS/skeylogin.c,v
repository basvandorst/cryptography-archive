head	1.38;
access;
symbols;
locks
	vince:1.38; strict;
comment	@ * @;


1.38
date	96.04.26.11.43.45;	author vince;	state Exp;
branches;
next	1.37;

1.37
date	96.03.30.14.58.22;	author vince;	state Exp;
branches;
next	1.36;

1.36
date	96.03.28.10.13.17;	author vince;	state Exp;
branches;
next	1.35;

1.35
date	95.11.27.15.52.56;	author vince;	state Exp;
branches;
next	1.34;

1.34
date	95.11.27.14.18.32;	author vince;	state Exp;
branches;
next	1.33;

1.33
date	95.11.27.13.43.34;	author vince;	state Exp;
branches;
next	1.32;

1.32
date	95.07.15.14.20.36;	author vince;	state Exp;
branches;
next	1.31;

1.31
date	95.07.14.16.06.28;	author vince;	state Exp;
branches;
next	1.30;

1.30
date	95.05.10.17.10.48;	author vince;	state Exp;
branches;
next	1.29;

1.29
date	95.04.22.17.19.22;	author vince;	state Exp;
branches;
next	1.28;

1.28
date	95.04.22.17.16.25;	author vince;	state Exp;
branches;
next	1.27;

1.27
date	95.04.22.09.56.56;	author vince;	state Exp;
branches;
next	1.26;

1.26
date	95.04.18.12.08.40;	author vince;	state Exp;
branches;
next	1.25;

1.25
date	95.04.14.16.51.41;	author vince;	state Exp;
branches;
next	1.24;

1.24
date	95.04.12.16.04.17;	author vince;	state Exp;
branches;
next	1.23;

1.23
date	95.02.25.14.54.11;	author vince;	state Exp;
branches;
next	1.22;

1.22
date	95.01.24.15.23.58;	author vince;	state Exp;
branches;
next	1.21;

1.21
date	95.01.24.12.50.43;	author vince;	state Exp;
branches;
next	1.20;

1.20
date	95.01.03.11.57.33;	author vince;	state Exp;
branches;
next	1.19;

1.19
date	95.01.02.17.53.36;	author vince;	state Exp;
branches;
next	1.18;

1.18
date	95.01.02.17.31.33;	author vince;	state Exp;
branches;
next	1.17;

1.17
date	94.12.28.20.28.08;	author vince;	state Exp;
branches;
next	1.16;

1.16
date	94.12.18.13.21.12;	author vince;	state Exp;
branches;
next	1.15;

1.15
date	94.12.14.09.56.46;	author vince;	state Exp;
branches;
next	1.14;

1.14
date	94.12.10.19.44.49;	author vince;	state Exp;
branches;
next	1.13;

1.13
date	94.12.10.14.17.28;	author vince;	state Exp;
branches;
next	1.12;

1.12
date	94.12.10.13.12.11;	author vince;	state Exp;
branches;
next	1.11;

1.11
date	94.12.10.12.59.47;	author vince;	state Exp;
branches;
next	1.10;

1.10
date	94.12.10.11.22.09;	author vince;	state Exp;
branches;
next	1.9;

1.9
date	94.12.10.11.21.48;	author vince;	state Exp;
branches;
next	1.8;

1.8
date	94.12.10.11.17.13;	author vince;	state Exp;
branches;
next	1.7;

1.7
date	94.12.10.10.43.44;	author vince;	state Exp;
branches;
next	1.6;

1.6
date	94.12.10.08.44.21;	author vince;	state Exp;
branches;
next	1.5;

1.5
date	94.12.09.18.00.32;	author vince;	state Exp;
branches;
next	1.4;

1.4
date	94.12.09.17.54.20;	author vince;	state Exp;
branches;
next	1.3;

1.3
date	94.12.09.16.33.17;	author vince;	state Exp;
branches;
next	1.2;

1.2
date	94.12.09.14.25.05;	author vince;	state Exp;
branches;
next	1.1;

1.1
date	94.12.08.18.00.33;	author vince;	state Exp;
branches;
next	;


desc
@@


1.38
log
@automatic
@
text
@/*
 * $Author: vince $
 * $Header: /users/vince/src/stel-dist/skey/RCS/skeylogin.c,v 1.37 1996/03/30 14:58:22 vince Exp vince $
 * $Date: 1996/03/30 14:58:22 $
 * $Revision: 1.37 $
 * $Locker: vince $
 */

#ifndef	lint
static char *rcsid = "@@(#) $Id: skeylogin.c,v 1.37 1996/03/30 14:58:22 vince Exp vince $";
#endif	lint

/*
 *   Login code for S/KEY Authentication.  S/KEY is a trademark
 *   of Bellcore.
 *
 *   Mink is the former name of the S/KEY authentication system.
 *   Many references for mink  may still be found in this program.
 */

#include <sys/param.h>
#ifdef	QUOTA
#include <sys/quota.h>
#endif
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>

#include <stdio.h>
#include <string.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <errno.h>
#include "skey.h"

#ifdef SKEYD
#define TALKERROR "Can't talk with skey authentication server\n"
#define CONFERROR "Unable to use skey authentication server's configuration file\n"
#define TOUTERROR "Connection with skey authentication server timed out!\n"
#include <sys/socket.h>
#include <netinet/in.h>
#include <netdb.h>
#include <unistd.h>
#include <signal.h>
#include "des.h"
#include "md4.h"

static char		*skeyserver;
static int		skeyport;
des_key_schedule	schedule;

static int		talktimeoutflg;
#endif

char *skipspace();

#ifdef SKEYD
/* this violates standard skeylookup() syntax */
int skeylookup __ARGS((struct skey *mp,char *name, int staylocal));
#else
int skeylookup __ARGS((struct skey *mp,char *name));
#endif



/* Issue a skey challenge for user 'name'. If successful,
 * fill in the caller's skey structure and return 0. If unsuccessful
 * (e.g., if name is unknown) return -1.
 *
 * The file read/write pointer is left at the start of the
 * record.
 */
int
getskeyprompt(mp,name,prompt)
struct skey *mp;
char *name;
char *prompt;
{
	int rval;

	sevenbit(name);
#ifdef SKEYD
	rval = skeylookup(mp,name, 0);
#else
	rval = skeylookup(mp,name);
#endif
	strcpy(prompt,"s/key 55 latour1\n");
	switch(rval){
	case -1:	/* File error */
		return -1;
	case 0:		/* Lookup succeeded, return challenge */
		sprintf(prompt,"s/key %d %s\n",mp->n - 1,mp->seed);
		return 0;
	case 1:		/* User not found */
		sfclose(mp->keyfile);
		return -1;
	}
	return -1;	/* Can't happen */
}	
/* Return  a skey challenge string for user 'name'. If successful,
 * fill in the caller's skey structure and return 0. If unsuccessful
 * (e.g., if name is unknown) return -1.
 *
 * The file read/write pointer is left at the start of the
 * record.
 */
int
skeychallenge(mp,name, ss)
struct skey *mp;
char *name;
char *ss;
{
	int rval;

	bzero(mp, sizeof(struct skey));

#ifdef SKEYD
	rval = skeylookup(mp,name, 0);
#else
	rval = skeylookup(mp,name);
#endif
	switch(rval){
	case -1:	/* File error */
		return -1;
	case 0:		/* Lookup succeeded, issue challenge */
                sprintf(ss, "s/key %d %s",mp->n - 1,mp->seed);
		return 0;
	case 1:		/* User not found */
		sfclose(mp->keyfile);
		return -1;
	}
	return -1;	/* Can't happen */
}

/* Find an entry in the One-time Password database.
 * Return codes:
 * -1: error in opening database
 *  0: entry found, file R/W pointer positioned at beginning of record
 *  1: entry not found, file R/W pointer positioned at EOF
 */
int
skeylookup(mp,name
#ifdef SKEYD	/* please note: this violates standard skeylookup() syntax.
		the meaning of ``staylocal'' is: do not use key servers,
		even if /etc/skeyd.conf exists  */
		, staylocal
#endif
			)
struct skey *mp;
char *name;
#ifdef SKEYD
int	staylocal;
#endif
{
	int found;
	int len;
	long recstart;
	char *cp;
	struct stat statbuf;

#ifdef SKEYD
	static char		answer[BUFLEN];

	/* do not use skeyd even if it is available */
	if (staylocal)
		goto readlocal;

	if (stat(SKEYDCONF, &statbuf) == -1)
		goto readlocal;

	/* file should never be readable by anyone */
	if (statbuf.st_mode & S_IROTH || statbuf.st_mode & S_IRGRP) {
		statbuf.st_mode &= ~(S_IROTH | S_IRGRP);
		(void)chmod(SKEYDCONF, statbuf.st_mode);
	}

	if (readskeydconf())
		return (-1);

	if (skeytalk(GIVEMEINFO, name, answer)) {
		fprintf(stderr, TALKERROR);
		return (-1);
	}

	if (answer[0] == '\0')
		return (1);

	if ((mp->logname = strtok(answer," \t")) == NULL)
		return (-1);
	if((cp = strtok(NULL," \t")) == NULL)
		return (-1);

	mp->n = atoi(cp);

	if((mp->seed = strtok(NULL," \t")) == NULL)
		return (-1);
	if((mp->val = strtok(NULL," \t")) == NULL)
		return (-1);
	return(0);

readlocal: /* no networking set, use local file */

#endif /* SKEYD */

	/* See if the KEYFILE exists, and create it if not */
	if(stat(KEYFILE,&statbuf) == -1 && errno == ENOENT){
		mp->keyfile = fopen(KEYFILE,"w+");
	} else {
		/* Otherwise open normally for update */
		mp->keyfile = fopen(KEYFILE,"r+");
	}
	if(mp->keyfile == NULL)
		return -1;

	/* Look up user name in database */
	len = strlen(name);
	if( len > 8 ) len = 8;		/*  Added 8/2/91  -  nmh */
	found = 0;
	while(!feof(mp->keyfile)) {
		recstart = ftell(mp->keyfile);
		mp->recstart = recstart;
		if(fgets(mp->buf,sizeof(mp->buf),mp->keyfile) != mp->buf){
			break;
		}
		rip(mp->buf);
		if(mp->buf[0] == '#')
			continue;	/* Comment */
		if((mp->logname = strtok(mp->buf," \t")) == NULL)
			continue;
		if((cp = strtok(NULL," \t")) == NULL)
			continue;
		mp->n = atoi(cp);
		if((mp->seed = strtok(NULL," \t")) == NULL)
			continue;
		if((mp->val = strtok(NULL," \t")) == NULL)
			continue;
		if(strlen(mp->logname) == len
		 && strncmp(mp->logname,name,len) == 0){
			found = 1;
			break;
		}
	}
	if(found){
		fseek(mp->keyfile,recstart,0);
		return 0;
	} else
		return 1;
}

/* Verify response to a s/key challenge.
 *
 * Return codes:
 * -1: Error of some sort; database unchanged
 *  0:  Verify successful, database updated
 *  1:  Verify failed, database unchanged
 *
 * The database file is always closed by this call.
 */
int
skeyverify(mp,response)
struct skey *mp;
char *response;
{
	char key[8];
	char fkey[8];
	char filekey[8];
	time_t now;
	struct tm *tm;
	char tbuf[27],buf[60];
	char *cp;
#ifdef SKEYD
	struct skeymessage	talk;
	char	line[BUFLEN], answer[BUFLEN];
	int	useskeyd = 0;
	struct stat	statbuf;

	if (stat(SKEYDCONF, &statbuf) == 0)
			useskeyd++;

	/* access is considered harmful */
	/*
	if (!access(SKEYDCONF, R_OK))
		useskeyd++;
	*/
#endif

	time(&now);
	tm = localtime(&now);
	strftime(tbuf, sizeof(tbuf), " %b %d,%Y %T", tm);

	if(response == NULL){
		sfclose(mp->keyfile);
		return -1;
	}
	rip(response);

	/* Convert response to binary */
	if(etob(key,response) != 1 && atob8(key,response) != 0) {
		/* Neither english words or ascii hex */
		sfclose(mp->keyfile);
		return -1;
	}

	/* Compute fkey = f(key) */
	memcpy(fkey,key,sizeof(key));
	fff(fkey);
	/* in order to make the window of update as short as possible
           we must do the comparison here and if OK write it back
           other wise the same password can be used twice to get in
  	   to the system
	*/

#ifndef SOLARIS24
	setpriority(PRIO_PROCESS, 0, -4);
#endif

	/* reread the file record NOW*/
#ifdef SKEYD
	if (useskeyd) {
		if (skeytalk(GIVEMEINFO, mp->logname, answer)) {
			fprintf(stderr, TALKERROR);
			return (-1);
		}
		strncpy(mp->buf, answer, sizeof(mp->buf));
	}
	else
#endif
	{
		fseek(mp->keyfile,mp->recstart,0);
		if(fgets(mp->buf,sizeof(mp->buf),mp->keyfile) != mp->buf){
#ifndef SOLARIS24
			setpriority(PRIO_PROCESS, 0, 0);
#endif
			sfclose(mp->keyfile);
			return -1;
		}
	}

	rip(mp->buf);
	mp->logname = strtok(mp->buf," \t");
	cp = strtok(NULL," \t") ;
	mp->seed = strtok(NULL," \t");
	mp->val = strtok(NULL," \t");
	/* And convert file value to hex for comparison */
	(void)atob8(filekey,mp->val);

	/* Do actual comparison */
	if(memcmp(filekey,fkey,8) != 0){
		/* Wrong response */
#ifndef SOLARIS24
		setpriority(PRIO_PROCESS, 0, 0);
#endif
		sfclose(mp->keyfile);
		return 1;
	}

	btoa8(mp->val,key);
	mp->n--;

#ifdef SKEYD
	if (useskeyd) {
		sprintf(line, "%s %04d %-16s %s %-21s\n",
			mp->logname, mp->n,mp->seed, mp->val, tbuf);
		if (skeytalk(UPDATEKEYS, line, answer)) {
			fprintf(stderr, TALKERROR);
			return (-1);
		}
	}
	else
#endif
	{
		/* Update key in database by overwriting entire record. Note
		 * that we must write exactly the same number of bytes as in
		 * the original record (note fixed width field for N)
		 */
		fseek(mp->keyfile,mp->recstart,0);
		fprintf(mp->keyfile,"%s %04d %-16s %s %-21s\n",mp->logname,
						mp->n,mp->seed, mp->val, tbuf);

		sfclose(mp->keyfile);
	}

#ifndef SOLARIS24
	setpriority(PRIO_PROCESS, 0, 0);
#endif
	return 0;
}


/* Convert 8-byte hex-ascii string to binary array
 * Returns 0 on success, -1 on error
 */
atob8(out,in)
register char *out,*in;
{
	register int i;
	register int val;

	if(in == NULL || out == NULL)
		return -1;

	for(i=0;i<8;i++){
		if((in = skipspace(in)) == NULL)
			return -1;
		if((val = htoi(*in++)) == -1)
			return -1;
		*out = val << 4;

		if((in = skipspace(in)) == NULL)
			return -1;
		if((val = htoi(*in++)) == -1)
			return -1;
		*out++ |= val;
	}
	return 0;
}

char *
skipspace(cp)
register char *cp;
{
	while(*cp == ' ' || *cp == '\t')
		cp++;

	if(*cp == '\0')
		return NULL;
	else
		return cp;
}

/* Convert 8-byte binary array to hex-ascii string */
int
btoa8(out,in)
register char *out,*in;
{
	register int i;

	if(in == NULL || out == NULL)
		return -1;

	for(i=0;i<8;i++){
		sprintf(out,"%02x",*in++ & 0xff);
		out += 2;
	}
	return 0;
}


/* Convert hex digit to binary integer */
int
htoi(c)
register char c;
{
	if('0' <= c && c <= '9')
		return c - '0';
	if('a' <= c && c <= 'f')
		return 10 + c - 'a';
	if('A' <= c && c <= 'F')
		return 10 + c - 'A';
	return -1;
}

#ifdef SKEYD

#define SKEYPWD		"skeypwd"
#define SKEYSERVER	"skeyserver"
#define SKEYPORT	"skeyport"

readskeydconf()
{
	FILE		*fp;
	char		line[BUFLEN];
	char		*p, *q, *sep = ": \t\n\r";
	extern int	errno;
	MD4_CTX		mdContext;
	des_cblock	key;
	int		i;
	int		keyset = 0, hstset = 0, prtset = 0;
	unsigned char	digest[16];

	if ((fp = fopen(SKEYDCONF, "r")) == NULL) {
		perror(SKEYDCONF);
		fprintf(stderr, CONFERROR);
		return (1);
	}
	errno = 0;
	while ((fgets(line, sizeof(line), fp)) != NULL) {
		/* skip blank lines, incomplete lines and remarks */
		if ((p = strtok(line, sep)) == NULL || *p == '#' ||
		    (q = strtok(NULL, sep)) == NULL)
			continue;
		if (!strncasecmp(p, SKEYPWD, strlen(SKEYPWD))) {
			bzero(&mdContext, sizeof(mdContext));
			MD4Init(&mdContext);
			MD4Update(&mdContext, q, strlen(q));
			MD4Final(digest, &mdContext);
			for (i = 0; i < 8; i++)
				digest[i] ^= digest[i + 8];
			memcpy(&key, digest, 8);
			des_set_key(&key, schedule);

#ifdef DEBUG
			printf("ENCRYPTION KEY: ");
			for (i = 0; i < 8; i++)
				printf("%02x", key[i]);
			printf("\n");
#endif

			keyset++;
		}
		else if (!strncasecmp(p, SKEYSERVER, strlen(SKEYSERVER))) {
			/*
			**  ULTRIX doesn't have strdup 
			**  studarus@@psc.edu - Tue May  2 15:43:57 EDT 1995
			**  skeyserver = strdup(q);
			*/
			skeyserver = strdup(q);
			/*
			q = (char*)malloc(strlen(skeyserver) * sizeof(char)) ;
			strcpy(q,skeyserver) ;
			*/
			hstset++;
		}
		else if (!strncasecmp(p, SKEYPORT, strlen(SKEYPORT))) {
			skeyport = atoi(q);
			prtset++;
		}
	}

	if (errno) {
		perror("fgets()");
		return(1);
	}
	if (sfclose(fp) == -1) {
		perror("fclose()");
		return(1);
	}

	if (!keyset || !hstset || !prtset) {
		fprintf(stderr, "%s incomplete.\n", SKEYDCONF);
		fprintf(stderr, CONFERROR);
		skeyserver = NULL;
		skeyport = 0;
		return(1);
	}
	return(0);
}

skeytalk(flag, input, answer)
char	*input, *answer;
int	flag;
{
	struct skeymessage	talk;
	struct sockaddr_in	sin;
	int			s;
	static void		timeout();
	unsigned int		remaining = 0;
	void			(*oldsig) ();

	/* check that skeyd is really available. needed for skeyinit */
	if (skeyserver == NULL || skeyport == 0) {
		(void)fprintf(stderr, "skeyserver or skeyport not set!\n");
		return (1);
	}

	/* do not use name server for security */
	if ((sin.sin_addr.s_addr = inet_addr(skeyserver)) == -1) {
		(void)fprintf(stderr, "%s: unknown hostname\n", skeyserver);
		return (1);
	}
	sin.sin_family = AF_INET;
	sin.sin_port = htons((ushort)skeyport);

	if ((s = socket(AF_INET, SOCK_STREAM, 0)) < 0) {
		perror("socket()");
		return (1);
	}

	if (connect(s, (struct sockaddr *)&sin, sizeof(sin)) < 0) {
		perror("connect()");
		return (1);
	}

	bzero(&talk, sizeof(talk));
	talk.flag = flag;
	strncpy(talk.buf, input, sizeof(talk.buf));

	talkencode(&talk);

	if ((oldsig = signal(SIGALRM, SIG_IGN)) != SIG_IGN)
		(void)signal(SIGALRM, timeout);
	remaining = alarm(SKEYTALKTIMEOUT);

	if (skey_write_data(s, &talk, sizeof(talk)) == -1) {
		if (errno == EINTR)
			(void)fprintf(stderr, TOUTERROR);
		else
			perror("write()");
		return (1);
	}

	if (skey_read_data(s, &talk, sizeof(talk)) == -1) {
		if (errno == EINTR)
			(void)fprintf(stderr, TOUTERROR);
		else
			perror("read()");
		return (1);
	}

	if (talktimeoutflg) {
		(void)fprintf(stderr, TOUTERROR);
		return (1);
	}

	(void)signal(SIGALRM, oldsig);
	(void)alarm(remaining);

	/* if talkdecode fails the password has been wrongly set
	   on the other side. talk.flag is not so important */
	if (talkdecode(&talk) || ntohl(talk.flag) != SKEYDOK) {
		(void)fprintf(stderr,
		"Received corrupted data from skey authentication server!\n");
		return(1);
	}

	(void)close(s);
	strcpy(answer, talk.buf);
	return(0);
}

/*
 * Modified read() & write() for sockets.
 * Returns: number of characters read if ok; -1 if fails.
 */
int		skey_read_data(s, buf, n)
int		s;
char		*buf;
int		n;
{
	int		bcount;
	int		br;

	bcount= 0;
	br= 0;
	while (bcount < n) {
		if ((br = read(s, buf, n - bcount)) > 0) {
			bcount += br;
			buf += br;
		}
		else if (br < 0)
			return(-1);
		else if (!br)
			break;
	}
	return(bcount);
}

int		skey_write_data(s, buf, n)
int		s;
char		*buf;
int		n;
{
	int		bcount;
	int		br;

	bcount= 0;
	br= 0;
	while (bcount < n) {
		if ((br = write(s, buf, n - bcount)) > 0) {
			bcount += br;
			buf += br;
		}
	else if (br < 0)
		return(-1);
	}
	return(bcount);
}

talkencode(talk)
struct skeymessage	*talk;
{
	MD4_CTX			mdContext;
	char			ivbuf[32];
	unsigned char		digest[16], ivbackup[8];

	/* set flag */
	talk->flag = htonl(talk->flag);

	/* build iv
	we just build up a suitably random string and then distill some
	randomness by means of md4.  this is not very strong, we know,
	but iv security is not really a concern here.
	*/
	bzero(ivbuf, sizeof(ivbuf));
	sprintf(ivbuf, "%ld %d %d", time(NULL), getpid(), getppid());

	MD4Init(&mdContext);
	MD4Update(&mdContext, (unsigned char *)ivbuf, strlen(ivbuf));
	MD4Final(digest, &mdContext);
	memcpy(talk->iv, digest, 8);
	memcpy(ivbackup, digest, 8);

	/* build checksum, skipping checksum itself.  the iv is included.
	since the iv gets modified in the des_cfb_encrypt step, we
	need to keep a iv backup copy to do things work */
	MD4Init(&mdContext);
	MD4Update(&mdContext, (unsigned char *)talk,
					sizeof(struct skeymessage) - 16);
	MD4Final(talk->checksum, &mdContext);

	/* encrypt buffer, skipping iv of course */
	des_cfb_encrypt((unsigned char *)talk + 8,
			(unsigned char *)talk + 8,
			8,
			sizeof(struct skeymessage) - 8,
			schedule,
			(des_cblock *)ivbackup,
			DES_ENCRYPT);

	return(0);
}

talkdecode(talk)
struct skeymessage	*talk;
{
	des_cblock		key;
	MD4_CTX			mdContext;
	unsigned char		digest[16], ivbackup[8];

	memcpy(ivbackup, (unsigned char *)talk->iv, 8);
	des_cfb_encrypt((unsigned char *)talk + 8,
			(unsigned char *)talk + 8,
			8,
			sizeof(struct skeymessage) - 8,
			schedule,
			(des_cblock *)talk->iv,
			DES_DECRYPT);

	memcpy((unsigned char *)talk->iv, ivbackup, 8);

	/* build checksum, skipping checksum itself */
	MD4Init(&mdContext);
	MD4Update(&mdContext, (unsigned char *)talk,
					sizeof(struct skeymessage) - 16);
	MD4Final(digest, &mdContext);

	talk->flag = htonl(talk->flag);

	return (memcmp(talk->checksum, digest, 16));
}

static void
timeout(s)
int	s;
{
	(void)signal(s, timeout);
	talktimeoutflg++;
}

#endif /* SKEYD */

/* safe close - check for pointer */
sfclose(fp)
FILE	*fp;
{
	int	x;

	if (fp == NULL)
		return(0);

	x = fclose(fp);
	fp = NULL;
	return (x);
}


#ifdef EXTRA
/* A set of small subroutines to make the lib work with obsolete code */
/*
 * skey_haskey ()
 *
 * Returns: 1 user doesnt exist, -1 fle error, 0 user exists.
 *
 */
skey_haskey (username)
  char *username;
{
  int i;
  struct skey skey;
 
#ifdef SKEYD
  return (skeylookup (&skey, username, 0));
#else
  return (skeylookup (&skey, username));
#endif
}
 
/*
 * skey_keyinfo ()
 *
 * Returns the current sequence number and
 * seed for the passed user.
 *
 */
char *skey_keyinfo (username)
  char *username;
{
  int i;
  static char str [50];
 
  struct skey skey;
 
  i = skeychallenge (&skey, username, str);
 
  if (i == -2)
     return 0;
 
  return str;
}
 
/*
 * skey_passcheck ()
 *
 * Check to see if answer is the correct one to the current
 * challenge.
 *
 * Returns: 0 success, -1 failure
 * XXX: calls skeyverify; therefore updates the record!! _H*
 */
skey_passcheck (username, passwd)
  char *username, *passwd;
{
  int i;
  struct skey skey;
 
#ifdef SKEYD
  i = skeylookup (&skey, username, 0);
#else
  i = skeylookup (&skey, username);
#endif
 
  if (i == -1 || i == 1)
      return -1;
 
  if (skeyverify (&skey, passwd) == 0)
      return skey.n;
 
  return -1;
}
#endif /* EXTRA */
@


1.37
log
@automatic
@
text
@d3 3
a5 3
 * $Header: /users/vince/src/skey/RCS/skeylogin.c,v 1.36 1996/03/28 10:13:17 vince Exp vince $
 * $Date: 1996/03/28 10:13:17 $
 * $Revision: 1.36 $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: skeylogin.c,v 1.36 1996/03/28 10:13:17 vince Exp vince $";
d778 1
a778 1
/* A set of small subroutines to make the lib wotk with obsolete code */
@


1.36
log
@automatic
@
text
@d3 4
a6 4
 * $Header: /res/usr/vince/src/skey/RCS/skeylogin.c,v 1.35 1995/11/27 15:52:56 vince Exp $
 * $Date: 1995/11/27 15:52:56 $
 * $Revision: 1.35 $
 * $Locker:  $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: skeylogin.c,v 1.35 1995/11/27 15:52:56 vince Exp $";
d313 1
d315 1
d331 1
d333 1
d350 1
d352 1
d383 1
d385 1
@


1.35
log
@automatic
@
text
@d3 4
a6 4
 * $Header: /res/usr/vince/src/skey/RCS/skeylogin.c,v 1.33 1995/11/27 13:43:34 vince Exp vince $
 * $Date: 1995/11/27 13:43:34 $
 * $Revision: 1.33 $
 * $Locker: vince $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: skeylogin.c,v 1.33 1995/11/27 13:43:34 vince Exp vince $";
d145 1
a145 1
		by menas of /etc/skeyd.conf file.  */
d571 1
a571 1
	if (connect(s, &sin, sizeof(sin)) < 0) {
@


1.34
log
@automatic
@
text
@a673 1
	des_cblock		key;
a674 2
	time_t			t;
	int			pid;
d676 1
a676 1
	unsigned char		digest[16];
d684 1
a684 1
	but iv security is not really a concern here
d687 2
a688 1
	sprintf(ivbuf, "%ld %d %d", time(NULL), pid(), ppid());
d693 1
d695 3
a697 1
	/* build checksum */
d699 2
a700 2
	/* skip checksum itself */
	MD4Update(&mdContext, (unsigned char *)talk, sizeof(talk) - 16);
d704 2
a705 2
	des_cfb_encrypt((des_cblock *)&talk + 1,
			(des_cblock *)&talk + 1,
d707 1
a707 1
			sizeof(talk) - 8,
d709 1
a709 1
			(des_cblock *)talk->iv,
d720 1
a720 2
	int			begin, end;
	unsigned char		digest[16];
d722 3
a724 2
	des_cfb_encrypt((des_cblock *)talk + 1,
			(des_cblock *)talk + 1,
d726 1
a726 1
			sizeof(talk) - 8,
d731 3
d735 2
a736 2
	/* skip checksum, padding */
	MD4Update(&mdContext, (unsigned char *)&talk, sizeof(talk) - 16);
@


1.33
log
@automatic
@
text
@d3 3
a5 3
 * $Header: /res/usr/vince/src/skey/RCS/skeylogin.c,v 1.32 1995/07/15 14:20:36 vince Exp vince $
 * $Date: 1995/07/15 14:20:36 $
 * $Revision: 1.32 $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: skeylogin.c,v 1.32 1995/07/15 14:20:36 vince Exp vince $";
a675 1
	int			begin, end;
d677 3
a679 2
	char			ivbuf[20];
	des_cblock		ivbuf2;
d681 1
d684 13
d698 2
a699 3
	begin = 8; /* iv */
	end = sizeof(struct skeymessage) - 32; /* skip checksum, padding */
	MD4Update(&mdContext, (unsigned char *) talk + begin, end);
d702 8
a709 2
	/* build iv */
	bzero(ivbuf, sizeof(ivbuf));
a710 18
	(void)time(&t);
	t <<= 8 * 3;
	t >>= 8 * 3;
	(void)sprintf(ivbuf, "%ld%d", t, getpid());
	(void)strncpy((char *)ivbuf2, ivbuf, 8);
	des_ecb_encrypt(&ivbuf2, &ivbuf2, schedule, DES_ENCRYPT);
	des_ecb_encrypt(&ivbuf2, &ivbuf2, schedule, DES_ENCRYPT);
	des_ecb_encrypt(&ivbuf2, &ivbuf2, schedule, DES_ENCRYPT);
	memcpy(talk->iv, (char *)ivbuf2, 8);

	/* encrypt buffer and checksum */
	des_cbc_encrypt((des_cblock *)talk->buf, (des_cblock *)talk->buf,
			sizeof(talk->buf), schedule, (des_cblock *)talk->iv,
			DES_ENCRYPT);
	des_cbc_encrypt((des_cblock *)talk->checksum,
			(des_cblock *)talk->checksum,
			sizeof(talk->checksum), schedule,
			(des_cblock *)talk->iv, DES_ENCRYPT);
d722 7
a728 7
	des_cbc_encrypt((des_cblock *)talk->buf, (des_cblock *)talk->buf,
			sizeof(talk->buf), schedule,
			(des_cblock *)talk->iv, DES_DECRYPT);
	des_cbc_encrypt((des_cblock *)talk->checksum,
			(des_cblock *)talk->checksum,
			sizeof(talk->checksum), schedule,
			(des_cblock *)talk->iv, DES_DECRYPT);
d732 1
a732 3
	begin = 8; /* iv */
	end = sizeof(struct skeymessage) - 32; /* skip checksum, padding */
	MD4Update(&mdContext, (unsigned char *) talk + begin, end);
@


1.32
log
@automatic
@
text
@d3 3
a5 3
 * $Header: /res/usr/vince/src/skey/RCS/skeylogin.c,v 1.31 1995/07/14 16:06:28 vince Exp vince $
 * $Date: 1995/07/14 16:06:28 $
 * $Revision: 1.31 $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: skeylogin.c,v 1.31 1995/07/14 16:06:28 vince Exp vince $";
d39 1
a39 1
#define TOUTERROR "Connection with skey authentication server expired\n"
d58 1
d83 1
a83 1
	rval = skeylookup(mp,name,0);
d118 1
a118 1
	rval = skeylookup(mp,name,0);
d143 3
a145 1
#ifdef SKEYD /* this violates standard skeylookup() syntax */
d249 1
@


1.31
log
@automatic
@
text
@d3 4
a6 4
 * $Header: /res/usr/vince/src/skey/RCS/skeylogin.c,v 1.30 1995/05/10 17:10:48 vince Exp $
 * $Date: 1995/05/10 17:10:48 $
 * $Revision: 1.30 $
 * $Locker:  $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: skeylogin.c,v 1.30 1995/05/10 17:10:48 vince Exp $";
d273 1
a273 5
	/* access() is considered harmful _H* */
	if (stat(SKEYDCONF, &statbuf) != -1) {
		if (statbuf.st_mode & S_IROTH ||
		(statbuf.st_mode & S_IRGRP && getegid() == statbuf.st_gid) ||
		(statbuf.st_mode & S_IRUSR && geteuid() == statbuf.st_uid))
d275 2
a276 1
	}
@


1.30
log
@automatic
@
text
@d3 4
a6 4
 * $Header: /res/usr/vince/src/skey/RCS/skeylogin.c,v 1.29 1995/04/22 17:19:22 vince Exp vince $
 * $Date: 1995/04/22 17:19:22 $
 * $Revision: 1.29 $
 * $Locker: vince $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: skeylogin.c,v 1.29 1995/04/22 17:19:22 vince Exp vince $";
a36 1
#define SKEYDCONF "/etc/skeydconf"
d271 1
d273 8
d283 1
d576 1
a576 1
	talk.flag = htonl(flag);
d680 2
d734 2
@


1.29
log
@automatic
@
text
@d3 3
a5 3
 * $Header: /res/usr/vince/src/skey/RCS/skeylogin.c,v 1.28 1995/04/22 17:16:25 vince Exp vince $
 * $Date: 1995/04/22 17:16:25 $
 * $Revision: 1.28 $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: skeylogin.c,v 1.28 1995/04/22 17:16:25 vince Exp vince $";
d494 5
d500 4
d576 1
a576 1
	if (write_data(s, &talk, sizeof(talk)) == -1) {
d584 1
a584 1
	if (read_data(s, &talk, sizeof(talk)) == -1) {
d617 1
a617 1
int		read_data(s, buf, n)
d632 4
a635 2
	else if (br < 0)
		return(-1);
d640 1
a640 1
int		write_data(s, buf, n)
d667 1
a667 1
	long			t;
@


1.28
log
@automatic
@
text
@d3 3
a5 3
 * $Header: /res/usr/vince/src/skey/RCS/skeylogin.c,v 1.27 1995/04/22 09:56:56 vince Exp vince $
 * $Date: 1995/04/22 09:56:56 $
 * $Revision: 1.27 $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: skeylogin.c,v 1.27 1995/04/22 09:56:56 vince Exp vince $";
d668 1
a668 1
/*
a677 2
*/
	memcpy(talk->iv, ivbuf, 8);
@


1.27
log
@automatic
@
text
@d3 4
a6 4
 * $Header: /res/usr/vince/src/skey/RCS/skeylogin.c,v 1.26 1995/04/18 12:08:40 vince Exp $
 * $Date: 1995/04/18 12:08:40 $
 * $Revision: 1.26 $
 * $Locker:  $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: skeylogin.c,v 1.26 1995/04/18 12:08:40 vince Exp $";
d47 1
a47 1
#include "md5.h"
d457 1
a457 1
	MD5_CTX		mdContext;
d461 1
d475 4
a478 3
			MD5Init(&mdContext);
			MD5Update(&mdContext, q, strlen(q));
			MD5Final(&mdContext);
d480 2
a481 5
				mdContext.digest[i] ^= mdContext.digest[i + 8];
			/* this is a bug!
			des_string_to_key(mdContext.digest, &key);
			*/
			memcpy(&key, mdContext.digest, 8);
d654 1
a654 1
	MD5_CTX			mdContext;
d660 1
a660 1
	MD5Init(&mdContext);
d663 2
a664 3
	MD5Update(&mdContext, (unsigned char *) talk + begin, end);
	MD5Final(&mdContext);
	memcpy(talk->checksum, mdContext.digest, 16);
d668 1
d677 2
d696 1
a696 1
	MD5_CTX			mdContext;
d698 1
d708 1
a708 1
	MD5Init(&mdContext);
d712 2
a713 2
	MD5Update(&mdContext, (unsigned char *) talk + begin, end);
	MD5Final(&mdContext);
d715 1
a715 1
	return (memcmp(talk->checksum, mdContext.digest, 16));
@


1.26
log
@automatic
@
text
@d3 4
a6 4
 * $Header: /res/usr/vince/src/skey/RCS/skeylogin.c,v 1.25 1995/04/14 16:51:41 vince Exp vince $
 * $Date: 1995/04/14 16:51:41 $
 * $Revision: 1.25 $
 * $Locker: vince $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: skeylogin.c,v 1.25 1995/04/14 16:51:41 vince Exp vince $";
a667 27
#ifdef DEBUG
	puts("THIS is talkencode()");
	printf("ENCODE\n");
	{
		int	i;
		printf("IV: ");
		for (i = 0; i < 8; i++)
			printf("%02x", talk->iv[i]);
		printf("\n");
		printf("md calcolato: ");
		for (i = 0; i < 16; i++)
			printf("%02x", mdContext.digest[i]);
		printf("\n");
		printf("md trasmesso: ");
		for (i = 0; i < 16; i++)
			printf("%02x", talk->checksum[i]);
		printf("\n");
		for (i = 0; i < 256; i++)
			printf("%02x", (unsigned char)talk->buf[i]);
		printf("\n");
		printf("%d\n", talk->flag);
		for (i = 0; i < 16; i++)
			printf("%02x", talk->checksum[i]);
		printf("\n");
	}
#endif

a679 13
#ifdef DEBUG
	puts("Before DES");
	{
		int	i;
		for (i = 0; i < 256; i++)
			printf("%02x", (unsigned char) talk->buf[i]);
		printf("\n");
		for (i = 0; i < 16; i++)
			printf("%02x", (unsigned char) talk->checksum[i]);
		printf("\n");
	}
#endif

a687 12
#ifdef DEBUG
	puts("After DES");
	{
		int	i;
		for (i = 0; i < 256; i++)
			printf("%02x", (unsigned char) talk->buf[i]);
		printf("\n");
		for (i = 0; i < 16; i++)
			printf("%02x", (unsigned char) talk->checksum[i]);
		printf("\n");
	}
#endif
a697 11
#ifdef DEBUG
	puts("This is talkdecode()");
	printf("DECODE\n");
	{
		int	i;
		for (i = 0; i < 256; i++)
			printf("%02x", (unsigned char) talk->buf[i]);
		printf("\n");
	}
#endif

a711 25

#ifdef DEBUG
	{
		int	i;
		printf("IV: ");
		for (i = 0; i < 8; i++)
			printf("%02x", talk->iv[i]);
		printf("\n");
		printf("md calcolato: ");
		for (i = 0; i < 16; i++)
			printf("%02x", mdContext.digest[i]);
		printf("\n");
		printf("md ricevuto: ");
		for (i = 0; i < 16; i++)
			printf("%02x", talk->checksum[i]);
		printf("\n");
		for (i = 0; i < 256; i++)
			printf("%02x", (unsigned char)talk->buf[i]);
		printf("\n");
		printf("%d\n", talk->flag);
		for (i = 0; i < 16; i++)
			printf("%02x", talk->checksum[i]);
		printf("\n");
	}
#endif
@


1.25
log
@automatic
@
text
@d3 4
a6 4
 * $Header: /res/usr/vince/src/skey/RCS/skeylogin.c,v 1.24 1995/04/12 16:04:17 vince Exp $
 * $Date: 1995/04/12 16:04:17 $
 * $Revision: 1.24 $
 * $Locker:  $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: skeylogin.c,v 1.24 1995/04/12 16:04:17 vince Exp $";
d57 4
d62 1
d65 1
d82 3
d86 1
d117 3
d121 1
d142 5
a146 1
skeylookup(mp,name)
d149 3
d162 4
d843 3
d847 1
d888 3
d892 1
@


1.24
log
@automatic
@
text
@d3 3
a5 3
 * $Header: /res/usr/vince/src/skey/RCS/skeylogin.c,v 1.23 1995/02/25 14:54:11 vince Exp $
 * $Date: 1995/02/25 14:54:11 $
 * $Revision: 1.23 $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: skeylogin.c,v 1.23 1995/02/25 14:54:11 vince Exp $";
d778 10
a787 1
#endif
a869 8

static void
timeout(s)
int	s;
{
	(void)signal(s, timeout);
	talktimeoutflg++;
}
@


1.23
log
@automatic
@
text
@d3 3
a5 3
 * $Header: /res/usr/vince/src/skey/RCS/skeylogin.c,v 1.22 1995/01/24 15:23:58 vince Exp $
 * $Date: 1995/01/24 15:23:58 $
 * $Revision: 1.22 $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: skeylogin.c,v 1.22 1995/01/24 15:23:58 vince Exp $";
d521 1
a521 1
	sin.sin_port = skeyport;
d534 1
a534 1
	talk.flag = flag;
d569 1
a569 1
	if (talkdecode(&talk) || talk.flag != SKEYDOK) {
@


1.22
log
@automatic
@
text
@d3 4
a6 4
 * $Header: /res/usr/vince/src/skey/RCS/skeylogin.c,v 1.21 1995/01/24 12:50:43 vince Exp vince $
 * $Date: 1995/01/24 12:50:43 $
 * $Revision: 1.21 $
 * $Locker: vince $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: skeylogin.c,v 1.21 1995/01/24 12:50:43 vince Exp vince $";
d506 2
d539 3
a541 2
	(void)signal(SIGALRM, timeout);
	(void)alarm(SKEYTALKTIMEOUT);
d564 2
a565 2
	(void)alarm(0);
	(void)signal(SIGALRM, SIG_DFL);
@


1.21
log
@automatic
@
text
@d3 4
a6 4
 * $Header: /res/usr/vince/src/skey/RCS/skeylogin.c,v 1.20 1995/01/03 11:57:33 vince Exp $
 * $Date: 1995/01/03 11:57:33 $
 * $Revision: 1.20 $
 * $Locker:  $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: skeylogin.c,v 1.20 1995/01/03 11:57:33 vince Exp $";
d38 3
a40 2
#define TALKERROR "ERROR: can't talk with skeyd authentication server\n"
#define CONFERROR "ERROR: can't parse skeyd configuration file\n"
d45 1
d52 2
a152 6
	/*
	printf("%s read succeeded\n", SKEYDCONF);
	printf("skeyserver: %s\n", skeyserver);
	printf("skeyport: %d\n", skeyport);
	*/

a153 1
		perror("skeytalk()");
a283 1
			perror("skeytalk()");
a323 1
			perror("skeytalk()");
d505 1
d509 1
a509 1
		errno = ECONNREFUSED;
d515 1
a515 1
		errno = ECONNREFUSED;
d521 2
a522 1
	if ((s = socket(AF_INET, SOCK_STREAM, 0)) < 0)
d524 1
d527 1
d536 4
d541 4
d549 9
d561 3
d567 2
a568 1
		errno = EPROTO;
d858 8
@


1.20
log
@automatic
@
text
@d3 4
a6 4
 * $Header: /res/usr/vince/src/skey/RCS/skeylogin.c,v 1.19 1995/01/02 17:53:36 vince Exp vince $
 * $Date: 1995/01/02 17:53:36 $
 * $Revision: 1.19 $
 * $Locker: vince $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: skeylogin.c,v 1.19 1995/01/02 17:53:36 vince Exp vince $";
d496 2
d510 6
@


1.19
log
@automatic
@
text
@d3 3
a5 3
 * $Header: /res/usr/vince/src/skey/RCS/skeylogin.c,v 1.18 1995/01/02 17:31:33 vince Exp vince $
 * $Date: 1995/01/02 17:31:33 $
 * $Revision: 1.18 $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: skeylogin.c,v 1.18 1995/01/02 17:31:33 vince Exp vince $";
d38 2
a39 2
#define TALKERROR "Can't talk with skeyd authentication server.\n"
#define CONFERROR "Can't parse skeyd configuration file.\n"
@


1.18
log
@automatic
@
text
@d3 4
a6 4
 * $Header: /res/usr/vince/src/skey/RCS/skeylogin.c,v 1.17 1994/12/28 20:28:08 vince Exp $
 * $Date: 1994/12/28 20:28:08 $
 * $Revision: 1.17 $
 * $Locker:  $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: skeylogin.c,v 1.17 1994/12/28 20:28:08 vince Exp $";
d38 2
d157 1
d288 1
d329 1
d441 1
a441 1
	
d444 1
d495 1
d519 1
a519 1
	
d543 1
a543 1
	
@


1.17
log
@automatic
@
text
@d3 4
a6 4
 * $Header: /res/usr/vince/src/skey/RCS/skeylogin.c,v 1.16 1994/12/18 13:21:12 vince Exp vince $
 * $Date: 1994/12/18 13:21:12 $
 * $Revision: 1.16 $
 * $Locker: vince $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: skeylogin.c,v 1.16 1994/12/18 13:21:12 vince Exp vince $";
d460 1
a460 1
			printf("KEY: ");
d606 1
d645 1
a645 1
	puts("PRIMA");
d666 1
a666 1
	puts("DOPO");
d688 1
d755 68
@


1.16
log
@automatic
@
text
@d3 3
a5 3
 * $Header: /res/usr/vince/src/skey/RCS/skeylogin.c,v 1.15 1994/12/14 09:56:46 vince Exp vince $
 * $Date: 1994/12/14 09:56:46 $
 * $Revision: 1.15 $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: skeylogin.c,v 1.15 1994/12/14 09:56:46 vince Exp vince $";
d453 1
d455 2
d459 1
a459 1
			/*
d464 1
a464 1
			*/
d605 1
a605 1
	/*
d622 1
a622 1
			printf("%02x", talk->buf[i]);
d629 1
a629 1
	*/
d643 1
a643 1
	/*
d654 1
a654 1
	*/
d664 1
a664 1
	/*
d675 1
a675 1
	*/
d686 1
a686 1
	/*
d691 1
a691 1
			printf("%02x", talk->buf[i]);
d694 1
a694 1
	*/
d711 1
a711 1
	/*
d727 1
a727 1
			printf("%02x", talk->buf[i]);
d734 1
a734 1
	*/
@


1.15
log
@automatic
@
text
@d3 3
a5 3
 * $Header: /res/usr/vince/src/skey/RCS/skeylogin.c,v 1.14 1994/12/10 19:44:49 vince Exp vince $
 * $Date: 1994/12/10 19:44:49 $
 * $Revision: 1.14 $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: skeylogin.c,v 1.14 1994/12/10 19:44:49 vince Exp vince $";
d26 1
a32 1
#include <time.h>
@


1.14
log
@automatic
@
text
@d3 4
a6 4
 * $Header: /res/usr/vince/src/skey/RCS/skeylogin.c,v 1.13 1994/12/10 14:17:28 vince Exp $
 * $Date: 1994/12/10 14:17:28 $
 * $Revision: 1.13 $
 * $Locker:  $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: skeylogin.c,v 1.13 1994/12/10 14:17:28 vince Exp $";
a25 2
#include <sys/time.h>
#include <sys/timeb.h>
@


1.13
log
@automatic
@
text
@d3 3
a5 3
 * $Header: /res/usr/vince/src/skey/RCS/skeylogin.c,v 1.12 1994/12/10 13:12:11 vince Exp $
 * $Date: 1994/12/10 13:12:11 $
 * $Revision: 1.12 $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: skeylogin.c,v 1.12 1994/12/10 13:12:11 vince Exp $";
d43 1
d81 1
a81 3
#ifndef SKEYD
		fclose(mp->keyfile);
#endif
d111 1
a111 3
#ifndef SKEYD
		fclose(mp->keyfile);
#endif
a237 3
 struct timeval startval;
 struct timeval endval;
long microsec;
a243 2
	char me[80];
	int rval;
d248 4
d259 1
a259 3
#ifndef SKEYD
		fclose(mp->keyfile);
#endif
d267 1
a267 3
#ifndef SKEYD
		fclose(mp->keyfile);
#endif
d284 16
a299 3
	if (skeytalk(GIVEMEINFO, mp->logname, answer)) {
		perror("skeytalk()");
		return (-1);
a300 2
	strncpy(mp->buf, answer, sizeof(mp->buf));
#else
a301 7
	fseek(mp->keyfile,mp->recstart,0);
	if(fgets(mp->buf,sizeof(mp->buf),mp->keyfile) != mp->buf){
		setpriority(PRIO_PROCESS, 0, 0);
		fclose(mp->keyfile);
		return -1;
	}
#endif
d308 1
a308 1
	atob8(filekey,mp->val);
d314 1
a314 3
#ifndef SKEYD
		fclose(mp->keyfile);
#endif
a317 1
#ifdef SKEYD
d321 8
a328 5
	sprintf(line, "%s %04d %-16s %s %-21s\n",
		mp->logname, mp->n,mp->seed, mp->val, tbuf);
	if (skeytalk(UPDATEKEYS, line, answer)) {
		perror("skeytalk()");
		return (-1);
d330 10
a339 10
#else
	/* Update key in database by overwriting entire record. Note
	 * that we must write exactly the same number of bytes as in
	 * the original record (note fixed width field for N)
	 */
	btoa8(mp->val,key);
	mp->n--;
	fseek(mp->keyfile,mp->recstart,0);
	fprintf(mp->keyfile,"%s %04d %-16s %s %-21s\n",mp->logname,
					mp->n,mp->seed, mp->val, tbuf);
d341 2
a342 2
	fclose(mp->keyfile);
#endif /* SKEYD */
d455 2
a456 2
			des_string_to_key(mdContext.digest, key);
			des_set_key(key, &schedule);
d481 1
a481 1
	if (fclose(fp) == -1) {
d595 1
d636 4
a639 3
	des_ecb_encrypt(ivbuf, ivbuf, &schedule, DES_ENCRYPT);
	des_ecb_encrypt(ivbuf, ivbuf, &schedule, DES_ENCRYPT);
	des_ecb_encrypt(ivbuf, ivbuf, &schedule, DES_ENCRYPT);
d657 2
a658 1
			sizeof(talk->buf), &schedule, talk->iv, DES_ENCRYPT);
d661 2
a662 2
			sizeof(talk->checksum), &schedule,
			talk->iv, DES_ENCRYPT);
d696 2
a697 1
			sizeof(talk->buf), &schedule, talk->iv, DES_DECRYPT);
d700 2
a701 2
			sizeof(talk->checksum), &schedule,
			talk->iv, DES_DECRYPT);
d738 14
@


1.12
log
@automatic
@
text
@d3 4
a6 4
 * $Header: /res/usr/vince/src/skey/RCS/skeylogin.c,v 1.10 1994/12/10 11:22:09 vince Exp vince $
 * $Date: 1994/12/10 11:22:09 $
 * $Revision: 1.10 $
 * $Locker: vince $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: skeylogin.c,v 1.10 1994/12/10 11:22:09 vince Exp vince $";
d447 1
@


1.11
log
@automatic
@
text
@d149 1
a149 2
	if (readskeydconf()) {
		perror(SKEYDCONF);
a150 1
	}
d443 2
a444 1
	if ((fp = fopen(SKEYDCONF, "r")) == NULL)
d446 1
d479 7
a485 1
	if (errno || fclose(fp) == -1)
d487 2
@


1.10
log
@automatic
@
text
@d2 5
a6 5
 * $Author:$
 * $Header:$
 * $Date:$
 * $Revision:$
 * $Locker:$
d10 1
a10 1
static char *rcsid = "@@(#) $Id:$";
d13 2
a14 2

/*   Login code for S/KEY Authentication.  S/KEY is a trademark
d283 1
a283 1
	f(fkey);
a290 3
/*
  gettimeofday(&startval, (char *)0 );
*/
d344 2
a345 8
	fprintf(mp->keyfile,"%s %04d %-16s %s %-21s\n",mp->logname,mp->n,mp->seed,
	mp->val, tbuf);
/*
gettimeofday(&endval, (char *)0 );
 microsec = (endval.tv_sec - startval.tv_sec) * 1000000 + (endval.tv_usec - startval.tv_usec);
fprintf(stderr, "window= %d micro seconds \n"  , microsec);
*/

d461 1
d466 1
@


1.9
log
@automatic
@
text
@d1 13
@


1.8
log
@automatic
@
text
@d141 1
d145 1
d518 2
d629 1
d636 3
d640 1
d649 1
d656 3
d660 1
d687 1
a687 4
	/*
	des_cbc_encrypt((des_cblock *)talk + 8, (des_cblock *)talk + 8, sizeof(struct skeymessage) - 8,
					&schedule, talk->iv, DES_DECRYPT);
	*/
@


1.7
log
@automatic
@
text
@d35 1
a35 1
static des_key_schedule	schedule;
d435 1
d452 3
a454 1
			des_set_key(mdContext.digest, &schedule);
d457 1
a457 1
				printf("%02x", mdContext.digest[i]);
d459 1
d625 22
a646 3
	/* encrypt all message but trailing IV */
	des_cbc_encrypt(talk + 8, talk + 8, sizeof(struct skeymessage) - 8,
					&schedule, talk->iv, DES_ENCRYPT);
d657 18
a674 1
	des_cbc_encrypt(talk + 8, talk + 8, sizeof(struct skeymessage) - 8,
d676 1
a684 1
	printf("DECODE\n");
@


1.6
log
@automatic
@
text
@d5 2
a6 1
 *   Many references for mink  may still be found in this program.   */
d33 3
a35 3
static char	*skeyserver;
static char	*skeypwd;
static int	skeyport;
a140 1
	/*
a141 1
	printf("skeypwd: %s\n", skeypwd);
a143 1
	*/
d431 1
a431 1
	char		line[80];
d434 3
d445 14
a458 3
		if (!strncasecmp(p, SKEYPWD, strlen(SKEYPWD)))
			skeypwd = strdup(q);
		else if (!strncasecmp(p, SKEYSERVER, strlen(SKEYSERVER)))
d460 3
a462 1
		else if (!strncasecmp(p, SKEYPORT, strlen(SKEYPORT)))
d464 2
d469 4
a502 1
	printf("write data...\n");
a507 1
	printf("read data...\n");
d571 1
a571 2
	des_key_schedule	schedule;
	des_cblock		key, iv;
d573 3
d578 3
a580 2
	/* skip checksum, padding */
	MD5Update(&mdContext, talk, sizeof(struct skeymessage) - 16 - 8);
d584 40
a623 5
	des_string_to_key(skeypwd, key);
	des_set_key(key, &schedule);
	bzero(iv, sizeof(iv));
	des_cbc_encrypt(talk, talk, sizeof(struct skeymessage),
						&schedule, &iv, DES_ENCRYPT);
d630 1
a630 2
	des_key_schedule	schedule;
	des_cblock		key, iv;
d632 1
a632 1
	int			i, len;
d634 2
a635 5
	des_string_to_key(skeypwd, key);
	des_set_key(key, &schedule);
	bzero(iv, sizeof(iv));
	des_cbc_encrypt(talk, talk, sizeof(struct skeymessage),
						&schedule, &iv, DES_DECRYPT);
d638 3
a640 1
	MD5Update(&mdContext, talk, sizeof(struct skeymessage) - 16 - 8);
d643 25
a667 3
	for (i = 0; i < 16; i++)
		printf("%x", mdContext.digest[i]);
	printf("\n");
@


1.5
log
@automatic
@
text
@a87 1
	/* vince */
d124 1
a124 2
	/* uno */
	static char		*answer;
d147 1
a147 1
	if ((answer = strdup(skeytalk(GIVEMEINFO, name))) == NULL) {
d244 1
a244 1
	char	line[256], *answer;
d284 1
a284 1
	if ((answer = skeytalk(GIVEMEINFO, mp->logname)) == NULL) {
a316 1
	/* due */
d322 1
a322 1
	if ((answer = skeytalk(UPDATEKEYS, line)) == NULL) {
a325 5
	/* rip(answer); */
	if (strcmp(answer, SKEYDOK) || strlen(SKEYDOK) != strlen(answer)) {
		printf("`%s' != %s\n", answer, SKEYDOK);
		return(-1);
	}
d456 3
a458 4
char *
skeytalk(querytype, input)
char	*input;
int	querytype;
d460 1
a460 1
	static struct skeymessage		talk;
d467 1
a467 1
		return (NULL);
d473 1
a473 1
		return (NULL);
d476 1
a476 2
		(void)close(s);
		return (NULL);
d480 1
a480 1
	talk.querytype = querytype;
d483 1
d486 1
a486 2
		(void)close(s);
		return (NULL);
d489 1
d491 1
a491 2
		(void)close(s);
		return (NULL);
d493 4
a496 3
	if (talkdecode(&talk)) {
		(void)close(s);
		return (NULL);
d500 2
a501 1
	return(talk.buf);
@


1.4
log
@automatic
@
text
@d597 4
@


1.3
log
@automatic
@
text
@d30 1
a30 1
#include "md4.h"
a324 1
	/* fix: checksum crypt ecc */
a491 1
	/* fix: checksum, encryption */
d563 1
a563 1
	MDstruct		md;
d565 5
a569 4
	MDbegin(&md);
	MDupdate(&md, (unsigned char *) talk,
				sizeof(struct skeymessage) - 16 - 8);
	memcpy(talk->checksum, md.buffer, 16);
d584 2
a585 1
	MDstruct		md;
d592 4
a595 3
	MDbegin(&md);
	MDupdate(&md, (unsigned char *) talk,
				sizeof(struct skeymessage) - 16 - 8);
d597 1
a597 1
	return (memcmp(talk->checksum, md.buffer, 16));
@


1.2
log
@automatic
@
text
@a15 1
 
d29 2
a453 3
			/*
			strncpy(conf->skeypwd, q, sizeof(conf->skeypwd) - 1);
			*/
a455 3
			/*
			strncpy(conf->skeyserver, q, sizeof(conf->skeyserver) - 1);
			*/
a457 3
			/*
			conf->skeyport = atoi(q);
			*/
d495 1
d505 4
d560 38
@


1.1
log
@auto
@
text
@a24 1
#define	KEYFILE	"/etc/skeykeys"
d30 4
d65 1
d67 1
d98 3
a100 2
		if (mp->keyfile) /* vince */
			fclose(mp->keyfile);
d124 2
a125 2
	struct skeydconf	skeydconf;
	char			*answer;
d136 1
a136 1
	if (readskeydconf(&skeydconf)) {
d141 1
d143 4
a146 3
	printf("skeypwd: %s\n", skeydconf.skeypwd);
	printf("skeyserver: %s\n", skeydconf.skeyserver);
	printf("skeyport: %d\n", skeydconf.skeyport);
d148 1
a148 2
	if ((answer = skeytalk(GIVEMEINFO, name, skeydconf.skeyserver,
	    skeydconf.skeyport, skeydconf.skeypwd)) == NULL) {
a152 2
	printf("received from %s: `%s'\n", skeydconf.skeyserver, answer);

d245 1
d253 1
d255 1
d261 1
a261 1
	if(etob(key,response) != 1 && atob8(key,response) != 0){
d263 1
d265 1
d284 7
d298 1
d311 1
d313 1
d318 1
d321 2
a322 2
	talk.qyerytype = UPDATEKEYS;
	fprintf(talk.buf, "%s %04d %-16s %s %-21s\n",
d325 1
a325 3

	if ((answer = skeytalk(GIVEMEINFO, name, skeydconf.skeyserver,
	    skeydconf.skeyport, skeydconf.skeypwd)) == NULL) {
d329 5
a333 2
	/*questa e` la struttura che lui sta per scrivere*/

d353 1
a353 1
	
d438 1
a438 2
readskeydconf(conf)
struct skeydconf *conf;
d453 1
d455 2
d458 1
d460 2
d463 1
d465 2
d474 3
a476 3
skeytalk(querytype, input, server, port, pwd)
char	*input, *server, *pwd;
int	querytype, port;
d478 1
a480 1
	static struct skeymessage		talk;
d483 1
a483 1
	if ((sin.sin_addr.s_addr = inet_addr(server)) == -1) {
d488 1
a488 1
	sin.sin_port = port;
a497 2
	printf("connected with %s/%d\n", server, port);

d499 2
a500 4
	if (querytype == GIVEMEINFO) {
		talk.querytype = GIVEMEINFO;
		strncpy(talk.buf, input, sizeof(talk.buf));
	}
@
