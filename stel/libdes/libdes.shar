#! /bin/sh
# This is a shell archive.  Remove anything before this line, then feed it
# into a shell via "sh file" or similar.  To overwrite existing files,
# type "sh file -c".
# The tool that generated this appeared in the comp.sources.unix newsgroup;
# send mail to comp-sources-unix@uunet.uu.net if you want that tool.
# Contents:  ARTISTIC COPYING FILES INSTALL Imakefile README VERSION
#   makefile times vms.com KERBEROS MODES.DES CHANGES des.c des.man
#   destest.c speed.c rpw.c des_crypt.man des.h cbc_cksm.c cbc_enc.c
#   ecb_enc.c enc_read.c enc_writ.c pcbc_enc.c qud_cksm.c rand_key.c
#   read_pwd.c set_key.c str2key.c fcrypt.c des_locl.h podd.h sk.h
#   spr.h cfb_enc.c 3ecb_enc.c ofb_enc.c 3cbc_enc.c des.pl testdes.pl
#   doIP doPC1 doPC2 PC1 PC2 shifts.pl
# Wrapped by taino@idea on Sat Jan  7 16:58:39 1995
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
echo If this archive is complete, you will see the following message:
echo '          "shar: End of archive."'
if test -f 'ARTISTIC' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'ARTISTIC'\"
else
  echo shar: Extracting \"'ARTISTIC'\" \(4642 characters\)
  sed "s/^X//" >'ARTISTIC' <<'END_OF_FILE'
X
X			 The "Artistic License"
X
X				Preamble
X
XThe intent of this document is to state the conditions under which a
XPackage may be copied, such that the Copyright Holder maintains some
Xsemblance of artistic control over the development of the package,
Xwhile giving the users of the package the right to use and distribute
Xthe Package in a more-or-less customary fashion, plus the right to make
Xreasonable modifications.
X
XDefinitions:
X
X	"Package" refers to the collection of files distributed by the
X	Copyright Holder, and derivatives of that collection of files
X	created through textual modification.
X
X	"Standard Version" refers to such a Package if it has not been
X	modified, or has been modified in accordance with the wishes
X	of the Copyright Holder as specified below.
X
X	"Copyright Holder" is whoever is named in the copyright or
X	copyrights for the package.
X
X	"You" is you, if you're thinking about copying or distributing
X	this Package.
X
X	"Reasonable copying fee" is whatever you can justify on the
X	basis of media cost, duplication charges, time of people involved,
X	and so on.  (You will not be required to justify it to the
X	Copyright Holder, but only to the computing community at large
X	as a market that must bear the fee.)
X
X	"Freely Available" means that no fee is charged for the item
X	itself, though there may be fees involved in handling the item.
X	It also means that recipients of the item may redistribute it
X	under the same conditions they received it.
X
X1. You may make and give away verbatim copies of the source form of the
XStandard Version of this Package without restriction, provided that you
Xduplicate all of the original copyright notices and associated disclaimers.
X
X2. You may apply bug fixes, portability fixes and other modifications
Xderived from the Public Domain or from the Copyright Holder.  A Package
Xmodified in such a way shall still be considered the Standard Version.
X
X3. You may otherwise modify your copy of this Package in any way, provided
Xthat you insert a prominent notice in each changed file stating how and
Xwhen you changed that file, and provided that you do at least ONE of the
Xfollowing:
X
X    a) place your modifications in the Public Domain or otherwise make them
X    Freely Available, such as by posting said modifications to Usenet or
X    an equivalent medium, or placing the modifications on a major archive
X    site such as uunet.uu.net, or by allowing the Copyright Holder to include
X    your modifications in the Standard Version of the Package.
X
X    b) use the modified Package only within your corporation or organization.
X
X    c) rename any non-standard executables so the names do not conflict
X    with standard executables, which must also be provided, and provide
X    a separate manual page for each non-standard executable that clearly
X    documents how it differs from the Standard Version.
X
X    d) make other distribution arrangements with the Copyright Holder.
X
X4. You may distribute the programs of this Package in object code or
Xexecutable form, provided that you do at least ONE of the following:
X
X    a) distribute a Standard Version of the executables and library files,
X    together with instructions (in the manual page or equivalent) on where
X    to get the Standard Version.
X
X    b) accompany the distribution with the machine-readable source of
X    the Package with your modifications.
X
X    c) give non-standard executables non-standard names, and clearly
X    document the differences in manual pages (or equivalent), together
X    with instructions on where to get the Standard Version.
X
X    d) make other distribution arrangements with the Copyright Holder.
X
X5. You may charge a reasonable copying fee for any distribution of this
XPackage.  You may charge any fee you choose for support of this
XPackage.  You may not charge a fee for this Package itself.  However,
Xyou may distribute this Package in aggregate with other (possibly
Xcommercial) programs as part of a larger (possibly commercial) software
Xdistribution provided that you do not advertise this Package as a
Xproduct of your own.
X
X6. Any programs linked with this library do not automatically fall
Xunder the copyright of this Package, but belong to whomever generated
Xthem, and may be sold commercially, and may be aggregated with this
XPackage.
X
X7. The name of the Copyright Holder may not be used to endorse or promote
Xproducts derived from this software without specific prior written permission.
X
X8. THIS PACKAGE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR
XIMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
XWARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
X
X				The End
X
END_OF_FILE
  if test 4642 -ne `wc -c <'ARTISTIC'`; then
    echo shar: \"'ARTISTIC'\" unpacked with wrong size!
  fi
  # end of 'ARTISTIC'
fi
if test -f 'COPYING' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'COPYING'\"
else
  echo shar: Extracting \"'COPYING'\" \(25510 characters\)
  sed "s/^X//" >'COPYING' <<'END_OF_FILE'
XCopyright (C) 1993 Eric Young
X
XThis is a DES implementation written by Eric Young (eay@psych.psy.uq.oz.au)
XThe implementation was written so as to conform with the manual entry
Xfor the des_crypt(3) library routines from MIT's project Athena.
X
X
X
X		  GNU LIBRARY GENERAL PUBLIC LICENSE
X		       Version 2, June 1991
X
X Copyright (C) 1991 Free Software Foundation, Inc.
X                    675 Mass Ave, Cambridge, MA 02139, USA
X Everyone is permitted to copy and distribute verbatim copies
X of this license document, but changing it is not allowed.
X
X[This is the first released version of the library GPL.  It is
X numbered 2 because it goes with version 2 of the ordinary GPL.]
X
X			    Preamble
X
X  The licenses for most software are designed to take away your
Xfreedom to share and change it.  By contrast, the GNU General Public
XLicenses are intended to guarantee your freedom to share and change
Xfree software--to make sure the software is free for all its users.
X
X  This license, the Library General Public License, applies to some
Xspecially designated Free Software Foundation software, and to any
Xother libraries whose authors decide to use it.  You can use it for
Xyour libraries, too.
X
X  When we speak of free software, we are referring to freedom, not
Xprice.  Our General Public Licenses are designed to make sure that you
Xhave the freedom to distribute copies of free software (and charge for
Xthis service if you wish), that you receive source code or can get it
Xif you want it, that you can change the software or use pieces of it
Xin new free programs; and that you know you can do these things.
X
X  To protect your rights, we need to make restrictions that forbid
Xanyone to deny you these rights or to ask you to surrender the rights.
XThese restrictions translate to certain responsibilities for you if
Xyou distribute copies of the library, or if you modify it.
X
X  For example, if you distribute copies of the library, whether gratis
Xor for a fee, you must give the recipients all the rights that we gave
Xyou.  You must make sure that they, too, receive or can get the source
Xcode.  If you link a program with the library, you must provide
Xcomplete object files to the recipients so that they can relink them
Xwith the library, after making changes to the library and recompiling
Xit.  And you must show them these terms so they know their rights.
X
X  Our method of protecting your rights has two steps: (1) copyright
Xthe library, and (2) offer you this license which gives you legal
Xpermission to copy, distribute and/or modify the library.
X
X  Also, for each distributor's protection, we want to make certain
Xthat everyone understands that there is no warranty for this free
Xlibrary.  If the library is modified by someone else and passed on, we
Xwant its recipients to know that what they have is not the original
Xversion, so that any problems introduced by others will not reflect on
Xthe original authors' reputations.
X
X  Finally, any free program is threatened constantly by software
Xpatents.  We wish to avoid the danger that companies distributing free
Xsoftware will individually obtain patent licenses, thus in effect
Xtransforming the program into proprietary software.  To prevent this,
Xwe have made it clear that any patent must be licensed for everyone's
Xfree use or not licensed at all.
X
X  Most GNU software, including some libraries, is covered by the ordinary
XGNU General Public License, which was designed for utility programs.  This
Xlicense, the GNU Library General Public License, applies to certain
Xdesignated libraries.  This license is quite different from the ordinary
Xone; be sure to read it in full, and don't assume that anything in it is
Xthe same as in the ordinary license.
X
X  The reason we have a separate public license for some libraries is that
Xthey blur the distinction we usually make between modifying or adding to a
Xprogram and simply using it.  Linking a program with a library, without
Xchanging the library, is in some sense simply using the library, and is
Xanalogous to running a utility program or application program.  However, in
Xa textual and legal sense, the linked executable is a combined work, a
Xderivative of the original library, and the ordinary General Public License
Xtreats it as such.
X
X  Because of this blurred distinction, using the ordinary General
XPublic License for libraries did not effectively promote software
Xsharing, because most developers did not use the libraries.  We
Xconcluded that weaker conditions might promote sharing better.
X
X  However, unrestricted linking of non-free programs would deprive the
Xusers of those programs of all benefit from the free status of the
Xlibraries themselves.  This Library General Public License is intended to
Xpermit developers of non-free programs to use free libraries, while
Xpreserving your freedom as a user of such programs to change the free
Xlibraries that are incorporated in them.  (We have not seen how to achieve
Xthis as regards changes in header files, but we have achieved it as regards
Xchanges in the actual functions of the Library.)  The hope is that this
Xwill lead to faster development of free libraries.
X
X  The precise terms and conditions for copying, distribution and
Xmodification follow.  Pay close attention to the difference between a
X"work based on the library" and a "work that uses the library".  The
Xformer contains code derived from the library, while the latter only
Xworks together with the library.
X
X  Note that it is possible for a library to be covered by the ordinary
XGeneral Public License rather than by this special one.
X
X		  GNU LIBRARY GENERAL PUBLIC LICENSE
X   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
X
X  0. This License Agreement applies to any software library which
Xcontains a notice placed by the copyright holder or other authorized
Xparty saying it may be distributed under the terms of this Library
XGeneral Public License (also called "this License").  Each licensee is
Xaddressed as "you".
X
X  A "library" means a collection of software functions and/or data
Xprepared so as to be conveniently linked with application programs
X(which use some of those functions and data) to form executables.
X
X  The "Library", below, refers to any such software library or work
Xwhich has been distributed under these terms.  A "work based on the
XLibrary" means either the Library or any derivative work under
Xcopyright law: that is to say, a work containing the Library or a
Xportion of it, either verbatim or with modifications and/or translated
Xstraightforwardly into another language.  (Hereinafter, translation is
Xincluded without limitation in the term "modification".)
X
X  "Source code" for a work means the preferred form of the work for
Xmaking modifications to it.  For a library, complete source code means
Xall the source code for all modules it contains, plus any associated
Xinterface definition files, plus the scripts used to control compilation
Xand installation of the library.
X
X  Activities other than copying, distribution and modification are not
Xcovered by this License; they are outside its scope.  The act of
Xrunning a program using the Library is not restricted, and output from
Xsuch a program is covered only if its contents constitute a work based
Xon the Library (independent of the use of the Library in a tool for
Xwriting it).  Whether that is true depends on what the Library does
Xand what the program that uses the Library does.
X  
X  1. You may copy and distribute verbatim copies of the Library's
Xcomplete source code as you receive it, in any medium, provided that
Xyou conspicuously and appropriately publish on each copy an
Xappropriate copyright notice and disclaimer of warranty; keep intact
Xall the notices that refer to this License and to the absence of any
Xwarranty; and distribute a copy of this License along with the
XLibrary.
X
X  You may charge a fee for the physical act of transferring a copy,
Xand you may at your option offer warranty protection in exchange for a
Xfee.
X
X  2. You may modify your copy or copies of the Library or any portion
Xof it, thus forming a work based on the Library, and copy and
Xdistribute such modifications or work under the terms of Section 1
Xabove, provided that you also meet all of these conditions:
X
X    a) The modified work must itself be a software library.
X
X    b) You must cause the files modified to carry prominent notices
X    stating that you changed the files and the date of any change.
X
X    c) You must cause the whole of the work to be licensed at no
X    charge to all third parties under the terms of this License.
X
X    d) If a facility in the modified Library refers to a function or a
X    table of data to be supplied by an application program that uses
X    the facility, other than as an argument passed when the facility
X    is invoked, then you must make a good faith effort to ensure that,
X    in the event an application does not supply such function or
X    table, the facility still operates, and performs whatever part of
X    its purpose remains meaningful.
X
X    (For example, a function in a library to compute square roots has
X    a purpose that is entirely well-defined independent of the
X    application.  Therefore, Subsection 2d requires that any
X    application-supplied function or table used by this function must
X    be optional: if the application does not supply it, the square
X    root function must still compute square roots.)
X
XThese requirements apply to the modified work as a whole.  If
Xidentifiable sections of that work are not derived from the Library,
Xand can be reasonably considered independent and separate works in
Xthemselves, then this License, and its terms, do not apply to those
Xsections when you distribute them as separate works.  But when you
Xdistribute the same sections as part of a whole which is a work based
Xon the Library, the distribution of the whole must be on the terms of
Xthis License, whose permissions for other licensees extend to the
Xentire whole, and thus to each and every part regardless of who wrote
Xit.
X
XThus, it is not the intent of this section to claim rights or contest
Xyour rights to work written entirely by you; rather, the intent is to
Xexercise the right to control the distribution of derivative or
Xcollective works based on the Library.
X
XIn addition, mere aggregation of another work not based on the Library
Xwith the Library (or with a work based on the Library) on a volume of
Xa storage or distribution medium does not bring the other work under
Xthe scope of this License.
X
X  3. You may opt to apply the terms of the ordinary GNU General Public
XLicense instead of this License to a given copy of the Library.  To do
Xthis, you must alter all the notices that refer to this License, so
Xthat they refer to the ordinary GNU General Public License, version 2,
Xinstead of to this License.  (If a newer version than version 2 of the
Xordinary GNU General Public License has appeared, then you can specify
Xthat version instead if you wish.)  Do not make any other change in
Xthese notices.
X
X  Once this change is made in a given copy, it is irreversible for
Xthat copy, so the ordinary GNU General Public License applies to all
Xsubsequent copies and derivative works made from that copy.
X
X  This option is useful when you wish to copy part of the code of
Xthe Library into a program that is not a library.
X
X  4. You may copy and distribute the Library (or a portion or
Xderivative of it, under Section 2) in object code or executable form
Xunder the terms of Sections 1 and 2 above provided that you accompany
Xit with the complete corresponding machine-readable source code, which
Xmust be distributed under the terms of Sections 1 and 2 above on a
Xmedium customarily used for software interchange.
X
X  If distribution of object code is made by offering access to copy
Xfrom a designated place, then offering equivalent access to copy the
Xsource code from the same place satisfies the requirement to
Xdistribute the source code, even though third parties are not
Xcompelled to copy the source along with the object code.
X
X  5. A program that contains no derivative of any portion of the
XLibrary, but is designed to work with the Library by being compiled or
Xlinked with it, is called a "work that uses the Library".  Such a
Xwork, in isolation, is not a derivative work of the Library, and
Xtherefore falls outside the scope of this License.
X
X  However, linking a "work that uses the Library" with the Library
Xcreates an executable that is a derivative of the Library (because it
Xcontains portions of the Library), rather than a "work that uses the
Xlibrary".  The executable is therefore covered by this License.
XSection 6 states terms for distribution of such executables.
X
X  When a "work that uses the Library" uses material from a header file
Xthat is part of the Library, the object code for the work may be a
Xderivative work of the Library even though the source code is not.
XWhether this is true is especially significant if the work can be
Xlinked without the Library, or if the work is itself a library.  The
Xthreshold for this to be true is not precisely defined by law.
X
X  If such an object file uses only numerical parameters, data
Xstructure layouts and accessors, and small macros and small inline
Xfunctions (ten lines or less in length), then the use of the object
Xfile is unrestricted, regardless of whether it is legally a derivative
Xwork.  (Executables containing this object code plus portions of the
XLibrary will still fall under Section 6.)
X
X  Otherwise, if the work is a derivative of the Library, you may
Xdistribute the object code for the work under the terms of Section 6.
XAny executables containing that work also fall under Section 6,
Xwhether or not they are linked directly with the Library itself.
X
X  6. As an exception to the Sections above, you may also compile or
Xlink a "work that uses the Library" with the Library to produce a
Xwork containing portions of the Library, and distribute that work
Xunder terms of your choice, provided that the terms permit
Xmodification of the work for the customer's own use and reverse
Xengineering for debugging such modifications.
X
X  You must give prominent notice with each copy of the work that the
XLibrary is used in it and that the Library and its use are covered by
Xthis License.  You must supply a copy of this License.  If the work
Xduring execution displays copyright notices, you must include the
Xcopyright notice for the Library among them, as well as a reference
Xdirecting the user to the copy of this License.  Also, you must do one
Xof these things:
X
X    a) Accompany the work with the complete corresponding
X    machine-readable source code for the Library including whatever
X    changes were used in the work (which must be distributed under
X    Sections 1 and 2 above); and, if the work is an executable linked
X    with the Library, with the complete machine-readable "work that
X    uses the Library", as object code and/or source code, so that the
X    user can modify the Library and then relink to produce a modified
X    executable containing the modified Library.  (It is understood
X    that the user who changes the contents of definitions files in the
X    Library will not necessarily be able to recompile the application
X    to use the modified definitions.)
X
X    b) Accompany the work with a written offer, valid for at
X    least three years, to give the same user the materials
X    specified in Subsection 6a, above, for a charge no more
X    than the cost of performing this distribution.
X
X    c) If distribution of the work is made by offering access to copy
X    from a designated place, offer equivalent access to copy the above
X    specified materials from the same place.
X
X    d) Verify that the user has already received a copy of these
X    materials or that you have already sent this user a copy.
X
X  For an executable, the required form of the "work that uses the
XLibrary" must include any data and utility programs needed for
Xreproducing the executable from it.  However, as a special exception,
Xthe source code distributed need not include anything that is normally
Xdistributed (in either source or binary form) with the major
Xcomponents (compiler, kernel, and so on) of the operating system on
Xwhich the executable runs, unless that component itself accompanies
Xthe executable.
X
X  It may happen that this requirement contradicts the license
Xrestrictions of other proprietary libraries that do not normally
Xaccompany the operating system.  Such a contradiction means you cannot
Xuse both them and the Library together in an executable that you
Xdistribute.
X
X  7. You may place library facilities that are a work based on the
XLibrary side-by-side in a single library together with other library
Xfacilities not covered by this License, and distribute such a combined
Xlibrary, provided that the separate distribution of the work based on
Xthe Library and of the other library facilities is otherwise
Xpermitted, and provided that you do these two things:
X
X    a) Accompany the combined library with a copy of the same work
X    based on the Library, uncombined with any other library
X    facilities.  This must be distributed under the terms of the
X    Sections above.
X
X    b) Give prominent notice with the combined library of the fact
X    that part of it is a work based on the Library, and explaining
X    where to find the accompanying uncombined form of the same work.
X
X  8. You may not copy, modify, sublicense, link with, or distribute
Xthe Library except as expressly provided under this License.  Any
Xattempt otherwise to copy, modify, sublicense, link with, or
Xdistribute the Library is void, and will automatically terminate your
Xrights under this License.  However, parties who have received copies,
Xor rights, from you under this License will not have their licenses
Xterminated so long as such parties remain in full compliance.
X
X  9. You are not required to accept this License, since you have not
Xsigned it.  However, nothing else grants you permission to modify or
Xdistribute the Library or its derivative works.  These actions are
Xprohibited by law if you do not accept this License.  Therefore, by
Xmodifying or distributing the Library (or any work based on the
XLibrary), you indicate your acceptance of this License to do so, and
Xall its terms and conditions for copying, distributing or modifying
Xthe Library or works based on it.
X
X  10. Each time you redistribute the Library (or any work based on the
XLibrary), the recipient automatically receives a license from the
Xoriginal licensor to copy, distribute, link with or modify the Library
Xsubject to these terms and conditions.  You may not impose any further
Xrestrictions on the recipients' exercise of the rights granted herein.
XYou are not responsible for enforcing compliance by third parties to
Xthis License.
X
X  11. If, as a consequence of a court judgment or allegation of patent
Xinfringement or for any other reason (not limited to patent issues),
Xconditions are imposed on you (whether by court order, agreement or
Xotherwise) that contradict the conditions of this License, they do not
Xexcuse you from the conditions of this License.  If you cannot
Xdistribute so as to satisfy simultaneously your obligations under this
XLicense and any other pertinent obligations, then as a consequence you
Xmay not distribute the Library at all.  For example, if a patent
Xlicense would not permit royalty-free redistribution of the Library by
Xall those who receive copies directly or indirectly through you, then
Xthe only way you could satisfy both it and this License would be to
Xrefrain entirely from distribution of the Library.
X
XIf any portion of this section is held invalid or unenforceable under any
Xparticular circumstance, the balance of the section is intended to apply,
Xand the section as a whole is intended to apply in other circumstances.
X
XIt is not the purpose of this section to induce you to infringe any
Xpatents or other property right claims or to contest validity of any
Xsuch claims; this section has the sole purpose of protecting the
Xintegrity of the free software distribution system which is
Ximplemented by public license practices.  Many people have made
Xgenerous contributions to the wide range of software distributed
Xthrough that system in reliance on consistent application of that
Xsystem; it is up to the author/donor to decide if he or she is willing
Xto distribute software through any other system and a licensee cannot
Ximpose that choice.
X
XThis section is intended to make thoroughly clear what is believed to
Xbe a consequence of the rest of this License.
X
X  12. If the distribution and/or use of the Library is restricted in
Xcertain countries either by patents or by copyrighted interfaces, the
Xoriginal copyright holder who places the Library under this License may add
Xan explicit geographical distribution limitation excluding those countries,
Xso that distribution is permitted only in or among countries not thus
Xexcluded.  In such case, this License incorporates the limitation as if
Xwritten in the body of this License.
X
X  13. The Free Software Foundation may publish revised and/or new
Xversions of the Library General Public License from time to time.
XSuch new versions will be similar in spirit to the present version,
Xbut may differ in detail to address new problems or concerns.
X
XEach version is given a distinguishing version number.  If the Library
Xspecifies a version number of this License which applies to it and
X"any later version", you have the option of following the terms and
Xconditions either of that version or of any later version published by
Xthe Free Software Foundation.  If the Library does not specify a
Xlicense version number, you may choose any version ever published by
Xthe Free Software Foundation.
X
X  14. If you wish to incorporate parts of the Library into other free
Xprograms whose distribution conditions are incompatible with these,
Xwrite to the author to ask for permission.  For software which is
Xcopyrighted by the Free Software Foundation, write to the Free
XSoftware Foundation; we sometimes make exceptions for this.  Our
Xdecision will be guided by the two goals of preserving the free status
Xof all derivatives of our free software and of promoting the sharing
Xand reuse of software generally.
X
X			    NO WARRANTY
X
X  15. BECAUSE THE LIBRARY IS LICENSED FREE OF CHARGE, THERE IS NO
XWARRANTY FOR THE LIBRARY, TO THE EXTENT PERMITTED BY APPLICABLE LAW.
XEXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR
XOTHER PARTIES PROVIDE THE LIBRARY "AS IS" WITHOUT WARRANTY OF ANY
XKIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE
XIMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
XPURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE
XLIBRARY IS WITH YOU.  SHOULD THE LIBRARY PROVE DEFECTIVE, YOU ASSUME
XTHE COST OF ALL NECESSARY SERVICING, REPAIR OR CORRECTION.
X
X  16. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN
XWRITING WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY
XAND/OR REDISTRIBUTE THE LIBRARY AS PERMITTED ABOVE, BE LIABLE TO YOU
XFOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR
XCONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE THE
XLIBRARY (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING
XRENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A
XFAILURE OF THE LIBRARY TO OPERATE WITH ANY OTHER SOFTWARE), EVEN IF
XSUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
XDAMAGES.
X
X		     END OF TERMS AND CONDITIONS
X
X     Appendix: How to Apply These Terms to Your New Libraries
X
X  If you develop a new library, and you want it to be of the greatest
Xpossible use to the public, we recommend making it free software that
Xeveryone can redistribute and change.  You can do so by permitting
Xredistribution under these terms (or, alternatively, under the terms of the
Xordinary General Public License).
X
X  To apply these terms, attach the following notices to the library.  It is
Xsafest to attach them to the start of each source file to most effectively
Xconvey the exclusion of warranty; and each file should have at least the
X"copyright" line and a pointer to where the full notice is found.
X
X    <one line to give the library's name and a brief idea of what it does.>
X    Copyright (C) <year>  <name of author>
X
X    This library is free software; you can redistribute it and/or
X    modify it under the terms of the GNU Library General Public
X    License as published by the Free Software Foundation; either
X    version 2 of the License, or (at your option) any later version.
X
X    This library is distributed in the hope that it will be useful,
X    but WITHOUT ANY WARRANTY; without even the implied warranty of
X    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
X    Library General Public License for more details.
X
X    You should have received a copy of the GNU Library General Public
X    License along with this library; if not, write to the Free
X    Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X
XAlso add information on how to contact you by electronic and paper mail.
X
XYou should also get your employer (if you work as a programmer) or your
Xschool, if any, to sign a "copyright disclaimer" for the library, if
Xnecessary.  Here is a sample; alter the names:
X
X  Yoyodyne, Inc., hereby disclaims all copyright interest in the
X  library `Frob' (a library for tweaking knobs) written by James Random Hacker.
X
X  <signature of Ty Coon>, 1 April 1990
X  Ty Coon, President of Vice
X
XThat's all there is to it!
END_OF_FILE
  if test 25510 -ne `wc -c <'COPYING'`; then
    echo shar: \"'COPYING'\" unpacked with wrong size!
  fi
  # end of 'COPYING'
fi
if test -f 'FILES' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'FILES'\"
else
  echo shar: Extracting \"'FILES'\" \(2333 characters\)
  sed "s/^X//" >'FILES' <<'END_OF_FILE'
X/* General stuff */
XCHANGES		- Changes since the last posting to comp.sources.misc.
XARTISTIC	- Copying info.
XCOPYING		- Copying info.
XMODES.DES	- A description of the features of the different modes of DES.
XFILES		- This file.
XINSTALL		- How to make things compile.
XImakefile	- For use with kerberos.
XREADME		- What this package is.
XVERSION		- Which version this is.
XKERBEROS	- Kerberos version 4 notes.
Xmakefile	- The make file.
Xtimes		- Some outputs from 'speed' on my local machines.
Xvms.com		- For use when compiling under VMS
X
X/* My sunOS des(1) replacement */
Xdes.c		- des(1) source code.
Xdes.man		- des(1) manual.
X
X/* Testing and timing programs. */
Xdestest.c	- Source for libdes.a test program.
Xspeed.c		- Source for libdes.a timing program.
Xrpw.c		- Source for libdes.a testing password reading routines.
X
X/* libdes.a source code */
Xdes_crypt.man	- libdes.a manual page.
Xdes.h		- Public libdes.a header file.
Xecb_enc.c	- des_ecb_encrypt() source, this contains the basic DES code.
X3ecb_enc.c	- des_3ecb_encrypt() source.
Xcbc_ckm.c	- des_cbc_cksum() source.
Xcbc_enc.c	- des_cbc_encrypt() source.
X3cbc_enc.c	- des_3cbc_encrypt() source.
Xcfb_enc.c	- des_cfb_encrypt() source.
Xofb_enc.c	- des_cfb_encrypt() source.
Xenc_read.c	- des_enc_read() source.
Xenc_writ.c	- des_enc_write() source.
Xpcbc_enc.c	- des_pcbc_encrypt() source.
Xqud_cksm.c	- quad_cksum() source.
Xrand_key.c	- des_random_key() source.
Xread_pwd.c	- Source for des_read_password() plus related functions.
Xset_key.c	- Source for des_set_key().
Xstr2key.c	- Covert a string of any length into a key.
Xfcrypt.c	- A small, fast version of crypt(3).
Xdes_locl.h	- Internal libdes.a header file.
Xpodd.h		- Odd parity tables - used in des_set_key().
Xsk.h		- Lookup tables used in des_set_key().
Xspr.h		- What is left of the S tables - used in ecb_encrypt().
X
X/* The perl scripts - you can ignore these files they are only
X * included for the curious */
Xdes.pl		- des in perl anyone? des_set_key and des_ecb_encrypt
X		  both done in a perl library.
Xtestdes.pl	- Testing program for des.pl
XdoIP		- Perl script used to develop IP xor/shift code.
XdoPC1		- Perl script used to develop PC1 xor/shift code.
XdoPC2		- Generates sk.h.
XPC1		- Output of doPC1 should be the same as output from PC1.
XPC2		- used in development of doPC2.
Xshifts.pl	- Perl library used by my perl scripts.
X
END_OF_FILE
  if test 2333 -ne `wc -c <'FILES'`; then
    echo shar: \"'FILES'\" unpacked with wrong size!
  fi
  # end of 'FILES'
fi
if test -f 'INSTALL' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'INSTALL'\"
else
  echo shar: Extracting \"'INSTALL'\" \(2169 characters\)
  sed "s/^X//" >'INSTALL' <<'END_OF_FILE'
XCheck the CC and CFLAGS lines in the makefile
X
XIf your C library does not support the times(3) function, change the
X#define TIMES to
X#undef TIMES in speed.c
XIf it does, check the HZ value for the times(3) function.
XIf your system does not define CLK_TCK it will be assumed to
Xbe 60.
X
XIf possible use gcc v 2.2.2
XTurn on the maximum optimising
X
Xtype 'make'
X
Xrun './destest' to check things are ok.
Xrun './rpw' to check the tty code for reading passwords works.
Xrun './speed' to see how fast those optimisations make the library run :-)
X
XA make install will by default install
Xlibdes.a      in /usr/local/lib/libdes.a
Xdes           in /usr/local/bin/des
Xdes_crypt.man in /usr/local/man/man3/des_crypt.3
Xdes.man       in /usr/local/man/man1/des.1
Xdes.h         in /usr/include/des.h
X
Xdes(1) should be compatible with sunOS's but I have been unable to
Xtest it.
X
XThese routines should compile on MSDOS, most 32bit and 64bit version
Xof Unix (BSD and SYSV) and VMS, without modification.
XThe only problems should be #include files that are in the wrong places.
X
XThese routines can be compiled under MSDOS.
XI have successfully encrypted files using des(1) under MSDOS and then
Xdecrypted the files on a SparcStation.
XI have been able to compile and test the routines with
XMicrosoft C v 5.1 and Turbo C v 2.0.
XThe code in this library is in no way optimised for the 16bit
Xoperation of MSDOS.  Microsoft C generates code that is 40% slower
Xthan Turbo C's code.  I believe this is due to problems it has with
Xcode generation with the 32bit shift operation in the IP and FP
Xsections.  I have added some 16bit optimization in ecb_encrypt.c
Xand this generated a %70 speedup under Turbo C.  Such are the
Xlimitations of DOS compilers :-(.
X
XFor Turbo C v 2.0, make sure to define MSDOS, in the relevant menu.
X
XThere is an alternative version of the D_ENCRYPT macro that can be
Xenabled with the -DALT_ECB option in the makefile.  This alternative
Xmacro can make a +-%20 speed difference to the DES encryption speed,
Xdepending on the compiler/CPU combinations.
XIt has its greatest effect on Sparc machines when using the sun compiler.
XIf in doubt, try enable/disable it and running speed.
END_OF_FILE
  if test 2169 -ne `wc -c <'INSTALL'`; then
    echo shar: \"'INSTALL'\" unpacked with wrong size!
  fi
  # end of 'INSTALL'
fi
if test -f 'Imakefile' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Imakefile'\"
else
  echo shar: Extracting \"'Imakefile'\" \(1013 characters\)
  sed "s/^X//" >'Imakefile' <<'END_OF_FILE'
X# This Imakefile has not been tested for a while but it should still
X# work when placed in the correct directory in the kerberos v 4 distribution
X
XSRCS=   cbc_cksm.c cbc_enc.c ecb_enc.c pcbc_enc.c \
X        qud_cksm.c rand_key.c read_pwd.c set_key.c str2key.c \
X        enc_read.c enc_writ.c fcrypt.c cfb_enc.c \
X	3ecb_enc.c ofb_enc.c
X
XOBJS=   cbc_cksm.o cbc_enc.o ecb_enc.o pcbc_enc.o \
X	qud_cksm.o rand_key.o read_pwd.o set_key.o str2key.o \
X	enc_read.o enc_writ.o fcrypt.o cfb_enc.o \
X	3ecb_enc.o ofb_enc.o
X
XGENERAL=COPYING FILES INSTALL Imakefile README VERSION makefile times \
X	vms.com KERBEROS
XDES=    des.c des.man
XTESTING=destest.c speed.c rpw.c
XLIBDES= des_crypt.man des.h des_locl.h podd.h sk.h spr.h
X
XPERL=   des.pl testdes.pl doIP doPC1 doPC2 PC1 PC2 shifts.pl
X
XCODE=    $(GENERAL) $(DES) $(TESTING) $(SRCS) $(LIBDES) $(PERL)
X
XSRCDIR=$(SRCTOP)/lib/des
X
XDBG= -O
XINCLUDE= -I$(SRCDIR)
XCC= cc
X
Xlibrary_obj_rule()
X
Xinstall_library_target(des,$(OBJS),$(SRCS),)
X
Xtest(destest,libdes.a,)
Xtest(rpw,libdes.a,)
END_OF_FILE
  if test 1013 -ne `wc -c <'Imakefile'`; then
    echo shar: \"'Imakefile'\" unpacked with wrong size!
  fi
  # end of 'Imakefile'
fi
if test -f 'README' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'README'\"
else
  echo shar: Extracting \"'README'\" \(2419 characters\)
  sed "s/^X//" >'README' <<'END_OF_FILE'
X
X			libdes, Version 3.00 93/10/07
X
X		Copyright (c) 1993, Eric Young
X			  All rights reserved.
X
X    This program is free software; you can redistribute it and/or modify
X    it under the terms of either:
X    
X	a) the GNU General Public License as published by the Free
X	Software Foundation; either version 1, or (at your option) any
X	later version, or
X
X	b) the "Artistic License" which comes with this Kit.
X
X    This program is distributed in the hope that it will be useful,
X    but WITHOUT ANY WARRANTY; without even the implied warranty of
X    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See either
X    the GNU General Public License or the Artistic License for more details.
X
X    You should have received a copy of the Artistic License with this
X    Kit, in the file named "Artistic".  If not, I'll be glad to provide one.
X
X    You should also have received a copy of the GNU General Public License
X    along with this program; if not, write to the Free Software
X    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X---
XThis kit builds a DES encryption library and a DES encryption program.
XIt suports ecb, cbc, ofb, cfb, triple ecb, triple cbc and MIT's pcbc
Xencryption modes and also has a fast implementation of crypt(3).
XIt contains support routines to read keys from a terminal,
Xgenerate a random key, generate a key from an arbitary length string,
Xread/write encrypted data from/to a file descriptor.
X
XThe implementation was written so as to conform with the manual entry
Xfor the des_crypt(3) library routines from MIT's project Athena.
X
Xdestest should be run after compilation to test the des routines.
Xrpw should be run after compilation to test the read password routines.
XThe des program is a replacement for the sun des command.  I believe it
Xconforms to the sun version.
X
XThe Imakefile is setup for use in the kerberos distribution.
X
XThese routines are best compiled with gcc or any other good
Xoptimising compiler.
XJust turn you optimiser up to the highest settings and run destest
Xafter the build to make sure everything works.
X
XI believe these routines are close to the fastest and most portable DES
Xroutines that use small lookup tables (4.5k) that are publicly available.
XThe fcrypt routine is faster than ufc's fcrypt (when compiling with
Xgcc2 -O2) on the sparc 2 (1410 vs 1270) but is not so good on other machines
X(on a sun3/260 168 vs 336).
X
XEric Young (eay@psych.psy.uq.oz.au)
END_OF_FILE
  if test 2419 -ne `wc -c <'README'`; then
    echo shar: \"'README'\" unpacked with wrong size!
  fi
  # end of 'README'
fi
if test -f 'VERSION' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'VERSION'\"
else
  echo shar: Extracting \"'VERSION'\" \(6824 characters\)
  sed "s/^X//" >'VERSION' <<'END_OF_FILE'
XRelease apon comp.sources.misc
XVersion 3.01 08/10/93
X	Added des_3cbc_encrypt()
X
XVersion 3.00 07/10/93
X	Fixed up documentation.
X	quad_cksum definitly compatable with MIT's now.
X
XVersion 2.30 24/08/93
X	Tripple DES now defaults to tripple cbc but can do tripple ecb
X	 with the -b flag.
X	Fixed some MSDOS uuen/uudecoding problems, thanks to
X	Added prototypes.
X	
XVersion 2.22 29/06/93
X	Fixed a bug in des_is_weak_key() which stopped it working :-(
X	thanks to engineering@MorningStar.Com.
X
XVersion 2.21 03/06/93
X	des(1) with no arguments gives quite a bit of help.
X	Added -c (generate ckecksum) flag to des(1).
X	Added -3 (tripple DES) flag to des(1).
X	Added cfb and ofb routines to the library.
X
XVersion 2.20 11/03/93
X	Added -u (uuencode) flag to des(1).
X	I have been playing with byte order in quad_cksum to make it
X	 compatible with MIT's version.  All I can say is aviod this
X	 function if possible since MIT's output is endian dependent.
X
XVersion 2.12 14/10/92
X	Added MSDOS specific macro in ecb_encrypt which gives a %70
X	 speed up when the code is compiled with turbo C.
X
XVersion 2.11 12/10/92
X	Speedup in set_key (recoding of PC-1)
X	 I now do it in 47 simple operations, down from 60.
X	 Thanks to John Fletcher (john_fletcher@lccmail.ocf.llnl.gov)
X	 for motivating me to look for a faster system :-)
X	 The speedup is probably less that 1% but it is still 13
X	 instructions less :-).
X
XVersion 2.10 06/10/92
X	The code now works on the 64bit ETA10 and CRAY without modifications or
X	 #defines.  I believe the code should work on any machine that
X	 defines long, int or short to be 8 bytes long.
X	Thanks to Shabbir J. Safdar (shabby@mentor.cc.purdue.edu)
X	 for helping me fix the code to run on 64bit machines (he had
X	 access to an ETA10).
X	Thanks also to John Fletcher <john_fletcher@lccmail.ocf.llnl.gov>
X	 for testing the routines on a CRAY.
X	read_password.c has been renamed to read_passwd.c
X	string_to_key.c has been renamed to string2key.c
X
XVersion 2.00 14/09/92
X	Made mods so that the library should work on 64bit CPU's.
X	Removed all my uchar and ulong defs.  To many different
X	 versions of unix define them in their header files in too many
X	 different combinations :-)
X	IRIX - Sillicon Graphics mods (mostly in read_password.c).
X	 Thanks to Andrew Daviel (advax@erich.triumf.ca)
X
XVersion 1.99 26/08/92
X	Fixed a bug or 2 in enc_read.c
X	Fixed a bug in enc_write.c
X	Fixed a pseudo bug in fcrypt.c (very obscure).
X
XVersion 1.98 31/07/92
X	Support for the ETA10.  This is a strange machine that defines
X	longs and ints as 8 bytes and shorts as 4 bytes.
X	Since I do evil things with long * that assume that they are 4
X	bytes.  Look in the Makefile for the option to compile for
X	this machine.  quad_cksum appears to have problems but I
X	will don't have the time to fix it right now, and this is not
X	a function that uses DES and so will not effect the main uses
X	of the library.
X
XVersion 1.97 20/05/92 eay
X	Fixed the Imakefile and made some changes to des.h to fix some
X	problems when building this package with Kerberos v 4.
X
XVersion 1.96 18/05/92 eay
X	Fixed a small bug in string_to_key() where problems could
X	occur if des_check_key was set to true and the string
X	generated a weak key.
X
XPatch2 posted to comp.sources.misc
XVersion 1.95 13/05/92 eay
X	Added an alternative version of the D_ENCRYPT macro in
X	ecb_encrypt and fcrypt.  Depending on the compiler, one version or the
X	other will be faster.  This was inspired by 
X	Dana How <how@isl.stanford.edu>, and her pointers about doing the
X	*(ulong *)((uchar *)ptr+(value&0xfc))
X	vs
X	ptr[value&0x3f]
X	to stop the C compiler doing a <<2 to convert the long array index.
X
XVersion 1.94 05/05/92 eay
X	Fixed an incompatibility between my string_to_key and the MIT
X	 version.  When the key is longer than 8 chars, I was wrapping
X	 with a different method.  To use the old version, define
X	 OLD_STR_TO_KEY in the makefile.  Thanks to
X	 viktor@newsu.shearson.com (Viktor Dukhovni).
X
XVersion 1.93 28/04/92 eay
X	Fixed the VMS mods so that echo is now turned off in
X	 read_password.  Thanks again to brennan@coco.cchs.su.oz.AU.
X	MSDOS support added.  The routines can be compiled with
X	 Turbo C (v2.0) and MSC (v5.1).  Make sure MSDOS is defined.
X
XPatch1 posted to comp.sources.misc
XVersion 1.92 13/04/92 eay
X	Changed D_ENCRYPT so that the rotation of R occurs outside of
X	 the loop.  This required rotating all the longs in sp.h (now
X	 called spr.h). Thanks to Richard Outerbridge <71755.204@CompuServe.COM>
X	speed.c has been changed so it will work without SIGALRM.  If
X	 times(3) is not present it will try to use ftime() instead.
X
XVersion 1.91 08/04/92 eay
X	Added -E/-D options to des(1) so it can use string_to_key.
X	Added SVR4 mods suggested by witr@rwwa.COM
X	Added VMS mods suggested by brennan@coco.cchs.su.oz.AU.  If
X	anyone knows how to turn of tty echo in VMS please tell me or
X	implement it yourself :-).
X	Changed FILE *IN/*OUT to *DES_IN/*DES_OUT since it appears VMS
X	does not like IN/OUT being used.
X
XLibdes posted to comp.sources.misc
XVersion 1.9 24/03/92 eay
X	Now contains a fast small crypt replacement.
X	Added des(1) command.
X	Added des_rw_mode so people can use cbc encryption with
X	enc_read and enc_write.
X
XVersion 1.8 15/10/91 eay
X	Bug in cbc_cksum.
X	Many thanks to Keith Reynolds (keithr@sco.COM) for pointing this
X	one out.
X
XVersion 1.7 24/09/91 eay
X	Fixed set_key :-)
X	set_key is 4 times faster and takes less space.
X	There are a few minor changes that could be made.
X
XVersion 1.6 19/09/1991 eay
X	Finally go IP and FP finished.
X	Now I need to fix set_key.
X	This version is quite a bit faster that 1.51
X
XVersion 1.52 15/06/1991 eay
X	20% speedup in ecb_encrypt by changing the E bit selection
X	to use 2 32bit words.  This also required modification of the
X	sp table.  There is still a way to speedup the IP and IP-1
X	(hints from outer@sq.com) still working on this one :-(.
X
XVersion 1.51 07/06/1991 eay
X	Faster des_encrypt by loop unrolling
X	Fixed bug in quad_cksum.c (thanks to hughes@logos.ucs.indiana.edu)
X
XVersion 1.50 28/05/1991 eay
X	Optimized the code a bit more for the sparc.  I have improved the
X	speed of the inner des_encrypt by speeding up the initial and
X	final permutations.
X
XVersion 1.40 23/10/1990 eay
X	Fixed des_random_key, it did not produce a random key :-(
X
XVersion 1.30  2/10/1990 eay
X	Have made des_quad_cksum the same as MIT's, the full package
X	should be compatible with MIT's
X	Have tested on a DECstation 3100
X	Still need to fix des_set_key (make it faster).
X	Does des_cbc_encrypts at 70.5k/sec on a 3100.
X
XVersion 1.20 18/09/1990 eay
X	Fixed byte order dependencies.
X	Fixed (I hope) all the word alignment problems.
X	Speedup in des_ecb_encrypt.
X
XVersion 1.10 11/09/1990 eay
X	Added des_enc_read and des_enc_write.
X	Still need to fix des_quad_cksum.
X	Still need to document des_enc_read and des_enc_write.
X
XVersion 1.00 27/08/1990 eay
END_OF_FILE
  if test 6824 -ne `wc -c <'VERSION'`; then
    echo shar: \"'VERSION'\" unpacked with wrong size!
  fi
  # end of 'VERSION'
fi
if test -f 'makefile' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'makefile'\"
else
  echo shar: Extracting \"'makefile'\" \(3215 characters\)
  sed "s/^X//" >'makefile' <<'END_OF_FILE'
X# Turn this option on if using a SGI Iris running IRIX.
X# IRIX does not appear to define sgttyb anywhere :-(
X#OPTS0= -D_IRIX 
X
X# Version 1.94 has changed the strings_to_key function so that it is
X# now compatible with MITs when the string is longer than 8 characters.
X# If you wish to keep the old version, uncomment the following line.
X# This will affect the -E/-D options on des(1).
X#OPTS1= -DOLD_STR_TO_KEY
X
X# This #define specifies the use of an alternative D_ENCRYPT macro in
X# ecb_encrypt.  The choice of macro can make a %20 difference in the
X# speed.  Unfortunatly the choise of the best macro appears to be very
X# dependant on the compiler and the machine in question.
X# For the following combinations use the ALT_ECB option.
X# Sparc 2 (cc -O4), sun 3/260 (cc -O4)
X# For the following combinations do not use the ALT_ECB option.
X# Sparc 2 (gcc2 -O2), sun 3/260 (cc -O2), mvax2 (cc -O), MSDOS (Turbo Cv2)
X# For other machines, experiment with changing the option and run
X# ./speed to see which is faster.
X# DO NOT TURN THIS OPTION ON WHEN COMPILING THIS CODE ON A 64 BIT MACHINE
X#OPTS2= -DALT_ECB
X
XOPTS= $(OPTS0) $(OPTS1) $(OPTS2)
X#CC=cc
X#CFLAGS= -g $(OPTS)
XCC=gcc
XCFLAGS= -O2 $(OPTS)
X
XLIBDIR=/usr/local/lib
XBINDIR=/usr/local/bin
XINCDIR=/usr/include
XMANDIR=/usr/local/man
XMAN1=1
XMAN3=3
XSHELL=/bin/sh
X
XOBJS=	cbc_cksm.o cbc_enc.o ecb_enc.o pcbc_enc.o \
X	qud_cksm.o rand_key.o read_pwd.o set_key.o str2key.o \
X	enc_read.o enc_writ.o fcrypt.o cfb_enc.o \
X	3ecb_enc.o ofb_enc.o 3cbc_enc.o
X
XGENERAL=ARTISTIC COPYING FILES INSTALL Imakefile README VERSION makefile times \
X	vms.com KERBEROS MODES.DES CHANGES
XDES=	des.c des.man
XTESTING=destest.c speed.c rpw.c
XLIBDES=	des_crypt.man des.h cbc_cksm.c cbc_enc.c ecb_enc.c \
X	enc_read.c enc_writ.c pcbc_enc.c qud_cksm.c rand_key.c \
X	read_pwd.c set_key.c str2key.c fcrypt.c des_locl.h \
X	podd.h sk.h spr.h cfb_enc.c 3ecb_enc.c \
X	ofb_enc.c 3cbc_enc.c
X
XPERL=	des.pl testdes.pl doIP doPC1 doPC2 PC1 PC2 shifts.pl
X
XALL=	$(GENERAL) $(DES) $(TESTING) $(LIBDES) $(PERL)
X
XLIB=	libdes.a
X
Xall: $(LIB) destest rpw des speed
X
X$(LIB):	$(OBJS)
X	/bin/rm -f $(LIB)
X	ar cr $(LIB) $(OBJS)
X	-if test -s /bin/ranlib; then /bin/ranlib $(LIB); \
X	else if test -s /usr/bin/ranlib; then /usr/bin/ranlib $(LIB); \
X	else exit 0; fi; fi
X
Xdestest: destest.o libdes.a
X	$(CC) $(CFLAGS) -o destest destest.o libdes.a
X
Xrpw: rpw.o libdes.a
X	$(CC) $(CFLAGS) -o rpw rpw.o libdes.a
X
Xspeed: speed.o libdes.a
X	$(CC) $(CFLAGS) -o speed speed.o libdes.a
X
Xdes: des.o libdes.a
X	$(CC) $(CFLAGS) -o des des.o libdes.a
X
Xtar:
X	tar cf libdes.tar $(ALL)
X
Xshar:
X	shar $(ALL) >libdes.shar
X
Xclean:
X	/bin/rm -f *.o rpw destest des speed $(LIB)
X
Xinstall: $(LIB) des
X	cp $(LIB) $(LIBDIR)/$(LIB)
X	-if test -s /bin/ranlib; then /bin/ranlib $(LIBDIR)/$(LIB); \
X	else if test -s /usr/bin/ranlib; then /usr/bin/ranlib $(LIBDIR)/$(LIB); \
X	fi; fi
X	chmod 644 $(LIBDIR)/$(LIB)
X	cp des $(BINDIR)/des
X	chmod 711 $(BINDIR)/des
X	cp des_crypt.man $(MANDIR)/man$(MAN3)/des_crypt.$(MAN3)
X	chmod 644 $(MANDIR)/man$(MAN3)/des_crypt.$(MAN3)
X	cp des.man $(MANDIR)/man$(MAN1)/des.$(MAN1)
X	chmod 644 $(MANDIR)/man$(MAN1)/des.$(MAN1)
X	cp des.h $(INCDIR)/des.h
X	chmod 644 $(INCDIR)/des.h
X# DO NOT DELETE THIS LINE -- make depend depends on it.
END_OF_FILE
  if test 3215 -ne `wc -c <'makefile'`; then
    echo shar: \"'makefile'\" unpacked with wrong size!
  fi
  # end of 'makefile'
fi
if test -f 'times' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'times'\"
else
  echo shar: Extracting \"'times'\" \(2688 characters\)
  sed "s/^X//" >'times' <<'END_OF_FILE'
XDEC Alpha DEC 4000/610 AXP OSF/1 v 1.3 - gcc v 2.3.3
Xset_key       per sec =    101840.19 (  9.8uS)
XDES ecb bytes per sec =   1223712.35 (  6.5uS)
XDES cbc bytes per sec =   1230542.98 (  6.5uS)
Xcrypt         per sec =      6428.75 (155.6uS)
X
XDEC Alpha DEC 4000/610 APX OSF/1 v 1.3 - cc -O2 - OSF/1 AXP
Xset_key       per sec =    114198.91 (  8.8uS)
XDES ecb bytes per sec =   1022710.93 (  7.8uS)
XDES cbc bytes per sec =   1008821.93 (  7.9uS)
Xcrypt         per sec =      5454.13 (183.3uS)
X
XDEC Alpha - DEC 3000/500 AXP OSF/1 - cc -O2 - 02/12/92
Xset_key       per sec =     83587.04 ( 12.0uS)
XDES ecb bytes per sec =    822620.82 (  9.7uS)
XDES cbc bytes per sec =    832929.60 (  9.6uS)
Xcrypt         per sec =      4807.62 (208.0uS)
X
Xsun sparc 10/30 - gcc -O2
Xset_key       per sec =     42005.24 ( 23.8uS)
XDES ecb bytes per sec =    555949.47 ( 14.4uS)
XDES cbc bytes per sec =    549440.28 ( 14.6uS)
Xcrypt         per sec =      2580.25 (387.6uS)
X
XPA-RISC 1.1 HP 710
Xset_key       per sec =     38916.86
XDES ecb bytes per sec =    505971.82
XDES cbc bytes per sec =    515381.13
Xcrypt         per sec =      2438.24
X
Xsun sparc 10/30 - cc -O4
Xset_key       per sec =     38379.86 ( 26.1uS)
XDES ecb bytes per sec =    460051.34 ( 17.4uS)
XDES cbc bytes per sec =    464970.54 ( 17.2uS)
Xcrypt         per sec =      2092.64 (477.9uS)
X
Xsun sparc 2 - gcc2 -O2
Xset_key       per sec =     21559.10
XDES ecb bytes per sec =    305566.92
XDES cbc bytes per sec =    303497.50
Xcrypt         per sec =      1410.48
X
XRS/6000 model 320
Xset_key       per sec =     14371.93
XDES ecb bytes per sec =    222231.26
XDES cbc bytes per sec =    223926.79
Xcrypt         per sec =       981.20
X
X68030 HP400
Xset_key       per sec =      5251.28
XDES ecb bytes per sec =     56186.56
XDES cbc bytes per sec =     58681.53
Xcrypt         per sec =       276.15
X
X80486sx/33MHz MSDOS Turbo C v 2.0
Xset_key       per sec =      1883.22 (531.0uS)
XDES ecb bytes per sec =     63393.31 (126.2uS)
XDES cbc bytes per sec =     63416.83 (126.1uS)
Xcrypt         per sec =       158.71 (6300.6uS)
X
X80486sx/33MHz MSDOS djgpp gcc 1.39 (32bit compiler)
Xset_key       per sec =     12603.08 (79.3)
XDES ecb bytes per sec =    158875.15 (50.4)
XDES cbc bytes per sec =    159893.85 (50.0)
Xcrypt         per sec =       780.24 (1281.7)
X
XVersion 1.99 26/08/92
X8MHz 68000 Atari-ST gcc 2.1 -O2 MiNT 0.94
Xset_key       per sec =       325.68 (3070.5uS)
XDES ecb bytes per sec =      4173.67 (1916.8uS)
XDES cbc bytes per sec =      4249.89 (1882.4uS)
Xcrypt         per sec =        20.19 (49521.6uS)
X
X8088/4.77mh MSDOS Turbo C v 2.0
Xset_key       per sec =        35.09
XDES ecb bytes per sec =       563.63
Xcrypt         per sec =         2.69
END_OF_FILE
  if test 2688 -ne `wc -c <'times'`; then
    echo shar: \"'times'\" unpacked with wrong size!
  fi
  # end of 'times'
fi
if test -f 'vms.com' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'vms.com'\"
else
  echo shar: Extracting \"'vms.com'\" \(2311 characters\)
  sed "s/^X//" >'vms.com' <<'END_OF_FILE'
X$! --- VMS.com ---
X$!
X$ GoSub defines
X$ GoSub linker_options
X$ If (P1 .nes. "")
X$ Then 
X$   GoSub 'P1'
X$ Else
X$   GoSub lib
X$   GoSub destest
X$   GoSub rpw
X$   GoSub speed
X$   GoSub des
X$ EndIF
X$!
X$ Exit
X$!
X$!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
X$!
X$DEFINES:
X$ OPT_FILE := "VAX_LINKER_OPTIONS.OPT"
X$!
X$ CC_OPTS := "/NODebug/OPTimize/NOWarn"
X$!
X$ LINK_OPTS := "/NODebug/NOTraceback/Contiguous"
X$!
X$ OBJS  = "cbc_cksm.obj,cbc_enc.obj,ecb_enc.obj,pcbc_enc.obj," + -
X          "qud_cksm.obj,rand_key.obj,read_pwd.obj,set_key.obj,"      + -
X          "str2key.obj,enc_read.obj,enc_writ.obj,fcrypt.obj,"           + -
X	  "cfb_enc.obj,3ecb_enc.obj,ofb_enc.obj"
X	   
X	   
X$!
X$ LIBDES = "cbc_cksm.c,cbc_enc.c,ecb_enc.c,enc_read.c,"           + -
X           "enc_writ.c,pcbc_enc.c,qud_cksm.c,rand_key.c,"         + -
X           "read_pwd.c,set_key.c,str2key.c,fcrypt.c,"                + -
X	   "cfb_enc.c,3ecb_enc.c,ofb_enc.c"
X$ Return
X$!
X$!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
X$!
X$LINKER_OPTIONS:
X$ If (f$search(OPT_FILE) .eqs. "")
X$ Then
X$   Create 'OPT_FILE'
X$DECK
X! Default system options file to link against the sharable C runtime library
X!
XSys$Share:VAXcRTL.exe/Share
X$EOD
X$ EndIF
X$ Return
X$!
X$!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
X$!
X$LIB:
X$ CC 'CC_OPTS' 'LIBDES'
X$ If (f$search("LIBDES.OLB") .nes. "")
X$ Then Library /Object /Replace libdes 'OBJS'
X$ Else Library /Create /Object  libdes 'OBJS'
X$ EndIF
X$ Return
X$!
X$!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
X$!
X$DESTEST:
X$ CC 'CC_OPTS' destest
X$ Link 'link_opts' /Exec=destest destest.obj,libdes/LIBRARY,'opt_file'/Option
X$ Return
X$!
X$!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
X$!
X$RPW:
X$ CC 'CC_OPTS' rpw
X$ Link 'link_opts' /Exec=rpw  rpw.obj,libdes/LIBRARY,'opt_file'/Option
X$ Return
X$!
X$!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
X$!
X$SPEED:
X$ CC 'CC_OPTS' speed
X$ Link 'link_opts' /Exec=speed speed.obj,libdes/LIBRARY,'opt_file'/Option
X$ Return
X$!
X$!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
X$!
X$DES:
X$ CC 'CC_OPTS' des
X$ Link 'link_opts' /Exec=des des.obj,libdes/LIBRARY,'opt_file'/Option
X$ Return
END_OF_FILE
  if test 2311 -ne `wc -c <'vms.com'`; then
    echo shar: \"'vms.com'\" unpacked with wrong size!
  fi
  # end of 'vms.com'
fi
if test -f 'KERBEROS' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'KERBEROS'\"
else
  echo shar: Extracting \"'KERBEROS'\" \(1398 characters\)
  sed "s/^X//" >'KERBEROS' <<'END_OF_FILE'
XTo use this library with Bones (kerberos without DES):
X1) Get my modified Bones - eBones.  It can be found on
X   gondwana.ecr.mu.oz.au (128.250.1.63) /pub/athena/eBones-p9.tar.Z
X   and
X   nic.funet.fi (128.214.6.100) /pub/unix/security/Kerberos/eBones-p9.tar.Z
X
X2) Unpack this library in src/lib/des, makeing sure it is version
X   3.00 or greater (libdes.tar.93-10-07.Z).  This versions differences
X   from the version in comp.sources.misc volume 29 patchlevel2.
X   The primarily difference is that it should compile under kerberos :-).
X   It can be found at.
X   ftp.psy.uq.oz.au (130.102.32.1) /pub/DES/libdes.tar.93-10-07.Z
X
XNow do a normal kerberos build and things should work.
X
XOne problem I found when I was build on my local sun.
X---
XFor sunOS 4.1.1 apply the following patch to src/util/ss/make_commands.c
X
X*** make_commands.c.orig	Fri Jul  3 04:18:35 1987
X--- make_commands.c	Wed May 20 08:47:42 1992
X***************
X*** 98,104 ****
X       if (!rename(o_file, z_file)) {
X  	  if (!vfork()) {
X  	       chdir("/tmp");
X! 	       execl("/bin/ld", "ld", "-o", o_file+5, "-s", "-r", "-n",
X  		     z_file+5, 0);
X  	       perror("/bin/ld");
X  	       _exit(1);
X--- 98,104 ----
X       if (!rename(o_file, z_file)) {
X  	  if (!vfork()) {
X  	       chdir("/tmp");
X! 	       execl("/bin/ld", "ld", "-o", o_file+5, "-s", "-r",
X  		     z_file+5, 0);
X  	       perror("/bin/ld");
X  	       _exit(1);
END_OF_FILE
  if test 1398 -ne `wc -c <'KERBEROS'`; then
    echo shar: \"'KERBEROS'\" unpacked with wrong size!
  fi
  # end of 'KERBEROS'
fi
if test -f 'MODES.DES' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'MODES.DES'\"
else
  echo shar: Extracting \"'MODES.DES'\" \(4262 characters\)
  sed "s/^X//" >'MODES.DES' <<'END_OF_FILE'
XModes of DES
XQuite a bit of the following information has been taken from
X	AS 2805.5.2
X	Australian Standard
X	Electronic funds transfer - Requirements for interfaces,
X	Part 5.2: Modes of operation for an n-bit block cipher algorithm
X	Appendix A
X
XThere are several different modes in which DES can be used, they are
Xas follows.
X
XElectronic Codebook Mode (ECB) (des_ecb_encrypt())
X- 64 bits are enciphered at a time.
X- The order of the blocks can be rearranged without detection.
X- The same plaintext block always produces the same ciphertext block
X  (for the same key) making it vulnerable to a 'dictionary attack'.
X- An error will only affect one ciphertext block.
X
XCipher Block Chaining Mode (CBC) (des_cbc_encrypt())
X- a multiple of 64 bits are enciphered at a time.
X- The CBC mode produces the same ciphertext whenever the same
X  plaintext is encrypted using the same key and starting variable.
X- The chaining operation makes the ciphertext blocks dependent on the
X  current and all preceding plaintext blocks and therefore blocks can not
X  be rearranged.
X- The use of different starting variables prevents the same plaintext
X  enciphering to the same ciphertext.
X- An error will affect the current and the following ciphertext blocks.
X
XCipher Feedback Mode (CFB) (des_cfb_encrypt())
X- a number of bits (j) <= 64 are enciphered at a time.
X- The CFB mode produces the same ciphertext whenever the same
X  plaintext is encrypted using the same key and starting variable.
X- The chaining operation makes the ciphertext variables dependent on the
X  current and all preceding variables and therefore j-bit variables are
X  chained together and con not be rearranged.
X- The use of different starting variables prevents the same plaintext
X  enciphering to the same ciphertext.
X- The strength of the CFB mode depends on the size of k (maximal if
X  j == k).  In my implementation this is always the case.
X- Selection of a small value for j will require more cycles through
X  the encipherment algorithm per unit of plaintext and thus cause
X  greater processing overheads.
X- Only multiples of j bits can be enciphered.
X- An error will affect the current and the following ciphertext variables.
X
XOutput Feedback Mode (OFB) (des_ofb_encrypt())
X- a number of bits (j) <= 64 are enciphered at a time.
X- The OFB mode produces the same ciphertext whenever the same
X  plaintext enciphered using the same key and starting variable.  More
X  over, in the OFB mode the same key stream is produced when the same
X  key and start variable are used.  Consequently, for security reasons
X  a specific start variable should be used only once for a given key.
X- The absence of chaining makes the OFB more vulnerable to specific attacks.
X- The use of different start variables values prevents the same
X  plaintext enciphering to the same ciphertext, by producing different
X  key streams.
X- Selection of a small value for j will require more cycles through
X  the encipherment algorithm per unit of plaintext and thus cause
X  greater processing overheads.
X- Only multiples of j bits can be enciphered.
X- OFB mode of operation does not extend ciphertext errors in the
X  resultant plaintext output.  Every bit error in the ciphertext causes
X  only one bit to be in error in the deciphered plaintext.
X- OFB mode is not self-synchronising.  If the two operation of
X  encipherment and decipherment get out of synchronism, the system needs
X  to be re-initialised.
X- Each re-initialisation should use a value of the start variable
Xdifferent from the start variable values used before with the same
Xkey.  The reason for this is that an identical bit stream would be
Xproduced each time from the same parameters.  This would be
Xsusceptible to a ' known plaintext' attack.
X
XTriple ECB Mode (des_3ecb_encrypt())
X- Encrypt with key1, decrypt with key2 and encrypt with key1 again.
X- As for ECB encryption but increases the effective key length to 112 bits.
X- If both keys are the same it is equivalent to encrypting once with
X  just one key.
X
XTriple CBC Mode (des_3cbc_encrypt())
X- Encrypt with key1, decrypt with key2 and encrypt with key1 again.
X- As for CBC encryption but increases the effective key length to 112 bits.
X- If both keys are the same it is equivalent to encrypting once with
X  just one key.
END_OF_FILE
  if test 4262 -ne `wc -c <'MODES.DES'`; then
    echo shar: \"'MODES.DES'\" unpacked with wrong size!
  fi
  # end of 'MODES.DES'
fi
if test -f 'CHANGES' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'CHANGES'\"
else
  echo shar: Extracting \"'CHANGES'\" \(663 characters\)
  sed "s/^X//" >'CHANGES' <<'END_OF_FILE'
XThe main changes in this package since it was last posted to
Xcomp.sources.misc are
X
XThe main changes are
X- Major changes to the Copyright restrictions.
X- Lots and lots of features added to the des(1) command, including
X  - Triple DES, both triple ECB and triple CBC options.
X  - uuencodeing/uudecoding built in to des(1).
X  - generate checksums.
X  - hex keys.
X- Cleaned up the prototypes in des.h
X- Filenames are now mostly <= 8 characters long.
X- OFB, CFB, triple ECB and triple CBC modes of DES added to the library.
X- Compiles and runs of all 64bit machines I could test the code on
X  (Cray, ETA10, DEC Alpha).
X- It really does work with kerberos v 4 now :-).
END_OF_FILE
  if test 663 -ne `wc -c <'CHANGES'`; then
    echo shar: \"'CHANGES'\" unpacked with wrong size!
  fi
  # end of 'CHANGES'
fi
if test -f 'des.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'des.c'\"
else
  echo shar: Extracting \"'des.c'\" \(16298 characters\)
  sed "s/^X//" >'des.c' <<'END_OF_FILE'
X/* des.c */
X/* Copyright (C) 1993 Eric Young - see README for more details */
X#include <stdio.h>
X#ifdef VMS
X#include <types.h>
X#include <stat.h>
X#else
X#ifndef _IRIX
X#include <sys/types.h>
X#endif
X#include <sys/stat.h>
X#endif
X#include "des.h"
X
X#if defined(__STDC__) || defined(VMS) || defined(M_XENIX) || defined(MSDOS)
X#include <string.h>
X#define bcopy(f,t,n)	memcpy(t,f,(size_t)(n))
X#define bzero(s,n)	memset(s,0,(size_t)(n))
X#define bcmp(a,b,n)	memcmp(a, b,(size_t)(n))
X#define index(s,c)	strchr(s,c)
X#endif
X
X#ifdef PROTO
Xint usage(void);
Xint doencryption(void);
Xint uufwrite(char *data, int size, int num, FILE *fp);
Xint uufwriteEnd(FILE *fp);
Xint uufread(char *out,int size,int num,FILE *fp);
Xint uuencode(unsigned char *in,int num,unsigned char *out);
Xint uudecode(unsigned char *in,int num,unsigned char *out);
X#else
Xint usage();
Xint doencryption();
Xint uufwrite();
Xint uufwriteEnd();
Xint uufread();
Xint uuencode();
Xint uudecode();
X#endif
X
X#ifdef VMS
X#define EXIT(a) exit(a&0x10000000)
X#else
X#define EXIT(a) exit(a)
X#endif
X
X#define BUFSIZE (8*1024)
X#define VERIFY  1
X#define KEYSIZ	8
X#define KEYSIZB 1024 /* should hit tty line limit first :-) */
Xchar key[KEYSIZB+1];
Xint do_encrypt,longk=0;
Xchar *in=NULL,*out=NULL;
XFILE *DES_IN,*DES_OUT,*CKSUM_OUT;
Xchar uuname[200];
Xchar uubuf[50];
Xint uubufnum;
X#define INUUBUFN	(45*100)
X#define OUTUUBUF	(65*100)
Xchar b[OUTUUBUF];
Xchar bb[300];
Xdes_cblock cksum={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};
Xchar cksumname[200]="";
X
Xint cflag,eflag,dflag,kflag,bflag,fflag,sflag,uflag,flag3,hflag,error;
X
Xmain(argc,argv)
Xint argc;
Xchar *argv[];
X	{
X	int i;
X	struct stat ins,outs;
X	char *p;
X
X	cflag=eflag=dflag=kflag=hflag=bflag=fflag=sflag=uflag=flag3=0,error=0;
X	bzero(key,sizeof(key));
X
X	for (i=1; i<argc; i++)
X		{
X		p=argv[i];
X		if ((p[0] == '-') && (p[1] != '\0'))
X			{
X			p++;
X			while (*p)
X				{
X				switch (*(p++))
X					{
X				case '3':
X					flag3=1;
X				/*	bflag=0; */
X					longk=1;
X					break;
X				case 'c':
X					cflag=1;
X					strncpy(cksumname,p,200);
X					p+=strlen(cksumname);
X					break;
X				case 'C':
X					cflag=1;
X					longk=1;
X					strncpy(cksumname,p,200);
X					p+=strlen(cksumname);
X					break;
X				case 'e':
X					eflag=1;
X					break;
X				case 'E':
X					eflag=1;
X					longk=1;
X					break;
X				case 'd':
X					dflag=1;
X					break;
X				case 'D':
X					dflag=1;
X					longk=1;
X					break;
X				case 'b':
X					bflag=1;
X					flag3=0;
X					break;
X				case 'f':
X					fflag=1;
X					break;
X				case 's':
X					sflag=1;
X					break;
X				case 'u':
X					uflag=1;
X					strncpy(uuname,p,200);
X					p+=strlen(uuname);
X					break;
X				case 'h':
X					hflag=1;
X					break;
X				case 'k':
X					kflag=1;
X					if ((i+1) == argc)
X						{
X						fputs("must have a key with the -k option\n",stderr);
X						error=1;
X						}
X					else
X						{
X						int j;
X
X						i++;
X						strncpy(key,argv[i],KEYSIZB);
X						for (j=strlen(argv[i])-1; j>=0; j--)
X							argv[i][j]='\0';
X						}
X					break;
X				default:
X					fprintf(stderr,"'%c' unknown flag\n",p[-1]);
X					error=1;
X					break;
X					}
X				}
X			}
X		else
X			{
X			if (in == NULL)
X				in=argv[i];
X			else if (out == NULL)
X				out=argv[i];
X			else
X				error=1;
X			}
X		}
X	if (error) usage();
X	/* We either
X	 * do checksum or
X	 * do encrypt or
X	 * do decrypt or
X	 * do decrypt then ckecksum or
X	 * do checksum then encrypt
X	 */
X	if (((eflag+dflag) == 1) || cflag)
X		{
X		if (eflag) do_encrypt=DES_ENCRYPT;
X		if (dflag) do_encrypt=DES_DECRYPT;
X		}
X	else
X		usage();
X
X	if (	(in != NULL) &&
X		(out != NULL) &&
X#ifndef MSDOS
X		(stat(in,&ins) != -1) &&
X		(stat(out,&outs) != -1) &&
X		(ins.st_dev == outs.st_dev) &&
X		(ins.st_ino == outs.st_ino))
X#else /* MSDOS */
X		(strcmp(in,out) == 0))
X#endif
X			{
X			fputs("input and output file are the same\n",stderr);
X			EXIT(3);
X			}
X
X	if (!kflag)
X		if (des_read_pw_string(key,KEYSIZB+1,"Enter key:",eflag?VERIFY:0))
X			{
X			fputs("password error\n",stderr);
X			EXIT(2);
X			}
X
X	if (in == NULL)
X		DES_IN=stdin;
X	else if ((DES_IN=fopen(in,"r")) == NULL)
X		{
X		perror("opening input file");
X		EXIT(4);
X		}
X
X	CKSUM_OUT=stdout;
X	if (out == NULL)
X		{
X		DES_OUT=stdout;
X		CKSUM_OUT=stderr;
X		}
X	else if ((DES_OUT=fopen(out,"w")) == NULL)
X		{
X		perror("opening output file");
X		EXIT(5);
X		}
X
X#ifdef MSDOS
X	/* This should set the file to binary mode. */
X	{
X#include <fcntl.h>
X	if (!(uflag && dflag))
X		setmode(fileno(DES_IN),O_BINARY);
X	if (!(uflag && eflag))
X		setmode(fileno(DES_OUT),O_BINARY);
X	}
X#endif
X
X	doencryption();
X	fclose(DES_IN);
X	fclose(DES_OUT);
X	EXIT(0);
X	}
X
Xusage()
X	{
X	char **u;
X	static char *usage[]={
X"des <options> [input-file [output-file]]",
X"options:",
X"-e         : encrypt using sunOS compatible user key to DES key conversion.",
X"-E         : encrypt ",
X"-d         : decrypt using sunOS compatible user key to DES key conversion.",
X"-D         : decrypt ",
X"-c[ckname] : generate a cbc_cksum using sunOS compatible user key to",
X"             DES key conversion and output to ckname (stdout default,",
X"             stderr if data being output on stdout).  The checksum is",
X"             generated before encryption and after decryption if used",
X"             in conjunction with -[eEdD].",
X"-C[ckname] : generate a cbc_cksum as for -c but compatible with -[ED].",
X"-k key     : use key 'key'",
X"-h         : the key that is entered will be a hexidecimal number",
X"-u[uuname] : input file is uudecoded if -[dD] or output uuencoded",
X"             data if -[eE] (uuname is the filename to put in the",
X"             uuencode header).",
X"-b         : encrypt using DES in ecb encryption mode, the defaut is",
X"             cbc mode.",
X"-3         : encrypt using tripple DES encryption.  This uses 2 keys",
X"             generated from the input key.  If the input key is less",
X"             than 8 characters long, this is equivelent to normal",
X"             encryption.  Default is tripple cbc, -b makes it tripple ecb.",
XNULL
X};
X	for (u=usage; *u; u++)
X		{
X		fputs(*u,stderr);
X		fputc('\n',stderr);
X		}
X
X	EXIT(1);
X	}
X
Xdoencryption()
X	{
X	register int i;
X	des_key_schedule ks,ks2;
X	unsigned char iv[8],iv2[8],iv3[8];
X	char *p;
X	int num=0,j,k,l,rem,ll,len,last,ex=0;
X	des_cblock kk,k2;
X	FILE *O;
X	int Exit=0;
X#ifndef MSDOS
X	static unsigned char buf[BUFSIZE+8],obuf[BUFSIZE+8];
X#else
X	static unsigned char *buf=NULL,*obuf=NULL;
X
X	if (buf == NULL)
X		{
X		if (    (( buf=(unsigned char *)malloc(BUFSIZE+8)) == NULL) ||
X			((obuf=(unsigned char *)malloc(BUFSIZE+8)) == NULL))
X			{
X			fputs("Not enough memory\n",stderr);
X			Exit=10;
X			goto problems;
X			}
X		}
X#endif
X
X	if (hflag)
X		{
X		j=(flag3?16:8);
X		p=key;
X		for (i=0; i<j; i++)
X			{
X			k=0;
X			if ((*p <= '9') && (*p >= '0'))
X				k=(*p-'0')<<4;
X			else if ((*p <= 'f') && (*p >= 'a'))
X				k=(*p-'a'+10)<<4;
X			else if ((*p <= 'F') && (*p >= 'A'))
X				k=(*p-'A'+10)<<4;
X			else
X				{
X				fputs("Bad hex key\n",stderr);
X				Exit=9;
X				goto problems;
X				}
X			p++;
X			if ((*p <= '9') && (*p >= '0'))
X				k|=(*p-'0');
X			else if ((*p <= 'f') && (*p >= 'a'))
X				k|=(*p-'a'+10);
X			else if ((*p <= 'F') && (*p >= 'A'))
X				k|=(*p-'A'+10);
X			else
X				{
X				fputs("Bad hex key\n",stderr);
X				Exit=9;
X				goto problems;
X				}
X			p++;
X			if (i < 8)
X				kk[i]=k;
X			else
X				k2[i-8]=k;
X			}
X		des_set_key((C_Block *)k2,ks2);
X		bzero(k2,sizeof(k2));
X		}
X	else if (longk || flag3)
X		{
X		if (flag3)
X			{
X			des_string_to_2keys(key,(C_Block *)kk,(C_Block *)k2);
X			des_set_key((C_Block *)k2,ks2);
X			bzero(k2,sizeof(k2));
X			}
X		else
X			des_string_to_key(key,(C_Block *)kk);
X		}
X	else
X		for (i=0; i<KEYSIZ; i++)
X			{
X			l=0;
X			k=key[i];
X			for (j=0; j<8; j++)
X				{
X				if (k&1) l++;
X				k>>=1;
X				}
X			if (l & 1)
X				kk[i]=key[i]&0x7f;
X			else
X				kk[i]=key[i]|0x80;
X			}
X
X	des_set_key((C_Block *)kk,ks);
X	bzero(key,sizeof(key));
X	bzero(kk,sizeof(kk));
X	/* woops - A bug that does not showup under unix :-( */
X	bzero(iv,sizeof(iv));
X	bzero(iv2,sizeof(iv2));
X	bzero(iv3,sizeof(iv3));
X
X	l=1;
X	rem=0;
X	/* first read */
X	if (eflag || (!dflag && cflag))
X		{
X		for (;;)
X			{
X			num=l=fread(&(buf[rem]),1,BUFSIZE,DES_IN);
X			l+=rem;
X			num+=rem;
X			if (l < 0)
X				{
X				perror("read error");
X				Exit=6;
X				goto problems;
X				}
X
X			rem=l%8;
X			len=l-rem;
X			if (feof(DES_IN))
X				{
X				srand(time(NULL));
X				for (i=7-rem; i>0; i--)
X					buf[l++]=rand()&0xff;
X				buf[l++]=rem;
X				ex=1;
X				len+=rem;
X				}
X			else
X				l-=rem;
X
X			if (cflag)
X				{
X				des_cbc_cksum((C_Block *)buf,(C_Block *)cksum,
X					(long)len,ks,(C_Block *)cksum);
X				if (!eflag)
X					{
X					if (feof(DES_IN)) break;
X					else continue;
X					}
X				}
X
X			if (bflag && !flag3)
X				for (i=0; i<l; i+=8)
X					des_ecb_encrypt(
X						(des_cblock *)&(buf[i]),
X						(des_cblock *)&(obuf[i]),
X						ks,do_encrypt);
X			else if (flag3 && bflag)
X				for (i=0; i<l; i+=8)
X					des_3ecb_encrypt(
X						(des_cblock *)&(buf[i]),
X						(des_cblock *)&(obuf[i]),
X						ks,ks2,do_encrypt);
X			else if (flag3 && !bflag)
X				{
X				char tmpbuf[8];
X
X				if (rem) bcopy(&(buf[l]),tmpbuf,rem);
X				des_3cbc_encrypt(
X					(des_cblock *)buf,(des_cblock *)obuf,
X					(long)l,ks,ks2,(des_cblock *)iv,
X					(des_cblock *)iv2,do_encrypt);
X				if (rem) bcopy(tmpbuf,&(buf[l]),rem);
X				}
X			else
X				{
X				des_cbc_encrypt(
X					(des_cblock *)buf,(des_cblock *)obuf,
X					(long)l,ks,(des_cblock *)iv,do_encrypt);
X				if (l >= 8) bcopy(&(obuf[l-8]),iv,8);
X				}
X			if (rem) bcopy(&(buf[l]),buf,rem);
X
X			i=0;
X			while (i < l)
X				{
X				if (uflag)
X					j=uufwrite(obuf,1,l-i,DES_OUT);
X				else
X					j=fwrite(obuf,1,l-i,DES_OUT);
X				if (j == -1)
X					{
X					perror("Write error");
X					Exit=7;
X					goto problems;
X					}
X				i+=j;
X				}
X			if (feof(DES_IN))
X				{
X				if (uflag) uufwriteEnd(DES_OUT);
X				break;
X				}
X			}
X		}
X	else /* decrypt */
X		{
X		ex=1;
X		for (;;)
X			{
X			if (ex) {
X				if (uflag)
X					l=uufread(buf,1,BUFSIZE,DES_IN);
X				else
X					l=fread(buf,1,BUFSIZE,DES_IN);
X				ex=0;
X				rem=l%8;
X				l-=rem;
X				}
X			if (l < 0)
X				{
X				perror("read error");
X				Exit=6;
X				goto problems;
X				}
X
X			if (bflag && !flag3)
X				for (i=0; i<l; i+=8)
X					des_ecb_encrypt(
X						(des_cblock *)&(buf[i]),
X						(des_cblock *)&(obuf[i]),
X						ks,do_encrypt);
X			else if (flag3 && bflag)
X				for (i=0; i<l; i+=8)
X					des_3ecb_encrypt(
X						(des_cblock *)&(buf[i]),
X						(des_cblock *)&(obuf[i]),
X						ks,ks2,do_encrypt);
X			else if (flag3 && !bflag)
X				{
X				des_3cbc_encrypt(
X					(des_cblock *)buf,(des_cblock *)obuf,
X					(long)l,ks,ks2,(des_cblock *)iv,
X					(des_cblock *)iv2,do_encrypt);
X				}
X			else
X				{
X				des_cbc_encrypt(
X					(des_cblock *)buf,(des_cblock *)obuf,
X				 	(long)l,ks,(des_cblock *)iv,do_encrypt);
X				if (l >= 8) bcopy(&(buf[l-8]),iv,8);
X				}
X
X			if (uflag)
X				ll=uufread(&(buf[rem]),1,BUFSIZE,DES_IN);
X			else
X				ll=fread(&(buf[rem]),1,BUFSIZE,DES_IN);
X			ll+=rem;
X			rem=ll%8;
X			ll-=rem;
X			if (feof(DES_IN) && (ll == 0))
X				{
X				last=obuf[l-1];
X
X				if ((last > 7) || (last < 0))
X					{
X					fputs("The file was not decrypted correctly.\n",
X						stderr);
X					/*Exit=8;
X					goto problems;*/
X					last=0;
X					}
X				l=l-8+last;
X				}
X			i=0;
X			if (cflag) des_cbc_cksum((C_Block *)obuf,
X				(C_Block *)cksum,(long)l/8*8,ks,
X				(C_Block *)cksum);
X			while (i != l)
X				{
X				j=fwrite(obuf,1,l-i,DES_OUT);
X				if (j == -1)
X					{
X					perror("Write error");
X					Exit=7;
X					goto problems;
X					}
X				i+=j;
X				}
X			l=ll;
X			if ((l == 0) && feof(DES_IN)) break;
X			}
X		}
X	if (cflag)
X		{
X		l=0;
X		if (cksumname[0] != '\0')
X			{
X			if ((O=fopen(cksumname,"w")) != NULL)
X				{
X				CKSUM_OUT=O;
X				l=1;
X				}
X			}
X		for (i=0; i<8; i++)
X			fprintf(CKSUM_OUT,"%02X",cksum[i]);
X		fprintf(CKSUM_OUT,"\n");
X		if (l) fclose(CKSUM_OUT);
X		}
Xproblems:
X	bzero(buf,sizeof(buf));
X	bzero(obuf,sizeof(obuf));
X	bzero(ks,sizeof(ks));
X	bzero(ks2,sizeof(ks2));
X	bzero(iv,sizeof(iv));
X	bzero(iv2,sizeof(iv2));
X	bzero(iv3,sizeof(iv3));
X	bzero(kk,sizeof(kk));
X	bzero(k2,sizeof(k2));
X	bzero(uubuf,sizeof(uubuf));
X	bzero(b,sizeof(b));
X	bzero(bb,sizeof(bb));
X	bzero(cksum,sizeof(cksum));
X	if (Exit) EXIT(Exit);
X	}
X
Xint uufwrite(data,size,num,fp)
Xchar *data;
Xint size; /* We ignore this parameter but it should be > ~50 I believe */
Xint num;
XFILE *fp;
X	{
X	int i,j,left,rem,ret=num;
X	static int start=1;
X
X	if (start)
X		{
X		fprintf(fp,"begin 600 %s\n",
X			(uuname[0] == '\0')?"text.d":uuname);
X		start=0;
X		}
X
X	if (uubufnum)
X		{
X		if (uubufnum+num < 45)
X			{
X			bcopy(data,&(uubuf[uubufnum]),num);
X			uubufnum+=num;
X			return(num);
X			}
X		else
X			{
X			i=45-uubufnum;
X			bcopy(data,&(uubuf[uubufnum]),i);
X			j=uuencode(uubuf,45,b);
X			fwrite(b,1,j,fp);
X			uubufnum=0;
X			data+=i;
X			num-=i;
X			}
X		}
X
X	for (i=0; i<(num-INUUBUFN); i+=INUUBUFN)
X		{
X		j=uuencode(&(data[i]),INUUBUFN,b);
X		fwrite(b,1,j,fp);
X		}
X	rem=(num-i)%45;
X	left=(num-i-rem);
X	if (left)
X		{
X		j=uuencode(&(data[i]),left,b);
X		fwrite(b,1,j,fp);
X		i+=left;
X		}
X	if (i != num)
X		{
X		bcopy(&(data[i]),uubuf,rem);
X		uubufnum=rem;
X		}
X	return(ret);
X	}
X
Xint uufwriteEnd(fp)
XFILE *fp;
X	{
X	int j;
X	static char *end=" \nend\n";
X
X	if (uubufnum != 0)
X		{
X		uubuf[uubufnum]='\0';
X		uubuf[uubufnum+1]='\0';
X		uubuf[uubufnum+2]='\0';
X		j=uuencode(uubuf,uubufnum,b);
X		fwrite(b,1,j,fp);
X		}
X	fwrite(end,1,strlen(end),fp);
X	}
X
Xint uufread(out,size,num,fp)
Xchar *out;
Xint size; /* should always be > ~ 60; I actually ignore this parameter :-) */
Xint num;
XFILE *fp;
X	{
X	int i,j,tot;
X	static int done=0;
X	static int valid=0;
X	static int start=1;
X
X	if (start)
X		{
X		for (;;)
X			{
X			b[0]='\0';
X			fgets(b,300,fp);
X			if (b[0] == '\0')
X				{
X				fprintf(stderr,"no 'begin' found in uuencoded input\n");
X				return(-1);
X				}
X			if (strncmp(b,"begin ",6) == 0) break;
X			}
X		start=0;
X		}
X	if (done) return(0);
X	tot=0;
X	if (valid)
X		{
X		bcopy(bb,out,valid);
X		tot=valid;
X		valid=0;
X		}
X	for (;;)
X		{
X		b[0]='\0';
X		fgets(b,300,fp);
X		if (b[0] == '\0') break;
X		i=strlen(b);
X		if ((b[0] == 'e') && (b[1] == 'n') && (b[2] == 'd'))
X			{
X			done=1;
X			while (!feof(fp))
X				{
X				fgets(b,300,fp);
X				}
X			break;
X			}
X		i=uudecode(b,i,bb);
X		if (i < 0) break;
X		if ((i+tot+8) > num)
X			{
X			/* num to copy to make it a multiple of 8 */
X			j=(num/8*8)-tot-8;
X			bcopy(bb,&(out[tot]),j);
X			tot+=j;
X			bcopy(&(bb[j]),bb,i-j);
X			valid=i-j;
X			break;
X			}
X		bcopy(bb,&(out[tot]),i);
X		tot+=i;
X		}
X	return(tot);
X	}
X
X#define ccc2l(c,l)      (l =((unsigned long)(*((c)++)))<<16, \
X			 l|=((unsigned long)(*((c)++)))<< 8, \
X		 	 l|=((unsigned long)(*((c)++))))
X
X#define l2ccc(l,c)      (*((c)++)=(unsigned char)(((l)>>16)&0xff), \
X                         *((c)++)=(unsigned char)(((l)>> 8)&0xff), \
X                         *((c)++)=(unsigned char)(((l)    )&0xff))
X
X
Xint uuencode(in,num,out)
Xunsigned char *in;
Xint num;
Xunsigned char *out;
X	{
X	int j,i,k,n,tot=0;
X	unsigned long l;
X	register unsigned char *p;
X	p=out;
X
X	for (j=0; j<num; j+=45)
X		{
X		if (j+45 > num)
X			i=(num-j);
X		else	i=45;
X		*(p++)=i+' ';
X		for (n=0; n<i; n+=3)
X			{
X			ccc2l(in,l);
X			*(p++)=((l>>18)&0x3f)+' ';
X			*(p++)=((l>>12)&0x3f)+' ';
X			*(p++)=((l>> 6)&0x3f)+' ';
X			*(p++)=((l    )&0x3f)+' ';
X			tot+=4;
X			}
X		*(p++)='\n';
X		tot+=2;
X		}
X	*p='\0';
X	l=0;
X	return(tot);
X	}
X
Xint uudecode(in,num,out)
Xunsigned char *in;
Xint num;
Xunsigned char *out;
X	{
X	int j,i,k;
X	unsigned int n,space=0;
X	unsigned long l;
X	unsigned long w,x,y,z;
X	unsigned int blank='\n'-' ';
X
X	for (j=0; j<num; )
X		{
X		n= *(in++)-' ';
X		if (n == blank)
X			{
X			n=0;
X			in--;
X			}
X		if (n > 60)
X			{
X			fprintf(stderr,"uuencoded line length too long\n");
X			return(-1);
X			}
X		j++;
X
X		for (i=0; i<n; j+=4,i+=3)
X			{
X			/* the following is for cases where spaces are
X			 * removed from lines.
X			 */
X			if (space)
X				{
X				w=x=y=z=0;
X				}
X			else
X				{
X				w= *(in++)-' ';
X				x= *(in++)-' ';
X				y= *(in++)-' ';
X				z= *(in++)-' ';
X				}
X			if ((w > 63) || (x > 63) || (y > 63) || (z > 63))
X				{
X				k=0;
X				if (w == blank) k=1;
X				if (x == blank) k=2;
X				if (y == blank) k=3;
X				if (z == blank) k=4;
X				space=1;
X				switch (k) {
X				case 1:	w=0; in--;
X				case 2: x=0; in--;
X				case 3: y=0; in--;
X				case 4: z=0; in--;
X					break;
X				case 0:
X					space=0;
X					fprintf(stderr,"bad uuencoded data values\n");
X					w=x=y=z=0;
X					return(-1);
X					break;
X					}
X				}
X			l=(w<<18)|(x<<12)|(y<< 6)|(z    );
X			l2ccc(l,out);
X			}
X		if (*(in++) != '\n')
X			{
X			fprintf(stderr,"missing nl in uuencoded line\n");
X			w=x=y=z=0;
X			return(-1);
X			}
X		j++;
X		}
X	*out='\0';
X	w=x=y=z=0;
X	return(n);
X	}
END_OF_FILE
  if test 16298 -ne `wc -c <'des.c'`; then
    echo shar: \"'des.c'\" unpacked with wrong size!
  fi
  # end of 'des.c'
fi
if test -f 'des.man' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'des.man'\"
else
  echo shar: Extracting \"'des.man'\" \(4709 characters\)
  sed "s/^X//" >'des.man' <<'END_OF_FILE'
X.TH DES 1 
X.SH NAME
Xdes - encrypt or decrypt data using Data Encryption Standard
X.SH SYNOPSIS
X.B des
X(
X.B \-e
X|
X.B \-E
X) | (
X.B \-d
X|
X.B \-D
X) | (
X.B \-\fR[\fPcC\fR][\fPckname\fR]\fP
X) |
X[
X.B \-b3hfs
X] [
X.B \-k
X.I key
X]
X] [
X.B \-u\fR[\fIuuname\fR]
X[
X.I input-file
X[
X.I output-file
X] ]
X.SH DESCRIPTION
X.B des
Xencrypts and decrypts data using the
XData Encryption Standard algorithm.
XOne of
X.B \-e, \-E
X(for encrypt) or
X.B \-d, \-D
X(for decrypt) must be specified.
XIt is also possible to use
X.B \-c
Xor
X.B \-C
Xin conjunction or instead of the a encrypt/decrypt option to generate
Xa 16 character hexadecimal checksum, generated via the
X.I des_cbc_cksum.
X.LP
XTwo standard encryption modes are supported by the
X.B des
Xprogram, Cipher Block Chaining (the default) and Electronic Code Book
X(specified with
X.B \-b
X).
X.LP
XThe key used for the DES
Xalgorithm is obtained by prompting the user unless the
X.B `\-k
X.I key'
Xoption is given.
XIf the key is an argument to the
X.B des
Xcommand, it is potentially visible to users executing
X.BR ps (1)
Xor a derivative.  To minimise this possibility,
X.B des
Xtakes care to destroy the key argument immediately upon entry.
XIf your shell keeps a history file be careful to make sure it is not
Xworld readable.
X.LP
XSince this program attempts to maintain compatability with sunOS's
Xdes(1) command, there are 2 different methods used to convert the user
Xsupplied key to a des key.
XWhenever and one or more of
X.B \-E, \-D, \-C
Xor
X.B \-3
Xoptions are used, the key conversion procedure will not be compatible
Xwith the sunOS des(1) version but will use all the user supplied
Xcharacter to generate the des key.
X.B des
Xcommand reads from standard input unless
X.I input-file
Xis specified and writes to standard output unless
X.I output-file
Xis given.
X.SH OPTIONS
X.TP
X.B \-b
XSelect ECB
X(eight bytes at a time) encryption mode.
X.TP
X.B \-3
XEncrypt using triple encryption.
XBy default triple cbc encryption is used but if the
X.B \-b
Xoption is used then triple ecb encryption is performed.
XIf the key is less than 8 characters long, the flag has no effect.
X.TP
X.B \-e
XEncrypt data using an 8 byte key in a manner compatible with sunOS
Xdes(1).
X.TP
X.B \-E
XEncrypt data using a key of nearly unlimited length (1024 bytes).
XThis will product a more secure encryption.
X.TP
X.B \-d
XDecrypt data that was encrypted with the \-e option.
X.TP
X.B \-D
XDecrypt data that was encrypted with the \-E option.
X.TP
X.B \-c
XGenerate a 16 character hexadecimal cbc checksum and output this to
Xstderr.
XIf a filename was specified after the
X.B \-c
Xoption, the checksum is output to that file.
XThe checksum is generated using a key generated in a sunOS compatible
Xmanner.
X.TP
X.B \-C
XA cbc checksum is generated in the same manner as described for the
X.B \-c
Xoption but the DES key is generated in the same manner as used for the
X.B \-E
Xand
X.B \-D
Xoptions
X.TP
X.B \-f
XDoes nothing - allowed for compatibility with sunOS des(1) command.
X.TP
X.B \-s
XDoes nothing - allowed for compatibility with sunOS des(1) command.
X.TP
X.B "\-k \fIkey\fP"
XUse the encryption 
X.I key
Xspecified.
X.TP
X.B "\-h"
XThe
X.I key
Xis assumed to be a 16 character hexadecimal number.
XIf the
X.B "\-3"
Xoption is used the key is assumed to be a 32 character hexadecimal
Xnumber.
X.TP
X.B \-u
XThis flag is used to read and write uuencoded files.  If decrypting,
Xthe input file is assumed to contain uuencoded, DES encrypted data.
XIf encrypting, the characters following the -u are used as the name of
Xthe uuencoded file to embed in the begin line of the uuencoded
Xoutput.  If there is no name specified after the -u, the name text.des
Xwill be embedded in the header.
X.SH SEE ALSO
X.B ps (1)
X.B des_crypt(3)
X.SH BUGS
X.LP
XThe problem with using the
X.B -e
Xoption is the short key length.
XIt would be better to use a real 56-bit key rather than an
XASCII-based 56-bit pattern.  Knowing that the key was derived from ASCII
Xradically reduces the time necessary for a brute-force cryptographic attack.
XMy attempt to remove this problem is to add an alternative text-key to
XDES-key function.  This alternative function (accessed via
X.B -E, -D, -S
Xand
X.B -3
X)
Xuses DES to help generate the key.
X.LP
XBe carefully when using the -u option.  Doing des -ud <filename> will
Xnot decrypt filename (the -u option will gobble the d option).
X.LP
XThe VMS operating system operates in a world where files are always a
Xmultiple of 512 bytes.  This causes problems when encrypted data is
Xsend from unix to VMS since a 88 byte file will suddenly be padded
Xwith 424 null bytes.  To get around this problem, use the -u option
Xto uuencode the data before it is send to the VMS system.
X.SH AUTHOR
X.LP
XEric Young (eay@psych.psy.uq.oz.au), Psychology Department,
XUniversity of Queensland, Australia.
END_OF_FILE
  if test 4709 -ne `wc -c <'des.man'`; then
    echo shar: \"'des.man'\" unpacked with wrong size!
  fi
  # end of 'des.man'
fi
if test -f 'destest.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'destest.c'\"
else
  echo shar: Extracting \"'destest.c'\" \(12238 characters\)
  sed "s/^X//" >'destest.c' <<'END_OF_FILE'
X/* destest.c */
X/* Copyright (C) 1993 Eric Young - see README for more details */
X#include <stdio.h>
X#include "des_locl.h" /* for des.h and bcopy macros */
X/* tisk tisk - the test keys don't all have odd parity :-( */
X
X/* test data */
X#define NUM_TESTS 34
Xstatic unsigned char key_data[NUM_TESTS][8]={
X	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
X	0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
X	0x30,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
X	0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,
X	0x01,0x23,0x45,0x67,0x89,0xAB,0xCD,0xEF,
X	0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,
X	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
X	0xFE,0xDC,0xBA,0x98,0x76,0x54,0x32,0x10,
X	0x7C,0xA1,0x10,0x45,0x4A,0x1A,0x6E,0x57,
X	0x01,0x31,0xD9,0x61,0x9D,0xC1,0x37,0x6E,
X	0x07,0xA1,0x13,0x3E,0x4A,0x0B,0x26,0x86,
X	0x38,0x49,0x67,0x4C,0x26,0x02,0x31,0x9E,
X	0x04,0xB9,0x15,0xBA,0x43,0xFE,0xB5,0xB6,
X	0x01,0x13,0xB9,0x70,0xFD,0x34,0xF2,0xCE,
X	0x01,0x70,0xF1,0x75,0x46,0x8F,0xB5,0xE6,
X	0x43,0x29,0x7F,0xAD,0x38,0xE3,0x73,0xFE,
X	0x07,0xA7,0x13,0x70,0x45,0xDA,0x2A,0x16,
X	0x04,0x68,0x91,0x04,0xC2,0xFD,0x3B,0x2F,
X	0x37,0xD0,0x6B,0xB5,0x16,0xCB,0x75,0x46,
X	0x1F,0x08,0x26,0x0D,0x1A,0xC2,0x46,0x5E,
X	0x58,0x40,0x23,0x64,0x1A,0xBA,0x61,0x76,
X	0x02,0x58,0x16,0x16,0x46,0x29,0xB0,0x07,
X	0x49,0x79,0x3E,0xBC,0x79,0xB3,0x25,0x8F,
X	0x4F,0xB0,0x5E,0x15,0x15,0xAB,0x73,0xA7,
X	0x49,0xE9,0x5D,0x6D,0x4C,0xA2,0x29,0xBF,
X	0x01,0x83,0x10,0xDC,0x40,0x9B,0x26,0xD6,
X	0x1C,0x58,0x7F,0x1C,0x13,0x92,0x4F,0xEF,
X	0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,
X	0x1F,0x1F,0x1F,0x1F,0x0E,0x0E,0x0E,0x0E,
X	0xE0,0xFE,0xE0,0xFE,0xF1,0xFE,0xF1,0xFE,
X	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
X	0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
X	0x01,0x23,0x45,0x67,0x89,0xAB,0xCD,0xEF,
X	0xFE,0xDC,0xBA,0x98,0x76,0x54,0x32,0x10};
X
Xstatic unsigned char plain_data[NUM_TESTS][8]={
X	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
X	0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
X	0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x01,
X	0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,
X	0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,
X	0x01,0x23,0x45,0x67,0x89,0xAB,0xCD,0xEF,
X	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
X	0x01,0x23,0x45,0x67,0x89,0xAB,0xCD,0xEF,
X	0x01,0xA1,0xD6,0xD0,0x39,0x77,0x67,0x42,
X	0x5C,0xD5,0x4C,0xA8,0x3D,0xEF,0x57,0xDA,
X	0x02,0x48,0xD4,0x38,0x06,0xF6,0x71,0x72,
X	0x51,0x45,0x4B,0x58,0x2D,0xDF,0x44,0x0A,
X	0x42,0xFD,0x44,0x30,0x59,0x57,0x7F,0xA2,
X	0x05,0x9B,0x5E,0x08,0x51,0xCF,0x14,0x3A,
X	0x07,0x56,0xD8,0xE0,0x77,0x47,0x61,0xD2,
X	0x76,0x25,0x14,0xB8,0x29,0xBF,0x48,0x6A,
X	0x3B,0xDD,0x11,0x90,0x49,0x37,0x28,0x02,
X	0x26,0x95,0x5F,0x68,0x35,0xAF,0x60,0x9A,
X	0x16,0x4D,0x5E,0x40,0x4F,0x27,0x52,0x32,
X	0x6B,0x05,0x6E,0x18,0x75,0x9F,0x5C,0xCA,
X	0x00,0x4B,0xD6,0xEF,0x09,0x17,0x60,0x62,
X	0x48,0x0D,0x39,0x00,0x6E,0xE7,0x62,0xF2,
X	0x43,0x75,0x40,0xC8,0x69,0x8F,0x3C,0xFA,
X	0x07,0x2D,0x43,0xA0,0x77,0x07,0x52,0x92,
X	0x02,0xFE,0x55,0x77,0x81,0x17,0xF1,0x2A,
X	0x1D,0x9D,0x5C,0x50,0x18,0xF7,0x28,0xC2,
X	0x30,0x55,0x32,0x28,0x6D,0x6F,0x29,0x5A,
X	0x01,0x23,0x45,0x67,0x89,0xAB,0xCD,0xEF,
X	0x01,0x23,0x45,0x67,0x89,0xAB,0xCD,0xEF,
X	0x01,0x23,0x45,0x67,0x89,0xAB,0xCD,0xEF,
X	0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
X	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
X	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
X	0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF};
X
Xstatic unsigned char cipher_data[NUM_TESTS][8]={
X	0x8C,0xA6,0x4D,0xE9,0xC1,0xB1,0x23,0xA7,
X	0x73,0x59,0xB2,0x16,0x3E,0x4E,0xDC,0x58,
X	0x95,0x8E,0x6E,0x62,0x7A,0x05,0x55,0x7B,
X	0xF4,0x03,0x79,0xAB,0x9E,0x0E,0xC5,0x33,
X	0x17,0x66,0x8D,0xFC,0x72,0x92,0x53,0x2D,
X	0x8A,0x5A,0xE1,0xF8,0x1A,0xB8,0xF2,0xDD,
X	0x8C,0xA6,0x4D,0xE9,0xC1,0xB1,0x23,0xA7,
X	0xED,0x39,0xD9,0x50,0xFA,0x74,0xBC,0xC4,
X	0x69,0x0F,0x5B,0x0D,0x9A,0x26,0x93,0x9B,
X	0x7A,0x38,0x9D,0x10,0x35,0x4B,0xD2,0x71,
X	0x86,0x8E,0xBB,0x51,0xCA,0xB4,0x59,0x9A,
X	0x71,0x78,0x87,0x6E,0x01,0xF1,0x9B,0x2A,
X	0xAF,0x37,0xFB,0x42,0x1F,0x8C,0x40,0x95,
X	0x86,0xA5,0x60,0xF1,0x0E,0xC6,0xD8,0x5B,
X	0x0C,0xD3,0xDA,0x02,0x00,0x21,0xDC,0x09,
X	0xEA,0x67,0x6B,0x2C,0xB7,0xDB,0x2B,0x7A,
X	0xDF,0xD6,0x4A,0x81,0x5C,0xAF,0x1A,0x0F,
X	0x5C,0x51,0x3C,0x9C,0x48,0x86,0xC0,0x88,
X	0x0A,0x2A,0xEE,0xAE,0x3F,0xF4,0xAB,0x77,
X	0xEF,0x1B,0xF0,0x3E,0x5D,0xFA,0x57,0x5A,
X	0x88,0xBF,0x0D,0xB6,0xD7,0x0D,0xEE,0x56,
X	0xA1,0xF9,0x91,0x55,0x41,0x02,0x0B,0x56,
X	0x6F,0xBF,0x1C,0xAF,0xCF,0xFD,0x05,0x56,
X	0x2F,0x22,0xE4,0x9B,0xAB,0x7C,0xA1,0xAC,
X	0x5A,0x6B,0x61,0x2C,0xC2,0x6C,0xCE,0x4A,
X	0x5F,0x4C,0x03,0x8E,0xD1,0x2B,0x2E,0x41,
X	0x63,0xFA,0xC0,0xD0,0x34,0xD9,0xF7,0x93,
X	0x61,0x7B,0x3A,0x0C,0xE8,0xF0,0x71,0x00,
X	0xDB,0x95,0x86,0x05,0xF8,0xC8,0xC6,0x06,
X	0xED,0xBF,0xD1,0xC6,0x6C,0x29,0xCC,0xC7,
X	0x35,0x55,0x50,0xB2,0x15,0x0E,0x24,0x51,
X	0xCA,0xAA,0xAF,0x4D,0xEA,0xF1,0xDB,0xAE,
X	0xD5,0xD4,0x4F,0xF7,0x20,0x68,0x3D,0x0D,
X	0x2A,0x2B,0xB0,0x08,0xDF,0x97,0xC2,0xF2};
X
Xstatic unsigned char cbc_key[8]={0x01,0x23,0x45,0x67,0x89,0xab,0xcd,0xef};
Xstatic unsigned char cbc_iv[8]={0xfe,0xdc,0xba,0x98,0x76,0x54,0x32,0x10};
Xstatic unsigned char cbc_data[40]="7654321 Now is the time for ";
X
Xstatic unsigned char cbc_ok[32]={
X	0xcc,0xd1,0x73,0xff,0xab,0x20,0x39,0xf4,
X	0xac,0xd8,0xae,0xfd,0xdf,0xd8,0xa1,0xeb,
X	0x46,0x8e,0x91,0x15,0x78,0x88,0xba,0x68,
X	0x1d,0x26,0x93,0x97,0xf7,0xfe,0x62,0xb4};
X
Xstatic unsigned char pcbc_ok[32]={
X	0xcc,0xd1,0x73,0xff,0xab,0x20,0x39,0xf4,
X	0x6d,0xec,0xb4,0x70,0xa0,0xe5,0x6b,0x15,
X	0xae,0xa6,0xbf,0x61,0xed,0x7d,0x9c,0x9f,
X	0xf7,0x17,0x46,0x3b,0x8a,0xb3,0xcc,0x88};
X
Xstatic unsigned char cksum_ok[8]={
X	0x1d,0x26,0x93,0x97,0xf7,0xfe,0x62,0xb4};
X
Xstatic unsigned char cfb_key[8]={0x01,0x23,0x45,0x67,0x89,0xab,0xcd,0xef};
Xstatic unsigned char cfb_iv[8]={0x12,0x34,0x56,0x78,0x90,0xab,0xcd,0xef};
Xstatic unsigned char cfb_buf1[24],cfb_buf2[24],cfb_tmp[8];
Xstatic unsigned char cfb_plain[24]=
X	{
X	0x4e,0x6f,0x77,0x20,0x69,0x73,
X	0x20,0x74,0x68,0x65,0x20,0x74,
X	0x69,0x6d,0x65,0x20,0x66,0x6f,
X	0x72,0x20,0x61,0x6c,0x6c,0x20
X	};
Xstatic unsigned char cfb_cipher[24]=
X	{
X	0xf3,0x1f,0xda,0x07,0x01,0x14,
X	0x62,0xee,0x18,0x7f,0x43,0xd8,
X	0x0a,0x7c,0xd9,0xb5,0xb0,0xd2,
X	0x90,0xda,0x6e,0x5b,0x9a,0x87
X	};
X
Xstatic unsigned char ofb_key[8]={0x01,0x23,0x45,0x67,0x89,0xab,0xcd,0xef};
Xstatic unsigned char ofb_iv[8]={0x12,0x34,0x56,0x78,0x90,0xab,0xcd,0xef};
Xstatic unsigned char ofb_plain[24]=
X	{
X	0x4e,0x6f,0x77,0x20,0x69,0x73,
X	0x20,0x74,0x68,0x65,0x20,0x74,
X	0x69,0x6d,0x65,0x20,0x66,0x6f,
X	0x72,0x20,0x61,0x6c,0x6c,0x20
X	};
Xstatic unsigned char ofb_buf1[24],ofb_buf2[24],ofb_tmp[8];
Xstatic unsigned char ofb_cipher[24]=
X	{
X	0xf3,0x09,0x62,0x49,0xc7,0xf4,0x6e,0x51,
X	0x35,0xf2,0x4a,0x24,0x2e,0xeb,0x3d,0x3f,
X	0x3d,0x6d,0x5b,0xe3,0x25,0x5a,0xf8,0xc3
X	};
X
Xchar *malloc();
Xchar *pt();
X
Xmain()
X	{
X	int i,j;
X	des_cblock in,out,outin;
X	des_key_schedule ks;
X	unsigned char cbc_in[40],cbc_out[40];
X	unsigned long cs;
X	unsigned char qret[4][4];
X	unsigned long lqret[4];
X	char *str;
X
X	printf("Doing ecb\n");
X	for (i=0; i<NUM_TESTS; i++)
X		{
X		if ((j=key_sched((C_Block *)(key_data[i]),ks)) != 0)
X			printf("Key error %2d:%d\n",i+1,j);
X		bcopy(plain_data[i],in,8);
X		bzero(out,8);
X		bzero(outin,8);
X		des_ecb_encrypt((C_Block *)in,(C_Block *)out,ks,DES_ENCRYPT);
X		des_ecb_encrypt((C_Block *)out,(C_Block *)outin,ks,DES_DECRYPT);
X
X		if (bcmp(out,cipher_data[i],8) != 0)
X			{
X			printf("Encryption error %2d\nk=%s p=%s o=%s act=%s\n",
X				i+1,pt(key_data[i]),pt(in),pt(cipher_data[i]),
X				pt(out));
X			}
X		if (bcmp(in,outin,8) != 0)
X			{
X			printf("Decryption error %2d\nk=%s p=%s o=%s act=%s\n",
X				i+1,pt(key_data[i]),pt(out),pt(in),pt(outin));
X			}
X		}
X
X	printf("Doing cbc\n");
X	if ((j=key_sched((C_Block *)cbc_key,ks)) != 0)
X		printf("Key error %2d:%d\n",i+1,j);
X	bzero(cbc_out,40);
X	bzero(cbc_in,40);
X	des_cbc_encrypt((C_Block *)cbc_data,(C_Block *)cbc_out,
X		(long)strlen(cbc_data),ks,(C_Block *)cbc_iv,DES_ENCRYPT);
X	if (bcmp(cbc_out,cbc_ok,32) != 0)
X		printf("cbc_encrypt encrypt error\n");
X	des_cbc_encrypt((C_Block *)cbc_out,(C_Block *)cbc_in,
X		(long)strlen(cbc_data),ks,(C_Block *)cbc_iv,DES_DECRYPT);
X	if (bcmp(cbc_in,cbc_data,32) != 0)
X		printf("cbc_encrypt decrypt error\n");
X
X	printf("Doing pcbc\n");
X	if ((j=key_sched((C_Block *)cbc_key,ks)) != 0)
X		printf("Key error %2d:%d\n",i+1,j);
X	bzero(cbc_out,40);
X	bzero(cbc_in,40);
X	des_pcbc_encrypt((C_Block *)cbc_data,(C_Block *)cbc_out,
X		(long)strlen(cbc_data),ks,(C_Block *)cbc_iv,DES_ENCRYPT);
X	if (bcmp(cbc_out,pcbc_ok,32) != 0)
X		printf("pcbc_encrypt encrypt error\n");
X	des_pcbc_encrypt((C_Block *)cbc_out,(C_Block *)cbc_in,
X		(long)strlen(cbc_data),ks,(C_Block *)cbc_iv,DES_DECRYPT);
X	if (bcmp(cbc_in,cbc_data,32) != 0)
X		printf("pcbc_encrypt decrypt error\n");
X
X	printf("Doing cfb\n");
X	key_sched((C_Block *)cfb_key,ks);
X	bcopy(cfb_iv,cfb_tmp,sizeof(cfb_iv));
X	des_cfb_encrypt(cfb_plain,cfb_buf1,8,(long)sizeof(cfb_plain),ks,
X		(C_Block *)cfb_tmp,DES_ENCRYPT);
X	if (bcmp(cfb_cipher,cfb_buf1,sizeof(cfb_buf1)) != 0)
X		printf("cfb_encrypt encrypt error\n");
X	bcopy(cfb_iv,cfb_tmp,sizeof(cfb_iv));
X	des_cfb_encrypt(cfb_buf1,cfb_buf2,8,(long)sizeof(cfb_buf1),ks,
X		(C_Block *)cfb_tmp,DES_DECRYPT);
X	if (bcmp(cfb_plain,cfb_buf2,sizeof(cfb_buf2)) != 0)
X		printf("cfb_encrypt decrypt error\n");
X
X	bcopy(cfb_iv,cfb_tmp,sizeof(cfb_iv));
X	for (i=0; i<sizeof(cfb_plain); i++)
X		des_cfb_encrypt(&(cfb_plain[i]),&(cfb_buf1[i]),
X			8,(long)1,ks,(C_Block *)cfb_tmp,DES_ENCRYPT);
X	if (bcmp(cfb_cipher,cfb_buf1,sizeof(cfb_buf1)) != 0)
X		printf("cfb_encrypt small encrypt error\n");
X
X	bcopy(cfb_iv,cfb_tmp,sizeof(cfb_iv));
X	for (i=0; i<sizeof(cfb_plain); i++)
X		des_cfb_encrypt(&(cfb_buf1[i]),&(cfb_buf2[i]),
X			8,(long)1,ks,(C_Block *)cfb_tmp,DES_DECRYPT);
X	if (bcmp(cfb_plain,cfb_buf2,sizeof(cfb_buf2)) != 0)
X		printf("cfb_encrypt small decrypt error\n");
X
X	printf("Doing ofb\n");
X	key_sched((C_Block *)ofb_key,ks);
X	bcopy(ofb_iv,ofb_tmp,sizeof(ofb_iv));
X	des_ofb_encrypt(ofb_plain,ofb_buf1,64,(long)sizeof(cfb_plain)/8,ks,
X		(C_Block *)ofb_tmp);
X	if (bcmp(ofb_cipher,ofb_buf1,sizeof(ofb_buf1)) != 0)
X		printf("ofb_encrypt encrypt error\n");
X	bcopy(ofb_iv,ofb_tmp,sizeof(ofb_iv));
X	des_ofb_encrypt(ofb_buf1,ofb_buf2,64,(long)sizeof(ofb_buf1)/8,ks,
X		(C_Block *)ofb_tmp);
X	if (bcmp(ofb_plain,ofb_buf2,sizeof(ofb_buf2)) != 0)
X		printf("ofb_encrypt decrypt error\n");
X
X	printf("Doing cbc_cksum\n");
X	des_cbc_cksum((C_Block *)cbc_data,(C_Block *)cbc_out,
X		(long)strlen(cbc_data),ks,(C_Block *)cbc_iv);
X	if (bcmp(cbc_out,cksum_ok,8) != 0)
X		printf("cbc_cksum error\n");
X
X	printf("Doing quad_cksum\n");
X	cs=quad_cksum((C_Block *)cbc_data,(C_Block *)qret,
X		(long)strlen(cbc_data),2,(C_Block *)cbc_iv);
X	for (i=0; i<4; i++)
X		{
X		lqret[i]=0;
X		bcopy(&(qret[i][0]),&(lqret[i]),4);
X		}
X	{ /* Big-endian fix */
X	static unsigned long l=1;
X	static unsigned char *c=(unsigned char *)&l;
X	unsigned long ll;
X
X	if (!c[0])
X		{
X		ll=lqret[0]^lqret[3];
X		lqret[0]^=ll;
X		lqret[3]^=ll;
X		ll=lqret[1]^lqret[2];
X		lqret[1]^=ll;
X		lqret[2]^=ll;
X		}
X	}
X	if (cs != 0x70d7a63a)
X		printf("quad_cksum error, ret %08x should be 70d7a63a\n",cs);
X	if (lqret[0] != 0x327eba8d)
X		printf("quad_cksum error, out[0] %08x is not %08x\n",
X			lqret[0],0x327eba8d);
X	if (lqret[1] != 0x201a49cc)
X		printf("quad_cksum error, out[1] %08x is not %08x\n",
X			lqret[1],0x201a49cc);
X	if (lqret[2] != 0x70d7a63a)
X		printf("quad_cksum error, out[2] %08x is not %08x\n",
X			lqret[2],0x70d7a63a);
X	if (lqret[3] != 0x501c2c26)
X		printf("quad_cksum error, out[3] %08x is not %08x\n",
X			lqret[3],0x501c2c26);
X
X	printf("input word alignment test");
X	for (i=0; i<4; i++)
X		{
X		printf(" %d",i);
X		des_cbc_encrypt((C_Block *)&(cbc_out[i]),(C_Block *)cbc_in,
X			(long)strlen(cbc_data),ks,(C_Block *)cbc_iv,
X			DES_ENCRYPT);
X		}
X	printf("\noutput word alignment test");
X	for (i=0; i<4; i++)
X		{
X		printf(" %d",i);
X		des_cbc_encrypt((C_Block *)cbc_out,(C_Block *)&(cbc_in[i]),
X			(long)strlen(cbc_data),ks,(C_Block *)cbc_iv,
X			DES_ENCRYPT);
X		}
X	printf("\n");
X	printf("fast crypt test ");
X	str=crypt("testing","ef");
X	if (strcmp("efGnQx2725bI2",str) != 0)
X		printf("fast crypt error, %x should be efGnQx2725bI2\n",str);
X	str=crypt("bca76;23","yA");
X	if (strcmp("yA1Rp/1hZXIJk",str) != 0)
X		printf("fast crypt error, %x should be yA1Rp/1hZXIJk\n",str);
X	printf("\n");
X	exit(0);
X	}
X
Xchar *pt(p)
Xunsigned char *p;
X	{
X	char *ret;
X	int i;
X	static char *f="0123456789ABCDEF";
X
X	ret=(char *)malloc(17);
X	for (i=0; i<8; i++)
X		{
X		ret[i*2]=f[(p[i]>>4)&0xf];
X		ret[i*2+1]=f[p[i]&0xf];
X		}
X	ret[16]='\0';
X	return(ret);
X	}
X	
END_OF_FILE
  if test 12238 -ne `wc -c <'destest.c'`; then
    echo shar: \"'destest.c'\" unpacked with wrong size!
  fi
  # end of 'destest.c'
fi
if test -f 'speed.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'speed.c'\"
else
  echo shar: Extracting \"'speed.c'\" \(4296 characters\)
  sed "s/^X//" >'speed.c' <<'END_OF_FILE'
X/* speed.c */
X/* Copyright (C) 1993 Eric Young - see README for more details */
X/* 11-Sep-92 Andrew Daviel   Support for Silicon Graphics IRIX added */
X/* 06-Apr-92 Luke Brennan    Support for VMS and add extra signal calls */
X
X#ifndef MSDOS
X#define TIMES
X#endif
X
X#include <stdio.h>
X#include <signal.h>
X#ifndef VMS
X#ifndef _IRIX
X#include <time.h>
X#endif
X#ifdef TIMES
X#include <sys/types.h>
X#include <sys/times.h>
X#endif /* TIMES */
X#else /* VMS */
X#include <types.h>
Xstruct tms {
X	time_t tms_utime;
X	time_t tms_stime;
X	time_t tms_uchild;	/* I dunno...  */
X	time_t tms_uchildsys;	/* so these names are a guess :-) */
X	}
X#endif
X#ifndef TIMES
X#include <sys/timeb.h>
X#endif
X#include "des.h"
X
X/* The following if from times(3) man page.  It may need to be changed */
X#ifndef CLK_TCK
X#ifndef VMS
X#define HZ	60.0
X#else /* VMS */
X#define HZ	100.0
X#endif
X#else /* CLK_TCK */
X#define HZ ((double)CLK_TCK)
X#endif
X
X#define BUFSIZE	((long)1024*8)
Xlong run=0;
X
X#ifdef SIGALRM
X#ifdef __STDC__
X#define SIGRETTYPE void
X#else
X#define SIGRETTYPE int
X#endif 
X
XSIGRETTYPE sig_done(sig)
Xint sig;
X	{
X	signal(SIGALRM,sig_done);
X	run=0;
X	}
X#endif
X
X#define START	0
X#define STOP	1
X
Xdouble Time_F(s)
Xint s;
X	{
X	double ret;
X#ifdef TIMES
X	static struct tms tstart,tend;
X
X	if (s == START)
X		{
X		times(&tstart);
X		return(0);
X		}
X	else
X		{
X		times(&tend);
X		ret=((double)(tend.tms_utime-tstart.tms_utime))/HZ;
X		return((ret == 0.0)?1e-6:ret);
X		}
X#else /* !times() */
X	static struct timeb tstart,tend;
X	long i;
X
X	if (s == START)
X		{
X		ftime(&tstart);
X		return(0);
X		}
X	else
X		{
X		ftime(&tend);
X		i=(long)tend.millitm-(long)tstart.millitm;
X		ret=((double)(tend.time-tstart.time))+((double)i)/1000.0;
X		return((ret == 0.0)?1e-6:ret);
X		}
X#endif
X	}
X
Xmain(argc,argv)
Xint argc;
Xchar *argv[];
X	{
X	long count;
X	static unsigned char buf[BUFSIZE];
X	static des_cblock key={0x12,0x34,0x56,0x78,0x9a,0xbc,0xde,0xf0};
X	des_key_schedule sch;
X	double d,a,b,c;
X	long ca,cb,cc,cd;
X
X#ifndef TIMES
X	printf("To get the most acurate results, try to run this\n");
X	printf("program when this computer is idle.\n");
X#endif
X
X#ifndef SIGALRM
X	printf("First we calculate the aproximate speed ...\n");
X	des_set_key((C_Block *)key,sch);
X	count=10;
X	do	{
X		int i;
X		count*=2;
X		Time_F(START);
X		for (i=count; i; i--)
X			des_ecb_encrypt((C_Block *)buf,(C_Block *)buf,
X				&(sch[0]),DES_ENCRYPT);
X		d=Time_F(STOP);
X		} while (d <3);
X	ca=count;
X	cb=count*10;
X	cc=count*10*8/BUFSIZE+1;
X	cd=count/20+1;
X	printf("Doing set_key %ld times\n",ca);
X#define COND(d)	(count != (d))
X#define COUNT(d) (d)
X#else
X#define COND(c)	(run)
X#define COUNT(d) (count)
X	signal(SIGALRM,sig_done);
X	printf("Doing set_key for 10 seconds\n");
X	alarm(10);
X#endif
X
X	Time_F(START);
X	for (count=0,run=1; COND(ca); count++)
X		des_set_key((C_Block *)key,sch);
X	d=Time_F(STOP);
X	printf("%ld set_key's in %.2f seconds\n",count,d);
X	a=((double)COUNT(ca))/d;
X
X#ifdef SIGALRM
X	printf("Doing des_ecb_encrypt's for 10 seconds\n");
X	alarm(10);
X#else
X	printf("Doing des_ecb_encrypt %ld times\n",cb);
X#endif
X	Time_F(START);
X	for (count=0,run=1; COND(cb); count++)
X		des_ecb_encrypt((C_Block *)buf,(C_Block *)buf,
X			&(sch[0]),DES_ENCRYPT);
X	d=Time_F(STOP);
X	printf("%ld des_ecb_encrypt's in %.2f second\n",count,d);
X	b=((double)COUNT(cb)*8)/d;
X
X#ifdef SIGALRM
X	printf("Doing des_cbc_encrypt on %ld byte blocks for 10 seconds\n",
X		BUFSIZE);
X	alarm(10);
X#else
X	printf("Doing des_cbc_encrypt %ld times on %ld byte blocks\n",cc,
X		BUFSIZE);
X#endif
X	Time_F(START);
X	for (count=0,run=1; COND(cc); count++)
X		des_cbc_encrypt((C_Block *)buf,(C_Block *)buf,BUFSIZE,&(sch[0]),
X			(C_Block *)&(key[0]),DES_ENCRYPT);
X	d=Time_F(STOP);
X	printf("%ld des_cbc_encrypt's of %ld byte blocks in %.2f second\n",
X		count,BUFSIZE,d);
X	c=((double)COUNT(cc)*BUFSIZE)/d;
X
X#ifdef SIGALRM
X	printf("Doing crypt for 10 seconds\n");
X	alarm(10);
X#else
X	printf("Doing crypt %ld times\n",cd);
X#endif
X	Time_F(START);
X	for (count=0,run=1; COND(cd); count++)
X		crypt("testing1","ef");
X	d=Time_F(STOP);
X	printf("%ld crypts in %.2f second\n",count,d);
X	d=((double)COUNT(cd))/d;
X
X	printf("set_key       per sec = %12.2f (%5.1fuS)\n",a,1.0e6/a);
X	printf("DES ecb bytes per sec = %12.2f (%5.1fuS)\n",b,8.0e6/b);
X	printf("DES cbc bytes per sec = %12.2f (%5.1fuS)\n",c,8.0e6/c);
X	printf("crypt         per sec = %12.2f (%5.1fuS)\n",d,1.0e6/d);
X	}
END_OF_FILE
  if test 4296 -ne `wc -c <'speed.c'`; then
    echo shar: \"'speed.c'\" unpacked with wrong size!
  fi
  # end of 'speed.c'
fi
if test -f 'rpw.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'rpw.c'\"
else
  echo shar: Extracting \"'rpw.c'\" \(728 characters\)
  sed "s/^X//" >'rpw.c' <<'END_OF_FILE'
X/* rpw.c */
X/* Copyright (C) 1993 Eric Young - see README for more details */
X#include <stdio.h>
X#include "des.h"
X
Xmain()
X	{
X	des_cblock k,k1;
X	int i;
X
X	printf("read passwd\n");
X	if ((i=des_read_password((C_Block *)k,"Enter password:",0)) == 0)
X		{
X		printf("password = ");
X		for (i=0; i<8; i++)
X			printf("%02x ",k[i]);
X		}
X	else
X		printf("error %d\n",i);
X	printf("\n");
X	printf("read 2passwds and verify\n");
X	if ((i=des_read_2passwords((C_Block *)k,(C_Block *)k1,
X		"Enter verified password:",1)) == 0)
X		{
X		printf("password1 = ");
X		for (i=0; i<8; i++)
X			printf("%02x ",k[i]);
X		printf("\n");
X		printf("password2 = ");
X		for (i=0; i<8; i++)
X			printf("%02x ",k1[i]);
X		printf("\n");
X		}
X	else
X		printf("error %d\n",i);
X	}
END_OF_FILE
  if test 728 -ne `wc -c <'rpw.c'`; then
    echo shar: \"'rpw.c'\" unpacked with wrong size!
  fi
  # end of 'rpw.c'
fi
if test -f 'des_crypt.man' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'des_crypt.man'\"
else
  echo shar: Extracting \"'des_crypt.man'\" \(12459 characters\)
  sed "s/^X//" >'des_crypt.man' <<'END_OF_FILE'
X.TH DES_CRYPT 3 
X.SH NAME
Xdes_read_password, des_read_2password,
Xdes_string_to_key, des_string_to_2key, des_read_pw_string,
Xdes_random_key, des_set_key,
Xdes_key_sched, des_ecb_encrypt, des_3ecb_encrypt, des_cbc_encrypt,
Xdes_3cbc_encrypt,
Xdes_pcbc_encrypt, des_cfb_encrypt, des_ofb_encrypt,
Xdes_cbc_cksum, des_quad_cksum,
Xdes_enc_read, des_enc_write, des_set_odd_parity,
Xdes_is_weak_key, crypt \- (non USA) DES encryption
X.SH SYNOPSIS
X.nf
X.nj
X.ft B
X#include <des.h>
X.PP
X.B int des_read_password(key,prompt,verify)
Xdes_cblock *key;
Xchar *prompt;
Xint verify;
X.PP
X.B int des_read_2password(key1,key2,prompt,verify)
Xdes_cblock *key1,*key2;
Xchar *prompt;
Xint verify;
X.PP
X.B int des_string_to_key(str,key)
Xchar *str;
Xdes_cblock *key;
X.PP
X.B int des_string_to_2keys(str,key1,key2)
Xchar *str;
Xdes_cblock *key1,*key2;
X.PP
X.B int des_read_pw_string(buf,length,prompt,verify)
Xchar *buf;
Xint length;
Xchar *prompt;
Xint verify;
X.PP
X.B int des_random_key(key)
Xdes_cblock *key;
X.PP
X.B int des_set_key(key,schedule)
Xdes_cblock *key;
Xdes_key_schedule schedule;
X.PP
X.B int des_key_sched(key,schedule)
Xdes_cblock *key;
Xdes_key_schedule schedule;
X.PP
X.B int des_ecb_encrypt(input,output,schedule,encrypt)
Xdes_cblock *input;
Xdes_cblock *output;
Xdes_key_schedule schedule;
Xint encrypt;
X.PP
X.B int des_3ecb_encrypt(input,output,ks1,ks2,encrypt)
Xdes_cblock *input;
Xdes_cblock *output;
Xdes_key_schedule ks1,ks2;
Xint encrypt;
X.PP
X.B int des_cbc_encrypt(input,output,length,schedule,ivec,encrypt)
Xdes_cblock *input;
Xdes_cblock *output;
Xlong length;
Xdes_key_schedule schedule;
Xdes_cblock *ivec;
Xint encrypt;
X.PP
X.B int des_3cbc_encrypt(input,output,length,sk1,sk2,ivec1,ivec2,encrypt)
Xdes_cblock *input;
Xdes_cblock *output;
Xlong length;
Xdes_key_schedule sk1;
Xdes_key_schedule sk2;
Xdes_cblock *ivec1;
Xdes_cblock *ivec2;
Xint encrypt;
X.PP
X.B int des_pcbc_encrypt(input,output,length,schedule,ivec,encrypt)
Xdes_cblock *input;
Xdes_cblock *output;
Xlong length;
Xdes_key_schedule schedule;
Xdes_cblock *ivec;
Xint encrypt;
X.PP
X.B int des_cfb_encrypt(input,output,numbits,length,schedule,ivec,encrypt)
Xunsigned char *input;
Xunsigned char *output;
Xint numbits;
Xlong length;
Xdes_key_schedule schedule;
Xdes_cblock *ivec;
Xint encrypt;
X.PP
X.B int des_ofb_encrypt(input,output,numbits,length,schedule,ivec)
Xunsigned char *input,*output;
Xint numbits;
Xlong length;
Xdes_key_schedule schedule;
Xdes_cblock *ivec;
X.PP
X.B unsigned long des_cbc_cksum(input,output,length,schedule,ivec)
Xdes_cblock *input;
Xdes_cblock *output;
Xlong length;
Xdes_key_schedule schedule;
Xdes_cblock *ivec;
X.PP
X.B unsigned long des_quad_cksum(input,output,length,out_count,seed)
Xdes_cblock *input;
Xdes_cblock *output;
Xlong length;
Xint out_count;
Xdes_cblock *seed;
X.PP
X.B int des_check_key;
X.PP
X.B int des_enc_read(fd,buf,len,sched,iv)
Xint fd;
Xchar *buf;
Xint len;
Xdes_key_schedule sched;
Xdes_cblock *iv;
X.PP
X.B int des_enc_write(fd,buf,len,sched,iv)
Xint fd;
Xchar *buf;
Xint len;
Xdes_key_schedule sched;
Xdes_cblock *iv;
X.PP
X.B extern int des_rw_mode;
X.PP
X.B void des_set_odd_parity(key)
Xdes_cblock *key;
X.PP
X.B int des_is_weak_key(key)
Xdes_cblock *key;
X.PP
X.B char *crypt(passwd,salt)
Xchar *passwd;
Xchar *salt;
X.PP
X.fi
X.SH DESCRIPTION
XThis library contains a fast implementation of the DES encryption
Xalgorithm.
X.PP
XThere are two phases to the use of DES encryption.
XThe first is the generation of a
X.I des_key_schedule
Xfrom a key,
Xthe second is the actual encryption.
XA des key is of type
X.I des_cblock.
XThis type is made from 8 characters with odd parity.
XThe least significant bit in the character is the parity bit.
XThe key schedule is an expanded form of the key; it is used to speed the
Xencryption process.
X.PP
X.I des_read_password
Xwrites the string specified by prompt to the standard output,
Xturns off echo and reads an input string from standard input
Xuntil terminated with a newline.
XIf verify is non-zero, it prompts and reads the input again and verifies
Xthat both entered passwords are the same.
XThe entered string is converted into a des key by using the
X.I des_string_to_key
Xroutine.
XThe new key is placed in the
X.I des_cblock
Xthat was passed (by reference) to the routine.
XIf there were no errors,
X.I des_read_password
Xreturns 0,
X-1 is returned if there was a terminal error and 1 is returned for
Xany other error.
X.PP
X.I des_read_2password
Xoperates in the same way as
X.I des_read_password
Xexcept that it generates 2 keys by using the
X.I des_string_to_2key
Xfunction.
X.PP
X.I des_read_pw_string
Xis called by
X.I des_read_password
Xto read and verify a string from a terminal device.
XThe string is returned in
X.I buf.
XThe size of
X.I buf
Xis passed to the routine via the
X.I length
Xparameter.
X.PP
X.I des_string_to_key
Xconverts a string into a valid des key.
X.PP
X.I des_string_to_2key
Xconverts a string into 2 valid des keys.
XThis routine is best suited for used to generate keys for use with
X.I des_3ecb_encrypt.
X.PP
X.I des_random_key
Xreturns a random key that is made of a combination of process id,
Xtime and an increasing counter.
X.PP
XBefore a des key can be used it is converted into a
X.I des_key_schedule
Xvia the
X.I des_set_key
Xroutine.
XIf the
X.I des_check_key
Xflag is non-zero,
X.I des_set_key
Xwill check that the key passed is of odd parity and is not a week or
Xsemi-weak key.
XIf the parity is wrong,
Xthen -1 is returned.
XIf the key is a weak key,
Xthen -2 is returned.
XIf an error is returned,
Xthe key schedule is not generated.
X.PP
X.I des_key_sched
Xis another name for the
X.I des_set_key
Xfunction.
X.PP
XThe following routines mostly operate on an input and output stream of
X.I des_cblock's.
X.PP
X.I des_ecb_encrypt
Xis the basic DES encryption routine that encrypts or decrypts a single 8-byte
X.I des_cblock
Xin
X.I electronic code book
Xmode.
XIt always transforms the input data, pointed to by
X.I input,
Xinto the output data,
Xpointed to by the
X.I output
Xargument.
XIf the
X.I encrypt
Xargument is non-zero (DES_ENCRYPT),
Xthe
X.I input
X(cleartext) is encrypted in to the
X.I output
X(ciphertext) using the key_schedule specified by the
X.I schedule
Xargument,
Xpreviously set via
X.I des_set_key.
XIf
X.I encrypt
Xis zero (DES_DECRYPT),
Xthe
X.I input
X(now ciphertext)
Xis decrypted into the
X.I output
X(now cleartext).
XInput and output may overlap.
XNo meaningful value is returned.
X.PP
X.I des_3ecb_encrypt
Xencrypts/decrypts the
X.I input
Xblock by using triple ecb DES encryption.
XThis involves encrypting the input with 
X.I ks1,
Xdecryption with the key schedule
X.I ks2,
Xand then encryption with the first again.
XThis routine greatly reduces the chances of brute force breaking of
XDES and has the advantage of if
X.I ks1
Xand
X.I ks2
Xare the same, it is equivalent to just encryption using ecb mode and
X.I ks1
Xas the key.
X.PP
X.I des_cbc_encrypt
Xencrypts/decrypts using the
X.I cipher-block-chaining
Xmode of DES.
XIf the
X.I encrypt
Xargument is non-zero,
Xthe routine cipher-block-chain encrypts the cleartext data pointed to by the
X.I input
Xargument into the ciphertext pointed to by the
X.I output
Xargument,
Xusing the key schedule provided by the
X.I schedule
Xargument,
Xand initialisation vector provided by the
X.I ivec
Xargument.
XIf the
X.I length
Xargument is not an integral multiple of eight bytes, 
Xthe last block is copied to a temporary area and zero filled.
XThe output is always
Xan integral multiple of eight bytes.
XTo make multiple cbc encrypt calls on a large amount of data appear to
Xbe one 
X.I des_cbc_encrypt
Xcall, the
X.I ivec
Xof subsequent calls should be the last 8 bytes of the output.
X.PP
X.I des_3cbc_encrypt
Xencrypts/decrypts the
X.I input
Xblock by using triple cbc DES encryption.
XThis involves encrypting the input with key schedule
X.I ks1,
Xdecryption with the key schedule
X.I ks2,
Xand then encryption with the first again.
X2 initialisation vectors are required,
X.I ivec1
Xand
X.I ivec2.
XUnlike
X.I des_cbc_encrypt,
Xthese initialisation vectors are modified by the subroutine.
XThis routine greatly reduces the chances of brute force breaking of
XDES and has the advantage of if
X.I ks1
Xand
X.I ks2
Xare the same, it is equivalent to just encryption using cbc mode and
X.I ks1
Xas the key.
X.PP
X.I des_pcbc_encrypt
Xencrypt/decrypts using a modified block chaining mode.
XIt provides better error propagation characteristics than cbc
Xencryption.
X.PP
X.I des_cfb_encrypt
Xencrypt/decrypts using cipher feedback mode.  This method takes an
Xarray of characters as input and outputs and array of characters.  It
Xdoes not require any padding to 8 character groups.  Note: the ivec
Xvariable is changed and the new changed value needs to be passed to
Xthe next call to this function.  Since this function runs a complete
XDES ecb encryption per numbits, this function is only suggested for
Xuse when sending small numbers of characters.
X.PP
X.I des_ofb_encrypt
Xencrypt using output feedback mode.  This method takes an
Xarray of characters as input and outputs and array of characters.  It
Xdoes not require any padding to 8 character groups.  Note: the ivec
Xvariable is changed and the new changed value needs to be passed to
Xthe next call to this function.  Since this function runs a complete
XDES ecb encryption per numbits, this function is only suggested for
Xuse when sending small numbers of characters.
X.PP
X.I des_cbc_cksum
Xproduces an 8 byte checksum based on the input stream (via cbc encryption).
XThe last 4 bytes of the checksum is returned and the complete 8 bytes is
Xplaced in
X.I output.
X.PP
X.I des_quad_cksum
Xreturns a 4 byte checksum from the input bytes.
XThe algorithm can be iterated over the input,
Xdepending on
X.I out_count,
X1, 2, 3 or 4 times.
XIf
X.I output
Xis non-NULL,
Xthe 8 bytes generated by each pass are written into
X.I output.
X.PP
X.I des_enc_write
Xis used to write
X.I len
Xbytes
Xto file descriptor
X.I fd
Xfrom buffer
X.I buf.
XThe data is encrypted via
X.I pcbc_encrypt
X(default) using
X.I sched
Xfor the key and
X.I iv
Xas a starting vector.
XThe actual data send down
X.I fd
Xconsists of 4 bytes (in network byte order) containing the length of the
Xfollowing encrypted data.  The encrypted data then follows, padded with random
Xdata out to a multiple of 8 bytes.
X.PP
X.I des_enc_read
Xis used to read
X.I len
Xbytes
Xfrom file descriptor
X.I fd
Xinto buffer
X.I buf.
XThe data being read from
X.I fd
Xis assumed to have come from
X.I des_enc_write
Xand is decrypted using
X.I sched
Xfor the key schedule and
X.I iv
Xfor the initial vector.
XThe
X.I des_enc_read/des_enc_write
Xpair can be used to read/write to files, pipes and sockets.
XI have used them in implementing a version of rlogin in which all
Xdata is encrypted.
X.PP
X.I des_rw_mode
Xis used to specify the encryption mode to use with 
X.I des_enc_read
Xand 
X.I des_end_write.
XIf set to
X.I DES_PCBC_MODE
X(the default), des_pcbc_encrypt is used.
XIf set to
X.I DES_CBC_MODE
Xdes_cbc_encrypt is used.
XThese two routines and the variable are not part of the normal MIT library.
X.PP
X.I des_set_odd_parity
Xsets the parity of the passed
X.I key
Xto odd.  This routine is not part of the standard MIT library.
X.PP
X.I des_is_weak_key
Xreturns 1 is the passed key is a weak key (pick again :-),
X0 if it is ok.
XThis routine is not part of the standard MIT library.
X.PP
X.I crypt
Xis a replacement for the normal system crypt.
XIt is much faster than the system crypt.
X.PP
X.SH FILES
X/usr/include/des.h
X.br
X/usr/lib/libdes.a
X.PP
XThe encryption routines have been tested on 16bit, 32bit and 64bit
Xmachines of various endian and even works under VMS.
X.PP
X.SH BUGS
X.PP
XIf you think this manual is sparse,
Xread the des_crypt(3) manual from the MIT kerberos (or bones outside
Xof the USA) distribution.
X.PP
X.I des_cfb_encrypt
Xand
X.I des_ofb_encrypt
Xoperates on input of 8 bits.  What this means is that if you set
Xnumbits to 12, and length to 2, the first 12 bits will come from the 1st
Xinput byte and the low half of the second input byte.  The second 12
Xbits will have the low 8 bits taken from the 3rd input byte and the
Xtop 4 bits taken from the 4th input byte.  The same holds for output.
XThis function has been implemented this way because most people will
Xbe using a multiple of 8 and because once you get into pulling bytes input
Xbytes apart things get ugly!
X.PP
X.I des_read_pw_string
Xis the most machine/OS dependent function and normally generates the
Xmost problems when porting this code.
X.PP
X.I des_string_to_key
Xis probably different from the MIT version since there are lots
Xof fun ways to implement one-way encryption of a text string.
X.PP
XThe routines are optimised for 32 bit machines and so are not efficient
Xon IBM PCs.
X.SH AUTHOR
XEric Young (eay@psych.psy.uq.oz.au),
XPsychology Department,
XUniversity of Queensland, Australia.
END_OF_FILE
  if test 12459 -ne `wc -c <'des_crypt.man'`; then
    echo shar: \"'des_crypt.man'\" unpacked with wrong size!
  fi
  # end of 'des_crypt.man'
fi
if test -f 'des.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'des.h'\"
else
  echo shar: Extracting \"'des.h'\" \(4074 characters\)
  sed "s/^X//" >'des.h' <<'END_OF_FILE'
X/* des.h */
X/* Copyright (C) 1993 Eric Young - see README for more details */
X#ifndef DES_DEFS
X#define DES_DEFS
X
Xtypedef unsigned char des_cblock[8];
Xtypedef struct des_ks_struct
X	{
X	union	{
X		des_cblock _;
X		/* make sure things are correct size on machines with
X		 * 8 byte longs */
X		unsigned long pad[2];
X		} ks;
X#define _	ks._
X	} des_key_schedule[16];
X
X#define DES_KEY_SZ 	(sizeof(des_cblock))
X#define DES_ENCRYPT	1
X#define DES_DECRYPT	0
X
X#define DES_CBC_MODE	0
X#define DES_PCBC_MODE	1
X
X#define C_Block des_cblock
X#define Key_schedule des_key_schedule
X#define ENCRYPT DES_ENCRYPT
X#define DECRYPT DES_DECRYPT
X#define KEY_SZ DES_KEY_SZ
X#define string_to_key des_string_to_key
X#define read_pw_string des_read_pw_string
X#define random_key des_random_key
X#define pcbc_encrypt des_pcbc_encrypt
X#define set_key des_set_key
X#define key_sched des_key_sched
X#define ecb_encrypt des_ecb_encrypt
X#define cbc_encrypt des_cbc_encrypt
X#define cbc_cksum des_cbc_cksum
X#define quad_cksum des_quad_cksum
X
X/* For compatibility with the MIT lib - eay 20/05/92 */
Xtypedef struct des_ks_struct bit_64;
X
Xextern int des_check_key;	/* defaults to false */
Xextern int des_rw_mode;		/* defaults to DES_PCBC_MODE */
X
X/* The next line is used to disable full ANSI prototypes, if your
X * compiler has problems with the prototypes, make sure this line always
X * evaluates to true :-) */
X#if !defined(MSDOS) && !defined(__STDC__)
X#ifndef KERBEROS
Xint des_3ecb_encrypt();
Xint des_cbc_encrypt();
Xint des_3cbc_encrypt();
Xint des_cfb_encrypt();
Xint des_ecb_encrypt();
Xint des_encrypt();
Xint des_enc_read();
Xint des_enc_write();
Xint des_ofb_encrypt();
Xint des_pcbc_encrypt();
Xint des_random_key();
Xint des_read_password();
Xint des_read_2passwords();
Xint des_read_pw_string();
Xint des_is_weak_key();
Xint des_set_key();
Xint des_key_sched();
Xint des_string_to_key();
Xint des_string_to_2keys();
X#endif
X/*
Xchar *crypt();
X*/
Xunsigned long des_cbc_cksum();
Xunsigned long des_quad_cksum();
Xunsigned long des_cbc_cksum();
Xvoid des_set_odd_parity();
X#else /* PROTO */
Xint des_3ecb_encrypt(des_cblock *input,des_cblock *output,\
X	des_key_schedule ks1,des_key_schedule ks2,int encrypt);
Xunsigned long des_cbc_cksum(des_cblock *input,des_cblock *output,\
X	long length,des_key_schedule schedule,des_cblock *ivec);
Xint des_cbc_encrypt(des_cblock *input,des_cblock *output,long length,\
X	des_key_schedule schedule,des_cblock *ivec,int encrypt);
Xint des_3cbc_encrypt(des_cblock *input,des_cblock *output,long length,\
X	des_key_schedule sk1,des_key_schedule sk2,\
X	des_cblock *ivec1,des_cblock *ivec2,int encrypt);
Xint des_cfb_encrypt(unsigned char *in,unsigned char *out,int numbits,\
X	long length,des_key_schedule schedule,des_cblock *ivec,int encrypt);
Xint des_ecb_encrypt(des_cblock *input,des_cblock *output,\
X	des_key_schedule ks,int encrypt);
Xint des_encrypt(unsigned long *input,unsigned long *output,
X	des_key_schedule ks, int encrypt);
Xint des_enc_read(int fd,char *buf,int len,des_key_schedule sched,\
X	des_cblock *iv);
Xint des_enc_write(int fd,char *buf,int len,des_key_schedule sched,\
X	des_cblock *iv);
X/*
Xchar *crypt(char *buf,char *salt);
X*/
Xint des_ofb_encrypt(unsigned char *in,unsigned char *out,\
X	int numbits,long length,des_key_schedule schedule,des_cblock *ivec);
Xint des_pcbc_encrypt(des_cblock *input,des_cblock *output,long length,\
X	des_key_schedule schedule,des_cblock *ivec,int encrypt);
Xunsigned long des_quad_cksum(des_cblock *input,des_cblock *output,\
X	long length,int out_count,des_cblock *seed);
Xint des_random_key(des_cblock ret);
Xint des_read_password(des_cblock *key,char *prompt,int verify);
Xint des_read_2passwords(des_cblock *key1,des_cblock *key2, \
X	char *prompt,int verify);
Xint des_read_pw_string(char *buf,int length,char *prompt,int verify);
Xvoid des_set_odd_parity(des_cblock *key);
Xint des_is_weak_key(des_cblock *key);
Xint des_set_key(des_cblock *key,des_key_schedule schedule);
Xint des_key_sched(des_cblock *key,des_key_schedule schedule);
Xint des_string_to_key(char *str,des_cblock *key);
Xint des_string_to_2keys(char *str,des_cblock *key1,des_cblock *key2);
X#endif
X#endif
END_OF_FILE
  if test 4074 -ne `wc -c <'des.h'`; then
    echo shar: \"'des.h'\" unpacked with wrong size!
  fi
  # end of 'des.h'
fi
if test -f 'cbc_cksm.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'cbc_cksm.c'\"
else
  echo shar: Extracting \"'cbc_cksm.c'\" \(1002 characters\)
  sed "s/^X//" >'cbc_cksm.c' <<'END_OF_FILE'
X/* cbc_cksm.c */
X/* Copyright (C) 1993 Eric Young - see README for more details */
X#include "des_locl.h"
X
Xunsigned long des_cbc_cksum(input,output,length,schedule,ivec)
Xdes_cblock *input;
Xdes_cblock *output;
Xlong length;
Xdes_key_schedule schedule;
Xdes_cblock *ivec;
X	{
X	register unsigned long tout0,tout1,tin0,tin1;
X	register long l=length;
X	unsigned long tin[2],tout[2];
X	unsigned char *in,*out,*iv;
X
X	in=(unsigned char *)input;
X	out=(unsigned char *)output;
X	iv=(unsigned char *)ivec;
X
X	c2l(iv,tout0);
X	c2l(iv,tout1);
X	for (; l>0; l-=8)
X		{
X		if (l >= 8)
X			{
X			c2l(in,tin0);
X			c2l(in,tin1);
X			}
X		else
X			c2ln(in,tin0,tin1,l);
X			
X		tin0^=tout0;
X		tin1^=tout1;
X		tin[0]=tin0;
X		tin[1]=tin1;
X		des_encrypt((unsigned long *)tin,(unsigned long *)tout,
X			schedule,DES_ENCRYPT);
X		/* fix 15/10/91 eay - thanks to keithr@sco.COM */
X		tout0=tout[0];
X		tout1=tout[1];
X		}
X	if (out != NULL)
X		{
X		l2c(tout0,out);
X		l2c(tout1,out);
X		}
X	tout0=tin0=tin1=tin[0]=tin[1]=tout[0]=tout[1]=0;
X	return(tout1);
X	}
END_OF_FILE
  if test 1002 -ne `wc -c <'cbc_cksm.c'`; then
    echo shar: \"'cbc_cksm.c'\" unpacked with wrong size!
  fi
  # end of 'cbc_cksm.c'
fi
if test -f 'cbc_enc.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'cbc_enc.c'\"
else
  echo shar: Extracting \"'cbc_enc.c'\" \(1451 characters\)
  sed "s/^X//" >'cbc_enc.c' <<'END_OF_FILE'
X/* cbc_enc.c */
X/* Copyright (C) 1993 Eric Young - see README for more details */
X#include "des_locl.h"
X
Xint des_cbc_encrypt(input,output,length,schedule,ivec,encrypt)
Xdes_cblock *input;
Xdes_cblock *output;
Xlong length;
Xdes_key_schedule schedule;
Xdes_cblock *ivec;
Xint encrypt;
X	{
X	register unsigned long tin0,tin1;
X	register unsigned long tout0,tout1,xor0,xor1;
X	register unsigned char *in,*out;
X	register long l=length;
X	unsigned long tout[2],tin[2];
X	unsigned char *iv;
X
X	in=(unsigned char *)input;
X	out=(unsigned char *)output;
X	iv=(unsigned char *)ivec;
X
X	if (encrypt)
X		{
X		c2l(iv,tout0);
X		c2l(iv,tout1);
X		for (; l>0; l-=8)
X			{
X			if (l >= 8)
X				{
X				c2l(in,tin0);
X				c2l(in,tin1);
X				}
X			else
X				c2ln(in,tin0,tin1,l);
X			tin0^=tout0;
X			tin1^=tout1;
X			tin[0]=tin0;
X			tin[1]=tin1;
X			des_encrypt((unsigned long *)tin,(unsigned long *)tout,
X				schedule,encrypt);
X			tout0=tout[0];
X			tout1=tout[1];
X			l2c(tout0,out);
X			l2c(tout1,out);
X			}
X		}
X	else
X		{
X		c2l(iv,xor0);
X		c2l(iv,xor1);
X		for (; l>0; l-=8)
X			{
X			c2l(in,tin0);
X			c2l(in,tin1);
X			tin[0]=tin0;
X			tin[1]=tin1;
X			des_encrypt((unsigned long *)tin,(unsigned long *)tout,
X				schedule,encrypt);
X			tout0=tout[0]^xor0;
X			tout1=tout[1]^xor1;
X			if (l >= 8)
X				{
X				l2c(tout0,out);
X				l2c(tout1,out);
X				}
X			else
X				l2cn(tout0,tout1,out,l);
X			xor0=tin0;
X			xor1=tin1;
X			}
X		}
X	tin0=tin1=tout0=tout1=xor0=xor1=0;
X	tin[0]=tin[1]=tout[0]=tout[1]=0;
X	return(0);
X	}
X
END_OF_FILE
  if test 1451 -ne `wc -c <'cbc_enc.c'`; then
    echo shar: \"'cbc_enc.c'\" unpacked with wrong size!
  fi
  # end of 'cbc_enc.c'
fi
if test -f 'ecb_enc.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'ecb_enc.c'\"
else
  echo shar: Extracting \"'ecb_enc.c'\" \(2525 characters\)
  sed "s/^X//" >'ecb_enc.c' <<'END_OF_FILE'
X/* ecb_enc.c */
X/* Copyright (C) 1993 Eric Young - see README for more details */
X#include "des_locl.h"
X#include "spr.h"
X
Xint des_ecb_encrypt(input,output,ks,encrypt)
Xdes_cblock *input;
Xdes_cblock *output;
Xdes_key_schedule ks;
Xint encrypt;
X	{
X	register unsigned long l0,l1;
X	register unsigned char *in,*out;
X	unsigned long ll[2];
X
X	in=(unsigned char *)input;
X	out=(unsigned char *)output;
X	c2l(in,l0);
X	c2l(in,l1);
X	ll[0]=l0;
X	ll[1]=l1;
X	des_encrypt(ll,ll,ks,encrypt);
X	l0=ll[0];
X	l1=ll[1];
X	l2c(l0,out);
X	l2c(l1,out);
X	l0=l1=ll[0]=ll[1]=0;
X	return(0);
X	}
X
Xint des_encrypt(input,output,ks,encrypt)
Xunsigned long *input;
Xunsigned long *output;
Xdes_key_schedule ks;
Xint encrypt;
X	{
X	register unsigned long l,r,t,u;
X#ifdef ALT_ECB
X	register unsigned char *des_SP=(unsigned char *)des_SPtrans;
X#endif
X#ifdef MSDOS
X	union fudge {
X		unsigned long  l;
X		unsigned short s[2];
X		unsigned char  c[4];
X		} U,T;
X#endif
X	register int i;
X	register unsigned long *s;
X
X	l=input[0];
X	r=input[1];
X
X	/* do IP */
X	PERM_OP(r,l,t, 4,0x0f0f0f0f);
X	PERM_OP(l,r,t,16,0x0000ffff);
X	PERM_OP(r,l,t, 2,0x33333333);
X	PERM_OP(l,r,t, 8,0x00ff00ff);
X	PERM_OP(r,l,t, 1,0x55555555);
X	/* r and l are reversed - remember that :-) - fix
X	 * it in the next step */
X
X	/* Things have been modified so that the initial rotate is
X	 * done outside the loop.  This required the
X	 * des_SPtrans values in sp.h to be rotated 1 bit to the right.
X	 * One perl script later and things have a 5% speed up on a sparc2.
X	 * Thanks to Richard Outerbridge <71755.204@CompuServe.COM>
X	 * for pointing this out. */
X	t=(r<<1)|(r>>31);
X	r=(l<<1)|(l>>31);
X	l=t;
X
X	/* clear the top bits on machines with 8byte longs */
X	l&=0xffffffff;
X	r&=0xffffffff;
X
X	s=(unsigned long *)ks;
X	/* I don't know if it is worth the effort of loop unrolling the
X	 * inner loop */
X	if (encrypt)
X		{
X		for (i=0; i<32; i+=4)
X			{
X			D_ENCRYPT(l,r,i+0); /*  1 */
X			D_ENCRYPT(r,l,i+2); /*  2 */
X			}
X		}
X	else
X		{
X		for (i=30; i>0; i-=4)
X			{
X			D_ENCRYPT(l,r,i-0); /* 16 */
X			D_ENCRYPT(r,l,i-2); /* 15 */
X			}
X		}
X	l=(l>>1)|(l<<31);
X	r=(r>>1)|(r<<31);
X	/* clear the top bits on machines with 8byte longs */
X	l&=0xffffffff;
X	r&=0xffffffff;
X
X	/* swap l and r
X	 * we will not do the swap so just remember they are
X	 * reversed for the rest of the subroutine
X	 * luckily FP fixes this problem :-) */
X
X	PERM_OP(r,l,t, 1,0x55555555);
X	PERM_OP(l,r,t, 8,0x00ff00ff);
X	PERM_OP(r,l,t, 2,0x33333333);
X	PERM_OP(l,r,t,16,0x0000ffff);
X	PERM_OP(r,l,t, 4,0x0f0f0f0f);
X
X	output[0]=l;
X	output[1]=r;
X	l=r=t=u=0;
X	return(0);
X	}
X
END_OF_FILE
  if test 2525 -ne `wc -c <'ecb_enc.c'`; then
    echo shar: \"'ecb_enc.c'\" unpacked with wrong size!
  fi
  # end of 'ecb_enc.c'
fi
if test -f 'enc_read.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'enc_read.c'\"
else
  echo shar: Extracting \"'enc_read.c'\" \(3343 characters\)
  sed "s/^X//" >'enc_read.c' <<'END_OF_FILE'
X/* enc_read.c */
X/* Copyright (C) 1993 Eric Young - see README for more details */
X#include <errno.h>
X#include "des_locl.h"
X
X/* This has some uglies in it but it works - even over sockets. */
Xextern int errno;
Xint des_rw_mode=DES_PCBC_MODE;
X
Xint des_enc_read(fd,buf,len,sched,iv)
Xint fd;
Xchar *buf;
Xint len;
Xdes_key_schedule sched;
Xdes_cblock *iv;
X	{
X	/* data to be unencrypted */
X	int net_num=0;
X	unsigned char net[BSIZE];
X	/* extra unencrypted data 
X	 * for when a block of 100 comes in but is des_read one byte at
X	 * a time. */
X	static char unnet[BSIZE];
X	static int unnet_start=0;
X	static int unnet_left=0;
X	int i;
X	long num=0,rnum;
X	unsigned char *p;
X
X	/* left over data from last decrypt */
X	if (unnet_left != 0)
X		{
X		if (unnet_left < len)
X			{
X			/* we still still need more data but will return
X			 * with the number of bytes we have - should always
X			 * check the return value */
X			bcopy(&(unnet[unnet_start]),buf,unnet_left);
X			/* eay 26/08/92 I had the next 2 lines
X			 * reversed :-( */
X			i=unnet_left;
X			unnet_start=unnet_left=0;
X			}
X		else
X			{
X			bcopy(&(unnet[unnet_start]),buf,len);
X			unnet_start+=len;
X			unnet_left-=len;
X			i=len;
X			}
X		return(i);
X		}
X
X	/* We need to get more data. */
X	if (len > MAXWRITE) len=MAXWRITE;
X
X	/* first - get the length */
X	net_num=0;
X	while (net_num < HDRSIZE) 
X		{
X		i=read(fd,&(net[net_num]),HDRSIZE-net_num);
X		if ((i == -1) && (errno == EINTR)) continue;
X		if (i <= 0) return(0);
X		net_num+=i;
X		}
X
X	/* we now have at net_num bytes in net */
X	p=net;
X	num=0;
X	n2l(p,num);
X	/* num should be rounded up to the next group of eight
X	 * we make sure that we have read a multiple of 8 bytes from the net.
X	 */
X	if ((num > MAXWRITE) || (num < 0)) /* error */
X		return(-1);
X	rnum=(num < 8)?8:((num+7)/8*8);
X
X	net_num=0;
X	while (net_num < rnum)
X		{
X		i=read(fd,&(net[net_num]),rnum-net_num);
X		if ((i == -1) && (errno == EINTR)) continue;
X		if (i <= 0) return(0);
X		net_num+=i;
X		}
X
X	/* Check if there will be data left over. */
X	if (len < num)
X		{
X		if (des_rw_mode & DES_PCBC_MODE)
X			pcbc_encrypt((des_cblock *)net,(des_cblock *)unnet,
X				num,sched,iv,DES_DECRYPT);
X		else
X			cbc_encrypt((des_cblock *)net,(des_cblock *)unnet,
X				num,sched,iv,DES_DECRYPT);
X		bcopy(unnet,buf,len);
X		unnet_start=len;
X		unnet_left=num-len;
X
X		/* The following line is done because we return num
X		 * as the number of bytes read. */
X		num=len;
X		}
X	else
X		{
X		/* >output is a multiple of 8 byes, if len < rnum
X		 * >we must be careful.  The user must be aware that this
X		 * >routine will write more bytes than he asked for.
X		 * >The length of the buffer must be correct.
X		 * FIXED - Should be ok now 18-9-90 - eay */
X		if (len < rnum)
X			{
X			char tmpbuf[BSIZE];
X
X			if (des_rw_mode & DES_PCBC_MODE)
X				pcbc_encrypt((des_cblock *)net,
X					(des_cblock *)tmpbuf,
X					num,sched,iv,DES_DECRYPT);
X			else
X				cbc_encrypt((des_cblock *)net,
X					(des_cblock *)tmpbuf,
X					num,sched,iv,DES_DECRYPT);
X
X			/* eay 26/08/92 fix a bug that returned more
X			 * bytes than you asked for (returned len bytes :-( */
X			bcopy(tmpbuf,buf,num);
X			}
X		else
X			{
X			if (des_rw_mode & DES_PCBC_MODE)
X				pcbc_encrypt((des_cblock *)net,
X					(des_cblock *)buf,num,sched,iv,
X					DES_DECRYPT);
X			else
X				cbc_encrypt((des_cblock *)net,
X					(des_cblock *)buf,num,sched,iv,
X					DES_DECRYPT);
X			}
X		}
X	return(num);
X	}
X
END_OF_FILE
  if test 3343 -ne `wc -c <'enc_read.c'`; then
    echo shar: \"'enc_read.c'\" unpacked with wrong size!
  fi
  # end of 'enc_read.c'
fi
if test -f 'enc_writ.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'enc_writ.c'\"
else
  echo shar: Extracting \"'enc_writ.c'\" \(1718 characters\)
  sed "s/^X//" >'enc_writ.c' <<'END_OF_FILE'
X/* enc_writ.c */
X/* Copyright (C) 1993 Eric Young - see README for more details */
X#include <errno.h>
X#include "des_locl.h"
X
Xint des_enc_write(fd,buf,len,sched,iv)
Xint fd;
Xchar *buf;
Xint len;
Xdes_key_schedule sched;
Xdes_cblock *iv;
X	{
X	long rnum;
X	int i,j,k,outnum;
X	char outbuf[BSIZE+HDRSIZE];
X	char shortbuf[8];
X	char *p;
X	static int start=1;
X
X	/* If we are sending less than 8 bytes, the same char will look
X	 * the same if we don't pad it out with random bytes */
X	if (start)
X		{
X		start=0;
X		srandom(time(NULL));
X		}
X
X	/* lets recurse if we want to send the data in small chunks */
X	if (len > MAXWRITE)
X		{
X		j=0;
X		for (i=0; i<len; i+=k)
X			{
X			k=des_enc_write(fd,&(buf[i]),
X				((len-i) > MAXWRITE)?MAXWRITE:(len-i),sched,iv);
X			if (k < 0)
X				return(k);
X			else
X				j+=k;
X			}
X		return(j);
X		}
X
X	/* write length first */
X	p=outbuf;
X	l2n(len,p);
X
X	/* pad short strings */
X	if (len < 8)
X		{
X		p=shortbuf;
X		bcopy(buf,shortbuf,len);
X		for (i=len; i<8; i++)
X			shortbuf[i]=random();
X		rnum=8;
X		}
X	else
X		{
X		p=buf;
X		rnum=((len+7)/8*8); /* round up to nearest eight */
X		}
X
X	if (des_rw_mode & DES_PCBC_MODE)
X		pcbc_encrypt((des_cblock *)p,(des_cblock *)&(outbuf[HDRSIZE]),
X			(long)((len<8)?8:len),sched,iv,DES_ENCRYPT); 
X	else
X		cbc_encrypt((des_cblock *)p,(des_cblock *)&(outbuf[HDRSIZE]),
X			(long)((len<8)?8:len),sched,iv,DES_ENCRYPT); 
X
X	/* output */
X	outnum=rnum+HDRSIZE;
X
X	for (j=0; j<outnum; j+=i)
X		{
X		/* eay 26/08/92 I was not doing writing from where we
X		 * got upto. */
X		i=write(fd,&(outbuf[j]),(int)(outnum-j));
X		if (i == -1)
X			{
X			if (errno == EINTR)
X				i=0;
X			else 	/* This is really a bad error - very bad
X				 * It will stuff-up both ends. */
X				return(-1);
X			}
X		}
X
X	return(len);
X	}
END_OF_FILE
  if test 1718 -ne `wc -c <'enc_writ.c'`; then
    echo shar: \"'enc_writ.c'\" unpacked with wrong size!
  fi
  # end of 'enc_writ.c'
fi
if test -f 'pcbc_enc.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'pcbc_enc.c'\"
else
  echo shar: Extracting \"'pcbc_enc.c'\" \(1447 characters\)
  sed "s/^X//" >'pcbc_enc.c' <<'END_OF_FILE'
X/* pcbc_enc.c */
X/* Copyright (C) 1993 Eric Young - see README for more details */
X#include "des_locl.h"
X
Xint des_pcbc_encrypt(input,output,length,schedule,ivec,encrypt)
Xdes_cblock *input;
Xdes_cblock *output;
Xlong length;
Xdes_key_schedule schedule;
Xdes_cblock *ivec;
Xint encrypt;
X	{
X	register unsigned long sin0,sin1,xor0,xor1,tout0,tout1;
X	unsigned long tin[2],tout[2];
X	unsigned char *in,*out,*iv;
X
X	in=(unsigned char *)input;
X	out=(unsigned char *)output;
X	iv=(unsigned char *)ivec;
X
X	if (encrypt)
X		{
X		c2l(iv,xor0);
X		c2l(iv,xor1);
X		for (; length>0; length-=8)
X			{
X			if (length >= 8)
X				{
X				c2l(in,sin0);
X				c2l(in,sin1);
X				}
X			else
X				c2ln(in,sin0,sin1,length);
X			tin[0]=sin0^xor0;
X			tin[1]=sin1^xor1;
X			des_encrypt((unsigned long *)tin,(unsigned long *)tout,
X				schedule,encrypt);
X			tout0=tout[0];
X			tout1=tout[1];
X			xor0=sin0^tout[0];
X			xor1=sin1^tout[1];
X			l2c(tout0,out);
X			l2c(tout1,out);
X			}
X		}
X	else
X		{
X		c2l(iv,xor0); c2l(iv,xor1);
X		for (; length>0; length-=8)
X			{
X			c2l(in,sin0);
X			c2l(in,sin1);
X			tin[0]=sin0;
X			tin[1]=sin1;
X			des_encrypt((unsigned long *)tin,(unsigned long *)tout,
X				schedule,encrypt);
X			tout0=tout[0]^xor0;
X			tout1=tout[1]^xor1;
X			if (length >= 8)
X				{
X				l2c(tout0,out);
X				l2c(tout1,out);
X				}
X			else
X				l2cn(tout0,tout1,out,length);
X			xor0=tout0^sin0;
X			xor1=tout1^sin1;
X			}
X		}
X	tin[0]=tin[1]=tout[0]=tout[1]=0;
X	sin0=sin1=xor0=xor1=tout0=tout1=0;
X	return(0);
X	}
END_OF_FILE
  if test 1447 -ne `wc -c <'pcbc_enc.c'`; then
    echo shar: \"'pcbc_enc.c'\" unpacked with wrong size!
  fi
  # end of 'pcbc_enc.c'
fi
if test -f 'qud_cksm.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'qud_cksm.c'\"
else
  echo shar: Extracting \"'qud_cksm.c'\" \(2121 characters\)
  sed "s/^X//" >'qud_cksm.c' <<'END_OF_FILE'
X/* qud_cksm.c */
X/* Copyright (C) 1993 Eric Young - see README for more details */
X/* From "Message Authentication"  R.R. Jueneman, S.M. Matyas, C.H. Meyer
X * IEEE Communications Magazine Sept 1985 Vol. 23 No. 9 p 29-40
X * This module in only based on the code in this paper and is
X * almost definitely not the same as the MIT implementation.
X */
X#include "des_locl.h"
X
X/* bug fix for dos - 7/6/91 - Larry hughes@logos.ucs.indiana.edu */
X#define B0(a)	(((unsigned long)(a)))
X#define B1(a)	(((unsigned long)(a))<<8)
X#define B2(a)	(((unsigned long)(a))<<16)
X#define B3(a)	(((unsigned long)(a))<<24)
X
X/* used to scramble things a bit */
X/* Got the value MIT uses via brute force :-) 2/10/90 eay */
X#define NOISE	((unsigned long)83653421)
X
Xunsigned long des_quad_cksum(input,output,length,out_count,seed)
Xdes_cblock *input;
Xdes_cblock *output;
Xlong length;
Xint out_count;
Xdes_cblock *seed;
X	{
X	unsigned long z0,z1,t0,t1;
X	int i;
X	long l=0;
X	unsigned char *cp;
X	unsigned char *lp;
X
X	if (out_count < 1) out_count=1;
X	lp=(unsigned char *)output;
X
X	z0=B0((*seed)[0])|B1((*seed)[1])|B2((*seed)[2])|B3((*seed)[3]);
X	z1=B0((*seed)[4])|B1((*seed)[5])|B2((*seed)[6])|B3((*seed)[7]);
X
X	for (i=0; ((i<4)&&(i<out_count)); i++)
X		{
X		cp=(unsigned char *)input;
X		l=length;
X		while (l > 0)
X			{
X			if (l > 1)
X				{
X				t0= (unsigned long)(*(cp++));
X				t0|=(unsigned long)B1(*(cp++));
X				l--;
X				}
X			else
X				t0= (unsigned long)(*(cp++));
X			l--;
X			/* add */
X			t0+=z0;
X			t0&=0xffffffff;
X			t1=z1;
X			/* square, well sort of square */
X			z0=((((t0*t0)&0xffffffff)+((t1*t1)&0xffffffff))
X				&0xffffffff)%0x7fffffff; 
X			z1=((t0*((t1+NOISE)&0xffffffff))&0xffffffff)%0x7fffffff;
X			}
X		if (lp != NULL)
X			{
X			/* I believe I finally have things worked out.
X			 * The MIT library assumes that the checksum
X			 * is one huge number and it is returned in a
X			 * host dependant byte order.
X			 */
X			static unsigned long l=1;
X			static unsigned char *c=(unsigned char *)&l;
X
X			if (c[0])
X				{
X				l2c(z0,lp);
X				l2c(z1,lp);
X				}
X			else
X				{
X				lp=output[out_count-i-1];
X				l2n(z1,lp);
X				l2n(z0,lp);
X				}
X			}
X		}
X	return(z0);
X	}
X
END_OF_FILE
  if test 2121 -ne `wc -c <'qud_cksm.c'`; then
    echo shar: \"'qud_cksm.c'\" unpacked with wrong size!
  fi
  # end of 'qud_cksm.c'
fi
if test -f 'rand_key.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'rand_key.c'\"
else
  echo shar: Extracting \"'rand_key.c'\" \(918 characters\)
  sed "s/^X//" >'rand_key.c' <<'END_OF_FILE'
X/* rand_key.c */
X/* Copyright (C) 1993 Eric Young - see README for more details */
X#include "des_locl.h"
X
Xint des_random_key(ret)
Xdes_cblock ret;
X	{
X	des_key_schedule ks;
X	static unsigned long c=0;
X	static unsigned short pid=0;
X	static des_cblock data={0x01,0x23,0x45,0x67,0x89,0xab,0xcd,0xef};
X	des_cblock key;
X	unsigned char *p;
X	unsigned long t;
X
X#ifdef MSDOS
X	pid=1;
X#else
X	if (!pid) pid=getpid();
X#endif
X	p=key;
X	t=(unsigned long)time(NULL);
X	l2c(t,p);
X	t=(unsigned long)((pid)|((c++)<<16));
X	l2c(t,p);
X
X	des_set_odd_parity((des_cblock *)data);
X	des_set_key((des_cblock *)data,ks);
X	des_cbc_cksum((des_cblock *)key,(des_cblock *)key,
X		(long)sizeof(key),ks,(des_cblock *)data);
X	des_set_odd_parity((des_cblock *)key);
X	des_cbc_cksum((des_cblock *)key,(des_cblock *)key,
X		(long)sizeof(key),ks,(des_cblock *)data);
X
X	bcopy(key,ret,sizeof(key));
X	bzero(key,sizeof(key));
X	bzero(ks,sizeof(ks));
X	t=0;
X	return(0);
X	}
END_OF_FILE
  if test 918 -ne `wc -c <'rand_key.c'`; then
    echo shar: \"'rand_key.c'\" unpacked with wrong size!
  fi
  # end of 'rand_key.c'
fi
if test -f 'read_pwd.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'read_pwd.c'\"
else
  echo shar: Extracting \"'read_pwd.c'\" \(5215 characters\)
  sed "s/^X//" >'read_pwd.c' <<'END_OF_FILE'
X/* read_pwd.c */
X/* Copyright (C) 1993 Eric Young - see README for more details */
X/* 06-Apr-92 Luke Brennan    Support for VMS */
X#include "des_locl.h"
X#include <string.h>
X#include <signal.h>
X#include <setjmp.h>
X
X#ifndef VMS
X#ifndef MSDOS
X#ifndef _IRIX
X#ifdef CRAY
X#include <termio.h>
X#define sgttyb termio
X#define sg_flags c_lflag
X#else /* !CRAY */
X#include <sgtty.h>
X#endif
X#include <sys/ioctl.h>
X#else /* _IRIX */
Xstruct  sgttyb {
X	char    sg_ispeed;              /* input speed */
X	char    sg_ospeed;              /* output speed */
X	char    sg_erase;               /* erase character */
X	char    sg_kill;                /* kill character */
X	short   sg_flags; /* mode flags */
X	};
X#endif
X#else /* MSDOS */
X#define fgets(a,b,c) noecho_fgets(a,b,c)
X#ifndef NSIG
X#define NSIG 32
X#endif
X#endif
X#else /* VMS */
X#include <ssdef.h>
X#include <iodef.h>
X#include <ttdef.h>
X#include <descrip.h>
Xstruct IOSB {
X	short iosb$w_value;
X	short iosb$w_count;
X	long  iosb$l_info;
X	};
X#endif
X
Xstatic void read_till_nl();
Xstatic int read_pw();
Xstatic void recsig();
Xstatic void pushsig();
Xstatic void popsig();
X#ifdef MSDOS
Xstatic int noecho_fgets();
X#endif
X
Xstatic void (*savsig[NSIG])();
Xstatic jmp_buf save;
X
Xint des_read_password(key,prompt,verify)
Xdes_cblock *key;
Xchar *prompt;
Xint verify;
X	{
X	int ok;
X	char buf[BUFSIZ],buff[BUFSIZ];
X
X	if ((ok=read_pw(buf,buff,BUFSIZ,prompt,verify)) == 0)
X		des_string_to_key(buf,key);
X	bzero(buf,BUFSIZ);
X	bzero(buff,BUFSIZ);
X	return(ok);
X	}
X
Xint des_read_2passwords(key1,key2,prompt,verify)
Xdes_cblock *key1;
Xdes_cblock *key2;
Xchar *prompt;
Xint verify;
X	{
X	int ok;
X	char buf[BUFSIZ],buff[BUFSIZ];
X
X	if ((ok=read_pw(buf,buff,BUFSIZ,prompt,verify)) == 0)
X		des_string_to_2keys(buf,key1,key2);
X	bzero(buf,BUFSIZ);
X	bzero(buff,BUFSIZ);
X	return(ok);
X	}
X
Xint des_read_pw_string(buf,length,prompt,verify)
Xchar *buf;
Xint length;
Xchar *prompt;
Xint verify;
X	{
X	char buff[BUFSIZ];
X	int ret;
X
X	ret=read_pw(buf,buff,(length>BUFSIZ)?BUFSIZ:length,prompt,verify);
X	bzero(buff,BUFSIZ);
X	return(ret);
X	}
X
Xstatic void read_till_nl(in)
XFILE *in;
X	{
X#define SIZE 4
X	char buf[SIZE+1];
X
X	do	{
X		fgets(buf,SIZE,in);
X		} while (index(buf,'\n') == NULL);
X	}
X
X/* return 0 if ok, 1 (or -1) otherwise */
Xstatic int read_pw(buf,buff,size,prompt,verify)
Xchar *buf,*buff;
Xint size;
Xchar *prompt;
Xint verify;
X	{
X#ifndef VMS
X#ifndef MSDOS
X	struct sgttyb tty_orig,tty_new;
X#endif /* !MSDOS */
X#else
X	struct IOSB iosb;
X	$DESCRIPTOR(terminal,"TT");
X	long tty_orig[3], tty_new[3];
X	long status;
X	unsigned short channel = 0;
X#endif
X	int ok=0;
X	char *p;
X	int ps=0;
X	FILE *tty;
X
X#ifndef MSDOS
X	if ((tty=fopen("/dev/tty","r")) == NULL)
X		tty=stdin;
X#else /* MSDOS */
X	if ((tty=fopen("con","r")) == NULL)
X		tty=stdin;
X#endif /* MSDOS */
X#ifndef VMS
X#ifdef TIOCGETP
X	if (ioctl(fileno(tty),TIOCGETP,(char *)&tty_orig) == -1)
X		return(-1);
X	bcopy(&(tty_orig),&(tty_new),sizeof(tty_orig));
X#endif
X#else /* VMS */
X	status = SYS$ASSIGN(&terminal,&channel,0,0);
X	if (status != SS$_NORMAL)
X		return(-1);
X	status=SYS$QIOW(0,channel,IO$_SENSEMODE,&iosb,0,0,tty_orig,12,0,0,0,0);
X	if ((status != SS$_NORMAL) || (iosb.iosb$w_value != SS$_NORMAL))
X		return(-1);
X#endif
X
X	if (setjmp(save))
X		{
X		ok=0;
X		goto error;
X		}
X	pushsig();
X	ps=1;
X#ifndef VMS
X#ifndef MSDOS
X	tty_new.sg_flags &= ~ECHO;
X#endif /* !MSDOS */
X#ifdef TIOCSETP
X	if (ioctl(fileno(tty),TIOCSETP,(char *)&tty_new) == -1)
X		return(-1);
X#endif
X#else /* VMS */
X	tty_new[0] = tty_orig[0];
X	tty_new[1] = tty_orig[1] | TT$M_NOECHO;
X	tty_new[2] = tty_orig[2];
X	status = SYS$QIOW(0,channel,IO$_SETMODE,&iosb,0,0,tty_new,12,0,0,0,0);
X	if ((status != SS$_NORMAL) || (iosb.iosb$w_value != SS$_NORMAL))
X		return(-1);
X#endif /* VMS */
X	ps=2;
X
X	while (!ok)
X		{
X		fputs(prompt,stderr);
X		fflush(stderr);
X
X		buf[0]='\0';
X		fgets(buf,size,tty);
X		if (feof(tty)) goto error;
X		if ((p=(char *)index(buf,'\n')) != NULL)
X			*p='\0';
X		else	read_till_nl(tty);
X		if (verify)
X			{
X			fprintf(stderr,"\nVerifying password %s",prompt);
X			fflush(stderr);
X			buff[0]='\0';
X			fgets(buff,size,tty);
X			if (feof(tty)) goto error;
X			if ((p=(char *)index(buff,'\n')) != NULL)
X				*p='\0';
X			else	read_till_nl(tty);
X				
X			if (strcmp(buf,buff) != 0)
X				{
X				fprintf(stderr,"\nVerify failure - try again\n");
X				fflush(stderr);
X				continue;
X				}
X			}
X		ok=1;
X		}
X
Xerror:
X	fprintf(stderr,"\n");
X	/* What can we do if there is an error? */
X#ifndef VMS
X#ifdef TIOCSETP
X	if (ps >= 2) ioctl(fileno(tty),TIOCSETP,(char *)&tty_orig);
X#endif
X#else /* VMS */
X	if (ps >= 2)
X		status = SYS$QIOW(0,channel,IO$_SETMODE,&iosb,0,0
X			,tty_orig,12,0,0,0,0);
X#endif /* VMS */
X	
X	if (ps >= 1) popsig();
X	if (stdin != tty) fclose(tty);
X#ifdef VMS
X	status = SYS$DASSGN(channel);
X#endif
X	return(!ok);
X	}
X
Xstatic void pushsig()
X	{
X	int i;
X
X	for (i=0; i<NSIG; i++)
X		savsig[i]=signal(i,recsig);
X	}
X
Xstatic void popsig()
X	{
X	int i;
X
X	for (i=0; i<NSIG; i++)
X		signal(i,savsig[i]);
X	}
X
Xstatic void recsig()
X	{
X	longjmp(save,1);
X	}
X
X#ifdef MSDOS
Xstatic int noecho_fgets(buf,size,tty)
Xchar *buf;
Xint size;
XFILE *tty;
X	{
X	int i;
X	char *p;
X
X	p=buf;
X	for (;;)
X		{
X		if (size == 0)
X			{
X			*p='\0';
X			break;
X			}
X		size--;
X		i=getch();
X		if (i == '\r') i='\n';
X		*(p++)=i;
X		if (i == '\n')
X			{
X			*p='\0';
X			break;
X			}
X		}
X	}
X#endif
END_OF_FILE
  if test 5215 -ne `wc -c <'read_pwd.c'`; then
    echo shar: \"'read_pwd.c'\" unpacked with wrong size!
  fi
  # end of 'read_pwd.c'
fi
if test -f 'set_key.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'set_key.c'\"
else
  echo shar: Extracting \"'set_key.c'\" \(4706 characters\)
  sed "s/^X//" >'set_key.c' <<'END_OF_FILE'
X/* set_key.c */
X/* Copyright (C) 1993 Eric Young - see README for more details */
X/* set_key.c v 1.4 eay 24/9/91
X * 1.4 Speed up by 400% :-)
X * 1.3 added register declarations.
X * 1.2 unrolled make_key_sched a bit more
X * 1.1 added norm_expand_bits
X * 1.0 First working version
X */
X#include "des_locl.h"
X#include "podd.h"
X#include "sk.h"
X
Xstatic int check_parity();
X
Xint des_check_key=0;
X
Xvoid des_set_odd_parity(key)
Xdes_cblock *key;
X	{
X	int i;
X
X	for (i=0; i<DES_KEY_SZ; i++)
X		(*key)[i]=odd_parity[(*key)[i]];
X	}
X
Xstatic int check_parity(key)
Xdes_cblock *key;
X	{
X	int i;
X
X	for (i=0; i<DES_KEY_SZ; i++)
X		{
X		if ((*key)[i] != odd_parity[(*key)[i]])
X			return(0);
X		}
X	return(1);
X	}
X
X/* Weak and semi week keys as take from
X * %A D.W. Davies
X * %A W.L. Price
X * %T Security for Computer Networks
X * %I John Wiley & Sons
X * %D 1984
X * Many thanks to smb@ulysses.att.com (Steven Bellovin) for the reference
X * (and actual cblock values).
X */
X#define NUM_WEAK_KEY	16
Xstatic des_cblock weak_keys[NUM_WEAK_KEY]={
X	/* weak keys */
X	0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,
X	0xFE,0xFE,0xFE,0xFE,0xFE,0xFE,0xFE,0xFE,
X	0x1F,0x1F,0x1F,0x1F,0x1F,0x1F,0x1F,0x1F,
X	0xE0,0xE0,0xE0,0xE0,0xE0,0xE0,0xE0,0xE0,
X	/* semi-weak keys */
X	0x01,0xFE,0x01,0xFE,0x01,0xFE,0x01,0xFE,
X	0xFE,0x01,0xFE,0x01,0xFE,0x01,0xFE,0x01,
X	0x1F,0xE0,0x1F,0xE0,0x0E,0xF1,0x0E,0xF1,
X	0xE0,0x1F,0xE0,0x1F,0xF1,0x0E,0xF1,0x0E,
X	0x01,0xE0,0x01,0xE0,0x01,0xF1,0x01,0xF1,
X	0xE0,0x01,0xE0,0x01,0xF1,0x01,0xF1,0x01,
X	0x1F,0xFE,0x1F,0xFE,0x0E,0xFE,0x0E,0xFE,
X	0xFE,0x1F,0xFE,0x1F,0xFE,0x0E,0xFE,0x0E,
X	0x01,0x1F,0x01,0x1F,0x01,0x0E,0x01,0x0E,
X	0x1F,0x01,0x1F,0x01,0x0E,0x01,0x0E,0x01,
X	0xE0,0xFE,0xE0,0xFE,0xF1,0xFE,0xF1,0xFE,
X	0xFE,0xE0,0xFE,0xE0,0xFE,0xF1,0xFE,0xF1};
X
Xint des_is_weak_key(key)
Xdes_cblock *key;
X	{
X	int i;
X
X	for (i=0; i<NUM_WEAK_KEY; i++)
X		/* Added == 0 to comparision, I obviously don't run
X		 * this section very often :-(, thanks to
X		 * engineering@MorningStar.Com for the fix
X		 * eay 93/06/29 */
X		if (memcmp(weak_keys[i],key,sizeof(key)) == 0) return(1);
X	return(0);
X	}
X
X/* NOW DEFINED IN des_local.h
X * See ecb_encrypt.c for a pseudo description of these macros. 
X * #define PERM_OP(a,b,t,n,m) ((t)=((((a)>>(n))^(b))&(m)),\
X * 	(b)^=(t),\
X * 	(a)=((a)^((t)<<(n))))
X */
X
X#define HPERM_OP(a,t,n,m) ((t)=((((a)<<(16-(n)))^(a))&(m)),\
X	(a)=(a)^(t)^(t>>(16-(n))))
X
Xstatic char shifts2[16]={0,0,1,1,1,1,1,1,0,1,1,1,1,1,1,0};
X
X/* return 0 if key parity is odd (correct),
X * return -1 if key parity error,
X * return -2 if illegal weak key.
X */
Xint des_set_key(key,schedule)
Xdes_cblock *key;
Xdes_key_schedule schedule;
X	{
X	register unsigned long c,d,t,s;
X	register unsigned char *in;
X	register unsigned long *k;
X	register int i;
X
X	if (des_check_key)
X		{
X		if (!check_parity(key))
X			return(-1);
X
X		if (des_is_weak_key(key))
X			return(-2);
X		}
X
X	k=(unsigned long *)schedule;
X	in=(unsigned char *)key;
X
X	c2l(in,c);
X	c2l(in,d);
X
X	/* do PC1 in 60 simple operations */ 
X/*	PERM_OP(d,c,t,4,0x0f0f0f0f);
X	HPERM_OP(c,t,-2, 0xcccc0000);
X	HPERM_OP(c,t,-1, 0xaaaa0000);
X	HPERM_OP(c,t, 8, 0x00ff0000);
X	HPERM_OP(c,t,-1, 0xaaaa0000);
X	HPERM_OP(d,t,-8, 0xff000000);
X	HPERM_OP(d,t, 8, 0x00ff0000);
X	HPERM_OP(d,t, 2, 0x33330000);
X	d=((d&0x00aa00aa)<<7)|((d&0x55005500)>>7)|(d&0xaa55aa55);
X	d=(d>>8)|((c&0xf0000000)>>4);
X	c&=0x0fffffff; */
X
X	/* I now do it in 47 simple operations :-)
X	 * Thanks to John Fletcher (john_fletcher@lccmail.ocf.llnl.gov)
X	 * for the inspiration. :-) */
X	PERM_OP (d,c,t,4,0x0f0f0f0f);
X	HPERM_OP(c,t,-2,0xcccc0000);
X	HPERM_OP(d,t,-2,0xcccc0000);
X	PERM_OP (d,c,t,1,0x55555555);
X	PERM_OP (c,d,t,8,0x00ff00ff);
X	PERM_OP (d,c,t,1,0x55555555);
X	d=	(((d&0x000000ff)<<16)| (d&0x0000ff00)     |
X		 ((d&0x00ff0000)>>16)|((c&0xf0000000)>>4));
X	c&=0x0fffffff;
X
X	for (i=0; i<ITERATIONS; i++)
X		{
X		if (shifts2[i])
X			{ c=((c>>2)|(c<<26)); d=((d>>2)|(d<<26)); }
X		else
X			{ c=((c>>1)|(c<<27)); d=((d>>1)|(d<<27)); }
X		c&=0x0fffffff;
X		d&=0x0fffffff;
X		/* could be a few less shifts but I am to lazy at this
X		 * point in time to investigate */
X		s=	des_skb[0][ (c    )&0x3f                ]|
X			des_skb[1][((c>> 6)&0x03)|((c>> 7)&0x3c)]|
X			des_skb[2][((c>>13)&0x0f)|((c>>14)&0x30)]|
X			des_skb[3][((c>>20)&0x01)|((c>>21)&0x06) |
X						  ((c>>22)&0x38)];
X		t=	des_skb[4][ (d    )&0x3f                ]|
X			des_skb[5][((d>> 7)&0x03)|((d>> 8)&0x3c)]|
X			des_skb[6][ (d>>15)&0x3f                ]|
X			des_skb[7][((d>>21)&0x0f)|((d>>22)&0x30)];
X
X		/* table contained 0213 4657 */
X		*(k++)=((t<<16)|(s&0x0000ffff))&0xffffffff;
X		s=     ((s>>16)|(t&0xffff0000));
X		
X		s=(s<<4)|(s>>28);
X		*(k++)=s&0xffffffff;
X		}
X	return(0);
X	}
X
Xint des_key_sched(key,schedule)
Xdes_cblock *key;
Xdes_key_schedule schedule;
X	{
X	return(des_set_key(key,schedule));
X	}
END_OF_FILE
  if test 4706 -ne `wc -c <'set_key.c'`; then
    echo shar: \"'set_key.c'\" unpacked with wrong size!
  fi
  # end of 'set_key.c'
fi
if test -f 'str2key.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'str2key.c'\"
else
  echo shar: Extracting \"'str2key.c'\" \(2341 characters\)
  sed "s/^X//" >'str2key.c' <<'END_OF_FILE'
X/* str2key.c */
X/* Copyright (C) 1993 Eric Young - see README for more details */
X#include "des_locl.h"
X
Xextern int des_check_key;
X
Xint des_string_to_key(str,key)
Xchar *str;
Xdes_cblock *key;
X	{
X	des_key_schedule ks;
X	int i,length;
X	register unsigned char j;
X
X	bzero(key,8);
X	length=strlen(str);
X#ifdef OLD_STR_TO_KEY
X	for (i=0; i<length; i++)
X		(*key)[i%8]^=(str[i]<<1);
X#else /* MIT COMPATIBLE */
X	for (i=0; i<length; i++)
X		{
X		j=str[i];
X		if ((i%16) < 8)
X			(*key)[i%8]^=(j<<1);
X		else
X			{
X			/* Reverse the bit order 05/05/92 eay */
X			j=((j<<4)&0xf0)|((j>>4)&0x0f);
X			j=((j<<2)&0xcc)|((j>>2)&0x33);
X			j=((j<<1)&0xaa)|((j>>1)&0x55);
X			(*key)[7-(i%8)]^=j;
X			}
X		}
X#endif
X	des_set_odd_parity((des_cblock *)key);
X	i=des_check_key;
X	des_check_key=0;
X	des_set_key((des_cblock *)key,ks);
X	des_check_key=i;
X	des_cbc_cksum((des_cblock *)str,(des_cblock *)key,(long)length,ks,
X		(des_cblock *)key);
X	bzero(ks,sizeof(ks));
X	des_set_odd_parity((des_cblock *)key);
X	return(0);
X	}
X
Xint des_string_to_2keys(str,key1,key2)
Xchar *str;
Xdes_cblock *key1,*key2;
X	{
X	des_key_schedule ks;
X	int i,length;
X	register unsigned char j;
X
X	bzero(key1,8);
X	bzero(key2,8);
X	length=strlen(str);
X#ifdef OLD_STR_TO_KEY
X	if (length <= 8)
X		{
X		for (i=0; i<length; i++)
X			{
X			(*key2)[i]=(*key1)[i]=(str[i]<<1);
X			}
X		}
X	else
X		{
X		for (i=0; i<length; i++)
X			{
X			if ((i/8)&1)
X				(*key2)[i%8]^=(str[i]<<1);
X			else
X				(*key1)[i%8]^=(str[i]<<1);
X			}
X		}
X#else /* MIT COMPATIBLE */
X	for (i=0; i<length; i++)
X		{
X		j=str[i];
X		if ((i%32) < 16)
X			{
X			if ((i%16) < 8)
X				(*key1)[i%8]^=(j<<1);
X			else
X				(*key2)[i%8]^=(j<<1);
X			}
X		else
X			{
X			j=((j<<4)&0xf0)|((j>>4)&0x0f);
X			j=((j<<2)&0xcc)|((j>>2)&0x33);
X			j=((j<<1)&0xaa)|((j>>1)&0x55);
X			if ((i%16) < 8)
X				(*key1)[7-(i%8)]^=j;
X			else
X				(*key2)[7-(i%8)]^=j;
X			}
X		}
X	if (length <= 8) bcopy(key1,key2,8);
X#endif
X	des_set_odd_parity((des_cblock *)key1);
X	des_set_odd_parity((des_cblock *)key2);
X	i=des_check_key;
X	des_check_key=0;
X	des_set_key((des_cblock *)key1,ks);
X	des_cbc_cksum((des_cblock *)str,(des_cblock *)key1,(long)length,ks,
X		(des_cblock *)key1);
X	des_set_key((des_cblock *)key2,ks);
X	des_cbc_cksum((des_cblock *)str,(des_cblock *)key2,(long)length,ks,
X		(des_cblock *)key2);
X	des_check_key=i;
X	bzero(ks,sizeof(ks));
X	des_set_odd_parity(key1);
X	des_set_odd_parity(key2);
X	return(0);
X	}
END_OF_FILE
  if test 2341 -ne `wc -c <'str2key.c'`; then
    echo shar: \"'str2key.c'\" unpacked with wrong size!
  fi
  # end of 'str2key.c'
fi
if test -f 'fcrypt.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'fcrypt.c'\"
else
  echo shar: Extracting \"'fcrypt.c'\" \(20174 characters\)
  sed "s/^X//" >'fcrypt.c' <<'END_OF_FILE'
X/* fcrypt.c */
X/* Copyright (C) 1993 Eric Young - see README for more details */
X#include <stdio.h>
X
X/* Eric Young.
X * This version of crypt has been developed from my MIT compatable
X * DES library.
X * The library is available at pub/DES at ftp.psy.uq.oz.au
X * eay@psych.psy.uq.oz.au
X */
X
Xtypedef unsigned char des_cblock[8];
X
Xtypedef struct des_ks_struct
X	{
X	union	{
X		des_cblock _;
X		/* make sure things are correct size on machines with
X		 * 8 byte longs */
X		unsigned long pad[2];
X		} ks;
X#define _	ks._
X	} des_key_schedule[16];
X
X#define DES_KEY_SZ 	(sizeof(des_cblock))
X#define DES_ENCRYPT	1
X#define DES_DECRYPT	0
X
X#define ITERATIONS 16
X#define HALF_ITERATIONS 8
X
X#define c2l(c,l)	(l =((unsigned long)(*((c)++)))    , \
X			 l|=((unsigned long)(*((c)++)))<< 8, \
X			 l|=((unsigned long)(*((c)++)))<<16, \
X			 l|=((unsigned long)(*((c)++)))<<24)
X
X#define l2c(l,c)	(*((c)++)=(unsigned char)(((l)    )&0xff), \
X			 *((c)++)=(unsigned char)(((l)>> 8)&0xff), \
X			 *((c)++)=(unsigned char)(((l)>>16)&0xff), \
X			 *((c)++)=(unsigned char)(((l)>>24)&0xff))
X
Xstatic unsigned long SPtrans[8][64]={
X/* nibble 0 */
X0x00820200, 0x00020000, 0x80800000, 0x80820200,
X0x00800000, 0x80020200, 0x80020000, 0x80800000,
X0x80020200, 0x00820200, 0x00820000, 0x80000200,
X0x80800200, 0x00800000, 0x00000000, 0x80020000,
X0x00020000, 0x80000000, 0x00800200, 0x00020200,
X0x80820200, 0x00820000, 0x80000200, 0x00800200,
X0x80000000, 0x00000200, 0x00020200, 0x80820000,
X0x00000200, 0x80800200, 0x80820000, 0x00000000,
X0x00000000, 0x80820200, 0x00800200, 0x80020000,
X0x00820200, 0x00020000, 0x80000200, 0x00800200,
X0x80820000, 0x00000200, 0x00020200, 0x80800000,
X0x80020200, 0x80000000, 0x80800000, 0x00820000,
X0x80820200, 0x00020200, 0x00820000, 0x80800200,
X0x00800000, 0x80000200, 0x80020000, 0x00000000,
X0x00020000, 0x00800000, 0x80800200, 0x00820200,
X0x80000000, 0x80820000, 0x00000200, 0x80020200,
X/* nibble 1 */
X0x10042004, 0x00000000, 0x00042000, 0x10040000,
X0x10000004, 0x00002004, 0x10002000, 0x00042000,
X0x00002000, 0x10040004, 0x00000004, 0x10002000,
X0x00040004, 0x10042000, 0x10040000, 0x00000004,
X0x00040000, 0x10002004, 0x10040004, 0x00002000,
X0x00042004, 0x10000000, 0x00000000, 0x00040004,
X0x10002004, 0x00042004, 0x10042000, 0x10000004,
X0x10000000, 0x00040000, 0x00002004, 0x10042004,
X0x00040004, 0x10042000, 0x10002000, 0x00042004,
X0x10042004, 0x00040004, 0x10000004, 0x00000000,
X0x10000000, 0x00002004, 0x00040000, 0x10040004,
X0x00002000, 0x10000000, 0x00042004, 0x10002004,
X0x10042000, 0x00002000, 0x00000000, 0x10000004,
X0x00000004, 0x10042004, 0x00042000, 0x10040000,
X0x10040004, 0x00040000, 0x00002004, 0x10002000,
X0x10002004, 0x00000004, 0x10040000, 0x00042000,
X/* nibble 2 */
X0x41000000, 0x01010040, 0x00000040, 0x41000040,
X0x40010000, 0x01000000, 0x41000040, 0x00010040,
X0x01000040, 0x00010000, 0x01010000, 0x40000000,
X0x41010040, 0x40000040, 0x40000000, 0x41010000,
X0x00000000, 0x40010000, 0x01010040, 0x00000040,
X0x40000040, 0x41010040, 0x00010000, 0x41000000,
X0x41010000, 0x01000040, 0x40010040, 0x01010000,
X0x00010040, 0x00000000, 0x01000000, 0x40010040,
X0x01010040, 0x00000040, 0x40000000, 0x00010000,
X0x40000040, 0x40010000, 0x01010000, 0x41000040,
X0x00000000, 0x01010040, 0x00010040, 0x41010000,
X0x40010000, 0x01000000, 0x41010040, 0x40000000,
X0x40010040, 0x41000000, 0x01000000, 0x41010040,
X0x00010000, 0x01000040, 0x41000040, 0x00010040,
X0x01000040, 0x00000000, 0x41010000, 0x40000040,
X0x41000000, 0x40010040, 0x00000040, 0x01010000,
X/* nibble 3 */
X0x00100402, 0x04000400, 0x00000002, 0x04100402,
X0x00000000, 0x04100000, 0x04000402, 0x00100002,
X0x04100400, 0x04000002, 0x04000000, 0x00000402,
X0x04000002, 0x00100402, 0x00100000, 0x04000000,
X0x04100002, 0x00100400, 0x00000400, 0x00000002,
X0x00100400, 0x04000402, 0x04100000, 0x00000400,
X0x00000402, 0x00000000, 0x00100002, 0x04100400,
X0x04000400, 0x04100002, 0x04100402, 0x00100000,
X0x04100002, 0x00000402, 0x00100000, 0x04000002,
X0x00100400, 0x04000400, 0x00000002, 0x04100000,
X0x04000402, 0x00000000, 0x00000400, 0x00100002,
X0x00000000, 0x04100002, 0x04100400, 0x00000400,
X0x04000000, 0x04100402, 0x00100402, 0x00100000,
X0x04100402, 0x00000002, 0x04000400, 0x00100402,
X0x00100002, 0x00100400, 0x04100000, 0x04000402,
X0x00000402, 0x04000000, 0x04000002, 0x04100400,
X/* nibble 4 */
X0x02000000, 0x00004000, 0x00000100, 0x02004108,
X0x02004008, 0x02000100, 0x00004108, 0x02004000,
X0x00004000, 0x00000008, 0x02000008, 0x00004100,
X0x02000108, 0x02004008, 0x02004100, 0x00000000,
X0x00004100, 0x02000000, 0x00004008, 0x00000108,
X0x02000100, 0x00004108, 0x00000000, 0x02000008,
X0x00000008, 0x02000108, 0x02004108, 0x00004008,
X0x02004000, 0x00000100, 0x00000108, 0x02004100,
X0x02004100, 0x02000108, 0x00004008, 0x02004000,
X0x00004000, 0x00000008, 0x02000008, 0x02000100,
X0x02000000, 0x00004100, 0x02004108, 0x00000000,
X0x00004108, 0x02000000, 0x00000100, 0x00004008,
X0x02000108, 0x00000100, 0x00000000, 0x02004108,
X0x02004008, 0x02004100, 0x00000108, 0x00004000,
X0x00004100, 0x02004008, 0x02000100, 0x00000108,
X0x00000008, 0x00004108, 0x02004000, 0x02000008,
X/* nibble 5 */
X0x20000010, 0x00080010, 0x00000000, 0x20080800,
X0x00080010, 0x00000800, 0x20000810, 0x00080000,
X0x00000810, 0x20080810, 0x00080800, 0x20000000,
X0x20000800, 0x20000010, 0x20080000, 0x00080810,
X0x00080000, 0x20000810, 0x20080010, 0x00000000,
X0x00000800, 0x00000010, 0x20080800, 0x20080010,
X0x20080810, 0x20080000, 0x20000000, 0x00000810,
X0x00000010, 0x00080800, 0x00080810, 0x20000800,
X0x00000810, 0x20000000, 0x20000800, 0x00080810,
X0x20080800, 0x00080010, 0x00000000, 0x20000800,
X0x20000000, 0x00000800, 0x20080010, 0x00080000,
X0x00080010, 0x20080810, 0x00080800, 0x00000010,
X0x20080810, 0x00080800, 0x00080000, 0x20000810,
X0x20000010, 0x20080000, 0x00080810, 0x00000000,
X0x00000800, 0x20000010, 0x20000810, 0x20080800,
X0x20080000, 0x00000810, 0x00000010, 0x20080010,
X/* nibble 6 */
X0x00001000, 0x00000080, 0x00400080, 0x00400001,
X0x00401081, 0x00001001, 0x00001080, 0x00000000,
X0x00400000, 0x00400081, 0x00000081, 0x00401000,
X0x00000001, 0x00401080, 0x00401000, 0x00000081,
X0x00400081, 0x00001000, 0x00001001, 0x00401081,
X0x00000000, 0x00400080, 0x00400001, 0x00001080,
X0x00401001, 0x00001081, 0x00401080, 0x00000001,
X0x00001081, 0x00401001, 0x00000080, 0x00400000,
X0x00001081, 0x00401000, 0x00401001, 0x00000081,
X0x00001000, 0x00000080, 0x00400000, 0x00401001,
X0x00400081, 0x00001081, 0x00001080, 0x00000000,
X0x00000080, 0x00400001, 0x00000001, 0x00400080,
X0x00000000, 0x00400081, 0x00400080, 0x00001080,
X0x00000081, 0x00001000, 0x00401081, 0x00400000,
X0x00401080, 0x00000001, 0x00001001, 0x00401081,
X0x00400001, 0x00401080, 0x00401000, 0x00001001,
X/* nibble 7 */
X0x08200020, 0x08208000, 0x00008020, 0x00000000,
X0x08008000, 0x00200020, 0x08200000, 0x08208020,
X0x00000020, 0x08000000, 0x00208000, 0x00008020,
X0x00208020, 0x08008020, 0x08000020, 0x08200000,
X0x00008000, 0x00208020, 0x00200020, 0x08008000,
X0x08208020, 0x08000020, 0x00000000, 0x00208000,
X0x08000000, 0x00200000, 0x08008020, 0x08200020,
X0x00200000, 0x00008000, 0x08208000, 0x00000020,
X0x00200000, 0x00008000, 0x08000020, 0x08208020,
X0x00008020, 0x08000000, 0x00000000, 0x00208000,
X0x08200020, 0x08008020, 0x08008000, 0x00200020,
X0x08208000, 0x00000020, 0x00200020, 0x08008000,
X0x08208020, 0x00200000, 0x08200000, 0x08000020,
X0x00208000, 0x00008020, 0x08008020, 0x08200000,
X0x00000020, 0x08208000, 0x00208020, 0x00000000,
X0x08000000, 0x08200020, 0x00008000, 0x00208020};
Xstatic unsigned long skb[8][64]={
X/* for C bits (numbered as per FIPS 46) 1 2 3 4 5 6 */
X0x00000000,0x00000010,0x20000000,0x20000010,
X0x00010000,0x00010010,0x20010000,0x20010010,
X0x00000800,0x00000810,0x20000800,0x20000810,
X0x00010800,0x00010810,0x20010800,0x20010810,
X0x00000020,0x00000030,0x20000020,0x20000030,
X0x00010020,0x00010030,0x20010020,0x20010030,
X0x00000820,0x00000830,0x20000820,0x20000830,
X0x00010820,0x00010830,0x20010820,0x20010830,
X0x00080000,0x00080010,0x20080000,0x20080010,
X0x00090000,0x00090010,0x20090000,0x20090010,
X0x00080800,0x00080810,0x20080800,0x20080810,
X0x00090800,0x00090810,0x20090800,0x20090810,
X0x00080020,0x00080030,0x20080020,0x20080030,
X0x00090020,0x00090030,0x20090020,0x20090030,
X0x00080820,0x00080830,0x20080820,0x20080830,
X0x00090820,0x00090830,0x20090820,0x20090830,
X/* for C bits (numbered as per FIPS 46) 7 8 10 11 12 13 */
X0x00000000,0x02000000,0x00002000,0x02002000,
X0x00200000,0x02200000,0x00202000,0x02202000,
X0x00000004,0x02000004,0x00002004,0x02002004,
X0x00200004,0x02200004,0x00202004,0x02202004,
X0x00000400,0x02000400,0x00002400,0x02002400,
X0x00200400,0x02200400,0x00202400,0x02202400,
X0x00000404,0x02000404,0x00002404,0x02002404,
X0x00200404,0x02200404,0x00202404,0x02202404,
X0x10000000,0x12000000,0x10002000,0x12002000,
X0x10200000,0x12200000,0x10202000,0x12202000,
X0x10000004,0x12000004,0x10002004,0x12002004,
X0x10200004,0x12200004,0x10202004,0x12202004,
X0x10000400,0x12000400,0x10002400,0x12002400,
X0x10200400,0x12200400,0x10202400,0x12202400,
X0x10000404,0x12000404,0x10002404,0x12002404,
X0x10200404,0x12200404,0x10202404,0x12202404,
X/* for C bits (numbered as per FIPS 46) 14 15 16 17 19 20 */
X0x00000000,0x00000001,0x00040000,0x00040001,
X0x01000000,0x01000001,0x01040000,0x01040001,
X0x00000002,0x00000003,0x00040002,0x00040003,
X0x01000002,0x01000003,0x01040002,0x01040003,
X0x00000200,0x00000201,0x00040200,0x00040201,
X0x01000200,0x01000201,0x01040200,0x01040201,
X0x00000202,0x00000203,0x00040202,0x00040203,
X0x01000202,0x01000203,0x01040202,0x01040203,
X0x08000000,0x08000001,0x08040000,0x08040001,
X0x09000000,0x09000001,0x09040000,0x09040001,
X0x08000002,0x08000003,0x08040002,0x08040003,
X0x09000002,0x09000003,0x09040002,0x09040003,
X0x08000200,0x08000201,0x08040200,0x08040201,
X0x09000200,0x09000201,0x09040200,0x09040201,
X0x08000202,0x08000203,0x08040202,0x08040203,
X0x09000202,0x09000203,0x09040202,0x09040203,
X/* for C bits (numbered as per FIPS 46) 21 23 24 26 27 28 */
X0x00000000,0x00100000,0x00000100,0x00100100,
X0x00000008,0x00100008,0x00000108,0x00100108,
X0x00001000,0x00101000,0x00001100,0x00101100,
X0x00001008,0x00101008,0x00001108,0x00101108,
X0x04000000,0x04100000,0x04000100,0x04100100,
X0x04000008,0x04100008,0x04000108,0x04100108,
X0x04001000,0x04101000,0x04001100,0x04101100,
X0x04001008,0x04101008,0x04001108,0x04101108,
X0x00020000,0x00120000,0x00020100,0x00120100,
X0x00020008,0x00120008,0x00020108,0x00120108,
X0x00021000,0x00121000,0x00021100,0x00121100,
X0x00021008,0x00121008,0x00021108,0x00121108,
X0x04020000,0x04120000,0x04020100,0x04120100,
X0x04020008,0x04120008,0x04020108,0x04120108,
X0x04021000,0x04121000,0x04021100,0x04121100,
X0x04021008,0x04121008,0x04021108,0x04121108,
X/* for D bits (numbered as per FIPS 46) 1 2 3 4 5 6 */
X0x00000000,0x10000000,0x00010000,0x10010000,
X0x00000004,0x10000004,0x00010004,0x10010004,
X0x20000000,0x30000000,0x20010000,0x30010000,
X0x20000004,0x30000004,0x20010004,0x30010004,
X0x00100000,0x10100000,0x00110000,0x10110000,
X0x00100004,0x10100004,0x00110004,0x10110004,
X0x20100000,0x30100000,0x20110000,0x30110000,
X0x20100004,0x30100004,0x20110004,0x30110004,
X0x00001000,0x10001000,0x00011000,0x10011000,
X0x00001004,0x10001004,0x00011004,0x10011004,
X0x20001000,0x30001000,0x20011000,0x30011000,
X0x20001004,0x30001004,0x20011004,0x30011004,
X0x00101000,0x10101000,0x00111000,0x10111000,
X0x00101004,0x10101004,0x00111004,0x10111004,
X0x20101000,0x30101000,0x20111000,0x30111000,
X0x20101004,0x30101004,0x20111004,0x30111004,
X/* for D bits (numbered as per FIPS 46) 8 9 11 12 13 14 */
X0x00000000,0x08000000,0x00000008,0x08000008,
X0x00000400,0x08000400,0x00000408,0x08000408,
X0x00020000,0x08020000,0x00020008,0x08020008,
X0x00020400,0x08020400,0x00020408,0x08020408,
X0x00000001,0x08000001,0x00000009,0x08000009,
X0x00000401,0x08000401,0x00000409,0x08000409,
X0x00020001,0x08020001,0x00020009,0x08020009,
X0x00020401,0x08020401,0x00020409,0x08020409,
X0x02000000,0x0A000000,0x02000008,0x0A000008,
X0x02000400,0x0A000400,0x02000408,0x0A000408,
X0x02020000,0x0A020000,0x02020008,0x0A020008,
X0x02020400,0x0A020400,0x02020408,0x0A020408,
X0x02000001,0x0A000001,0x02000009,0x0A000009,
X0x02000401,0x0A000401,0x02000409,0x0A000409,
X0x02020001,0x0A020001,0x02020009,0x0A020009,
X0x02020401,0x0A020401,0x02020409,0x0A020409,
X/* for D bits (numbered as per FIPS 46) 16 17 18 19 20 21 */
X0x00000000,0x00000100,0x00080000,0x00080100,
X0x01000000,0x01000100,0x01080000,0x01080100,
X0x00000010,0x00000110,0x00080010,0x00080110,
X0x01000010,0x01000110,0x01080010,0x01080110,
X0x00200000,0x00200100,0x00280000,0x00280100,
X0x01200000,0x01200100,0x01280000,0x01280100,
X0x00200010,0x00200110,0x00280010,0x00280110,
X0x01200010,0x01200110,0x01280010,0x01280110,
X0x00000200,0x00000300,0x00080200,0x00080300,
X0x01000200,0x01000300,0x01080200,0x01080300,
X0x00000210,0x00000310,0x00080210,0x00080310,
X0x01000210,0x01000310,0x01080210,0x01080310,
X0x00200200,0x00200300,0x00280200,0x00280300,
X0x01200200,0x01200300,0x01280200,0x01280300,
X0x00200210,0x00200310,0x00280210,0x00280310,
X0x01200210,0x01200310,0x01280210,0x01280310,
X/* for D bits (numbered as per FIPS 46) 22 23 24 25 27 28 */
X0x00000000,0x04000000,0x00040000,0x04040000,
X0x00000002,0x04000002,0x00040002,0x04040002,
X0x00002000,0x04002000,0x00042000,0x04042000,
X0x00002002,0x04002002,0x00042002,0x04042002,
X0x00000020,0x04000020,0x00040020,0x04040020,
X0x00000022,0x04000022,0x00040022,0x04040022,
X0x00002020,0x04002020,0x00042020,0x04042020,
X0x00002022,0x04002022,0x00042022,0x04042022,
X0x00000800,0x04000800,0x00040800,0x04040800,
X0x00000802,0x04000802,0x00040802,0x04040802,
X0x00002800,0x04002800,0x00042800,0x04042800,
X0x00002802,0x04002802,0x00042802,0x04042802,
X0x00000820,0x04000820,0x00040820,0x04040820,
X0x00000822,0x04000822,0x00040822,0x04040822,
X0x00002820,0x04002820,0x00042820,0x04042820,
X0x00002822,0x04002822,0x00042822,0x04042822,
X};
X
X/* See ecb_encrypt.c for a pseudo description of these macros. */
X#define PERM_OP(a,b,t,n,m) ((t)=((((a)>>(n))^(b))&(m)),\
X	(b)^=(t),\
X	(a)^=((t)<<(n)))
X
X#define HPERM_OP(a,t,n,m) ((t)=((((a)<<(16-(n)))^(a))&(m)),\
X	(a)=(a)^(t)^(t>>(16-(n))))\
X
Xstatic char shifts2[16]={0,0,1,1,1,1,1,1,0,1,1,1,1,1,1,0};
X
Xstatic int body();
Xstatic int des_set_key();
X
Xstatic int des_set_key(key,schedule)
Xdes_cblock *key;
Xdes_key_schedule schedule;
X	{
X	register unsigned long c,d,t,s;
X	register unsigned char *in;
X	register unsigned long *k;
X	register int i;
X
X	k=(unsigned long *)schedule;
X	in=(unsigned char *)key;
X
X	c2l(in,c);
X	c2l(in,d);
X
X	/* I now do it in 47 simple operations :-)
X	 * Thanks to John Fletcher (john_fletcher@lccmail.ocf.llnl.gov)
X	 * for the inspiration. :-) */
X	PERM_OP (d,c,t,4,0x0f0f0f0f);
X	HPERM_OP(c,t,-2,0xcccc0000);
X	HPERM_OP(d,t,-2,0xcccc0000);
X	PERM_OP (d,c,t,1,0x55555555);
X	PERM_OP (c,d,t,8,0x00ff00ff);
X	PERM_OP (d,c,t,1,0x55555555);
X	d=	(((d&0x000000ff)<<16)| (d&0x0000ff00)     |
X		 ((d&0x00ff0000)>>16)|((c&0xf0000000)>>4));
X	c&=0x0fffffff;
X
X	for (i=0; i<ITERATIONS; i++)
X		{
X		if (shifts2[i])
X			{ c=((c>>2)|(c<<26)); d=((d>>2)|(d<<26)); }
X		else
X			{ c=((c>>1)|(c<<27)); d=((d>>1)|(d<<27)); }
X		c&=0x0fffffff;
X		d&=0x0fffffff;
X		/* could be a few less shifts but I am to lazy at this
X		 * point in time to investigate */
X		s=	skb[0][ (c    )&0x3f                ]|
X			skb[1][((c>> 6)&0x03)|((c>> 7)&0x3c)]|
X			skb[2][((c>>13)&0x0f)|((c>>14)&0x30)]|
X			skb[3][((c>>20)&0x01)|((c>>21)&0x06) |
X			                      ((c>>22)&0x38)];
X		t=	skb[4][ (d    )&0x3f                ]|
X			skb[5][((d>> 7)&0x03)|((d>> 8)&0x3c)]|
X			skb[6][ (d>>15)&0x3f                ]|
X			skb[7][((d>>21)&0x0f)|((d>>22)&0x30)];
X
X		/* table contained 0213 4657 */
X		*(k++)=((t<<16)|(s&0x0000ffff))&0xffffffff;
X		s=     ((s>>16)|(t&0xffff0000));
X		
X		s=(s<<4)|(s>>28);
X		*(k++)=s&0xffffffff;
X		}
X	return(0);
X	}
X
X/******************************************************************
X * modified stuff for crypt.
X ******************************************************************/
X
X/* The changes to this macro may help or hinder, depending on the
X * compiler and the achitecture.  gcc2 always seems to do well :-). 
X * Inspired by Dana How <how@isl.stanford.edu>
X * DO NOT use the alternative version on machines with 8 byte longs.
X */
X#ifdef ALT_ECB
X#define D_ENCRYPT(L,R,S) \
X	v=(R^(R>>16)); \
X	u=(v&E0); \
X	v=(v&E1); \
X	u=((u^(u<<16))^R^s[S  ])<<2; \
X	t=(v^(v<<16))^R^s[S+1]; \
X	t=(t>>2)|(t<<30); \
X	L^= \
X	*(unsigned long *)(des_SP+0x0100+((t    )&0xfc))+ \
X	*(unsigned long *)(des_SP+0x0300+((t>> 8)&0xfc))+ \
X	*(unsigned long *)(des_SP+0x0500+((t>>16)&0xfc))+ \
X	*(unsigned long *)(des_SP+0x0700+((t>>24)&0xfc))+ \
X	*(unsigned long *)(des_SP+       ((u    )&0xfc))+ \
X  	*(unsigned long *)(des_SP+0x0200+((u>> 8)&0xfc))+ \
X  	*(unsigned long *)(des_SP+0x0400+((u>>16)&0xfc))+ \
X 	*(unsigned long *)(des_SP+0x0600+((u>>24)&0xfc));
X#else /* original version */
X#define D_ENCRYPT(L,R,S)	\
X	v=(R^(R>>16)); \
X	u=(v&E0); \
X	v=(v&E1); \
X	u=(u^(u<<16))^R^s[S  ]; \
X	t=(v^(v<<16))^R^s[S+1]; \
X	t=(t>>4)|(t<<28); \
X	L^=	SPtrans[1][(t    )&0x3f]| \
X		SPtrans[3][(t>> 8)&0x3f]| \
X		SPtrans[5][(t>>16)&0x3f]| \
X		SPtrans[7][(t>>24)&0x3f]| \
X		SPtrans[0][(u    )&0x3f]| \
X		SPtrans[2][(u>> 8)&0x3f]| \
X		SPtrans[4][(u>>16)&0x3f]| \
X		SPtrans[6][(u>>24)&0x3f];
X#endif
X
Xunsigned char con_salt[128]={
X0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
X0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
X0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
X0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
X0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
X0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,
X0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,
X0x0A,0x0B,0x05,0x06,0x07,0x08,0x09,0x0A,
X0x0B,0x0C,0x0D,0x0E,0x0F,0x10,0x11,0x12,
X0x13,0x14,0x15,0x16,0x17,0x18,0x19,0x1A,
X0x1B,0x1C,0x1D,0x1E,0x1F,0x20,0x21,0x22,
X0x23,0x24,0x25,0x20,0x21,0x22,0x23,0x24,
X0x25,0x26,0x27,0x28,0x29,0x2A,0x2B,0x2C,
X0x2D,0x2E,0x2F,0x30,0x31,0x32,0x33,0x34,
X0x35,0x36,0x37,0x38,0x39,0x3A,0x3B,0x3C,
X0x3D,0x3E,0x3F,0x00,0x00,0x00,0x00,0x00,
X};
X
Xunsigned char cov_2char[64]={
X0x2E,0x2F,0x30,0x31,0x32,0x33,0x34,0x35,
X0x36,0x37,0x38,0x39,0x41,0x42,0x43,0x44,
X0x45,0x46,0x47,0x48,0x49,0x4A,0x4B,0x4C,
X0x4D,0x4E,0x4F,0x50,0x51,0x52,0x53,0x54,
X0x55,0x56,0x57,0x58,0x59,0x5A,0x61,0x62,
X0x63,0x64,0x65,0x66,0x67,0x68,0x69,0x6A,
X0x6B,0x6C,0x6D,0x6E,0x6F,0x70,0x71,0x72,
X0x73,0x74,0x75,0x76,0x77,0x78,0x79,0x7A
X};
X
Xchar *crypt(buf,salt)
Xchar *buf;
Xchar *salt;
X	{
X	unsigned int i,j,x,y;
X	unsigned long Eswap0=0,Eswap1=0;
X	unsigned long out[2],ll;
X	des_cblock key;
X	des_key_schedule ks;
X	static unsigned char buff[20];
X	unsigned char bb[9];
X	unsigned char *b=bb;
X	unsigned char c,u;
X
X	/* eay 25/08/92
X	 * If you call crypt("pwd","*") as often happens when you
X	 * have * as the pwd field in /etc/passwd, the function
X	 * returns *\0XXXXXXXXX
X	 * The \0 makes the string look like * so the pwd "*" would
X	 * crypt to "*".  This was found when replacing the crypt in
X	 * our shared libraries.  People found that the disbled
X	 * accounts effectivly had no passwd :-(. */
X	if (salt[0] == '\0') salt[0]='A';
X	if (salt[1] == '\0') salt[1]='A';
X	x=buff[0]=salt[0];
X	Eswap0=con_salt[x];
X	x=buff[1]=salt[1];
X	Eswap1=con_salt[x]<<4;
X
X	for (i=0; i<8; i++)
X		{
X		c= *(buf++);
X		if (!c) break;
X		key[i]=(c<<1);
X		}
X	for (; i<8; i++)
X		key[i]=0;
X
X	des_set_key((des_cblock *)(key),ks);
X	body(&out[0],&out[1],ks,Eswap0,Eswap1);
X
X	ll=out[0]; l2c(ll,b);
X	ll=out[1]; l2c(ll,b);
X	y=0;
X	u=0x80;
X	bb[8]=0;
X	for (i=2; i<13; i++)
X		{
X		c=0;
X		for (j=0; j<6; j++)
X			{
X			c<<=1;
X			if (bb[y] & u) c|=1;
X			u>>=1;
X			if (!u)
X				{
X				y++;
X				u=0x80;
X				}
X			}
X		buff[i]=cov_2char[c];
X		}
X	return((char *)buff);
X	}
X
Xstatic int body(out0,out1,ks,Eswap0,Eswap1)
Xunsigned long *out0,*out1;
Xdes_key_schedule *ks;
Xunsigned long Eswap0,Eswap1;
X	{
X	register unsigned long l,r,t,u,v;
X#ifdef ALT_ECB
X	register unsigned char *des_SP=(unsigned char *)SPtrans;
X#endif
X	register unsigned long *s;
X	register int i,j;
X	register unsigned long E0,E1;
X
X	l=0;
X	r=0;
X
X	s=(unsigned long *)ks;
X	E0=Eswap0;
X	E1=Eswap1;
X
X	for (j=0; j<25; j++)
X		{
X		for (i=0; i<(ITERATIONS*2); i+=4)
X			{
X			D_ENCRYPT(l,r,  i);	/*  1 */
X			D_ENCRYPT(r,l,  i+2);	/*  2 */
X			}
X		t=l;
X		l=r;
X		r=t;
X		}
X	t=r;
X	r=(l>>1)|(l<<31);
X	l=(t>>1)|(t<<31);
X	/* clear the top bits on machines with 8byte longs */
X	l&=0xffffffff;
X	r&=0xffffffff;
X
X	PERM_OP(r,l,t, 1,0x55555555);
X	PERM_OP(l,r,t, 8,0x00ff00ff);
X	PERM_OP(r,l,t, 2,0x33333333);
X	PERM_OP(l,r,t,16,0x0000ffff);
X	PERM_OP(r,l,t, 4,0x0f0f0f0f);
X
X	*out0=l;
X	*out1=r;
X	return(0);
X	}
X
END_OF_FILE
  if test 20174 -ne `wc -c <'fcrypt.c'`; then
    echo shar: \"'fcrypt.c'\" unpacked with wrong size!
  fi
  # end of 'fcrypt.c'
fi
if test -f 'des_locl.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'des_locl.h'\"
else
  echo shar: Extracting \"'des_locl.h'\" \(5949 characters\)
  sed "s/^X//" >'des_locl.h' <<'END_OF_FILE'
X/* des_locl.h */
X/* Copyright (C) 1993 Eric Young - see README for more details */
X#include <stdio.h>
X#include "des.h"
X
X#if defined(__STDC__) || defined(VMS) || defined(M_XENIX) || defined(MSDOS)
X#include <string.h>
X#define bcopy(b1,b2,len) memcpy(b2, b1, (size_t)(len))
X#define bzero(b,len) memset(b, 0, (size_t)(len))
X#define bcmp(b1,b2,len) memcmp(b1, b2, (size_t)(len))
X#define index(s1,char) strchr(s1,char)
X#endif
X
X#ifdef MSDOS
X#define getpid() 2
X#define RAND
Xextern int errno;
X#define PROTO
X#endif
X
X#ifdef __STDC__
X#define PROTO
X#endif
X
X#ifdef RAND
X#define random() rand()
X#define srandom(s) srand(s)
X#endif
X
X#define ITERATIONS 16
X#define HALF_ITERATIONS 8
X
X/* used in des_read and des_write */
X#define MAXWRITE	(1024*16)
X#define BSIZE		(MAXWRITE+4)
X
X#define c2l(c,l)	(l =((unsigned long)(*((c)++)))    , \
X			 l|=((unsigned long)(*((c)++)))<< 8, \
X			 l|=((unsigned long)(*((c)++)))<<16, \
X			 l|=((unsigned long)(*((c)++)))<<24)
X
X/* NOTE - c is not incremented as per c2l */
X#define c2ln(c,l1,l2,n)	{ \
X			c+=n; \
X			l1=l2=0; \
X			switch (n) { \
X			case 8: l2|=((unsigned long)(*(--(c))))<<24; \
X			case 7: l2|=((unsigned long)(*(--(c))))<<16; \
X			case 6: l2|=((unsigned long)(*(--(c))))<< 8; \
X			case 5: l2|=((unsigned long)(*(--(c))));     \
X			case 4: l1|=((unsigned long)(*(--(c))))<<24; \
X			case 3: l1|=((unsigned long)(*(--(c))))<<16; \
X			case 2: l1|=((unsigned long)(*(--(c))))<< 8; \
X			case 1: l1|=((unsigned long)(*(--(c))));     \
X				} \
X			}
X
X#define l2c(l,c)	(*((c)++)=(unsigned char)(((l)    )&0xff), \
X			 *((c)++)=(unsigned char)(((l)>> 8)&0xff), \
X			 *((c)++)=(unsigned char)(((l)>>16)&0xff), \
X			 *((c)++)=(unsigned char)(((l)>>24)&0xff))
X
X/* replacements for htonl and ntohl since I have no idea what to do
X * when faced with machines with 8 byte longs. */
X#define HDRSIZE 4
X
X#define n2l(c,l)	(l =((unsigned long)(*((c)++)))<<24, \
X			 l|=((unsigned long)(*((c)++)))<<16, \
X			 l|=((unsigned long)(*((c)++)))<< 8, \
X			 l|=((unsigned long)(*((c)++))))
X
X#define l2n(l,c)	(*((c)++)=(unsigned char)(((l)>>24)&0xff), \
X			 *((c)++)=(unsigned char)(((l)>>16)&0xff), \
X			 *((c)++)=(unsigned char)(((l)>> 8)&0xff), \
X			 *((c)++)=(unsigned char)(((l)    )&0xff))
X
X/* NOTE - c is not incremented as per l2c */
X#define l2cn(l1,l2,c,n)	{ \
X			c+=n; \
X			switch (n) { \
X			case 8: *(--(c))=(unsigned char)(((l2)>>24)&0xff); \
X			case 7: *(--(c))=(unsigned char)(((l2)>>16)&0xff); \
X			case 6: *(--(c))=(unsigned char)(((l2)>> 8)&0xff); \
X			case 5: *(--(c))=(unsigned char)(((l2)    )&0xff); \
X			case 4: *(--(c))=(unsigned char)(((l1)>>24)&0xff); \
X			case 3: *(--(c))=(unsigned char)(((l1)>>16)&0xff); \
X			case 2: *(--(c))=(unsigned char)(((l1)>> 8)&0xff); \
X			case 1: *(--(c))=(unsigned char)(((l1)    )&0xff); \
X				} \
X			}
X
X/* The changes to this macro may help or hinder, depending on the
X * compiler and the achitecture.  gcc2 always seems to do well :-).
X * Inspired by Dana How <how@isl.stanford.edu>
X * DO NOT use the alternative version on machines with 8 byte longs. */
X#ifdef ALT_ECB
X#define D_ENCRYPT(L,R,S) \
X	u=((R^s[S  ])<<2);	\
X	t= R^s[S+1]; \
X	t=((t>>2)+(t<<30)); \
X	L^= \
X	*(unsigned long *)(des_SP+0x0100+((t    )&0xfc))+ \
X	*(unsigned long *)(des_SP+0x0300+((t>> 8)&0xfc))+ \
X	*(unsigned long *)(des_SP+0x0500+((t>>16)&0xfc))+ \
X	*(unsigned long *)(des_SP+0x0700+((t>>24)&0xfc))+ \
X	*(unsigned long *)(des_SP+       ((u    )&0xfc))+ \
X  	*(unsigned long *)(des_SP+0x0200+((u>> 8)&0xfc))+ \
X  	*(unsigned long *)(des_SP+0x0400+((u>>16)&0xfc))+ \
X 	*(unsigned long *)(des_SP+0x0600+((u>>24)&0xfc));
X#else /* original version */
X#ifdef MSDOS
X#define D_ENCRYPT(L,R,S)	\
X	U.l=R^s[S+1]; \
X	T.s[0]=((U.s[0]>>4)|(U.s[1]<<12))&0x3f3f; \
X	T.s[1]=((U.s[1]>>4)|(U.s[0]<<12))&0x3f3f; \
X	U.l=(R^s[S  ])&0x3f3f3f3f; \
X	L^=	des_SPtrans[1][(T.c[0])]| \
X		des_SPtrans[3][(T.c[1])]| \
X		des_SPtrans[5][(T.c[2])]| \
X		des_SPtrans[7][(T.c[3])]| \
X		des_SPtrans[0][(U.c[0])]| \
X		des_SPtrans[2][(U.c[1])]| \
X		des_SPtrans[4][(U.c[2])]| \
X		des_SPtrans[6][(U.c[3])];
X#else
X#define D_ENCRYPT(L,R,S)	\
X	u=(R^s[S  ]); \
X	t=R^s[S+1]; \
X	t=((t>>4)+(t<<28)); \
X	L^=	des_SPtrans[1][(t    )&0x3f]| \
X		des_SPtrans[3][(t>> 8)&0x3f]| \
X		des_SPtrans[5][(t>>16)&0x3f]| \
X		des_SPtrans[7][(t>>24)&0x3f]| \
X		des_SPtrans[0][(u    )&0x3f]| \
X		des_SPtrans[2][(u>> 8)&0x3f]| \
X		des_SPtrans[4][(u>>16)&0x3f]| \
X		des_SPtrans[6][(u>>24)&0x3f];
X#endif
X#endif
X
X	/* IP and FP
X	 * The problem is more of a geometric problem that random bit fiddling.
X	 0  1  2  3  4  5  6  7      62 54 46 38 30 22 14  6
X	 8  9 10 11 12 13 14 15      60 52 44 36 28 20 12  4
X	16 17 18 19 20 21 22 23      58 50 42 34 26 18 10  2
X	24 25 26 27 28 29 30 31  to  56 48 40 32 24 16  8  0
X
X	32 33 34 35 36 37 38 39      63 55 47 39 31 23 15  7
X	40 41 42 43 44 45 46 47      61 53 45 37 29 21 13  5
X	48 49 50 51 52 53 54 55      59 51 43 35 27 19 11  3
X	56 57 58 59 60 61 62 63      57 49 41 33 25 17  9  1
X
X	The output has been subject to swaps of the form
X	0 1 -> 3 1 but the odd and even bits have been put into
X	2 3    2 0
X	different words.  The main trick is to remember that
X	t=((l>>size)^r)&(mask);
X	r^=t;
X	l^=(t<<size);
X	can be used to swap and move bits between words.
X
X	So l =  0  1  2  3  r = 16 17 18 19
X	        4  5  6  7      20 21 22 23
X	        8  9 10 11      24 25 26 27
X	       12 13 14 15      28 29 30 31
X	becomes (for size == 2 and mask == 0x3333)
X	   t =   2^16  3^17 -- --   l =  0  1 16 17  r =  2  3 18 19
X		 6^20  7^21 -- --        4  5 20 21       6  7 22 23
X		10^24 11^25 -- --        8  9 24 25      10 11 24 25
X		14^28 15^29 -- --       12 13 28 29      14 15 28 29
X
X	Thanks for hints from Richard Outerbridge - he told me IP&FP
X	could be done in 15 xor, 10 shifts and 5 ands.
X	When I finally started to think of the problem in 2D
X	I first got ~42 operations without xors.  When I remembered
X	how to use xors :-) I got it to its final state.
X	*/
X#define PERM_OP(a,b,t,n,m) ((t)=((((a)>>(n))^(b))&(m)),\
X	(b)^=(t),\
X	(a)^=((t)<<(n)))
X
END_OF_FILE
  if test 5949 -ne `wc -c <'des_locl.h'`; then
    echo shar: \"'des_locl.h'\" unpacked with wrong size!
  fi
  # end of 'des_locl.h'
fi
if test -f 'podd.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'podd.h'\"
else
  echo shar: Extracting \"'podd.h'\" \(1159 characters\)
  sed "s/^X//" >'podd.h' <<'END_OF_FILE'
X/* podd.h */
X/* Copyright (C) 1993 Eric Young - see README for more details */
Xstatic unsigned char odd_parity[256]={
X  1,  1,  2,  2,  4,  4,  7,  7,  8,  8, 11, 11, 13, 13, 14, 14,
X 16, 16, 19, 19, 21, 21, 22, 22, 25, 25, 26, 26, 28, 28, 31, 31,
X 32, 32, 35, 35, 37, 37, 38, 38, 41, 41, 42, 42, 44, 44, 47, 47,
X 49, 49, 50, 50, 52, 52, 55, 55, 56, 56, 59, 59, 61, 61, 62, 62,
X 64, 64, 67, 67, 69, 69, 70, 70, 73, 73, 74, 74, 76, 76, 79, 79,
X 81, 81, 82, 82, 84, 84, 87, 87, 88, 88, 91, 91, 93, 93, 94, 94,
X 97, 97, 98, 98,100,100,103,103,104,104,107,107,109,109,110,110,
X112,112,115,115,117,117,118,118,121,121,122,122,124,124,127,127,
X128,128,131,131,133,133,134,134,137,137,138,138,140,140,143,143,
X145,145,146,146,148,148,151,151,152,152,155,155,157,157,158,158,
X161,161,162,162,164,164,167,167,168,168,171,171,173,173,174,174,
X176,176,179,179,181,181,182,182,185,185,186,186,188,188,191,191,
X193,193,194,194,196,196,199,199,200,200,203,203,205,205,206,206,
X208,208,211,211,213,213,214,214,217,217,218,218,220,220,223,223,
X224,224,227,227,229,229,230,230,233,233,234,234,236,236,239,239,
X241,241,242,242,244,244,247,247,248,248,251,251,253,253,254,254};
END_OF_FILE
  if test 1159 -ne `wc -c <'podd.h'`; then
    echo shar: \"'podd.h'\" unpacked with wrong size!
  fi
  # end of 'podd.h'
fi
if test -f 'sk.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'sk.h'\"
else
  echo shar: Extracting \"'sk.h'\" \(6350 characters\)
  sed "s/^X//" >'sk.h' <<'END_OF_FILE'
X/* sk.h */
X/* Copyright (C) 1993 Eric Young - see README for more details */
Xstatic unsigned long des_skb[8][64]={
X/* for C bits (numbered as per FIPS 46) 1 2 3 4 5 6 */
X0x00000000,0x00000010,0x20000000,0x20000010,
X0x00010000,0x00010010,0x20010000,0x20010010,
X0x00000800,0x00000810,0x20000800,0x20000810,
X0x00010800,0x00010810,0x20010800,0x20010810,
X0x00000020,0x00000030,0x20000020,0x20000030,
X0x00010020,0x00010030,0x20010020,0x20010030,
X0x00000820,0x00000830,0x20000820,0x20000830,
X0x00010820,0x00010830,0x20010820,0x20010830,
X0x00080000,0x00080010,0x20080000,0x20080010,
X0x00090000,0x00090010,0x20090000,0x20090010,
X0x00080800,0x00080810,0x20080800,0x20080810,
X0x00090800,0x00090810,0x20090800,0x20090810,
X0x00080020,0x00080030,0x20080020,0x20080030,
X0x00090020,0x00090030,0x20090020,0x20090030,
X0x00080820,0x00080830,0x20080820,0x20080830,
X0x00090820,0x00090830,0x20090820,0x20090830,
X/* for C bits (numbered as per FIPS 46) 7 8 10 11 12 13 */
X0x00000000,0x02000000,0x00002000,0x02002000,
X0x00200000,0x02200000,0x00202000,0x02202000,
X0x00000004,0x02000004,0x00002004,0x02002004,
X0x00200004,0x02200004,0x00202004,0x02202004,
X0x00000400,0x02000400,0x00002400,0x02002400,
X0x00200400,0x02200400,0x00202400,0x02202400,
X0x00000404,0x02000404,0x00002404,0x02002404,
X0x00200404,0x02200404,0x00202404,0x02202404,
X0x10000000,0x12000000,0x10002000,0x12002000,
X0x10200000,0x12200000,0x10202000,0x12202000,
X0x10000004,0x12000004,0x10002004,0x12002004,
X0x10200004,0x12200004,0x10202004,0x12202004,
X0x10000400,0x12000400,0x10002400,0x12002400,
X0x10200400,0x12200400,0x10202400,0x12202400,
X0x10000404,0x12000404,0x10002404,0x12002404,
X0x10200404,0x12200404,0x10202404,0x12202404,
X/* for C bits (numbered as per FIPS 46) 14 15 16 17 19 20 */
X0x00000000,0x00000001,0x00040000,0x00040001,
X0x01000000,0x01000001,0x01040000,0x01040001,
X0x00000002,0x00000003,0x00040002,0x00040003,
X0x01000002,0x01000003,0x01040002,0x01040003,
X0x00000200,0x00000201,0x00040200,0x00040201,
X0x01000200,0x01000201,0x01040200,0x01040201,
X0x00000202,0x00000203,0x00040202,0x00040203,
X0x01000202,0x01000203,0x01040202,0x01040203,
X0x08000000,0x08000001,0x08040000,0x08040001,
X0x09000000,0x09000001,0x09040000,0x09040001,
X0x08000002,0x08000003,0x08040002,0x08040003,
X0x09000002,0x09000003,0x09040002,0x09040003,
X0x08000200,0x08000201,0x08040200,0x08040201,
X0x09000200,0x09000201,0x09040200,0x09040201,
X0x08000202,0x08000203,0x08040202,0x08040203,
X0x09000202,0x09000203,0x09040202,0x09040203,
X/* for C bits (numbered as per FIPS 46) 21 23 24 26 27 28 */
X0x00000000,0x00100000,0x00000100,0x00100100,
X0x00000008,0x00100008,0x00000108,0x00100108,
X0x00001000,0x00101000,0x00001100,0x00101100,
X0x00001008,0x00101008,0x00001108,0x00101108,
X0x04000000,0x04100000,0x04000100,0x04100100,
X0x04000008,0x04100008,0x04000108,0x04100108,
X0x04001000,0x04101000,0x04001100,0x04101100,
X0x04001008,0x04101008,0x04001108,0x04101108,
X0x00020000,0x00120000,0x00020100,0x00120100,
X0x00020008,0x00120008,0x00020108,0x00120108,
X0x00021000,0x00121000,0x00021100,0x00121100,
X0x00021008,0x00121008,0x00021108,0x00121108,
X0x04020000,0x04120000,0x04020100,0x04120100,
X0x04020008,0x04120008,0x04020108,0x04120108,
X0x04021000,0x04121000,0x04021100,0x04121100,
X0x04021008,0x04121008,0x04021108,0x04121108,
X/* for D bits (numbered as per FIPS 46) 1 2 3 4 5 6 */
X0x00000000,0x10000000,0x00010000,0x10010000,
X0x00000004,0x10000004,0x00010004,0x10010004,
X0x20000000,0x30000000,0x20010000,0x30010000,
X0x20000004,0x30000004,0x20010004,0x30010004,
X0x00100000,0x10100000,0x00110000,0x10110000,
X0x00100004,0x10100004,0x00110004,0x10110004,
X0x20100000,0x30100000,0x20110000,0x30110000,
X0x20100004,0x30100004,0x20110004,0x30110004,
X0x00001000,0x10001000,0x00011000,0x10011000,
X0x00001004,0x10001004,0x00011004,0x10011004,
X0x20001000,0x30001000,0x20011000,0x30011000,
X0x20001004,0x30001004,0x20011004,0x30011004,
X0x00101000,0x10101000,0x00111000,0x10111000,
X0x00101004,0x10101004,0x00111004,0x10111004,
X0x20101000,0x30101000,0x20111000,0x30111000,
X0x20101004,0x30101004,0x20111004,0x30111004,
X/* for D bits (numbered as per FIPS 46) 8 9 11 12 13 14 */
X0x00000000,0x08000000,0x00000008,0x08000008,
X0x00000400,0x08000400,0x00000408,0x08000408,
X0x00020000,0x08020000,0x00020008,0x08020008,
X0x00020400,0x08020400,0x00020408,0x08020408,
X0x00000001,0x08000001,0x00000009,0x08000009,
X0x00000401,0x08000401,0x00000409,0x08000409,
X0x00020001,0x08020001,0x00020009,0x08020009,
X0x00020401,0x08020401,0x00020409,0x08020409,
X0x02000000,0x0A000000,0x02000008,0x0A000008,
X0x02000400,0x0A000400,0x02000408,0x0A000408,
X0x02020000,0x0A020000,0x02020008,0x0A020008,
X0x02020400,0x0A020400,0x02020408,0x0A020408,
X0x02000001,0x0A000001,0x02000009,0x0A000009,
X0x02000401,0x0A000401,0x02000409,0x0A000409,
X0x02020001,0x0A020001,0x02020009,0x0A020009,
X0x02020401,0x0A020401,0x02020409,0x0A020409,
X/* for D bits (numbered as per FIPS 46) 16 17 18 19 20 21 */
X0x00000000,0x00000100,0x00080000,0x00080100,
X0x01000000,0x01000100,0x01080000,0x01080100,
X0x00000010,0x00000110,0x00080010,0x00080110,
X0x01000010,0x01000110,0x01080010,0x01080110,
X0x00200000,0x00200100,0x00280000,0x00280100,
X0x01200000,0x01200100,0x01280000,0x01280100,
X0x00200010,0x00200110,0x00280010,0x00280110,
X0x01200010,0x01200110,0x01280010,0x01280110,
X0x00000200,0x00000300,0x00080200,0x00080300,
X0x01000200,0x01000300,0x01080200,0x01080300,
X0x00000210,0x00000310,0x00080210,0x00080310,
X0x01000210,0x01000310,0x01080210,0x01080310,
X0x00200200,0x00200300,0x00280200,0x00280300,
X0x01200200,0x01200300,0x01280200,0x01280300,
X0x00200210,0x00200310,0x00280210,0x00280310,
X0x01200210,0x01200310,0x01280210,0x01280310,
X/* for D bits (numbered as per FIPS 46) 22 23 24 25 27 28 */
X0x00000000,0x04000000,0x00040000,0x04040000,
X0x00000002,0x04000002,0x00040002,0x04040002,
X0x00002000,0x04002000,0x00042000,0x04042000,
X0x00002002,0x04002002,0x00042002,0x04042002,
X0x00000020,0x04000020,0x00040020,0x04040020,
X0x00000022,0x04000022,0x00040022,0x04040022,
X0x00002020,0x04002020,0x00042020,0x04042020,
X0x00002022,0x04002022,0x00042022,0x04042022,
X0x00000800,0x04000800,0x00040800,0x04040800,
X0x00000802,0x04000802,0x00040802,0x04040802,
X0x00002800,0x04002800,0x00042800,0x04042800,
X0x00002802,0x04002802,0x00042802,0x04042802,
X0x00000820,0x04000820,0x00040820,0x04040820,
X0x00000822,0x04000822,0x00040822,0x04040822,
X0x00002820,0x04002820,0x00042820,0x04042820,
X0x00002822,0x04002822,0x00042822,0x04042822,
X};
END_OF_FILE
  if test 6350 -ne `wc -c <'sk.h'`; then
    echo shar: \"'sk.h'\" unpacked with wrong size!
  fi
  # end of 'sk.h'
fi
if test -f 'spr.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'spr.h'\"
else
  echo shar: Extracting \"'spr.h'\" \(6392 characters\)
  sed "s/^X//" >'spr.h' <<'END_OF_FILE'
X/* spr.h */
X/* Copyright (C) 1993 Eric Young - see README for more details */
Xstatic unsigned long des_SPtrans[8][64]={
X/* nibble 0 */
X0x00820200, 0x00020000, 0x80800000, 0x80820200,
X0x00800000, 0x80020200, 0x80020000, 0x80800000,
X0x80020200, 0x00820200, 0x00820000, 0x80000200,
X0x80800200, 0x00800000, 0x00000000, 0x80020000,
X0x00020000, 0x80000000, 0x00800200, 0x00020200,
X0x80820200, 0x00820000, 0x80000200, 0x00800200,
X0x80000000, 0x00000200, 0x00020200, 0x80820000,
X0x00000200, 0x80800200, 0x80820000, 0x00000000,
X0x00000000, 0x80820200, 0x00800200, 0x80020000,
X0x00820200, 0x00020000, 0x80000200, 0x00800200,
X0x80820000, 0x00000200, 0x00020200, 0x80800000,
X0x80020200, 0x80000000, 0x80800000, 0x00820000,
X0x80820200, 0x00020200, 0x00820000, 0x80800200,
X0x00800000, 0x80000200, 0x80020000, 0x00000000,
X0x00020000, 0x00800000, 0x80800200, 0x00820200,
X0x80000000, 0x80820000, 0x00000200, 0x80020200,
X
X/* nibble 1 */
X0x10042004, 0x00000000, 0x00042000, 0x10040000,
X0x10000004, 0x00002004, 0x10002000, 0x00042000,
X0x00002000, 0x10040004, 0x00000004, 0x10002000,
X0x00040004, 0x10042000, 0x10040000, 0x00000004,
X0x00040000, 0x10002004, 0x10040004, 0x00002000,
X0x00042004, 0x10000000, 0x00000000, 0x00040004,
X0x10002004, 0x00042004, 0x10042000, 0x10000004,
X0x10000000, 0x00040000, 0x00002004, 0x10042004,
X0x00040004, 0x10042000, 0x10002000, 0x00042004,
X0x10042004, 0x00040004, 0x10000004, 0x00000000,
X0x10000000, 0x00002004, 0x00040000, 0x10040004,
X0x00002000, 0x10000000, 0x00042004, 0x10002004,
X0x10042000, 0x00002000, 0x00000000, 0x10000004,
X0x00000004, 0x10042004, 0x00042000, 0x10040000,
X0x10040004, 0x00040000, 0x00002004, 0x10002000,
X0x10002004, 0x00000004, 0x10040000, 0x00042000,
X
X/* nibble 2 */
X0x41000000, 0x01010040, 0x00000040, 0x41000040,
X0x40010000, 0x01000000, 0x41000040, 0x00010040,
X0x01000040, 0x00010000, 0x01010000, 0x40000000,
X0x41010040, 0x40000040, 0x40000000, 0x41010000,
X0x00000000, 0x40010000, 0x01010040, 0x00000040,
X0x40000040, 0x41010040, 0x00010000, 0x41000000,
X0x41010000, 0x01000040, 0x40010040, 0x01010000,
X0x00010040, 0x00000000, 0x01000000, 0x40010040,
X0x01010040, 0x00000040, 0x40000000, 0x00010000,
X0x40000040, 0x40010000, 0x01010000, 0x41000040,
X0x00000000, 0x01010040, 0x00010040, 0x41010000,
X0x40010000, 0x01000000, 0x41010040, 0x40000000,
X0x40010040, 0x41000000, 0x01000000, 0x41010040,
X0x00010000, 0x01000040, 0x41000040, 0x00010040,
X0x01000040, 0x00000000, 0x41010000, 0x40000040,
X0x41000000, 0x40010040, 0x00000040, 0x01010000,
X
X/* nibble 3 */
X0x00100402, 0x04000400, 0x00000002, 0x04100402,
X0x00000000, 0x04100000, 0x04000402, 0x00100002,
X0x04100400, 0x04000002, 0x04000000, 0x00000402,
X0x04000002, 0x00100402, 0x00100000, 0x04000000,
X0x04100002, 0x00100400, 0x00000400, 0x00000002,
X0x00100400, 0x04000402, 0x04100000, 0x00000400,
X0x00000402, 0x00000000, 0x00100002, 0x04100400,
X0x04000400, 0x04100002, 0x04100402, 0x00100000,
X0x04100002, 0x00000402, 0x00100000, 0x04000002,
X0x00100400, 0x04000400, 0x00000002, 0x04100000,
X0x04000402, 0x00000000, 0x00000400, 0x00100002,
X0x00000000, 0x04100002, 0x04100400, 0x00000400,
X0x04000000, 0x04100402, 0x00100402, 0x00100000,
X0x04100402, 0x00000002, 0x04000400, 0x00100402,
X0x00100002, 0x00100400, 0x04100000, 0x04000402,
X0x00000402, 0x04000000, 0x04000002, 0x04100400,
X
X/* nibble 4 */
X0x02000000, 0x00004000, 0x00000100, 0x02004108,
X0x02004008, 0x02000100, 0x00004108, 0x02004000,
X0x00004000, 0x00000008, 0x02000008, 0x00004100,
X0x02000108, 0x02004008, 0x02004100, 0x00000000,
X0x00004100, 0x02000000, 0x00004008, 0x00000108,
X0x02000100, 0x00004108, 0x00000000, 0x02000008,
X0x00000008, 0x02000108, 0x02004108, 0x00004008,
X0x02004000, 0x00000100, 0x00000108, 0x02004100,
X0x02004100, 0x02000108, 0x00004008, 0x02004000,
X0x00004000, 0x00000008, 0x02000008, 0x02000100,
X0x02000000, 0x00004100, 0x02004108, 0x00000000,
X0x00004108, 0x02000000, 0x00000100, 0x00004008,
X0x02000108, 0x00000100, 0x00000000, 0x02004108,
X0x02004008, 0x02004100, 0x00000108, 0x00004000,
X0x00004100, 0x02004008, 0x02000100, 0x00000108,
X0x00000008, 0x00004108, 0x02004000, 0x02000008,
X
X/* nibble 5 */
X0x20000010, 0x00080010, 0x00000000, 0x20080800,
X0x00080010, 0x00000800, 0x20000810, 0x00080000,
X0x00000810, 0x20080810, 0x00080800, 0x20000000,
X0x20000800, 0x20000010, 0x20080000, 0x00080810,
X0x00080000, 0x20000810, 0x20080010, 0x00000000,
X0x00000800, 0x00000010, 0x20080800, 0x20080010,
X0x20080810, 0x20080000, 0x20000000, 0x00000810,
X0x00000010, 0x00080800, 0x00080810, 0x20000800,
X0x00000810, 0x20000000, 0x20000800, 0x00080810,
X0x20080800, 0x00080010, 0x00000000, 0x20000800,
X0x20000000, 0x00000800, 0x20080010, 0x00080000,
X0x00080010, 0x20080810, 0x00080800, 0x00000010,
X0x20080810, 0x00080800, 0x00080000, 0x20000810,
X0x20000010, 0x20080000, 0x00080810, 0x00000000,
X0x00000800, 0x20000010, 0x20000810, 0x20080800,
X0x20080000, 0x00000810, 0x00000010, 0x20080010,
X
X/* nibble 6 */
X0x00001000, 0x00000080, 0x00400080, 0x00400001,
X0x00401081, 0x00001001, 0x00001080, 0x00000000,
X0x00400000, 0x00400081, 0x00000081, 0x00401000,
X0x00000001, 0x00401080, 0x00401000, 0x00000081,
X0x00400081, 0x00001000, 0x00001001, 0x00401081,
X0x00000000, 0x00400080, 0x00400001, 0x00001080,
X0x00401001, 0x00001081, 0x00401080, 0x00000001,
X0x00001081, 0x00401001, 0x00000080, 0x00400000,
X0x00001081, 0x00401000, 0x00401001, 0x00000081,
X0x00001000, 0x00000080, 0x00400000, 0x00401001,
X0x00400081, 0x00001081, 0x00001080, 0x00000000,
X0x00000080, 0x00400001, 0x00000001, 0x00400080,
X0x00000000, 0x00400081, 0x00400080, 0x00001080,
X0x00000081, 0x00001000, 0x00401081, 0x00400000,
X0x00401080, 0x00000001, 0x00001001, 0x00401081,
X0x00400001, 0x00401080, 0x00401000, 0x00001001,
X
X/* nibble 7 */
X0x08200020, 0x08208000, 0x00008020, 0x00000000,
X0x08008000, 0x00200020, 0x08200000, 0x08208020,
X0x00000020, 0x08000000, 0x00208000, 0x00008020,
X0x00208020, 0x08008020, 0x08000020, 0x08200000,
X0x00008000, 0x00208020, 0x00200020, 0x08008000,
X0x08208020, 0x08000020, 0x00000000, 0x00208000,
X0x08000000, 0x00200000, 0x08008020, 0x08200020,
X0x00200000, 0x00008000, 0x08208000, 0x00000020,
X0x00200000, 0x00008000, 0x08000020, 0x08208020,
X0x00008020, 0x08000000, 0x00000000, 0x00208000,
X0x08200020, 0x08008020, 0x08008000, 0x00200020,
X0x08208000, 0x00000020, 0x00200020, 0x08008000,
X0x08208020, 0x00200000, 0x08200000, 0x08000020,
X0x00208000, 0x00008020, 0x08008020, 0x08200000,
X0x00000020, 0x08208000, 0x00208020, 0x00000000,
X0x08000000, 0x08200020, 0x00008000, 0x00208020};
END_OF_FILE
  if test 6392 -ne `wc -c <'spr.h'`; then
    echo shar: \"'spr.h'\" unpacked with wrong size!
  fi
  # end of 'spr.h'
fi
if test -f 'cfb_enc.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'cfb_enc.c'\"
else
  echo shar: Extracting \"'cfb_enc.c'\" \(2172 characters\)
  sed "s/^X//" >'cfb_enc.c' <<'END_OF_FILE'
X/* cfb_enc.c */
X/* Copyright (C) 1993 Eric Young - see README for more details */
X#include "des_locl.h"
X
X/* The input and output are loaded in multiples of 8 bits.
X * What this means is that if you hame numbits=12 and length=2
X * the first 12 bits will be retrieved from the first byte and half
X * the second.  The second 12 bits will come from the 3rd and half the 4th
X * byte.
X */
Xint des_cfb_encrypt(in,out,numbits,length,schedule,ivec,encrypt)
Xunsigned char *in,*out;
Xint numbits;
Xlong length;
Xdes_key_schedule schedule;
Xdes_cblock *ivec;
Xint encrypt;
X	{
X	register unsigned long d0,d1,v0,v1,n=(numbits+7)/8;
X	register unsigned long mask0,mask1;
X	register long l=length;
X	register int num=numbits;
X	unsigned long ti[2],to[2];
X	unsigned char *iv;
X
X	if (num > 64) return(0);
X	if (num > 32)
X		{
X		mask0=0xffffffff;
X		if (num == 64)
X			mask1=mask0;
X		else
X			mask1=(1L<<(num-32))-1;
X		}
X	else
X		{
X		if (num == 32)
X			mask0=0xffffffff;
X		else
X			mask0=(1L<<num)-1;
X		mask1=0x00000000;
X		}
X
X	iv=(unsigned char *)ivec;
X	c2l(iv,v0);
X	c2l(iv,v1);
X	if (encrypt)
X		{
X		while (l-- > 0)
X			{
X			ti[0]=v0;
X			ti[1]=v1;
X			des_encrypt((unsigned long *)ti,(unsigned long *)to,
X					schedule,DES_ENCRYPT);
X			c2ln(in,d0,d1,n);
X			in+=n;
X			d0=(d0^to[0])&mask0;
X			d1=(d1^to[1])&mask1;
X			l2cn(d0,d1,out,n);
X			out+=n;
X			if (num > 32)
X				{
X				v0=((v1>>(num-32))|(d0<<(64-num)))&0xffffffff;
X				v1=((d0>>(num-32))|(d1<<(64-num)))&0xffffffff;
X				}
X			else
X				{
X				v0=((v0>>num)|(v1<<(32-num)))&0xffffffff;
X				v1=((v1>>num)|(d0<<(32-num)))&0xffffffff;
X				}
X			}
X		}
X	else
X		{
X		while (l-- > 0)
X			{
X			ti[0]=v0;
X			ti[1]=v1;
X			des_encrypt((unsigned long *)ti,(unsigned long *)to,
X					schedule,DES_ENCRYPT);
X			c2ln(in,d0,d1,n);
X			in+=n;
X			if (num > 32)
X				{
X				v0=((v1>>(num-32))|(d0<<(64-num)))&0xffffffff;
X				v1=((d0>>(num-32))|(d1<<(64-num)))&0xffffffff;
X				}
X			else
X				{
X				v0=((v0>>num)|(v1<<(32-num)))&0xffffffff;
X				v1=((v1>>num)|(d0<<(32-num)))&0xffffffff;
X				}
X			d0=(d0^to[0])&mask0;
X			d1=(d1^to[1])&mask1;
X			l2cn(d0,d1,out,n);
X			out+=n;
X			}
X		}
X	iv=(unsigned char *)ivec;
X	l2c(v0,iv);
X	l2c(v1,iv);
X	v0=v1=d0=d1=ti[0]=ti[1]=to[0]=to[1]=0;
X	return(0);
X	}
X
END_OF_FILE
  if test 2172 -ne `wc -c <'cfb_enc.c'`; then
    echo shar: \"'cfb_enc.c'\" unpacked with wrong size!
  fi
  # end of 'cfb_enc.c'
fi
if test -f '3ecb_enc.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'3ecb_enc.c'\"
else
  echo shar: Extracting \"'3ecb_enc.c'\" \(600 characters\)
  sed "s/^X//" >'3ecb_enc.c' <<'END_OF_FILE'
X/* 3ecb_enc.c */
X/* Copyright (C) 1993 Eric Young - see README for more details */
X#include "des_locl.h"
X
Xint des_3ecb_encrypt(input,output,ks1,ks2,encrypt)
Xdes_cblock *input;
Xdes_cblock *output;
Xdes_key_schedule ks1,ks2;
Xint encrypt;
X	{
X	register unsigned long l0,l1,t;
X	register unsigned char *in,*out;
X	unsigned long ll[2];
X
X	in=(unsigned char *)input;
X	out=(unsigned char *)output;
X	c2l(in,l0);
X	c2l(in,l1);
X	ll[0]=l0;
X	ll[1]=l1;
X	des_encrypt(ll,ll,ks1,encrypt);
X	des_encrypt(ll,ll,ks2,!encrypt);
X	des_encrypt(ll,ll,ks1,encrypt);
X	l0=ll[0];
X	l1=ll[1];
X	l2c(l0,out);
X	l2c(l1,out);
X	return(0);
X	}
X
END_OF_FILE
  if test 600 -ne `wc -c <'3ecb_enc.c'`; then
    echo shar: \"'3ecb_enc.c'\" unpacked with wrong size!
  fi
  # end of '3ecb_enc.c'
fi
if test -f 'ofb_enc.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'ofb_enc.c'\"
else
  echo shar: Extracting \"'ofb_enc.c'\" \(1368 characters\)
  sed "s/^X//" >'ofb_enc.c' <<'END_OF_FILE'
X/* ofb_enc.c */
X/* Copyright (C) 1993 Eric Young - see README for more details */
X#include "des_locl.h"
X
X/* The input and output are loaded in multiples of 8 bits.
X * What this means is that if you hame numbits=12 and length=2
X * the first 12 bits will be retrieved from the first byte and half
X * the second.  The second 12 bits will come from the 3rd and half the 4th
X * byte.
X */
Xint des_ofb_encrypt(in,out,numbits,length,schedule,ivec)
Xunsigned char *in,*out;
Xint numbits;
Xlong length;
Xdes_key_schedule schedule;
Xdes_cblock *ivec;
X	{
X	register unsigned long d0,d1,v0,v1,n=(numbits+7)/8;
X	register unsigned long mask0,mask1;
X	register long l=length;
X	register int num=numbits;
X	unsigned long ti[2];
X	unsigned char *iv;
X
X	if (num > 64) return(0);
X	if (num > 32)
X		{
X		mask0=0xffffffff;
X		if (num >= 64)
X			mask1=mask0;
X		else
X			mask1=(1L<<(num-32))-1;
X		}
X	else
X		{
X		if (num == 32)
X			mask0=0xffffffff;
X		else
X			mask0=(1L<<num)-1;
X		mask1=0x00000000;
X		}
X
X	iv=(unsigned char *)ivec;
X	c2l(iv,v0);
X	c2l(iv,v1);
X	ti[0]=v0;
X	ti[1]=v1;
X	while (l-- > 0)
X		{
X		des_encrypt((unsigned long *)ti,(unsigned long *)ti,
X				schedule,DES_ENCRYPT);
X		c2ln(in,d0,d1,n);
X		in+=n;
X		d0=(d0^ti[0])&mask0;
X		d1=(d1^ti[1])&mask1;
X		l2cn(d0,d1,out,n);
X		out+=n;
X		}
X	v0=ti[0];
X	v1=ti[1];
X	iv=(unsigned char *)ivec;
X	l2c(v0,iv);
X	l2c(v1,iv);
X	v0=v1=d0=d1=ti[0]=ti[1]=0;
X	return(0);
X	}
X
END_OF_FILE
  if test 1368 -ne `wc -c <'ofb_enc.c'`; then
    echo shar: \"'ofb_enc.c'\" unpacked with wrong size!
  fi
  # end of 'ofb_enc.c'
fi
if test -f '3cbc_enc.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'3cbc_enc.c'\"
else
  echo shar: Extracting \"'3cbc_enc.c'\" \(1370 characters\)
  sed "s/^X//" >'3cbc_enc.c' <<'END_OF_FILE'
X/* 3cbc_enc.c */
X/* Copyright (C) 1993 Eric Young - see README for more details */
X#include "des_locl.h"
X
Xint des_3cbc_encrypt(input,output,length,ks1,ks2,iv1,iv2,encrypt)
Xdes_cblock *input;
Xdes_cblock *output;
Xlong length;
Xdes_key_schedule ks1,ks2;
Xdes_cblock *iv1,*iv2;
Xint encrypt;
X	{
X	int off=length/8-1;
X	des_cblock niv1,niv2;
X
Xprintf("3cbc\n");
Xxp(iv1);
Xxp(iv1);
Xxp(iv2);
Xxp(input);
X	if (encrypt == DES_ENCRYPT)
X		{
X		des_cbc_encrypt(input,output,length,ks1,iv1,encrypt);
X		if (length >= sizeof(des_cblock))
X			bcopy(output[off],niv1,sizeof(des_cblock));
X		des_cbc_encrypt(output,output,length,ks2,iv1,!encrypt);
X		des_cbc_encrypt(output,output,length,ks1,iv2, encrypt);
X		if (length >= sizeof(des_cblock))
X			bcopy(output[off],niv2,sizeof(des_cblock));
X		bcopy(niv1,*iv1,sizeof(des_cblock));
X		}
X	else
X		{
X		if (length >= sizeof(des_cblock))
X			bcopy(input[off],niv1,sizeof(des_cblock));
X		des_cbc_encrypt(input,output,length,ks1,iv1,encrypt);
X		des_cbc_encrypt(output,output,length,ks2,iv2,!encrypt);
X		if (length >= sizeof(des_cblock))
X			bcopy(output[off],niv2,sizeof(des_cblock));
X		des_cbc_encrypt(output,output,length,ks1,iv2, encrypt);
X		}
X	bcopy(niv1,iv1,sizeof(des_cblock));
X	bcopy(niv2,iv2,sizeof(des_cblock));
Xxp(iv1);
Xxp(iv1);
Xxp(iv2);
Xxp(output);
X	return(0);
X	}
X
Xxp(a)
Xunsigned char *a;
X{ int i; for(i=0; i<8; i++) printf("%02X",a[i]);printf("\n");}
END_OF_FILE
  if test 1370 -ne `wc -c <'3cbc_enc.c'`; then
    echo shar: \"'3cbc_enc.c'\" unpacked with wrong size!
  fi
  # end of '3cbc_enc.c'
fi
if test -f 'des.pl' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'des.pl'\"
else
  echo shar: Extracting \"'des.pl'\" \(17839 characters\)
  sed "s/^X//" >'des.pl' <<'END_OF_FILE'
X#!/usr/local/bin/perl
X# Copyright (C) 1993 Eric Young
X# des.pl - eric young 22/11/1991 eay@psych.psy.uq.oz.au
X# eay - 92/08/31 - I think I have fixed all problems for 64bit
X# versions of perl but I could be wrong since I have not tested it yet :-).
X#
X# This is an implementation of DES in perl.
X# The two routines (des_set_key and des_ecb_encrypt)
X# take 8 byte objects as arguments.
X#
X# des_set_key takes an 8 byte string as a key and returns a key schedule
X# for use in calls to des_ecb_encrypt.
X# des_ecb_encrypt takes three arguments, the first is a key schedule
X# (make sure to pass it by reference with the *), the second is 1
X# to encrypt, 0 to decrypt.  The third argument is an 8 byte object
X# to encrypt.  The function returns an 8 byte object that has been
X# DES encrypted.
X#
X# example:
X# require 'des.pl'
X#
X# $key =pack("C8",0x12,0x23,0x45,0x67,0x89,0xab,0xcd,0xef);
X# @ks=  &des_set_key($key);
X#
X# $outbytes= &des_ecb_encrypt(*ks,1,$data);
X# @enc =unpack("C8",$outbytes);
X#
X
Xpackage des;
X
X# The following 8 arrays are used in des_set_key
X@skb0=(
X# for C bits (numbered as per FIPS 46) 1 2 3 4 5 6 
X0x00000000,0x00000010,0x20000000,0x20000010,
X0x00010000,0x00010010,0x20010000,0x20010010,
X0x00000800,0x00000810,0x20000800,0x20000810,
X0x00010800,0x00010810,0x20010800,0x20010810,
X0x00000020,0x00000030,0x20000020,0x20000030,
X0x00010020,0x00010030,0x20010020,0x20010030,
X0x00000820,0x00000830,0x20000820,0x20000830,
X0x00010820,0x00010830,0x20010820,0x20010830,
X0x00080000,0x00080010,0x20080000,0x20080010,
X0x00090000,0x00090010,0x20090000,0x20090010,
X0x00080800,0x00080810,0x20080800,0x20080810,
X0x00090800,0x00090810,0x20090800,0x20090810,
X0x00080020,0x00080030,0x20080020,0x20080030,
X0x00090020,0x00090030,0x20090020,0x20090030,
X0x00080820,0x00080830,0x20080820,0x20080830,
X0x00090820,0x00090830,0x20090820,0x20090830,
X);
X@skb1=(
X# for C bits (numbered as per FIPS 46) 7 8 10 11 12 13 
X0x00000000,0x02000000,0x00002000,0x02002000,
X0x00200000,0x02200000,0x00202000,0x02202000,
X0x00000004,0x02000004,0x00002004,0x02002004,
X0x00200004,0x02200004,0x00202004,0x02202004,
X0x00000400,0x02000400,0x00002400,0x02002400,
X0x00200400,0x02200400,0x00202400,0x02202400,
X0x00000404,0x02000404,0x00002404,0x02002404,
X0x00200404,0x02200404,0x00202404,0x02202404,
X0x10000000,0x12000000,0x10002000,0x12002000,
X0x10200000,0x12200000,0x10202000,0x12202000,
X0x10000004,0x12000004,0x10002004,0x12002004,
X0x10200004,0x12200004,0x10202004,0x12202004,
X0x10000400,0x12000400,0x10002400,0x12002400,
X0x10200400,0x12200400,0x10202400,0x12202400,
X0x10000404,0x12000404,0x10002404,0x12002404,
X0x10200404,0x12200404,0x10202404,0x12202404,
X);
X@skb2=(
X# for C bits (numbered as per FIPS 46) 14 15 16 17 19 20 
X0x00000000,0x00000001,0x00040000,0x00040001,
X0x01000000,0x01000001,0x01040000,0x01040001,
X0x00000002,0x00000003,0x00040002,0x00040003,
X0x01000002,0x01000003,0x01040002,0x01040003,
X0x00000200,0x00000201,0x00040200,0x00040201,
X0x01000200,0x01000201,0x01040200,0x01040201,
X0x00000202,0x00000203,0x00040202,0x00040203,
X0x01000202,0x01000203,0x01040202,0x01040203,
X0x08000000,0x08000001,0x08040000,0x08040001,
X0x09000000,0x09000001,0x09040000,0x09040001,
X0x08000002,0x08000003,0x08040002,0x08040003,
X0x09000002,0x09000003,0x09040002,0x09040003,
X0x08000200,0x08000201,0x08040200,0x08040201,
X0x09000200,0x09000201,0x09040200,0x09040201,
X0x08000202,0x08000203,0x08040202,0x08040203,
X0x09000202,0x09000203,0x09040202,0x09040203,
X);
X@skb3=(
X# for C bits (numbered as per FIPS 46) 21 23 24 26 27 28 
X0x00000000,0x00100000,0x00000100,0x00100100,
X0x00000008,0x00100008,0x00000108,0x00100108,
X0x00001000,0x00101000,0x00001100,0x00101100,
X0x00001008,0x00101008,0x00001108,0x00101108,
X0x04000000,0x04100000,0x04000100,0x04100100,
X0x04000008,0x04100008,0x04000108,0x04100108,
X0x04001000,0x04101000,0x04001100,0x04101100,
X0x04001008,0x04101008,0x04001108,0x04101108,
X0x00020000,0x00120000,0x00020100,0x00120100,
X0x00020008,0x00120008,0x00020108,0x00120108,
X0x00021000,0x00121000,0x00021100,0x00121100,
X0x00021008,0x00121008,0x00021108,0x00121108,
X0x04020000,0x04120000,0x04020100,0x04120100,
X0x04020008,0x04120008,0x04020108,0x04120108,
X0x04021000,0x04121000,0x04021100,0x04121100,
X0x04021008,0x04121008,0x04021108,0x04121108,
X);
X@skb4=(
X# for D bits (numbered as per FIPS 46) 1 2 3 4 5 6 
X0x00000000,0x10000000,0x00010000,0x10010000,
X0x00000004,0x10000004,0x00010004,0x10010004,
X0x20000000,0x30000000,0x20010000,0x30010000,
X0x20000004,0x30000004,0x20010004,0x30010004,
X0x00100000,0x10100000,0x00110000,0x10110000,
X0x00100004,0x10100004,0x00110004,0x10110004,
X0x20100000,0x30100000,0x20110000,0x30110000,
X0x20100004,0x30100004,0x20110004,0x30110004,
X0x00001000,0x10001000,0x00011000,0x10011000,
X0x00001004,0x10001004,0x00011004,0x10011004,
X0x20001000,0x30001000,0x20011000,0x30011000,
X0x20001004,0x30001004,0x20011004,0x30011004,
X0x00101000,0x10101000,0x00111000,0x10111000,
X0x00101004,0x10101004,0x00111004,0x10111004,
X0x20101000,0x30101000,0x20111000,0x30111000,
X0x20101004,0x30101004,0x20111004,0x30111004,
X);
X@skb5=(
X# for D bits (numbered as per FIPS 46) 8 9 11 12 13 14 
X0x00000000,0x08000000,0x00000008,0x08000008,
X0x00000400,0x08000400,0x00000408,0x08000408,
X0x00020000,0x08020000,0x00020008,0x08020008,
X0x00020400,0x08020400,0x00020408,0x08020408,
X0x00000001,0x08000001,0x00000009,0x08000009,
X0x00000401,0x08000401,0x00000409,0x08000409,
X0x00020001,0x08020001,0x00020009,0x08020009,
X0x00020401,0x08020401,0x00020409,0x08020409,
X0x02000000,0x0A000000,0x02000008,0x0A000008,
X0x02000400,0x0A000400,0x02000408,0x0A000408,
X0x02020000,0x0A020000,0x02020008,0x0A020008,
X0x02020400,0x0A020400,0x02020408,0x0A020408,
X0x02000001,0x0A000001,0x02000009,0x0A000009,
X0x02000401,0x0A000401,0x02000409,0x0A000409,
X0x02020001,0x0A020001,0x02020009,0x0A020009,
X0x02020401,0x0A020401,0x02020409,0x0A020409,
X);
X@skb6=(
X# for D bits (numbered as per FIPS 46) 16 17 18 19 20 21 
X0x00000000,0x00000100,0x00080000,0x00080100,
X0x01000000,0x01000100,0x01080000,0x01080100,
X0x00000010,0x00000110,0x00080010,0x00080110,
X0x01000010,0x01000110,0x01080010,0x01080110,
X0x00200000,0x00200100,0x00280000,0x00280100,
X0x01200000,0x01200100,0x01280000,0x01280100,
X0x00200010,0x00200110,0x00280010,0x00280110,
X0x01200010,0x01200110,0x01280010,0x01280110,
X0x00000200,0x00000300,0x00080200,0x00080300,
X0x01000200,0x01000300,0x01080200,0x01080300,
X0x00000210,0x00000310,0x00080210,0x00080310,
X0x01000210,0x01000310,0x01080210,0x01080310,
X0x00200200,0x00200300,0x00280200,0x00280300,
X0x01200200,0x01200300,0x01280200,0x01280300,
X0x00200210,0x00200310,0x00280210,0x00280310,
X0x01200210,0x01200310,0x01280210,0x01280310,
X);
X@skb7=(
X# for D bits (numbered as per FIPS 46) 22 23 24 25 27 28 
X0x00000000,0x04000000,0x00040000,0x04040000,
X0x00000002,0x04000002,0x00040002,0x04040002,
X0x00002000,0x04002000,0x00042000,0x04042000,
X0x00002002,0x04002002,0x00042002,0x04042002,
X0x00000020,0x04000020,0x00040020,0x04040020,
X0x00000022,0x04000022,0x00040022,0x04040022,
X0x00002020,0x04002020,0x00042020,0x04042020,
X0x00002022,0x04002022,0x00042022,0x04042022,
X0x00000800,0x04000800,0x00040800,0x04040800,
X0x00000802,0x04000802,0x00040802,0x04040802,
X0x00002800,0x04002800,0x00042800,0x04042800,
X0x00002802,0x04002802,0x00042802,0x04042802,
X0x00000820,0x04000820,0x00040820,0x04040820,
X0x00000822,0x04000822,0x00040822,0x04040822,
X0x00002820,0x04002820,0x00042820,0x04042820,
X0x00002822,0x04002822,0x00042822,0x04042822,
X);
X
X@shifts2=(0,0,1,1,1,1,1,1,0,1,1,1,1,1,1,0);
X
X# used in ecb_encrypt
X@SP0=(
X0x00410100, 0x00010000, 0x40400000, 0x40410100,
X0x00400000, 0x40010100, 0x40010000, 0x40400000,
X0x40010100, 0x00410100, 0x00410000, 0x40000100,
X0x40400100, 0x00400000, 0x00000000, 0x40010000,
X0x00010000, 0x40000000, 0x00400100, 0x00010100,
X0x40410100, 0x00410000, 0x40000100, 0x00400100,
X0x40000000, 0x00000100, 0x00010100, 0x40410000,
X0x00000100, 0x40400100, 0x40410000, 0x00000000,
X0x00000000, 0x40410100, 0x00400100, 0x40010000,
X0x00410100, 0x00010000, 0x40000100, 0x00400100,
X0x40410000, 0x00000100, 0x00010100, 0x40400000,
X0x40010100, 0x40000000, 0x40400000, 0x00410000,
X0x40410100, 0x00010100, 0x00410000, 0x40400100,
X0x00400000, 0x40000100, 0x40010000, 0x00000000,
X0x00010000, 0x00400000, 0x40400100, 0x00410100,
X0x40000000, 0x40410000, 0x00000100, 0x40010100,
X);
X@SP1=(
X0x08021002, 0x00000000, 0x00021000, 0x08020000,
X0x08000002, 0x00001002, 0x08001000, 0x00021000,
X0x00001000, 0x08020002, 0x00000002, 0x08001000,
X0x00020002, 0x08021000, 0x08020000, 0x00000002,
X0x00020000, 0x08001002, 0x08020002, 0x00001000,
X0x00021002, 0x08000000, 0x00000000, 0x00020002,
X0x08001002, 0x00021002, 0x08021000, 0x08000002,
X0x08000000, 0x00020000, 0x00001002, 0x08021002,
X0x00020002, 0x08021000, 0x08001000, 0x00021002,
X0x08021002, 0x00020002, 0x08000002, 0x00000000,
X0x08000000, 0x00001002, 0x00020000, 0x08020002,
X0x00001000, 0x08000000, 0x00021002, 0x08001002,
X0x08021000, 0x00001000, 0x00000000, 0x08000002,
X0x00000002, 0x08021002, 0x00021000, 0x08020000,
X0x08020002, 0x00020000, 0x00001002, 0x08001000,
X0x08001002, 0x00000002, 0x08020000, 0x00021000,
X);
X@SP2=(
X0x20800000, 0x00808020, 0x00000020, 0x20800020,
X0x20008000, 0x00800000, 0x20800020, 0x00008020,
X0x00800020, 0x00008000, 0x00808000, 0x20000000,
X0x20808020, 0x20000020, 0x20000000, 0x20808000,
X0x00000000, 0x20008000, 0x00808020, 0x00000020,
X0x20000020, 0x20808020, 0x00008000, 0x20800000,
X0x20808000, 0x00800020, 0x20008020, 0x00808000,
X0x00008020, 0x00000000, 0x00800000, 0x20008020,
X0x00808020, 0x00000020, 0x20000000, 0x00008000,
X0x20000020, 0x20008000, 0x00808000, 0x20800020,
X0x00000000, 0x00808020, 0x00008020, 0x20808000,
X0x20008000, 0x00800000, 0x20808020, 0x20000000,
X0x20008020, 0x20800000, 0x00800000, 0x20808020,
X0x00008000, 0x00800020, 0x20800020, 0x00008020,
X0x00800020, 0x00000000, 0x20808000, 0x20000020,
X0x20800000, 0x20008020, 0x00000020, 0x00808000,
X);
X@SP3=(
X0x00080201, 0x02000200, 0x00000001, 0x02080201,
X0x00000000, 0x02080000, 0x02000201, 0x00080001,
X0x02080200, 0x02000001, 0x02000000, 0x00000201,
X0x02000001, 0x00080201, 0x00080000, 0x02000000,
X0x02080001, 0x00080200, 0x00000200, 0x00000001,
X0x00080200, 0x02000201, 0x02080000, 0x00000200,
X0x00000201, 0x00000000, 0x00080001, 0x02080200,
X0x02000200, 0x02080001, 0x02080201, 0x00080000,
X0x02080001, 0x00000201, 0x00080000, 0x02000001,
X0x00080200, 0x02000200, 0x00000001, 0x02080000,
X0x02000201, 0x00000000, 0x00000200, 0x00080001,
X0x00000000, 0x02080001, 0x02080200, 0x00000200,
X0x02000000, 0x02080201, 0x00080201, 0x00080000,
X0x02080201, 0x00000001, 0x02000200, 0x00080201,
X0x00080001, 0x00080200, 0x02080000, 0x02000201,
X0x00000201, 0x02000000, 0x02000001, 0x02080200,
X);
X@SP4=(
X0x01000000, 0x00002000, 0x00000080, 0x01002084,
X0x01002004, 0x01000080, 0x00002084, 0x01002000,
X0x00002000, 0x00000004, 0x01000004, 0x00002080,
X0x01000084, 0x01002004, 0x01002080, 0x00000000,
X0x00002080, 0x01000000, 0x00002004, 0x00000084,
X0x01000080, 0x00002084, 0x00000000, 0x01000004,
X0x00000004, 0x01000084, 0x01002084, 0x00002004,
X0x01002000, 0x00000080, 0x00000084, 0x01002080,
X0x01002080, 0x01000084, 0x00002004, 0x01002000,
X0x00002000, 0x00000004, 0x01000004, 0x01000080,
X0x01000000, 0x00002080, 0x01002084, 0x00000000,
X0x00002084, 0x01000000, 0x00000080, 0x00002004,
X0x01000084, 0x00000080, 0x00000000, 0x01002084,
X0x01002004, 0x01002080, 0x00000084, 0x00002000,
X0x00002080, 0x01002004, 0x01000080, 0x00000084,
X0x00000004, 0x00002084, 0x01002000, 0x01000004,
X);
X@SP5=(
X0x10000008, 0x00040008, 0x00000000, 0x10040400,
X0x00040008, 0x00000400, 0x10000408, 0x00040000,
X0x00000408, 0x10040408, 0x00040400, 0x10000000,
X0x10000400, 0x10000008, 0x10040000, 0x00040408,
X0x00040000, 0x10000408, 0x10040008, 0x00000000,
X0x00000400, 0x00000008, 0x10040400, 0x10040008,
X0x10040408, 0x10040000, 0x10000000, 0x00000408,
X0x00000008, 0x00040400, 0x00040408, 0x10000400,
X0x00000408, 0x10000000, 0x10000400, 0x00040408,
X0x10040400, 0x00040008, 0x00000000, 0x10000400,
X0x10000000, 0x00000400, 0x10040008, 0x00040000,
X0x00040008, 0x10040408, 0x00040400, 0x00000008,
X0x10040408, 0x00040400, 0x00040000, 0x10000408,
X0x10000008, 0x10040000, 0x00040408, 0x00000000,
X0x00000400, 0x10000008, 0x10000408, 0x10040400,
X0x10040000, 0x00000408, 0x00000008, 0x10040008,
X);
X@SP6=(
X0x00000800, 0x00000040, 0x00200040, 0x80200000,
X0x80200840, 0x80000800, 0x00000840, 0x00000000,
X0x00200000, 0x80200040, 0x80000040, 0x00200800,
X0x80000000, 0x00200840, 0x00200800, 0x80000040,
X0x80200040, 0x00000800, 0x80000800, 0x80200840,
X0x00000000, 0x00200040, 0x80200000, 0x00000840,
X0x80200800, 0x80000840, 0x00200840, 0x80000000,
X0x80000840, 0x80200800, 0x00000040, 0x00200000,
X0x80000840, 0x00200800, 0x80200800, 0x80000040,
X0x00000800, 0x00000040, 0x00200000, 0x80200800,
X0x80200040, 0x80000840, 0x00000840, 0x00000000,
X0x00000040, 0x80200000, 0x80000000, 0x00200040,
X0x00000000, 0x80200040, 0x00200040, 0x00000840,
X0x80000040, 0x00000800, 0x80200840, 0x00200000,
X0x00200840, 0x80000000, 0x80000800, 0x80200840,
X0x80200000, 0x00200840, 0x00200800, 0x80000800,
X);
X@SP7=(
X0x04100010, 0x04104000, 0x00004010, 0x00000000,
X0x04004000, 0x00100010, 0x04100000, 0x04104010,
X0x00000010, 0x04000000, 0x00104000, 0x00004010,
X0x00104010, 0x04004010, 0x04000010, 0x04100000,
X0x00004000, 0x00104010, 0x00100010, 0x04004000,
X0x04104010, 0x04000010, 0x00000000, 0x00104000,
X0x04000000, 0x00100000, 0x04004010, 0x04100010,
X0x00100000, 0x00004000, 0x04104000, 0x00000010,
X0x00100000, 0x00004000, 0x04000010, 0x04104010,
X0x00004010, 0x04000000, 0x00000000, 0x00104000,
X0x04100010, 0x04004010, 0x04004000, 0x00100010,
X0x04104000, 0x00000010, 0x00100010, 0x04004000,
X0x04104010, 0x00100000, 0x04100000, 0x04000010,
X0x00104000, 0x00004010, 0x04004010, 0x04100000,
X0x00000010, 0x04104000, 0x00104010, 0x00000000,
X0x04000000, 0x04100010, 0x00004000, 0x00104010,
X);
X
Xsub main'des_set_key
X	{
X	local($param)=@_;
X	local(@key);
X	local($c,$d,$i,$s,$t);
X	local(@ks)=();
X
X	# Get the bytes in the order we want.
X	@key=unpack("C8",$param);
X
X	$c=	($key[0]    )|
X		($key[1]<< 8)|
X		($key[2]<<16)|
X		($key[3]<<24);
X	$d=	($key[4]    )|
X		($key[5]<< 8)|
X		($key[6]<<16)|
X		($key[7]<<24);
X
X	&doPC1(*c,*d);
X
X	for $i (@shifts2)
X		{
X		if ($i)
X			{
X			$c=($c>>2)|($c<<26);
X			$d=($d>>2)|($d<<26);
X			}
X		else
X			{
X			$c=($c>>1)|($c<<27);
X			$d=($d>>1)|($d<<27);
X			}
X		$c&=0x0fffffff;
X		$d&=0x0fffffff;
X		$s=	$skb0[ ($c    )&0x3f                 ]|
X			$skb1[(($c>> 6)&0x03)|(($c>> 7)&0x3c)]|
X			$skb2[(($c>>13)&0x0f)|(($c>>14)&0x30)]|
X			$skb3[(($c>>20)&0x01)|(($c>>21)&0x06) |
X					     (($c>>22)&0x38)];
X		$t=     $skb4[ ($d    )&0x3f                ]|
X			$skb5[(($d>> 7)&0x03)|(($d>> 8)&0x3c)]|
X			$skb6[ ($d>>15)&0x3f                 ]|
X			$skb7[(($d>>21)&0x0f)|(($d>>22)&0x30)];
X		push(@ks,(($t<<16)|($s&0x0000ffff))&0xffffffff);
X		$s=      ($s>>16)|($t&0xffff0000) ;
X		push(@ks,(($s<<4)|($s>>28))&0xffffffff);
X		}
X	@ks;
X	}
X
Xsub doPC1
X	{
X	local(*a,*b)=@_;
X	local($t);
X
X	$t=(($b>>4)^$a)&0x0f0f0f0f;
X	$b^=($t<<4); $a^=$t;
X	# do $a first 
X	$t=(($a<<18)^$a)&0xcccc0000;
X	$a=$a^$t^($t>>18);
X	$t=(($a<<17)^$a)&0xaaaa0000;
X	$a=$a^$t^($t>>17);
X	$t=(($a<< 8)^$a)&0x00ff0000;
X	$a=$a^$t^($t>> 8);
X	$t=(($a<<17)^$a)&0xaaaa0000;
X	$a=$a^$t^($t>>17);
X
X	# now do $b
X	$t=(($b<<24)^$b)&0xff000000;
X	$b=$b^$t^($t>>24);
X	$t=(($b<< 8)^$b)&0x00ff0000;
X	$b=$b^$t^($t>> 8);
X	$t=(($b<<14)^$b)&0x33330000;
X	$b=$b^$t^($t>>14);
X	$b=(($b&0x00aa00aa)<<7)|(($b&0x55005500)>>7)|($b&0xaa55aa55);
X	$b=($b>>8)|(($a&0xf0000000)>>4);
X	$a&=0x0fffffff;
X	}
X
Xsub doIP
X	{
X	local(*a,*b)=@_;
X	local($t);
X
X	$t=(($b>> 4)^$a)&0x0f0f0f0f;
X	$b^=($t<< 4); $a^=$t;
X	$t=(($a>>16)^$b)&0x0000ffff;
X	$a^=($t<<16); $b^=$t;
X	$t=(($b>> 2)^$a)&0x33333333;
X	$b^=($t<< 2); $a^=$t;
X	$t=(($a>> 8)^$b)&0x00ff00ff;
X	$a^=($t<< 8); $b^=$t;
X	$t=(($b>> 1)^$a)&0x55555555;
X	$b^=($t<< 1); $a^=$t;
X	$t=$a;
X	$a=$b&0xffffffff;
X	$b=$t&0xffffffff;
X	}
X
Xsub doFP
X	{
X	local(*a,*b)=@_;
X	local($t);
X
X	$t=(($b>> 1)^$a)&0x55555555;
X	$b^=($t<< 1); $a^=$t;
X	$t=(($a>> 8)^$b)&0x00ff00ff;
X	$a^=($t<< 8); $b^=$t;
X	$t=(($b>> 2)^$a)&0x33333333;
X	$b^=($t<< 2); $a^=$t;
X	$t=(($a>>16)^$b)&0x0000ffff;
X	$a^=($t<<16); $b^=$t;
X	$t=(($b>> 4)^$a)&0x0f0f0f0f;
X	$b^=($t<< 4); $a^=$t;
X	$a&=0xffffffff;
X	$b&=0xffffffff;
X	}
X
Xsub main'des_ecb_encrypt
X	{
X	local(*ks,$encrypt,$in)=@_;
X	local($l,$r,$inc,$start,$end,$i,$t,$u,@input);
X	
X	@input=unpack("C8",$in);
X	# Get the bytes in the order we want.
X	$l=	($input[0]    )|
X		($input[1]<< 8)|
X		($input[2]<<16)|
X		($input[3]<<24);
X	$r=	($input[4]    )|
X		($input[5]<< 8)|
X		($input[6]<<16)|
X		($input[7]<<24);
X
X	$l&=0xffffffff;
X	$r&=0xffffffff;
X	&doIP(*l,*r);
X	if ($encrypt)
X		{
X		for ($i=0; $i<32; $i+=4)
X			{
X			$t=(($r<<1)|($r>>31))&0xffffffff;
X			$u=$t^$ks[$i  ];
X			$t=$t^$ks[$i+1];
X			$t=(($t>>4)|($t<<28))&0xffffffff;
X			$l^=	$SP1[ $t     &0x3f]|
X				$SP3[($t>> 8)&0x3f]|
X				$SP5[($t>>16)&0x3f]|
X				$SP7[($t>>24)&0x3f]|
X				$SP0[ $u     &0x3f]|
X				$SP2[($u>> 8)&0x3f]|
X				$SP4[($u>>16)&0x3f]|
X				$SP6[($u>>24)&0x3f];
X
X			$t=(($l<<1)|($l>>31))&0xffffffff;
X			$u=$t^$ks[$i+2];
X			$t=$t^$ks[$i+3];
X			$t=(($t>>4)|($t<<28))&0xffffffff;
X			$r^=	$SP1[ $t     &0x3f]|
X				$SP3[($t>> 8)&0x3f]|
X				$SP5[($t>>16)&0x3f]|
X				$SP7[($t>>24)&0x3f]|
X				$SP0[ $u     &0x3f]|
X				$SP2[($u>> 8)&0x3f]|
X				$SP4[($u>>16)&0x3f]|
X				$SP6[($u>>24)&0x3f];
X			}
X		}
X	else	
X		{
X		for ($i=30; $i>0; $i-=4)
X			{
X			$t=(($r<<1)|($r>>31))&0xffffffff;
X			$u=$t^$ks[$i  ];
X			$t=$t^$ks[$i+1];
X			$t=(($t>>4)|($t<<28))&0xffffffff;
X			$l^=	$SP1[ $t     &0x3f]|
X				$SP3[($t>> 8)&0x3f]|
X				$SP5[($t>>16)&0x3f]|
X				$SP7[($t>>24)&0x3f]|
X				$SP0[ $u     &0x3f]|
X				$SP2[($u>> 8)&0x3f]|
X				$SP4[($u>>16)&0x3f]|
X				$SP6[($u>>24)&0x3f];
X
X			$t=(($l<<1)|($l>>31))&0xffffffff;
X			$u=$t^$ks[$i-2];
X			$t=$t^$ks[$i-1];
X			$t=(($t>>4)|($t<<28))&0xffffffff;
X			$r^=	$SP1[ $t     &0x3f]|
X				$SP3[($t>> 8)&0x3f]|
X				$SP5[($t>>16)&0x3f]|
X				$SP7[($t>>24)&0x3f]|
X				$SP0[ $u     &0x3f]|
X				$SP2[($u>> 8)&0x3f]|
X				$SP4[($u>>16)&0x3f]|
X				$SP6[($u>>24)&0x3f];
X			}
X		}
X	&doFP(*l,*r);
X	pack("C8",$l&0xff,$l>>8,$l>>16,$l>>24,
X		  $r&0xff,$r>>8,$r>>16,$r>>24);
X	}
END_OF_FILE
  if test 17839 -ne `wc -c <'des.pl'`; then
    echo shar: \"'des.pl'\" unpacked with wrong size!
  fi
  # end of 'des.pl'
fi
if test -f 'testdes.pl' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'testdes.pl'\"
else
  echo shar: Extracting \"'testdes.pl'\" \(5644 characters\)
  sed "s/^X//" >'testdes.pl' <<'END_OF_FILE'
X#!/usr/local/bin/perl
X
X# des.pl tesing code
X
Xrequire 'des.pl';
X
X$num_tests=34;
X@key_data=(
X	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
X	0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
X	0x30,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
X	0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,
X	0x01,0x23,0x45,0x67,0x89,0xAB,0xCD,0xEF,
X	0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,
X	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
X	0xFE,0xDC,0xBA,0x98,0x76,0x54,0x32,0x10,
X	0x7C,0xA1,0x10,0x45,0x4A,0x1A,0x6E,0x57,
X	0x01,0x31,0xD9,0x61,0x9D,0xC1,0x37,0x6E,
X	0x07,0xA1,0x13,0x3E,0x4A,0x0B,0x26,0x86,
X	0x38,0x49,0x67,0x4C,0x26,0x02,0x31,0x9E,
X	0x04,0xB9,0x15,0xBA,0x43,0xFE,0xB5,0xB6,
X	0x01,0x13,0xB9,0x70,0xFD,0x34,0xF2,0xCE,
X	0x01,0x70,0xF1,0x75,0x46,0x8F,0xB5,0xE6,
X	0x43,0x29,0x7F,0xAD,0x38,0xE3,0x73,0xFE,
X	0x07,0xA7,0x13,0x70,0x45,0xDA,0x2A,0x16,
X	0x04,0x68,0x91,0x04,0xC2,0xFD,0x3B,0x2F,
X	0x37,0xD0,0x6B,0xB5,0x16,0xCB,0x75,0x46,
X	0x1F,0x08,0x26,0x0D,0x1A,0xC2,0x46,0x5E,
X	0x58,0x40,0x23,0x64,0x1A,0xBA,0x61,0x76,
X	0x02,0x58,0x16,0x16,0x46,0x29,0xB0,0x07,
X	0x49,0x79,0x3E,0xBC,0x79,0xB3,0x25,0x8F,
X	0x4F,0xB0,0x5E,0x15,0x15,0xAB,0x73,0xA7,
X	0x49,0xE9,0x5D,0x6D,0x4C,0xA2,0x29,0xBF,
X	0x01,0x83,0x10,0xDC,0x40,0x9B,0x26,0xD6,
X	0x1C,0x58,0x7F,0x1C,0x13,0x92,0x4F,0xEF,
X	0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,
X	0x1F,0x1F,0x1F,0x1F,0x0E,0x0E,0x0E,0x0E,
X	0xE0,0xFE,0xE0,0xFE,0xF1,0xFE,0xF1,0xFE,
X	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
X	0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
X	0x01,0x23,0x45,0x67,0x89,0xAB,0xCD,0xEF,
X	0xFE,0xDC,0xBA,0x98,0x76,0x54,0x32,0x10,
X	);
X
X@plain_data=(
X	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
X	0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
X	0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x01,
X	0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,
X	0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,
X	0x01,0x23,0x45,0x67,0x89,0xAB,0xCD,0xEF,
X	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
X	0x01,0x23,0x45,0x67,0x89,0xAB,0xCD,0xEF,
X	0x01,0xA1,0xD6,0xD0,0x39,0x77,0x67,0x42,
X	0x5C,0xD5,0x4C,0xA8,0x3D,0xEF,0x57,0xDA,
X	0x02,0x48,0xD4,0x38,0x06,0xF6,0x71,0x72,
X	0x51,0x45,0x4B,0x58,0x2D,0xDF,0x44,0x0A,
X	0x42,0xFD,0x44,0x30,0x59,0x57,0x7F,0xA2,
X	0x05,0x9B,0x5E,0x08,0x51,0xCF,0x14,0x3A,
X	0x07,0x56,0xD8,0xE0,0x77,0x47,0x61,0xD2,
X	0x76,0x25,0x14,0xB8,0x29,0xBF,0x48,0x6A,
X	0x3B,0xDD,0x11,0x90,0x49,0x37,0x28,0x02,
X	0x26,0x95,0x5F,0x68,0x35,0xAF,0x60,0x9A,
X	0x16,0x4D,0x5E,0x40,0x4F,0x27,0x52,0x32,
X	0x6B,0x05,0x6E,0x18,0x75,0x9F,0x5C,0xCA,
X	0x00,0x4B,0xD6,0xEF,0x09,0x17,0x60,0x62,
X	0x48,0x0D,0x39,0x00,0x6E,0xE7,0x62,0xF2,
X	0x43,0x75,0x40,0xC8,0x69,0x8F,0x3C,0xFA,
X	0x07,0x2D,0x43,0xA0,0x77,0x07,0x52,0x92,
X	0x02,0xFE,0x55,0x77,0x81,0x17,0xF1,0x2A,
X	0x1D,0x9D,0x5C,0x50,0x18,0xF7,0x28,0xC2,
X	0x30,0x55,0x32,0x28,0x6D,0x6F,0x29,0x5A,
X	0x01,0x23,0x45,0x67,0x89,0xAB,0xCD,0xEF,
X	0x01,0x23,0x45,0x67,0x89,0xAB,0xCD,0xEF,
X	0x01,0x23,0x45,0x67,0x89,0xAB,0xCD,0xEF,
X	0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
X	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
X	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
X	0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF);
X
X@cipher_data=(
X	0x8C,0xA6,0x4D,0xE9,0xC1,0xB1,0x23,0xA7,
X	0x73,0x59,0xB2,0x16,0x3E,0x4E,0xDC,0x58,
X	0x95,0x8E,0x6E,0x62,0x7A,0x05,0x55,0x7B,
X	0xF4,0x03,0x79,0xAB,0x9E,0x0E,0xC5,0x33,
X	0x17,0x66,0x8D,0xFC,0x72,0x92,0x53,0x2D,
X	0x8A,0x5A,0xE1,0xF8,0x1A,0xB8,0xF2,0xDD,
X	0x8C,0xA6,0x4D,0xE9,0xC1,0xB1,0x23,0xA7,
X	0xED,0x39,0xD9,0x50,0xFA,0x74,0xBC,0xC4,
X	0x69,0x0F,0x5B,0x0D,0x9A,0x26,0x93,0x9B,
X	0x7A,0x38,0x9D,0x10,0x35,0x4B,0xD2,0x71,
X	0x86,0x8E,0xBB,0x51,0xCA,0xB4,0x59,0x9A,
X	0x71,0x78,0x87,0x6E,0x01,0xF1,0x9B,0x2A,
X	0xAF,0x37,0xFB,0x42,0x1F,0x8C,0x40,0x95,
X	0x86,0xA5,0x60,0xF1,0x0E,0xC6,0xD8,0x5B,
X	0x0C,0xD3,0xDA,0x02,0x00,0x21,0xDC,0x09,
X	0xEA,0x67,0x6B,0x2C,0xB7,0xDB,0x2B,0x7A,
X	0xDF,0xD6,0x4A,0x81,0x5C,0xAF,0x1A,0x0F,
X	0x5C,0x51,0x3C,0x9C,0x48,0x86,0xC0,0x88,
X	0x0A,0x2A,0xEE,0xAE,0x3F,0xF4,0xAB,0x77,
X	0xEF,0x1B,0xF0,0x3E,0x5D,0xFA,0x57,0x5A,
X	0x88,0xBF,0x0D,0xB6,0xD7,0x0D,0xEE,0x56,
X	0xA1,0xF9,0x91,0x55,0x41,0x02,0x0B,0x56,
X	0x6F,0xBF,0x1C,0xAF,0xCF,0xFD,0x05,0x56,
X	0x2F,0x22,0xE4,0x9B,0xAB,0x7C,0xA1,0xAC,
X	0x5A,0x6B,0x61,0x2C,0xC2,0x6C,0xCE,0x4A,
X	0x5F,0x4C,0x03,0x8E,0xD1,0x2B,0x2E,0x41,
X	0x63,0xFA,0xC0,0xD0,0x34,0xD9,0xF7,0x93,
X	0x61,0x7B,0x3A,0x0C,0xE8,0xF0,0x71,0x00,
X	0xDB,0x95,0x86,0x05,0xF8,0xC8,0xC6,0x06,
X	0xED,0xBF,0xD1,0xC6,0x6C,0x29,0xCC,0xC7,
X	0x35,0x55,0x50,0xB2,0x15,0x0E,0x24,0x51,
X	0xCA,0xAA,0xAF,0x4D,0xEA,0xF1,0xDB,0xAE,
X	0xD5,0xD4,0x4F,0xF7,0x20,0x68,0x3D,0x0D,
X	0x2A,0x2B,0xB0,0x08,0xDF,0x97,0xC2,0xF2);
X
Xprint "Doing ecb tests\n";
Xfor ($i=0; $i<$num_tests; $i++)
X	{
X	printf "Doing test $i\n";
X	$key =pack("C8",splice(@key_data   ,0,8));
X	$data=pack("C8",splice(@plain_data ,0,8));
X	$res =pack("C8",splice(@cipher_data,0,8));
X
X	@ks=  &des_set_key($key);
X	$out1= &des_ecb_encrypt(*ks,1,$data);
X	$out2= &des_ecb_encrypt(*ks,0,$out1);
X	$out3= &des_ecb_encrypt(*ks,0,$res);
X	&eprint("encryption failure",$res,$out1)
X		if ($out1 ne $res);
X	&eprint("encryption/decryption failure",$data,$out2)
X		if ($out2 ne $data);
X	&eprint("decryption failure",$data,$out3)
X		if ($data ne $out3);
X	}
Xprint "Done\n";
X
Xprint "doing speed test over 30 seconds\n";
X$SIG{'ALRM'}='done';
Xsub done {$done=1;}
X$done=0;
X
X$count=0;
X$d=pack("C8",0x01,0x23,0x45,0x67,0x89,0xab,0xcd,0xef);
X@ks=  &des_set_key($d);
Xalarm(30);
X$start=(times)[0];
Xwhile (!$done)
X	{
X	$count++;
X	$d=&des_ecb_encrypt(*ks,1,$d);
X	}
X$end=(times)[0];
X$t=$end-$start;
Xprintf "$count DESs in %.2f seconds is %.2f DESs/sec or %.2f bytes/sec\n",
X	1.0*$t,1.0*$count/$t,$count*8.0/$t;
X
Xsub eprint
X	{
X	local($s,$c,$e)=@_;
X	local(@k);
X
X	@k=unpack("C8",$c);
X	printf "%02x%02x%02x%02x %02x%02x%02x%02x - ",unpack("C8",$c);
X	printf "%02x%02x%02x%02x %02x%02x%02x%02x :",unpack("C8",$e);
X	print " $s\n";
X	}
END_OF_FILE
  if test 5644 -ne `wc -c <'testdes.pl'`; then
    echo shar: \"'testdes.pl'\" unpacked with wrong size!
  fi
  chmod +x 'testdes.pl'
  # end of 'testdes.pl'
fi
if test -f 'doIP' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'doIP'\"
else
  echo shar: Extracting \"'doIP'\" \(831 characters\)
  sed "s/^X//" >'doIP' <<'END_OF_FILE'
X#!/usr/local/bin/perl
X
X@l=(
X	 0, 1, 2, 3, 4, 5, 6, 7,
X	 8, 9,10,11,12,13,14,15,
X	16,17,18,19,20,21,22,23,
X	24,25,26,27,28,29,30,31
X	);
X@r=(
X	32,33,34,35,36,37,38,39,
X	40,41,42,43,44,45,46,47,
X	48,49,50,51,52,53,54,55,
X	56,57,58,59,60,61,62,63
X	);
X
Xrequire 'shifts.pl';
X
Xsub PERM_OP
X	{
X	local(*a,*b,*t,$n,$m)=@_;
X
X	@z=&shift(*a,-$n);
X	@z=&xor(*b,*z);
X	@z=&and(*z,$m);
X	@b=&xor(*b,*z);
X	@z=&shift(*z,$n);
X	@a=&xor(*a,*z);
X	}
X
X
X@L=@l;
X@R=@r;
X&PERM_OP(*R,*L,*T,4,0x0f0f0f0f);
X&PERM_OP(*L,*R,*T,16,0x0000ffff);
X&PERM_OP(*R,*L,*T,2,0x33333333);
X&PERM_OP(*L,*R,*T,8,0x00ff00ff);
X&PERM_OP(*R,*L,*T,1,0x55555555);
X	&printit(@L);
X	&printit(@R);
X&PERM_OP(*R,*L,*T,1,0x55555555);
X&PERM_OP(*L,*R,*T,8,0x00ff00ff);
X&PERM_OP(*R,*L,*T,2,0x33333333);
X&PERM_OP(*L,*R,*T,16,0x0000ffff);
X&PERM_OP(*R,*L,*T,4,0x0f0f0f0f);
X	&printit(@L);
X	&printit(@R);
END_OF_FILE
  if test 831 -ne `wc -c <'doIP'`; then
    echo shar: \"'doIP'\" unpacked with wrong size!
  fi
  chmod +x 'doIP'
  # end of 'doIP'
fi
if test -f 'doPC1' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'doPC1'\"
else
  echo shar: Extracting \"'doPC1'\" \(2106 characters\)
  sed "s/^X//" >'doPC1' <<'END_OF_FILE'
X#!/usr/local/bin/perl
X
X@l=(
X	 0, 1, 2, 3, 4, 5, 6, 7,
X	 8, 9,10,11,12,13,14,15,
X	16,17,18,19,20,21,22,23,
X	24,25,26,27,28,29,30,31
X	);
X@r=(
X	32,33,34,35,36,37,38,39,
X	40,41,42,43,44,45,46,47,
X	48,49,50,51,52,53,54,55,
X	56,57,58,59,60,61,62,63
X	);
X
Xrequire 'shifts.pl';
X
Xsub PERM_OP
X	{
X	local(*a,*b,*t,$n,$m)=@_;
X
X	@z=&shift(*a,-$n);
X	@z=&xor(*b,*z);
X	@z=&and(*z,$m);
X	@b=&xor(*b,*z);
X	@z=&shift(*z,$n);
X	@a=&xor(*a,*z);
X	}
X
Xsub HPERM_OP2
X	{
X	local(*a,*t,$n,$m)=@_;
X	local(@x,@y,$i);
X
X	@z=&shift(*a,16-$n);
X	@z=&xor(*a,*z);
X	@z=&and(*z,$m);
X	@a=&xor(*a,*z);
X	@z=&shift(*z,$n-16);
X	@a=&xor(*a,*z);
X	}
X
Xsub HPERM_OP
X        {
X        local(*a,*t,$n,$m)=@_;
X        local(@x,@y,$i);
X
X        for ($i=0; $i<16; $i++)
X                {
X                $x[$i]=$a[$i];
X                $y[$i]=$a[16+$i];
X                }
X        @z=&shift(*x,-$n);
X        @z=&xor(*y,*z);
X        @z=&and(*z,$m);
X        @y=&xor(*y,*z);
X        @z=&shift(*z,$n);
X        @x=&xor(*x,*z);
X        for ($i=0; $i<16; $i++)
X                {
X                $a[$i]=$x[$i];
X                $a[16+$i]=$y[$i];
X                }
X        }
X
X@L=@l;
X@R=@r;
X
X	print "---\n"; &printit(@R);
X&PERM_OP(*R,*L,*T,4,0x0f0f0f0f);
X	print "---\n"; &printit(@R);
X&HPERM_OP2(*L,*T,-2,0xcccc0000);
X&HPERM_OP2(*R,*T,-2,0xcccc0000);
X	print "---\n"; &printit(@R);
X&PERM_OP(*R,*L,*T,1,0x55555555);
X	print "---\n"; &printit(@R);
X&PERM_OP(*L,*R,*T,8,0x00ff00ff);
X	print "---\n"; &printit(@R);
X&PERM_OP(*R,*L,*T,1,0x55555555);
X	print "---\n"; &printit(@R);
X#	&printit(@L);
X	&printit(@R);
Xprint <<"EOF";
X==============================
X63  55  47  39  31  23  15   7  
X62  54  46  38  30  22  14   6  
X61  53  45  37  29  21  13   5  
X60  52  44  36  --  --  --  --  
X
X57  49  41  33  25  17   9   1  
X58  50  42  34  26  18  10   2  
X59  51  43  35  27  19  11   3  
X28  20  12   4  --  --  --  --  
XEOF
Xexit(1);
X@A=&and(*R,0x000000ff);
X@A=&shift(*A,16);
X@B=&and(*R,0x0000ff00);
X@C=&and(*R,0x00ff0000);
X@C=&shift(*C,-16);
X@D=&and(*L,0xf0000000);
X@D=&shift(*D,-4);
X@A=&or(*A,*B);
X@B=&or(*D,*C);
X@R=&or(*A,*B);
X@L=&and(*L,0x0fffffff);
X
X	&printit(@L);
X	&printit(@R);
X
END_OF_FILE
  if test 2106 -ne `wc -c <'doPC1'`; then
    echo shar: \"'doPC1'\" unpacked with wrong size!
  fi
  chmod +x 'doPC1'
  # end of 'doPC1'
fi
if test -f 'doPC2' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'doPC2'\"
else
  echo shar: Extracting \"'doPC2'\" \(1578 characters\)
  sed "s/^X//" >'doPC2' <<'END_OF_FILE'
X#!/usr/local/bin/perl
X
X@PC2_C=(14,17,11,24, 1, 5,
X	 3,28,15, 6,21,10,
X	23,19,12, 4,26, 8,
X	16, 7,27,20,13, 2,
X	);
X
X@PC2_D=(41,52,31,37,47,55,
X	30,40,51,45,33,48,
X	44,49,39,56,34,53,
X	46,42,50,36,29,32,
X	);
X
X$i=0;
Xforeach (@PC2_C) {
X	$_--;
X#	printf "%2d,",$_;
X	$C{$_}=$i;
X	++$i;
X#	print "\n" if ((($i) % 8) == 0);
X	}
X$i=0;
X#print "\n";
Xforeach (@PC2_D) {
X	$_-=28;
X	$_--;
X#	printf "%2d,",$_;
X	$D{$_}=$i;
X	$i++;
X#	print "\n" if ((($i) % 8) == 0);
X	}
X
X#print "\n";
Xforeach $i (0 .. 27)
X	{
X	$_=$C{$i};
X#	printf "%2d,",$_;
X	$i++;
X#	print "\n" if ((($i) % 8) == 0);
X	}
X#print "\n";
X
X#print "\n";
Xforeach $i (0 .. 27)
X	{
X	$_=$D{$i};
X#	printf "%2d,",$_;
X	$i++;
X#	print "\n" if ((($i) % 8) == 0);
X	}
X#print "\n";
X
Xprint "static ulong skb[8][64]={\n";
X&doit("C",*C, 0, 1, 2, 3, 4, 5);
X&doit("C",*C, 6, 7, 9,10,11,12);
X&doit("C",*C,13,14,15,16,18,19);
X&doit("C",*C,20,22,23,25,26,27);
X
X&doit("D",*D, 0, 1, 2, 3, 4, 5);
X&doit("D",*D, 7, 8,10,11,12,13);
X&doit("D",*D,15,16,17,18,19,20);
X&doit("D",*D,21,22,23,24,26,27);
Xprint "};\n";
X
Xsub doit
X	{
X	local($l,*A,@b)=@_;
X	local(@out);
X
X	printf("/* for $l bits (numbered as per FIPS 46) %d %d %d %d %d %d */\n",
X		$b[0]+1, $b[1]+1, $b[2]+1, $b[3]+1, $b[4]+1, $b[5]+1);
X	for ($i=0; $i<64; $i++)
X		{
X		$out[$i]=0;
X		$j=1;
X#print "\n";
X		for ($k=0; $k<6; $k++)
X			{
X			$l=$A{$b[$k]};
X#print"$l - ";
X			if ((1<<$k) & $i)
X				{
X				$ll=int($l/6)*8+($l%6);
X				$out[$i]|=1<<($ll);
X				}
X			}
X		$pp=$out[$i];
X		$pp=($pp&0xff0000ff)|   (($pp&0x00ff0000)>>8)|
X					(($pp&0x0000ff00)<<8);
X		printf("0x%08X,",$pp);
X		print "\n" if (($i+1) % 4 == 0);
X		}
X	}
END_OF_FILE
  if test 1578 -ne `wc -c <'doPC2'`; then
    echo shar: \"'doPC2'\" unpacked with wrong size!
  fi
  chmod +x 'doPC2'
  # end of 'doPC2'
fi
if test -f 'PC1' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'PC1'\"
else
  echo shar: Extracting \"'PC1'\" \(454 characters\)
  sed "s/^X//" >'PC1' <<'END_OF_FILE'
X#!/usr/local/bin/perl
X
X@PC1=(  57,49,41,33,25,17, 9,
X	 1,58,50,42,34,26,18,
X	10, 2,59,51,43,35,27,
X	19,11, 3,60,52,44,36,
X	"-","-","-","-",
X	63,55,47,39,31,23,15,
X	 7,62,54,46,38,30,22,
X	14, 6,61,53,45,37,29,
X	21,13, 5,28,20,12, 4,
X	"-","-","-","-",
X	);
X
Xforeach (@PC1)
X	{
X	if ($_ ne "-")
X		{
X		$_--;
X		$_=int($_/8)*8+7-($_%8);
X		printf "%2d  ",$_;
X		}
X	else
X		{ print "--  "; }
X	print "\n" if (((++$i) % 8) == 0);
X	print "\n" if ((($i) % 32) == 0);
X	}
X
END_OF_FILE
  if test 454 -ne `wc -c <'PC1'`; then
    echo shar: \"'PC1'\" unpacked with wrong size!
  fi
  chmod +x 'PC1'
  # end of 'PC1'
fi
if test -f 'PC2' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'PC2'\"
else
  echo shar: Extracting \"'PC2'\" \(861 characters\)
  sed "s/^X//" >'PC2' <<'END_OF_FILE'
X#!/usr/local/bin/perl
X
X@PC2_C=(14,17,11,24, 1, 5,
X	 3,28,15, 6,21,10,
X	23,19,12, 4,26, 8,
X	16, 7,27,20,13, 2,
X	);
X
X@PC2_D=(41,52,31,37,47,55,
X	30,40,51,45,33,48,
X	44,49,39,56,34,53,
X	46,42,50,36,29,32,
X	);
X
Xforeach (@PC2_C) {
X	if ($_ ne "-")
X		{
X		$_--;
X		printf "%2d  ",$_; }
X	else { print "--  "; }
X	$C{$_}=1;
X	print "\n" if (((++$i) % 8) == 0);
X	}
X$i=0;
Xprint "\n";
Xforeach (@PC2_D) {
X	if ($_ ne "-")
X		{
X		$_-=29;
X		printf "%2d  ",$_; }
X	else { print "--  "; }
X	$D{$_}=1;
X	print "\n" if (((++$i) % 8) == 0); }
X
Xprint "\n";
Xforeach $i (0 .. 27)
X	{
X	$_=$C{$i};
X	if ($_ ne "-") {printf "%2d ",$_;}
X	else { print "--  "; }
X	print "\n" if (((++$i) % 8) == 0);
X	}
Xprint "\n";
X
Xprint "\n";
Xforeach $i (0 .. 27)
X	{
X	$_=$D{$i};
X	if ($_ ne "-") {printf "%2d  ",$_;}
X	else { print "--  "; }
X	print "\n" if (((++$i) % 8) == 0);
X	}
Xprint "\n";
Xsub numsort
X	{
X	$a-$b;
X	}
END_OF_FILE
  if test 861 -ne `wc -c <'PC2'`; then
    echo shar: \"'PC2'\" unpacked with wrong size!
  fi
  chmod +x 'PC2'
  # end of 'PC2'
fi
if test -f 'shifts.pl' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'shifts.pl'\"
else
  echo shar: Extracting \"'shifts.pl'\" \(1978 characters\)
  sed "s/^X//" >'shifts.pl' <<'END_OF_FILE'
Xsub lab_shift
X	{
X	local(*a,$n)=@_;
X	local(@r,$i,$j,$k,$d,@z);
X
X	@r=&shift(*a,$n);
X	foreach $i (0 .. 31)
X		{
X		@z=split(/\^/,$r[$i]);
X		for ($j=0; $j <= $#z; $j++)
X			{
X			($d)=($z[$j] =~ /^(..)/);
X			($k)=($z[$j] =~ /\[(.*)\]$/);
X			$k.=",$n" if ($k ne "");
X			$k="$n"	  if ($k eq "");
X			$d="$d[$k]";
X			$z[$j]=$d;
X			}
X		$r[$i]=join('^',@z);
X		}
X	return(@r);
X	}
X
Xsub shift
X	{
X	local(*a,$n)=@_;
X	local(@f);
X
X	if ($n > 0)
X		{
X		@f=&shiftl(*a,$n);
X		}
X	else
X		{
X		@f=&shiftr(*a,-$n);
X		}
X	return(@f);
X	}
X
Xsub shiftr
X	{
X	local(*a,$n)=@_;
X	local(@r,$i);
X
X	$#r=31;
X	foreach $i (0 .. 31)
X		{
X		if (($i+$n) > 31)
X			{
X			$r[$i]="--";
X			}
X		else
X			{
X			$r[$i]=$a[$i+$n];
X			}
X		}
X	return(@r);
X	}
X
Xsub shiftl
X	{
X	local(*a,$n)=@_;
X	local(@r,$i);
X
X	$#r=31;
X	foreach $i (0 .. 31)
X		{
X		if ($i < $n)
X			{
X			$r[$i]="--";
X			}
X		else
X			{
X			$r[$i]=$a[$i-$n];
X			}
X		}
X	return(@r);
X	}
X
Xsub printit
X	{
X	local(@a)=@_;
X	local($i);
X
X	foreach $i (0 .. 31)
X		{
X		printf "%2s  ",$a[$i];
X		print "\n" if (($i%8) == 7);
X		}
X	print "\n";
X	}
X
Xsub xor
X	{
X	local(*a,*b)=@_;
X	local(@r,$i);
X
X	$#r=31;
X	foreach $i (0 .. 31)
X		{
X		$r[$i]=&compress($a[$i].'^'.$b[$i]);
X#		$r[$i]=$a[$i]."^".$b[$i];
X		}
X	return(@r);
X	}
X
Xsub and
X	{
X	local(*a,$m)=@_;
X	local(@r,$i);
X
X	$#r=31;
X	foreach $i (0 .. 31)
X		{
X		$r[$i]=(($m & (1<<$i))?($a[$i]):('--'));
X		}
X	return(@r);
X	}
X
Xsub or
X	{
X	local(*a,*b)=@_;
X	local(@r,$i);
X
X	$#r=31;
X	foreach $i (0 .. 31)
X		{
X		$r[$i]='--'   if (($a[$i] eq '--') && ($b[$i] eq '--'));
X		$r[$i]=$a[$i] if (($a[$i] ne '--') && ($b[$i] eq '--'));
X		$r[$i]=$b[$i] if (($a[$i] eq '--') && ($b[$i] ne '--'));
X		$r[$i]='++'   if (($a[$i] ne '--') && ($b[$i] ne '--'));
X		}
X	return(@r);
X	}
X
Xsub compress
X	{
X	local($s)=@_;
X	local($_,$i,@a,%a,$r);
X
X	$s =~ s/\^\^/\^/g;
X	$s =~ s/^\^//;
X	$s =~ s/\^$//;
X	@a=split(/\^/,$s);
X
X	while ($#a >= 0)
X		{
X		$_=shift(@a);
X		next unless /\d/;
X		$a{$_}++;
X		}
X	foreach $i (sort keys %a)
X		{
X		next if ($a{$i}%2 == 0);
X		$r.="$i^";
X		}
X	chop($r);
X	return($r);
X	}
X1;
END_OF_FILE
  if test 1978 -ne `wc -c <'shifts.pl'`; then
    echo shar: \"'shifts.pl'\" unpacked with wrong size!
  fi
  # end of 'shifts.pl'
fi
echo shar: End of archive.
exit 0
