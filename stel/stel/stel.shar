#! /bin/sh
# This is a shell archive.  Remove anything before this line, then feed it
# into a shell via "sh file" or similar.  To overwrite existing files,
# type "sh file -c".
# The tool that generated this appeared in the comp.sources.unix newsgroup;
# send mail to comp-sources-unix@uunet.uu.net if you want that tool.
# Contents:  steld.c stel.c sub.c makeio.c md5c.c idea.c utmp_init.c
#   utmp_login.c utmp_logout.c updwtmp.c utmpx_init.c utmpx_login.c
#   utmpx_logout.c login.c logout.c logwtmp.c login_access.c sdihook.c
#   crc32.c truerand.c rc4.c defs.h idea.h md5.h global.h sys_defs.h
#   usuals.h rc4.h Makefile securid.conf skey.access skey.access.5
#   newvers.sh
# Wrapped by vince@idea on Tue Jan  2 16:53:36 1996
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
echo If this archive is complete, you will see the following message:
echo '          "shar: End of archive."'
if test -f 'steld.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'steld.c'\"
else
  echo shar: Extracting \"'steld.c'\" \(24323 characters\)
  sed "s/^X//" >'steld.c' <<'END_OF_FILE'
X/*
X * $Author: vince $
X * $Header: /res/usr/vince/src/stel/RCS/steld.c,v 1.102 1995/12/21 18:00:21 vince Exp $
X * $Date: 1995/12/21 18:00:21 $
X * $Revision: 1.102 $
X * $Locker:  $
X */
X
X#ifndef	lint
Xstatic char *rcsid = "@(#) $Id: steld.c,v 1.102 1995/12/21 18:00:21 vince Exp $";
X#endif	lint
X
X#include <stdio.h>
X#include <termios.h>
X#include <errno.h>
X#include <signal.h>
X#include <fcntl.h>
X#include <pwd.h>
X#include <syslog.h>
X#include <sys/stat.h>
X#include <netinet/in.h>
X#ifdef SUNOS4
X#include <sys/types.h>
X#include <sys/label.h>
X#include <sys/audit.h>
X#include <pwdadj.h>
X#include <utmp.h>
X#endif
X
X#ifdef HAS_SYS_PARAM_H
X#include <sys/param.h>
X#endif
X
X#ifdef AIX
X#include <sys/ioctl.h>
X#endif
X
X#ifdef SOLARIS
X#include <sys/stropts.h>
X#include <shadow.h>
X#endif
X
X/* md5 stuff */
X#include "global.h"
X#include "md5.h"
X
X#include "skey.h"
X#include "defs.h"
X
X#include "sys_defs.h"
X
X#define DEFAULT_PATH	"/bin:/usr/bin:/usr/ucb"
X
X#if defined (SUNOS4) || defined (SOLARIS)
X#define ERASECHAR	(0x7f)
X#define KILLCHAR	('u' & 0x1f)
X#else
X#define ERASECHAR	('h' & 0x1f)
X#define KILLCHAR	('x' & 0x1f)
X#endif
X
X/* idea stuff */
X#include "idea.h"
Xextern IDEAkey		c_ideakey;	/* client */
X
X/* des stuff */
X/* #include "des.h" */
Xextern des_key_schedule	c_schedule1;	/* client */
Xextern des_key_schedule	c_schedule2;	/* client */
Xextern des_key_schedule	c_schedule3;	/* client */
X
X/* IVs */
Xextern des_cblock	s_IV, c_IV;
X
Xextern char		sessionkeyhash[];
X
Xextern char		versionstring[];
X
Xvoid	fireman();
Xvoid	runshell();
X
Xstatic username[MAXUSERNAMELEN];
Xstatic fromhost[MAXHNAMELEN];
X
Xmain(argc, argv)
Xint	argc;
Xchar	*argv[];
X{
X	int		s, fh;
X	int		i, kflg, portnum;
X	int		timeout;
X	extern char	*optarg;
X	char		*p, *peername();
X
X#ifdef __ultrix
X	(void)openlog(STELSERVER, LOG_WARNING);
X#else
X	(void)openlog(STELSERVER, LOG_PID | LOG_ODELAY, LOG_DAEMON);
X#endif
X
X	kflg = 0;
X	portnum = 0;
X	timeout = IDLETIMEOUT;
X	while ((i = getopt(argc, argv, "kp:t:")) != EOF)
X		switch (i) {
X			/* do not kill IP-OPTIONS (killed by default) */
X			case	'k':
X				kflg++;
X				break;
X			case	'p':
X				portnum = atoi(optarg);
X				break;
X			case	't':
X				timeout = atoi(optarg);
X				break;
X			case	':':
X			case	'?':
X				syslog(LOGPRI, "bad options, exiting");
X				exit(1);
X				break;
X		}
X
X	if ((p = peername(0)) != NULL) { /* run by inetd */
X		if (portnum) 
X			syslog(LOGPRI, "run by inetd, -p option ignored");
X		strncpy(fromhost, p, sizeof(fromhost));
X		syslog(LOGPRI, "incoming connection from %s", fromhost);
X
X		if (!kflg) {
X#ifndef NO_IP_PROTO
X			/* kill IP_PROTO options */
X			if (killoptions(0, fromhost)) {
X				/* can't kill IP_OPTIONS */
X				(void)shutdown(0, 2);
X				(void)close(0);
X				exit(1);
X			}
X#endif
X		}
X
X		(void)serveclient(0, timeout);
X		syslog(LOGPRI, "end of connection from %s", fromhost);
X		(void)shutdown(0, 2);
X		(void)close(0);
X		exit(0);
X	}
X
X#ifndef DEBUG
X	detachfrompty();
X#endif /* DEBUG */
X
X	if (portnum == 0)
X		portnum = PORTNUM;
X	if ((s = establish(portnum)) == -1)
X		exit(1);
X
X	(void)signal(SIGCLD, fireman);
X
X	printf("server [%d] %s starting on port %d\n",
X					getpid(), versionstring, portnum);
X	syslog(LOGPRI, "server %s started on port %d",
X					versionstring, portnum);
X
X	for (; ; ) {
X		if ((fh = getconnection(s, fromhost)) < 0) {
X			if (errno == EINTR) /* child died */
X				continue;
X			syslog(LOGPRI, "accept(): %m");
X			exit(1);
X		}
X
X		syslog(LOGPRI, "connection from %s", fromhost);
X
X		if (!kflg) {
X#ifndef linux
X		/* kill IP_PROTO options */
X			if (killoptions(fh, fromhost)) {
X				/* can't kill IP_OPTIONS */
X				(void)shutdown(fh, 2);
X				(void)close(fh);
X				continue;
X			}
X#endif
X		}
X
X
X#ifdef DEBUG
X		(void)serveclient(fh, timeout);
X		(void)shutdown(fh, 2);
X		(void)close(fh);
X		syslog(LOGPRI, "end of connection from %s", fromhost);
X#else
X		switch(fork()) {
X			case	-1:
X				syslog(LOGPRI, "fork(): %m");
X				continue;
X			case	0:
X				(void)serveclient(fh, timeout);
X				(void)shutdown(fh, 2);
X				(void)close(fh);
X				syslog(LOGPRI, "end of connection from %s",
X							fromhost);
X				exit(0);
X			default:
X				(void)close(fh);
X				break;
X		}
X#endif
X	}
X
X	/*NOTREACHED*/
X	return(0);
X}
X
Xserveclient(fh, timeout)
Xint	fh;
Xint	timeout;
X{
X	cpacket		pp;
X	spacket		ppp;
X	int		child, firstack, sreply, pty, usepty = 0;
X	int		i, ret, cipher;
X	int		pfdin[2], pfdout[2], authpipe[2];
X	char		ttyline[16], *p, *authbuf, *authbuf2;
X	void		timeexpired();
X	MD5_CTX		mdContext;
X	unsigned char	digest[16];
X
X	char		*getstelsecret();
X
X	(void)signal(SIGALRM, timeexpired);
X	(void)alarm(LOGINTIMEOUT);
X
X	(void)strcpy((char *)username, "stillunknownuser");
X
X	if ((i = read(fh, &firstack, sizeof(firstack))) != sizeof(firstack)) {
X		if (!i)
X			syslog(LOGPRI, "Client has gone away.");
X		else
X			syslog(LOGPRI, "read(firstack): %m");
X		return(1);
X	}
X	firstack = ntohl(firstack);
X
X	if (!(firstack & FLG_NO_ENCRYPTION)) { /* encryption required */
X		if (dhexchange(fh, SERVER_SIDE, firstack, NULL) < 0) {
X			syslog(LOGPRI, "dhexchange(): %m");
X			return(1);
X		}
X	}
X
X	if ((i = read_data(fh, &pp, sizeof(pp))) != sizeof(pp)) {
X		if (!i)
X			syslog(LOGPRI, "Client has gone away.");
X		else
X			syslog(LOGPRI, "read(): %m");
X		return(1);
X	}
X
X	if (!(firstack & FLG_NO_ENCRYPTION)) {
X		if (firstack & FLG_USE_IDEA) {
X			cipher = IDEA_CIPHER;
X		}
X		else if (firstack & FLG_USE_SINGLE) {
X			cipher = DES_CIPHER;
X		}
X		else if (firstack & FLG_USE_RC4) {
X			cipher = RC4_CIPHER;
X		}
X		else { /* default */
X			cipher = TRIPLEDES_CIPHER;
X		}
X
X		/* set client IV */
X		memcpy(c_IV, pp.random, 8);
X
X		/* decrypt, skipping IV */
X		cryptbuf((char *)&pp + 8, sizeof(pp) - 8, DES_DECRYPT, cipher,
X								CLIENT_SIDE);
X	}
X
X	/* check integrity */
X	MD5Init(&mdContext);
X	/* skip digest itself */
X	MD5Update(&mdContext, &pp, sizeof(pp) - 16);
X	MD5Final(digest, &mdContext);
X
X	sreply = MSG_OKAY_DATA;
X
X	if (memcmp(digest, pp.digest, 16))
X		sreply = MSG_CORRUPTED_DATA; /* fail */
X	else if (htonl(pp.version) != VERSION) {
X		sreply = MSG_WRONG_VERSION;
X	}
X	else {
X		struct passwd	*pwd;
X
X		/* is ~/.stelsecret is required? */
X		if ((pwd = getpwnam(pp.username)) != NULL) {
X			char	spath[512];
X			
X			(void)sprintf(spath, "%s/%s",
X						pwd->pw_dir, STEL_SECRET_NAME);
X			/* ~/.stelsecret authentication required */
X			p = getstelsecret(spath, fromhost);
X			if (p != NULL) {
X				authbuf = (char *)strdup(p);
X				sreply |= MSG_LOGIN_AUTH_REQUIRED;
X			}
X		}
X			
X		/* is /etc/stelsecret authentication required? */
X		if ((authbuf2 = getstelsecret(ETC_STEL_SECRET_NAME, fromhost)) != NULL)
X			sreply |= MSG_SYSTEM_AUTH_REQUIRED;
X
X		/* if authentication is requred we refuse client's requests
X		not to use encryption. in other words encryption is a must
X		when performing mutual authentication */
X		if ((firstack & FLG_NO_ENCRYPTION) &&
X		    (sreply & MSG_LOGIN_AUTH_REQUIRED ||
X		     sreply & MSG_SYSTEM_AUTH_REQUIRED))
X			sreply = MSG_MUST_AUTH; /* fail */
X	}
X
X	i = htonl(sreply);
X	ppp.sreply = i;
X
X	if (!(firstack & FLG_NO_ENCRYPTION)) {
X		memcpy(ppp.random, (char *)randomdigest(), 16);
X		/* set server IV */
X		memcpy(s_IV, ppp.random, 8);
X	}
X
X	MD5Init(&mdContext);
X	/* skip digest itself */
X	MD5Update(&mdContext, &ppp, sizeof(ppp) - 16);
X	MD5Final(ppp.digest, &mdContext);
X
X	if (!(firstack & FLG_NO_ENCRYPTION)) {
X		cryptbuf((char *)&ppp + 8, sizeof(ppp) - 8, DES_ENCRYPT,
X							cipher, SERVER_SIDE);
X	}
X
X	if (write(fh, &ppp, sizeof(ppp)) != sizeof(ppp)) {
X		syslog(LOGPRI, "write(): %m");
X		return(1);
X	}
X
X	if (sreply == MSG_WRONG_VERSION) {
X		syslog(LOGPRI, "Wrong %s version: expected %d, received %d.",
X					STELSERVER, VERSION, htonl(pp.version));
X		return(1);
X	}
X
X	if (sreply == MSG_CORRUPTED_DATA) {
X		syslog(LOGPRI, "received CORRUPTED data from client");
X		return(1);
X	}
X
X	if (sreply == MSG_MUST_AUTH) {
X		syslog(LOGPRI, "NO ENCRYPTION request for client rejected");
X		return(1);
X	}
X
X	if (sreply & MSG_SYSTEM_AUTH_REQUIRED) {
X		ret = mauth(fh, authbuf2, SERVER_SIDE, firstack);
X		if (ret == -1) {
X			syslog(LOGPRI, "mauth(%s): %m", ETC_STEL_SECRET_NAME);
X			return(1);
X		}
X		else if (ret == 1) {
X			syslog(LOGPRI, "%s MUTUAL AUTHENTICATION FAILED",
X							ETC_STEL_SECRET_NAME);
X			return(1);
X		}
X		/* authentication succeeded */
X	}
X
X	if (sreply & MSG_LOGIN_AUTH_REQUIRED) {
X		ret = mauth(fh, authbuf, SERVER_SIDE, firstack);
X		if (ret == -1) {
X			syslog(LOGPRI, "mauth(%s): %m", STEL_SECRET_NAME);
X			return(1);
X		}
X		else if (ret == 1) {
X			syslog(LOGPRI, "%s MUTUAL AUTHENTICATION FAILED",
X							STEL_SECRET_NAME);
X			return(1);
X		}
X		/* authentication succeeded */
X	}
X
X	/* read modes */
X	pp.mode = ntohl(pp.mode);
X	pp.rows = ntohl(pp.rows);
X	pp.cols = ntohl(pp.cols);
X	if (!(pp.mode & FLG_DONTUSE_PTY))
X		usepty = 1;
X	
X	(void)strncpy(username, pp.username, sizeof(username));
X
X	if (usepty) {
X		if ((pty = getpty(ttyline)) == -1) {
X			syslog(LOGPRI, "no pseudo terminal available");
X			return(1);
X		}
X		if (pipe(authpipe) == -1) {
X			syslog(LOGPRI, "pipe(pipeauth): %m");
X			return(1);
X		}
X	}
X	else {
X		if (pipe(pfdin) == -1 ||
X		    pipe(pfdout) == -1) {
X			syslog(LOGPRI, "pipe(pfd): %m");
X			return(1);
X		}
X	}
X
X	switch ((child = fork())) {
X		case	-1:
X			syslog(LOGPRI, "fork(): %m");
X			if (usepty) {
X				(void)close(pty);
X			}
X			else {
X				(void)close(pfdout[0]);
X				(void)close(pfdout[1]);
X				(void)close(pfdin[0]);
X				(void)close(pfdin[1]);
X			}
X			return(1);
X		case	0:
X			/* alarm is cancelled by fork */
X			(void)alarm(LOGINTIMEOUT);
X
X			/* prevent user interrupts */
X			(void)signal(SIGINT, SIG_IGN);
X			(void)signal(SIGQUIT, SIG_IGN);
X
X			if (close(authpipe[0]) == -1) {
X				syslog(LOGPRI, "close(authpipe)");
X				exit(1);
X			}
X		
X			setterminal(usepty, ttyline, pfdin, pfdout,
X						pp.rows, pp.cols);
X
X			runshell(&pp, usepty, authpipe[1]);
X			/*NOTREACHED*/
X	}
X
X	(void)alarm(0); /* this is master side */
X
X	if (usepty) {
X		struct passwd	*pw;
X
X		if (close(authpipe[1]) == -1) {
X			syslog(LOGPRI, "close(authpipe)");
X			return(1);
X		}
X
X		if ((pw = getpwnam((char *)username)) == NULL) {
X			syslog(LOGPRI, 
X			"%s LOGIN ATTEMPTED (USER NOT EXISTENT), from %s",
X							username, fromhost);
X			return(1);
X		}
X
X		/* temporanely set user privileges.
X		this is needed for the file xfer facilities
X		*/
X		if (geteuid() == 0) {
X#ifdef AIX
X			priv_t priv;
X
X			priv.pv_priv[0] = 0;
X			priv.pv_priv[1] = 0;
X			setgroups(NULL, NULL);
X			if (setpriv(PRIV_SET | PRIV_INHERITED |
X						PRIV_EFFECTIVE |PRIV_BEQUEATH,
X			   &priv, sizeof(priv_t)) < 0 ||
X			   setgidx(ID_REAL|ID_EFFECTIVE, pwd->pw_gid) < 0 ||
X			   setuidx(ID_REAL|ID_EFFECTIVE, pw->pw_uid) < 0 ||
X			   seteuid((uid_t)pw->pw_uid) < 0) {
X				syslog(LOGPRI, "seteuid(%d): %m", pwd->pw_uid);
X				return(1);
X			}
X#else
X			if (seteuid(pw->pw_uid) == -1 ||
X			    setegid(pw->pw_gid) == -1) {
X				syslog(LOGPRI, "seteuid(%d): %m", pw->pw_uid);
X				return(1);
X			}
X#endif
X		}
X
X		if (makeio(pty, pty, fh, authpipe[0], SERVER_SIDE, firstack,
X				fromhost, NULL, NULL, timeout, username))
X			syslog(LOGPRI, "lost connection from %s", fromhost);
X
X		/* restore user privileges */
X		if (geteuid() == 0 &&
X		    (setuid(0) == -1 || setgid(0) == -1)) {
X			syslog(LOGPRI, "setuid(0): %m");
X			return(1);
X		}
X
X		/* eventually kill living child; this is necessary if
X		   connection with client drops somehow */
X		(void)signal(SIGCLD, fireman);
X		(void)kill(child, SIGKILL);
X
X		p = ttyline + sizeof("/dev/") - 1;
X#ifdef SYSV_UTMP
X		UTMP_LOGOUT(p);
X		(void)chown(ttyline, 0, 0);
X		(void)chmod(ttyline, 0644);
X#else /* SYSV_UTMP */
X		if (logout(p))
X			logwtmp(p, "", "");
X		(void)chmod(ttyline, 0666);
X		(void)chown(ttyline, 0, 0);
X		*p = 'p';
X		(void)chmod(ttyline, 0666);
X		(void)chown(ttyline, 0, 0);
X#endif /* SYSV_UTMP */
X		return(0);
X	}
X	else {
X		(void)close(pfdin[1]); (void)close(pfdout[0]);
X		if (makeio(pfdin[0], pfdout[1], fh, -1, SERVER_SIDE, firstack,
X				fromhost, NULL, NULL, timeout, username)) {
X			syslog(LOGPRI, "lost connection from %s", fromhost);
X		}
X		/* eventually kill living child; this is necessary if
X		   client failed */
X		(void)signal(SIGCLD, fireman);
X		(void)kill(child, SIGKILL);
X		return(0);
X	}
X	/*NOTREACHED*/
X}
X
X#if defined (hpux) || defined (IRIX)
Xchar    mailpath[] = "/usr/mail/\0\0\0\0\0\0\0\0\0\0";
X#else
Xchar    mailpath[] = "/usr/spool/mail/\0\0\0\0\0\0\0\0\0\0";
X#endif
Xchar    minusnam[16] = "-";
X
Xvoid
Xrunshell(pp, usepty, authfh)
Xcpacket	*pp;
Xint	usepty, authfh;
X{
X	char		*namep, *line = NULL;
X	struct passwd	*pwd;
X	int		status;
X	struct		skey	skey;
X	char		skeyprompt[80], skeybuf[80], stelkeyhash[64];
X	char		*ttyname(), *tty, *ttyn;
X	int		cnt, nosuchuser = 0;
X#ifdef SYSV_UTMP
X	/* SYSV login insists on an utmp(x) entry */
X	char *MAKE_UTMP_ID(), *utmp_id;
X#endif
X
X	if (usepty) {
X		if ((line = (char *)ttyname(0)) == NULL) {
X			(void)fprintf(stderr, "terminal not attached!?\n");
X			sleepexit(1);
X		}
X	}
X
X	if ((pwd = getpwnam((char *) username)) == NULL) {
X		syslog(LOGPRI,
X		"%s LOGIN ATTEMPTED (USER NOT EXISTENT), from %s",
X							username, fromhost);
X		nosuchuser = 1;
X		goto unixauth; /* make the hacker believe the user exists */
X	}
X
X	if(chdir(pwd->pw_dir) < 0) {
X		if ((pwd->pw_uid == 0) && (chdir("/") == 0))
X			printf("warning: $home is \"/\".\n");
X		else {
X			printf("unable to chdir to \"%s\"\n", pwd->pw_dir);
X			sleepexit(1);
X		}
X	}
X
X	if (usepty) {
X		if ((chmod(line, 0622) == -1 ||
X		    chown(line, pwd->pw_uid, pwd->pw_gid) == -1) &&
X		    !geteuid()) {
X			(void)fprintf(stderr, "cannot chown and chown terminal line\n");
X			sleepexit(1);
X		}
X	}
X
X	/* authentication loop */
X	for (cnt = 0; ; ) {
X		/* slow down guessing attacks (if ever) */
X		if (++cnt >= 3) {
X			if (cnt >= 10) {
X				syslog(LOGPRI,
X					"%s REPEATED LOGIN FAILURES from %s",
X							username, fromhost);
X				sleepexit(1);
X			}
X			sleep((u_int)((cnt - 3) * 5));
X		}
X
X		if (nosuchuser)
X			goto unixauth;
X#ifdef SECURID
X		/* sdi securID authentication */
X		if (issdiregistered(username)) {
X			printf("steld: SECURID authentication required for %s\n",
X								username);
X			if (!sdiauth(usepty, username))
X				goto authenticated;
X			syslog(LOGPRI, "%s SECURID LOGIN FAILURE from %s",
X						username, fromhost);
X			continue;
X
X		}
X#endif /* SECURID */
X
X		/* skey authentication */
X		skeyprompt[0] = '\0';
X		if (skeychallenge(&skey, (char *)username, skeyprompt)) {
X			/* user is not skey registered or skey daemon
X			it not responding.  default to unix authentication */
X			goto unixauth;
X		}
X		printf("steld: S/KEY authentication required for %s\n",
X								username);
X			
X		/* printf("[%s]\n",skeyprompt); */
X		printf("%s\n",skeyprompt);
X
X		printf("Response: ");
X		(void)fflush(stdout);
X		if (fgets(skeybuf, sizeof(skeybuf), stdin) == NULL)
X			sleepexit(1);
X		rip(skeybuf);
X		if (skeyverify(&skey, skeybuf))  {
X			syslog(LOGPRI, "%s SKEY LOGIN FAILURE from %s",
X						username, fromhost);
X			puts("Invalid response");
X			continue;
X		}
X		else { /* skey successful */
X			break;
X		}
Xunixauth:
X		if (!skeyaccess(username, line, fromhost, fromhost)) {
X			syslog(LOGPRI,
X				"UNIX PASSWORDS NOT PERMITTED for %s from %s",
X							username, fromhost);
X			puts("UNIX passwords NOT permitted.");
X			sleepexit(1);
X		}
X		/* unix password authentication */
X		printf("steld: UNIX password authentication required for %s\n",
X								username);
X		if (mkunixauth(usepty, nosuchuser)) {
X			syslog(LOGPRI, "%s LOGIN FAILURE from %s",
X							username, fromhost);
X			puts("Login incorrect");
X			continue;
X		}
X		else /* unixauth successful */
X			break;
X	}
X
X#ifdef SECURID
Xauthenticated:
X#endif
X	if (!login_access(username, fromhost)) {
X		syslog(LOGPRI, "%s LOGIN REFUSED FROM %s", username, fromhost);
X		puts("Permission denied");
X		sleepexit(1);
X	}
X
X	(void)alarm(0);
X
X	/* the following are performed by superuser only */
X	if (!geteuid()) {
X#ifndef SYSV_UTMP
X		struct utmp utmp;
X#endif
X
X		if (usepty) {
X			ttyn = ttyname(0);
X			if (ttyn == NULL || *ttyn == '\0')
X				ttyn = "/dev/tty??";
X			if ((tty = (char *) strchr(ttyn + 1, '/')))
X				++tty;
X			else
X				tty = ttyn;
X			
X#ifdef SYSV_UTMP
X			utmp_id = MAKE_UTMP_ID(ttyn, "tn");
X			UTMP_INIT(tty, ".telnet", utmp_id);
X			if (UTMP_LOGIN(tty, username, fromhost) != 0) {
X				syslog(LOGPRI, "UTMP_INIT() failed");
X				sleepexit(1);
X			}
X#else /* SYSV_UTMP */
X			memset((char *)&utmp, 0, sizeof(utmp));
X			(void)time(&utmp.ut_time);
X			strncpy(utmp.ut_name, username, sizeof(utmp.ut_name));
X#ifndef SOLARIS
X			strncpy(utmp.ut_host, fromhost, sizeof(utmp.ut_host));
X#endif
X			strncpy(utmp.ut_line, tty, sizeof(utmp.ut_line));
X			login(&utmp);
X#endif /* SYSV_UTMP */
X		}
X	}
X
X	if (!geteuid()) {
X#ifdef GENERICLOGIN
X		if (initgroups(pwd->pw_name, -1) == -1) {
X			syslog(LOGPRI, "initgroups(): %m");
X			sleepexit(1);
X		}
X#ifdef hpux
X		if (setgid(pwd->pw_gid) ||
X				setresuid(pwd->pw_uid, pwd->pw_uid, 0))
X#else
X		if (setgid(pwd->pw_gid) || setuid(pwd->pw_uid))
X#endif
X							{
X			(void)fprintf(stderr, "can not set user IDs");
X			sleepexit(1);
X		}
X#endif /* GENERICLOGIN */
X	}
X
X	(void)strncat(mailpath, pwd->pw_name, 8);
X	if (*pwd->pw_shell == '\0')
X		pwd->pw_shell = "/bin/sh";
X
X	/* provide a hashing of the session key */
X	sprintf(stelkeyhash, "%02x%02x%02x%02x%02x%02x%02x%02x",
X		(unsigned char)sessionkeyhash[0],
X		(unsigned char)sessionkeyhash[1],
X		(unsigned char)sessionkeyhash[2],
X		(unsigned char)sessionkeyhash[3],
X		(unsigned char)sessionkeyhash[4],
X		(unsigned char)sessionkeyhash[5],
X		(unsigned char)sessionkeyhash[6],
X		(unsigned char)sessionkeyhash[7]);
X
X	if (
X	    putvar("HOME",      pwd->pw_dir)	||
X	    putvar("LOGNAME",   pwd->pw_name)	||
X	    putvar("USER",   	pwd->pw_name)	||
X	    putvar("USERNAME", 	pwd->pw_name)	||
X	    putvar("SHELL",     pwd->pw_shell)	||
X	    putvar("MAIL",      mailpath)	||
X	    putvar("TERM",	pp->TERM)	||
X	    putvar("LINES",	pp->LINES)	||
X	    putvar("COLUMNS",	pp->COLUMNS)	||
X	    putvar("DISPLAY",	pp->DISPLAY)	||
X	    putvar("WINDOWID",	pp->WINDOWID)	||
X	    putvar("STELKEYHASH", stelkeyhash)	||
X	    /* putvar("PATH",	pp->PATH)	|| */
X	    putvar("PATH",	DEFAULT_PATH)
X						) {
X		(void)fprintf(stderr, "can not set environment\n");
X		sleepexit(1);
X	}
X
X	if (line == NULL)
X		line = "unattached";
X
X	/* restore signals */
X	(void)signal(SIGINT, SIG_DFL);
X	(void)signal(SIGQUIT, SIG_DFL);
X
X	if (usepty) {
X		if (write(authfh, USRAUTH, strlen(USRAUTH)) != strlen(USRAUTH)) {
X			syslog(LOGPRI, "write(authfh): %m");
X			exit(1);
X		}
X		/* won't be used again */
X		if (close(authfh) == -1) {
X			syslog(LOGPRI, "close(authbuf): %m");
X			exit(1);
X		}
X	}
X
X	if (pp->command[0] == '\0') {
X		if ((namep = (char *)strrchr(pwd->pw_shell, '/')) == NULL)
X			namep = pwd->pw_shell;
X		else
X			namep++;
X		(void)strcat(minusnam, namep);
X
X		syslog(LOGPRI, "%s LOGIN from %s, %s, \"%s\"",
X				username, fromhost, line, pwd->pw_shell);
X
X#ifdef GENERICLOGIN
X		(void)execl(pwd->pw_shell, minusnam, 0);
X		syslog(LOGPRI, "execl(%s): %m", pwd->pw_shell);
X		(void)fprintf(stderr, "no shell\n");
X		sleepexit(1);
X#else
X		/* -f: skip a second authentication
X		   -p: preserve environment
X		*/
X		(void)execl("/bin/login", "login", "-f", "-p", "-l",
X							pwd->pw_name, NULL);
X		syslog(LOGPRI, "execl(/bin/login): %m");
X		(void)fprintf(stderr, "no /bin/login\n");
X		sleepexit(1);
X#endif
X	}
X	else {
X		syslog(LOGPRI, "%s LOGIN from %s, %s, \"%s\"",
X					username, fromhost, line, pp->command);
X		(void)signal(SIGCLD, SIG_DFL);
X		if ((status = system(pp->command)) == -1) {
X			syslog(LOGPRI, "system() failed: %m");
X			sleepexit(1);
X		}
X		if (status & 0177 || status >> 8) {
X			syslog(LOGPRI, "command failed \"%s\"", pp->command);
X			sleepexit(1);
X		}
X		exit(0);
X	}
X}
X
Xputvar(name, value)
Xchar	*name, *value;
X{
X	char		*p;
X	size_t		size;
X	
X	if (!value || !*value)
X		return(0);
X	size = strlen(name) + strlen(value);
X	size += 2; /* '=' + '\0' */
X	if ((p = (char *) malloc(size)) == NULL) {
X		syslog(LOGPRI, "malloc(): %m");
X		return(1);
X	}
X	(void)sprintf(p, "%s=%s", name, value);
X	(void)putenv(p);
X
X	return(0);
X}
X
X
Xmkunixauth(usepty, fail)
Xint	usepty, fail;
X{
X	char		*crypt(), *getpass();
X	char		*p;
X	struct passwd	*pwd;
X	struct passwd	*shadow_getpwnam();
X
X	if (!fail && (pwd = shadow_getpwnam((char *) username)) == NULL)
X		/* non existent user */
X		return(1);
X
X	if (usepty) {
X		p = getpass("Password: ");
X		if (p == NULL || !strlen(p))
X			return(1);
X	}
X	else {
X		if ((p = (char *) malloc(MAXPWDLEN)) == NULL) {
X			syslog(LOGPRI, "malloc(): %m");
X			return(1);
X		}
X		fprintf(stderr, "Password (echo is on): ");
X		(void)fflush(stderr);
X		if (fgets(p, MAXPWDLEN, stdin) == NULL)
X			return(1);
X		/* p[strlen(p) - 2] = '\0'; */ /* remote \n\r */
X	}
X
X	if (fail)
X		return(1);
X
X	return(strcmp(pwd->pw_passwd, crypt(p, pwd->pw_passwd)));
X}
X
X#ifndef DEBUG
Xdetachfrompty()
X{
X	if (fork() > 0)
X		exit(0);
X	else {
X/*
X#if defined(SUNOS4) || defined(SOLARIS)
X		(void)setpgrp(getuid(), 0);
X#else
X		(void)setpgrp();
X#endif
X*/
X		setsid();
X	}
X}
X#endif
X
Xvoid
Xtimeexpired(s)
Xint	s;
X{
X	(void)signal(s, timeexpired);
X	syslog(LOGPRI, "time expired for %s from %s", username, fromhost);
X	exit(1);
X}
X
X#ifdef AIX
X#ifndef TIOCSWINSZ
X#define TIOCSWINSZ	_IOW('t', 103, struct winsize)  /* set window size */
X#endif
X#endif
Xsetterminal(usepty, ttyline, pfdin, pfdout, rows, cols)
Xchar	*ttyline;
Xint	usepty, *pfdin, *pfdout;
Xint	rows, cols;
X{
X	int		i;
X	struct winsize	os_window;
X
X	/* pty attached */
X	if (usepty) {
X		int		t;
X		struct termios	b;
X
X		if ((t = open(ttyline, O_RDWR)) == -1) {
X			syslog(LOGPRI, "open1(%s): %m", ttyline);
X			exit(1);
X		}
X
X#ifdef SOLARIS
X		if (ioctl(t, I_PUSH, "ptem") < 0 ||
X		    ioctl(t, I_PUSH, "ldterm") < 0 ||
X		    ioctl(t, I_PUSH, "ttcompat") < 0) {
X			syslog(LOGPRI, "Cannot push streams modules onto pty");
X			exit(1);
X		}
X#endif
X		/* get terminal attributes */
X		if (tcgetattr(t, &b) == -1) {
X			syslog(LOGPRI, "tcgetattr(): %m");
X			exit(1);
X		}
X
X#ifdef hpux
X		b.c_lflag |= ECHO | ECHOK | ECHOE | ICANON | ISIG;
X		b.c_iflag |= ICRNL | BRKINT | ISTRIP | IXON;
X		b.c_iflag &= ~(IXANY | PARMRK);
X		b.c_oflag |= ONLCR | OPOST;
X		b.c_oflag &= ~TAB3;
X#else
X		b.c_lflag |= ECHO;
X		b.c_iflag |= ICRNL;
X		b.c_oflag |= ONLCR;
X		b.c_oflag &= ~TAB3;
X#endif
X		b.c_cflag = B9600 | CS8 | CREAD | HUPCL;
X
X		b.c_cc[VERASE] = ERASECHAR;
X		b.c_cc[VKILL] = KILLCHAR;
X		b.c_cc[VEOF] = 'd'&0x1f;
X		b.c_cc[VINTR] = 0x3; /* ^C */
X		b.c_cc[VEOL] = b.c_cc[VSUSP] = 0;
X		if (tcsetattr(t, TCSANOW, &b) == -1) {
X			syslog(LOGPRI, "tcsetattr(): %m");
X			exit(1);
X		}
X
X
X		if (rows >= 0 && cols >= 0) {
X			os_window.ws_row = rows;
X			os_window.ws_col = cols;
X			if (ioctl(t,TIOCSWINSZ,&os_window) == -1) {
X				syslog(LOGPRI, "ioctl(): %m");
X				exit(1);
X			}
X		}
X
X		/* Acquire a controlling terminal */
X		if (setsid() == -1) {
X			syslog(LOGPRI, "setsid(): %m");
X			exit(1);
X		}
X		i = t;
X		if ((t = open(ttyline, O_RDWR)) < 0) {
X			syslog(LOGPRI, "open2(ttyline): %m");
X			exit(1);
X		}
X		(void)close(i);
X		
X		if (dup2(t, 0) == -1 ||
X		    dup2(t, 1) == -1 ||
X		    dup2(t, 2) == -1)  {
X			syslog(LOGPRI, "dup2(): %m");
X			exit(1);
X		}
X
X		return(t);
X
X	}
X	/* no pty attached */
X	else {
X		if (close(0) || close(1) || close(2)) {
X			syslog(LOGPRI, "close(): %m");
X			exit(1);
X		}
X
X#if defined(SUNOS4) || defined(SOLARIS)
X		if (setpgrp(getuid(), 0) == -1)
X#else
X		if (setpgrp() == -1)
X#endif
X					{
X			syslog(LOGPRI, "setpgrp(): %m");
X			exit(1);
X		}
X
X		if (dup(pfdout[0]) != 0 || dup(pfdin[1]) != 1 ||
X		    dup(pfdin[1]) != 2) {
X			syslog(LOGPRI, "dup(): %m");
X			exit(1);
X		}
X
X		if (close(pfdout[0]) == -1 || close(pfdout[1]) == -1 ||
X		    close(pfdin[0]) == -1 || close(pfdin[1]) == -1) {
X			syslog(LOGPRI, "close(): %m");
X			exit(1);
X		}
X		
X		return(-1); /* unused! */
X	}
X	/*NOTREACHED*/
X}
X
Xstruct passwd *
Xshadow_getpwnam(user)
Xchar	*user;
X{
X	static struct passwd	*pwd;
X#ifdef SUNOS4
X	struct passwd_adjunct	*pa;
X#else
X#ifdef SOLARIS
X	struct	spwd		*pa;
X#endif
X#endif
X	if ((pwd = getpwnam(user)) == NULL)
X		return(NULL);
X	
X#ifdef SUNOS4
X	if (issecure()) {
X		if ((pa = getpwanam(user)) == NULL)
X			return(NULL);
X		pwd->pw_passwd =  (char *)strdup(pa->pwa_passwd);
X	}
X#else
X#ifdef SOLARIS
X	if ((pa = getspnam(user)) == NULL)
X		return(NULL);
X	pwd->pw_passwd = (char *)strdup(pa->sp_pwdp);
X#endif
X#endif
X	return(pwd);
X}
X
X#ifdef SECURID
X#define SECURIDUSRLIST	"/etc/securid.conf"
Xissdiregistered(user)
Xchar	*user;
X{
X	char	line[80];
X	FILE	*fp;
X
X	if ((fp = fopen(SECURIDUSRLIST, "r")) == NULL)
X		return(0);
X	while (fgets(line, sizeof(line), fp) != NULL) {
X		rip(line);
X		if (line[0] == '#')
X			continue;
X		if (!strcmp(user, line)) {
X			(void)fclose(fp);
X			return(1);
X		}
X	}
X	(void)fclose(fp);
X	return(0);
X}
X#endif
X
Xsleepexit(eval)
Xint eval;
X{
X	sleep((u_int)5);
X	exit(eval);
X}
END_OF_FILE
  if test 24323 -ne `wc -c <'steld.c'`; then
    echo shar: \"'steld.c'\" unpacked with wrong size!
  fi
  # end of 'steld.c'
fi
if test -f 'stel.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'stel.c'\"
else
  echo shar: Extracting \"'stel.c'\" \(16874 characters\)
  sed "s/^X//" >'stel.c' <<'END_OF_FILE'
X/*
X * $Author: vince $
X * $Header: /res/usr/vince/src/stel/RCS/stel.c,v 1.115 1995/12/22 10:55:10 vince Exp $
X * $Date: 1995/12/22 10:55:10 $
X * $Revision: 1.115 $
X * $Locker:  $
X */
X
X#ifndef	lint
Xstatic char *rcsid = "@(#) $Id: stel.c,v 1.115 1995/12/22 10:55:10 vince Exp $";
X#endif	lint
X
X#include <stdio.h>
X#include <termios.h>
X#include <signal.h>
X#include <pwd.h>
X#include <netinet/in.h>
X#include <netdb.h>
X#include <syslog.h>
X
X#ifdef HAS_SYS_PARAM_H
X#include <sys/param.h>
X#endif
X
X#ifdef AIX
X#include <sys/ioctl.h>
X#endif
X#include "defs.h"
X
X/* md5 stuff */
X#include "global.h"
X#include "md5.h"
X
X/* idea stuff */
X#include "idea.h"
Xextern IDEAkey		c_ideakey;	/* client */
X
X/* des stuff */
X/* #include "des.h" */
Xextern des_key_schedule	c_schedule1;	/* client */
Xextern des_key_schedule	c_schedule2;	/* client */
Xextern des_key_schedule	c_schedule3;	/* client */
X
X/* IVs */
Xextern des_cblock	s_IV, c_IV;
X
Xextern int	logfh; /* log to file handler */
X
X#define OPTIONS "l:np:tvrmMi14AsDeh"
X
X#define USAGE		\
X"STEL: Secure TELnet, %s\n\
Xplease do not circulate --- bugs to stel-authors@idea.sec.dsi.unimi.it\n\
XUsage: %s [hostname] [-l logname] [-p port] [-%s] [commands...]\n\
X	hostname:	the system you want to connect to\n\
X     	-l logname:	the username on the remote system\n\
X	-p portnumber:	set port number\n\
X	-i:		use IDEA cipher\n\
X	-1:		use SINGLE DES cipher\n\
X	-4:		use RC4 cipher\n\
X	-n:		do not use data encryption\n\
X	-r:		enter a random string to enhance randomness\n\
X	-m:		use (small) 512 bits modulus\n\
X	-M:		use (large) 2048 bits modulus\n\
X	-A:		do not protect from active attacks\n\
X	-s:		maximum security mode: aka -a -M -i -r\n\
X	-t:		do not allocate a pseudo terminal\n\
X	-e:		disable escape features\n\
X	-v:		be verbose\n\
X	-D:		be extra verbose\n\
X	-h:		display this help screen\n\n\
XDefault port number is %d\n\
XDefault encryption algorithm is TRIPLE DES\n\
XDefault Diffie-Hellman modulus size is 1024 bits\n\
XDefault escape character is '^]'\n"
X#define USECRYPT	\
X"This session is using %s encryption for all data transmissions.\r\n"
X#define NOUSECRYPT	\
X"WARNING: NOT USING DATA ENCRYPTION -- THIS SESSION IS INSECURE\r\n"
X#define NOUSEPTY	\
X"This session is not using pseudo terminals: passwords will be visible.\r\n"
X#define BADOPTION	"option -%c is not compatible with previous options\n"
X#define ACTIVEPROTECT	\
X"This session is checking integrity and ordering for all data transmissions.\r\n"
X#define NOACTIVEPROTECT	\
X"-A option is set: no protection from active attacks, no file transfer\r\n"
X
Xextern char		versionstring[];
X
Xstruct termios		old, new;
Xint			ttyset;
Xstatic struct termios	saved_ttymode, noecho_ttymode; 
X
Xmain(argc, argv)
Xint	argc;
Xchar	*argv[];
X{
X	cpacket		pp;
X	spacket		ppp;
X	char		hostbuf[100], username[MAXUSERNAMELEN];
X	char		*tohost, *env, *encmode;
X	char		*rndstr, rndbuf[512], authbuf[STEL_SECRET_MAX_LEN];
X	int		i, s;
X	int		cipher;
X	int		firstack, sreply, noptyflg, errflg, rflg;
X	int		portnumber;
X	extern char	*optarg;
X	extern int	optind;
X	struct passwd	*pwd;
X	MD5_CTX		mdContext;
X	unsigned char	digest[16];
X	struct winsize	os_window;
X	struct servent	*serv;
X
X	void		trapper();
X
X	char		*getstelsecret();
X
X	/* using SYSV fashion */
X	tohost = NULL;
X	if (argc > 1 && argv[1][0] != '-') {
X		tohost = argv[1]; /* server name */
X		argv++;
X		argc--;
X	}
X
X	/* parse options */
X	errflg = noptyflg = rflg = 0;
X
X	firstack = 0;
X	rndstr = NULL;
X	bzero(&pp, sizeof(pp));
X
X	if ((serv = getservbyname(STELCLIENT, "tcp")) == NULL)
X		portnumber = PORTNUM;
X	else
X		portnumber = serv->s_port;
X	
X	/* testing */
X	/*
X	portnumber = 10006;
X	*/
X
X	firstack |= FLG_ACTIVE_ATTACKS;
X	while ((i = getopt(argc, argv, OPTIONS)) != -1)
X		switch (i) {
X			case	'l':
X				strncpy(username, optarg, sizeof(username));
X				strncpy(pp.username, optarg, sizeof(pp.username));
X				break;
X
X			case	't':
X				noptyflg++;
X				break;
X
X			case	'n':
X				if (firstack & FLG_USE_SINGLE ||
X				    firstack & FLG_USE_IDEA ||
X				    firstack & FLG_USE_RC4) {
X					fprintf(stderr, BADOPTION, i);
X					errflg++;
X					break;
X				}
X				firstack |= FLG_NO_ENCRYPTION;
X				break;
X
X			case	'1':
X				if (firstack & FLG_NO_ENCRYPTION ||
X				    firstack & FLG_USE_IDEA ||
X				    firstack & FLG_USE_RC4) {
X					fprintf(stderr, BADOPTION, i);
X					errflg++;
X					break;
X				}
X				firstack |= FLG_USE_SINGLE;
X				break;
X
X			case	'i':
X				if (firstack & FLG_NO_ENCRYPTION ||
X				    firstack & FLG_USE_SINGLE ||
X				    firstack & FLG_USE_RC4) {
X					fprintf(stderr, BADOPTION, i);
X					errflg++;
X					break;
X				}
X				firstack |= FLG_USE_IDEA;
X				break;
X
X			case	'4':
X				if (firstack & FLG_NO_ENCRYPTION ||
X				    firstack & FLG_USE_SINGLE ||
X				    firstack & FLG_USE_IDEA) {
X					fprintf(stderr, BADOPTION, i);
X					errflg++;
X					break;
X				}
X				firstack |= FLG_USE_RC4;
X				break;
X
X			case	'm':
X				if (firstack & FLG_NO_ENCRYPTION) {
X					fprintf(stderr, BADOPTION, i);
X					errflg++;
X					break;
X				}
X				firstack |= FLG_SMALL_MODULUS;
X				break;
X
X			case	'M':
X				if (firstack & FLG_NO_ENCRYPTION) {
X					fprintf(stderr, BADOPTION, i);
X					errflg++;
X					break;
X				}
X				firstack |= FLG_LARGE_MODULUS;
X				break;
X
X			case	'A':
X				firstack &= ~FLG_ACTIVE_ATTACKS;
X				break;
X
X			case	'r':
X				if (firstack & FLG_NO_ENCRYPTION) {
X					fprintf(stderr, BADOPTION, i);
X					errflg++;
X					break;
X				}
X				rflg++;
X				break;
X
X			case	'p':
X				portnumber = atoi(optarg);
X				if (portnumber < 0) {
X					fprintf(stderr, "bad port number\n");
X					errflg++;
X				}
X				break;
X
X			case	'v':
X				firstack |= FLG_BE_VERBOSE;
X				break;
X
X			case	'D':
X				firstack |= FLG_BE_VERBOSE;
X				firstack |= FLG_DEBUG;
X				break;
X
X			case	'e':
X				firstack |= FLG_NO_ESCAPE;
X				break;
X
X			case	'h':
X				(void)fprintf(stderr,
X					USAGE, versionstring,
X					STELCLIENT, OPTIONS, PORTNUM);
X				exit(0);
X				break;
X			
X			case	's':
X				if (firstack & FLG_NO_ENCRYPTION) {
X					fprintf(stderr, BADOPTION, i);
X					errflg++;
X					break;
X				}
X				firstack |= FLG_LARGE_MODULUS;
X				firstack |= FLG_USE_IDEA;
X				firstack |= FLG_ACTIVE_ATTACKS;
X				rflg++;
X				break;
X
X			case	'?':
X			case	':':
X				errflg++;
X				break;
X		}
X
X	if (errflg) {
X		(void)fprintf(stderr, "bad options -- %s -h for help.\n",
X								STELCLIENT);
X		exit(1);
X	}
X
X	if (rflg) {
X		if (getstelpass("Enter a lenghty random string", rndbuf,
X							sizeof(rndbuf))) {
X			(void)fprintf(stderr, "string must be provided!\n");
X			exit(1);
X		}
X		if (strlen(rndbuf) < 16) {
X			(void)fprintf(stderr, "please enter a longer string!\n");
X			exit(1);
X		}
X		rndstr = rndbuf;
X	}
X
X	/* set command */
X	for (i = 0; optind < argc; optind++) {
X		i += strlen(argv[optind]) + 1;
X		if (i > sizeof(pp.command) - 2) {
X			(void)fprintf(stderr, "command is too large.\n");
X			exit(1);
X		}
X		(void)strcat(pp.command, argv[optind]);
X		if (optind < argc -1)
X			(void)strcat(pp.command, " ");
X	}
X
X	/* set username */
X	if (pp.username[0] == '\0') {
X		if ((pwd = getpwuid(getuid())) == NULL) {
X			(void)fprintf(stderr, "Who are you?\n");
X			exit(1);
X		}
X		strncpy(username, pwd->pw_name, sizeof(username));
X		strncpy(pp.username, pwd->pw_name, sizeof(pp.username));
X	}
X
X	/* don't use terminals when deattached from a terminal */
X	if (!isatty(0)) {
X		noptyflg = 1;
X		pp.mode |= FLG_DONTUSE_PTY;
X	}
X	/* command line option */
X	else if (noptyflg)
X		pp.mode |= FLG_DONTUSE_PTY;
X
X	
X	if (!noptyflg && isatty(0) && ioctl(0, TIOCGWINSZ, &os_window) >= 0) {
X		pp.rows = os_window.ws_row;
X		pp.cols = os_window.ws_col;
X	}
X	else {
X		pp.rows = (-1);
X		pp.cols = (-1);
X	}
X
X	/* set environment */
X	if ((env = (char *)getenv("TERM")) != NULL)
X		strncpy(pp.TERM, env, sizeof(pp.TERM));
X	if ((env = (char *)getenv("DISPLAY")) != NULL)
X		strncpy(pp.DISPLAY, env, sizeof(pp.DISPLAY));
X	if ((env = (char *)getenv("LINES")) != NULL)
X		strncpy(pp.LINES, env, sizeof(pp.LINES));
X	if ((env = (char *)getenv("COLUMNS")) != NULL)
X		strncpy(pp.COLUMNS, env, sizeof(pp.COLUMNS));
X	if ((env = (char *)getenv("WINDOWID")) != NULL)
X		strncpy(pp.WINDOWID, env, sizeof(pp.WINDOWID));
X	/*
X	if ((env = (char *)getenv("PATH")) != NULL)
X		strncpy(pp.PATH, env, sizeof(pp.PATH));
X	*/
X
X	if (tohost == NULL) {
X		printf("Hostname? ");
X		if (fgets(hostbuf, sizeof(hostbuf), stdin) == NULL) {
X			(void)fprintf(stderr, "no host?\n");
X			exit(1);
X		}
X		tohost = hostbuf;
X		rip(tohost);
X		if (!strlen(tohost)) {
X			(void)fprintf(stderr, "No host?\n");
X			exit(1);
X		}
X	}
X
X#ifdef __ultrix
X	(void)openlog(STELCLIENT, LOG_WARNING);
X#else
X	(void)openlog(STELCLIENT, LOG_PID | LOG_ODELAY, LOG_DAEMON);
X#endif
X
X	if ((s = callsocket(tohost, portnumber)) == -1)
X		exit(1);
X
X	if (firstack & FLG_BE_VERBOSE)
X		printf("Connected to %s on port %d.\n", tohost, portnumber);
X	else
X		printf("Connected to %s.\n", tohost);
X	
X	/* tell master about user selected options */
X	if (firstack & FLG_DEBUG)
X		printf("\nSENDING FIRSTACK 0x%02X TO SERVER\n",
X								firstack);
X	i = htonl(firstack);
X	if (write(s, &i, sizeof(firstack)) != sizeof(firstack)) {
X		perror("write(firstack)");
X		exit(1);
X	}
X
X	pp.mode = htonl(pp.mode);
X	pp.rows = htonl(pp.rows);
X	pp.cols = htonl(pp.cols);
X	pp.version = htonl(VERSION);
X
X	if (!(firstack & FLG_NO_ENCRYPTION)) {
X		memcpy(pp.random, (char *)randomdigest(), 16);
X		if (firstack & FLG_DEBUG) {
X			hexdump("client stream randomizer: ", pp.random, 16);
X		}
X	}
X
X	MD5Init(&mdContext);
X	/* skip digest itself */
X	MD5Update(&mdContext, &pp, sizeof(pp) - 16);
X	MD5Final(pp.digest, &mdContext);
X
X	if (!(firstack & FLG_NO_ENCRYPTION)) { /* encryption required */
X		/* exchange keys */
X		if (dhexchange(s, CLIENT_SIDE, firstack, rndstr) < 0) {
X			perror("dhexchange()");
X			exit(1);
X		}
X
X		/* use IDEA encryption */
X		if (firstack & FLG_USE_IDEA) {
X			encmode = "IDEA";
X			cipher = IDEA_CIPHER;
X		}
X
X		/* use SINGLE DES encryption */
X		else if (firstack & FLG_USE_SINGLE) {
X			encmode = "SINGLE DES";
X			cipher = DES_CIPHER;
X		}
X
X		/* use IDEA encryption */
X		else if (firstack & FLG_USE_RC4) {
X			encmode = "RC4";
X			cipher = RC4_CIPHER;
X		}
X
X		/* use triple DES encryption by default */
X		else {
X			encmode = "TRIPLE DES";
X			cipher = TRIPLEDES_CIPHER;
X		}
X
X		/* set client IV */
X		memcpy(&c_IV, pp.random, 8);
X
X		/* encrypt pp, skipping IV */
X		cryptbuf((char *)&pp + 8, sizeof(pp) - 8, DES_ENCRYPT, cipher,
X								CLIENT_SIDE);
X	}
X
X	if (firstack & FLG_DEBUG) {
X		printf("\nSENDING ENVINFO TO SERVER\n");
X		hexdump("first envinfo 20 bytes: ", &pp, 20);
X		hexdump("next envinfo 20 random bytes : ",
X							(char *)&pp + 20, 20);
X		hexdump("next envinfo 20 random bytes : ",
X							(char *)&pp + 40, 20);
X	}
X
X	if (write_data(s, &pp, sizeof(pp)) != sizeof(pp)) {
X		perror("write()");
X		exit(1);
X	}
X
X	/* we have send the packet to server, now let's listen to its reply */
X	if ((i = read(s, &ppp, sizeof(ppp)) != sizeof(ppp))) {
X		if (!i) {
X			printf("Server has gone away.\n");
X			exit(1);
X		}
X		perror("read()");
X		exit(1);
X	}
X
X	if (!(firstack & FLG_NO_ENCRYPTION)) { /* encryption required */
X		/* set server IV */
X		memcpy(&s_IV, ppp.random, 8);
X
X		/* decrypt it skipping server IV */
X		cryptbuf((char *)&ppp + 8, sizeof(ppp) - 8, DES_DECRYPT,
X							cipher, SERVER_SIDE);
X
X	}
X
X	/* check ppp integrity */
X	MD5Init(&mdContext);
X	/* skip digest itself */
X	MD5Update(&mdContext, &ppp, sizeof(ppp) - 16);
X	MD5Final(digest, &mdContext);
X
X	if (memcmp(digest, ppp.digest, 16)) {
X		printf("Received corrupted data from server!\n");
X		exit(1);
X	}
X
X	ppp.sreply = ntohl(ppp.sreply);
X
X	if (firstack & FLG_DEBUG) {
X		printf("\nREAD REPLY FROM SERVER\n");
X		printf("sreply flag: 0x%02X\n", ppp.sreply);
X
X		if (!(firstack & FLG_NO_ENCRYPTION))
X			hexdump("server stream randomizer: ", ppp.random, 16);
X	}
X
X	if (ppp.sreply & MSG_WRONG_VERSION) {
X		printf("%s version mismatch.  Can not talk with server.\n",
X								STELCLIENT);
X		exit(1);
X	}
X					
X
X	/* this is is weak, and it is intended as an experimental feature
X	only.  the point is that /etc/stelsecret should be readable by the
X	user.  this is no good since the user could make /etc/stelsecret
X	public and thus completely defeat the mutual authentication method.
X	actually, stel is supposed to be run as a SUID to root program in
X	order to take advantage of this feature. I do not like SUIDed
X	programs, though. */
X	if (ppp.sreply & MSG_SYSTEM_AUTH_REQUIRED) {
X		char	*systelsec;
X
X		printf("Host mutual authentication is required by %s.\n",
X								tohost);
X
X		if ((systelsec = getstelsecret(ETC_STEL_SECRET_NAME, tohost)) == NULL) {
X			printf("Cannot access %s\n", ETC_STEL_SECRET_NAME);
X			if (getstelpass("Please enter it manually", authbuf,
X							sizeof(authbuf))) {
X				(void)fprintf(stderr, "No secret?\n");
X				exit(1);
X			}
X			systelsec = authbuf;
X		}
X
X		i = mauth(s, systelsec, CLIENT_SIDE, firstack);
X		bzero(systelsec, strlen(systelsec));
X		if (i == -1) {
X			perror("mauth()");
X			exit(1);
X		}
X		else if (i == 1) {
X			fprintf(stderr, "Host mutual authentication failed!\n");
X			exit(1);
X		}
X		printf("Host mutual authentication OK\n");
X	}
X
X	/* restore ids, in case stel was a SUID program */
X	if (setgid(getgid()) == -1) {
X		perror("setgid()");
X		exit(1);
X	}
X	if (setuid(getuid()) == -1) {
X		perror("setuid()");
X		exit(1);
X	}
X
X	if (ppp.sreply & MSG_LOGIN_AUTH_REQUIRED) {
X		printf("User mutual authentication required by %s@%s.\n",
X							username, tohost);
X
X		if (getstelpass("Enter stelsecret", authbuf, sizeof(authbuf))) {
X			(void)fprintf(stderr, "No secret?\n");
X			exit(1);
X		}
X
X		i = mauth(s, authbuf, CLIENT_SIDE, firstack);
X		if (i == -1) {
X			perror("mauth()");
X			exit(1);
X		}
X		else if (i == 1) {
X			fprintf(stderr, "User mutual authentication failed!\n");
X			exit(1);
X		}
X		printf("User mutual authentication OK\n");
X	}
X		
X	if (ppp.sreply == MSG_MUST_AUTH) {
X		printf(
X			"Mutual authentication required -- not using encryption, aborting...\n");
X		exit(1);
X	}
X	
X	if (ppp.sreply == MSG_CORRUPTED_DATA) {
X		printf("Server received corrupted data from us!\n");
X		exit(1);
X	}
X
X	/* server allocates a pseudo terminal */
X	if (!noptyflg) {
X		(void)signal(SIGINT, trapper);
X		(void)signal(SIGQUIT, trapper);
X		(void)signal(SIGHUP, trapper);
X		(void)signal(SIGTERM, trapper);
X
X		/* set terminal to raw */
X		if (tcgetattr(0, &old) == -1) {
X			perror("tcgetattr()");
X			exit(1);
X		}
X		(void)memcpy(&new, &old, sizeof(struct termios));
X		new.c_cc[VTIME] = 0;
X		new.c_cc[VMIN]  = 1;
X		new.c_cc[VINTR] = 0;
X		new.c_lflag &= ~(ECHO | ISIG | ICANON);
X		new.c_oflag &= ~(ONLCR | OPOST);
X#ifndef SOLARIS
X#if defined(BSD) && (BSD >= 199306)
X		new.c_iflag &= ~(INLCR | ICRNL | IXON | IXOFF | 
X							ISTRIP | BRKINT);
X#else
X		new.c_iflag &= ~(INLCR | ICRNL | IXON | IXOFF | IUCLC |
X							ISTRIP | BRKINT);
X#endif
X#else /* !SOLARIS */
X		new.c_iflag &= ~(INLCR | ICRNL | IXON | IXOFF | IUCLC |
X							ISTRIP | BRKINT);
X#endif /* SOLARIS */
X		if (tcsetattr(0, TCSANOW, &new) == -1) {
X			perror("tcgetattr()");
X			exit(1);
X		}
X		ttyset = 1;
X	}
X
X	if (firstack & FLG_NO_ENCRYPTION)
X		printf(NOUSECRYPT);
X	else
X		printf(USECRYPT, encmode);
X
X	if (firstack & FLG_ACTIVE_ATTACKS)
X		printf(ACTIVEPROTECT);
X	else
X		printf(NOACTIVEPROTECT);
X
X	/* escape status */
X	if (noptyflg) {
X		printf(NOUSEPTY);
X		printf("Escape features disabled.\r\n");
X	}
X	else
X		printf("Escape character is '^]'.\r\n");
X
X	cprintf("please note the pid\r\n");
X	cprintf("messages without the pid are originated by remote party\r\n");
X	cprintf("----GOING REMOTE----\r\n\n");
X
X	if (makeio(0, 1, s, -1, CLIENT_SIDE, firstack, tohost,
X				&old, &new, NOTIMEOUT, username)) {
X		if (logfh)
X			(void)close(logfh);
X		if (!noptyflg)
X			(void)tcsetattr(0, TCSANOW, &old);
X		cprintf("Connection with %s lost.\n", tohost);
X		(void)shutdown(s, 2);
X		(void)close(s);
X		exit(1);
X	}
X	if (logfh)
X		(void)close(logfh);
X	(void)shutdown(s, 2);
X	(void)close(s);
X	if (!noptyflg)
X		(void)tcsetattr(0, TCSANOW, &old);
X	cprintf("Connection with %s closed.\n", tohost);
X	return(0);
X}
X
Xvoid
Xtrapper(s)
Xint	s;
X{
X	(void)signal(s, trapper);
X
X	(void)fprintf(stderr, "%s: trapped signal %d!\n", STELCLIENT, s);
X	if (ttyset)
X		(void)tcsetattr(0, TCSANOW, &old);
X	exit(1);
X}
X
Xgetstelpass(prompt, buf, len)
Xchar	*prompt, *buf;
Xint	len;
X{
X	void		(*oldsig) (); 
X	void		gp_restore_ttymode();
X
X	if (isatty(0)) {
X		printf("%s: ", prompt);
X		(void)fflush(stdout);
X		/* ECHO OFF */
X		tcgetattr(0, &saved_ttymode);
X		if ((oldsig = signal(SIGINT, SIG_IGN)) != SIG_IGN)
X			(void)signal(SIGINT, gp_restore_ttymode);
X		tcgetattr(0, &noecho_ttymode);
X		noecho_ttymode.c_lflag &= ~ECHO;
X		tcsetattr(0, TCSANOW, &noecho_ttymode);
X	}
X	else {
X		printf("%s (echo is on): ", prompt);
X		(void)fflush(stdout);
X	}
X
X	/* get password */
X	if (fgets(buf, len, stdin) == NULL)
X		return(1);
X	rip(buf);
X
X	if (isatty(0)) {
X		/* ECHO ON */
X		tcsetattr(0, TCSANOW, &saved_ttymode);
X		if (oldsig != SIG_IGN)
X			(void)signal(SIGINT, oldsig);
X		printf("\n");
X	}
X	return(0);
X}
X
X/* restore - restore terminal modes when user aborts command */
Xvoid gp_restore_ttymode()
X{
X	if (tcsetattr(0, TCSANOW, &saved_ttymode) == -1)
X		perror("tcsetattr()");
X	exit(1);
X}
X
END_OF_FILE
  if test 16874 -ne `wc -c <'stel.c'`; then
    echo shar: \"'stel.c'\" unpacked with wrong size!
  fi
  # end of 'stel.c'
fi
if test -f 'sub.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'sub.c'\"
else
  echo shar: Extracting \"'sub.c'\" \(36262 characters\)
  sed "s/^X//" >'sub.c' <<'END_OF_FILE'
X/*
X * $Author: vince $
X * $Header: /res/usr/vince/src/stel/RCS/sub.c,v 1.94 1995/12/21 10:58:55 vince Exp $
X * $Date: 1995/12/21 10:58:55 $
X * $Revision: 1.94 $
X * $Locker:  $
X */
X
X#ifndef	lint
Xstatic char *rcsid = "@(#) $Id: sub.c,v 1.94 1995/12/21 10:58:55 vince Exp $";
X#endif	lint
X
X#include <stdio.h>
X#include <termios.h>
X#include <fcntl.h>
X#include <unistd.h>
X#include <sys/types.h>
X#include <netinet/in.h>
X#include <sys/socket.h>
X#include <netdb.h>
X#include <errno.h>
X#include <sys/wait.h>
X#include <signal.h>
X#include <sys/stat.h>
X#include <sys/utsname.h>
X#include <syslog.h>
X#include <varargs.h>
X
X#include "regex.h"
X
X#ifdef HAS_SYS_PARAM_H
X#include <sys/param.h>
X#endif
X
X#ifndef SOLARIS
X#if (defined(BSD) && (BSD >= 199306))
X#define SIGCLD  SIGCHLD
X#endif
X#endif
X
X/* md5 stuff */
X#include "global.h"
X#include "md5.h"
X
X#include "gmp.h"
X
X#include "defs.h"
X
X/* idea stuff */
X#include "idea.h"
XIDEAkey			s_ideakey;	/* server */
XIDEAkey			c_ideakey;	/* client */
X
X/* des stuff */
X/* #include "des.h" */
Xdes_key_schedule	s_schedule1;	/* server */
Xdes_key_schedule	s_schedule2;	/* server */
Xdes_key_schedule	s_schedule3;	/* server */
Xdes_key_schedule	c_schedule1;	/* client */
Xdes_key_schedule	c_schedule2;	/* client */
Xdes_key_schedule	c_schedule3;	/* client */
X
Xdes_cblock		s_IV;		/* server, IDEA and DES only */
Xdes_cblock		c_IV;		/* client, IDEA and DES only */
X
X/* rc4 stuff */
X#include "rc4.h"
XRC4Context		s_rc4;		/* server */
XRC4Context		c_rc4;		/* client */
X
X/* rc5 stuff */
Xunsigned char		s_rc5[16];	/* server */
Xunsigned char		c_rc5[16];	/* client */
X
X/* initialisation variables */
X
X/* global */
Xchar		sessionkeyhash[8];
X
Xstatic char	*buildregexp();
Xstatic		oneofthese();
Xstatic		doaddrmatch();
Xstatic void	CFBcrypt();
X
Xestablish(portnum)
Xint	portnum;
X{
X	struct sockaddr_in	sa;
X	int			s, on = 1;
X	struct servent		*serv;
X
X	if (!portnum) {
X		if ((serv = getservbyname(STELCLIENT, "tcp")) == NULL)
X			portnum = PORTNUM;
X		else
X			portnum = serv->s_port;
X	}
X	
X	sa.sin_family 		= AF_INET;
X	sa.sin_addr.s_addr	= INADDR_ANY;
X	sa.sin_port		= htons((u_short)portnum);
X
X	if ((s = socket(AF_INET, SOCK_STREAM, 0)) == -1) {
X		syslog(LOGPRI, "socket(): %m");
X		return(-1);
X	}
X
X	if (setsockopt(s, SOL_SOCKET, SO_KEEPALIVE,
X					(char *)&on, sizeof (on)) == -1) {
X		syslog(LOGPRI, "setsockopt (SO_KEEPALIVE): %m");
X		return(-1);
X	}
X
X#ifdef DEBUG
X	if (setsockopt(s, SOL_SOCKET, SO_REUSEADDR,
X					(char *)&on, sizeof (on)) == -1) {
X		syslog(LOGPRI, "setsockopt (SO_REUSEADDR): %m");
X		return(-1);
X	}
X#endif
X	
X	if (bind(s, (struct sockaddr *)&sa, sizeof(sa)) == -1) {
X		perror("bind()");
X		(void)fprintf(stderr, "cannot bind to port %d; may be another server is running?\n",
X							portnum);
X		syslog(LOGPRI, "bind(%d): %m", portnum);
X		return(-1);
X	}
X	
X	if (listen(s, 10) == -1) {
X		syslog(LOGPRI, "listen(): %m");
X		return(-1);
X	}
X	return(s);
X}
X
Xgetconnection(s, hostname)
Xint	s;
Xchar	*hostname;
X{
X	struct sockaddr_in	sa;
X	struct hostent		*he;
X	int			t, salen;
X
X	salen = sizeof(sa);
X	if ((t = accept(s, (struct sockaddr *)&sa, &salen)) < 0) {
X		return(-1);
X	}
X	
X	if ((he = gethostbyaddr((char *)&sa.sin_addr,
X				sizeof(struct in_addr), AF_INET)) == NULL)
X		(void)strcpy(hostname, (char *)inet_ntoa(sa.sin_addr));
X	else
X		(void)strncpy(hostname, he->h_name, MAXHNAMELEN);
X	return(t);
X}
X
Xchar *
Xpeername(fd)
Xint	fd;
X{
X	struct sockaddr_in	addr;
X	struct hostent		*he;
X	static char		name[MAXHNAMELEN];
X	int			addrlen = sizeof(addr);
X
X	if (getpeername(fd, (struct sockaddr *)&addr, &addrlen) == -1)
X		return(NULL);
X
X	if ((he = gethostbyaddr((char *)&addr.sin_addr,
X				sizeof(struct in_addr), AF_INET)) == NULL)
X		(void)strcpy(name, (char *) inet_ntoa(addr.sin_addr));
X	else
X		(void)strncpy(name, he->h_name, sizeof(name));
X	return(name);
X}
X
Xcallsocket(hostname, portnum)
Xchar	*hostname;
Xint	portnum;
X{
X	struct sockaddr_in	sa;
X	struct hostent		*hp;
X	int			s, on = 1;
X	extern int		errno;
X
X	bzero(&sa, sizeof(sa));
X	if ((hp = gethostbyname(hostname)) == NULL) {
X		if ((sa.sin_addr.s_addr = inet_addr(hostname)) == -1) {
X			(void)fprintf(stderr, "%s: unknown host\n", hostname);
X			return(-1);
X		}
X	}
X	else {
X		(void)memcpy((char *) &sa.sin_addr, hp->h_addr, hp->h_length);
X		strcpy(hostname, hp->h_name);
X	}
X	sa.sin_family = AF_INET;
X	sa.sin_port = htons((u_short)portnum);
X
X	if ((s = socket(AF_INET, SOCK_STREAM, 0)) < 0) {
X		perror("socket()");
X		return(-1);
X	}
X	if (setsockopt(s, SOL_SOCKET, SO_KEEPALIVE, (char *)&on,
X							sizeof(on)) == -1) {
X		perror("setsockopt(SO_KEEPALIVE)");
X		return(-1);
X	}
X	
X#if defined(SOCKS)
X	if (Rconnect(s, (struct sockaddr *)&sa, sizeof(sa)) == -1) {
X#else
X	if (connect(s, (struct sockaddr *)&sa, sizeof(sa)) == -1) {
X#endif
X                perror("connect()");
X                return(-1);
X        }
X	
X	return(s);
X}
X
Xvoid
Xfireman()
X{
X#if defined(hpux) || defined(SOLARIS) || defined(IRIX) || defined(AIX)
X	int	wstatus;
X#else
X	union wait      wstatus;
X#endif
X
X	while (wait3(&wstatus, WNOHANG, NULL) > 0)
X		;
X	(void)signal(SIGCLD, fireman);
X}
X
X#ifdef IRIX
Xint	getpty(line)
Xchar	*line;
X{
X	int		slave;
X	char		*_getpty();
X	char		*mline;
X
X	mline = _getpty(&slave, O_RDWR, 0600, 1);
X	if (mline == NULL) {
X		perror("_getpty()");
X		return(-1);
X	}
X	strcpy(line, mline);
X	return(slave);
X}
X#else /* !IRIX */
X#ifdef SOLARIS
X#include <sys/stropts.h>
Xint	getpty(line)
Xchar	*line;
X{
X	int	p;
X	char	*buf;
X	char	*ptsname();
X
X	if ((p = open("/dev/ptmx", O_RDWR)) < 0) {
X		puts("All network ports in use");
X		return(-1);
X	}
X	if (grantpt(p) < 0 || unlockpt(p) < 0) {
X		puts("Cannot initialize pty slave");
X		return(-1);
X	}
X
X	if ((buf = ptsname(p)) == 0) {
X		puts("Cannot find  pty slave");
X		return(-1);
X	}
X	strcpy(line, buf);
X
X	return(p);
X}
X
X#else /* !SOLARIS */
Xint	getpty(line)
Xchar	*line;
X{
X        register int p;
X        register char c, *p1, *p2;
X        register int i;
X	char tmp[16];
X
X#ifdef hpux
X        (void) sprintf(line, "/dev/ptym/ptyXX");
X        p1 = &line[13];
X        p2 = &line[14];
X#else
X        (void) sprintf(line, "/dev/ptyXX");
X        p1 = &line[8];
X        p2 = &line[9];
X#endif
X        for (c = 'p'; c <= 'z'; c++) {
X                struct stat stb;
X
X                *p1 = c;
X                *p2 = '0';
X                if (stat(line, &stb) < 0)
X                        continue;
X                for (i = 0; i < 16; i++) {
X                        *p2 = "0123456789abcdef"[i];
X                        p = open(line, O_RDWR);
X			if (p > 0) {
X#ifdef hpux
X				sprintf(tmp, "/dev/pty/tty%c%c", *p1, *p2);
X#else
X				sprintf(tmp, "/dev/tty%c%c", *p1, *p2);
X#endif
X				if (!access(tmp, R_OK | W_OK)) {
X					strcpy(line, tmp);
X					return(p);
X				}
X                        }
X                }
X        }
X        return(-1);
X}
X#endif /* SOLARIS */
X#endif /* !IRIX */
X
X/* 512 bits modulus */
Xchar	*smallmodulostring = "\
XD7EE241E121D4993D8FF64313C1B57F0388243704B98F9FABC7EFC1F\
XA36803B88337E7220693839293974DD183990A5AA6FD5FCE0CC3DDED\
X2CE73933B270CFA7";
X
X/* 1024 bits modulus */
Xchar *defaultmodulostring = "\
X96F5D737535D8BC982698A80AB91DAE28E84E2982071998880C736B5\
X695AF14D015401A942186B865496ECBECAFE964A5E70B7031F5756C0\
X60AD53528687F4FBFF059150D529638C11FA6FAB6A58785DBD62D73D\
X1001014BE3EA53E97D43944F1EF83885196E5BCDD4098744B7673B54\
XBA2EB1FDB29ED2C3BA3AD8644FAFF05F";
X
X/* 2048 bits modulo */
Xchar *largemodulostring = "\
XE269EF4E 56C7CC6B 34897619 7DD83DE3 C9BE3C34 ACE6A557 36A662E5\
XF8210923 3BBF3357 5C5D4924 4AE73744 EEFDA659 884A7C63 C3BAD016\
X426335E0 A4FA7B2C 323C4B0E AD4D745A 6A5DB92C 99A5D040 F6F4FBC8\
X13132332 F6233C68 11AD3112 5148C55A F1B99D5A DE3531ED F68217AB\
XD4B1D105 AF58A55F A2C4A1D4 A5E391DF 68C8FF1C 78C6ED6F 24D7B848\
X5437E97F D71B6798 6A94DF03 9BD557D7 9D038724 382E86BF 2197E021\
X516DC16E DAE86723 85FB1A84 00B9822E 4A6ADEF2 3EBC75C6 02D05FF6\
XCB854914 0E7B91C3 A1011399 78A1EC83 B59EB508 F51F6098 6F4CEFF3\
XBA13D59C 1136D8C8 288AB1BC A56CBD92 AAAF1CED 07D21764 FF4603FB\
X4D2F6E8B";
X
Xdhexchange(s, side, firstack, rndstr)
Xint	s, side, firstack;
Xunsigned char	*rndstr;
X{
X	MP_INT		modulo, three, sharedsecret, mysecret,
X			mypublic, hispublic;
X	char		pwstr[4096], exchange[4096];
X	unsigned char	randbuf[4096];
X	int		i, modulobits, secretkeybits;
X	MD5_CTX		mdContext;
X	unsigned char	digest1[16], digest2[16];
X	des_key_schedule	tmpsched;
X	des_cblock	c_third, s_third;
X
X	unsigned char	*internalrnd();
X
X	mpz_init(&modulo);
X	mpz_init(&three);
X	mpz_init(&sharedsecret);
X	mpz_init(&mysecret);
X	mpz_init(&mypublic);
X	mpz_init(&hispublic);
X
X	mpz_set_ui(&three, 3L);
X	if (firstack & FLG_LARGE_MODULUS) /* 2048 bits modulo */
X		mpz_set_str(&modulo, largemodulostring, 16);
X	else if (firstack & FLG_SMALL_MODULUS) /* 512 bits modulus */
X		mpz_set_str(&modulo, smallmodulostring, 16);
X	else /* 1024 bits modulus */
X		mpz_set_str(&modulo, defaultmodulostring, 16);
X
X	/* get randomness from system */
X	strncpy(randbuf, internalrnd(), sizeof(randbuf));
X
X	/* user-provided randomness */
X	if (rndstr) {
X		(void)strcat(randbuf, "\n");
X		(void)strncat(randbuf, rndstr,
X				sizeof(randbuf) - strlen(randbuf) - 2);
X	}
X
X	/* dh: generate a random number % modulo */
X	mkrnd(randbuf, &mysecret, &modulo,
X			(side == CLIENT_SIDE && firstack & FLG_DEBUG));
X
X	modulobits = mpz_sizeinbase(&modulo, 2);
X	secretkeybits = mpz_sizeinbase(&mysecret, 2);
X	if (side == CLIENT_SIDE && firstack & FLG_BE_VERBOSE) {
X		if (firstack & FLG_DEBUG)
X			printf("\nGENERATING KEYS WITH DIFFIE-HELLMAN\n");
X		printf("Using %d bits modulus, %d bits secret key\n",
X						modulobits, secretkeybits);
X		printf("exchanging keys with DH scheme (can be a lengthy process)...\n");
X	}
X
X	if (side == CLIENT_SIDE && firstack & FLG_BE_VERBOSE) {
X		printf("x (client secret key) randomly generated\n");
X		if (firstack & FLG_DEBUG) {
X			printf("x (client secret key):\n");
X			mpz_out_str(stdout, 10, &mysecret);
X			printf("\n");
X		}
X	}
X
X	/* dh: calculate exponential */
X	mpz_powm(&mypublic, &three, &mysecret, &modulo);
X
X	bzero(exchange, sizeof(exchange));
X	mpz_get_str(exchange, 10, &mypublic);
X
X	if (side == CLIENT_SIDE && firstack & FLG_BE_VERBOSE) {
X		printf("3**x (client public key) exponentially generated\n");
X		if (firstack & FLG_DEBUG) {
X			printf("3**x (client public key):\n");
X			mpz_out_str(stdout, 10, &mypublic);
X			printf("\n");
X		}
X	}
X
X	/* dh: exchange exponentials */
X	if (write_data(s, exchange, sizeof(exchange)) != sizeof(exchange))
X		return(-1);
X	
X	bzero(exchange, sizeof(exchange));
X	if (read_data(s, exchange, sizeof(exchange)) != sizeof(exchange))
X		return(-1);
X
X	mpz_set_str(&hispublic, exchange, 10);
X
X	if (side == CLIENT_SIDE && firstack & FLG_BE_VERBOSE) {
X		printf("3**y (server public key) received from server\n");
X		if (firstack & FLG_DEBUG) {
X			printf("3**y (server public key):\n");
X			mpz_out_str(stdout, 10, &hispublic);
X			printf("\n");
X		}
X	}
X
X	/* dh: calculate shared secret */
X        mpz_powm(&sharedsecret, &hispublic, &mysecret, &modulo);
X
X	if (side == CLIENT_SIDE && firstack & FLG_BE_VERBOSE) {
X		printf("(3**y)**x (shared secret) exponentially generated\n");
X		if (firstack & FLG_DEBUG) {
X			printf("(3**y)**x (shared secret):\n");
X			mpz_out_str(stdout, 10, &sharedsecret);
X			printf("\n");
X		}
X	}
X	
X	/* convert shared secret to ascii decimal string, divide the
X	decimal string into two halves.  the first half is the client
X	one, the second one is the server one.  both halves are 
X	digested by md5 in order to distill randomness and provide
X	actual encryption keys.
X	we use different keys for server and client in order to prevent
X	false data injection, as it has been pointed out by S.Bellovin
X	in Session Layer Encryption, V USENIX Symposium
X	things are just natural for single DES (one 8 bytes key) and
X	IDEA (one 16 bytes key), but triple des needs three 8 bytes
X	keys.  we generate the 3des third key by means of the IDEA
X	cipher */
X
X	/* digest shared secret */
X	bzero(pwstr, sizeof(pwstr));
X	mpz_get_str(pwstr, 10, &sharedsecret);
X
X	/* digest first half
X	single des and idea client keys are based on digest1
X	triple des client keys are based on digest1 and pwstr
X	*/
X	MD5Init(&mdContext);
X	MD5Update(&mdContext, pwstr, strlen(pwstr) / 2);
X	MD5Final(digest1, &mdContext);
X
X	/* digest second half
X	single des and idea server keys are based on digest2
X	triple des server keys are based on digest2 and pwstr
X	*/
X	MD5Init(&mdContext);
X	MD5Update(&mdContext, pwstr + strlen(pwstr) / 2, strlen(pwstr) / 2);
X	MD5Final(digest2, &mdContext);
X
X	/* calculate a special pwstr hash for use in the mutual authentication
X	phase only.  since it is maintained in memory for use in the
X	mutual auth phase, it could be eventually disclosed; this is why
X	this is a one way hash, based upon a subset of the key.
X	sessionkeyhash is calculated as follows: the first 8 bytes of
X	digest1 are used as a des key to encrypt the first 8 bytes of
X	digest2.
X	*/
X#ifdef DESCORE
X	descore_key_sched(digest1, tmpsched);
X#else
X	des_set_key((des_cblock *)digest1, tmpsched);
X#endif
X
X	memcpy(sessionkeyhash, digest2, 8);
X
X#ifdef DESCORE
X	descore_ecb_encrypt(sessionkeyhash, sessionkeyhash, tmpsched, ENCRYPT);
X#else
X	des_ecb_encrypt((des_cblock *)sessionkeyhash,
X			(des_cblock *)sessionkeyhash, tmpsched, ENCRYPT);
X#endif
X	bzero(tmpsched, sizeof(tmpsched));
X
X	/* the itself key is random, so we do not need a changing IV */
X	/* bzero(IV, sizeof(IV)); */
X
X	/* set single des keys */
X	if (firstack & FLG_USE_IDEA) {
X		/* set client encryption key */
X		init_this_key_idea(c_ideakey, digest1, FALSE);
X
X		/* set server encryption key */
X		init_this_key_idea(s_ideakey, digest2, FALSE);
X	}
X	/* set idea keys */
X	else if (firstack & FLG_USE_SINGLE) {
X		/* fold (xor) md5 digests 16 bytes into 8 bytes des keys */
X		for (i = 0; i < 8; i++) {
X			digest1[i] ^= digest1[i + 8];
X			digest2[i] ^= digest2[i + 8];
X		}
X
X		/* set client encryption key */
X#ifdef DESCORE
X		descore_key_sched(digest1, c_schedule1);
X#else
X		des_set_key((des_cblock *)digest1, c_schedule1);
X#endif
X
X		/* set server encryption key */
X#ifdef DESCORE
X		descore_key_sched(digest2, s_schedule1);
X#else
X		des_set_key((des_cblock *)digest2, s_schedule1);
X#endif
X
X	}
X	/* set rc4 keys */
X	else if (firstack & FLG_USE_RC4) {
X		rc4_init(&c_rc4, digest1, 16);
X		rc4_init(&s_rc4, digest2, 16);
X	}
X	/* calculate and set triple des keys 
X	triple DES is default encryption mode
X	*/
X	else {
X		/* set client first encryption key */
X#ifdef DESCORE
X		descore_key_sched(digest1, c_schedule1);
X#else
X		des_set_key((des_cblock *)digest1, c_schedule1);
X#endif
X
X		/* set client second encryption key */
X		/* fixed by Mark C. Henderson */
X#ifdef DESCORE
X		descore_key_sched((des_cblock *)digest1 + 1, c_schedule2);
X#else
X		des_set_key((des_cblock *)digest1 + 1, c_schedule2);
X#endif
X
X		/* set client third encryption key
X		to calculate the third key we take advantage of the
X		IDEA cipher, setting digest1 as encryption key 
X		and using first digest2's half as plaintext.  the resulting
X		ciphertexst is set into c_third
X		*/
X		init_this_key_idea(c_ideakey, digest1, FALSE);
X		cipher_idea(digest2, c_third, c_ideakey);
X
X#ifdef DESCORE
X		descore_key_sched(c_third, c_schedule3);
X#else
X		des_set_key((des_cblock *)c_third, c_schedule3);
X#endif
X
X		/* set server first encryption key */
X#ifdef DESCORE
X		descore_key_sched(digest2, s_schedule1);
X#else
X		des_set_key((des_cblock *)digest2, s_schedule1);
X#endif
X
X		/* set server second encryption key */
X		/* fixed by Mark C. Henderson */
X#ifdef DESCORE
X		descore_key_sched(digest2 + 8, s_schedule2);
X#else
X		des_set_key((des_cblock *)digest2 + 1, s_schedule2);
X#endif
X
X		/* set server third encryption key
X		to calculate the third key we take advantage of the
X		IDEA cipher, setting digest2 as encryption key 
X		and using first digest1's half as plaintext.  the resulting
X		ciphertexst is set into c_third
X		*/
X		init_this_key_idea(s_ideakey, digest2, FALSE);
X		cipher_idea(digest1, s_third, c_ideakey);
X#ifdef DESCORE
X		descore_key_sched(s_third, s_schedule3);
X#else
X		des_set_key((des_cblock *)s_third, s_schedule3);
X#endif
X	}
X
X	if (side == CLIENT_SIDE && firstack & FLG_BE_VERBOSE) {
X		if (firstack & FLG_USE_IDEA) {
X			hexdump("IDEA client key: ", digest1, 16);
X			hexdump("IDEA server key: ", digest2, 16);
X		}
X		else if (firstack & FLG_USE_SINGLE) {
X			hexdump("DES client key: ", digest1, 8);
X			hexdump("DES server key: ", digest2, 8);
X		}
X		else if (firstack & FLG_USE_RC4) {
X			hexdump("RC4 client key: ", digest1, 16);
X			hexdump("RC4 server key: ", digest2, 16);
X		}
X		else { /* default is triple DES */
X			hexdump("3DES client key #1: ", digest1, 8);
X			hexdump("3DES client key #2: ", digest1 + 8, 8);
X			hexdump("3DES client key #3: ", c_third, 8);
X			hexdump("3DES server key #1: ", digest2, 8);
X			hexdump("3DES server key #2: ", digest2 + 8, 8);
X			hexdump("3DES server key #3: ", s_third, 8);
X		}
X	}
X
X	/* delete traces */
X	bzero(pwstr, sizeof(pwstr));
X	bzero(digest1, 16);
X	bzero(digest2, 16);
X	mpz_clear(&modulo);
X	mpz_clear(&three);
X	mpz_clear(&sharedsecret);
X	mpz_clear(&mysecret);
X	mpz_clear(&mypublic);
X	mpz_clear(&hispublic);
X	return(0);
X}
X
X/* generate randomness by means of DES and MD5.
X
Xwe have a really unpredictable strings, that is str,
Xwhich has been built by internalrnd().  we distill randomness from
Xstr by means of the MD5 function.  we divide the digest into two
Xhalves.  then, we repeatly copy the second half to randomstring
Xand DES/CBC encrypt it using the first digest as encryption key.
Xas a result, randomstring is now a suitably long supposed-to-be
Xrandom string which is converted into a multi-precision number
Xfor use in the DH scheme.
Xyes, this is a weird method to get randomness from a unpredictable
Xstring.  suggestions and criticism is welcome!
X*/
Xmkrnd(str, rnd, modulo, logging)
Xunsigned char	*str;
XMP_INT		*rnd, *modulo;
Xint		logging;
X{
X	MP_INT		x, y, ff, value;
X	int		i;
X
X	MD5_CTX		mdContext;
X	unsigned char	digest[16];
X
X	IDEAkey		arandomkey;
X	des_cblock	iv;
X
X	/* the size of randomstring should be a multiple of 16, that is,
X	the size of MDx digest; if sizeof(randomstring) == 512 then it
X	is possible to generate up to 4096 bits numbers. in the
X	present version, we only need 2048 bits longs numbers maximum.
X	*/
X	unsigned char	randomstring[512];
X
X	mpz_init(&x);
X	mpz_init(&y);
X	mpz_init(&ff);
X	mpz_init(&value);
X
X	/* digest user's input */
X	MD5Init(&mdContext);
X	MD5Update(&mdContext, str, strlen(str));
X	MD5Final(digest, &mdContext);
X
X	if (logging) {
X		printf("\nGENERATING KEY RANDOMNESS\n");
X		printf("random string: \"%s\"\n", str);
X		hexdump("digest of random string: ", digest, 16);
X	}
X
X	/* build idea key */
X	init_this_key_idea(arandomkey, digest, FALSE);
X	/* set idea cfb */
X	bzero(iv, 8);
X	initcfb_idea((word16 *)iv, (byte *)arandomkey, FALSE);
X
X	/* reset randomstring */
X	bzero(randomstring, sizeof(randomstring));
X
X	/* encrypt randomstring */
X	ideacfb(randomstring, sizeof(randomstring));
X
X	/* give a glance at the first random bytes... */
X	if (logging) {
X		hexdump("first 20 random bytes: ", randomstring, 20);
X		hexdump("next 20 random bytes : ", randomstring + 20, 20);
X		hexdump("next 20 random bytes : ", randomstring + 40, 20);
X		printf("skipped all remaining random bytes (%d bytes in all)\n",
X							sizeof(randomstring));
X	}
X
X	/* build a verylong random number whose size is
X	sizeof(randomstring) * 8 bits. this is accomplished in a very old
X	fashioned way, but performances should not be an issue here
X	*/
X	mpz_set_ui(&ff, 256L);
X	for (i = 0; i < sizeof(randomstring); i++) {
X		int	tmp;
X
X		/* y = 256**i */
X		tmp = i;
X		mpz_pow_ui(&y, &ff, (unsigned long)tmp);
X
X		/* x = y * randomstring[i] */
X		tmp = randomstring[i];
X		mpz_mul_ui(&x, &y, (unsigned long)tmp);
X
X		/* value = value + x */
X		mpz_add(&value, &value, &x);
X
X		/* value >= modulo ? break */
X		if (mpz_cmp(&value, modulo) >= 0)
X			break;
X	}
X
X	mpz_mod(rnd, &value, modulo);
X
X	/* clear all traces */
X	bzero(randomstring, sizeof(randomstring));
X	bzero(str, strlen(str));
X	mpz_clear(&x);
X	mpz_clear(&y);
X	mpz_clear(&ff);
X	mpz_clear(&value);
X}
X
X#ifndef NO_IP_PROTO
Xkilloptions(s, host)
Xint	s;
Xchar	*host;
X{
X	unsigned char	buf[BUFSIZ / 3], *pbuf;
X	char		dumpbuf[BUFSIZ], *pdump = dumpbuf;
X	int		bufsiz = sizeof(buf);
X
X	if (!getsockopt(s, IPPROTO_IP, IP_OPTIONS, (char *)buf, &bufsiz) &&
X	    bufsiz != 0) { /* options are set */
X		for (pbuf = buf; bufsiz > 0; pbuf++, bufsiz--, pdump += 3)
X			sprintf(pdump, " %2.2x", *pbuf);
X		syslog(LOGPRI,
X			"connection from %s with IP_OPTIONS (ignored): %s",
X							host, dumpbuf);
X		if (setsockopt(s, IPPROTO_IP, IP_OPTIONS, NULL, 0)) {
X			syslog(LOG_ERR, "setsockopt(IP_OPTIONS): %m");
X			return(1);
X		}
X	}
X	return(0);
X}
X#endif
X
X
X/* build a truly random string using some sources of randomness 
Xinside unix computer systems.  we use computer clock, PIDs,
Xsystem names, date of files, CWD and the truerand function which
Xis supposed to generate physically random numbers.  each string's
Xindividual bit has considerably less than 1 bit of entropy;
Xhowever, the string is to be digested by md5, a strong hashing
Xalgorithm.
X*/
Xunsigned char *
Xinternalrnd()
X{
X	static unsigned char	buf[4096];
X	unsigned char		tmp[512];
X	struct utsname		name;
X	long			t;
X	char			*ctime();
X	struct stat 		sbuf;
X	void			(*oldsig) ();
X
X	bzero(buf, sizeof(buf));
X
X	/* system names */
X	if (uname(&name) >= 0) {
X		(void)sprintf(tmp, "unames = (%s %s %s %s %s);\n",
X			name.sysname, name.nodename, name.release,
X			name.machine, name.version);
X		(void)strcat(buf, tmp);
X	}
X
X	/* date */
X	t = time(NULL);
X	(void)sprintf(tmp, "time = %ld; ctime = %s ", t, ctime(&t));
X	(void)strcat(buf, tmp);
X
X	/* pids */
X	(void)sprintf(tmp, "pid = %d; getpgrp = %d; getppid = %d;\n",
X					getpid(), getpgrp(), getppid());
X	(void)strcat(buf, tmp);
X
X	/* dates of frequently changing files */
X	if (stat("/etc/passwd", &sbuf) != -1) {
X		(void)sprintf(tmp, "/etc/passwd dates = (%ld %ld %ld);\n",
X			sbuf.st_atime, sbuf.st_mtime, sbuf.st_ctime);
X		(void)strcat(buf, tmp);
X	}
X	if (stat("/dev/tty", &sbuf) != -1) {
X		(void)sprintf(tmp, "/dev/tty dates = (%ld %ld %ld);\n",
X			sbuf.st_atime, sbuf.st_mtime, sbuf.st_ctime);
X		(void)strcat(buf, tmp);
X	}
X	if (stat("/dev/console", &sbuf) != -1) {
X		(void)sprintf(tmp, "/dev/console dates = (%ld %ld %ld);\n",
X			sbuf.st_atime, sbuf.st_mtime, sbuf.st_ctime);
X		(void)strcat(buf, tmp);
X	}
X	if (stat("/tmp", &sbuf) != -1) {
X		(void)sprintf(tmp, "/tmp dates = (%ld %ld %ld);\n",
X			sbuf.st_atime, sbuf.st_mtime, sbuf.st_ctime);
X		(void)strcat(buf, tmp);
X	}
X
X	if (stat("/usr/tmp", &sbuf) != -1) {
X		(void)sprintf(tmp, "/usr/tmp dates = (%ld %ld %ld);\n",
X			sbuf.st_atime, sbuf.st_mtime, sbuf.st_ctime);
X		(void)strcat(buf, tmp);
X	}
X
X	/* cwd */
X	if (getcwd(tmp, sizeof(tmp)) != NULL) {
X		strcat(buf, "cwd: ");
X		(void)strcat(buf, tmp);
X		strcat(buf, "\n");
X	}
X
X	/* a few ``true random'' numbers */
X	/* oldsig = signal(SIGALRM, SIG_IGN); /* truerand modifies sigalrm */
X	(void)sprintf(tmp, "a few random numbers = (%d %d %d);\n",
X		truerand(),
X		truerand(),
X		truerand());
X	/* (void)signal(SIGALRM, oldsig); */
X	(void)strcat(buf, tmp);
X	
X	return(buf);
X}
X
Xmauth(s, authbuf, side, firstack)
Xint	s, side, firstack;
Xchar	*authbuf;
X{
X	MD5_CTX			mdContext;
X	unsigned char		digest[16];
X	des_key_schedule	authsched;
X	unsigned char		cookie[8], *firsthalve, *secondhalve;
X	unsigned char		othercookie[8], *otherfirst, *othersecond;
X	int			i;
X	int			logging;
X	
X	logging = side == CLIENT_SIDE && firstack & FLG_DEBUG;
X
X	/* digest content of ~/.stelsecret */
X	MD5Init(&mdContext);
X	MD5Update(&mdContext, authbuf, strlen(authbuf));
X	MD5Final(digest, &mdContext);
X
X	for (i = 0; i < 8; i++)
X		/* xor halves together */
X		digest[i] ^= digest[i + 8];
X
X	/* set a des key */
X#ifdef DESCORE
X	descore_key_sched(digest, authsched);
X#else
X	des_set_key((des_cblock *)digest, authsched);
X#endif
X
X	/* build K_E(sessionkeyhash) */
X	memcpy(cookie, sessionkeyhash, 8);
X#ifdef DESCORE
X	descore_ecb_encrypt(cookie, cookie, authsched, ENCRYPT);
X#else
X	des_ecb_encrypt((des_cblock *)cookie, (des_cblock *)cookie,
X							authsched, ENCRYPT);
X#endif
X	if (side == SERVER_SIDE) /* encrypt twice */
X#ifdef DESCORE
X		descore_ecb_encrypt(cookie, cookie, authsched, ENCRYPT);
X#else
X		des_ecb_encrypt((des_cblock *)cookie, (des_cblock *)cookie,
X							authsched, ENCRYPT);
X#endif
X
X	if (logging) {
X		printf("\nMUTUAL AUTHENTICATION\n");
X		printf("AX authenticator is equal to E_K(sessionkeyhash), where:\n");
X		hexdump("K is a stelsecret derived DES key, equal to: ",
X								digest, 8);
X		hexdump("sessionkeyhash is equal to: ", sessionkeyhash, 8);
X		hexdump("AX authenticator: ", cookie, 8);
X		printf(\
X"AX and AY are divided in two halves; AX = AX1|AX2, AY = AY1|AY2\n");
X	}
X
X	/* split it into two halves */
X	firsthalve = cookie;
X	secondhalve = cookie + 4;
X
X	otherfirst = othercookie;
X	othersecond = othercookie + 4;
X
X	/* Send halves in order. We have differently encrypted the two
X	cookies (double encryption has been performed by the server
X	while single encryption by the client), so a replay attack
X	should be infeasible for the Man In The Middle */
X
X	if (side == CLIENT_SIDE) {
X		if (logging)
X			hexdump("sending AX1: ", firsthalve, 4);
X		if (write_data(s, firsthalve, 4) != 4)
X			return(-1);
X
X		if (read_data(s, otherfirst, 4) != 4)
X			return(-1);
X		if (logging)
X			hexdump("received AY1: ", otherfirst, 4);
X
X		if (logging)
X			hexdump("sending AX2: ", secondhalve, 4);
X		if (write_data(s, secondhalve, 4) != 4)
X			return(-1);
X
X		if (read_data(s, othersecond, 4) != 4)
X			return(-1);
X		if (logging)  {
X			hexdump("received AY2: ", othersecond, 4);
X			hexdump("AY: ", othercookie, 8);
X		}
X	}
X	else {
X		if (read_data(s, otherfirst, 4) != 4 ||
X		    write_data(s, firsthalve, 4) != 4 ||
X		    read_data(s, othersecond, 4) != 4 ||
X		    write_data(s, secondhalve, 4) != 4)
X			return(-1);
X	}
X
X	if (side == CLIENT_SIDE) /* decrypt it once */
X#ifdef DESCORE
X		descore_ecb_encrypt(othercookie, othercookie, authsched, DECRYPT);
X#else
X		des_ecb_encrypt((des_cblock *)othercookie,
X			(des_cblock *)othercookie, authsched, DECRYPT);
X#endif
X	else if (side == SERVER_SIDE) /* encrypt once more */
X#ifdef DESCORE
X		descore_ecb_encrypt(othercookie, othercookie, authsched, ENCRYPT);
X#else
X		des_ecb_encrypt((des_cblock *)othercookie,
X			(des_cblock *)othercookie, authsched, ENCRYPT);
X#endif
X
X	if (logging) {
X		printf(\
X"AY is double encrypted. We decrypt it before comparing AX with AY\n");
X		hexdump("AY (decrypted): ", othercookie, 8);
X		hexdump("AX: ", cookie, 8);
X	}
X	
X	if (memcmp(cookie, othercookie, 8)) {
X		if (logging)
X			printf("AX != AY, authentication failed\n");
X		return(1);
X	}
X
X	if (logging)
X		printf("AX = AY, authentication succeeded\n");
X
X	return(0);
X}
X
Xhexdump(prompt, buf, len)
Xchar		*prompt;
Xunsigned char	*buf;
Xint		len;
X{
X	int	i;
X
X	if (prompt)
X		printf("%s", prompt);
X	for (i = 0; i < len; i++)
X		printf("%02X", buf[i]);
X	(void)fflush(stdout);
X	printf("\r\n");
X}
X
X/*
X * Construct a control character sequence
X * for a special character.
X */
Xchar *
Xcontrol(c)
X	register cc_t c;
X{
X	static char buf[5];
X	register unsigned int uic = (unsigned int)c;
X
X	if (uic == 0x7f)
X		return ("^?");
X
X	if (uic >= 0x80) {
X		buf[0] = '\\';
X		buf[1] = ((c>>6)&07) + '0';
X		buf[2] = ((c>>3)&07) + '0';
X		buf[3] = (c&07) + '0';
X		buf[4] = 0;
X	} else if (uic >= 0x20) {
X		buf[0] = c;
X		buf[1] = 0;
X	} else {
X		buf[0] = '^';
X		buf[1] = '@'+c;
X		buf[2] = 0;
X	}
X	return (buf);
X}
X
X/*
X * Modified read() & write() for sockets.
X * Returns: number of characters read if ok; -1 if fails.
X */
Xint		read_data(s, buf, n)
Xint		s;
Xchar		*buf;
Xint		n;
X{
X	int		bcount;
X	int		br;
X
X	bcount= 0;
X	br= 0;
X	while (bcount < n) {
X		if ((br = read(s, buf, n - bcount)) > 0) {
X			bcount += br;
X			buf += br;
X		}
X		else if (br < 0)
X			return(-1);
X		else if (!br)
X			break;
X	}
X	return(bcount);
X}
X
Xint		write_data(s, buf, n)
Xint		s;
Xchar		*buf;
Xint		n;
X{
X	int		bcount;
X	int		br;
X
X	bcount= 0;
X	br= 0;
X	while (bcount < n) {
X		if ((br = write(s, buf, n - bcount)) > 0) {
X			bcount += br;
X			buf += br;
X		}
X	else if (br < 0)
X		return(-1);
X	}
X	return(bcount);
X}
X
X
X/*
X * CFB encrypt a single byte using DES, 3DES or IDEA.
X * mode: DES_ENCRYPT, DES_DECRYPT
X * cipher: DES_CIPHER, TRIPLEDES_CIPHER, IDEA_CIPHER
X * side: CLIENT_SIDE, SERVER_SIDE
X *
X * (uses global s_IV and c_IV initialisation variables) 
X */
Xtypedef union { /* solaris needs this */
X	char	octet[8];
X} SHIFT;
X
Xstatic void
XCFBcrypt(char *databyte, int mode, int cipher, int side)
X{
X	char	*shift1, *shift2, *first1, *first2;
X
X	static SHIFT	c_shift1, c_shift2;
X	static SHIFT	s_shift1, s_shift2;
X	static char	c_first1, c_first2;
X	static char	s_first1, s_first2;
X
X	register char	*shift, add;
X	register	i;
X
X	des_key_schedule	*sched1, *sched2, *sched3;
X	IDEAkey			*ideakey;
X	des_cblock		*IV;
X
X	if (databyte == NULL) { /* reset option, unused */
X		bzero(&c_shift1, sizeof(SHIFT));
X		bzero(&c_shift2, sizeof(SHIFT));
X		bzero(&s_shift1, sizeof(SHIFT));
X		bzero(&s_shift2, sizeof(SHIFT));
X		c_first1 = c_first2 = s_first1 = s_first2 = 0;
X	}
X
X	if (mode < 0)
X		return;
X
X	/* rc4 is the fastests -- but probably insecure -- cipher */
X	if (cipher == RC4_CIPHER) {
X		*databyte ^= rc4_byte(side == CLIENT_SIDE ? &c_rc4 : &s_rc4);
X		return;
X	}
X	
X	/* we need to keep to different queues for both client
X	   and server. This is done for security reasons and
X	   syncronicity reasons */
X	if (side == CLIENT_SIDE) {
X		sched1 = &c_schedule1;
X		sched2 = &c_schedule2;
X		sched3 = &c_schedule3;
X		ideakey = &c_ideakey;
X		shift1 = (char *)&c_shift1;
X		shift2 = (char *)&c_shift2;
X		first1 = &c_first1;
X		first2 = &c_first2;
X		IV = (des_cblock *)&c_IV;
X	}
X	else { /* SERVER_SIDE */
X		sched1 = &s_schedule1;
X		sched2 = &s_schedule2;
X		sched3 = &s_schedule3;
X		ideakey = &s_ideakey;
X		shift1 = (char *)&s_shift1;
X		shift2 = (char *)&s_shift2;
X		first1 = &s_first1;
X		first2 = &s_first2;
X		IV = (des_cblock *)&s_IV;
X	}
X
X	switch (mode) {
X		case	DES_ENCRYPT:
X			if (*first1 == 0) { /* First time we use this queue? */
X				(void)memcpy(shift1, IV, 8);
X				*first1 = 1;
X			}
X			shift = shift1;
X			break;
X		case	DES_DECRYPT:
X			if (*first2 == 0) {
X				(void)memcpy(shift2, IV, 8);
X				*first2 = 1;
X				*first2 = 2;
X			}
X			shift = shift2;
X			break;
X		default	:
X			return;
X	}
X
X	if (mode == DES_DECRYPT)
X		add = *databyte;
X
X	if (cipher == IDEA_CIPHER) { /* idea */
X		word16	XX[4];
X
X		memcpy(XX, shift, 8);
X		/* idea_ecb(shift, shift); */
X
X#ifndef HIGHFIRST /* dunigan@thdsun.epm.ornl.gov */
X		XX[0] = XX[0] >> 8 | XX[0] << 8;
X		XX[1] = XX[1] >> 8 | XX[1] << 8;
X		XX[2] = XX[2] >> 8 | XX[2] << 8;
X		XX[3] = XX[3] >> 8 | XX[3] << 8;
X                cipher_idea(XX, XX, *ideakey);
X		XX[0] = XX[0] >> 8 | XX[0] << 8;
X		XX[1] = XX[1] >> 8 | XX[1] << 8;
X		XX[2] = XX[2] >> 8 | XX[2] << 8;
X		XX[3] = XX[3] >> 8 | XX[3] << 8;
X#else
X		cipher_idea(XX, XX, *ideakey);
X#endif HIGHFIRST
X
X		memcpy(shift, XX, 8);
X	}
X	else if (cipher == TRIPLEDES_CIPHER) { /* 3 DES */
X#ifdef DESCORE
X		descore_ecb_encrypt(shift, shift, *sched1, DES_ENCRYPT);
X		descore_ecb_encrypt(shift, shift, *sched2, DES_DECRYPT);
X		descore_ecb_encrypt(shift, shift, *sched3, DES_ENCRYPT);
X#else
X		des_ecb_encrypt((des_cblock *)shift, (des_cblock *)shift,
X							*sched1, DES_ENCRYPT);
X		des_ecb_encrypt((des_cblock *)shift, (des_cblock *)shift,
X							*sched2, DES_DECRYPT);
X		des_ecb_encrypt((des_cblock *)shift, (des_cblock *)shift,
X							*sched3, DES_ENCRYPT);
X#endif
X	}
X	else if (cipher == DES_CIPHER) { /* single DES */
X#ifdef DESCORE
X		des_ecb_encrypt(shift, shift, *sched1, DES_ENCRYPT);
X#else
X		des_ecb_encrypt((des_cblock *)shift, (des_cblock *)shift,
X							*sched1, DES_ENCRYPT);
X#endif
X	}
X	else {
X		exit(1);
X	}
X
X	*databyte ^= shift[0];	
X
X	for (i = 1; i <= 7; i++)
X		shift[i - 1] = shift[i];
X
X	if (mode == DES_ENCRYPT)
X		add = *databyte;
X
X	shift[7] = add;
X}
X
Xcryptbuf(buf, len, dec, cipher, side)
Xchar	*buf;
Xint	len, dec, cipher, side;
X{
X	register	i;
X
X	for (i = 0; i < len; i++)
X		CFBcrypt(&buf[i], dec, cipher, side);
X}
X
Xstatic
Xdoaddrmatch(char *pat, char *str)
X{
X	regex_t		re;
X	regmatch_t	pm;
X	char		*pattern;
X
X	/* fix: performances */
X	if ((pattern = (char *)buildregexp(pat)) == NULL) {
X		syslog(LOGPRI, "buildregexp() failed");
X		exit(1);
X	}
X
X	if (regcomp(&re, pattern, REG_EXTENDED | REG_ICASE)) {
X		syslog(LOGPRI, "regcomp() failed");
X		exit(1);
X	}
X
X	/* regexec(&re, pbuf, 1, &pm, 0 */
X	if (!regexec(&re, str, 1, &pm, 0))
X		return(0);
X	else
X		return(1);
X}
X
Xstatic char *
Xbuildregexp(char *str)
X{
X	char		*tmp1;
X	static char	*tmp2;
X	register	i, j;
X
X	if ((tmp1 = (char *) malloc(strlen(str) * 2)) == NULL) {
X		perror("malloc()");
X		return(NULL);
X	}
X
X	/* . --> \. */
X	for (i = 0, j = 0; i < strlen(str); i++) {
X		if (str[i] == '.') {
X			tmp1[j++] = '\\';
X			tmp1[j++] = '.';
X		}
X		else
X			tmp1[j++] = str[i];
X	}
X	tmp1[j] = '\0';
X
X	if (tmp2 == NULL) {
X		if ((tmp2 = (char *) malloc(strlen(tmp1) * 10)) == NULL) {
X			perror("malloc()");
X			return(NULL);
X		}
X	}
X	else if ((tmp2 = (char *) realloc(tmp2, strlen(tmp1) * 10)) == NULL) {
X		perror("realloc()");
X		return(NULL);
X	}
X	/*
X	 * * --> [a-z0-9]+
X	 * ? --> [a-z0-9]
X	 */
X	j = 0;
X	tmp2[j++] = '^';
X	for (i = 0; i < strlen(tmp1); i++) {
X		if (tmp1[i] == '*') {
X			tmp2[j++] = '[';
X			tmp2[j++] = '-';
X			tmp2[j++] = 'a';
X			tmp2[j++] = '-';
X			tmp2[j++] = 'z';
X			tmp2[j++] = '0';
X			tmp2[j++] = '-';
X			tmp2[j++] = '9';
X			tmp2[j++] = ']';
X			tmp2[j++] = '+';
X		}
X		else if (tmp1[i] == '?') {
X			tmp2[j++] = '[';
X			tmp2[j++] = '-';
X			tmp2[j++] = 'a';
X			tmp2[j++] = '-';
X			tmp2[j++] = 'z';
X			tmp2[j++] = '0';
X			tmp2[j++] = '-';
X			tmp2[j++] = '9';
X			tmp2[j++] = ']';
X		}
X		else
X			tmp2[j++] = tmp1[i];
X	}
X	tmp2[j++] = '$';
X	tmp2[j] = '\0';
X
X	free(tmp1);
X	/*
X	printf("regexp: %s --> %s\n", str, tmp2);
X	*/
X	return(tmp2);
X}
X
X/* host1,host2,host3,...,hostn:password */
Xchar *
Xgetstelsecret(char *pathname, char *hname)
X{
X	FILE		*fp;
X	static char	authbuf[STEL_SECRET_MAX_LEN];
X	char		line[STEL_SECRET_MAX_LEN];
X	int		firsttoklen, linenum = 0;
X	int		found = 0;
X	char		*p;
X
X	if ((fp = fopen(pathname, "r")) == NULL)
X		return(NULL);
X
X	while  (fgets(line, sizeof(line), fp) != NULL) {
X		/* check address matching */
X		p = (char *)strtok(line, ": \t");	
X
X		linenum++;
X
X		rip(p);
X		if (p == NULL || *p == '#' || p == '\0')
X			continue;
X
X		/* save pointer to stel secret */
X		firsttoklen = strlen(p);
X
X		/* check that hname match any host in p */
X		if (!oneofthese(hname, p))
X			continue;
X
X		/* extract stelsecret */
X		p = (char *)strtok(line + firsttoklen + 1, "\n\t ");
X		if (p == NULL) {
X			syslog(LOGPRI, "%s syntax error on line %d\n",
X							pathname, linenum);
X			continue;
X		}
X	
X		/* we found it */
X		found++;
X		(void)strncpy(authbuf, p, sizeof(authbuf));
X		break;
X	}
X
X	(void)fclose(fp);
X
X	if (!found)
X		return(NULL);
X
X	return(authbuf);
X}
X
X/* 0 = not found, 1 = found */
Xstatic
Xoneofthese(char *hname, char *hosts)
X{
X	char		*tmp;
X	char		*p;
X	int		i;
X	int		found = 0;
X
X	struct hostent	*hp;
X	struct in_addr	x;
X	int		j;
X
X	if ((hp = gethostbyname(hname)) == NULL)
X		return(0); /* Unknown host. should never happen */
X
X	if ((tmp = (char *)strdup(hosts)) == NULL)
X		return(0);
X
X	i = 0;
X	while ((p = (char *)strtok((i == 0 ? tmp : NULL), ", \t")) != NULL) {
X		/*
X		syslog(LOGPRI, "comparing %s with %s", hname, p);
X		*/
X		/* check official name */
X		if (!doaddrmatch(p, (char *)hp->h_name)) {
X			found++;
X			break;
X		}
X
X		/* check aliases */
X		for (j = 0; hp->h_aliases[j]; j++) {
X			if (!doaddrmatch(p, hp->h_aliases[j])) {
X				found++;
X				break;
X			}
X		}
X
X		for (j = 0; hp->h_addr_list[j]; j++) {
X			memcpy((char *)&x, hp->h_addr_list[j], hp->h_length);
X			if (!doaddrmatch(p, (char *)inet_ntoa(x))) {
X				found++;
X				break;
X			}
X		}
X			
X		if (found)
X			break;
X		i++;
X	}
X
X	(void)free(tmp);
X
X	if (found)
X		syslog(LOGPRI, "matched pattern: %s", p);
X	return(found);
X}
X
Xchar *
Xrandomdigest()
X{
X	char		buf[128];
X	MD5_CTX		mdContext;
X	static char	digest[16];
X	void		(*oldsig) ();
X
X	oldsig = signal(SIGALRM, SIG_IGN); /* truerand modifies sigalrm */
X	sprintf(buf, "%ld %d %d %d",
X			time(NULL), truerand(), truerand(), getpid());
X	(void)signal(SIGALRM, oldsig);
X	MD5Init(&mdContext);
X	MD5Update(&mdContext, buf, strlen(buf));
X	MD5Final(digest, &mdContext);
X	
X	return(digest);
X}
X
X/* client printf */
X#if defined(IRIX) || defined(AIX)
Xcprintf(char *fmt, ...)
X#else
Xcprintf(va_alist)
Xva_dcl
X#endif
X{
X	va_list		args;
X#if !defined(IRIX) && !defined(AIX)
X	char		*fmt;
X#endif
X	char		buf[128];
X
X#if defined(IRIX) || defined(AIX)
X	va_start(args, fmt);
X#else
X	va_start(args);
X	fmt = va_arg(args, char *);
X#endif
X
X/*
X#if defined(AIX)
X	fmt = va_arg(args, char *);
X#endif
X*/
X
X	vsprintf(buf, fmt, args);
X	printf("%s[%d]: %s", STELCLIENT, getpid(), buf);
X	fflush(stdout);
X}
END_OF_FILE
  if test 36262 -ne `wc -c <'sub.c'`; then
    echo shar: \"'sub.c'\" unpacked with wrong size!
  fi
  # end of 'sub.c'
fi
if test -f 'makeio.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'makeio.c'\"
else
  echo shar: Extracting \"'makeio.c'\" \(45770 characters\)
  sed "s/^X//" >'makeio.c' <<'END_OF_FILE'
X/*
X * $Author: vince $
X * $Header: /res/usr/vince/src/stel/RCS/makeio.c,v 1.107 1995/12/26 19:22:18 vince Exp vince $
X * $Date: 1995/12/26 19:22:18 $
X * $Revision: 1.107 $
X * $Locker: vince $
X */
X
X#ifndef	lint
Xstatic char *rcsid = "@(#) $Id: makeio.c,v 1.107 1995/12/26 19:22:18 vince Exp vince $";
X#endif	lint
X
X#include <stdio.h>
X#include <fcntl.h>
X#include <sys/stat.h>
X#include <termios.h>
X#include <signal.h>
X#include <errno.h>
X#include <sys/wait.h>
X#include <syslog.h>
X#include <sys/time.h>
X#include <netinet/in.h>
X#include <pwd.h>
X#include "regex.h"
X
X#ifdef HAS_SYS_PARAM_H
X#include <sys/param.h>
X#endif
X
X#if defined(BSD)    /* pure BSD-based */
X#ifndef SIGCLD
X#define SIGCLD  SIGCHLD
X#endif
X#endif
X
X#include "skey.h"
X#include "defs.h"
X
X#define ESCAPE_CMD	"escape"
X#define SKEY_CMD	"skey"
X#define SKEY_CMD_BIS	"s/key"
X#define LOG_CMD		"log"
X#ifdef XFERLOG
X#define XFER_CMD	"xfer"
X#endif
X#define GET_CMD		"get"
X#define PUT_CMD		"put"
X#define min(x, y)	(x < y ? x  : y)
X
Xstatic int		child_is_dead;
Xstatic int		idle_timeout;
X
X/* idea stuff */
X#include "idea.h"
XIDEAkey			s_ideakey;	/* server */
XIDEAkey			c_ideakey;	/* client */
X
X/* des stuff */
X/* #include "des.h" */
Xdes_key_schedule	s_schedule1;	/* server */
Xdes_key_schedule	s_schedule2;	/* server */
Xdes_key_schedule	s_schedule3;	/* server */
Xdes_key_schedule	c_schedule1;	/* client */
Xdes_key_schedule	c_schedule2;	/* client */
Xdes_key_schedule	c_schedule3;	/* client */
X
X/* control messages, file xfer integrity */
Xlong	crc32val;
X
X/* md5 stuff */
X#include "global.h"
X#include "md5.h"
X
X#if defined (IRIX)
X#define sigmask(n)	((unsigned int)1 << (((n) - 1) & (32 - 1)))
X#endif
X#define CONTROL(x)	((x) & 0x1f)		/* CTRL(x) is not portable */
Xstatic int		escape = CONTROL(']');
Xstatic long		oldmask;
Xstatic long		start;
Xstatic char		skeybuf[SKEYBUFSIZE];
Xstatic unsigned long	userstrokes, traffic;
X
X/* logging stuff */
Xstatic int		logging;
Xint			logfh; /* visible by stel.c */
Xstatic char		logfilename[256];
X
X/* flags stuff. used for file transfer */
X#ifdef COMBOFLAG
Xstatic int		comboflag = COMBO_FLG_DATA;
X#endif /* COMBOFLAG */
X
X/* experimental xferlog stuff. disabled. */
X#ifdef XFERLOG
Xstatic int		tobexfered;
Xstatic int		tobeskipped;
Xstatic char		xferfilename[256];
Xint			xferfh;
X#define LOGIOERROR() \
X{ \
X	cprintf("%s: %s\n", xferfilename, sys_errlist[errno]); \
X	tobexfered = 0; \
X	return(1); \
X}
X#define MINUS_ONLCR	"stty -onlcr"
X#define PLUS_ONLCR	"stty onlcr"
X#endif /* XFERLOG */
X
Xstatic char		fromfile[256];
Xstatic char		tofile[256];
Xstatic int		userauthenticated;
X
Xchar			*doskeymatch();
X
Xextern int		errno;
Xextern char		*sys_errlist[];
X
X/* in skeyresp() */
Xstatic struct termios saved_ttymode, noecho_ttymode;
X
Xint
Xmakeio(in, out, channel, authfh, side, firstack, remhostname, old, new,
X						timeout, username)
Xint		in, out, channel, authfh;
Xint		firstack;
Xchar		*remhostname, *username;
Xstruct termios	*old, *new;
Xint		timeout;
X{
X	int		ret;
X	int		mask;
X	char		buf[MAKEIOBUF];
X	void		deadchild();
X	void		idletimeout();
X
X	struct timeval	seltimer, *tim = NULL;
X	start = time(NULL);
X
X	crcgen(); /* init crc engime */
X
X	/* block signals */
X	(void)signal(SIGCLD, deadchild);
X	(void)signal(SIGALRM, idletimeout);
X#ifndef SOLARIS
X	oldmask = sigblock(sigmask(SIGCLD) | sigmask(SIGALRM));
X#endif
X
X	/* init regexp */
X	if (!(firstack & FLG_NO_ESCAPE))
X		(void)doskeymatch(NULL, SKEYPATTERN);
X
X	for (; ; ) {
X		/* unblock signals */
X#ifdef SOLARIS
X		(void)sigrelse(SIGCLD);
X		(void)sigrelse(SIGALRM);
X#else
X		(void)sigsetmask(oldmask);
X#endif
X
X		/* some signal occurred. may be that some data arrived
X		   when executing critical (signals inhibited) code, so we
X		   flush streams, by waiting one more second for more data */
X		if (child_is_dead || idle_timeout) {
X			seltimer.tv_sec = 1;
X			seltimer.tv_usec = 0;
X			tim = &seltimer;
X		}
X
X		mask = (1 << in) | (1 << channel);
X
X		if (!userauthenticated &&
X		    authfh >= 0 &&
X		    firstack & FLG_ACTIVE_ATTACKS)
X			mask |= (1 << authfh);
X
X#ifdef SOLARIS
X		switch (select(32, (fd_set *)&mask, 0, 0, tim))
X#else
X		switch (select(32, &mask, 0, 0, tim))
X#endif
X							{
X			case	-1:
X				if (errno == EINTR && child_is_dead) {
X					return(0);
X				}
X				if (errno == EINTR && idle_timeout) {
X					/* client side, notify user */
X					if (side == CLIENT_SIDE)
X						cprintf("session timeout\r\n");
X					return(0);
X				}
X				syslog(LOGPRI, "select(): %m");
X				return(1);
X			case	0:
X				/*
X				printf("select times out\n");
X				*/
X				return(0);
X		}
X
X#ifdef SOLARIS
X		(void)sighold(SIGCLD);
X		(void)sighold(SIGALRM);
X#else
X		/* entering critical code, block signals */
X		oldmask = sigblock(sigmask(SIGCLD));
X#endif
X
X		if (mask & (1 << in)) {
X			ret = doinput(in, channel, buf, side, firstack,
X						remhostname, old, new);
X
X		}
X
X		else if (mask & (1 << channel)) {
X			ret = dochannel(channel, out, buf, side, firstack,
X					remhostname, username, timeout);
X		}
X
X		else if (mask & (1 << authfh)) {
X			char	buf[100];
X
X			bzero(buf, sizeof(buf));
X			if (read(authfh, buf, sizeof(buf)) != strlen(USRAUTH) ||
X			    memcmp(buf, USRAUTH, strlen(USRAUTH))) {
X				syslog(LOGPRI, "bad authentication channel! bad msg: `%s'",
X					buf);
X				ret = 1;
X			}
X			if (close(authfh) == -1) {
X				syslog(LOGPRI, "close(authfh): %m");
X				ret = 1;
X			}
X			userauthenticated++;
X			ret = -1;
X		}
X
X		/* clean ending */
X		if (ret == 0)
X			break;
X		/* an error occurred */
X		else if (ret == 1)
X			return(1);
X	}
X	return(0);
X}
X
Xvoid
Xdeadchild()
X{
X#if defined(hpux) || defined(SOLARIS) || defined(IRIX) || defined(AIX)
X        int             wstatus;
X#else
X        union wait      wstatus;
X#endif
X
X        while (wait3(&wstatus, WNOHANG, NULL) > 0)
X                ;
X        child_is_dead++;
X        (void)signal(SIGCLD, deadchild);
X
X	syslog(LOGPRI, "entering deadchild");
X        return;
X}
X
Xvoid
Xidletimeout()
X{
X#if defined(hpux) || defined(SOLARIS) || defined(IRIX) || defined(AIX)
X        int             wstatus;
X#else
X        union wait      wstatus;
X#endif
X
X        while (wait3(&wstatus, WNOHANG, NULL) > 0)
X                ;
X        idle_timeout++;
X        (void)signal(SIGALRM, idletimeout);
X        return;
X}
X
Xdoescape(remhostname, old, new, firstack, buf, len)
Xchar		*remhostname, *buf;
Xstruct termios *old, *new;
Xint		firstack;
Xint		*len;
X{
X	char	line[80];
X	int	quit = 0;
X	char	*skeyprompt;
X	char	*control(), *skeyresp();
X
X	/* turn into cooked mode */
X	if (tcsetattr(0, TCSANOW, old) == -1) {
X		perror("tcgetattr()");
X		return(1);
X	}
X
X	(void)alarm(0);
X
X	for (; ;) {
X		printf("\n");
X		cprintf("> ");
X
X		if (fgets(line, sizeof(line), stdin) == NULL) {
X			quit = 1; /* user hit ^D */
X			break;
X		}
X
X		rip(line);
X
X		/* return to remote */
X		if (line[0] == '\0') {
X			break;
X		}
X
X		/* return to remote */
X		if (!strncmp(line, "return", strlen(line))) {
X			break;
X		}
X
X		/* terminate connection */
X		if (!strncmp(line, "close", strlen(line)) ||
X		    !strncmp(line, "quit", strlen(line))) {
X			quit = 1;
X			break;
X		}
X
X		/* calculate skey response. skey arguments can be
X		provided at the command line */
X		if (!strncmp(line, SKEY_CMD, strlen(SKEY_CMD)) ||
X		    !strncmp(line, SKEY_CMD_BIS, strlen(SKEY_CMD_BIS))) {
X			char	*p = skeyresp(line, 0);
X
X			if (p)
X				cprintf("skey response: %s\n", p);
X			continue;
X		}
X
X		/* automatic skey prompting */
X		if (!strncmp(line, "autoskey", strlen(line))) {
X			char	*p;
X
X			skeyprompt = doskeymatch(skeybuf, NULL);
X			if (!skeyprompt) {
X				cprintf("no skey challenge found\r\n");
X				break;
X			}
X
X			p = skeyresp(skeyprompt, 1);
X			if (p == NULL) /* failed */
X				return(0);
X			*len = strlen(p) + 1;
X			strcpy(buf, p);
X			buf[strlen(p)] = '\n';
X			buf[strlen(p) + 1] = '\0';
X
X			quit = -1;
X			break;
X		}
X
X		/* log stdout to file */
X		if (!strncmp(line, LOG_CMD, strlen(LOG_CMD))) {
X			if (logging) {
X				if (close(logfh))
X					perror(logfilename);
X				logfh = 0;
X				printf("Capture is OFF (%s)\n", logfilename);
X				logging = 0;
X			}
X			else {
X				char	*p;
X
X				p = (char *)strtok(line +
X						strlen(LOG_CMD), " \t");
X				strcpy(logfilename, p ? p : tmpnam(NULL));
X				if ((logfh = open(logfilename,
X					O_WRONLY | O_CREAT, 0600)) == -1) {
X					perror(logfilename);
X					break;
X				}
X				printf("Capture is ON (%s)\n", logfilename);
X				logging = 1;
X			}
X
X			break;
X		}
X
X#ifdef XFERLOG
X		/* this feature is experimental  */
X		if (!strncmp(line, XFER_CMD, strlen(XFER_CMD))) {
X			char	*p, *q, *r, *t;
X			char	*linep;
X
X			linep = line + strlen(XFER_CMD);
X			if ((p = (char *)strtok(linep, " \t")) == NULL ||
X			    (q = (char *)strtok(NULL, " \t")) == NULL ||
X			    (r = (char *)strtok(NULL, " \t")) == NULL ||
X			    (t = (char *)strtok(NULL, "\"")) == NULL) {
X				printf("usage: %s bytenum extra-skip logfile commands\n",
X								XFER_CMD);
X				continue;
X			}
X
X			if ((tobexfered = atoi(p)) < 1) {
X				printf("size should be > 0\n");
X				continue;
X			}
X
X			if (atoi(q) < 0) {
X				printf("skip cannot be negative\n");
X				continue;
X			}
X
X			strncpy(xferfilename, r, sizeof(xferfilename));
X
X			/* open file for writing */
X			xferfh = open(xferfilename,
X					O_WRONLY | O_TRUNC | O_CREAT, 0600);
X
X			if (xferfh == -1) {
X				perror(xferfilename);
X				break;
X			}
X
X
X			sprintf(buf, "%s; %s; %s\n", 
X				MINUS_ONLCR, t, PLUS_ONLCR);
X			*len = strlen(buf);
X
X			/* it seems that the number of characters to be
X			skipped is machine dependent.  it is dependent,
X			in fact, on the system you are connected to.
X			*/
X			tobeskipped = *len + atoi(q);
X
X			if (tobeskipped >= tobexfered) {
X				printf("xfer is to small!\n");
X				continue;
X			}
X
X			buf[*len - 1] = '\0';
X			cprintf("command is: ``%s''\n", buf);
X			buf[*len - 1] = '\n';
X			cprintf("it should produce %d bytes\n", tobexfered);
X			cprintf("piping to %s, skipping first %d + %d bytes\n",
X					xferfilename, tobeskipped, atoi(q));
X			quit = -1;
X			break;
X		}
X#endif /* XFERLOG */
X
X		/* start xfer connection */
X		if (firstack & FLG_ACTIVE_ATTACKS &&
X		    (!strncmp(line, GET_CMD, strlen(GET_CMD)) ||
X		    !strncmp(line, PUT_CMD, strlen(PUT_CMD)))) {
X			char	*p, *q, *linep, mode;
X
X			mode = !strncmp(line, GET_CMD, strlen(GET_CMD)) ?
X				COMBO_FLG_GET : COMBO_FLG_PUT;
X
X			linep = line + strlen(GET_CMD);
X			if ((p = (char *)strtok(linep, " \t")) == NULL ||
X			    (q = (char *)strtok(NULL, " \t")) == NULL) {
X				if (mode == COMBO_FLG_GET)
X					printf("usage: get remotefile localfile\n");
X				else
X					printf("usage: put localfile remotefile\n");
X				continue;
X			}
X
X			/* set sources and destination files */
X			bzero(fromfile, sizeof(fromfile));
X			strncpy(fromfile, p, strlen(p));
X
X			bzero(tofile, sizeof(tofile));
X			strncpy(tofile, q, strlen(q));
X
X			/* set buffer */
X			strcpy(buf, XFERTOKEN);
X			*len = strlen(buf);
X
X			/* set flags */
X			comboflag |= mode;
X
X			quit = -1;
X			break;
X		}
X
X		/* display some parameters and information */
X		if (!strncmp(line, "status", strlen(line))) {
X			int hrs, min, sec;
X			long elp;
X			char *mode;
X
X			elp = time(NULL) - start;
X			hrs = (int)(elp / 3600L);
X			min = (int)((elp -  (long)hrs * 3600L) / 60L);
X			sec = (int)(elp - (long)hrs * 3600L - (long)min * 60L);
X
X			if (firstack & FLG_NO_ENCRYPTION)
X				mode = "DISABLED: this session is insecure!";
X			else if (firstack & FLG_USE_IDEA)
X				mode = "ENABLED (IDEA)";
X			else if (firstack & FLG_USE_SINGLE)
X				mode = "ENABLED (SINGLE DES)";
X			else if (firstack & FLG_USE_RC4)
X				mode = "ENABLED (RC4)";
X			else
X				mode = "ENABLED (TRIPLE DES)";
X
X			printf("Connected to %s.\n", remhostname);
X			printf("Connection time: %s", ctime(&start));
X			printf("Elapsed time: %d h, %d m, %d s\n",
X								hrs, min, sec);
X			printf("Inbound traffic: %ld bytes\n", traffic);
X			printf("Outbound traffic: %ld bytes\n", userstrokes);
X			printf("Logging to file: %s\n", 
X				logging ? logfilename : "OFF");
X			printf("Escape character is '%s'\n", control(escape));
X			printf("Data encryption: %s\n", mode);
X			printf("Active attacks protection: %s\n",
X				firstack & FLG_ACTIVE_ATTACKS ?
X				"ENABLED" : "DISABLED");
X			printf("\n");
X
X			break;
X		}
X
X		/* escape to shell */
X		if (line[0] == '!') {
X			char	*shell;
X
X			if (line[1] == '\0') {
X				if ((shell = (char *)getenv("SHELL")) == NULL)
X					shell = "/bin/sh";
X			}
X			else
X				shell = line + 1;
X			
X#ifdef SOLARIS
X			(void)sigrelse(SIGCLD);
X			(void)sigrelse(SIGALRM);
X#else
X			(void)sigsetmask(oldmask);
X#endif
X			(void)signal(SIGCLD, SIG_DFL);
X			(void)signal(SIGALRM, SIG_DFL);
X
X			if (system(shell) == -1)
X				perror("system()");
X			(void)signal(SIGCLD, deadchild);
X			/* (void)signal(SIGALRM, idletimeout); */
X#ifdef SOLARIS
X			/* (void)sighold(SIGALRM); */
X			(void)sighold(SIGCLD);
X#else
X			oldmask = sigblock(sigmask(SIGCLD) | sigmask(SIGALRM));
X#endif
X			break;
X		}
X
X		if (!strcmp(line, "z")) {
X			(void)kill(0, SIGTSTP);
X			break;
X		}
X
X		if (!strncmp(line, ESCAPE_CMD, strlen(ESCAPE_CMD))) {
X			unsigned char	x;
X			char		*escbuf;
X			
X			/* make escbuf point to first non command character */
X			escbuf = line + strlen(ESCAPE_CMD);
X			while (isspace(*escbuf))
X				escbuf++;
X
X			if (*escbuf) {
X				x = *escbuf;
X			}
X			else {
X				printf("Current escape character is: '%s'\n",
X							control(escape));
X				printf("Enter new escape character: ");
X				(void)fflush(stdout);
X				x = (unsigned char)getchar();
X			}
X
X			if (isspace(x))
X				printf("escape character not set\n");
X			else {
X				escape = x;
X				printf("escape character set to: %s\n",
X							control(escape));
X			}
X			continue;
X		}
X
X		if (!strncmp(line, "sendesc", strlen(line))) {
X			quit = -1;
X			/* everything is in the buffer already */
X			break;
X		}
X
X		if (!strcmp(line, "?")) {
X			printf("Commands may be abbreviated.  * means: arguments supported\n\n");
X			
X			printf("close, quit, ^D	close current connection\n");
X			printf("return, ^M	return to remote system\n");
X			printf("skey, s/key *	generate skey response\n");
X			printf("autoskey	generate and send skey response\n");
X			printf("status		display operating parameters\n");
X			printf("escape      *	set escape character\n");
X			printf("sendesc		send escape character\n");
X			printf("log 	    *	log to file\n");
X#ifdef XFERLOG
X			printf("xfer	    *	experimental ftp surrogate\n");
X#endif /* XFERLOG */
X			if (firstack & FLG_ACTIVE_ATTACKS) {
X				printf("put	    *	upload a file\n");
X				printf("get         *	download a file\n");
X			}
X			printf("!	    *	shell escape\n");
X			printf("z		suspend telnet\n");
X			printf("?		print help information\n");
X			continue;
X		}
X
X		printf("?Invalid command. Try '?'\n");
X	}
X
X	/* return to raw mode */
X	if (tcsetattr(0, TCSANOW, new) == -1) {
X		perror("tcgetattr()");
X		return(1);
X	}
X	return(quit);
X}
X
Xchar *
Xskeyresp(line, automjr)
Xchar	*line;
Xint	automjr;
X{
X	char		*seed, *seqn, passwd[80];
X	static char	buf[256];
X	int		n;
X	int		desmode = 0;
X	char		key[8];
X	void		sk_restore_ttymode();
X	void		(*oldsig) ();
X
X	cprintf(
X"Reminder: do not use this while logged in via telnet or dial-in\n");
X
X	if (*line == '[') /* skip trailing [ */
X		line++;
X	if (!strncmp(line, SKEY_CMD, strlen(SKEY_CMD)))
X		line += strlen(SKEY_CMD); /* skip the first word */
X	else if (!strncmp(line, SKEY_CMD_BIS, strlen(SKEY_CMD_BIS)))
X		line += strlen(SKEY_CMD_BIS); /* skip the first word */
X	seqn = (char *)strtok(line, ", \t[]"); /* check command line args */
X	if (seqn == NULL) {
X		cprintf("sequence number, seed: ");
X		(void)fflush(stdout);
X		if (fgets(buf, sizeof(buf), stdin) == NULL) {
X			cprintf("EOF\n");
X			return(NULL);
X		}
X		rip(buf);
X
X		seqn = (char *)strtok(buf, ", \t[]");
X		if (seqn == NULL) {
X			cprintf("no input?\n");
X			return(NULL);
X		}
X	}
X	n = atoi(seqn);
X	if (n < 0) {
X		cprintf("%d not positive\n", n);
X		return(NULL);
X	}
X	seed = (char *)strtok(NULL, " \t[]");
X	if (seed == NULL) {
X		cprintf("no seed provided?\n");
X		return(NULL);
X	}
X
X	/* cprintf("[s/key %d %s]\n", n, seed); */
X	cprintf("s/key %d %s\n", n, seed);
X	cprintf("Enter secret password: ");
X
X	/* ECHO OFF */
X	if (tcgetattr(0, &saved_ttymode) == -1) {
X		perror("tcgetattr()");
X		return(NULL);
X	}
X	if ((oldsig = signal(SIGINT, SIG_IGN)) != SIG_IGN)
X		(void)signal(SIGINT, sk_restore_ttymode);
X	if (tcgetattr(0, &noecho_ttymode) == -1) {
X		perror("tcgetattr()");
X		return(NULL);
X	}
X	noecho_ttymode.c_lflag &= ~ECHO;
X	if (tcsetattr(0, TCSANOW, &noecho_ttymode) == -1) {
X		perror("tcsetattr()");
X		return(NULL);
X	}
X
X	if (fgets(passwd, sizeof(passwd), stdin) == NULL) {
X		cprintf("no password provided\n");
X		return(NULL);
X	}
X	rip(passwd);
X
X	/* ECHO ON */
X	if (tcsetattr(0, TCSANOW, &saved_ttymode) == -1) {
X		perror("tcsetattr()");
X		return(NULL);
X	}
X	if (oldsig != SIG_IGN)
X		(void)signal(SIGINT, oldsig);
X	printf("\n");
X
X	if ((char *)getenv("SKEYPADFILE") != NULL) {
X		if (automjr) {
X			cprintf("(using mjr DES padding mode)\n");
X			cprintf("using skeypadfile %s\n",
X							getenv("SKEYPADFILE"));
X			desmode = 1;
X		}
X		else {
X			cprintf("use mjr DES padding mode ? ");
X			if (fgets(buf, sizeof(buf), stdin) == NULL) {
X				cprintf("EOF\n");
X				return(NULL);
X			}
X			rip(buf);
X			if (buf[0] == 'y')
X				desmode = 1;
X		}
X	}
X
X	/* Crunch seed and password into starting key */
X	if(desmode ? deskeycrunch(key, seed, passwd) :
X		keycrunch(key,seed,passwd) != 0) {
X		cprintf("key crunch failed\n");
X		return(NULL);
X	}
X
X	while(n-- != 0)
X		fff(key);
X	btoe(buf, key);
X	return(buf);
X}
X
X/* restore - restore terminal modes when user aborts command */
Xvoid sk_restore_ttymode()
X{
X	if (tcsetattr(0, TCSANOW, &saved_ttymode) == -1)
X		perror("tcsetattr()");
X	exit(1);
X}
X
X
Xstoreskeybuf(buf, len)
Xchar	*buf;
Xint	len;
X{
X	static int	skeyoffset;
X	static int	skeybufsize = sizeof(skeybuf);
X
X	if (skeyoffset == 0) /* init buffer */
X		bzero(skeybuf, skeybufsize);
X	
X	/* buffer fits into skeybuf, the simplest case */
X	if (len + skeyoffset < skeybufsize) {
X		memcpy(skeybuf + skeyoffset, buf, len);
X		skeyoffset += len;
X	}
X	/* buffer does not fit into skeybuf, and in fact it is larger
X	than skeybufsize, so a full shift is performed */
X	else if (len >= skeybufsize) {
X		char	 *p;
X
X		/* get last skeybufsize bytes from buf */
X		p = buf + (len - skeybufsize);
X		memcpy(skeybuf, p, skeybufsize);
X		/* set offset at end of buffer */
X		skeyoffset = skeybufsize - 1;
X	}
X	/* buffer does not fit into skeybuf, but it is smaller than
X	skeybufsize. Two partial shifts are performed */
X	else if (len < skeybufsize) {
X		int	diff;
X
X		/* how many exceeding bytes? */
X		diff = len - (skeybufsize - skeyoffset) + 1;
X		/* first shift */
X		memcpy(skeybuf, skeybuf + diff, skeyoffset - diff);
X		/* second shift */
X		memcpy(skeybuf + skeyoffset - diff, buf, len);
X		/* set offset at end of buffer */
X		skeyoffset = skeybufsize - 1;
X	}
X}
X
Xchar *
Xdoskeymatch(buf, pat)
Xchar	*buf, *pat;
X{
X	static regex_t		storedre;
X	regex_t			re;
X	regmatch_t		pm;
X	static char		prompt[128];
X	char			*pbuf, *rbuf, result[128];
X	int			found = 0;
X
X	if (pat) {
X		/* it seems that re is somewhat corrupred by regexec().
X		so we store it in a safe place and use a temporary copy */
X		(void)regcomp(&storedre, pat, REG_EXTENDED);
X		return(NULL);
X	}
X
X	bzero(result, sizeof(result));
X	bzero(&pm, sizeof(pm));
X	(void)memcpy(&re, &storedre, sizeof(re));
X
X	/* skip all matches but last one */
X	pbuf = buf;
X	while (!regexec(&re, pbuf, 1, &pm, 0)) {
X		if (sizeof(result) < pm.rm_eo - pm.rm_so + 2) /* overflow */
X			continue;
X		strncpy(result, pbuf + pm.rm_so, pm.rm_eo - pm.rm_so);
X		result[pm.rm_eo - pm.rm_so] = '\0';
X		found++;
X		pbuf += pm.rm_eo;
X	}
X
X	if (!found)
X		return(NULL);
X
X	/* remove all \n\r */
X	rbuf = result;
X	pbuf = prompt;
X	while (*rbuf) {
X		if (*rbuf != '\n' && *rbuf != '\r')
X			*pbuf++ = *rbuf;
X		rbuf++;
X	}
X	*pbuf = '\0';
X
X	return (prompt);
X}
X
Xdoinput(in, channel, buf, side, firstack, remhostname, old, new)
Xint		in, channel;
Xint		side, firstack;
Xchar		*buf, *remhostname;
Xstruct 		termios	*old, *new;
X{
X	static unsigned long	sequence;
X	/*
X	register		side;
X	*/
X	static			enc, cipher, cipherinit;
X	int			len;
X
X	/*
X	side = remhostname ? CLIENT_SIDE : SERVER_SIDE;
X	*/
X	if (!cipherinit++) {
X		if (!(firstack & FLG_NO_ENCRYPTION))
X			enc = DES_ENCRYPT;
X		else
X			enc = -1;
X
X		cipher = 0; /* use single des by default */
X		if (firstack & FLG_USE_SINGLE)
X			cipher = DES_CIPHER;
X		else if (firstack & FLG_USE_IDEA)
X			cipher = IDEA_CIPHER;
X		else if (firstack & FLG_USE_RC4)
X			cipher = RC4_CIPHER;
X		else
X			cipher = TRIPLEDES_CIPHER;
X	}
X
X	if ((len = read(in, buf, MAKEIOBUF)) == -1) {
X/* #if defined(SUNOS4) || defined(linux) */
X		if (errno == EIO) /* sun EOF */
X			return(0);
X			
X/* #endif */
X		syslog(LOGPRI, "read(): %m");
X		return(1);
X	}
X	if (!len)
X		return(0);
X
X	if (side == CLIENT_SIDE &&
X	    len == 1 && /* prevent accidental triggering */
X	    (buf[0] == escape) && !(firstack & FLG_NO_ESCAPE)) {
X		int	ret;
X
X		ret = doescape(remhostname, old, new, firstack, buf, &len);
X		if (ret == 1) { /* terminate connection */
X			return(0);
X		}
X
X		cprintf("Returning to remote\r\n");
X		if (ret == 0) { /* cont connection */
X			return(-1);
X		}
X		/* if ret == -1 fall trought, so buf is
X		passed on to the server */
X	}
X
X	userstrokes += len;
X
X	/* check integrity and ordering */
X	if (firstack & FLG_ACTIVE_ATTACKS) {
X		struct dataset {
X			unsigned long	seq;
X#ifdef COMBOFLAG
X			int		flag;
X#endif /* COMBOFLAG */
X			long		crc32;
X			int		len;
X		} set;
X
X		crc32val = 0L;
X		UpdateCRC(buf, len);
X		sequence++;
X
X		/* set it */
X		set.seq = htonl(sequence);
X#ifdef COMBOFLAG
X		set.flag = htonl(comboflag);
X#endif /* COMBOFLAG */
X		set.crc32 = htonl(crc32val);
X		set.len = htonl(len);
X
X		/*
X		{
X			char	tmp[MAKEIOBUF * 2];
X
X			bzero(tmp, sizeof(buf));
X			memcpy(tmp, buf, len);
X			syslog(LOGPRI, "SENDING data = ``%s''", buf);
X		}
X		*/
X
X		/* encrypt it */
X		cryptbuf(&set, sizeof(set), enc, cipher, side);
X		cryptbuf(buf, len, enc, cipher, side);
X
X		/* send it.
X		eventually, send put/get commands
X		*/
X		if (write_data(channel, &set, sizeof(set)) != sizeof(set) ||
X		    write_data(channel, buf, len) != len) {
X			syslog(LOGPRI, "write_data(dataset+buf)");
X			return(1);
X		}
X
X		/* perform GET command */
X		if (firstack & FLG_ACTIVE_ATTACKS &&
X		    (comboflag & COMBO_FLG_GET || comboflag & COMBO_FLG_PUT)) {
X			int	ret;
X			ret = doclientftp(channel, fromfile, tofile,
X							cipher, comboflag);
X			if (ret) {
X				cprintf("File xfer failed\r\n");
X				if (ret == 1)
X					return(1);
X			}
X			comboflag = COMBO_FLG_DATA;
X		}
X
X	}
X	/**/ 
X	else {
X		/* encrypt data buffer */
X		cryptbuf(buf, len, enc, cipher, side);
X
X		if (write_data(channel, buf, len) != len) {
X			syslog(LOGPRI, "write_data(net): %m");
X			return(1);
X		}
X	}
X
X	return(-1);
X}
X
Xdochannel(channel, out, buf, side, firstack, remhostname, username, timeout)
Xint	channel, out;
Xchar	*buf;
Xint	side, firstack;
Xchar	*remhostname, *username;
Xint	timeout;
X{
X	combopacket		**p;
X	combopacket		**extract();
X	static unsigned long	sequence;
X	register		i, len, iside;
X	static			dec, cipher, cipherinit;
X
X	/* INVERTED, for encryption issues */
X	iside = side == CLIENT_SIDE ? SERVER_SIDE : CLIENT_SIDE;
X
X	if (!cipherinit++) {
X		if (!(firstack & FLG_NO_ENCRYPTION))
X			dec = DES_DECRYPT;
X		else
X			dec = -1;
X
X		cipher = 0; /* use single des by default */
X		if (firstack & FLG_USE_SINGLE)
X			cipher = DES_CIPHER;
X		else if (firstack & FLG_USE_IDEA)
X			cipher = IDEA_CIPHER;
X		else if (firstack & FLG_USE_RC4)
X			cipher = RC4_CIPHER;
X		else
X			cipher = TRIPLEDES_CIPHER;
X	}
X
X	/* check integrity and ordering */
X	if (firstack & FLG_ACTIVE_ATTACKS) {
X		if ((len = read(channel, buf, MAKEIOBUF)) == -1) {
X			syslog(LOGPRI, "read(): %m");
X			return(1);
X		}
X
X		if (!len) /* disconnection */
X			return(0);
X
X		traffic += len;
X		if (side == CLIENT_SIDE && firstack & FLG_DEBUG) {
X			cprintf("hexdump buffer %d bytes: ", len);
X			hexdump(NULL, buf, len);
X		}
X
X		/* decode buffer */
X		cryptbuf(buf, len, dec, cipher, iside);
X
X		if ((p = extract(buf, len)) == NULL)
X			return(1);
X
X		for (i = 0; p[i]; i++) {
X			/* increase sequence number */
X			sequence++;
X
X			/* check sequence for remote packet */
X			if (sequence != p[i]->seq) {
X				syslog(LOGPRI, "data out of order, possible active attack! packet #%lu expected, #%lu received",
X							sequence, p[i]->seq);
X				if (side == CLIENT_SIDE)
X					cprintf("DATA OUT OF ORDER, possible active attack!\n\r");
X				return(1);
X			}
X
X			/* check checksum for remote packet */
X			crc32val = 0L;
X			UpdateCRC(p[i]->data, p[i]->len);
X			if (crc32val != p[i]->crc32) {
X				syslog(LOGPRI, "garbled data, possible active attack! packet #%lu, len = %d, crc32 %ld expected %ld received",
X					sequence,
X					p[i]->len,
X					crc32val,
X					p[i]->crc32);
X		/*
X		{
X			char	buf[MAKEIOBUF * 2];
X
X			bzero(buf, sizeof(buf));
X			memcpy(buf, p[i]->data, p[i]->len > 1000 ? 1000 : p[i]->len);
X			syslog(LOGPRI, "garbled buffer (%d) = ``%s''", p[i]->len,  buf);
X		}
X		*/
X				if (side == CLIENT_SIDE)
X					cprintf("GARBLED DATA, possible active attack!\n\r");
X				return(1);
X			}
X
X			/* log to file. only client gets logging set */
X			if (logging) {
X				if (write(logfh, p[i]->data, p[i]->len) == -1) {
X					cprintf("%s: %s\r\n",
X						logfilename,
X						sys_errlist[errno]);
X					(void)close(logfh);
X					logfh = 0;
X					logging = 0;
X				}
X			}
X
X#ifdef XFERLOG
X			/* xfer files. only client gets tobeskipped set */
X			if (tobexfered) {
X				int		still;
X				char		*tmp, *data;
X
X				data = p[i]->data;
X
X				/* skip  the command itself */
X				if (tobeskipped) {
X					if (tobeskipped > p[i]->len) {
X						tobeskipped -= p[i]->len;
X						continue;
X					}
X					data += tobeskipped;
X					p[i]->len -= tobeskipped;
X					tobeskipped = 0;
X				}
X
X				/* write all buffer to file */
X				if (tobexfered >= p[i]->len) {
X					if (write(xferfh, data, p[i]->len) == -1) {
X						LOGIOERROR();
X					}
X					tobexfered -= p[i]->len;
X					if (!tobexfered)
X						goto xfercompleted;
X					continue;
X				}
X				
X				/* write part of buffer to file */
X				if (write(xferfh, data, tobexfered) == -1) {
X					LOGIOERROR();
X				}
X				/* shift buffer */
X				if ((tmp = (char *)malloc(p[i]->len)) == NULL) {
X					LOGIOERROR();
X				}
X				memcpy(tmp, data, p[i]->len);
X				still = p[i]->len - tobexfered;
X				memcpy(data, tmp + tobexfered, still);
X				free(tmp);
X				p[i]->len = still;
X
Xxfercompleted:
X				if (close(xferfh) == -1) {
X					LOGIOERROR();
X				}
X				tobexfered = 0;
X				cprintf("xfer completed (%s)\r\n",
X							 xferfilename);
X				continue;
X			}
X#endif /* XFERLOG */
X
X			if (firstack & FLG_ACTIVE_ATTACKS &&
X			    /* double check */
X			    (p[i]->flag & COMBO_FLG_GET ||
X			    p[i]->flag & COMBO_FLG_PUT) &&
X			    /* this is a triple check! */
X			    !memcmp(p[i]->data, XFERTOKEN, strlen(XFERTOKEN))) {
X				int	ret;
X
X				ret = doserverftp(channel, cipher, p[i]->flag,
X							username, remhostname);
X				syslog(LOGPRI, "return: %d", ret);
X
X				if (ret == 1)
X						return(1);
X				continue;
X			}
X
X			/* write buffer to OUT */
X			if (write_data(out, p[i]->data, p[i]->len) !=
X								p[i]->len) {
X				syslog(LOGPRI, "write_data(out): %m");
X				return(1);
X			}
X
X			/* store output into a circular buffer, for skey
X			challenge detection and skey response automatic
X			generation
X			*/
X			storeskeybuf(p[i]->data, p[i]->len);
X		}
X	}
X	/**/
X	else {
X		if ((len = read(channel, buf, MAKEIOBUF)) == -1) {
X			syslog(LOGPRI, "read(): %m");
X			return(1);
X		}
X
X		if (!len)
X			return(0);
X
X		traffic += len;
X
X		if (side == CLIENT_SIDE && firstack & FLG_DEBUG) {
X			cprintf("hexdump buffer %d bytes: ", len);
X			hexdump(NULL, buf, len);
X		}
X
X		/* decode buffer */
X		cryptbuf(buf, len, dec, cipher, iside);
X
X		if (write_data(out, buf, len) != len) {
X			syslog(LOGPRI, "write_data(out): %m");
X			return(1);
X		}
X
X		/* store output into a circular buffer, for skey
X		challenge detection and skey response automatic
X		generation */
X		storeskeybuf(buf, len);
X	}
X
X	/* server side: receiving some kind of user's input */
X	if (side == SERVER_SIDE && timeout) {
X		(void)alarm(timeout * 60); /* reset timer */
X	}
X
X	return(-1);
X}
X
Xcombopacket **
Xextract(buf, len)
Xchar	*buf;
Xint	len;
X{
X	static combopacket	*p[MAXCOMBONUM];
X	static combopacket	*x;
X	int			objnum;
X	static char		intbuf[MAKEIOBUF * 2], tmp[MAKEIOBUF * 2];
X	static int		intbufoffset; /* append offset */
X	int			readoffset; /* reading offset */
X	int			datalen; /* size of current data buffer */
X	long			dataseq; /* seq number of current data buf */
X#ifdef COMBOFLAG
X	int			dataflag; /* option flag */
X#endif /* COMBOFLAG */
X	unsigned long		datacrc32; /* checksum of current data buf */
X	int			remaining; /* decreasing counter */
X	static int		olddatalen;
X	static unsigned long	olddataseq;
X#ifdef COMBOFLAG
X	static int		olddataflag;
X#endif /* COMBOFLAG */
X	static long		olddatacrc32;
X	int			readheader = 0;
X	register		i;
X
X	/* free array elements */
X	for (i = 0; p[i]; i++) {
X		free(p[i]->data);
X		free(p[i]);
X	}
X
X	/* overflow! should never happen */
X	if (len + intbufoffset > MAKEIOBUF * 2) {
X		syslog(LOGPRI, "extract: buffer overflow!\n");
X		return(NULL);
X	}
X
X	/* store buf into internal buffer.  we handle packet
X	fragmentation in this way */
X	memcpy(intbuf + intbufoffset, buf, len);
X	remaining = intbufoffset + len;
X
X	/* build combopacket array */
X	for (objnum = 0, readoffset = 0; ; objnum++) {
X		/*
X		syslog(LOGPRI, "extract: ANALYZING OBJECT # %d", objnum);
X		*/
X
X		/* handle residue data.
X		at least the non-dynamic part of combopacket should fit
X		if it does not, continue and collect more data. */
X		if (!olddatalen && remaining <
X				sizeof(dataseq) +
X#ifdef COMBOFLAG
X				sizeof(dataflag) +
X#endif /* COMBOFLAG */
X				sizeof(datacrc32) +
X				sizeof(datalen)) {
X			/*
X			syslog(LOGPRI, "BREAKING at the first point: remaining = %d", remaining);
X			*/
X			break;
X		}
X
X		if (objnum >= MAXCOMBONUM - 1) {
X			syslog(LOGPRI, "extract: packetnum overflow!\n");
X			return(NULL);
X		}
X
X		if (!olddatalen) {
X			/* get sequence number of this packet */
X			memcpy(&dataseq,
X				intbuf +
X				readoffset,
X					sizeof(dataseq));
X			dataseq = ntohl(dataseq);
X#ifdef COMBOFLAG
X			memcpy(&dataflag,
X				intbuf +
X				readoffset +
X				sizeof(dataseq),
X					sizeof(dataflag));
X			dataflag = ntohl(dataflag);
X#endif /* COMBOFLAG */
X
X			/* get checksum of this packet */
X			memcpy(&datacrc32,
X				intbuf +
X				readoffset +
X				sizeof(dataseq)
X#ifdef COMBOFLAG
X				+ sizeof(dataflag)
X#endif /* COMBOFLAG */
X					, sizeof(datacrc32));
X			datacrc32 = ntohl(datacrc32);
X
X			/* get size of this packet */
X			memcpy(&datalen,
X				intbuf +
X				readoffset +
X				sizeof(dataseq) +
X#ifdef COMBOFLAG
X				sizeof(dataflag) +
X#endif /* COMBOFLAG */
X				sizeof(datacrc32),
X					sizeof(datalen));
X			datalen = ntohl(datalen);
X
X			remaining -= sizeof(datalen) +
X				     sizeof(dataseq) +
X#ifdef COMBOFLAG
X				     sizeof(dataflag) + 
X#endif /* COMBOFLAG */
X				     sizeof(datacrc32);
X			readheader++;
X		}
X		else {
X			datalen = olddatalen;
X			dataseq = olddataseq;
X#ifdef COMBOFLAG
X			dataflag = olddataflag;
X#endif /* COMBOFLAG */
X			datacrc32 = olddatacrc32;
X		}
X
X		/* this is a special case: we read datalen and we find out
X		that there is not enough data in the buffer.  we have to
X		keep track of datalen before returning to get more data */
X		if (datalen > remaining) {
X			olddatalen = datalen;
X			olddataseq = dataseq;
X#ifdef COMBOFLAG
X			olddataflag = dataflag;
X#endif /* COMBOFLAG */
X			olddatacrc32 = datacrc32;
X			/*
X			syslog(LOGPRI, "extract: BREAKING at the second point (datalen = %d >>> remaining = %d)",
X							datalen, remaining);
X			*/
X			break;
X		}
X
X		/*
X		syslog(LOGPRI, "extract: before *x setting...");
X		syslog(LOGPRI, "extract: *x dump: %lu, %ld, %d, %s\n",
X			dataseq, datacrc32, datalen, intbuf + readoffset);
X		*/
X
X		/* allocate x */
X		if ((x = (combopacket *)malloc(sizeof(combopacket))) == NULL) {
X			syslog(LOGPRI, "extract: malloc()");
X			return(NULL);
X		}
X
X		/* set x.seq */
X		x->seq = dataseq;
X
X#ifdef COMBOFLAG
X		/* set x.flag */
X		x->flag = dataflag;
X#endif /* COMBOFLAG */
X
X		/* set x.crc32 */
X		x->crc32 = datacrc32;
X
X		/* set x.len */
X		x->len = datalen;
X
X		/* set x.data */
X		if ((x->data = (char *)malloc(datalen)) == NULL) {
X			perror("extract: malloc()");
X			return(NULL);
X		}
X		/* copy data into x->data, skipping datalen */
X		if (/* !olddatalen */ readheader)
X			memcpy(x->data, intbuf +
X					readoffset +
X					sizeof(datalen) +
X				 	sizeof(dataseq) +
X#ifdef COMBOFLAG
X					sizeof(dataflag) +
X#endif /* COMBOFLAG */
X				 	sizeof(datacrc32),
X								datalen);
X		else {
X			memcpy(x->data, intbuf + readoffset, datalen);
X		}
X
X		/*
X		syslog(LOGPRI, "extract: *x dump...");
X		syslog(LOGPRI, "extract: *x dump: seq = %lu, crc = %ld, len =  %d",
X			dataseq, datacrc32, datalen);
X		{
X			char	buf[MAKEIOBUF * 2];
X
X			bzero(buf, sizeof(buf));
X			memcpy(buf, x->data, datalen);
X			syslog(LOGPRI, "extract: data = ``%s''", buf);
X		}
X		*/
X		
X
X		/* set array element */
X		p[objnum] = x;
X
X		/* update pointers */
X		if (/* !olddatalen */ readheader) {
X			readoffset += datalen +
X					sizeof(datalen) +
X				 	sizeof(dataseq) +
X#ifdef COMBOFLAG
X					sizeof(dataflag) +
X#endif /* COMBOFLAG */
X				 	sizeof(datacrc32);
X			/* ``remaining'' has already been decreased by
X			header's size */
X			remaining -= datalen;
X		}
X		else {
X			readoffset += datalen;
X			remaining -= datalen;
X		}
X		olddatalen = 0;
X#ifdef COMBOFLAG
X		olddataflag = 0;
X#endif /* COMBOFLAG */
X		olddatacrc32 = 0L;
X		olddataseq = 0L;
X		readheader = 0;
X	}
X
X	/* reduce intbuffer */
X	memcpy(tmp, intbuf, MAKEIOBUF * 2);
X	bzero(intbuf, sizeof(intbuf));
X	/* if (!olddatalen || fragmentation) */
X	if (!readheader) /* this nly happens when breaking out of the loop */
X		memcpy(intbuf, tmp + readoffset, MAKEIOBUF * 2 - readoffset);
X	else /* skip header */
X		memcpy(intbuf, tmp +
X				readoffset +
X				sizeof(datalen) +
X				sizeof(dataseq) +
X#ifdef COMBOFLAG
X				sizeof(dataflag) +
X#endif /* COMBOFLAG */
X				sizeof(datacrc32),
X				MAKEIOBUF * 2 -
X				readoffset -
X				sizeof(datalen) -
X				sizeof(dataseq) -
X#ifdef COMBOFLAG
X				sizeof(dataflag) -
X#endif /* COMBOFLAG */
X				sizeof(datacrc32));
X	intbufoffset = remaining;
X
X	/* lasty element should be zero */
X	p[objnum] = NULL;
X
X	return(p);
X}
X
X
X/* client read()s (blocks) first */
Xdoclientftp(net, in, out, cipher, mode)
Xchar	*in, *out;
Xint	net, cipher, mode;
X{
X	char		buf[100];
X	unsigned char	digest[16];
X	combocmd	cmd;
X	comboanswer	answer;
X	int		localfh, len;
X	int		error = 0;
X	MD5_CTX		mdContext;
X	long		crc32tmp;
X
X	/* read what ack from server */
X	if (read_data(net, buf, strlen(WHAT_ACK)) != strlen(WHAT_ACK)) {
X		cprintf("Bad WHAT_ACK from server\r\n");
X		return(1);
X	}
X
X	/* decrypt what ack */
X	cryptbuf(buf, strlen(WHAT_ACK), DES_ENCRYPT, cipher, CLIENT_SIDE);
X
X	/* check WHAT_ACK */
X	if (memcmp(buf, WHAT_ACK, strlen(WHAT_ACK))) {
X		cprintf("Corrupted WHAT_ACK from server\r\n");
X		return(1);
X	}
X
X	bzero(&cmd, sizeof(cmd));
X
X	/* set operation */
X	cmd.cmd = mode;
X
X	/* put local ``in'' file into remote ``out'' file */
X	if (mode & COMBO_FLG_PUT) {
X		struct stat	sbuf;
X
X		/* set filename */
X		strncpy(cmd.filename, out, sizeof(cmd.filename));
X
X		if (stat(in, &sbuf) == -1) {
X			cprintf("PUT failed: %s: %s\r\n",
X						in, sys_errlist[errno]);
X			error++;
X		}
X		cmd.filesize = len = (unsigned long)sbuf.st_size;
X		/* open file for reading */
X		if ((localfh = open(in, O_RDONLY)) == -1) {
X			cprintf("local error: %s: %s\r\n",
X						in, sys_errlist[errno]);
X			error++;
X		}
X	}
X	/* get remote ``in'' file and put it into local ``out'' file */
X	else if (mode & COMBO_FLG_GET) {
X		/* set filename */
X		strncpy(cmd.filename, in, sizeof(cmd.filename));
X
X		/* set filesize */
X		cmd.filesize = (unsigned long)0L;
X		/* open for writing */
X		if ((localfh = open(out, O_WRONLY | O_CREAT | O_TRUNC,
X							0600)) == -1) {
X			cprintf("local error: %s: %s\r\n",
X						out, sys_errlist[errno]);
X			error++;
X		}
X	}
X	else
X		error++;
X
X	if (error)
X		cmd.cmd = 0;
X	
X	cmd.cmd = htonl(cmd.cmd);
X	cmd.filesize = htonl(cmd.filesize);
X
X	/* calculate checksum */
X	MD5Init(&mdContext);
X	MD5Update(&mdContext, &cmd, sizeof(cmd) - 16);
X	MD5Final(cmd.checksum, &mdContext);
X
X	/* encrypt cmd */
X	cryptbuf(&cmd, sizeof(cmd), DES_ENCRYPT, cipher, CLIENT_SIDE);
X
X	/* write cmd to server.
X	if error occurred, let server know about it 
X	*/
X	if (write_data(net, &cmd, sizeof(cmd)) != sizeof(cmd)) {
X		cprintf("Error sending cmd to server\r\n");
X		close(localfh);
X		return(1);
X	}
X
X	if (error) {
X		return(-1); /* error gets handled */
X	}
X
X	if (read_data(net, &answer, sizeof(answer)) != sizeof(answer)) {
X		cprintf("Bad answer from server\r\n");
X		close(localfh);
X		return(1);
X	}
X
X	/* decrypt answer */
X	cryptbuf(&answer, sizeof(answer), DES_ENCRYPT, cipher, CLIENT_SIDE);
X
X	/* check answer integrity */
X	MD5Init(&mdContext);
X	MD5Update(&mdContext, &answer, sizeof(answer) - 16);
X	MD5Final(digest, &mdContext);
X	if (memcmp(digest, answer.checksum, 16)) {
X		cprintf("Corrupted ANSWER from server\r\n");
X		return(1);
X	}
X
X	answer.answer = ntohl(answer.answer);
X	answer.filesize = ntohl(answer.filesize);
X
X	if (answer.answer) {
X		cprintf("Remote error: %s\r\n", answer.message);
X		return(-1);
X	}
X
X	if (mode & COMBO_FLG_PUT) {
X		/* copy file to network */
X		if (streamcp(localfh, net, len, 1,
X					DES_ENCRYPT, cipher, 1)) {
X			cprintf("Error uploading %s: %s\r\n",
X							in, sys_errlist[errno]);
X			(void)close(localfh);
X			return(1);
X		}
X		if (close(localfh) == -1) {
X			cprintf("close(%s): %s\r\n", in, sys_errlist[errno]);
X			return(1);
X		}
X		cprintf("Local file %s UPLOADED to %s\r\n", in, out);
X	}
X	else if (mode & COMBO_FLG_GET) {
X		len = answer.filesize;
X		/* copy network to file */
X		if (streamcp(net, localfh, len, 1,
X					DES_ENCRYPT, cipher, 0)) {
X			cprintf("Error downloading %s: %s\r\n",
X							in, sys_errlist[errno]);
X			(void)close(localfh);
X			return(1);
X		}
X		if (close(localfh) == -1) {
X			cprintf("close(%s): %s\r\n", out, sys_errlist[errno]);
X			return(1);
X		}
X		cprintf("Remote file %s DOWNLOADED to %s\r\n", in, out);
X	}
X
X	/* check the integrity of the xfered file */
X	crc32tmp = htonl(crc32val);
X
X	/* crypt crc32tmp  */
X	cryptbuf(&crc32tmp, sizeof(crc32tmp), DES_ENCRYPT, cipher, CLIENT_SIDE);
X
X	/* send encrypted checksum to server, get checksum from server */
X	if (write_data(net, &crc32tmp, sizeof(crc32tmp)) != sizeof(crc32tmp) ||
X	    read_data(net, &crc32tmp, sizeof(crc32tmp)) != sizeof(crc32tmp)) {
X		cprintf("Cannot verify transfer integrity!\r\n");
X		return(1);
X	}
X
X	crc32tmp = ntohl(crc32tmp);
X
X	/* decrypt crc32tmp */
X	cryptbuf(&crc32tmp, sizeof(crc32tmp), DES_ENCRYPT, cipher, SERVER_SIDE);
X	if (crc32tmp != crc32val) {
X		cprintf("File is CORRUPTED!  Do NOT use it!\r\n");
X		return(1);
X	}
X
X	return(0);
X}
X
Xdoserverftp(net, cipher, mode, username, remhostname)
Xchar	*username, *remhostname;
Xint	net, cipher, mode;
X{
X	char		buf[100];
X	unsigned char	digest[16];
X	combocmd	cmd;
X	comboanswer	answer;
X	int		localfh, len;
X	int		error = 0;
X	MD5_CTX		mdContext;
X	long		crc32tmp;
X
X#if 0
X	struct passwd	*pwd;
X	int		status;
X
X	if ((pwd = getpwnam(username)) == NULL) {
X		syslog(LOGPRI, "XFER: %s: password error!", username);
X		return(1);
X	}
X
X	(void)signal(SIGCLD, SIG_DFL);
X	switch (fork()) {
X		case	-1:
X			syslog(LOGPRI, "XFER: fork(): %m");
X			return(1);
X
X		case	0:
X			if (setgid(pwd->pw_gid) == -1 ||
X			    setuid(pwd->pw_uid) == -1) {
X				syslog(LOGPRI, "setuid(): %m");
X				exit(1);
X			}
X			break;
X
X		default	:
X			while (wait3(&status, WNOHANG, NULL) > 0)
X				;
X
X			/*
X			if (wait(&status) == -1) {
X				syslog(LOGPRI, "XFER: wait(): %m");
X				return(1);
X			}
X			*/
X			(void)signal(SIGCLD, deadchild);
X
X
X			if (WIFSIGNALED(status))
X				return(1);
X			else if (WIFEXITED(status)) {
X				if (WEXITSTATUS(status) == 0)
X					return(0);
X				else if (WEXITSTATUS(status) == 1)
X					return(1);
X				else if (WEXITSTATUS(status) == 255)
X					return(-1);
X			}
X			/* should never happen */
X			syslog(LOGPRI, "XFER: wait() internal error (%d)!",
X							WEXITSTATUS(status));
X			return(1);
X	}
X#endif
X
X	/* send what ack to client */
X	strncpy(buf, WHAT_ACK, sizeof(buf));
X	cryptbuf(buf, strlen(WHAT_ACK), DES_DECRYPT, cipher, CLIENT_SIDE);
X	if (write_data(net, buf, strlen(WHAT_ACK)) != strlen(WHAT_ACK)) {
X		syslog(LOGPRI, "XFER: error sending WHAT_ACK to %s",
X								remhostname);
X		return(1);
X	}
X
X	/* read combocmd from client */
X	if (read_data(net, &cmd, sizeof(cmd)) != sizeof(cmd)) {
X		syslog(LOGPRI, "XFER: bad cmd, connection with %s broken",
X							remhostname);
X		return(1);
X	}
X
X	/* decrypt cmd */
X	cryptbuf(&cmd, sizeof(cmd), DES_DECRYPT, cipher, CLIENT_SIDE);
X
X	/* check cmd integrity */
X	MD5Init(&mdContext);
X	MD5Update(&mdContext, &cmd, sizeof(cmd) - 16);
X	MD5Final(digest, &mdContext);
X	if (memcmp(digest, cmd.checksum, 16)) {
X		syslog(LOGPRI, "XFER: corrupted cmd from %s", remhostname);
X		return(1);
X	}
X
X	cmd.cmd = ntohl(cmd.cmd);
X	cmd.filesize = ntohl(cmd.filesize);
X
X	if (cmd.cmd == 0) { /* handled error */
X		return(-1);
X	}
X
X	/* double check mode */
X	if (mode != cmd.cmd) {
X		syslog(LOGPRI, "XFER: bad command from %s", remhostname);
X		return(1);
X	}
X
X	bzero(&answer, sizeof(answer));
X
X	answer.answer = 0; /* successful by default */
X
X	/* send file to client */
X	if (!userauthenticated) {
X		syslog(LOGPRI,
X		"XFER %s ATTEMPTED to %s %s from %s, not being authenticated!",
X			username,
X			mode & COMBO_FLG_GET ? "GET" : "PUT",
X			cmd.filename,
X			remhostname);
X		strncpy(answer.message, "not authenticated!",
X						sizeof(answer.message));
X		error++;
X	}
X	else if (mode & COMBO_FLG_GET) {
X		struct stat	sbuf;
X
X		/* set filesize */
X		if (stat(cmd.filename, &sbuf) == -1) {
X			syslog(LOGPRI, "GET failed by %s from %s: %s: %m",
X					username, remhostname, cmd.filename);
X			answer.answer = 1;
X			strncpy(answer.message, sys_errlist[errno],
X							sizeof(answer.message));
X			error++;
X		}
X		answer.filesize = len = (unsigned long)sbuf.st_size;
X		/* open file for reading */
X		if ((localfh = open(cmd.filename, O_RDONLY)) == -1) {
X			syslog(LOGPRI, "GET failed by %s from from %s: %s: %m",
X					username, remhostname, cmd.filename);
X			strncpy(answer.message, sys_errlist[errno],
X							sizeof(answer.message));
X			error++;
X		}
X	}
X	/* receive file from client */
X	else if (mode & COMBO_FLG_PUT) {
X		len = cmd.filesize;
X		answer.filesize = (unsigned long)0L;
X		if ((localfh = open(cmd.filename, O_WRONLY | O_CREAT | O_TRUNC,
X							0600)) == -1) {
X			syslog(LOGPRI, "PUT failed by %s from %s: %s: %m",
X					username, remhostname, cmd.filename);
X			strncpy(answer.message, sys_errlist[errno],
X							sizeof(answer.message));
X			error++;
X		}
X	}
X	else /* should never happen */
X		error++;
X
X	if (error)
X		answer.answer = 1; /* fails */
X	
X	answer.answer = htonl(answer.answer);
X	answer.filesize = htonl(answer.filesize);
X
X	/* calculate answer checksum */
X	MD5Init(&mdContext);
X	MD5Update(&mdContext, &answer, sizeof(answer) - 16);
X	MD5Final(answer.checksum, &mdContext);
X
X	/* crypt answer */
X	cryptbuf(&answer, sizeof(answer), DES_DECRYPT, cipher, CLIENT_SIDE);
X
X	if (write_data(net, &answer, sizeof(answer)) != sizeof(answer)) {
X		syslog(LOGPRI, "XFER: error sending answer to %s", remhostname);
X		return(1);
X	}
X
X	
X	if (error)
X		return(-1);
X	
X	/* copy file to network */
X	if (mode & COMBO_FLG_PUT) {
X		if (streamcp(net, localfh, len, 0,
X					DES_DECRYPT, cipher, 0)) {
X			syslog(LOGPRI, "XFER: error storing %s from %s: %m",
X						cmd.filename, remhostname);
X			(void)close(localfh);
X			return(1);
X		}
X		if (close(localfh) == -1) {
X			syslog("XFER: close(%s): %m", cmd.filename);
X			return(1);
X		}
X		syslog(LOGPRI, "%s UPLOADED %s (%d bytes) from %s",
X				username, cmd.filename, len, remhostname);
X	}
X	/* copy network to file */
X	else if (mode & COMBO_FLG_GET) {
X		if (streamcp(localfh, net, len, 0,
X					DES_DECRYPT, cipher, 1)) {
X			syslog(LOGPRI, "XFER: error sending %s to %s: %m",
X						cmd.filename, remhostname);
X			(void)close(localfh);
X			return(1);
X		}
X		if (close(localfh) == -1) {
X			syslog("XFER: close(%s): %m", cmd.filename);
X			return(1);
X		}
X		syslog(LOGPRI, "%s DOWNLOADED %s (%d bytes) from %s",
X				username, cmd.filename, len, remhostname);
X	}
X
X	/* check the integrity of the xfered file */
X	crc32tmp = htonl(crc32val);
X
X	/* crypt crc32tmp  */
X	cryptbuf(&crc32tmp, sizeof(crc32tmp), DES_DECRYPT, cipher, SERVER_SIDE);
X
X	/* send encrypted checksum to client, get checksum from client */
X	if (write_data(net, &crc32tmp, sizeof(crc32tmp)) != sizeof(crc32tmp) ||
X	    read_data(net, &crc32tmp, sizeof(crc32tmp)) != sizeof(crc32tmp)) {
X		syslog(LOGPRI, "XFER: cannot verify integrity for %s from %s",
X						cmd.filename, remhostname);
X		return(1);
X	}
X
X	crc32tmp = ntohl(crc32tmp);
X
X	/* decrypt crc32tmp */
X	cryptbuf(&crc32tmp, sizeof(crc32tmp), DES_DECRYPT, cipher, CLIENT_SIDE);
X	if (crc32tmp != crc32val) {
X		syslog(LOGPRI, "XFER: corrupted file: %s from %s",
X						cmd.filename, remhostname);
X		return(1);
X	}
X
X	return(0);
X}
X
Xstreamcp(from, to, size, isclientside, enc, cipher, crcthencrypt)
Xint	from, to, size, isclientside, enc, cipher, crcthencrypt;
X{
X	char		buf[MAKEIOBUF];
X	register	todo, toread;
X	struct timeval	first, second;
X	struct timezone	tz;
X
X	if (isclientside) {
X		cprintf("xfering %d bytes, using %d bytes/hash mark:  ",
X						size, sizeof(buf));
X	}
X
X	/* reset crc32 */
X	crc32val = 0L;
X
X	(void)gettimeofday(&first, &tz);
X
X	todo = size;
X	while (todo > 0) {
X		toread = todo < sizeof(buf) ? todo : sizeof(buf);
X		if (read_data(from, buf, toread) != toread) {
X			return(1);
X		}
X
X		if (crcthencrypt) { /* from fle to network */
X			UpdateCRC(buf, toread);
X		}
X
X		cryptbuf(buf, toread, enc, cipher, CLIENT_SIDE);
X
X		if (!crcthencrypt) { /* from net to file */
X			UpdateCRC(buf, toread);
X		}
X
X		if (write_data(to, buf, toread) != toread) {
X			return(1);
X		}
X
X
X		todo -= toread;
X
X		if (isclientside) {
X			printf("#");
X			fflush(stdout);
X		}
X	}
X
X	(void)gettimeofday(&second, &tz);
X
X	if (isclientside) {
X		float	ratio;
X
X		if (first.tv_usec > second.tv_usec) {
X			second.tv_usec += 1000000;
X			second.tv_sec--;
X		}
X
X		ratio = (float)size * (float)1000000;
X		ratio /= (float)(second.tv_sec - first.tv_sec) *
X						(float)1000000 +
X			((float)(second.tv_usec - first.tv_usec));
X		ratio /= (float)1024;
X
X		printf("\r\n");
X		fflush(stdout);
X		cprintf("%d bytes received in %lu.%ld seconds (%.2f Kbytes/s)\r\n",
X				size, 
X				second.tv_sec - first.tv_sec,
X				(second.tv_usec - first.tv_usec) / 10000L,
X				ratio);
X	}
X	return(0);
X}
END_OF_FILE
  if test 45770 -ne `wc -c <'makeio.c'`; then
    echo shar: \"'makeio.c'\" unpacked with wrong size!
  fi
  # end of 'makeio.c'
fi
if test -f 'md5c.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'md5c.c'\"
else
  echo shar: Extracting \"'md5c.c'\" \(10425 characters\)
  sed "s/^X//" >'md5c.c' <<'END_OF_FILE'
X/* MD5C.C - RSA Data Security, Inc., MD5 message-digest algorithm
X */
X
X/* Copyright (C) 1991-2, RSA Data Security, Inc. Created 1991. All
Xrights reserved.
X
XLicense to copy and use this software is granted provided that it
Xis identified as the "RSA Data Security, Inc. MD5 Message-Digest
XAlgorithm" in all material mentioning or referencing this software
Xor this function.
X
XLicense is also granted to make and use derivative works provided
Xthat such works are identified as "derived from the RSA Data
XSecurity, Inc. MD5 Message-Digest Algorithm" in all material
Xmentioning or referencing the derived work.
X
XRSA Data Security, Inc. makes no representations concerning either
Xthe merchantability of this software or the suitability of this
Xsoftware for any particular purpose. It is provided "as is"
Xwithout express or implied warranty of any kind.
X
XThese notices must be retained in any copies of any part of this
Xdocumentation and/or software.
X */
X
X#include "global.h"
X#include "md5.h"
X
X/* Constants for MD5Transform routine.
X */
X
X#define S11 7
X#define S12 12
X#define S13 17
X#define S14 22
X#define S21 5
X#define S22 9
X#define S23 14
X#define S24 20
X#define S31 4
X#define S32 11
X#define S33 16
X#define S34 23
X#define S41 6
X#define S42 10
X#define S43 15
X#define S44 21
X
Xstatic void MD5Transform PROTO_LIST ((UINT4 [4], unsigned char [64]));
Xstatic void Encode PROTO_LIST
X  ((unsigned char *, UINT4 *, unsigned int));
Xstatic void Decode PROTO_LIST
X  ((UINT4 *, unsigned char *, unsigned int));
Xstatic void MD5_memcpy PROTO_LIST ((POINTER, POINTER, unsigned int));
Xstatic void MD5_memset PROTO_LIST ((POINTER, int, unsigned int));
X
Xstatic unsigned char PADDING[64] = {
X  0x80, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
X  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
X  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
X};
X
X/* F, G, H and I are basic MD5 functions.
X */
X#define F(x, y, z) (((x) & (y)) | ((~x) & (z)))
X#define G(x, y, z) (((x) & (z)) | ((y) & (~z)))
X#define H(x, y, z) ((x) ^ (y) ^ (z))
X#define I(x, y, z) ((y) ^ ((x) | (~z)))
X
X/* ROTATE_LEFT rotates x left n bits.
X */
X#define ROTATE_LEFT(x, n) (((x) << (n)) | ((x) >> (32-(n))))
X
X/* FF, GG, HH, and II transformations for rounds 1, 2, 3, and 4.
XRotation is separate from addition to prevent recomputation.
X */
X#define FF(a, b, c, d, x, s, ac) { \
X (a) += F ((b), (c), (d)) + (x) + (UINT4)(ac); \
X (a) = ROTATE_LEFT ((a), (s)); \
X (a) += (b); \
X  }
X#define GG(a, b, c, d, x, s, ac) { \
X (a) += G ((b), (c), (d)) + (x) + (UINT4)(ac); \
X (a) = ROTATE_LEFT ((a), (s)); \
X (a) += (b); \
X  }
X#define HH(a, b, c, d, x, s, ac) { \
X (a) += H ((b), (c), (d)) + (x) + (UINT4)(ac); \
X (a) = ROTATE_LEFT ((a), (s)); \
X (a) += (b); \
X  }
X#define II(a, b, c, d, x, s, ac) { \
X (a) += I ((b), (c), (d)) + (x) + (UINT4)(ac); \
X (a) = ROTATE_LEFT ((a), (s)); \
X (a) += (b); \
X  }
X
X/* MD5 initialization. Begins an MD5 operation, writing a new context.
X */
Xvoid MD5Init (context)
XMD5_CTX *context;                                        /* context */
X{
X  context->count[0] = context->count[1] = 0;
X  /* Load magic initialization constants.
X*/
X  context->state[0] = 0x67452301;
X  context->state[1] = 0xefcdab89;
X  context->state[2] = 0x98badcfe;
X  context->state[3] = 0x10325476;
X}
X
X/* MD5 block update operation. Continues an MD5 message-digest
X  operation, processing another message block, and updating the
X  context.
X */
Xvoid MD5Update (context, input, inputLen)
XMD5_CTX *context;                                        /* context */
Xunsigned char *input;                                /* input block */
Xunsigned int inputLen;                     /* length of input block */
X{
X  unsigned int i, index, partLen;
X
X  /* Compute number of bytes mod 64 */
X  index = (unsigned int)((context->count[0] >> 3) & 0x3F);
X
X  /* Update number of bits */
X  if ((context->count[0] += ((UINT4)inputLen << 3))
X   < ((UINT4)inputLen << 3))
X context->count[1]++;
X  context->count[1] += ((UINT4)inputLen >> 29);
X
X  partLen = 64 - index;
X
X  /* Transform as many times as possible.
X*/
X  if (inputLen >= partLen) {
X MD5_memcpy
X   ((POINTER)&context->buffer[index], (POINTER)input, partLen);
X MD5Transform (context->state, context->buffer);
X
X for (i = partLen; i + 63 < inputLen; i += 64)
X   MD5Transform (context->state, &input[i]);
X
X index = 0;
X  }
X  else
X i = 0;
X
X  /* Buffer remaining input */
X  MD5_memcpy
X ((POINTER)&context->buffer[index], (POINTER)&input[i],
X  inputLen-i);
X}
X
X/* MD5 finalization. Ends an MD5 message-digest operation, writing the
X  the message digest and zeroizing the context.
X */
Xvoid MD5Final (digest, context)
Xunsigned char digest[16];                         /* message digest */
XMD5_CTX *context;                                       /* context */
X{
X  unsigned char bits[8];
X  unsigned int index, padLen;
X
X  /* Save number of bits */
X  Encode (bits, context->count, 8);
X
X  /* Pad out to 56 mod 64.
X*/
X  index = (unsigned int)((context->count[0] >> 3) & 0x3f);
X  padLen = (index < 56) ? (56 - index) : (120 - index);
X  MD5Update (context, PADDING, padLen);
X
X  /* Append length (before padding) */
X  MD5Update (context, bits, 8);
X
X  /* Store state in digest */
X  Encode (digest, context->state, 16);
X
X  /* Zeroize sensitive information.
X*/
X  MD5_memset ((POINTER)context, 0, sizeof (*context));
X}
X
X/* MD5 basic transformation. Transforms state based on block.
X */
Xstatic void MD5Transform (state, block)
XUINT4 state[4];
Xunsigned char block[64];
X{
X  UINT4 a = state[0], b = state[1], c = state[2], d = state[3], x[16];
X
X  Decode (x, block, 64);
X
X  /* Round 1 */
X  FF (a, b, c, d, x[ 0], S11, 0xd76aa478); /* 1 */
X  FF (d, a, b, c, x[ 1], S12, 0xe8c7b756); /* 2 */
X  FF (c, d, a, b, x[ 2], S13, 0x242070db); /* 3 */
X  FF (b, c, d, a, x[ 3], S14, 0xc1bdceee); /* 4 */
X  FF (a, b, c, d, x[ 4], S11, 0xf57c0faf); /* 5 */
X  FF (d, a, b, c, x[ 5], S12, 0x4787c62a); /* 6 */
X  FF (c, d, a, b, x[ 6], S13, 0xa8304613); /* 7 */
X  FF (b, c, d, a, x[ 7], S14, 0xfd469501); /* 8 */
X  FF (a, b, c, d, x[ 8], S11, 0x698098d8); /* 9 */
X  FF (d, a, b, c, x[ 9], S12, 0x8b44f7af); /* 10 */
X  FF (c, d, a, b, x[10], S13, 0xffff5bb1); /* 11 */
X  FF (b, c, d, a, x[11], S14, 0x895cd7be); /* 12 */
X  FF (a, b, c, d, x[12], S11, 0x6b901122); /* 13 */
X  FF (d, a, b, c, x[13], S12, 0xfd987193); /* 14 */
X  FF (c, d, a, b, x[14], S13, 0xa679438e); /* 15 */
X  FF (b, c, d, a, x[15], S14, 0x49b40821); /* 16 */
X
X /* Round 2 */
X  GG (a, b, c, d, x[ 1], S21, 0xf61e2562); /* 17 */
X  GG (d, a, b, c, x[ 6], S22, 0xc040b340); /* 18 */
X  GG (c, d, a, b, x[11], S23, 0x265e5a51); /* 19 */
X  GG (b, c, d, a, x[ 0], S24, 0xe9b6c7aa); /* 20 */
X  GG (a, b, c, d, x[ 5], S21, 0xd62f105d); /* 21 */
X  GG (d, a, b, c, x[10], S22,  0x2441453); /* 22 */
X  GG (c, d, a, b, x[15], S23, 0xd8a1e681); /* 23 */
X  GG (b, c, d, a, x[ 4], S24, 0xe7d3fbc8); /* 24 */
X  GG (a, b, c, d, x[ 9], S21, 0x21e1cde6); /* 25 */
X  GG (d, a, b, c, x[14], S22, 0xc33707d6); /* 26 */
X  GG (c, d, a, b, x[ 3], S23, 0xf4d50d87); /* 27 */
X  GG (b, c, d, a, x[ 8], S24, 0x455a14ed); /* 28 */
X  GG (a, b, c, d, x[13], S21, 0xa9e3e905); /* 29 */
X  GG (d, a, b, c, x[ 2], S22, 0xfcefa3f8); /* 30 */
X  GG (c, d, a, b, x[ 7], S23, 0x676f02d9); /* 31 */
X  GG (b, c, d, a, x[12], S24, 0x8d2a4c8a); /* 32 */
X
X  /* Round 3 */
X  HH (a, b, c, d, x[ 5], S31, 0xfffa3942); /* 33 */
X  HH (d, a, b, c, x[ 8], S32, 0x8771f681); /* 34 */
X  HH (c, d, a, b, x[11], S33, 0x6d9d6122); /* 35 */
X  HH (b, c, d, a, x[14], S34, 0xfde5380c); /* 36 */
X  HH (a, b, c, d, x[ 1], S31, 0xa4beea44); /* 37 */
X  HH (d, a, b, c, x[ 4], S32, 0x4bdecfa9); /* 38 */
X  HH (c, d, a, b, x[ 7], S33, 0xf6bb4b60); /* 39 */
X  HH (b, c, d, a, x[10], S34, 0xbebfbc70); /* 40 */
X  HH (a, b, c, d, x[13], S31, 0x289b7ec6); /* 41 */
X  HH (d, a, b, c, x[ 0], S32, 0xeaa127fa); /* 42 */
X  HH (c, d, a, b, x[ 3], S33, 0xd4ef3085); /* 43 */
X  HH (b, c, d, a, x[ 6], S34,  0x4881d05); /* 44 */
X  HH (a, b, c, d, x[ 9], S31, 0xd9d4d039); /* 45 */
X  HH (d, a, b, c, x[12], S32, 0xe6db99e5); /* 46 */
X  HH (c, d, a, b, x[15], S33, 0x1fa27cf8); /* 47 */
X  HH (b, c, d, a, x[ 2], S34, 0xc4ac5665); /* 48 */
X
X  /* Round 4 */
X  II (a, b, c, d, x[ 0], S41, 0xf4292244); /* 49 */
X  II (d, a, b, c, x[ 7], S42, 0x432aff97); /* 50 */
X  II (c, d, a, b, x[14], S43, 0xab9423a7); /* 51 */
X  II (b, c, d, a, x[ 5], S44, 0xfc93a039); /* 52 */
X  II (a, b, c, d, x[12], S41, 0x655b59c3); /* 53 */
X  II (d, a, b, c, x[ 3], S42, 0x8f0ccc92); /* 54 */
X  II (c, d, a, b, x[10], S43, 0xffeff47d); /* 55 */
X  II (b, c, d, a, x[ 1], S44, 0x85845dd1); /* 56 */
X  II (a, b, c, d, x[ 8], S41, 0x6fa87e4f); /* 57 */
X  II (d, a, b, c, x[15], S42, 0xfe2ce6e0); /* 58 */
X  II (c, d, a, b, x[ 6], S43, 0xa3014314); /* 59 */
X  II (b, c, d, a, x[13], S44, 0x4e0811a1); /* 60 */
X  II (a, b, c, d, x[ 4], S41, 0xf7537e82); /* 61 */
X  II (d, a, b, c, x[11], S42, 0xbd3af235); /* 62 */
X  II (c, d, a, b, x[ 2], S43, 0x2ad7d2bb); /* 63 */
X  II (b, c, d, a, x[ 9], S44, 0xeb86d391); /* 64 */
X
X  state[0] += a;
X  state[1] += b;
X  state[2] += c;
X  state[3] += d;
X
X  /* Zeroize sensitive information.
X*/
X  MD5_memset ((POINTER)x, 0, sizeof (x));
X}
X
X/* Encodes input (UINT4) into output (unsigned char). Assumes len is
X  a multiple of 4.
X */
Xstatic void Encode (output, input, len)
Xunsigned char *output;
XUINT4 *input;
Xunsigned int len;
X{
X  unsigned int i, j;
X
X  for (i = 0, j = 0; j < len; i++, j += 4) {
X output[j] = (unsigned char)(input[i] & 0xff);
X output[j+1] = (unsigned char)((input[i] >> 8) & 0xff);
X output[j+2] = (unsigned char)((input[i] >> 16) & 0xff);
X output[j+3] = (unsigned char)((input[i] >> 24) & 0xff);
X  }
X}
X
X/* Decodes input (unsigned char) into output (UINT4). Assumes len is
X  a multiple of 4.
X */
Xstatic void Decode (output, input, len)
XUINT4 *output;
Xunsigned char *input;
Xunsigned int len;
X{
X  unsigned int i, j;
X
X  for (i = 0, j = 0; j < len; i++, j += 4)
X output[i] = ((UINT4)input[j]) | (((UINT4)input[j+1]) << 8) |
X   (((UINT4)input[j+2]) << 16) | (((UINT4)input[j+3]) << 24);
X}
X
X/* Note: Replace "for loop" with standard memcpy if possible.
X */
X
Xstatic void MD5_memcpy (output, input, len)
XPOINTER output;
XPOINTER input;
Xunsigned int len;
X{
X  unsigned int i;
X
X  for (i = 0; i < len; i++)
X output[i] = input[i];
X}
X
X/* Note: Replace "for loop" with standard memset if possible.
X */
Xstatic void MD5_memset (output, value, len)
XPOINTER output;
Xint value;
Xunsigned int len;
X{
X  unsigned int i;
X
X  for (i = 0; i < len; i++)
X ((char *)output)[i] = (char)value;
X}
END_OF_FILE
  if test 10425 -ne `wc -c <'md5c.c'`; then
    echo shar: \"'md5c.c'\" unpacked with wrong size!
  fi
  # end of 'md5c.c'
fi
if test -f 'idea.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'idea.c'\"
else
  echo shar: Extracting \"'idea.c'\" \(17882 characters\)
  sed "s/^X//" >'idea.c' <<'END_OF_FILE'
X/*	idea.c - C source code for IDEA block cipher.
X *	IDEA (International Data Encryption Algorithm), formerly known as 
X *	IPES (Improved Proposed Encryption Standard).
X *	Algorithm developed by Xuejia Lai and James L. Massey, of ETH Zurich.
X *	This implementation modified and derived from original C code 
X *	developed by Xuejia Lai.  
X *	Zero-based indexing added, names changed from IPES to IDEA.
X *	CFB functions added.  Random number routines added.
X *
X *  Optimized for speed 21 Oct 92 by Colin Plumb.
X *  Very minor speedup on 23 Feb 93 by Colin Plumb.
X *  idearand() given a separate expanded key on 25 Feb 93, Colin Plumb.
X *
X *	There are two adjustments that can be made to this code to
X *	speed it up.  Defaults may be used for PCs.  Only the -DIDEA32
X *	pays off significantly if selectively set or not set.  
X *	Experiment to see what works better for you.
X *
X *	Multiplication: default is inline, -DAVOID_JUMPS uses a
X *		different version that does not do any conditional
X *		jumps (a few percent worse on a SPARC), while
X *		-DSMALL_CACHE takes it out of line to stay
X *		within a small on-chip code cache.
X *	Variables: normally, 16-bit variables are used, but some
X *		machines (notably RISCs) do not have 16-bit registers,
X *		so they do a great deal of masking.  -DIDEA32 uses "int"
X *		register variables and masks explicitly only where
X *		necessary.  On a SPARC, for example, this boosts
X *		performace by 30%.
X *
X *	The IDEA(tm) block cipher is covered by a patent held by ETH and a
X *	Swiss company called Ascom-Tech AG.  The Swiss patent number is
X *	PCT/CH91/00117.  International patents are pending. IDEA(tm) is a
X *	trademark of Ascom-Tech AG.  There is no license fee required for
X *	noncommercial use.  Commercial users may obtain licensing details
X *	from Dieter Profos, Ascom Tech AG, Solothurn Lab, Postfach 151, 4502
X *	Solothurn, Switzerland, Tel +41 65 242885, Fax +41 65 235761.
X *
X *	The IDEA block cipher uses a 64-bit block size, and a 128-bit key 
X *	size.  It breaks the 64-bit cipher block into four 16-bit words
X *	because all of the primitive inner operations are done with 16-bit 
X *	arithmetic.  It likewise breaks the 128-bit cipher key into eight 
X *	16-bit words.
X *
X *	For further information on the IDEA cipher, see these papers:
X *	1) Xuejia Lai, "Detailed Description and a Software Implementation of 
X *  	   the IPES Cipher", Institute for Signal and Information
X *   	   Processing, ETH-Zentrum, Zurich, Switzerland, 1991
X *	2) Xuejia Lai, James L. Massey, Sean Murphy, "Markov Ciphers and 
X *   	   Differential Cryptanalysis", Advances in Cryptology- EUROCRYPT'91
X *
X *	This code assumes that each pair of 8-bit bytes comprising a 16-bit 
X *	word in the key and in the cipher block are externally represented 
X *	with the Most Significant Byte (MSB) first, regardless of the
X *	internal native byte order of the target CPU.
X */
X
X#include "idea.h"
X
X#ifdef TEST
X#include <stdio.h>
X#include <time.h>
X#endif
X
X#define ROUNDS	8		/* Don't change this value, should be 8 */
X#define KEYLEN	(6*ROUNDS+4)	/* length of key schedule */
X
X/* already defined in idea.h
Xtypedef word16 IDEAkey[KEYLEN];
X*/
X
X#ifdef IDEA32	/* Use >16-bit temporaries */
X#define low16(x) ((x) & 0xFFFF)
Xtypedef unsigned int uint16;	/* at LEAST 16 bits, maybe more */
X#else
X#define low16(x) (x)	/* this is only ever applied to uint16's */
Xtypedef word16 uint16;
X#endif
X
X#ifdef _GNUC_
X/* __const__ simply means there are no side effects for this function,
X * which is useful info for the gcc optimizer */
X#define CONST __const__
X#else
X#define CONST
X#endif
X
Xstatic void en_key_idea(word16 *userkey, word16 *Z);
Xstatic void de_key_idea(IDEAkey Z, IDEAkey DK);
X/* static */ void cipher_idea(word16 in[4], word16 out[4], CONST IDEAkey Z);
X
X/*
X *	Multiplication, modulo (2**16)+1
X * Note that this code is structured like this on the assumption that
X * untaken branches are cheaper than taken branches, and the compiler
X * doesn't schedule branches.
X */
X#ifdef SMALL_CACHE
XCONST static uint16 mul(register uint16 a, register uint16 b)
X{
X	register word32 p;
X
X	if (a)
X	{	if (b)
X		{	p = (word32)a * b;
X			b = low16(p);
X			a = p>>16;
X			return b - a + (b < a);
X		}
X		else
X		{	return 1-a;
X		}
X	}
X	else
X	{	return 1-b;
X	}
X}        /* mul */
X#endif /* SMALL_CACHE */
X
X/*
X *	Compute multiplicative inverse of x, modulo (2**16)+1,
X *	using Euclid's GCD algorithm.  It is unrolled twice to
X *	avoid swapping the meaning of the registers each iteration,
X *	and some subtracts of t have been changed to adds.
X */
XCONST static uint16 inv(uint16 x)     
X{
X	uint16 t0, t1;
X	uint16 q, y;
X
X	if (x <= 1)
X		return x;	/* 0 and 1 are self-inverse */
X	t1 = 0x10001L / x;	/* Since x >= 2, this fits into 16 bits */
X	y = 0x10001L % x;
X	if (y == 1)
X		return low16(1-t1);
X	t0 = 1;
X	do
X	{	q = x / y;
X		x = x % y;
X		t0 += q * t1;
X		if (x == 1)
X			return t0;
X		q = y / x;
X		y = y % x;
X		t1 += q * t0;
X	} while (y != 1);
X	return low16(1-t1);
X} /* inv */
X
X/*	Compute IDEA encryption subkeys Z */
Xstatic void en_key_idea(word16 *userkey, word16 *Z)
X{
X	int i,j;
X
X	/*
X	 * shifts
X	 */
X	for (j=0; j<8; j++)
X		Z[j] = *userkey++;
X
X	for (i=0; j<KEYLEN; j++)
X	{	i++;
X		Z[i+7] = Z[i & 7] << 9 | Z[i+1 & 7] >> 7;
X		Z += i & 8;
X		i &= 7;
X	}
X}        /* en_key_idea */
X
X/*	Compute IDEA decryption subkeys DK from encryption subkeys Z */
X/* Note: these buffers *may* overlap! */
Xstatic void de_key_idea(IDEAkey Z, IDEAkey DK)
X{
X	int j;
X	uint16 t1, t2, t3;
X	IDEAkey T;
X	word16 *p = T + KEYLEN;
X
X	t1 = inv(*Z++);
X	t2 = -*Z++;
X	t3 = -*Z++;
X	*--p = inv(*Z++);
X	*--p = t3;
X	*--p = t2;
X	*--p = t1;
X
X	for (j = 1; j < ROUNDS; j++)
X	{
X		t1 = *Z++;
X		*--p = *Z++;
X		*--p = t1;
X
X		t1 = inv(*Z++);
X		t2 = -*Z++;
X		t3 = -*Z++;
X		*--p = inv(*Z++);
X		*--p = t2;
X		*--p = t3;
X		*--p = t1;
X	}
X	t1 = *Z++;
X	*--p = *Z++;
X	*--p = t1;
X
X	t1 = inv(*Z++);
X	t2 = -*Z++;
X	t3 = -*Z++;
X	*--p = inv(*Z++);
X	*--p = t3;
X	*--p = t2;
X	*--p = t1;
X/* Copy and destroy temp copy */
X	for (j = 0, p = T; j < KEYLEN; j++)
X	{
X		*DK++ = *p;
X		*p++ = 0;
X	}
X} /* de_key_idea */
X
X/*
X * MUL(x,y) computes x = x*y, modulo 0x10001.  Requires two temps, 
X * t16 and t32.  x must me a side-effect-free lvalue.  y may be 
X * anything, but unlike x, must be strictly 16 bits even if low16() 
X * is #defined.
X * All of these are equivalent - see which is faster on your machine
X */
X#ifdef SMALL_CACHE
X#define MUL(x,y) (x = mul(low16(x),y))
X#else
X#ifdef AVOID_JUMPS
X#define MUL(x,y) (x = low16(x-1), t16 = low16((y)-1), \
X		t32 = (word32)x*t16+x+t16+1, x = low16(t32), \
X		t16 = t32>>16, x = x-t16+(x<t16) )
X#else
X#define MUL(x,y) ((t16 = (y)) ? (x=low16(x)) ? \
X	 t32 = (word32)x*t16, x = low16(t32), t16 = t32>>16, \
X	 x = x-t16+(x<t16) : \
X	 (x = 1-t16) : (x = 1-x))
X#endif
X#endif
X
X/*	IDEA encryption/decryption algorithm */
X/* Note that in and out can be the same buffer */ 
X/* static */
Xvoid cipher_idea(word16 in[4], word16 out[4], register CONST IDEAkey Z)
X{
X	register uint16 x1, x2, x3, x4, s2, s3;
X#ifndef SMALL_CACHE
X	register uint16 t16;
X	register word32 t32;
X#endif
X
X	int r = ROUNDS;
X
X	x1 = *in++;  x2 = *in++;
X	x3 = *in++;  x4 = *in;
X	do
X	{
X		MUL(x1,*Z++);
X		x2 += *Z++;
X		x3 += *Z++;
X		MUL(x4, *Z++);
X
X		s3 = x3;
X		x3 ^= x1;
X		MUL(x3, *Z++);
X		s2 = x2;
X		x2 ^= x4;
X		x2 += x3;
X		MUL(x2, *Z++);
X		x3 += x2;
X
X		x1 ^= x2;
X		x4 ^= x3;
X
X		x2 ^= s3;
X		x3 ^= s2;
X	} while (--r);
X	MUL(x1, *Z++);
X	*out++ = x1;
X	*out++ = x3 + *Z++;
X	*out++ = x2 + *Z++;
X	MUL(x4, *Z);
X	*out = x4;
X} /* cipher_idea */
X
X/*-------------------------------------------------------------*/
X
X#ifdef TEST
X/*
X * This is the number of Kbytes of test data to encrypt.
X * It defaults to 1 MByte.
X */
X#ifndef KBYTES
X#define KBYTES 1024
X#endif
X
Xvoid main(void)
X{	/* Test driver for IDEA cipher */ 
X	int i, j, k; 
X	IDEAkey Z, DK;
X	word16 XX[4], TT[4], YY[4];     
X	word16 userkey[8];
X	clock_t start, end;
X	long l;
X
X	/* Make a sample user key for testing... */
X	for(i=0; i<8; i++)
X		userkey[i] = i+1;
X
X	/* Compute encryption subkeys from user key... */
X	en_key_idea(userkey,Z);
X	printf("\nEncryption key subblocks: ");
X	for(j=0; j<ROUNDS+1; j++)
X	{
X		printf("\nround %d:   ", j+1);
X		if (j==ROUNDS)
X			for(i=0; i<4; i++)
X				printf(" %6u", Z[j*6+i]);
X		else
X			for(i=0; i<6; i++)
X				printf(" %6u", Z[j*6+i]);
X	}
X
X	/* Compute decryption subkeys from encryption subkeys... */
X	de_key_idea(Z,DK);
X	printf("\nDecryption key subblocks: ");
X	for(j=0; j<ROUNDS+1; j++)
X	{
X		printf("\nround %d:   ", j+1);
X		if (j==ROUNDS)
X			for(i=0; i<4; i++)
X				printf(" %6u", DK[j*6+i]);
X		else
X			for(i=0; i<6; i++)
X				printf(" %6u", DK[j*6+i]);
X	}
X
X	/* Make a sample plaintext pattern for testing... */
X	for (k=0; k<4; k++)
X		XX[k] = k;
X
X	printf("\n Encrypting %d KBytes (%ld blocks)...", KBYTES, KBYTES*64l);
X	fflush(stdout);
X	start = clock();
X	cipher_idea(XX,YY,Z);       /* encrypt plaintext XX, making YY */ 
X	for (l = 1; l < 64*KBYTES; l++)
X		cipher_idea(YY,YY,Z);	/* repeated encryption */
X	cipher_idea(YY,TT,DK);      /* decrypt ciphertext YY, making TT */ 
X	for (l = 1; l < 64*KBYTES; l++)
X		cipher_idea(TT,TT,DK);	/* repeated decryption */
X	end = clock() - start;
X	l = end * 1000. / CLOCKS_PER_SEC + 1;
X	i = l/1000;
X	j = l%1000;
X	l = KBYTES * 1024. * CLOCKS_PER_SEC / end;
X	printf("%d.%03d seconds = %ld bytes per second\n", i, j, l);
X
X	printf("\nX %6u   %6u  %6u  %6u \n",    
X	  XX[0], XX[1],  XX[2], XX[3]);
X	printf("Y %6u   %6u  %6u  %6u \n",
X	  YY[0], YY[1],  YY[2], YY[3]);
X	printf("T %6u   %6u  %6u  %6u \n",
X	  TT[0], TT[1],  TT[2], TT[3]);
X
X	/* Now decrypted TT should be same as original XX */
X	for (k=0; k<4; k++)
X		if (TT[k] != XX[k])
X		{
X			printf("\n\07Error!  Noninvertable encryption.\n");
X			exit(-1);	/* error exit */ 
X		}
X	printf("\nNormal exit.\n");
X	exit(0);	/* normal exit */ 
X}        /* main */
X
X
X#endif		/* TEST */
X
X
X/*************************************************************************/
X
X
X/*
X *	xorbuf - change buffer via xor with random mask block
X *	Used for Cipher Feedback (CFB) or Cipher Block Chaining
X *	(CBC) modes of encryption.
X *	Can be applied for any block encryption algorithm,
X *	with any block size, such as the DES or the IDEA cipher.
X */
Xstatic void xorbuf(register byteptr buf, register byteptr mask, 
X	register int count)
X/*	count must be > 0 */
X{
X	if (count) 
X		do
X			*buf++ ^= *mask++;
X		while (--count);
X}	/* xorbuf */
X
X
X/*
X *	cfbshift - shift bytes into IV for CFB input
X *	Used only for Cipher Feedback (CFB) mode of encryption.
X *	Can be applied for any block encryption algorithm with any 
X *	block size, such as the DES or the IDEA cipher.
X */
Xstatic void cfbshift(register byteptr iv, register byteptr buf, 
X		register int count, int blocksize)
X/* 	iv is the initialization vector.
X *	buf is the buffer pointer.
X *	count is the number of bytes to shift in...must be > 0.
X *	blocksize is 8 bytes for DES or IDEA ciphers.
X */
X{
X	int retained;
X	if (count)
X	{
X		retained = blocksize-count;	/* number bytes in iv to retain */
X		/* left-shift retained bytes of IV over by count bytes to make room */
X		while (retained--)
X		{
X			*iv = *(iv+count);
X			iv++;
X		}
X		/* now copy count bytes from buf to shifted tail of IV */
X		do	*iv++ = *buf++;
X		while (--count);
X	}
X}	/* cfbshift */
X
X
X
X/* Key schedules for IDEA encryption and decryption */
Xstatic IDEAkey Z;
Xstatic word16 *iv_idea;		/* pointer to IV for CFB or CBC */
Xstatic boolean cfb_dc_idea; /* TRUE iff CFB decrypting */
X
X
X/* initkey_idea initializes IDEA for ECB mode operations */
Xstatic void initkey_idea(byte key[16], boolean decryp)
X{
X	word16 userkey[8];	/* IDEA key is 16 bytes long */
X	int i;
X	/* Assume each pair of bytes comprising a word is ordered MSB-first. */
X	for (i=0; i<8; i++)
X	{
X		userkey[i] = (key[0]<<8) + key[1];
X		key++; key++;
X	}
X	en_key_idea(userkey,Z);
X	if (decryp)
X	{
X		de_key_idea(Z,Z);	/* compute inverse key schedule DK */
X	}
X	for (i=0; i<8; i++)	/* Erase dangerous traces */
X		userkey[i] = 0;
X}
X
X/* initkey_idea initializes IDEA for ECB mode operations */
Xvoid init_this_key_idea(word16 *ZZ, byte key[16], boolean decryp)
X{
X	word16 userkey[8];	/* IDEA key is 16 bytes long */
X	int i;
X	/* Assume each pair of bytes comprising a word is ordered MSB-first. */
X	for (i=0; i<8; i++)
X	{
X		userkey[i] = (key[0]<<8) + key[1];
X		key++; key++;
X	}
X	en_key_idea(userkey,ZZ);
X	if (decryp)
X	{
X		de_key_idea(ZZ,ZZ);	/* compute inverse key schedule DK */
X	}
X	for (i=0; i<8; i++)	/* Erase dangerous traces */
X		userkey[i] = 0;
X} /* initkey_idea */
X
X
X/*	Run a 64-bit block thru IDEA in ECB (Electronic Code Book) mode,
X	using the currently selected key schedule.
X*/
X/* vince */
X/* I want to use idea_ecb from outside modules */
X/* static */ void idea_ecb(word16 *inbuf, word16 *outbuf)
X{
X	/* Assume each pair of bytes comprising a word is ordered MSB-first. */
X#ifndef HIGHFIRST	/* If this is a least-significant-byte-first CPU */
X	word16 x;
X
X	/* Invert the byte order for each 16-bit word for internal use. */
X	x = inbuf[0]; outbuf[0] = x >> 8 | x << 8;
X	x = inbuf[1]; outbuf[1] = x >> 8 | x << 8;
X	x = inbuf[2]; outbuf[2] = x >> 8 | x << 8;
X	x = inbuf[3]; outbuf[3] = x >> 8 | x << 8;
X	cipher_idea(outbuf, outbuf, Z);
X	x = outbuf[0]; outbuf[0] = x >> 8 | x << 8;
X	x = outbuf[1]; outbuf[1] = x >> 8 | x << 8;
X	x = outbuf[2]; outbuf[2] = x >> 8 | x << 8;
X	x = outbuf[3]; outbuf[3] = x >> 8 | x << 8;
X#else	/* HIGHFIRST */
X	/* Byte order for internal and external representations is the same. */
X	cipher_idea(inbuf, outbuf, Z);
X#endif	/* HIGHFIRST */
X} /* idea_ecb */
X
X
X/*
X *	initcfb - Initializes the IDEA key schedule tables via key,
X *	and initializes the Cipher Feedback mode IV.
X *	References context variables cfb_dc_idea and iv_idea.
X */
Xvoid initcfb_idea(word16 iv0[4], byte key[16], boolean decryp)
X/* 	iv0 is copied to global iv_idea, buffer will be destroyed by ideacfb.
X	key is pointer to key buffer.
X	decryp is TRUE if decrypting, FALSE if encrypting.
X*/
X{
X	iv_idea = iv0;
X	cfb_dc_idea = decryp;
X	initkey_idea(key,FALSE);
X} /* initcfb_idea */
X
X
X/*
X *	ideacfb - encipher a buffer with IDEA enciphering algorithm,
X *		using Cipher Feedback (CFB) mode.
X *
X *	Assumes initcfb_idea has already been called.
X *	References context variables cfb_dc_idea and iv_idea.
X */
Xvoid ideacfb(byteptr buf, int count)
X/*	buf is input, output buffer, may be more than 1 block.
X *	count is byte count of buffer.  May be > IDEABLOCKSIZE.
X */
X{
X	int chunksize;	/* smaller of count, IDEABLOCKSIZE */
X	word16 temp[IDEABLOCKSIZE/2];
X
X	while ((chunksize = min(count,IDEABLOCKSIZE)) > 0)
X	{
X		idea_ecb(iv_idea,temp);  /* encrypt iv_idea, making temp. */ 
X
X		if (cfb_dc_idea)	/* buf is ciphertext */
X			/* shift in ciphertext to IV... */
X			cfbshift((byte *)iv_idea,buf,chunksize,IDEABLOCKSIZE);
X
X		/* convert buf via xor */
X		xorbuf(buf,(byte *)temp,chunksize); /* buf now has enciphered output */
X
X		if (!cfb_dc_idea)	/* buf was plaintext, is now ciphertext */
X			/* shift in ciphertext to IV... */
X			cfbshift((byte *)iv_idea,buf,chunksize,IDEABLOCKSIZE);
X
X		count -= chunksize;
X		buf += chunksize;
X	}
X} /* ideacfb */
X
X
X/*
X	close_idea function erases all the key schedule information when 
X	we are all done with a set of operations for a particular IDEA key 
X	context.  This is to prevent any sensitive data from being left 
X	around in memory.
X*/
Xvoid close_idea(void)	/* erase current key schedule tables */
X{
X	short i;
X	for (i = 0; i < KEYLEN; i++)
X		Z[i] = 0;
X}	/* close_idea() */
X
X/********************************************************************/
X
X/*
X *	These buffers are used by init_idearand, idearand, and close_idearand.
X */
Xstatic word16 dtbuf_idea[4] = {0}; /* buffer for enciphered timestamp */
Xstatic word16 randseed_idea[4] = {0}; /* seed for IDEA random # generator */
Xstatic word16 randbuf_idea[4] = {0}; /* buffer for IDEA random # generator */
Xstatic byte randbuf_idea_counter = 0;	/* # of random bytes left in randbuf_idea */
Xstatic IDEAkey randkey_idea;	/* Expanded key for IDEA random # generator */
X
X/*
X *	init_idearand - initialize idearand, IDEA random number generator.
X *		Used for generating cryptographically strong random numbers.
X *		Much of the design comes from Appendix C of ANSI X9.17.
X *		key is pointer to IDEA key buffer.
X *		seed is pointer to random number seed buffer.
X *		tstamp is a 32-bit timestamp
X */
Xvoid init_idearand(byte key[16], byte seed[8], word32 tstamp)
X{
X	int i;
X
X	en_key_idea((word16 *)key, randkey_idea);
X
X	for (i=0; i<4; i++)		/* capture timestamp material */
X	{	dtbuf_idea[i] = tstamp;	/* get bottom word */
X		tstamp = tstamp >> 16;	/* drop bottom word */
X		/* tstamp has only 4 bytes-- last 4 bytes will always be 0 */
X	}
X	/* Start with enciphered timestamp: */
X	cipher_idea(dtbuf_idea, dtbuf_idea, randkey_idea);
X
X	/* initialize seed material */
X	for (i=0; i<8; i++)
X		((byte *)randseed_idea)[i] = seed[i];
X
X	randbuf_idea_counter = 0;	/* # of random bytes left in randbuf_idea */
X
X} /* init_idearand */
X
X
X/*
X *	idearand - IDEA pseudo-random number generator
X *		Used for generating cryptographically strong random numbers.
X *		Much of the design comes from Appendix C of ANSI X9.17.
X */
Xbyte idearand(void)
X{
X	int i;
X	if (randbuf_idea_counter==0)	/* if random buffer is spent...*/
X	{	/* Combine enciphered timestamp with seed material: */
X		for (i=0; i<4; i++)
X			randseed_idea[i] ^= dtbuf_idea[i];
X		cipher_idea(randseed_idea,randbuf_idea,randkey_idea); /* fill new block */
X
X		/* Compute new seed vector: */
X		for (i=0; i<4; i++)
X			randseed_idea[i] = randbuf_idea[i] ^ dtbuf_idea[i];
X		cipher_idea(randseed_idea,randseed_idea,randkey_idea); /* fill new seed */
X
X		randbuf_idea_counter = 8;	/* reset counter for full buffer */
X	}
X	/* Take a byte from randbuf_idea: */
X	return(((byte *)randbuf_idea)[--randbuf_idea_counter]);
X} /* idearand */
X
X
Xvoid close_idearand(void)
X{	/* Erase random IDEA buffers and wipe out IDEA key info */
X	int i;
X	for (i=0; i<4; i++)
X	{	randbuf_idea[i] = 0;
X		randseed_idea[i] = 0;
X		dtbuf_idea[i] = 0;
X	}
X	for (i = 0; i<KEYLEN; i++)
X		randkey_idea[i] = 0;
X}	/* close_idearand */
X
X/* end of idea.c */
X
END_OF_FILE
  if test 17882 -ne `wc -c <'idea.c'`; then
    echo shar: \"'idea.c'\" unpacked with wrong size!
  fi
  # end of 'idea.c'
fi
if test -f 'utmp_init.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'utmp_init.c'\"
else
  echo shar: Extracting \"'utmp_init.c'\" \(868 characters\)
  sed "s/^X//" >'utmp_init.c' <<'END_OF_FILE'
X/* Author: Wietse Venema <wietse@wzv.win.tue.nl> */
X
X#include <sys/types.h>
X#include <utmp.h>
X#include <string.h>
X#include <syslog.h>
X
X/* utmp_init - update utmp and wtmp before login */
X
Xutmp_init(line, user, id)
Xchar   *line;
Xchar   *user;
Xchar   *id;
X{
X    struct utmp utx;
X
X    memset((char *) &utx, 0, sizeof(utx));
X    strncpy(utx.ut_id, id, sizeof(utx.ut_id));
X    strncpy(utx.ut_user, user, sizeof(utx.ut_user));
X    strncpy(utx.ut_line, line, sizeof(utx.ut_line));
X    utx.ut_pid = getpid();
X    utx.ut_type = LOGIN_PROCESS;
X    time(&(utx.ut_time));
X    pututline(&utx);
X    updwtmp(WTMP_FILE, &utx);
X    endutent();
X}
X
X/* utmp_ptsid - generate utmp id for pseudo terminal */
X
Xchar   *utmp_ptsid(line, tag)
Xchar   *line;
Xchar   *tag;
X{
X    static char buf[5];
X
X    strncpy(buf, tag, 2);
X    strncpy(buf + 2, line + strlen(line) - 2, 2);
X    return (buf);
X}
X
END_OF_FILE
  if test 868 -ne `wc -c <'utmp_init.c'`; then
    echo shar: \"'utmp_init.c'\" unpacked with wrong size!
  fi
  # end of 'utmp_init.c'
fi
if test -f 'utmp_login.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'utmp_login.c'\"
else
  echo shar: Extracting \"'utmp_login.c'\" \(1440 characters\)
  sed "s/^X//" >'utmp_login.c' <<'END_OF_FILE'
X/* Author: Wietse Venema <wietse@wzv.win.tue.nl> */
X
X#include <sys/types.h>
X#include <utmp.h>
X#include <string.h>
X#ifdef HAS_UT_ADDR
X#include <netdb.h>
X#endif
X
X/* utmp_login - update System V < 4 utmp and wtmp after login */
X
Xutmp_login(line, user, host)
Xchar   *line;
Xchar   *user;
Xchar   *host;
X{
X    struct utmp *ut;
X    pid_t   mypid = getpid();
X    int     ret = (-1);
X#ifdef HAS_UT_ADDR
X    struct hostent *hp;
X#endif
X
X    /*
X     * Some programs use entries with the "/dev/" prefix stripped off the tty
X     * port name. Some programs make utmp entries with the "/dev/" prefix
X     * included. We therefore cannot use getutline(). Return nonzero if no
X     * utmp entry was found with our own process ID for a login or user
X     * process.
X     */
X
X    while ((ut = getutent())) {
X	if (ut->ut_pid == mypid && (ut->ut_type == INIT_PROCESS
X	  || ut->ut_type == LOGIN_PROCESS || ut->ut_type == USER_PROCESS)) {
X	    strncpy(ut->ut_line, line, sizeof(ut->ut_line));
X	    strncpy(ut->ut_user, user, sizeof(ut->ut_user));
X#ifndef IRIX
X	    strncpy(ut->ut_host, host, sizeof(ut->ut_host));
X#endif
X	    time(&(ut->ut_time));
X#ifdef HAS_UT_ADDR
X	    if ((hp = gethostbyname(host)) != 0)
X		memcpy((char *) &ut->ut_addr, hp->h_addr, sizeof(ut->ut_addr));
X	    else
X		ut->ut_addr = 0;
X#endif
X	    ut->ut_type = USER_PROCESS;
X	    pututline(ut);
X	    updwtmp(WTMP_FILE, ut);
X	    ret = 0;
X	    break;
X	}
X    }
X    endutent();
X    return (ret);
X}
END_OF_FILE
  if test 1440 -ne `wc -c <'utmp_login.c'`; then
    echo shar: \"'utmp_login.c'\" unpacked with wrong size!
  fi
  # end of 'utmp_login.c'
fi
if test -f 'utmp_logout.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'utmp_logout.c'\"
else
  echo shar: Extracting \"'utmp_logout.c'\" \(528 characters\)
  sed "s/^X//" >'utmp_logout.c' <<'END_OF_FILE'
X/* Author: Wietse Venema <wietse@wzv.win.tue.nl> */
X
X#include <sys/types.h>
X#include <utmp.h>
X#include <string.h>
X
X/* utmp_logout - update utmp and wtmp after logout */
X
Xutmp_logout(line)
Xchar   *line;
X{
X    struct utmp utx;
X    struct utmp *ut;
X
X    strncpy(utx.ut_line, line, sizeof(utx.ut_line));
X
X    if (ut = getutline(&utx)) {
X	ut->ut_type = DEAD_PROCESS;
X#ifndef linux
X	ut->ut_exit.e_termination = 0;
X	ut->ut_exit.e_exit = 0;
X#endif
X	time(&(utx.ut_time));
X	pututline(ut);
X	updwtmp(WTMP_FILE, ut);
X    }
X    endutent();
X}
END_OF_FILE
  if test 528 -ne `wc -c <'utmp_logout.c'`; then
    echo shar: \"'utmp_logout.c'\" unpacked with wrong size!
  fi
  # end of 'utmp_logout.c'
fi
if test -f 'updwtmp.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'updwtmp.c'\"
else
  echo shar: Extracting \"'updwtmp.c'\" \(406 characters\)
  sed "s/^X//" >'updwtmp.c' <<'END_OF_FILE'
X/* Author: Wietse Venema <wietse@wzv.win.tue.nl> */
X
X#include <sys/types.h>
X#include <sys/time.h>
X#include <utmp.h>
X#include <fcntl.h>
X
X/* updwtmp - update System V < 4 wtmp after login or logout */
X
Xupdwtmp(file, ut)
Xchar   *file;
Xstruct utmp *ut;
X{
X    int     fd;
X
X    if ((fd = open(file, O_WRONLY | O_APPEND, 0)) >= 0) {
X	(void) write(fd, (char *) ut, sizeof(struct utmp));
X	(void) close(fd);
X    }
X}
END_OF_FILE
  if test 406 -ne `wc -c <'updwtmp.c'`; then
    echo shar: \"'updwtmp.c'\" unpacked with wrong size!
  fi
  # end of 'updwtmp.c'
fi
if test -f 'utmpx_init.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'utmpx_init.c'\"
else
  echo shar: Extracting \"'utmpx_init.c'\" \(1238 characters\)
  sed "s/^X//" >'utmpx_init.c' <<'END_OF_FILE'
X/* Author: Wietse Venema <wietse@wzv.win.tue.nl> */
X
X#include <sys/types.h>
X#include <sys/time.h>
X#include <utmpx.h>
X#include <string.h>
X#include <syslog.h>
X
X/* utmpx_init - update utmp and wtmp before login */
X
Xutmpx_init(line, user, id)
Xchar   *line;
Xchar   *user;
Xchar   *id;
X{
X    struct utmpx utx;
X
X    memset((char *) &utx, 0, sizeof(utx));
X    strncpy(utx.ut_id, id, sizeof(utx.ut_id));
X    strncpy(utx.ut_user, user, sizeof(utx.ut_user));
X    strncpy(utx.ut_line, line, sizeof(utx.ut_line));
X    utx.ut_pid = getpid();
X    utx.ut_type = LOGIN_PROCESS;
X#ifdef SOLARIS
X    gettimeofday(&(utx.ut_tv), NULL);
X#else
X    gettimeofday(&(utx.ut_tv));
X#endif
X    pututxline(&utx);
X    updwtmpx(WTMPX_FILE, &utx);
X    endutxent();
X}
X
X/* utmpx_ptsid - generate utmp id for pseudo terminal */
X
Xchar   *utmpx_ptsid(line, tag)
Xchar   *line;
Xchar   *tag;
X{
X    int     num;
X    static char buf[5];
X
X    /*
X     * Derive utmp ID from pty slave number and application-specific tag.
X     * SYSV4 uses a different but undocumented algorithm.
X     */
X
X    if (sscanf(line, "%*[^0-9]%d", &num) != 1 || num > 255) {
X	syslog(LOG_ERR, "unparseable pty slave name: %s", line);
X	_exit(1);
X    }
X    sprintf(buf, "%.2s%02x", tag, num);
X    return (buf);
X}
X
END_OF_FILE
  if test 1238 -ne `wc -c <'utmpx_init.c'`; then
    echo shar: \"'utmpx_init.c'\" unpacked with wrong size!
  fi
  # end of 'utmpx_init.c'
fi
if test -f 'utmpx_login.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'utmpx_login.c'\"
else
  echo shar: Extracting \"'utmpx_login.c'\" \(1406 characters\)
  sed "s/^X//" >'utmpx_login.c' <<'END_OF_FILE'
X/* Author: Wietse Venema <wietse@wzv.win.tue.nl> */
X
X#include <sys/types.h>
X#include <sys/time.h>
X#include <utmpx.h>
X#include <string.h>
X
X/* utmpx_login - update utmp and wtmp after login */
X
Xutmpx_login(line, user, host)
Xchar   *line;
Xchar   *user;
Xchar   *host;
X{
X    struct utmpx *ut;
X    pid_t   mypid = getpid();
X    int     ret = (-1);
X
X    /*
X     * SYSV4 ttymon and login use tty port names with the "/dev/" prefix
X     * stripped off. Rlogind and telnetd, on the other hand, make utmpx
X     * entries with device names like /dev/pts/nnn. We therefore cannot use
X     * getutxline(). Return nonzero if no utmp entry was found with our own
X     * process ID for a login or user process.
X     */
X
X    while ((ut = getutxent())) {
X	if (ut->ut_pid == mypid && (ut->ut_type == INIT_PROCESS
X	  || ut->ut_type == LOGIN_PROCESS || ut->ut_type == USER_PROCESS)) {
X	    strncpy(ut->ut_line, line, sizeof(ut->ut_line));
X	    strncpy(ut->ut_user, user, sizeof(ut->ut_user));
X	    strncpy(ut->ut_host, host, sizeof(ut->ut_host));
X	    ut->ut_syslen = strlen(host) + 1;
X	    if (ut->ut_syslen > sizeof(ut->ut_host))
X		ut->ut_syslen = sizeof(ut->ut_host);
X	    ut->ut_type = USER_PROCESS;
X#ifdef SOLARIS
X	    gettimeofday(&(ut->ut_tv), NULL);
X#else
X	    gettimeofday(&(ut->ut_tv));
X#endif
X	    pututxline(ut);
X	    updwtmpx(WTMPX_FILE, ut);
X	    ret = 0;
X	    break;
X	}
X    }
X    endutxent();
X    return (ret);
X}
END_OF_FILE
  if test 1406 -ne `wc -c <'utmpx_login.c'`; then
    echo shar: \"'utmpx_login.c'\" unpacked with wrong size!
  fi
  # end of 'utmpx_login.c'
fi
if test -f 'utmpx_logout.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'utmpx_logout.c'\"
else
  echo shar: Extracting \"'utmpx_logout.c'\" \(608 characters\)
  sed "s/^X//" >'utmpx_logout.c' <<'END_OF_FILE'
X/* Author: Wietse Venema <wietse@wzv.win.tue.nl> */
X
X#include <sys/types.h>
X#include <sys/time.h>
X#include <utmpx.h>
X#include <string.h>
X
X/* utmpx_logout - update utmp and wtmp after logout */
X
Xutmpx_logout(line)
Xchar   *line;
X{
X    struct utmpx utx;
X    struct utmpx *ut;
X
X    strncpy(utx.ut_line, line, sizeof(utx.ut_line));
X
X    if (ut = getutxline(&utx)) {
X	ut->ut_type = DEAD_PROCESS;
X	ut->ut_exit.e_termination = 0;
X	ut->ut_exit.e_exit = 0;
X#ifdef SOLARIS
X	gettimeofday(&(ut->ut_tv), NULL);
X#else
X	gettimeofday(&(ut->ut_tv));
X#endif
X	pututxline(ut);
X	updwtmpx(WTMPX_FILE, ut);
X    }
X    endutxent();
X}
END_OF_FILE
  if test 608 -ne `wc -c <'utmpx_logout.c'`; then
    echo shar: \"'utmpx_logout.c'\" unpacked with wrong size!
  fi
  # end of 'utmpx_logout.c'
fi
if test -f 'login.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'login.c'\"
else
  echo shar: Extracting \"'login.c'\" \(1642 characters\)
  sed "s/^X//" >'login.c' <<'END_OF_FILE'
X/*
X * Copyright (c) 1988 The Regents of the University of California.
X * All rights reserved.
X *
X * Redistribution and use in source and binary forms are permitted
X * provided that the above copyright notice and this paragraph are
X * duplicated in all such forms and that any documentation,
X * advertising materials, and other materials related to such
X * distribution and use acknowledge that the software was developed
X * by the University of California, Berkeley.  The name of the
X * University may not be used to endorse or promote products derived
X * from this software without specific prior written permission.
X * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
X * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
X * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
X */
X
X#if defined(LIBC_SCCS) && !defined(lint)
Xstatic char sccsid[] = "@(#)login.c	5.1 (Berkeley) 9/27/88";
X#endif /* LIBC_SCCS and not lint */
X
X#include <sys/types.h>
X#include <sys/file.h>
X#include <utmp.h>
X#include <stdio.h>
X#include <unistd.h>
X
X#ifdef HAS_PATHS_H
X#include <paths.h>
X#endif /* HAS_PATHS_H */
X
X#ifndef _PATH_UTMP
X#define	_PATH_UTMP	"/etc/utmp"
X#define	_PATH_WTMP	"/usr/adm/wtmp"
X#endif
X
Xvoid
Xlogin(ut)
X	struct utmp *ut;
X{
X	register int fd;
X	int tty;
X
X	tty = ttyslot();
X	if (tty > 0 && (fd = open(_PATH_UTMP, O_WRONLY, 0)) >= 0) {
X		(void)lseek(fd, (OFFSET_T)(tty * sizeof(struct utmp)), L_SET);
X		(void)write(fd, (char *)ut, sizeof(struct utmp));
X		(void)close(fd);
X	}
X	if ((fd = open(_PATH_WTMP, O_WRONLY|O_APPEND, 0)) >= 0) {
X		(void)write(fd, (char *)ut, sizeof(struct utmp));
X		(void)close(fd);
X	}
X}
END_OF_FILE
  if test 1642 -ne `wc -c <'login.c'`; then
    echo shar: \"'login.c'\" unpacked with wrong size!
  fi
  # end of 'login.c'
fi
if test -f 'logout.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'logout.c'\"
else
  echo shar: Extracting \"'logout.c'\" \(1884 characters\)
  sed "s/^X//" >'logout.c' <<'END_OF_FILE'
X/*
X * Copyright (c) 1988 The Regents of the University of California.
X * All rights reserved.
X *
X * Redistribution and use in source and binary forms are permitted
X * provided that the above copyright notice and this paragraph are
X * duplicated in all such forms and that any documentation,
X * advertising materials, and other materials related to such
X * distribution and use acknowledge that the software was developed
X * by the University of California, Berkeley.  The name of the
X * University may not be used to endorse or promote products derived
X * from this software without specific prior written permission.
X * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
X * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
X * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
X */
X
X#if defined(LIBC_SCCS) && !defined(lint)
Xstatic char sccsid[] = "@(#)logout.c	5.2 (Berkeley) 2/17/89";
X#endif /* LIBC_SCCS and not lint */
X
X#include <sys/types.h>
X#include <sys/file.h>
X#include <sys/time.h>
X#include <utmp.h>
X#include <stdio.h>
X
X#ifdef HAS_PATHS_H
X#include <paths.h>
X#endif /* HAS_PATHS_H */
X
X#ifndef _PATH_UTMP
X#define	_PATH_UTMP	"/etc/utmp" /* /var/run/utmp for BSD4.4? */
X#endif
X
X/* 0 on failure, 1 on success */
X
Xlogout(line)
X	register char *line;
X{
X	register FILE *fp;
X	struct utmp ut;
X	int rval;
X	time_t time();
X
X	if (!(fp = fopen(_PATH_UTMP, "r+")))
X		return(0);
X	rval = 0;
X	while (fread((char *)&ut, sizeof(struct utmp), 1, fp) == 1) {
X		if (!ut.ut_name[0] ||
X		    strncmp(ut.ut_line, line, sizeof(ut.ut_line)))
X			continue;
X		bzero(ut.ut_name, sizeof(ut.ut_name));
X		bzero(ut.ut_host, sizeof(ut.ut_host));
X		(void)time(&ut.ut_time);
X		(void)fseek(fp, (long)-sizeof(struct utmp), L_INCR);
X		(void)fwrite((char *)&ut, sizeof(struct utmp), 1, fp);
X		(void)fseek(fp, (long)0, L_INCR);
X		rval = 1;
X	}
X	(void)fclose(fp);
X	return(rval);
X}
END_OF_FILE
  if test 1884 -ne `wc -c <'logout.c'`; then
    echo shar: \"'logout.c'\" unpacked with wrong size!
  fi
  # end of 'logout.c'
fi
if test -f 'logwtmp.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'logwtmp.c'\"
else
  echo shar: Extracting \"'logwtmp.c'\" \(1758 characters\)
  sed "s/^X//" >'logwtmp.c' <<'END_OF_FILE'
X/*
X * Copyright (c) 1988 The Regents of the University of California.
X * All rights reserved.
X *
X * Redistribution and use in source and binary forms are permitted
X * provided that the above copyright notice and this paragraph are
X * duplicated in all such forms and that any documentation,
X * advertising materials, and other materials related to such
X * distribution and use acknowledge that the software was developed
X * by the University of California, Berkeley.  The name of the
X * University may not be used to endorse or promote products derived
X * from this software without specific prior written permission.
X * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
X * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
X * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
X */
X
X#if defined(LIBC_SCCS) && !defined(lint)
Xstatic char sccsid[] = "@(#)logwtmp.c	5.2 (Berkeley) 9/20/88";
X#endif /* LIBC_SCCS and not lint */
X
X#include <sys/types.h>
X#include <sys/file.h>
X#include <sys/time.h>
X#include <sys/stat.h>
X#include <utmp.h>
X
X#ifdef HAS_PATHS_H
X#include <paths.h>
X#endif /* HAS_PATHS_H */
X
X#ifndef _PATH_WTMP
X#define	_PATH_WTMP	"/usr/adm/wtmp"
X#endif
X
Xlogwtmp(line, name, host)
X	char *line, *name, *host;
X{
X	struct utmp ut;
X	struct stat buf;
X	int fd;
X	time_t time();
X	char *strncpy();
X
X	if ((fd = open(_PATH_WTMP, O_WRONLY|O_APPEND, 0)) < 0)
X		return;
X	if (!fstat(fd, &buf)) {
X		(void)strncpy(ut.ut_line, line, sizeof(ut.ut_line));
X		(void)strncpy(ut.ut_name, name, sizeof(ut.ut_name));
X		(void)strncpy(ut.ut_host, host, sizeof(ut.ut_host));
X		(void)time(&ut.ut_time);
X		if (write(fd, (char *)&ut, sizeof(struct utmp)) !=
X		    sizeof(struct utmp))
X			(void)ftruncate(fd, buf.st_size);
X	}
X	(void)close(fd);
X}
END_OF_FILE
  if test 1758 -ne `wc -c <'logwtmp.c'`; then
    echo shar: \"'logwtmp.c'\" unpacked with wrong size!
  fi
  # end of 'logwtmp.c'
fi
if test -f 'login_access.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'login_access.c'\"
else
  echo shar: Extracting \"'login_access.c'\" \(7505 characters\)
  sed "s/^X//" >'login_access.c' <<'END_OF_FILE'
X /*
X  * This module implements a simple but effective form of login access
X  * control based on login names and on host (or domain) names, internet
X  * addresses (or network numbers), or on terminal line names in case of
X  * non-networked logins. Diagnostics are reported through syslog(3).
X  * 
X  * Author: Wietse Venema, Eindhoven University of Technology, The Netherlands.
X  */
X
X#ifndef lint
Xstatic char sccsid[] = "%Z% %M% %I% %E% %U%";
X#endif
X
X#include <sys/types.h>
X#include <stdio.h>
X#include <syslog.h>
X#include <ctype.h>
X#include <grp.h>
X#include <errno.h>
X#include <string.h>
X#include <unistd.h>
X#include <stdlib.h>
X
Xextern struct group *getgrnam();
Xextern int errno;
X
X#if !defined(MAXHOSTNAMELEN) || (MAXHOSTNAMELEN < 64)
X#undef MAXHOSTNAMELEN
X#define MAXHOSTNAMELEN 256
X#endif
X
X /* Path name of the access control file. */
X
X#ifndef	TABLE
X#define TABLE	"/etc/login.access"
X#endif
X
X /* Delimiters for fields and for lists of users, ttys or hosts. */
X
Xstatic char fs[] = ":";			/* field separator */
Xstatic char sep[] = ", \t";		/* list-element separator */
X
X /* Constants to be used in assignments only, not in comparisons... */
X
X#define YES             1
X#define NO              0
X
Xstatic int list_match();
Xstatic int user_match();
Xstatic int from_match();
Xstatic int string_match();
X
X/* login_access - match username/group and host/tty with access control file */
X
Xlogin_access(user, from)
Xchar   *user;
Xchar   *from;
X{
X    FILE   *fp;
X    char    line[BUFSIZ];
X    char   *perm;			/* becomes permission field */
X    char   *users;			/* becomes list of login names */
X    char   *froms;			/* becomes list of terminals or hosts */
X    int     match = NO;
X    int     end;
X    int     lineno = 0;			/* for diagnostics */
X
X    /*
X     * Process the table one line at a time and stop at the first match.
X     * Blank lines and lines that begin with a '#' character are ignored.
X     * Non-comment lines are broken at the ':' character. All fields are
X     * mandatory. The first field should be a "+" or "-" character. A
X     * non-existing table means no access control.
X     */
X
X    if (fp = fopen(TABLE, "r")) {
X	while (!match && fgets(line, sizeof(line), fp)) {
X	    lineno++;
X	    if (line[end = strlen(line) - 1] != '\n') {
X		syslog(LOG_ERR, "%s: line %d: missing newline or line too long",
X		       TABLE, lineno);
X		continue;
X	    }
X	    if (line[0] == '#')
X		continue;			/* comment line */
X	    while (end > 0 && isspace(line[end - 1]))
X		end--;
X	    line[end] = 0;			/* strip trailing whitespace */
X	    if (line[0] == 0)			/* skip blank lines */
X		continue;
X	    if (!(perm = strtok(line, fs))
X		|| !(users = strtok((char *) 0, fs))
X		|| !(froms = strtok((char *) 0, fs))
X		|| strtok((char *) 0, fs)) {
X		syslog(LOG_ERR, "%s: line %d: bad field count", TABLE, lineno);
X		continue;
X	    }
X	    if (perm[0] != '+' && perm[0] != '-') {
X		syslog(LOG_ERR, "%s: line %d: bad first field", TABLE, lineno);
X		continue;
X	    }
X	    match = (list_match(froms, from, from_match)
X		     && list_match(users, user, user_match));
X	}
X	(void) fclose(fp);
X    } else if (errno != ENOENT) {
X	syslog(LOG_ERR, "cannot open %s: %m", TABLE);
X    }
X    return (match == 0 || (line[0] == '+'));
X}
X
X/* list_match - match an item against a list of tokens with exceptions */
X
Xstatic int list_match(list, item, match_fn)
Xchar   *list;
Xchar   *item;
Xint   (*match_fn) ();
X{
X    char   *tok;
X    int     match = NO;
X
X    /*
X     * Process tokens one at a time. We have exhausted all possible matches
X     * when we reach an "EXCEPT" token or the end of the list. If we do find
X     * a match, look for an "EXCEPT" list and recurse to determine whether
X     * the match is affected by any exceptions.
X     */
X
X    for (tok = strtok(list, sep); tok != 0; tok = strtok((char *) 0, sep)) {
X	if (strcasecmp(tok, "EXCEPT") == 0)	/* EXCEPT: give up */
X	    break;
X	if (match = (*match_fn) (tok, item))	/* YES */
X	    break;
X    }
X    /* Process exceptions to matches. */
X
X    if (match != NO) {
X	while ((tok = strtok((char *) 0, sep)) && strcasecmp(tok, "EXCEPT"))
X	     /* VOID */ ;
X	if (tok == 0 || list_match((char *) 0, item, match_fn) == NO)
X	    return (match);
X    }
X    return (NO);
X}
X
X/* myhostname - figure out local machine name */
X
Xstatic char *myhostname()
X{
X    static char name[MAXHOSTNAMELEN + 1] = "";
X
X    if (name[0] == 0) {
X	gethostname(name, sizeof(name));
X	name[MAXHOSTNAMELEN] = 0;
X    }
X    return (name);
X}
X
X/* netgroup_match - match group against machine or user */
X
Xstatic int netgroup_match(group, machine, user)
Xchar   *group;
Xchar   *machine;
Xchar   *user;
X{
X#ifdef NIS
X    static char *mydomain = 0;
X
X    if (mydomain == 0)
X	yp_get_default_domain(&mydomain);
X    return (innetgr(group, machine, user, mydomain));
X#else
X    syslog(LOG_ERR, "NIS netgroup support not configured");
X    return (NO);
X#endif
X}
X
X/* user_match - match a username against one token */
X
Xstatic int user_match(tok, string)
Xchar   *tok;
Xchar   *string;
X{
X    struct group *group;
X    int     i;
X    char   *at;
X
X    /*
X     * If a token has the magic value "ALL" the match always succeeds.
X     * Otherwise, return YES if the token fully matches the username, or if
X     * the token is a group that contains the username.
X     */
X
X    if ((at = strchr(tok + 1, '@')) != 0) {	/* split user@host pattern */
X	*at = 0;
X	return (user_match(tok, string) && from_match(at + 1, myhostname()));
X    } else if (tok[0] == '@') {			/* netgroup */
X	return (netgroup_match(tok + 1, (char *) 0, string));
X    } else if (string_match(tok, string)) {	/* ALL or exact match */
X	return (YES);
X    } else if (group = getgrnam(tok)) {		/* try group membership */
X	for (i = 0; group->gr_mem[i]; i++)
X	    if (strcasecmp(string, group->gr_mem[i]) == 0)
X		return (YES);
X    }
X    return (NO);
X}
X
X/* from_match - match a host or tty against a list of tokens */
X
Xstatic int from_match(tok, string)
Xchar   *tok;
Xchar   *string;
X{
X    int     tok_len;
X    int     str_len;
X
X    /*
X     * If a token has the magic value "ALL" the match always succeeds. Return
X     * YES if the token fully matches the string. If the token is a domain
X     * name, return YES if it matches the last fields of the string. If the
X     * token has the magic value "LOCAL", return YES if the string does not
X     * contain a "." character. If the token is a network number, return YES
X     * if it matches the head of the string.
X     */
X
X    if (tok[0] == '@') {			/* netgroup */
X	return (netgroup_match(tok + 1, string, (char *) 0));
X    } else if (string_match(tok, string)) {	/* ALL or exact match */
X	return (YES);
X    } else if (tok[0] == '.') {			/* domain: match last fields */
X	if ((str_len = strlen(string)) > (tok_len = strlen(tok))
X	    && strcasecmp(tok, string + str_len - tok_len) == 0)
X	    return (YES);
X    } else if (strcasecmp(tok, "LOCAL") == 0) {	/* local: no dots */
X	if (strchr(string, '.') == 0)
X	    return (YES);
X    } else if (tok[(tok_len = strlen(tok)) - 1] == '.'	/* network */
X	       && strncmp(tok, string, tok_len) == 0) {
X	return (YES);
X    }
X    return (NO);
X}
X
X/* string_match - match a string against one token */
X
Xstatic int string_match(tok, string)
Xchar   *tok;
Xchar   *string;
X{
X
X    /*
X     * If the token has the magic value "ALL" the match always succeeds.
X     * Otherwise, return YES if the token fully matches the string.
X     */
X
X    if (strcasecmp(tok, "ALL") == 0) {		/* all: always matches */
X	return (YES);
X    } else if (strcasecmp(tok, string) == 0) {	/* try exact match */
X	return (YES);
X    }
X    return (NO);
X}
END_OF_FILE
  if test 7505 -ne `wc -c <'login_access.c'`; then
    echo shar: \"'login_access.c'\" unpacked with wrong size!
  fi
  # end of 'login_access.c'
fi
if test -f 'sdihook.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'sdihook.c'\"
else
  echo shar: Extracting \"'sdihook.c'\" \(4982 characters\)
  sed "s/^X//" >'sdihook.c' <<'END_OF_FILE'
X#ifdef SECURID
X
X#include <stdio.h>
X#include <errno.h>
X#include <termios.h>
X#include <signal.h>
X
X#include "sdi_athd.h"
X#include "sdi_size.h"
X#include "sdi_type.h"
X#include "sdacmvls.h"
X#include "sdconf.h"
Xunion config_record configure;
X
Xstatic struct termios saved_ttymode;
X
X#ifdef TEST
Xmain(argc, argv)
Xint	argc;
Xchar	*argv[];
X{
X	if (argc != 2) {
X		(void)fprintf(stderr, "usage: %s username\n", argv[0]);
X		exit(1);
X	}
X
X	if (sdiauth(isatty(0), argv[1]))
X		puts("FAILED");
X	else
X		puts("SUCCEEDED");
X	return(0);
X}
X#endif
X
X#define CANCELLED	1
X
Xsdiauth(usepty, user)
Xchar	*user;
X{
X	struct SD_CLIENT sd_dat, *sd;
X	int	ret;
X	char	passcode[LENPRNST];
X	char	*c, reply[3], newpin[LENPRNST], pintype[20], pinsize[20];
X	int	failed = 0;
X	struct termios noecho_ttymode;
X	void    (*oldsig) ();
X	static void	sd_restore_ttymode();
X
X	memset(&sd_dat, 0, sizeof(sd_dat));   /* clear struct */
X	sd = &sd_dat;
X	creadcfg();		/*  access sdconf.rec  */
X	if (sd_init(sd)) {
X#ifdef TEST
X		fprintf(stderr, "Cannot initialize client-server session\n");
X#endif
X		return(1);
X	}
X
X	if (usepty) {
X		printf("Enter PASSCODE for %s: ", user);
X		(void)fflush(stdout);
X
X		/* ECHO OFF */
X		if (tcgetattr(0, &saved_ttymode) == -1) {
X			perror("tcgetattr()");
X			return(1);
X		}
X		if ((oldsig = signal(SIGINT, SIG_IGN)) != SIG_IGN)
X			signal(SIGINT, sd_restore_ttymode);
X		if (tcgetattr(0, &noecho_ttymode) == -1) {
X			perror("tcgetattr()");
X			return(1)
X		}
X		noecho_ttymode.c_lflag &= ~ECHO;
X		if (tcsetattr(0, TCSANOW, &noecho_ttymode) == -1) {
X			perror("tcsetattr()");
X			return(1);
X		}
X	}
X	else {
X		printf("Enter PASSCODE for %s (echo is on):", user);
X		(void)fflush(stdout);
X	}
X
X	if (fgets(passcode, sizeof(passcode), stdin) == NULL)
X		return(1);
X
X	if (usepty) {
X		/* ECHO ON */
X		if (tcsetattr(0, TCSANOW, &saved_ttymode) == -1) {
X			perror("tcsetattr()");
X			return(1);
X		}
X		if (oldsig != SIG_IGN)
X			signal(SIGINT, oldsig);
X		printf("\n");
X	}
X
X#ifdef TEST
X	passcode[strlen(pin) - 1] = '\0';
X#else /* rip() is contained in skey library */
X	rip(passcode);
X#endif
X
X	ret = sd_check(passcode, user, sd);
X	switch (ret) {		/* switch on ret from sd_check  */
X	case ACM_OK:
X		break;
X
X	case ACM_ACCESS_DENIED:
X		puts("Access Denied");
X		failed = 1;
X		break;
X
X	case ACM_NEXT_CODE_REQUIRED:
X		printf("Please enter NEXT cartcode: ");
X		if (fgets(passcode, sizeof(passcode), stdin) == NULL) {
X
X			failed = 1;
X			break;
X		}
X#ifdef TEST
X		passcode[strlen(passcode) - 1] = '\0';
X#else /* rip() is contained in skey library */
X		rip(passcode);
X#endif
X		if (sd_next(passcode, sd) == ACM_OK) {
X			break;
X		}
X		printf("BAD NEXT cartcode, access denied.\n");
X		failed = 1;
X		break;
X
X	case	ACM_NEW_PIN_REQUIRED:
X		printf("New PIN required; do you wish to continue? (y/n) [n]: ");
X		c = fgets(reply, 3, stdin);
X		if (strncmp(reply, "y", 1)) {
X			sd_pin("", CANCELLED, sd);
X			printf("Cancelled new PIN protocol, access denied.\n");
X			failed = 1;
X			break;
X		}
X		if (sd->alphanumeric)
X			strcpy(pintype, "characters");
X		else
X			strcpy(pintype, "digits");
X
X		if (sd->min_pin_len == sd->max_pin_len)
X			sprintf(pinsize, "%d", sd->min_pin_len);
X		else
X			sprintf(pinsize, "%d to %d",
X					sd->min_pin_len, sd->max_pin_len);
X
X		if (sd->user_selectable) {
X			printf("\nEnter your new PIN, containing %s %s,\n",
X							pinsize, pintype);
X			printf("                           or\n\
X<Return> to generate a new PIN and display it on the screen\n");
X			c = fgets(newpin, sd->max_pin_len + 1, stdin);
X			if (!strncmp(newpin, "\n", 1)) {
X				strncpy(newpin, sd->system_pin, LENMAXPIN);
X				printf("\n\nPIN:        %s \n", newpin);
X			}
X			else
X				newpin[strlen(newpin) - 1] = '\0';
X			if (sd_pin(newpin, 0, sd) == ACM_NEW_PIN_ACCEPTED) {
X				printf("New PIN accepted \n");
X				printf(
X"Wait for the code on your card to change, then log in with the new PIN\n");
X				failed = 1; /* be standard */
X				break;
X			}
X			else {
X				printf("New PIN rejected, access denied\n");
X				failed = 1;
X				break;
X			}
X		}
X		else { /*  system-generated PIN  */
X			printf(
X"\nPress <Return> to generate a new PIN and display it on the screen\n");
X			fgets(reply, 3, stdin);
X			if (!strncmp(reply, "\n", 1)) {
X				strncpy(newpin, sd->system_pin, LENMAXPIN);
X				printf("\n\nPIN:        %s \n", newpin);
X			}
X			else {
X				printf("New PIN protocol aborted, access denied\n");
X				failed = 1;
X				break;
X			}
X			if (sd_pin(newpin, 0, sd) == ACM_NEW_PIN_ACCEPTED) {
X				printf("New PIN accepted \n");
X				printf(
X"Wait for the code on your card to change, then log in with the new PIN\n");
X				failed = 1; /* be standard */
X			}
X			else {
X				printf("New PIN rejected, access denied.\n");
X				failed = 1;
X				break;
X			}
X		}
X		break;
X
X	default:
X		printf("sdi panics, unknown return code %d \n", ret);
X		failed = 1;
X		break;
X	}
X	return(failed);
X}
X
X/* restore - restore terminal modes when user aborts command */
Xvoid sd_restore_ttymode()
X{
X	if (tcsetattr(0, TCSANOW, &saved_ttymode) == -1) {
X		perror("tcsetattr()");
X		return(1);
X	}
X	exit(1);
X}
X
X#endif /* SECURID */
END_OF_FILE
  if test 4982 -ne `wc -c <'sdihook.c'`; then
    echo shar: \"'sdihook.c'\" unpacked with wrong size!
  fi
  # end of 'sdihook.c'
fi
if test -f 'crc32.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'crc32.c'\"
else
  echo shar: Extracting \"'crc32.c'\" \(1385 characters\)
  sed "s/^X//" >'crc32.c' <<'END_OF_FILE'
X/*  CRC-32 version 1.04 by Craig Bruce, 05-Dec-1994
X**
X**  Based on "File Verification Using CRC" by Mark R. Nelson in Dr. Dobb's
X**  Journal, May 1992, pp. 64-67.  This program DOES generate the same CRC
X**  values as ZMODEM and PKZIP
X**
X**  v1.00: original release.
X**  v1.01: fixed printf formats.
X**  v1.02: fixed something else.
X**  v1.03: replaced CRC constant table by generator function.
X**  v1.04: reformatted code, made ANSI C.  05-Dec-1994.
X**
X**    modified by David Vincenzetti <vince@dsi.unimi.it> for STEL 951228
X*/
X
Xstatic unsigned long crcTable[256];
X
X#ifdef TEST
Xunsigned long	crc32val;
X#else
Xextern unsigned long	crc32val;
X#endif
X
Xvoid
XUpdateCRC(buf, len)
Xregister char	*buf;
Xregister int	len;
X{
X	register	i;
X	int		c;
X
X	for (i = 0; i < len; i++)  {
X		c = buf[i];
X		crc32val = ((crc32val >> 8) & 0x00FFFFFF) ^
X			crcTable[ (crc32val ^ c) & 0xFF ];
X	}
X}
X
Xvoid
Xcrcgen()
X{
X    unsigned long	crc, poly;
X    register		i, j;
X
X	poly = 0xEDB88320L;
X
X	for (i = 0; i < 256; i++) {
X		crc = i;
X
X		for (j = 8; j > 0; j--) {
X			if (crc & 1)
X				crc = (crc >> 1) ^ poly;
X			else
X				crc >>= 1;
X		}
X		crcTable[i] = crc;
X	}
X
X	crc32val = 0L;
X}
X
X#ifdef TEST
Xmain()
X{
X	char	buf[128];
X	int	len;
X
X	crcgen();
X	while ((len = read(0, buf, sizeof(buf))) > 0)
X		UpdateCRC(buf, len);
X	
X	if (len == -1) {
X		perror("read()");
X		exit(1);
X	}
X
X	printf("CRC32 = %x\n", crc32val);
X	return(0);
X}
X#endif
END_OF_FILE
  if test 1385 -ne `wc -c <'crc32.c'`; then
    echo shar: \"'crc32.c'\" unpacked with wrong size!
  fi
  # end of 'crc32.c'
fi
if test -f 'truerand.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'truerand.c'\"
else
  echo shar: Extracting \"'truerand.c'\" \(2098 characters\)
  sed "s/^X//" >'truerand.c' <<'END_OF_FILE'
X/*
X *	Physically random numbers (very nearly uniform)
X *	D. P. Mitchell 
X * 		hacked by mab
X */
X/*
X * The author of this software is Don Mitchell.
X *              Copyright (c) 1995 by AT&T.
X * Permission to use, copy, and modify this software without fee
X * is hereby granted, provided that this entire notice is included in
X * all copies of any software which is or includes a copy or
X * modification of this software and in all copies of the supporting
X * documentation for such software.
X *
X * This software is subject to United States export controls.
X *
X * THIS SOFTWARE IS BEING PROVIDED "AS IS", WITHOUT ANY EXPRESS OR IMPLIED
X * WARRANTY.  IN PARTICULAR, NEITHER THE AUTHORS NOR AT&T MAKE ANY
X * REPRESENTATION OR WARRANTY OF ANY KIND CONCERNING THE MERCHANTABILITY
X * OF THIS SOFTWARE OR ITS FITNESS FOR ANY PARTICULAR PURPOSE.
X */
X
X#include <stdio.h>
X#include <sys/types.h>
X#include <sys/time.h>
X#include <signal.h>
X#include <setjmp.h>
X#include <math.h>
X
Xstatic jmp_buf env;
Xstatic unsigned count;
Xstatic unsigned ocount;
Xstatic unsigned buffer;
X
Xstatic
Xtick()
X{
X	struct itimerval it, oit;
X
X	timerclear(&it.it_interval);
X	it.it_value.tv_sec = 0;
X	it.it_value.tv_usec = 16665;
X	if (setitimer(ITIMER_REAL, &it, &oit) < 0)
X		perror("tick");
X}
X
Xstatic void
Xinterrupt()
X{
X	if (count)
X		longjmp(env, 1);
X	(void) signal(SIGALRM, interrupt);
X	tick();
X}
X
Xstatic unsigned
Xroulette()
X{
X	if (setjmp(env)) {
X		count ^= (count>>3) ^ (count>>6) ^ ocount;
X		count &= 0x7;
X		ocount=count;
X		buffer = (buffer<<3) ^ count;
X		return buffer;
X	}
X	(void) signal(SIGALRM, interrupt);
X
X	count = 0;
X	tick();
X	for (;;)
X		count++;	/* about 1 MHz on VAX 11/780 */
X}
X
Xunsigned
Xtruerand()
X{
X	count=0;
X	(void) roulette();
X	(void) roulette();
X	(void) roulette();
X	(void) roulette();
X	(void) roulette();
X	(void) roulette();
X	(void) roulette();
X	(void) roulette();
X	(void) roulette();
X	(void) roulette();
X	return roulette();
X}
X
Xint
Xn_truerand(n)
Xint n;
X{
X	int slop, v;
X
X	slop = 0x7FFFFFFF % n;
X	do {
X		v = truerand() >> 1;
X	} while (v <= slop);
X	return v % n;
X}
X
X#ifdef TEST
Xmain()
X{
X	printf("%u\n", truerand());
X}
X#endif
END_OF_FILE
  if test 2098 -ne `wc -c <'truerand.c'`; then
    echo shar: \"'truerand.c'\" unpacked with wrong size!
  fi
  # end of 'truerand.c'
fi
if test -f 'rc4.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'rc4.c'\"
else
  echo shar: Extracting \"'rc4.c'\" \(1886 characters\)
  sed "s/^X//" >'rc4.c' <<'END_OF_FILE'
X/*
X
XAlleged RC4 (based on the Usenet posting in Spring-95)
X
X*/
X
X#include <stdio.h>
X#include <assert.h>
X#include "rc4.h"
X
Xvoid rc4_init(RC4Context *ctx, const unsigned char *key, unsigned int key_len)
X{
X  unsigned int t, u;
X  unsigned int keyindex;
X  unsigned int stateindex;
X  unsigned char* state;
X  unsigned int counter;
X
X  assert(key_len > 0);
X
X  state = &ctx->state[0];
X  ctx->x = 0;
X  ctx->y = 0;
X  for (counter = 0; counter < 256; counter++)
X    state[counter] = counter;
X  keyindex = 0;
X  stateindex = 0;
X  for (counter = 0; counter < 256; counter++)
X    {
X      t = state[counter];
X      stateindex = (stateindex + key[keyindex] + t) & 0xff;
X      u = state[stateindex];
X      state[stateindex] = t;
X      state[counter] = u;
X      if (++keyindex >= key_len)
X	keyindex = 0;
X    }
X}
X
Xinline unsigned int rc4_byte(RC4Context *ctx)
X{
X  unsigned int x;
X  unsigned int y;
X  unsigned int sx, sy;
X  unsigned char *state;
X
X  state = ctx->state;
X  x = (ctx->x + 1) & 0xff;
X  sx = state[x];
X  y = (sx + ctx->y) & 0xff;
X  sy = state[y];
X  ctx->x = x;
X  ctx->y = y;
X  state[y] = sx;
X  state[x] = sy;
X  return state[(sx + sy) & 0xff];
X}
X
Xvoid rc4_encrypt(RC4Context *ctx, unsigned char *dest, 
X		 const unsigned char *src, unsigned int len)
X{
X  unsigned int i;
X  for (i = 0; i < len; i++)
X    dest[i] = src[i] ^ rc4_byte(ctx);
X}
X
Xvoid rc4_decrypt(RC4Context *ctx, unsigned char *dest, 
X		 const unsigned char *src, unsigned int len)
X{
X  rc4_encrypt(ctx, dest, src, len);
X}
X
X#ifdef TEST
Xmain(argc, argv)
Xint	argc;
Xchar	*argv[];
X{
X	RC4Context	rc4;
X	char		buf[1024];
X	register	i, len;
X
X	rc4_init(&rc4, argv[1], strlen(argv[1]));
X
X	while ((len = read(0, buf, sizeof(buf))) > 0)  {
X		for (i = 0; i < len; i++)
X			buf[i] ^= rc4_byte(&rc4);
X		if (write(1, buf, len) != len) {
X			perror("write()");
X			exit(1);
X		}
X	}
X	if (len < 0) {
X		perror("read()");
X		exit(1);
X	}
X	exit(0);
X}
X#endif /* TEST */
X
END_OF_FILE
  if test 1886 -ne `wc -c <'rc4.c'`; then
    echo shar: \"'rc4.c'\" unpacked with wrong size!
  fi
  # end of 'rc4.c'
fi
if test -f 'defs.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'defs.h'\"
else
  echo shar: Extracting \"'defs.h'\" \(4039 characters\)
  sed "s/^X//" >'defs.h' <<'END_OF_FILE'
X/**/
X#define PORTNUM			10005
X/**/
X
X#define MAXHNAMELEN	128	
X#define MAXUSERNAMELEN	32
X#define MAXPWDLEN	10	/* max password length for unix auth */
X
X/* Connection is closed if it takes more that logintimeout seconds
Xfor the user to be authenticated */
X#ifdef DEBUG
X#define LOGINTIMEOUT	99999999
X#else
X#define LOGINTIMEOUT	(60 * 3) /* seconds */
X#endif
X
X/* User gets disconnected when idle timeout expires.
XThis feature can be overridden by means of server's -t option.
X*/
X#define IDLETIMEOUT	0   /* zero = no timeout */
X
X/* circular skey buffer size */
X#define SKEYBUFSIZE	1024
X
X/* Bellcore S/Key prompt.
XThe following should catch most of commonly used skey application
Xskey prompts.  fixed to support seeds composed by any character
X*/
X#define SKEYPATTERN	\
X"[\n\r]*[[]*[Ss][/]?[Kk]ey[ \t]+[0-9]+[ \t]+[^ \t\n\r]+[]]*[\n\r]*"
X
X/* general makeio buffer */
X#define MAKEIOBUF	4096
X/* max # of packets inside MAKEIOBUF */
X#define MAXCOMBONUM     (MAKEIOBUF / 10)
X
X#define STELCLIENT	"stel"
X#define STELSERVER	"steld"
X#define VERSION		5
X
X/* initial ack (from client to server) */
X#define	FLG_NO_ENCRYPTION	0x01
X#define FLG_USE_IDEA		0x02
X#define FLG_USE_SINGLE		0x04
X#define FLG_SMALL_MODULUS	0x08
X#define FLG_LARGE_MODULUS	0x10
X#define FLG_BE_VERBOSE		0x20
X#define FLG_DEBUG		0x40
X#define FLG_NO_ESCAPE		0x80
X#define FLG_ACTIVE_ATTACKS	0x100
X#define FLG_USE_RC4		0x200
X
X/* second ack (from server to client) */
X#define MSG_OKAY_DATA			0x01
X#define MSG_CORRUPTED_DATA		0x02
X#define MSG_LOGIN_AUTH_REQUIRED		0x04
X#define MSG_MUST_AUTH			0x08
X#define MSG_SYSTEM_AUTH_REQUIRED	0x10
X#define MSG_WRONG_VERSION		0x20
X
X#define STEL_SECRET_MAX_LEN	128
X#define STEL_SECRET_NAME	".stelsecret"
X#define ETC_STEL_SECRET_NAME	"/etc/stelsecret"
X
X/* sides */
X#define CLIENT_SIDE		0
X#define SERVER_SIDE		1
X
X#define NOTIMEOUT		-1
X#define USRAUTH			"userauthenticated"
X
X/****************************************************************/
X/* first encrypted packet which is xmited from client to server */
X/****************************************************************/
Xtypedef struct {
X	char	random[16]; /* stream randomizer (IV is first 8 bytes) */
X	char	username[MAXUSERNAMELEN];
X	/* some environment variables */
X	char	command[1024];
X	char	TERM[8], LINES[8], COLUMNS[8], DISPLAY[32], WINDOWID[32];
X	/* char	PATH[512]; */
X	int	rows, cols;
X	int	mode;
X	int	version;
X	unsigned char	digest[16];
X} cpacket;
X
X/******************************************************/
X/* first packet which is xmited from server to client */
X/******************************************************/
Xtypedef struct {
X	char	random[16]; /* stream randomizer (IV is first 8 bytes) */
X	int	sreply;
X	unsigned char	digest[16];
X} spacket;
X
X/* used to protect against active attacks */
Xtypedef struct {
X	unsigned long   seq;
X#ifdef COMBOFLAG
X	int		flag;
X#endif /* COMBOFLAG */
X	long            crc32;
X	int             len;
X	char		*data;
X} combopacket;
X
X#ifdef COMBOFLAG
X#define COMBO_FLG_DATA	0x01
X#define COMBO_FLG_PUT	0x02
X#define COMBO_FLG_GET	0x04
X#define XFERTOKEN	"xferrequested" /* some random phrase */
X
X#define WHAT_ACK	"serverisready" /* S -> C, 1 */
X
Xtypedef struct {			/* C -> S, 1 */
X	int		cmd;
X	char		filename[256];
X	unsigned long	filesize;
X	unsigned char	checksum[16];
X} combocmd;
X
Xtypedef struct {			/* S -> C, 2 */
X	int		answer;
X	unsigned long	filesize;
X	char		message[128];
X	unsigned char	checksum[16];
X} comboanswer;
X#endif /* COMBOFLAG */
X
X/* mode */
X#define FLG_DONTUSE_PTY		0x01
X
X/* ciphers */
X#define		DES_CIPHER		0
X#define		TRIPLEDES_CIPHER	1
X#define		IDEA_CIPHER		2
X#define		RC4_CIPHER		3
X
X/* free bsd needs this; _H* */
X#ifndef SIGCLD
X#ifdef SIGCHLD
X#define SIGCLD SIGCHLD
X#endif
X#endif
X
X#ifdef DESCORE
X#include "desCore.h"
X
Xtypedef union {
X	unsigned char	x;
X} des_key_schedule[128];
X
Xtypedef union {
X	unsigned char	x;
X} des_cblock[8];
X#define DES_ENCRYPT	1
X#define DES_DECRYPT	0
X#define ENCRYPT		DES_ENCRYPT
X#define DECRYPT		DES_DECRYPT
X#else
X#include "des.h"
X#endif
X
X#ifdef hpux
X#define seteuid(x)	setresuid(-1, x, x)
X#define setegid(x)	setresgid(-1, x, x)
X#endif
END_OF_FILE
  if test 4039 -ne `wc -c <'defs.h'`; then
    echo shar: \"'defs.h'\" unpacked with wrong size!
  fi
  # end of 'defs.h'
fi
if test -f 'idea.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'idea.h'\"
else
  echo shar: Extracting \"'idea.h'\" \(851 characters\)
  sed "s/^X//" >'idea.h' <<'END_OF_FILE'
X/*	idea.h - header file for idea.c
X*/
X
X#include "usuals.h"  /* typedefs for byte, word16, boolean, etc. */
X
X#define ROUNDS  8               /* Don't change this value, should be 8 */
X#define KEYLEN  (6*ROUNDS+4)    /* length of key schedule */
Xtypedef word16 IDEAkey[KEYLEN];
X
X#define IDEAKEYSIZE 16
X#define IDEABLOCKSIZE 8
X
X
Xvoid initcfb_idea(word16 iv0[4], byte key[16], boolean decryp);
Xvoid ideacfb(byteptr buf, int count);
Xvoid close_idea(void);
X
Xvoid init_idearand(byte key[16], byte seed[8], word32 tstamp);
Xbyte idearand(void);
Xvoid close_idearand(void);
X
X
X/* prototypes for passwd.c */
X
X/* GetHashedPassPhrase - get pass phrase from user, hashes it to an IDEA key. */
Xint GetHashedPassPhrase(char *hash, boolean noecho);
X
X/* hashpass - Hash pass phrase down to 128 bits (16 bytes). */
Xvoid hashpass (char *keystring, int keylen, byte *hash);
END_OF_FILE
  if test 851 -ne `wc -c <'idea.h'`; then
    echo shar: \"'idea.h'\" unpacked with wrong size!
  fi
  # end of 'idea.h'
fi
if test -f 'md5.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'md5.h'\"
else
  echo shar: Extracting \"'md5.h'\" \(1350 characters\)
  sed "s/^X//" >'md5.h' <<'END_OF_FILE'
X/* MD5.H - header file for MD5C.C
X */
X
X/* Copyright (C) 1991-2, RSA Data Security, Inc. Created 1991. All
Xrights reserved.
X
XLicense to copy and use this software is granted provided that it
Xis identified as the "RSA Data Security, Inc. MD5 Message-Digest
XAlgorithm" in all material mentioning or referencing this software
Xor this function.
X
XLicense is also granted to make and use derivative works provided
Xthat such works are identified as "derived from the RSA Data
XSecurity, Inc. MD5 Message-Digest Algorithm" in all material
Xmentioning or referencing the derived work.
X
XRSA Data Security, Inc. makes no representations concerning either
Xthe merchantability of this software or the suitability of this
Xsoftware for any particular purpose. It is provided "as is"
Xwithout express or implied warranty of any kind.
X
XThese notices must be retained in any copies of any part of this
Xdocumentation and/or software.
X */
X
X/* MD5 context. */
Xtypedef struct {
X  UINT4 state[4];                                   /* state (ABCD) */
X  UINT4 count[2];        /* number of bits, modulo 2^64 (lsb first) */
X  unsigned char buffer[64];                         /* input buffer */
X} MD5_CTX;
X
Xvoid MD5Init PROTO_LIST ((MD5_CTX *));
Xvoid MD5Update PROTO_LIST
X  ((MD5_CTX *, unsigned char *, unsigned int));
Xvoid MD5Final PROTO_LIST ((unsigned char [16], MD5_CTX *));
END_OF_FILE
  if test 1350 -ne `wc -c <'md5.h'`; then
    echo shar: \"'md5.h'\" unpacked with wrong size!
  fi
  # end of 'md5.h'
fi
if test -f 'global.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'global.h'\"
else
  echo shar: Extracting \"'global.h'\" \(781 characters\)
  sed "s/^X//" >'global.h' <<'END_OF_FILE'
X/* GLOBAL.H - RSAREF types and constants
X */
X
X/* PROTOTYPES should be set to one if and only if the compiler supports
X  function argument prototyping.
XThe following makes PROTOTYPES default to 0 if it has not already
X  been defined with C compiler flags.
X */
X#ifndef PROTOTYPES
X#define PROTOTYPES 0
X#endif
X
X/* POINTER defines a generic pointer type */
Xtypedef unsigned char *POINTER;
X
X/* UINT2 defines a two byte word */
Xtypedef unsigned short int UINT2;
X
X/* UINT4 defines a four byte word */
Xtypedef unsigned long int UINT4;
X
X/* PROTO_LIST is defined depending on how PROTOTYPES is defined above.
XIf using PROTOTYPES, then PROTO_LIST returns the list, otherwise it
X  returns an empty list.
X */
X#if PROTOTYPES
X#define PROTO_LIST(list) list
X#else
X#define PROTO_LIST(list) ()
X#endif
END_OF_FILE
  if test 781 -ne `wc -c <'global.h'`; then
    echo shar: \"'global.h'\" unpacked with wrong size!
  fi
  # end of 'global.h'
fi
if test -f 'sys_defs.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'sys_defs.h'\"
else
  echo shar: Extracting \"'sys_defs.h'\" \(2602 characters\)
  sed "s/^X//" >'sys_defs.h' <<'END_OF_FILE'
X /*
X  * Cope with different major UNIX streams, and what the vendors did to them.
X  * 
X  * Author:Wietse Venema < wietse @ wzv.win.tue.nl >
X  * 
X  * Beginning of generic (vendor-independent) features.
X  */
X
X#ifdef HAS_UTMPX
X#include <utmpx.h>
X#else /* HAS_UTMPX */
X#include <utmp.h>
X#endif /* HAS_UTMPX */
X#ifndef UT_NAMESIZE
X#define UT_NAMESIZE     sizeof(((struct UTMP_STRUCT *)0)->ut_name)
X#endif /* UT_NAMESIZE */
X
X#if defined(SYSV2) || defined(SYSV3)
X#define NO_LASTLOG_H			/* no <lastlog.h> file */
X#define _PATH_LOGIN "/bin/login"
X#endif
X
X#if defined(SYSV2) || defined(SYSV3) || defined(SYSV4)
X#define SYSV_UTMP			/* insist on existing utmp entry */
X#define SYSV_ENV			/* TERM=value login arg, no ucb path */
X#define NO_TTYENT			/* no <ttyent.h> stuff */
X#define NO_MOTD				/* leave motd to the shell */
X#define USE_GETCWD			/* getcwd() instead of getwd() */
X#define SYSV_LS				/* "ls -l" lists groups */
X#endif
X
X#if defined(SYSV3) || defined(SYSV4)
X#define SYSV_SHADOW			/* shadow pwds, password expiry */
X#define SYSV_LOGINDEFS			/* has /etc/default/login */
X#endif
X
X#ifdef SYSV4
X#define HAS_UTMPX			/* utmp+utmpx, wtmp+wtmpx files */
X#define STREAM_PTY			/* ptys are streams devices */
X#define USE_SYS_MNTTAB_H		/* <sys/mnttab.h> */
X#endif
X
X#ifndef SOLARIS /* canno handle this!? */
X#if (defined(BSD) && (BSD >= 199306))    /* 4.4BSD-based */
X#define HAS_PATHS_H                   /* <paths.h> */
X#define HAS_SETLOGIN          /* setlogin() */
X#define SIGCLD  SIGCHLD
X#endif
X#endif /* SOLARIS */
X 
X
X /*
X  * End of generic (vendor-independent) features.
X  * 
X  * Beginning of vendor-specific exceptions.
X  */
X
X#ifdef hpux
X#define SYSV_UTMP			/* login requires utmp entry */
X#define NO_TTYENT			/* no <ttyent.h> stuff */
X#define NO_MOTD				/* leave motd to the shell */
X#define NO_LASTLOG_H			/* no <lastlog.h> file */
X#define USE_GETCWD			/* getcwd() instead of getwd() */
X#define USE_SETRESXID			/* setresuid(), setresgid() */
X/*#define USE_PTYOPEN */		/* ptyopen(), ptyexecvp() */
X#define SYSV_LS				/* "ls -l" lists groups */
X#define _PATH_LOGIN "/bin/login"
X#endif
X
X#ifdef IRIX
X#define	SYSV_UTMP			/* login requires utmp entry */
X#endif
X
X#ifdef linux
X#define	SYSV_UTMP			/* login requires utmp entry */
X#endif
X
X /*
X  * End of vendor-specific exceptions.
X  */
X
X#ifdef HAS_UTMPX
X#define UTMP_STRUCT	utmpx
X#define UTMP_INIT	utmpx_init
X#define UTMP_LOGIN	utmpx_login
X#define UTMP_LOGOUT	utmpx_logout
X#define MAKE_UTMP_ID	utmpx_ptsid
X#else
X#define UTMP_STRUCT	utmp
X#define UTMP_INIT	utmp_init
X#define UTMP_LOGIN	utmp_login
X#define UTMP_LOGOUT	utmp_logout
X#define MAKE_UTMP_ID	utmp_ptsid
X#endif
END_OF_FILE
  if test 2602 -ne `wc -c <'sys_defs.h'`; then
    echo shar: \"'sys_defs.h'\" unpacked with wrong size!
  fi
  # end of 'sys_defs.h'
fi
if test -f 'usuals.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'usuals.h'\"
else
  echo shar: Extracting \"'usuals.h'\" \(1262 characters\)
  sed "s/^X//" >'usuals.h' <<'END_OF_FILE'
X/* usuals.h - The usual typedefs, etc.
X*/
X#ifndef USUALS /* Assures no redefinitions of usual types...*/
X#define USUALS
X
Xtypedef unsigned char boolean;	/* values are TRUE or FALSE */
X
X#ifndef BYTEDEFINED
Xtypedef unsigned char byte;	/* values are 0-255 */
X#define BYTEDEFINED
X#endif
X
Xtypedef byte *byteptr;	/* pointer to byte */
Xtypedef char *string;	/* pointer to ASCII character string */
Xtypedef unsigned short word16;	/* values are 0-65535 */
X#ifdef __alpha
Xtypedef unsigned int word32;	/* values are 0-4294967295 */
X#else
Xtypedef unsigned long word32;	/* values are 0-4294967295 */
X#endif
X
X#ifndef TRUE
X#define FALSE 0
X#define TRUE (!FALSE)
X#endif	/* if TRUE not already defined */
X
X#ifndef min	/* if min macro not already defined */
X#define min(a,b) (((a)<(b)) ? (a) : (b) )
X#define max(a,b) (((a)>(b)) ? (a) : (b) )
X#endif	/* if min macro not already defined */
X
X/* void for use in pointers */
X#ifndef NO_VOID_STAR
X#define	VOID	void
X#else
X#define	VOID	char
X#endif
X
X	/* Zero-fill the byte buffer. */
X#define fill0(buffer,count)	memset( buffer, 0, count )
X
X	/* This macro is for burning sensitive data.  Many of the
X	   file I/O routines use it for zapping buffers */
X#define burn(x) fill0((VOID *)&(x),sizeof(x))
X
X#endif	/* if USUALS not already defined */
END_OF_FILE
  if test 1262 -ne `wc -c <'usuals.h'`; then
    echo shar: \"'usuals.h'\" unpacked with wrong size!
  fi
  # end of 'usuals.h'
fi
if test -f 'rc4.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'rc4.h'\"
else
  echo shar: Extracting \"'rc4.h'\" \(724 characters\)
  sed "s/^X//" >'rc4.h' <<'END_OF_FILE'
X/*
X
XAlleged RC4 (based on the Usenet posting in Spring-95)
X
X*/
X
X#ifndef RC4_H
X#define RC4_H
X
Xtypedef struct
X{
X   unsigned int x;
X   unsigned int y;
X   unsigned char state[256];
X} RC4Context;
X
X/* Initializes the context and sets the key. */
Xvoid rc4_init(RC4Context *ctx, const unsigned char *key, unsigned int keylen);
X
X/* Returns the next pseudo-random byte from the RC4 (pseudo-random generator)
X   stream. */
Xunsigned int rc4_byte(RC4Context *ctx);
X
X/* Encrypts data. */
Xvoid rc4_encrypt(RC4Context *ctx, unsigned char *dest, 
X		 const unsigned char *src, unsigned int len);
X
X/* Decrypts data. */
Xvoid rc4_decrypt(RC4Context *ctx, unsigned char *dest, 
X		 const unsigned char *src, unsigned int len);
X
X#endif /* RC4_H */
END_OF_FILE
  if test 724 -ne `wc -c <'rc4.h'`; then
    echo shar: \"'rc4.h'\" unpacked with wrong size!
  fi
  # end of 'rc4.h'
fi
if test -f 'Makefile' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Makefile'\"
else
  echo shar: Extracting \"'Makefile'\" \(5515 characters\)
  sed "s/^X//" >'Makefile' <<'END_OF_FILE'
X#
X# $Author: vince $
X# $Header: /res/usr/vince/src/stel/RCS/Makefile,v 1.75 1995/12/26 19:22:18 vince Exp vince $
X# $Date: 1995/12/26 19:22:18 $
X# $Revision: 1.75 $
X# $Locker: vince $
X#
X
X# AUTHENTICATION
X# -DSECURID and $(SDIDIR)=/usr/ace/system to add smart card
X#  support code (unbundled)
X# if user is securid registered securid auth is required
X# if user is skey registered skey auth is required
X# also, skey auth is required if /etc/skey.access says so
X# last-resort authentication are unix passwords
X
X# MORE CHECKS
X# /etc/login.access is checked when auth succeeded
X
X# -DGENERICLOGIN if you want to take advantage of STEL's internal login
X# routine. If GENERICLOGIN is not defined, then /bin/login -f is run
X# upon successful authentication. -DGENERICLOGIN is useful when system
X# login is broken (i.e., it does not support the -f, -l or -p options).
X
X# -DDESCORE if you want to take advantage of desCore DES library.
X# Dana L. How DesCore's is a major speedup in respect to Eric Young's
X# Libdes; speedups greatly depend on the architecture STEL runs on;
X# they sometimes vary from 20% to 80% and over.
X
X# jrhett@Navigist.Com
X# -DSOCKS if you want to SOCKSify the stel binary.
X# SOCKSLIB must be defined to where your SOCKS library is.
X# Only SOCKS version 4 is supported - v5 shouldn't need to be compiled in.
X
X# You should define OFFSET_T to be the right type.
X# OFFSET_T=long for most architectures
X# OFFSET_T=off_t for POSIX systems
X
XCC	= gcc
XDEFS	=  -DGENERICLOGIN -DCOMBOFLAG -DDESCORE  $(SYSDEFS) ### -DSECURID
X#DEFS	= -DGENERICLOGIN -DCOMBOFLAG $(SYSDEFS) ### -DSECURID
XINCDIRS	= -I$(DESDIR) -I$(DESCOREDIR) -I$(SKEYDIR) -I$(GMPDIR) $(OTHERINCDIR) ### -I$(SDIDIR) 
X
XDESDIR		= ../libdes
XDESCOREDIR	= ../descore
X
XSKEYDIR	= ../skey
XGMPDIR	= ../gmp-1.3.2
XGNUREGEX = ../regex-0.12
X
X# SOCKS support
X#SOCKSLIB	= /usr/local/socks/lib/libsocks.a
X
X
X# securid support
X###SDIDIR	= /usr/ace/sun
X###SDIDIR	= /usr/ace/hp
X###SDILIB	= $(SDIDIR)/sdiclient.a
X###SDILIB	= $(SDIDIR)/sdiclient.a
X
XCFLAGS	=  -g -O2 -fwritable-strings $(DEFS) $(INCDIRS)
X
XLDFLAGS	= -g -O2 -L$(DESDIR) -L$(DESCOREDIR) \
X	-L$(GMPDIR) -L$(SKEYDIR) $(OTHERLIBDIR) -lskey -ldes \
X	-lgmp $(SYSLIBS) -lm
X
XS5R3OBJ = utmp_init.o utmp_login.o utmp_logout.o updwtmp.o
XS5R4OBJ = utmpx_init.o utmpx_login.o utmpx_logout.o
XBSD4OBJ = login.o logout.o logwtmp.o
X
X
XMASTER	= steld.o sub.o makeio.o md5c.o idea.o login_access.o sdihook.o \
X	vers.o crc32.o truerand.o rc4.o  # lip.o
XSLAVE	= stel.o sub.o makeio.o md5c.o idea.o \
X	vers.o crc32.o truerand.o rc4.o  # lip.o
X
XALLOBJ	= $(MASTER) $(SLAVE) $(BSD4OBJ) $(S5R4OBJ) $(S5R3OBJ)
X
XSRC	= steld.c stel.c sub.c makeio.c md5c.c idea.c  \
X	  utmp_init.c utmp_login.c utmp_logout.c updwtmp.c \
X	  utmpx_init.c utmpx_login.c utmpx_logout.c \
X	  login.c logout.c logwtmp.c login_access.c sdihook.c \
X	  crc32.c truerand.c rc4.c  # lip.c
X
XETC	= Makefile securid.conf skey.access skey.access.5 newvers.sh
X
XHDR	= defs.h idea.h md5.h global.h sys_defs.h usuals.h rc4.h # lip.h
X
Xwhat:
X	@echo Please choose one of the following:
X	@echo "hpux, sunos4, solaris, irix, linux, ultrix, freebsd"
X
Xhpux	: 
X	make all ALLMASTER="$(S5R3OBJ) $(MASTER)" \
X	ALLSLAVE="$(SLAVE)" \
X	SYSDEFS="-DIDEA32 -DHIGHFIRST -DLOGPRI=LOG_INFO -DOFFSET_T=long \
X	-DDESCORE" \
X	SYSLIBS="-ldescore"
X
Xsunos4:
X	make all ALLMASTER="$(BSD4OBJ) $(MASTER) $(GNUREGEX)/regex.o" \
X	ALLSLAVE="$(SLAVE) $(GNUREGEX)/regex.o" \
X	OTHERINCDIR="-I$(GNUREGEX)" \
X	SYSDEFS="-DSUNOS4 -DIDEA32 -DHIGHFIRST -DLOGPRI=LOG_NOTICE \
X	-DOFFSET_T=off_t -DDESCORE" \
X	SYSLIBS="-ldescore"
X
Xlinux:
X	make all ALLMASTER="$(S5R3OBJ) $(MASTER)" \
X	ALLSLAVE="$(SLAVE)" \
X	SYSDEFS="-DSMALL_CACHE -DLOGPRI=LOG_INFO -DOFFSET_T=off_t \
X	-DNO_IP_PROTO -DDESCORE" \
X	SYSLIBS="-ldescore"
X
X
Xirix	:
X	make all ALLMASTER="$(S5R4OBJ) $(MASTER) $(GNUREGEX)/regex.o" \
X	ALLSLAVE="$(SLAVE) $(GNUREGEX)/regex.o" \
X	OTHERINCDIR="-I$(GNUREGEX)" \
X	SYSDEFS="-DIRIX -DIDEA32 -DHIGHFIRST -DLOGPRI=LOG_INFO \
X	-DOFFSET_T=off_t -DHAS_UTMPX -DDESCORE" \
X	SYSLIBS="-ldescore"
X
Xsolaris:
X	make all ALLMASTER="$(S5R4OBJ) $(MASTER)" \
X	ALLSLAVE="$(SLAVE)" \
X	SYSDEFS="-DSOLARIS -DSYSV4 -DIDEA32 -DHIGHFIRST -DLOGPRI=LOG_INFO \
X	-DOFFSET_T=off_t -DDESCORE" \
X	SYSLIBS="-ldescore -lsocket -lnsl -lucb"
X
Xfreebsd:
X	make all ALLMASTER="$(BSD4OBJ) $(MASTER)" \
X	ALLSLAVE="$(SLAVE)" \
X	SYSDEFS="-DIDEA32 -DLOGPRI=LOG_INFO -DOFFSET_T=off_t \
X	-DHAS_SYS_PARAM_H -DDESCORE" \
X	SYSLIBS="-ldescore -lutil"
X
Xultrix:
X	make all ALLMASTER="$(BSD4OBJ) $(MASTER)" \
X	ALLSLAVE="$(SLAVE)" \
X	SYSDEFS="-DIDEA32 -DHIGHFIRST -DLOGPRI=LOG_INFO -DOFFSET_T=off_t \
X	-DNO_IP_PROTO -DDESCORE" \
X	SYSLIBS="-ldescore"
X
Xaix:
X	make all ALLMASTER="$(BSD4OBJ) $(MASTER)" \
X	ALLSLAVE="$(SLAVE)" \
X	SYSDEFS="-DAIX -DIDEA32 -DHIGHFIRST -DLOGPRI=LOG_INFO -DOFFSET_T=off_t \
X	-DDESCORE" \
X	SYSLIBS="-ldescore"
X
X
X
Xall:	steld stel
X
Xvers.c	:
X	sh newvers.sh
X
Xsteld	: $(ALLMASTER)
X	$(CC) $(ALLMASTER) $(SDILIB) -o $@ $(LDFLAGS)
X
Xstel	: $(ALLSLAVE)
X	$(CC) $(ALLSLAVE) -o $@ $(LDFLAGS)
X	chmod 711 $@
X
Xci	:
X	ci -msafety -q -l $(SRC) $(ETC)
X
Xshar	:
X	shar $(SRC) $(HDR) $(ETC) > stel.shar
X
Xlint	:
X	lint \
X	-DIDEA32 -DHIGHFIRST -DLOGPRI=LOG_INFO -DOFFSET_T=long \
X	-I$(DESDIR) -I$(DESCOREDIR) -I$(SKEYDIR) -I$(GMPDIR)  $(DEFS) $(SRC)
X
Xwc	:
X	wc -l $(SRC) $(HDR)
X
Xclean	:
X	/bin/rm -f $(ALLOBJ) core steld stel
X
Xsignatures	:
X	echo > signatures
X	echo Wrapped and signed on this date `date` >> signatures
X	echo >> signatures
X	md5 $(SRC) $(HDR) $(ETC) >> signatures
X	echo >> signatures
X	echo vince >> signatures
X	pgp -sa signatures
X	rm signatures
X
Xtag	:
X	ctags -w $(SRC)
END_OF_FILE
  if test 5515 -ne `wc -c <'Makefile'`; then
    echo shar: \"'Makefile'\" unpacked with wrong size!
  fi
  # end of 'Makefile'
fi
if test -f 'securid.conf' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'securid.conf'\"
else
  echo shar: Extracting \"'securid.conf'\" \(160 characters\)
  sed "s/^X//" >'securid.conf' <<'END_OF_FILE'
X# all users defined in this file must authenticate using
X# securID cards. that is, if users are not SDI registered they
X# simply canno log in.
Xroot
Xuser1
Xuser2
END_OF_FILE
  if test 160 -ne `wc -c <'securid.conf'`; then
    echo shar: \"'securid.conf'\" unpacked with wrong size!
  fi
  # end of 'securid.conf'
fi
if test -f 'skey.access' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'skey.access'\"
else
  echo shar: Extracting \"'skey.access'\" \(963 characters\)
  sed "s/^X//" >'skey.access' <<'END_OF_FILE'
X# This file controls whether UNIX passwords are to be permitted.  Rules
X# are matched in order, and the search terminates when the first matching
X# rule has been found.
X#
X# Each rule has the form:
X#
X#       permit condition condition...
X#       deny condition condition...
X#
X# Where "permit" or "deny" may be followed by zero or more conditions.
X#
X# A rule is matched when all conditions are satisfied. A rule without
X# conditions is always satisfied.
X#
X# Examples of conditions are:
X#
X#       hostname wzv.win.tue.nl
X#       internet 131.155.210.0 255.255.255.0
X#       port     ttya
X#       user     root
X#       group    wheel
X#
X# The old S/Key form (permit/deny netnumber netmask) is still supported.
X#
X#permit user uugiga      # uucp login via modem or internet
X#permit port ttyb        # local
X#permit port console     # local
X#hostname idea.sec.dsi.unimi.it
Xpermit user root port console
Xpermit user root port ttyp1
Xdeny                    # anything else
END_OF_FILE
  if test 963 -ne `wc -c <'skey.access'`; then
    echo shar: \"'skey.access'\" unpacked with wrong size!
  fi
  # end of 'skey.access'
fi
if test -f 'skey.access.5' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'skey.access.5'\"
else
  echo shar: Extracting \"'skey.access.5'\" \(4277 characters\)
  sed "s/^X//" >'skey.access.5' <<'END_OF_FILE'
X.TH SKEY.ACCESS 5
X.SH NAME
Xskey.access \- S/Key password control table
X.SH DESCRIPTION
XThe S/Key password control table (\fI/etc/skey.access\fR) is used by
X\fIlogin\fR-like programs to determine when UNIX passwords may be used
Xto access the system.
X.IP \(bu
XWhen the table does not exist, there are no password restrictions.  The
Xuser may enter the UNIX password or the S/Key one.
X.IP \(bu
XWhen the table does exist, UNIX passwords are permitted only when
Xexplicitly specified.
X.IP \(bu
XFor the sake of sanity, UNIX passwords are always permitted on the
Xsystems console.
X.SH "TABLE FORMAT"
XThe format of the table is one rule per line.  Rules are matched in
Xorder.  The search terminates when the first matching rule is found, or
Xwhen the end of the table is reached.
X.PP
XRules have the form:
X.sp
X.in +5
Xpermit condition condition...
X.br
Xdeny condition condition...
X.in
X.PP
Xwhere
X.I permit
Xand
X.I deny
Xmay be followed by zero or more conditions. Comments begin with a `#\'
Xcharacter, and extend through the end of the line.  Empty lines or
Xlines with only comments are ignored.
X.PP
XA rule is matched when all conditions are satisfied. A rule without
Xconditions is always satisfied. For example, the last entry could
Xbe a line with just the word
X.I deny
Xon it.
X.SH CONDITIONS
X.IP "hostname wzv.win.tue.nl"
XTrue when the login comes from host wzv.win.tue.nl.
XSee the WARNINGS section below.
X.IP "internet 131.155.210.0 255.255.255.0"
XTrue when the remote host has an internet address in network
X131.155.210.  The general form of a net/mask rule is:
X.sp
X.ti +5
Xinternet net mask
X.sp
XThe expression is true when the host has an internet address for which
Xthe bitwise and of
X.I address
Xand
X.I mask
Xequals
X.IR net.
XSee the WARNINGS section below.
X.IP "port ttya"
XTrue when the login terminal is equal to
X.IR /dev/ttya .
XRemember that UNIX passwords are always permitted with logins on the
Xsystem console.
X.IP "user uucp"
XTrue when the user attempts to log in as
X.IR uucp .
X.IP "group wheel"
XTrue when the user attempts to log in as a member of the
X.I wheel
Xgroup.
X.SH COMPATIBILITY
XFor the sake of backwards compatibility, the
X.I internet
Xkeyword may be omitted from net/mask patterns.
X.SH WARNINGS
XSeveral rule types depend on host name or address information obtained
Xthrough the network.  What follows is a list of conceivable attacks to
Xforce the system to permit UNIX passwords.
X.IP "Host address spoofing (source routing)"
XAn intruder configures a local interface to an address in a trusted
Xnetwork and connects to the victim using that source address.  Given
Xthe wrong client address, the victim draws the wrong conclusion from
Xrules based on host addresses or from rules based on host names derived
Xfrom addresses.
X.sp
XRemedies: (1)  do not permit UNIX passwords with network logins; (2)
Xuse network software that discards source routing information (e.g.
Xa tcp wrapper).
X.PP
XAlmost every network server must look up the client host name using the
Xclient network address. The next obvious attack therefore is:
X.IP "Host name spoofing (bad PTR record)"
XAn intruder manipulates the name server system so that the client
Xnetwork address resolves to the name of a trusted host.  Given the
Xwrong host name, the victim draws the wrong conclusion from rules based
Xon host names, or from rules based on addresses derived from host
Xnames.
X.sp
XRemedies: (1) do not permit UNIX passwords with network logins; (2) use
Xnetwork software that verifies that the hostname resolves to the client
Xnetwork address (e.g. a tcp wrapper).
X.PP
XSome applications, such as the UNIX login program, must look up the
Xclient network address using the client host name. In addition to the
Xprevious two attacks, this opens up yet another possibility:
X.IP "Host address spoofing (extra A record)"
XAn intruder manipulates the name server system so that the client host
Xname (also) resolves to a trusted address.
X.sp
XRemedies: (1)  do not permit UNIX passwords with network logins; (2)
Xthe skeyaccess() routines ignore network addresses that appear to
Xbelong to someone else.
X.SH DIAGNOSTICS
XSyntax errors are reported to the syslogd. When an error is found
Xthe rule is skipped.
X.SH FILES
X/etc/skey.access, password control table
X.SH AUTHOR
X.nf
XWietse Venema
XEindhoven University of Technology
XThe Netherlands
END_OF_FILE
  if test 4277 -ne `wc -c <'skey.access.5'`; then
    echo shar: \"'skey.access.5'\" unpacked with wrong size!
  fi
  # end of 'skey.access.5'
fi
if test -f 'newvers.sh' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'newvers.sh'\"
else
  echo shar: Extracting \"'newvers.sh'\" \(236 characters\)
  sed "s/^X//" >'newvers.sh' <<'END_OF_FILE'
X#!/bin/sh -
Xif [ ! -r edit ]; then echo 0 > edit; fi
Xtouch edit
Xawk '	{ edit = $1 + 1; }\
XEND	{ printf "char versionstring[] = \"version BETA(%d) ", edit > "vers.c";\
X	  printf "%d\n", edit > "edit"; }' < edit
Xecho `date`'";' >> vers.c
END_OF_FILE
  if test 236 -ne `wc -c <'newvers.sh'`; then
    echo shar: \"'newvers.sh'\" unpacked with wrong size!
  fi
  # end of 'newvers.sh'
fi
echo shar: End of archive.
exit 0
