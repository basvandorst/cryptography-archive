head	1.114;
access;
symbols;
locks
	vince:1.114; strict;
comment	@ * @;


1.114
date	96.04.03.08.40.32;	author vince;	state Exp;
branches;
next	1.113;

1.113
date	96.03.30.14.58.08;	author vince;	state Exp;
branches;
next	1.112;

1.112
date	96.02.07.16.44.20;	author vince;	state Exp;
branches;
next	1.111;

1.111
date	96.01.26.15.15.13;	author vince;	state Exp;
branches;
next	1.110;

1.110
date	96.01.05.09.53.56;	author vince;	state Exp;
branches;
next	1.109;

1.109
date	96.01.03.18.20.26;	author vince;	state Exp;
branches;
next	1.108;

1.108
date	96.01.02.16.41.03;	author vince;	state Exp;
branches;
next	1.107;

1.107
date	95.12.26.19.22.18;	author vince;	state Exp;
branches;
next	1.106;

1.106
date	95.12.26.17.00.58;	author vince;	state Exp;
branches;
next	1.105;

1.105
date	95.12.23.16.02.15;	author vince;	state Exp;
branches;
next	1.104;

1.104
date	95.12.22.19.55.52;	author vince;	state Exp;
branches;
next	1.103;

1.103
date	95.12.22.10.55.10;	author vince;	state Exp;
branches;
next	1.102;

1.102
date	95.12.22.09.43.01;	author vince;	state Exp;
branches;
next	1.101;

1.101
date	95.12.22.08.16.30;	author vince;	state Exp;
branches;
next	1.100;

1.100
date	95.12.21.18.00.21;	author vince;	state Exp;
branches;
next	1.99;

1.99
date	95.12.21.11.27.56;	author vince;	state Exp;
branches;
next	1.98;

1.98
date	95.12.21.11.05.14;	author vince;	state Exp;
branches;
next	1.97;

1.97
date	95.12.21.10.58.55;	author vince;	state Exp;
branches;
next	1.96;

1.96
date	95.12.20.18.33.49;	author vince;	state Exp;
branches;
next	1.95;

1.95
date	95.12.19.14.39.00;	author vince;	state Exp;
branches;
next	1.94;

1.94
date	95.12.19.12.22.18;	author vince;	state Exp;
branches;
next	1.93;

1.93
date	95.12.19.08.37.40;	author vince;	state Exp;
branches;
next	1.92;

1.92
date	95.12.16.15.48.11;	author vince;	state Exp;
branches;
next	1.91;

1.91
date	95.12.15.17.40.24;	author vince;	state Exp;
branches;
next	1.90;

1.90
date	95.12.15.17.32.38;	author vince;	state Exp;
branches;
next	1.89;

1.89
date	95.12.15.16.36.17;	author vince;	state Exp;
branches;
next	1.88;

1.88
date	95.12.14.13.05.44;	author vince;	state Exp;
branches;
next	1.87;

1.87
date	95.12.14.10.42.27;	author vince;	state Exp;
branches;
next	1.86;

1.86
date	95.12.14.10.36.13;	author vince;	state Exp;
branches;
next	1.85;

1.85
date	95.12.08.16.07.06;	author vince;	state Exp;
branches;
next	1.84;

1.84
date	95.12.05.16.54.26;	author vince;	state Exp;
branches;
next	1.83;

1.83
date	95.12.05.15.36.22;	author vince;	state Exp;
branches;
next	1.82;

1.82
date	95.12.04.16.44.11;	author vince;	state Exp;
branches;
next	1.81;

1.81
date	95.12.04.16.36.21;	author vince;	state Exp;
branches;
next	1.80;

1.80
date	95.11.29.13.18.46;	author vince;	state Exp;
branches;
next	1.79;

1.79
date	95.11.25.16.53.41;	author vince;	state Exp;
branches;
next	1.78;

1.78
date	95.11.24.14.04.05;	author vince;	state Exp;
branches;
next	1.77;

1.77
date	95.11.24.10.08.11;	author vince;	state Exp;
branches;
next	1.76;

1.76
date	95.11.24.08.43.04;	author vince;	state Exp;
branches;
next	1.75;

1.75
date	95.11.24.08.40.41;	author vince;	state Exp;
branches;
next	1.74;

1.74
date	95.11.24.08.19.55;	author vince;	state Exp;
branches;
next	1.73;

1.73
date	95.11.24.08.06.44;	author vince;	state Exp;
branches;
next	1.72;

1.72
date	95.11.21.09.56.21;	author vince;	state Exp;
branches;
next	1.71;

1.71
date	95.08.26.12.01.03;	author vince;	state Exp;
branches;
next	1.70;

1.70
date	95.08.26.09.47.35;	author vince;	state Exp;
branches;
next	1.69;

1.69
date	95.08.25.15.58.26;	author vince;	state Exp;
branches;
next	1.68;

1.68
date	95.08.25.14.06.17;	author vince;	state Exp;
branches;
next	1.67;

1.67
date	95.08.25.13.44.55;	author vince;	state Exp;
branches;
next	1.66;

1.66
date	95.08.25.10.59.54;	author vince;	state Exp;
branches;
next	1.65;

1.65
date	95.08.23.15.14.46;	author vince;	state Exp;
branches;
next	1.64;

1.64
date	95.08.23.15.05.54;	author vince;	state Exp;
branches;
next	1.63;

1.63
date	95.08.23.11.16.54;	author vince;	state Exp;
branches;
next	1.62;

1.62
date	95.08.15.18.47.12;	author vince;	state Exp;
branches;
next	1.61;

1.61
date	95.07.29.19.52.54;	author vince;	state Exp;
branches;
next	1.60;

1.60
date	95.07.19.18.58.54;	author vince;	state Exp;
branches;
next	1.59;

1.59
date	95.07.14.16.06.22;	author vince;	state Exp;
branches;
next	1.58;

1.58
date	95.07.14.14.05.39;	author vince;	state Exp;
branches;
next	1.57;

1.57
date	95.07.14.13.58.45;	author vince;	state Exp;
branches;
next	1.56;

1.56
date	95.07.14.13.31.29;	author vince;	state Exp;
branches;
next	1.55;

1.55
date	95.07.13.17.35.49;	author vince;	state Exp;
branches;
next	1.54;

1.54
date	95.07.13.11.03.57;	author vince;	state Exp;
branches;
next	1.53;

1.53
date	95.07.12.16.44.00;	author vince;	state Exp;
branches;
next	1.52;

1.52
date	95.07.08.15.48.56;	author vince;	state Exp;
branches;
next	1.51;

1.51
date	95.07.05.17.31.05;	author vince;	state Exp;
branches;
next	1.50;

1.50
date	95.07.05.15.42.32;	author vince;	state Exp;
branches;
next	1.49;

1.49
date	95.07.05.15.21.22;	author vince;	state Exp;
branches;
next	1.48;

1.48
date	95.05.12.18.07.46;	author vince;	state Exp;
branches;
next	1.47;

1.47
date	95.05.12.18.00.14;	author vince;	state Exp;
branches;
next	1.46;

1.46
date	95.05.12.17.48.53;	author vince;	state Exp;
branches;
next	1.45;

1.45
date	95.05.12.17.37.20;	author vince;	state Exp;
branches;
next	1.44;

1.44
date	95.05.12.17.29.50;	author vince;	state Exp;
branches;
next	1.43;

1.43
date	95.05.12.16.53.48;	author vince;	state Exp;
branches;
next	1.42;

1.42
date	95.05.12.16.44.48;	author vince;	state Exp;
branches;
next	1.41;

1.41
date	95.05.11.16.49.40;	author vince;	state Exp;
branches;
next	1.40;

1.40
date	95.05.10.18.00.18;	author vince;	state Exp;
branches;
next	1.39;

1.39
date	95.05.10.15.31.50;	author vince;	state Exp;
branches;
next	1.38;

1.38
date	95.05.10.15.27.55;	author vince;	state Exp;
branches;
next	1.37;

1.37
date	95.05.10.15.10.14;	author vince;	state Exp;
branches;
next	1.36;

1.36
date	95.05.06.15.39.00;	author vince;	state Exp;
branches;
next	1.35;

1.35
date	95.04.08.15.43.35;	author vince;	state Exp;
branches;
next	1.34;

1.34
date	95.04.08.11.18.38;	author vince;	state Exp;
branches;
next	1.33;

1.33
date	95.04.05.16.35.14;	author vince;	state Exp;
branches;
next	1.32;

1.32
date	95.03.31.19.34.43;	author vince;	state Exp;
branches;
next	1.31;

1.31
date	95.02.27.15.03.39;	author vince;	state Exp;
branches;
next	1.30;

1.30
date	95.02.21.17.34.49;	author vince;	state Exp;
branches;
next	1.29;

1.29
date	95.02.20.10.10.16;	author vince;	state Exp;
branches;
next	1.28;

1.28
date	95.02.17.14.50.11;	author vince;	state Exp;
branches;
next	1.27;

1.27
date	95.02.06.20.55.46;	author vince;	state Exp;
branches;
next	1.26;

1.26
date	95.01.24.15.55.43;	author vince;	state Exp;
branches;
next	1.25;

1.25
date	95.01.24.10.04.40;	author vince;	state Exp;
branches;
next	1.24;

1.24
date	95.01.21.16.44.56;	author vince;	state Exp;
branches;
next	1.23;

1.23
date	95.01.21.16.35.47;	author vince;	state Exp;
branches;
next	1.22;

1.22
date	95.01.21.16.12.57;	author vince;	state Exp;
branches;
next	1.21;

1.21
date	95.01.21.15.37.28;	author vince;	state Exp;
branches;
next	1.20;

1.20
date	95.01.21.15.37.07;	author vince;	state Exp;
branches;
next	1.19;

1.19
date	95.01.21.15.26.51;	author vince;	state Exp;
branches;
next	1.18;

1.18
date	95.01.21.15.05.14;	author vince;	state Exp;
branches;
next	1.17;

1.17
date	95.01.21.14.26.31;	author vince;	state Exp;
branches;
next	1.16;

1.16
date	95.01.21.14.25.24;	author vince;	state Exp;
branches;
next	1.15;

1.15
date	94.12.28.12.18.20;	author vince;	state Exp;
branches;
next	1.14;

1.14
date	94.11.30.08.15.06;	author vince;	state Exp;
branches;
next	1.13;

1.13
date	94.11.28.18.26.12;	author vince;	state Exp;
branches;
next	1.12;

1.12
date	94.11.26.15.06.48;	author vince;	state Exp;
branches;
next	1.11;

1.11
date	94.11.26.13.15.59;	author vince;	state Exp;
branches;
next	1.10;

1.10
date	94.11.26.11.26.15;	author vince;	state Exp;
branches;
next	1.9;

1.9
date	94.10.26.10.11.39;	author vince;	state Exp;
branches;
next	1.8;

1.8
date	94.10.24.20.19.34;	author vince;	state Exp;
branches;
next	1.7;

1.7
date	94.10.24.18.17.21;	author vince;	state Exp;
branches;
next	1.6;

1.6
date	94.08.17.14.53.22;	author vince;	state Exp;
branches;
next	1.5;

1.5
date	94.08.17.11.20.32;	author vince;	state Exp;
branches;
next	1.4;

1.4
date	94.06.13.22.36.31;	author vince;	state Exp;
branches;
next	1.3;

1.3
date	94.06.13.16.44.05;	author vince;	state Exp;
branches;
next	1.2;

1.2
date	94.06.13.00.04.42;	author vince;	state Exp;
branches;
next	1.1;

1.1
date	94.06.06.16.27.39;	author vince;	state Exp;
branches;
next	;


desc
@@


1.114
log
@safety
@
text
@/*
 * $Author: vince $
 * $Header: /users/vince/src/stel/RCS/makeio.c,v 1.113 1996/03/30 14:58:08 vince Exp $
 * $Date: 1996/03/30 14:58:08 $
 * $Revision: 1.113 $
 * $Locker:  $
 */

#ifndef	lint
static char *rcsid = "@@(#) $Id: makeio.c,v 1.113 1996/03/30 14:58:08 vince Exp $";
#endif	lint

#include <stdio.h>
#include <fcntl.h>
#include <sys/stat.h>
#include <termios.h>
#include <signal.h>
#include <errno.h>
#include <sys/wait.h>
#include <syslog.h>
#include <sys/time.h>
#include <netinet/in.h>
#include <pwd.h>
#include "regex.h"

#ifdef HAS_SYS_PARAM_H
#include <sys/param.h>
#endif

#if defined(BSD)    /* pure BSD-based */
#ifndef SIGCLD
#define SIGCLD  SIGCHLD
#endif
#endif

#include "skey.h"
#include "defs.h"

#define ESCAPE_CMD	"escape"
#define SKEY_CMD	"skey"
#define SKEY_CMD_BIS	"s/key"
#define LOG_CMD		"log"
#define GET_CMD		"get"
#define PUT_CMD		"put"
#define min(x, y)	(x < y ? x  : y)

static int		child_is_dead;
static int		idle_timeout;

/* idea stuff */
#include "idea.h"
IDEAkey			s_ideakey;	/* server */
IDEAkey			c_ideakey;	/* client */

/* des stuff */
/* #include "des.h" */
des_key_schedule	s_schedule1;	/* server */
des_key_schedule	s_schedule2;	/* server */
des_key_schedule	s_schedule3;	/* server */
des_key_schedule	c_schedule1;	/* client */
des_key_schedule	c_schedule2;	/* client */
des_key_schedule	c_schedule3;	/* client */

/* control messages, file xfer integrity */
long	crc32val;

/* md5 stuff */
#include "global.h"
#include "md5.h"

#if defined (IRIX)
#define sigmask(n)	((unsigned int)1 << (((n) - 1) & (32 - 1)))
#endif
#define CONTROL(x)	((x) & 0x1f)		/* CTRL(x) is not portable */
static int		escape = CONTROL(']');
static long		oldmask;
static long		start;
static char		skeybuf[SKEYBUFSIZE];
static unsigned long	userstrokes, traffic, xfertraffic;

/* logging stuff */
static int		logging;
int			logfh; /* visible by stel.c */
static char		logfilename[256];

/* flags stuff. used for file transfer */
#ifdef COMBOFLAG
static int		comboflag = COMBO_FLG_DATA;
#endif /* COMBOFLAG */

static char		fromfile[256];
static char		tofile[256];
static int		userauthenticated;

char			*doskeymatch();

extern int		errno;
extern char		*sys_errlist[];

/* in skeyresp() */
static struct termios saved_ttymode, noecho_ttymode;

int
makeio(in, out, channel, authfh, side, firstack, remhostname, old, new,
						timeout, username)
int		in, out, channel, authfh;
int		firstack;
char		*remhostname, *username;
struct termios	*old, *new;
int		timeout;
{
	int		ret;
	int		mask;
	char		buf[MAKEIOBUF];
	void		deadchild();
	void		idletimeout();

	struct timeval	seltimer, *tim = NULL;
	start = time(NULL);

	crcgen(); /* init crc engime */

	/* block signals */
	(void)signal(SIGCLD, deadchild);
	(void)signal(SIGALRM, idletimeout);
#ifndef SOLARIS
	oldmask = sigblock(sigmask(SIGCLD) | sigmask(SIGALRM));
#endif

	/* init regexp */
	if (!(firstack & FLG_NO_ESCAPE))
		(void)doskeymatch(NULL, SKEYPATTERN);

	for (; ; ) {
		/* unblock signals */
#ifdef SOLARIS
		(void)sigrelse(SIGCLD);
		(void)sigrelse(SIGALRM);
#else
		(void)sigsetmask(oldmask);
#endif

		/* some signal occurred. may be that some data arrived
		   when executing critical (signals inhibited) code, so we
		   flush streams, by waiting one more second for more data */
		if (child_is_dead || idle_timeout) {
			seltimer.tv_sec = 1;
			seltimer.tv_usec = 0;
			tim = &seltimer;
		}

		mask = (1 << in) | (1 << channel);

		if (!userauthenticated &&
		    authfh >= 0 &&
		    firstack & FLG_ACTIVE_ATTACKS)
			mask |= (1 << authfh);

#ifdef SOLARIS
		switch (select(32, (fd_set *)&mask, 0, 0, tim))
#else
		switch (select(32, &mask, 0, 0, tim))
#endif
							{
			case	-1:
				if (errno == EINTR && child_is_dead) {
					return(0);
				}
				if (errno == EINTR && idle_timeout) {
					/* client side, notify user */
					if (side == CLIENT_SIDE)
						cprintf("session timeout\r\n");
					return(0);
				}
				syslog(LOGPRI, "select(): %m");
				return(1);
			case	0:
				/*
				printf("select times out\n");
				*/
				return(0);
		}

#ifdef SOLARIS
		(void)sighold(SIGCLD);
		(void)sighold(SIGALRM);
#else
		/* entering critical code, block signals */
		oldmask = sigblock(sigmask(SIGCLD));
#endif

		if (mask & (1 << in)) {
			ret = doinput(in, channel, buf, side, firstack,
						remhostname, old, new);

		}

		else if (mask & (1 << channel)) {
			ret = dochannel(channel, out, buf, side, firstack,
					remhostname, username, timeout);
		}

		else if (mask & (1 << authfh)) {
			char	authbuf[100];

			bzero(authbuf, sizeof(authbuf));
			if (read(authfh, authbuf, sizeof(authbuf)) !=
							strlen(USRAUTH) ||
			    memcmp(authbuf, USRAUTH, strlen(USRAUTH))) {
				syslog(LOGPRI, "bad authentication channel! bad msg: `%s'",
					authbuf);
				ret = 1;
			}
			if (close(authfh) == -1) {
				syslog(LOGPRI, "close(authfh): %m");
				ret = 1;
			}
			userauthenticated++;
			ret = -1;
		}

		/* clean ending */
		if (ret == 0)
			break;
		/* an error occurred */
		else if (ret == 1)
			return(1);
	}
	return(0);
}

void
deadchild()
{
#if defined(hpux) || defined(SOLARIS) || defined(IRIX) || defined(AIX) || defined(BSDI)
        int             wstatus;
#else
        union wait      wstatus;
#endif

#ifdef SOLARIS24
	(void)wait(NULL);
#else
        while (wait3(&wstatus, WNOHANG, NULL) > 0)
                ;
#endif
        child_is_dead++;
        (void)signal(SIGCLD, deadchild);

        return;
}

void
idletimeout()
{
#if defined(hpux) || defined(SOLARIS) || defined(IRIX) || defined(AIX) || defined(BSDI)
        int             wstatus;
#else
        union wait      wstatus;
#endif

#ifdef SOLARIS24
	(void)wait(NULL);
#else
        while (wait3(&wstatus, WNOHANG, NULL) > 0)
                ;
#endif
        idle_timeout++;
        (void)signal(SIGALRM, idletimeout);
        return;
}

doescape(remhostname, old, new, firstack, buf, len)
char		*remhostname, *buf;
struct termios *old, *new;
int		firstack;
int		*len;
{
	char	line[80];
	int	quit = 0;
	char	*skeyprompt;
	char	*control(), *skeyresp();

	/* turn into cooked mode */
	if (tcsetattr(0, TCSANOW, old) == -1) {
		perror("tcgetattr()");
		return(1);
	}

	(void)alarm(0);

	for (; ;) {
		printf("\n");
		cprintf("> ");

		if (fgets(line, sizeof(line), stdin) == NULL) {
			quit = 1; /* user hit ^D */
			break;
		}

		rip(line);

		/* return to remote */
		if (line[0] == '\0') {
			break;
		}

		/* return to remote */
		if (!strncmp(line, "return", strlen(line))) {
			break;
		}

		/* terminate connection */
		if (!strncmp(line, "close", strlen(line)) ||
		    !strncmp(line, "quit", strlen(line))) {
			quit = 1;
			break;
		}

		/* calculate skey response. skey arguments can be
		provided at the command line */
		if (!strncmp(line, SKEY_CMD, strlen(SKEY_CMD)) ||
		    !strncmp(line, SKEY_CMD_BIS, strlen(SKEY_CMD_BIS))) {
			char	*p = skeyresp(line, 0);

			if (p)
				cprintf("skey response: %s\n", p);
			continue;
		}

		/* automatic skey prompting */
		if (!strncmp(line, "autoskey", strlen(line))) {
			char	*p;

			skeyprompt = doskeymatch(skeybuf, NULL);
			if (!skeyprompt) {
				cprintf("no skey challenge found\r\n");
				break;
			}

			p = skeyresp(skeyprompt, 1);
			if (p == NULL) /* failed */
				return(0);
			*len = strlen(p) + 1;
			strcpy(buf, p);
			buf[strlen(p)] = '\n';
			buf[strlen(p) + 1] = '\0';

			quit = -1;
			break;
		}

		/* log stdout to file */
		if (!strncmp(line, LOG_CMD, strlen(LOG_CMD))) {
			if (logging) {
				if (close(logfh))
					perror(logfilename);
				logfh = 0;
				printf("Capture is OFF (%s)\n", logfilename);
				logging = 0;
			}
			else {
				char	*p;

				p = (char *)strtok(line +
						strlen(LOG_CMD), " \t");
				strcpy(logfilename, p ? p : tmpnam(NULL));
				if ((logfh = open(logfilename,
					O_WRONLY | O_CREAT, 0600)) == -1) {
					perror(logfilename);
					break;
				}
				printf("Capture is ON (%s)\n", logfilename);
				logging = 1;
			}

			break;
		}

#ifndef NOREMEXEC
		/* start xfer connection */
		if (firstack & FLG_ACTIVE_ATTACKS &&
		    (!strncmp(line, GET_CMD, strlen(GET_CMD)) ||
		    !strncmp(line, PUT_CMD, strlen(PUT_CMD)))) {
			char	*p, *q, *linep, mode;

			mode = !strncmp(line, GET_CMD, strlen(GET_CMD)) ?
				COMBO_FLG_GET : COMBO_FLG_PUT;

			linep = line + strlen(GET_CMD);
			if ((p = (char *)strtok(linep, " \t")) == NULL ||
			    (q = (char *)strtok(NULL, " \t")) == NULL) {
				if (mode == COMBO_FLG_GET)
					printf("usage: get remotefile localfile\n");
				else
					printf("usage: put localfile remotefile\n");
				continue;
			}

			/* set sources and destination files */
			bzero(fromfile, sizeof(fromfile));
			strncpy(fromfile, p, strlen(p));

			bzero(tofile, sizeof(tofile));
			strncpy(tofile, q, strlen(q));

			/* set buffer */
			strcpy(buf, XFERTOKEN);
			*len = strlen(buf);

			/* set flags */
			comboflag |= mode;

			quit = -1;
			break;
		}
#endif /* NOREMEXEC */

		/* display some parameters and information */
		if (!strncmp(line, "status", strlen(line))) {
			int hrs, min, sec;
			long elp;
			char *mode;

			elp = time(NULL) - start;
			hrs = (int)(elp / 3600L);
			min = (int)((elp -  (long)hrs * 3600L) / 60L);
			sec = (int)(elp - (long)hrs * 3600L - (long)min * 60L);

			if (firstack & FLG_NO_ENCRYPTION)
				mode = "DISABLED: THIS SESSION IS INSECURE!";
			else if (firstack & FLG_USE_IDEA)
				mode = "ENABLED (IDEA)";
			else if (firstack & FLG_USE_SINGLE)
				mode = "ENABLED (SINGLE DES)";
			else if (firstack & FLG_USE_RC4)
				mode = "ENABLED (RC4)";
			else
				mode = "ENABLED (TRIPLE DES)";

			printf("Connected to %s.\n", remhostname);
			printf("Connection time: %s", ctime(&start));
			printf("Elapsed time: %d h, %d m, %d s\n",
								hrs, min, sec);
			printf("Inbound traffic: %ld bytes\n", traffic);
			printf("Outbound traffic: %ld bytes\n", userstrokes);
			printf("File xfer traffic: %ld bytes\n", xfertraffic);
			printf("Logging to file: %s\n", 
				logging ? logfilename : "OFF");
			printf("Escape character is '%s'\n", control(escape));
			printf("Data encryption: %s\n", mode);
			printf("Active attacks protection: %s\n",
				firstack & FLG_ACTIVE_ATTACKS ?
				"ENABLED" : "DISABLED");
			printf("\n");

			break;
		}

		/* escape to shell */
		if (line[0] == '!') {
			char	*shell;

			if (line[1] == '\0') {
				if ((shell = (char *)getenv("SHELL")) == NULL)
					shell = "/bin/sh";
			}
			else
				shell = line + 1;
			
#ifdef SOLARIS
			(void)sigrelse(SIGCLD);
			(void)sigrelse(SIGALRM);
#else
			(void)sigsetmask(oldmask);
#endif
			(void)signal(SIGCLD, SIG_DFL);
			(void)signal(SIGALRM, SIG_DFL);

			if (system(shell) == -1)
				perror("system()");
			(void)signal(SIGCLD, deadchild);
			/* (void)signal(SIGALRM, idletimeout); */
#ifdef SOLARIS
			/* (void)sighold(SIGALRM); */
			(void)sighold(SIGCLD);
#else
			oldmask = sigblock(sigmask(SIGCLD) | sigmask(SIGALRM));
#endif
			break;
		}

		if (!strcmp(line, "z")) {
			(void)kill(0, SIGTSTP);
			break;
		}

		if (!strncmp(line, ESCAPE_CMD, strlen(ESCAPE_CMD))) {
			unsigned char	x;
			char		*escbuf;
			
			/* make escbuf point to first non command character */
			escbuf = line + strlen(ESCAPE_CMD);
			while (isspace(*escbuf))
				escbuf++;

			if (*escbuf) {
				x = *escbuf;
			}
			else {
				printf("Current escape character is: '%s'\n",
							control(escape));
				printf("Enter new escape character: ");
				(void)fflush(stdout);
				x = (unsigned char)getchar();
			}

			if (isspace(x))
				printf("escape character not set\n");
			else {
				escape = x;
				printf("escape character set to: %s\n",
							control(escape));
			}
			continue;
		}

		if (!strncmp(line, "sendesc", strlen(line))) {
			quit = -1;
			/* everything is in the buffer already */
			break;
		}

		if (!strcmp(line, "?")) {
			printf("Commands may be abbreviated.  * means: arguments supported\n\n");
			
			printf("close, quit, ^D	close current connection\n");
			printf("return, ^M	return to remote system\n");
			printf("skey, s/key *	generate skey response\n");
			printf("autoskey	generate and send skey response\n");
			printf("status		display operating parameters\n");
			printf("escape      *	set escape character\n");
			printf("sendesc		send escape character\n");
			printf("log 	    *	log to file\n");
#ifndef NOREMEXEC
			if (firstack & FLG_ACTIVE_ATTACKS) {
				printf("put	    *	upload a file\n");
				printf("get         *	download a file\n");
			}
#endif
			printf("!	    *	shell escape\n");
			printf("z		suspend telnet\n");
			printf("?		print help information\n");
			continue;
		}

		printf("?Invalid command. Try '?'\n");
	}

	/* return to raw mode */
	if (tcsetattr(0, TCSANOW, new) == -1) {
		perror("tcgetattr()");
		return(1);
	}
	return(quit);
}

char *
skeyresp(line, automjr)
char	*line;
int	automjr;
{
	char		*seed, *seqn, passwd[80];
	static char	buf[256];
	int		n;
	int		desmode = 0;
	char		key[8];
	void		sk_restore_ttymode();
	void		(*oldsig) ();

	cprintf(
"Reminder: do not use this while logged in via telnet or dial-in\n");

	if (*line == '[') /* skip trailing [ */
		line++;
	if (!strncmp(line, SKEY_CMD, strlen(SKEY_CMD)))
		line += strlen(SKEY_CMD); /* skip the first word */
	else if (!strncmp(line, SKEY_CMD_BIS, strlen(SKEY_CMD_BIS)))
		line += strlen(SKEY_CMD_BIS); /* skip the first word */
	seqn = (char *)strtok(line, ", \t[]"); /* check command line args */
	if (seqn == NULL) {
		cprintf("sequence number, seed: ");
		(void)fflush(stdout);
		if (fgets(buf, sizeof(buf), stdin) == NULL) {
			cprintf("EOF\n");
			return(NULL);
		}
		rip(buf);

		seqn = (char *)strtok(buf, ", \t[]");
		if (seqn == NULL) {
			cprintf("no input?\n");
			return(NULL);
		}
	}
	n = atoi(seqn);
	if (n < 0) {
		cprintf("%d not positive\n", n);
		return(NULL);
	}
	seed = (char *)strtok(NULL, " \t[]");
	if (seed == NULL) {
		cprintf("no seed provided?\n");
		return(NULL);
	}

	/* cprintf("[s/key %d %s]\n", n, seed); */
	cprintf("s/key %d %s      Enter secret password:", n, seed);

	/* ECHO OFF */
	if (tcgetattr(0, &saved_ttymode) == -1) {
		perror("tcgetattr()");
		return(NULL);
	}
	if ((oldsig = signal(SIGINT, SIG_IGN)) != SIG_IGN)
		(void)signal(SIGINT, sk_restore_ttymode);
	if (tcgetattr(0, &noecho_ttymode) == -1) {
		perror("tcgetattr()");
		return(NULL);
	}
	noecho_ttymode.c_lflag &= ~ECHO;
	if (tcsetattr(0, TCSANOW, &noecho_ttymode) == -1) {
		perror("tcsetattr()");
		return(NULL);
	}

	if (fgets(passwd, sizeof(passwd), stdin) == NULL) {
		cprintf("no password provided\n");
		return(NULL);
	}
	rip(passwd);

	/* ECHO ON */
	if (tcsetattr(0, TCSANOW, &saved_ttymode) == -1) {
		perror("tcsetattr()");
		return(NULL);
	}
	if (oldsig != SIG_IGN)
		(void)signal(SIGINT, oldsig);
	printf("\n");

	if ((char *)getenv("SKEYPADFILE") != NULL) {
		if (automjr) {
			cprintf("(using mjr DES padding mode)\n");
			cprintf("using skeypadfile %s\n",
							getenv("SKEYPADFILE"));
			desmode = 1;
		}
		else {
			cprintf("use mjr DES padding mode ? ");
			if (fgets(buf, sizeof(buf), stdin) == NULL) {
				cprintf("EOF\n");
				return(NULL);
			}
			rip(buf);
			if (buf[0] == 'y')
				desmode = 1;
		}
	}

	/* Crunch seed and password into starting key */
	if(desmode ? deskeycrunch(key, seed, passwd) :
		keycrunch(key,seed,passwd) != 0) {
		cprintf("key crunch failed\n");
		return(NULL);
	}

	while(n-- != 0)
		fff(key);
	btoe(buf, key);
	return(buf);
}

/* restore - restore terminal modes when user aborts command */
void sk_restore_ttymode()
{
	if (tcsetattr(0, TCSANOW, &saved_ttymode) == -1)
		perror("tcsetattr()");
	exit(1);
}


storeskeybuf(buf, len)
char	*buf;
int	len;
{
	static int	skeyoffset;
	static int	skeybufsize = sizeof(skeybuf);

	if (skeyoffset == 0) /* init buffer */
		bzero(skeybuf, skeybufsize);
	
	/* buffer fits into skeybuf, the simplest case */
	if (len + skeyoffset < skeybufsize) {
		memcpy(skeybuf + skeyoffset, buf, len);
		skeyoffset += len;
	}
	/* buffer does not fit into skeybuf, and in fact it is larger
	than skeybufsize, so a full shift is performed */
	else if (len >= skeybufsize) {
		char	 *p;

		/* get last skeybufsize bytes from buf */
		p = buf + (len - skeybufsize);
		memcpy(skeybuf, p, skeybufsize);
		/* set offset at end of buffer */
		skeyoffset = skeybufsize - 1;
	}
	/* buffer does not fit into skeybuf, but it is smaller than
	skeybufsize. Two partial shifts are performed */
	else if (len < skeybufsize) {
		int	diff;

		/* how many exceeding bytes? */
		diff = len - (skeybufsize - skeyoffset) + 1;
		/* first shift */
		memcpy(skeybuf, skeybuf + diff, skeyoffset - diff);
		/* second shift */
		memcpy(skeybuf + skeyoffset - diff, buf, len);
		/* set offset at end of buffer */
		skeyoffset = skeybufsize - 1;
	}
}

char *
doskeymatch(buf, pat)
char	*buf, *pat;
{
	static regex_t		storedre;
	regex_t			re;
	regmatch_t		pm;
	static char		prompt[128];
	char			*pbuf, *rbuf, result[128];
	int			found = 0;

	if (pat) {
		/* it seems that re is somewhat corrupred by regexec().
		so we store it in a safe place and use a temporary copy */
		(void)regcomp(&storedre, pat, REG_EXTENDED);
		return(NULL);
	}

	bzero(result, sizeof(result));
	bzero(&pm, sizeof(pm));
	(void)memcpy(&re, &storedre, sizeof(re));

	/* skip all matches but last one */
	pbuf = buf;
	while (!regexec(&re, pbuf, 1, &pm, 0)) {
		if (sizeof(result) < pm.rm_eo - pm.rm_so + 2) /* overflow */
			continue;
		strncpy(result, pbuf + pm.rm_so, pm.rm_eo - pm.rm_so);
		result[pm.rm_eo - pm.rm_so] = '\0';
		found++;
		pbuf += pm.rm_eo;
	}

	if (!found)
		return(NULL);

	/* remove all \n\r */
	rbuf = result;
	pbuf = prompt;
	while (*rbuf) {
		if (*rbuf != '\n' && *rbuf != '\r')
			*pbuf++ = *rbuf;
		rbuf++;
	}
	*pbuf = '\0';

	return (prompt);
}

doinput(in, channel, buf, side, firstack, remhostname, old, new)
int		in, channel;
int		side, firstack;
char		*buf, *remhostname;
struct 		termios	*old, *new;
{
	static unsigned long	sequence;
	/*
	register		side;
	*/
	static			enc, cipher, cipherinit;
	int			len;

	/*
	side = remhostname ? CLIENT_SIDE : SERVER_SIDE;
	*/
	if (!cipherinit++) {
		if (!(firstack & FLG_NO_ENCRYPTION))
			enc = DES_ENCRYPT;
		else
			enc = -1;

		cipher = 0; /* use single des by default */
		if (firstack & FLG_USE_SINGLE)
			cipher = DES_CIPHER;
		else if (firstack & FLG_USE_IDEA)
			cipher = IDEA_CIPHER;
		else if (firstack & FLG_USE_RC4)
			cipher = RC4_CIPHER;
		else
			cipher = TRIPLEDES_CIPHER;
	}

	if ((len = read(in, buf, MAKEIOBUF)) == -1) {
/* #if defined(SUNOS4) || defined(linux) */
		if (errno == EIO) /* sun EOF */
			return(0);
			
/* #endif */
		syslog(LOGPRI, "read(): %m");
		return(1);
	}
	if (!len)
		return(0);

	if (side == CLIENT_SIDE &&
	    len == 1 && /* prevent accidental triggering */
	    (buf[0] == escape) && !(firstack & FLG_NO_ESCAPE)) {
		int	ret;

		ret = doescape(remhostname, old, new, firstack, buf, &len);
		if (ret == 1) { /* terminate connection */
			return(0);
		}

		cprintf("Returning to remote\r\n");
		if (ret == 0) { /* cont connection */
			return(-1);
		}
		/* if ret == -1 fall trought, so buf is
		passed on to the server */
	}

	userstrokes += len;

	/* check integrity and ordering */
	if (firstack & FLG_ACTIVE_ATTACKS) {
		struct dataset {
			unsigned long	seq;
#ifdef COMBOFLAG
			int		flag;
#endif /* COMBOFLAG */
			long		crc32;
			int		len;
		} set;

		crc32val = 0L;
		UpdateCRC(buf, len);
		sequence++;

		/* set it */
		set.seq = htonl(sequence);
#ifdef COMBOFLAG
		set.flag = htonl(comboflag);
#endif /* COMBOFLAG */
		set.crc32 = htonl(crc32val);
		set.len = htonl(len);

		/*
		{
			char	tmp[MAKEIOBUF * 2];

			bzero(tmp, sizeof(buf));
			memcpy(tmp, buf, len);
			syslog(LOGPRI, "SENDING data = ``%s''", buf);
		}
		*/

		/* encrypt it */
		cryptbuf(&set, sizeof(set), enc, cipher, side);
		cryptbuf(buf, len, enc, cipher, side);

		/* send it.
		eventually, send put/get commands
		*/
		if (write_data(channel, &set, sizeof(set)) != sizeof(set) ||
		    write_data(channel, buf, len) != len) {
			syslog(LOGPRI, "write_data(dataset+buf)");
			return(1);
		}

#ifndef NOREMEXEC
		/* perform GET command */
		if (firstack & FLG_ACTIVE_ATTACKS &&
		    (comboflag & COMBO_FLG_GET || comboflag & COMBO_FLG_PUT)) {
			int	ret;
			ret = doclientftp(channel, fromfile, tofile,
						enc, cipher, comboflag);
			if (ret) {
				cprintf("File xfer failed\r\n");
				if (ret == 1)
					return(1);
			}
			comboflag = COMBO_FLG_DATA;
		}
#endif /* NOREMEXEC */

	}
	/**/ 
	else {
		/* encrypt data buffer */
		cryptbuf(buf, len, enc, cipher, side);

		if (write_data(channel, buf, len) != len) {
			syslog(LOGPRI, "write_data(net): %m");
			return(1);
		}
	}

	return(-1);
}

dochannel(channel, out, buf, side, firstack, remhostname, username, timeout)
int	channel, out;
char	*buf;
int	side, firstack;
char	*remhostname, *username;
int	timeout;
{
	combopacket		**p;
	combopacket		**extract();
	static unsigned long	sequence;
	register		i, len, iside;
	static			dec, cipher, cipherinit;

	/* INVERTED, for encryption issues */
	iside = side == CLIENT_SIDE ? SERVER_SIDE : CLIENT_SIDE;

	if (!cipherinit++) {
		if (!(firstack & FLG_NO_ENCRYPTION))
			dec = DES_DECRYPT;
		else
			dec = -1;

		if (firstack & FLG_USE_SINGLE)
			cipher = DES_CIPHER;
		else if (firstack & FLG_USE_IDEA)
			cipher = IDEA_CIPHER;
		else if (firstack & FLG_USE_RC4)
			cipher = RC4_CIPHER;
		else
			cipher = TRIPLEDES_CIPHER;
	}

	/* check integrity and ordering */
	if (firstack & FLG_ACTIVE_ATTACKS) {
		if ((len = read(channel, buf, MAKEIOBUF)) == -1) {
			syslog(LOGPRI, "read(): %m");
			return(1);
		}

		if (!len) /* disconnection */
			return(0);

		traffic += len;
		if (side == CLIENT_SIDE && firstack & FLG_DEBUG) {
			cprintf("hexdump buffer %d bytes: ", len);
			hexdump(NULL, buf, len);
		}

		/* decode buffer */
		cryptbuf(buf, len, dec, cipher, iside);

		if ((p = extract(buf, len)) == NULL)
			return(1);

		for (i = 0; p[i]; i++) {
			/* increase sequence number */
			sequence++;

			/* check sequence for remote packet */
			if (sequence != p[i]->seq) {
				syslog(LOGPRI, "data out of order, possible active attack! packet #%lu expected, #%lu received",
							sequence, p[i]->seq);
				if (side == CLIENT_SIDE)
					cprintf("DATA OUT OF ORDER, possible active attack!\n\r");
				return(1);
			}

			/* check checksum for remote packet */
			crc32val = 0L;
			UpdateCRC(p[i]->data, p[i]->len);
			if (crc32val != p[i]->crc32) {
				syslog(LOGPRI, "garbled data, possible active attack! packet #%lu, len = %d, crc32 %ld expected %ld received",
					sequence,
					p[i]->len,
					crc32val,
					p[i]->crc32);
		/*
		{
			char	buf[MAKEIOBUF * 2];

			bzero(buf, sizeof(buf));
			memcpy(buf, p[i]->data, p[i]->len > 1000 ? 1000 : p[i]->len);
			syslog(LOGPRI, "garbled buffer (%d) = ``%s''", p[i]->len,  buf);
		}
		*/
				if (side == CLIENT_SIDE)
					cprintf("GARBLED DATA, possible active attack!\n\r");
				return(1);
			}

			/* log to file. only client gets logging set */
			if (logging) {
				if (write(logfh, p[i]->data, p[i]->len) == -1) {
					cprintf("%s: %s\r\n",
						logfilename,
						sys_errlist[errno]);
					(void)close(logfh);
					logfh = 0;
					logging = 0;
				}
			}

#ifndef NOREMEXEC
			if (firstack & FLG_ACTIVE_ATTACKS &&
			    /* double check */
			    (p[i]->flag & COMBO_FLG_GET ||
			    p[i]->flag & COMBO_FLG_PUT) &&
			    /* this is a triple check! */
			    !memcmp(p[i]->data, XFERTOKEN, strlen(XFERTOKEN))) {
				int	ret;

				ret = doserverftp(channel, dec, cipher,
					p[i]->flag, username, remhostname);
				if (ret == 1)
						return(1);
				continue;
			}
#endif /* NOREMEXEC */

			/* write buffer to OUT */
			if (write_data(out, p[i]->data, p[i]->len) !=
								p[i]->len) {
				syslog(LOGPRI, "write_data(out): %m");
				return(1);
			}

			/* store output into a circular buffer, for skey
			challenge detection and skey response automatic
			generation
			*/
			storeskeybuf(p[i]->data, p[i]->len);
		}
	}
	/**/
	else {
		if ((len = read(channel, buf, MAKEIOBUF)) == -1) {
			syslog(LOGPRI, "read(): %m");
			return(1);
		}

		if (!len)
			return(0);

		traffic += len;

		if (side == CLIENT_SIDE && firstack & FLG_DEBUG) {
			cprintf("hexdump buffer %d bytes: ", len);
			hexdump(NULL, buf, len);
		}

		/* decode buffer */
		cryptbuf(buf, len, dec, cipher, iside);

		/* log to file. only client gets logging set */
		if (logging) {
			if (write(logfh, buf, len) == -1) {
				cprintf("%s: %s\r\n", logfilename,
							sys_errlist[errno]);
				(void)close(logfh);
				logfh = 0;
				logging = 0;
			}
		}

		if (write_data(out, buf, len) != len) {
			syslog(LOGPRI, "write_data(out): %m");
			return(1);
		}

		/* store output into a circular buffer, for skey
		challenge detection and skey response automatic
		generation */
		storeskeybuf(buf, len);
	}

	/* server side: receiving some kind of user's input */
	if (side == SERVER_SIDE && timeout) {
		(void)alarm(timeout * 60); /* reset timer */
	}

	return(-1);
}

combopacket **
extract(buf, len)
char	*buf;
int	len;
{
	static combopacket	*p[MAXCOMBONUM];
	static combopacket	*x;
	int			objnum;
	static char		intbuf[MAKEIOBUF * 2], tmp[MAKEIOBUF * 2];
	static int		intbufoffset; /* append offset */
	int			readoffset; /* reading offset */
	int			datalen; /* size of current data buffer */
	long			dataseq; /* seq number of current data buf */
#ifdef COMBOFLAG
	int			dataflag; /* option flag */
#endif /* COMBOFLAG */
	unsigned long		datacrc32; /* checksum of current data buf */
	int			remaining; /* decreasing counter */
	static int		olddatalen;
	static unsigned long	olddataseq;
#ifdef COMBOFLAG
	static int		olddataflag;
#endif /* COMBOFLAG */
	static long		olddatacrc32;
	int			readheader = 0;
	register		i;

	/* free array elements */
	for (i = 0; p[i]; i++) {
		free(p[i]->data);
		free(p[i]);
	}

	/* overflow! should never happen */
	if (len + intbufoffset > MAKEIOBUF * 2) {
		syslog(LOGPRI, "extract: buffer overflow!\n");
		return(NULL);
	}

	/* store buf into internal buffer.  we handle packet
	fragmentation in this way */
	memcpy(intbuf + intbufoffset, buf, len);
	remaining = intbufoffset + len;

	/* build combopacket array */
	for (objnum = 0, readoffset = 0; ; objnum++) {
		/*
		syslog(LOGPRI, "extract: ANALYZING OBJECT # %d", objnum);
		*/

		/* handle residue data.
		at least the non-dynamic part of combopacket should fit
		if it does not, continue and collect more data. */
		if (!olddatalen && remaining <
				sizeof(dataseq) +
#ifdef COMBOFLAG
				sizeof(dataflag) +
#endif /* COMBOFLAG */
				sizeof(datacrc32) +
				sizeof(datalen)) {
			/*
			syslog(LOGPRI, "BREAKING at the first point: remaining = %d", remaining);
			*/
			break;
		}

		if (objnum >= MAXCOMBONUM - 1) {
			syslog(LOGPRI, "extract: packetnum overflow!\n");
			return(NULL);
		}

		if (!olddatalen) {
			/* get sequence number of this packet */
			memcpy(&dataseq,
				intbuf +
				readoffset,
					sizeof(dataseq));
			dataseq = ntohl(dataseq);
#ifdef COMBOFLAG
			memcpy(&dataflag,
				intbuf +
				readoffset +
				sizeof(dataseq),
					sizeof(dataflag));
			dataflag = ntohl(dataflag);
#endif /* COMBOFLAG */

			/* get checksum of this packet */
			memcpy(&datacrc32,
				intbuf +
				readoffset +
				sizeof(dataseq)
#ifdef COMBOFLAG
				+ sizeof(dataflag)
#endif /* COMBOFLAG */
					, sizeof(datacrc32));
			datacrc32 = ntohl(datacrc32);

			/* get size of this packet */
			memcpy(&datalen,
				intbuf +
				readoffset +
				sizeof(dataseq) +
#ifdef COMBOFLAG
				sizeof(dataflag) +
#endif /* COMBOFLAG */
				sizeof(datacrc32),
					sizeof(datalen));
			datalen = ntohl(datalen);

			remaining -= sizeof(datalen) +
				     sizeof(dataseq) +
#ifdef COMBOFLAG
				     sizeof(dataflag) + 
#endif /* COMBOFLAG */
				     sizeof(datacrc32);
			readheader++;
		}
		else {
			datalen = olddatalen;
			dataseq = olddataseq;
#ifdef COMBOFLAG
			dataflag = olddataflag;
#endif /* COMBOFLAG */
			datacrc32 = olddatacrc32;
		}

		/* this is a special case: we read datalen and we find out
		that there is not enough data in the buffer.  we have to
		keep track of datalen before returning to get more data */
		if (datalen > remaining) {
			olddatalen = datalen;
			olddataseq = dataseq;
#ifdef COMBOFLAG
			olddataflag = dataflag;
#endif /* COMBOFLAG */
			olddatacrc32 = datacrc32;
			/*
			syslog(LOGPRI, "extract: BREAKING at the second point (datalen = %d >>> remaining = %d)",
							datalen, remaining);
			*/
			break;
		}

		/*
		syslog(LOGPRI, "extract: before *x setting...");
		syslog(LOGPRI, "extract: *x dump: %lu, %ld, %d, %s\n",
			dataseq, datacrc32, datalen, intbuf + readoffset);
		*/

		/* allocate x */
		if ((x = (combopacket *)malloc(sizeof(combopacket))) == NULL) {
			syslog(LOGPRI, "extract: malloc()");
			return(NULL);
		}

		/* set x.seq */
		x->seq = dataseq;

#ifdef COMBOFLAG
		/* set x.flag */
		x->flag = dataflag;
#endif /* COMBOFLAG */

		/* set x.crc32 */
		x->crc32 = datacrc32;

		/* set x.len */
		x->len = datalen;

		/* set x.data */
		if ((x->data = (char *)malloc(datalen)) == NULL) {
			perror("extract: malloc()");
			return(NULL);
		}
		/* copy data into x->data, skipping datalen */
		if (/* !olddatalen */ readheader)
			memcpy(x->data, intbuf +
					readoffset +
					sizeof(datalen) +
				 	sizeof(dataseq) +
#ifdef COMBOFLAG
					sizeof(dataflag) +
#endif /* COMBOFLAG */
				 	sizeof(datacrc32),
								datalen);
		else {
			memcpy(x->data, intbuf + readoffset, datalen);
		}

		/*
		syslog(LOGPRI, "extract: *x dump...");
		syslog(LOGPRI, "extract: *x dump: seq = %lu, crc = %ld, len =  %d",
			dataseq, datacrc32, datalen);
		{
			char	buf[MAKEIOBUF * 2];

			bzero(buf, sizeof(buf));
			memcpy(buf, x->data, datalen);
			syslog(LOGPRI, "extract: data = ``%s''", buf);
		}
		*/
		

		/* set array element */
		p[objnum] = x;

		/* update pointers */
		if (/* !olddatalen */ readheader) {
			readoffset += datalen +
					sizeof(datalen) +
				 	sizeof(dataseq) +
#ifdef COMBOFLAG
					sizeof(dataflag) +
#endif /* COMBOFLAG */
				 	sizeof(datacrc32);
			/* ``remaining'' has already been decreased by
			header's size */
			remaining -= datalen;
		}
		else {
			readoffset += datalen;
			remaining -= datalen;
		}
		olddatalen = 0;
#ifdef COMBOFLAG
		olddataflag = 0;
#endif /* COMBOFLAG */
		olddatacrc32 = 0L;
		olddataseq = 0L;
		readheader = 0;
	}

	/* reduce intbuffer */
	memcpy(tmp, intbuf, MAKEIOBUF * 2);
	bzero(intbuf, sizeof(intbuf));
	/* if (!olddatalen || fragmentation) */
	if (!readheader) /* this nly happens when breaking out of the loop */
		memcpy(intbuf, tmp + readoffset, MAKEIOBUF * 2 - readoffset);
	else /* skip header */
		memcpy(intbuf, tmp +
				readoffset +
				sizeof(datalen) +
				sizeof(dataseq) +
#ifdef COMBOFLAG
				sizeof(dataflag) +
#endif /* COMBOFLAG */
				sizeof(datacrc32),
				MAKEIOBUF * 2 -
				readoffset -
				sizeof(datalen) -
				sizeof(dataseq) -
#ifdef COMBOFLAG
				sizeof(dataflag) -
#endif /* COMBOFLAG */
				sizeof(datacrc32));
	intbufoffset = remaining;

	/* lasty element should be zero */
	p[objnum] = NULL;

	return(p);
}


/* client read()s (blocks) first */
doclientftp(net, in, out, enc, cipher, mode)
char	*in, *out;
int	net, enc, cipher, mode;
{
	char		buf[100];
	unsigned char	digest[16];
	combocmd	cmd;
	comboanswer	answer;
	int		localfh, len;
	int		error = 0;
	MD5_CTX		mdContext;
	long		crc32tmp;

	/* read what ack from server */
	if (read_data(net, buf, strlen(WHAT_ACK)) != strlen(WHAT_ACK)) {
		cprintf("Bad WHAT_ACK from server\r\n");
		return(1);
	}

	/* decrypt what ack */
	cryptbuf(buf, strlen(WHAT_ACK), enc, cipher, CLIENT_SIDE);

	/* check WHAT_ACK */
	if (memcmp(buf, WHAT_ACK, strlen(WHAT_ACK))) {
		cprintf("Corrupted WHAT_ACK from server\r\n");
		return(1);
	}

	bzero(&cmd, sizeof(cmd));

	/* set operation */
	cmd.cmd = mode;

	/* put local ``in'' file into remote ``out'' file */
	if (mode & COMBO_FLG_PUT) {
		struct stat	sbuf;

		/* set filename */
		strncpy(cmd.filename, out, sizeof(cmd.filename));

		if (stat(in, &sbuf) == -1) {
			cprintf("PUT failed: %s: %s\r\n",
						in, sys_errlist[errno]);
			error++;
		}
		cmd.filesize = len = (unsigned long)sbuf.st_size;
		/* open file for reading */
		if ((localfh = open(in, O_RDONLY)) == -1) {
			cprintf("local error: %s: %s\r\n",
						in, sys_errlist[errno]);
			error++;
		}
	}
	/* get remote ``in'' file and put it into local ``out'' file */
	else if (mode & COMBO_FLG_GET) {
		/* set filename */
		strncpy(cmd.filename, in, sizeof(cmd.filename));

		/* set filesize */
		cmd.filesize = (unsigned long)0L;
		/* open for writing */
		if ((localfh = open(out, O_WRONLY | O_CREAT | O_TRUNC,
							0600)) == -1) {
			cprintf("local error: %s: %s\r\n",
						out, sys_errlist[errno]);
			error++;
		}
	}
	else
		error++;

	if (error)
		cmd.cmd = 0;
	
	cmd.cmd = htonl(cmd.cmd);
	cmd.filesize = htonl(cmd.filesize);

	/* calculate checksum */
	MD5Init(&mdContext);
	MD5Update(&mdContext, &cmd, sizeof(cmd) - 16);
	MD5Final(cmd.checksum, &mdContext);

	/* encrypt cmd */
	cryptbuf(&cmd, sizeof(cmd), enc, cipher, CLIENT_SIDE);

	/* write cmd to server.
	if error occurred, let server know about it 
	*/
	if (write_data(net, &cmd, sizeof(cmd)) != sizeof(cmd)) {
		cprintf("Error sending cmd to server\r\n");
		close(localfh);
		return(1);
	}

	if (error) {
		return(-1); /* error gets handled */
	}

	if (read_data(net, &answer, sizeof(answer)) != sizeof(answer)) {
		cprintf("Bad answer from server\r\n");
		close(localfh);
		return(1);
	}

	/* decrypt answer */
	cryptbuf(&answer, sizeof(answer), enc, cipher, CLIENT_SIDE);

	/* check answer integrity */
	MD5Init(&mdContext);
	MD5Update(&mdContext, &answer, sizeof(answer) - 16);
	MD5Final(digest, &mdContext);
	if (memcmp(digest, answer.checksum, 16)) {
		cprintf("Corrupted ANSWER from server\r\n");
		return(1);
	}

	answer.answer = ntohl(answer.answer);
	answer.filesize = ntohl(answer.filesize);

	if (answer.answer) {
		cprintf("Remote error: %s\r\n", answer.message);
		return(-1);
	}

	if (mode & COMBO_FLG_PUT) {
		/* copy file to network */
		if (streamcp(localfh, net, len, 1, enc, cipher, 1)) {
			cprintf("Error uploading %s: %s\r\n",
							in, sys_errlist[errno]);
			(void)close(localfh);
			return(1);
		}
		if (close(localfh) == -1) {
			cprintf("close(%s): %s\r\n", in, sys_errlist[errno]);
			return(1);
		}
		cprintf("Local file %s UPLOADED to %s\r\n", in, out);
	}
	else if (mode & COMBO_FLG_GET) {
		len = answer.filesize;
		/* copy network to file */
		if (streamcp(net, localfh, len, 1, enc, cipher, 0)) {
			cprintf("Error downloading %s: %s\r\n",
							in, sys_errlist[errno]);
			(void)close(localfh);
			return(1);
		}
		if (close(localfh) == -1) {
			cprintf("close(%s): %s\r\n", out, sys_errlist[errno]);
			return(1);
		}
		cprintf("Remote file %s DOWNLOADED to %s\r\n", in, out);
	}

	/* check the integrity of the xfered file */
	crc32tmp = htonl(crc32val);

	/* crypt crc32tmp  */
	cryptbuf(&crc32tmp, sizeof(crc32tmp), enc, cipher, CLIENT_SIDE);

	/* send encrypted checksum to server, get checksum from server */
	if (write_data(net, &crc32tmp, sizeof(crc32tmp)) != sizeof(crc32tmp) ||
	    read_data(net, &crc32tmp, sizeof(crc32tmp)) != sizeof(crc32tmp)) {
		cprintf("Cannot verify transfer integrity!\r\n");
		return(1);
	}

	/* decrypt crc32tmp */
	cryptbuf(&crc32tmp, sizeof(crc32tmp), enc, cipher, SERVER_SIDE);
	crc32tmp = ntohl(crc32tmp);
	if (crc32tmp != crc32val) {
		cprintf("File is CORRUPTED!  Do NOT use it!\r\n");
		return(1);
	}

	return(0);
}

doserverftp(net, dec, cipher, mode, username, remhostname)
char	*username, *remhostname;
int	net, dec, cipher, mode;
{
	char		buf[100];
	unsigned char	digest[16];
	combocmd	cmd;
	comboanswer	answer;
	int		localfh, len;
	int		error = 0;
	MD5_CTX		mdContext;
	long		crc32tmp;

	/* send what ack to client */
	strncpy(buf, WHAT_ACK, sizeof(buf));
	cryptbuf(buf, strlen(WHAT_ACK), dec, cipher, CLIENT_SIDE);
	if (write_data(net, buf, strlen(WHAT_ACK)) != strlen(WHAT_ACK)) {
		syslog(LOGPRI, "XFER: error sending WHAT_ACK to %s",
								remhostname);
		return(1);
	}

	/* read combocmd from client */
	if (read_data(net, &cmd, sizeof(cmd)) != sizeof(cmd)) {
		syslog(LOGPRI, "XFER: bad cmd, connection with %s broken",
							remhostname);
		return(1);
	}

	/* decrypt cmd */
	cryptbuf(&cmd, sizeof(cmd), dec, cipher, CLIENT_SIDE);

	/* check cmd integrity */
	MD5Init(&mdContext);
	MD5Update(&mdContext, &cmd, sizeof(cmd) - 16);
	MD5Final(digest, &mdContext);
	if (memcmp(digest, cmd.checksum, 16)) {
		syslog(LOGPRI, "XFER: corrupted cmd from %s", remhostname);
		return(1);
	}

	cmd.cmd = ntohl(cmd.cmd);
	cmd.filesize = ntohl(cmd.filesize);

	if (cmd.cmd == 0) { /* handled error */
		return(-1);
	}

	/* double check mode */
	if (mode != cmd.cmd) {
		syslog(LOGPRI, "XFER: bad command from %s", remhostname);
		return(1);
	}

	bzero(&answer, sizeof(answer));

	answer.answer = 0; /* successful by default */

	/* send file to client */
	if (!userauthenticated) {
		syslog(LOGPRI,
		"XFER %s ATTEMPTED to %s %s from %s, not being authenticated!",
			username,
			mode & COMBO_FLG_GET ? "GET" : "PUT",
			cmd.filename,
			remhostname);
		strncpy(answer.message, "not authenticated!",
						sizeof(answer.message));
		error++;
	}
	else if (mode & COMBO_FLG_GET) {
		struct stat	sbuf;

		/* set filesize */
		if (stat(cmd.filename, &sbuf) == -1) {
			syslog(LOGPRI, "GET failed by %s from %s: %s: %m",
					username, remhostname, cmd.filename);
			answer.answer = 1;
			strncpy(answer.message, sys_errlist[errno],
							sizeof(answer.message));
			error++;
		}
		answer.filesize = len = (unsigned long)sbuf.st_size;
		/* open file for reading */
		if ((localfh = open(cmd.filename, O_RDONLY)) == -1) {
			syslog(LOGPRI, "GET failed by %s from from %s: %s: %m",
					username, remhostname, cmd.filename);
			strncpy(answer.message, sys_errlist[errno],
							sizeof(answer.message));
			error++;
		}
	}
	/* receive file from client */
	else if (mode & COMBO_FLG_PUT) {
		len = cmd.filesize;
		answer.filesize = (unsigned long)0L;
		if ((localfh = open(cmd.filename, O_WRONLY | O_CREAT | O_TRUNC,
							0600)) == -1) {
			syslog(LOGPRI, "PUT failed by %s from %s: %s: %m",
					username, remhostname, cmd.filename);
			strncpy(answer.message, sys_errlist[errno],
							sizeof(answer.message));
			error++;
		}
	}
	else /* should never happen */
		error++;

	if (error)
		answer.answer = 1; /* fails */
	
	answer.answer = htonl(answer.answer);
	answer.filesize = htonl(answer.filesize);

	/* calculate answer checksum */
	MD5Init(&mdContext);
	MD5Update(&mdContext, &answer, sizeof(answer) - 16);
	MD5Final(answer.checksum, &mdContext);

	/* crypt answer */
	cryptbuf(&answer, sizeof(answer), dec, cipher, CLIENT_SIDE);

	if (write_data(net, &answer, sizeof(answer)) != sizeof(answer)) {
		syslog(LOGPRI, "XFER: error sending answer to %s", remhostname);
		return(1);
	}

	
	if (error)
		return(-1);
	
	/* copy file to network */
	if (mode & COMBO_FLG_PUT) {
		if (streamcp(net, localfh, len, 0, dec, cipher, 0)) {
			syslog(LOGPRI, "XFER: error storing %s from %s: %m",
						cmd.filename, remhostname);
			(void)close(localfh);
			return(1);
		}
		if (close(localfh) == -1) {
			syslog(LOGPRI, "XFER: close(%s): %m", cmd.filename);
			return(1);
		}
		syslog(LOGPRI, "%s UPLOADED %s (%d bytes) from %s",
				username, cmd.filename, len, remhostname);
	}
	/* copy network to file */
	else if (mode & COMBO_FLG_GET) {
		if (streamcp(localfh, net, len, 0, dec, cipher, 1)) {
			syslog(LOGPRI, "XFER: error sending %s to %s: %m",
						cmd.filename, remhostname);
			(void)close(localfh);
			return(1);
		}
		if (close(localfh) == -1) {
			syslog(LOGPRI, "XFER: close(%s): %m", cmd.filename);
			return(1);
		}
		syslog(LOGPRI, "%s DOWNLOADED %s (%d bytes) from %s",
				username, cmd.filename, len, remhostname);
	}

	/* check the integrity of the xfered file */
	crc32tmp = htonl(crc32val);

	/* crypt crc32tmp  */
	cryptbuf(&crc32tmp, sizeof(crc32tmp), dec, cipher, SERVER_SIDE);

	/* send encrypted checksum to client, get checksum from client */
	if (write_data(net, &crc32tmp, sizeof(crc32tmp)) != sizeof(crc32tmp) ||
	    read_data(net, &crc32tmp, sizeof(crc32tmp)) != sizeof(crc32tmp)) {
		syslog(LOGPRI, "XFER: cannot verify integrity for %s from %s",
						cmd.filename, remhostname);
		return(1);
	}

	/* decrypt crc32tmp */
	cryptbuf(&crc32tmp, sizeof(crc32tmp), dec, cipher, CLIENT_SIDE);
	crc32tmp = ntohl(crc32tmp);
	if (crc32tmp != crc32val) {
		syslog(LOGPRI, "XFER: corrupted file: %s from %s",
						cmd.filename, remhostname);
		return(1);
	}

	return(0);
}

streamcp(from, to, size, isclientside, enc, cipher, crcthencrypt)
int	from, to, size, isclientside, enc, cipher, crcthencrypt;
{
	char		buf[MAKEIOBUF];
	register	todo, toread;
	struct timeval	first, second;
	struct timezone	tz;

	if (isclientside) {
		cprintf("xfering %d bytes, using %d bytes/hash mark:  ",
						size, sizeof(buf));
	}

	/* reset crc32 */
	crc32val = 0L;

	(void)gettimeofday(&first, &tz);

	todo = size;
	while (todo > 0) {
		toread = todo < sizeof(buf) ? todo : sizeof(buf);
		if (read_data(from, buf, toread) != toread) {
			return(1);
		}

		if (crcthencrypt) { /* from fle to network */
			UpdateCRC(buf, toread);
		}

		cryptbuf(buf, toread, enc, cipher, CLIENT_SIDE);

		if (!crcthencrypt) { /* from net to file */
			UpdateCRC(buf, toread);
		}

		if (write_data(to, buf, toread) != toread) {
			return(1);
		}

		todo -= toread;

		if (isclientside) {
			printf("#");
			fflush(stdout);
		}
		xfertraffic += toread;
	}

	(void)gettimeofday(&second, &tz);

	if (isclientside) {
		float	ratio;

		if (first.tv_usec > second.tv_usec) {
			second.tv_usec += 1000000;
			second.tv_sec--;
		}

		ratio = (float)size * (float)1000000;
		ratio /= (float)(second.tv_sec - first.tv_sec) *
						(float)1000000 +
			((float)(second.tv_usec - first.tv_usec));
		ratio /= (float)1024;

		printf("\r\n");
		fflush(stdout);
		cprintf("%d bytes received in %lu.%ld seconds (%.2f Kbytes/s)\r\n",
				size, 
				second.tv_sec - first.tv_sec,
				(second.tv_usec - first.tv_usec) / 10000L,
				ratio);
	}
	return(0);
}
@


1.113
log
@safety
@
text
@d3 3
a5 3
 * $Header: /users/vince/src/stel/RCS/makeio.c,v 1.112 1996/02/07 16:44:20 vince Exp $
 * $Date: 1996/02/07 16:44:20 $
 * $Revision: 1.112 $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: makeio.c,v 1.112 1996/02/07 16:44:20 vince Exp $";
d380 1
d417 1
d545 1
d550 1
d895 1
d909 1
d1028 1
d1043 1
@


1.112
log
@safety
@
text
@d3 3
a5 3
 * $Header: /home/vince/src/stel/RCS/makeio.c,v 1.111 1996/01/26 15:15:13 vince Exp $
 * $Date: 1996/01/26 15:15:13 $
 * $Revision: 1.111 $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: makeio.c,v 1.111 1996/01/26 15:15:13 vince Exp $";
d235 1
a235 1
#if defined(hpux) || defined(SOLARIS) || defined(IRIX) || defined(AIX)
d241 3
d246 1
d256 1
a256 1
#if defined(hpux) || defined(SOLARIS) || defined(IRIX) || defined(AIX)
d262 3
d267 1
@


1.111
log
@safety
@
text
@d3 4
a6 4
 * $Header: /res/usr/vince/src/stel-dist/stel/RCS/makeio.c,v 1.110 1996/01/05 09:53:56 vince Exp vince $
 * $Date: 1996/01/05 09:53:56 $
 * $Revision: 1.110 $
 * $Locker: vince $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: makeio.c,v 1.110 1996/01/05 09:53:56 vince Exp vince $";
d1062 11
@


1.110
log
@safety
@
text
@d3 3
a5 3
 * $Header: /res/usr/vince/src/stel-dist/stel/RCS/makeio.c,v 1.109 1996/01/03 18:20:26 vince Exp vince $
 * $Date: 1996/01/03 18:20:26 $
 * $Revision: 1.109 $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: makeio.c,v 1.109 1996/01/03 18:20:26 vince Exp vince $";
a42 3
#ifdef XFERLOG
#define XFER_CMD	"xfer"
#endif
a90 16
/* experimental xferlog stuff. disabled. */
#ifdef XFERLOG
static int		tobexfered;
static int		tobeskipped;
static char		xferfilename[256];
int			xferfh;
#define LOGIOERROR() \
{ \
	cprintf("%s: %s\n", xferfilename, sys_errlist[errno]); \
	tobexfered = 0; \
	return(1); \
}
#define MINUS_ONLCR	"stty -onlcr"
#define PLUS_ONLCR	"stty onlcr"
#endif /* XFERLOG */

a371 64
#ifdef XFERLOG
		/* this feature is experimental  */
		if (!strncmp(line, XFER_CMD, strlen(XFER_CMD))) {
			char	*p, *q, *r, *t;
			char	*linep;

			linep = line + strlen(XFER_CMD);
			if ((p = (char *)strtok(linep, " \t")) == NULL ||
			    (q = (char *)strtok(NULL, " \t")) == NULL ||
			    (r = (char *)strtok(NULL, " \t")) == NULL ||
			    (t = (char *)strtok(NULL, "\"")) == NULL) {
				printf("usage: %s bytenum extra-skip logfile commands\n",
								XFER_CMD);
				continue;
			}

			if ((tobexfered = atoi(p)) < 1) {
				printf("size should be > 0\n");
				continue;
			}

			if (atoi(q) < 0) {
				printf("skip cannot be negative\n");
				continue;
			}

			strncpy(xferfilename, r, sizeof(xferfilename));

			/* open file for writing */
			xferfh = open(xferfilename,
					O_WRONLY | O_TRUNC | O_CREAT, 0600);

			if (xferfh == -1) {
				perror(xferfilename);
				break;
			}


			sprintf(buf, "%s; %s; %s\n", 
				MINUS_ONLCR, t, PLUS_ONLCR);
			*len = strlen(buf);

			/* it seems that the number of characters to be
			skipped is machine dependent.  it is dependent,
			in fact, on the system you are connected to.
			*/
			tobeskipped = *len + atoi(q);

			if (tobeskipped >= tobexfered) {
				printf("xfer is to small!\n");
				continue;
			}

			buf[*len - 1] = '\0';
			cprintf("command is: ``%s''\n", buf);
			buf[*len - 1] = '\n';
			cprintf("it should produce %d bytes\n", tobexfered);
			cprintf("piping to %s, skipping first %d + %d bytes\n",
					xferfilename, tobeskipped, atoi(q));
			quit = -1;
			break;
		}
#endif /* XFERLOG */

d421 1
a421 1
				mode = "DISABLED: this session is insecure!";
a534 3
#ifdef XFERLOG
			printf("xfer	    *	experimental ftp surrogate\n");
#endif /* XFERLOG */
a1013 55
#ifdef XFERLOG
			/* xfer files. only client gets tobeskipped set */
			if (tobexfered) {
				int		still;
				char		*tmp, *data;

				data = p[i]->data;

				/* skip  the command itself */
				if (tobeskipped) {
					if (tobeskipped > p[i]->len) {
						tobeskipped -= p[i]->len;
						continue;
					}
					data += tobeskipped;
					p[i]->len -= tobeskipped;
					tobeskipped = 0;
				}

				/* write all buffer to file */
				if (tobexfered >= p[i]->len) {
					if (write(xferfh, data, p[i]->len) == -1) {
						LOGIOERROR();
					}
					tobexfered -= p[i]->len;
					if (!tobexfered)
						goto xfercompleted;
					continue;
				}
				
				/* write part of buffer to file */
				if (write(xferfh, data, tobexfered) == -1) {
					LOGIOERROR();
				}
				/* shift buffer */
				if ((tmp = (char *)malloc(p[i]->len)) == NULL) {
					LOGIOERROR();
				}
				memcpy(tmp, data, p[i]->len);
				still = p[i]->len - tobexfered;
				memcpy(data, tmp + tobexfered, still);
				free(tmp);
				p[i]->len = still;

xfercompleted:
				if (close(xferfh) == -1) {
					LOGIOERROR();
				}
				tobexfered = 0;
				cprintf("xfer completed (%s)\r\n",
							 xferfilename);
				continue;
			}
#endif /* XFERLOG */

a1514 2
	crc32tmp = ntohl(crc32tmp);

d1517 1
a1701 2
	crc32tmp = ntohl(crc32tmp);

d1704 1
@


1.109
log
@safety
@
text
@d3 3
a5 3
 * $Header: /res/usr/vince/src/stel/RCS/makeio.c,v 1.108 1996/01/02 16:41:03 vince Exp vince $
 * $Date: 1996/01/02 16:41:03 $
 * $Revision: 1.108 $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: makeio.c,v 1.108 1996/01/02 16:41:03 vince Exp vince $";
d974 1
a974 1
							cipher, comboflag);
a1019 1
		cipher = 0; /* use single des by default */
d1163 2
a1164 2
				ret = doserverftp(channel, cipher, p[i]->flag,
							username, remhostname);
d1489 1
a1489 1
doclientftp(net, in, out, cipher, mode)
d1491 1
a1491 1
int	net, cipher, mode;
d1509 1
a1509 1
	cryptbuf(buf, strlen(WHAT_ACK), DES_ENCRYPT, cipher, CLIENT_SIDE);
d1572 1
a1572 1
	cryptbuf(&cmd, sizeof(cmd), DES_ENCRYPT, cipher, CLIENT_SIDE);
d1594 1
a1594 1
	cryptbuf(&answer, sizeof(answer), DES_ENCRYPT, cipher, CLIENT_SIDE);
d1615 1
a1615 2
		if (streamcp(localfh, net, len, 1,
					DES_ENCRYPT, cipher, 1)) {
d1630 1
a1630 2
		if (streamcp(net, localfh, len, 1,
					DES_ENCRYPT, cipher, 0)) {
d1647 1
a1647 1
	cryptbuf(&crc32tmp, sizeof(crc32tmp), DES_ENCRYPT, cipher, CLIENT_SIDE);
d1659 1
a1659 1
	cryptbuf(&crc32tmp, sizeof(crc32tmp), DES_ENCRYPT, cipher, SERVER_SIDE);
d1668 1
a1668 1
doserverftp(net, cipher, mode, username, remhostname)
d1670 1
a1670 1
int	net, cipher, mode;
d1683 1
a1683 1
	cryptbuf(buf, strlen(WHAT_ACK), DES_DECRYPT, cipher, CLIENT_SIDE);
d1698 1
a1698 1
	cryptbuf(&cmd, sizeof(cmd), DES_DECRYPT, cipher, CLIENT_SIDE);
d1788 1
a1788 1
	cryptbuf(&answer, sizeof(answer), DES_DECRYPT, cipher, CLIENT_SIDE);
d1801 1
a1801 2
		if (streamcp(net, localfh, len, 0,
					DES_DECRYPT, cipher, 0)) {
d1816 1
a1816 2
		if (streamcp(localfh, net, len, 0,
					DES_DECRYPT, cipher, 1)) {
d1834 1
a1834 1
	cryptbuf(&crc32tmp, sizeof(crc32tmp), DES_DECRYPT, cipher, SERVER_SIDE);
d1847 1
a1847 1
	cryptbuf(&crc32tmp, sizeof(crc32tmp), DES_DECRYPT, cipher, CLIENT_SIDE);
@


1.108
log
@safety
@
text
@d3 3
a5 3
 * $Header: /res/usr/vince/src/stel/RCS/makeio.c,v 1.107 1995/12/26 19:22:18 vince Exp vince $
 * $Date: 1995/12/26 19:22:18 $
 * $Revision: 1.107 $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: makeio.c,v 1.107 1995/12/26 19:22:18 vince Exp vince $";
d223 1
a223 1
			char	buf[100];
d225 4
a228 3
			bzero(buf, sizeof(buf));
			if (read(authfh, buf, sizeof(buf)) != strlen(USRAUTH) ||
			    memcmp(buf, USRAUTH, strlen(USRAUTH))) {
d230 1
a230 1
					buf);
a264 1
	syslog(LOGPRI, "entering deadchild");
d692 1
a692 2
	cprintf("s/key %d %s\n", n, seed);
	cprintf("Enter secret password: ");
a1683 53
#if 0
	struct passwd	*pwd;
	int		status;

	if ((pwd = getpwnam(username)) == NULL) {
		syslog(LOGPRI, "XFER: %s: password error!", username);
		return(1);
	}

	(void)signal(SIGCLD, SIG_DFL);
	switch (fork()) {
		case	-1:
			syslog(LOGPRI, "XFER: fork(): %m");
			return(1);

		case	0:
			if (setgid(pwd->pw_gid) == -1 ||
			    setuid(pwd->pw_uid) == -1) {
				syslog(LOGPRI, "setuid(): %m");
				exit(1);
			}
			break;

		default	:
			while (wait3(&status, WNOHANG, NULL) > 0)
				;

			/*
			if (wait(&status) == -1) {
				syslog(LOGPRI, "XFER: wait(): %m");
				return(1);
			}
			*/
			(void)signal(SIGCLD, deadchild);


			if (WIFSIGNALED(status))
				return(1);
			else if (WIFEXITED(status)) {
				if (WEXITSTATUS(status) == 0)
					return(0);
				else if (WEXITSTATUS(status) == 1)
					return(1);
				else if (WEXITSTATUS(status) == 255)
					return(-1);
			}
			/* should never happen */
			syslog(LOGPRI, "XFER: wait() internal error (%d)!",
							WEXITSTATUS(status));
			return(1);
	}
#endif

d1812 1
a1812 1
			syslog("XFER: close(%s): %m", cmd.filename);
d1828 1
a1828 1
			syslog("XFER: close(%s): %m", cmd.filename);
@


1.107
log
@safety
@
text
@d3 3
a5 3
 * $Header: /res/usr/vince/src/stel/RCS/makeio.c,v 1.106 1995/12/26 17:00:58 vince Exp vince $
 * $Date: 1995/12/26 17:00:58 $
 * $Revision: 1.106 $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: makeio.c,v 1.106 1995/12/26 17:00:58 vince Exp vince $";
d23 1
d82 1
a82 1
static unsigned long	userstrokes, traffic;
d140 2
d263 2
d520 1
d1684 54
d1941 1
a1941 1
		if (crcthencrypt) /* from fle to network */
d1943 1
d1947 1
a1947 1
		if (!crcthencrypt) /* from net to file */
d1949 1
a1954 1

d1961 1
@


1.106
log
@safety
@
text
@d3 3
a5 3
 * $Header: /res/usr/vince/src/stel-dist/stel/RCS/makeio.c,v 1.105 1995/12/23 16:02:15 vince Exp vince $
 * $Date: 1995/12/23 16:02:15 $
 * $Revision: 1.105 $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: makeio.c,v 1.105 1995/12/23 16:02:15 vince Exp vince $";
d606 1
a606 1
			printf("skey, s/key 	generate skey response\n");
@


1.105
log
@safety
@
text
@d3 3
a5 3
 * $Header: /res/usr/vince/src/stel/RCS/makeio.c,v 1.104 1995/12/22 19:55:52 vince Exp vince $
 * $Date: 1995/12/22 19:55:52 $
 * $Revision: 1.104 $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: makeio.c,v 1.104 1995/12/22 19:55:52 vince Exp vince $";
d1558 3
d1601 3
d1642 1
a1642 1
	crc32tmp = crc32val;
d1654 2
d1706 3
d1775 3
d1830 1
a1830 1
	crc32tmp = crc32val;
d1842 2
@


1.104
log
@safety
@
text
@d3 3
a5 3
 * $Header: /res/usr/vince/src/stel/RCS/makeio.c,v 1.100 1995/12/21 18:00:21 vince Exp vince $
 * $Date: 1995/12/21 18:00:21 $
 * $Revision: 1.100 $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: makeio.c,v 1.100 1995/12/21 18:00:21 vince Exp vince $";
d1897 2
a1898 2
		ratio /= ((float)(second.tv_sec - first.tv_sec)) *
						((float)1000000) +
@


1.103
log
@safety
@
text
@d1606 1
a1606 1
					DES_ENCRYPT, cipher, CLIENT_SIDE)) {
d1616 1
a1616 2
		cprintf("Local file %s UPLOADED to %s (%ld bytes)\r\n",
							in, out, len);
d1622 1
a1622 1
					DES_ENCRYPT, cipher, CLIENT_SIDE)) {
d1632 1
a1632 2
		cprintf("Remote file %s DOWNLOADED to %s (%d bytes)\r\n",
							in, out, len);
d1785 1
a1785 1
					DES_DECRYPT, cipher, CLIENT_SIDE)) {
d1801 1
a1801 1
					DES_DECRYPT, cipher, CLIENT_SIDE)) {
d1840 2
a1841 2
streamcp(from, to, size, isclientside, enc, cipher, side)
int	from, to, size, isclientside, enc, cipher, side;
d1844 3
a1846 1
	register	toread;
d1849 2
a1850 2
		cprintf("xfering file, using %d bytes/hash mark:  ",
							sizeof(buf));
d1856 5
a1860 2
	while (size > 0) {
		toread = size < sizeof(buf) ? size : sizeof(buf);
d1865 7
a1871 1
		cryptbuf(buf, toread, enc, cipher, side);
a1876 1
		size -= toread;
d1878 1
a1878 1
		UpdateCRC(buf, toread);
d1886 16
a1901 1
	if (isclientside)
d1903 7
a1909 1

@


1.102
log
@safety
@
text
@d463 1
a463 1
					printf("usage: get localfile remotefile\n");
d465 1
a465 1
					printf("usage: put remotefile localfile\n");
d1605 2
a1606 1
		if (streamcp(localfh, net, len, 1)) {
d1622 2
a1623 1
		if (streamcp(net, localfh, len, 1)) {
d1654 1
d1786 2
a1787 1
		if (streamcp(net, localfh, len, 0)) {
d1802 2
a1803 1
		if (streamcp(localfh, net, len, 0)) {
d1836 1
d1842 2
a1843 2
streamcp(from, to, size, isclientside)
int	from, to, size, isclientside;
d1861 3
@


1.101
log
@safety
@
text
@a35 1
#include "md4.h"
d66 1
a66 1
/* control messages */
d69 4
d969 1
a969 1
						enc, cipher, comboflag);
d1159 2
a1160 2
				ret = doserverftp(channel, dec, cipher,
					p[i]->flag, username, remhostname);
d1485 1
a1485 1
doclientftp(net, in, out, enc, cipher, mode)
d1487 1
a1487 1
int	net, enc, cipher, mode;
d1495 2
d1504 2
a1505 2
	/* decrypt */
	cryptbuf(buf, strlen(WHAT_ACK), enc, cipher, CLIENT_SIDE);
a1517 1

d1559 7
a1565 2
	/* checksum */
	/* encrypt */
d1567 2
a1568 2
	/* write cmd to server.  if error occurred, let server
	know about it 
d1586 2
a1587 1
	/* decrypt */
d1589 8
a1596 7
	/*
	syslog(LOGPRI, "CLIENT: answer.answer: %ld\n", answer.answer);
	syslog(LOGPRI, "CLIENT: answer.size: %ld\n", answer.filesize);
	syslog(LOGPRI, "CLIENT: mode: %s", mode & COMBO_FLG_PUT ? "PUT" : "GET");
	syslog(LOGPRI, "CLIENT: len = %d", len);
	syslog(LOGPRI, "CLIENT: net = %d, localfh = %d", net, localfh);
	*/
d1635 18
a1652 3
	/*
	syslog(LOGPRI, "doclient exiting");
	*/
d1657 1
a1657 1
doserverftp(net, dec, cipher, mode, username, remhostname)
d1659 1
a1659 1
int	net, dec, cipher, mode;
d1667 2
a1668 1

a1669 1
	bzero(buf, sizeof(buf));
d1671 2
a1672 2
	cryptbuf(buf, strlen(buf), dec, cipher, SERVER_SIDE);
	if (write_data(net, WHAT_ACK, strlen(WHAT_ACK)) != strlen(WHAT_ACK)) {
d1680 2
a1681 1
		syslog(LOGPRI, "XFER: bad cmd from %s", remhostname);
d1685 2
a1686 2
	/* decrypt */
	/* check checksum */
d1688 8
a1695 5
	/*
	syslog(LOGPRI, "cmd.cmd: %d", cmd.cmd);
	syslog(LOGPRI, "cmd.filename: %s", cmd.filename);
	syslog(LOGPRI, "cmd.size: %ld", cmd.filesize);
	*/
d1764 7
a1770 1
	/* crypt */
a1777 7
	/*
	syslog(LOGPRI, "SERVER: mode: %s", mode & COMBO_FLG_PUT ? "PUT" : "GET");
	syslog(LOGPRI, "SERVER: len = %d", len);
	syslog(LOGPRI, "SERVER: net = %d, localfh = %d", net, localfh);
	syslog(LOGPRI, "SERVER: filename = %s", cmd.filename);
	*/

d1812 21
d1836 2
a1837 2
streamcp(from, to, size, echo)
int	from, to, size, echo;
d1842 1
a1842 1
	if (echo) {
d1847 3
d1858 1
d1860 4
a1863 1
		if (echo) {
d1869 1
a1869 1
	if (echo)
@


1.100
log
@safety
@
text
@d3 4
a6 4
 * $Header: /res/usr/vince/src/stel/RCS/makeio.c,v 1.99 1995/12/21 11:27:56 vince Exp $
 * $Date: 1995/12/21 11:27:56 $
 * $Revision: 1.99 $
 * $Locker:  $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: makeio.c,v 1.99 1995/12/21 11:27:56 vince Exp $";
a1479 29
/*
setonlcr(fh, mode)
int	fh;
int	mode;
{
	struct termios	x;

	if (tcgetattr(fh, &x) == -1) {
		syslog(LOGPRI, "tcgetattr(): %m");
		return(1);
	}

	if (!mode) {
		x.c_oflag &= ~ONLCR;
		x.c_lflag &= ~ECHO;
	}
	else {
		x.c_oflag |= ONLCR;
		x.c_lflag |= ECHO;
	}
	
	if (tcsetattr(fh, TCSANOW, &x) == -1) {
		syslog(LOGPRI, "tcsetattr(): %m");
		return(1);
	}

	return(0);
}
*/
d1500 1
d1631 1
a1631 1
doserverftp(net, enc, cipher, mode, username, remhostname)
d1633 1
a1633 1
int	net, enc, cipher, mode;
d1643 3
@


1.99
log
@safety
@
text
@d3 4
a6 4
 * $Header: /res/usr/vince/src/stel/RCS/makeio.c,v 1.96 1995/12/20 18:33:49 vince Exp vince $
 * $Date: 1995/12/20 18:33:49 $
 * $Revision: 1.96 $
 * $Locker: vince $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: makeio.c,v 1.96 1995/12/20 18:33:49 vince Exp vince $";
d167 3
a169 1
		if (authfh >= 0 && firstack & FLG_ACTIVE_ATTACKS)
d171 1
d222 6
a227 1
				syslog(LOGPRI, "bad authentication channel!");
d1632 1
a1632 1
		cprintf("Local file %s uploaded to %s (%ld bytes)\r\n",
d1648 1
a1648 1
		cprintf("Remote file %s downloaded to %s (%d bytes)\r\n",
@


1.98
log
@safety
@
text
@d167 1
a167 1
		if (authfh >= 0)
d440 3
a442 2
		if (!strncmp(line, GET_CMD, strlen(GET_CMD)) ||
		    !strncmp(line, PUT_CMD, strlen(PUT_CMD))) {
d591 6
a596 6
			printf("Commands marked with ``*'' may support arguments.\n");
			printf("Commands may be abbreviated.  Commands are:\n\n");
			printf("close quit ^D	close current connection\n");
			printf("return 	CR	return to remote system\n");
			printf("s[/]key *	generate skey response\n");
			printf("autoskey	generate and xmit skey response\n");
d598 3
a600 3
			printf("escape *	set escape character\n");
			printf("sendesc		xmit escape character itself\n");
			printf("log *		log to file\n");
d602 1
a602 1
			printf("xfer *		experimental ftp surrogate\n");
d604 5
a608 3
			printf("put *		upload a file\n");
			printf("get *		download a file\n");
			printf("! *		shell escape\n");
d674 2
a675 1
	cprintf("[s/key %d %s]\n", n, seed);
d954 2
a955 1
		if (comboflag & COMBO_FLG_GET || comboflag & COMBO_FLG_PUT) {
d1140 3
a1142 5
			if (p[i]->flag & COMBO_FLG_GET) {
				syslog(LOGPRI, "DUMP: `%s'", p[i]->data);
			}

			if ((p[i]->flag & COMBO_FLG_GET ||
d1144 1
a1144 1
			    /* this is a double check */
@


1.97
log
@safety
@
text
@d1135 4
@


1.96
log
@safety
@
text
@d3 3
a5 3
 * $Header: /res/usr/vince/src/stel-dist/stel/RCS/makeio.c,v 1.95 1995/12/19 14:39:00 vince Exp vince $
 * $Date: 1995/12/19 14:39:00 $
 * $Revision: 1.95 $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: makeio.c,v 1.95 1995/12/19 14:39:00 vince Exp vince $";
a108 1
#define USRAUTH		"userauthenticated"
d119 2
a120 1
makeio(in, out, channel, firstack, remhostname, old, new, timeout, authfh, username)
d181 1
a181 1
					if (remhostname)
d203 1
a203 1
			ret = doinput(in, channel, buf, firstack,
d209 2
a210 2
			ret = dochannel(channel, out, buf, firstack,
						remhostname, username, timeout);
d213 1
a213 1
		else if (authfh >= 0 && mask & (1 << authfh)) {
a335 1
			cprintf("skey challenge detected, generating response\n");
d590 1
a590 1
			printf("Commands marked with ``*'' support arguments.\n");
d595 1
a595 1
			printf("autoskey	generate and automatically xmit skey response\n");
d603 2
a604 2
			printf("put *		download a file\n");
			printf("get *		upload a file\n");
d671 2
a672 2
	cprintf("s/key %d %s: secret password: ", n, seed);
	(void)fflush(stdout);
a714 1
			(void)fflush(stdout);
d838 5
a842 6
doinput(in, channel, buf, firstack, remhostname, old, new)
int	in, channel;
char	*buf;
int	firstack;
char	*remhostname;
struct termios	*old, *new;
d845 1
d847 1
d851 1
d853 1
d883 2
a884 1
	if (remhostname && len == 1 && /* prevent accidental triggering */
d953 1
a953 1
					enc, cipher, side, comboflag);
d977 1
a977 1
dochannel(channel, out, buf, firstack, remhostname, timeout, username)
d980 1
a980 1
int	firstack;
d987 1
a987 1
	register		i, len, side;
d990 3
a992 2
	/* inverted */
	side = remhostname ? SERVER_SIDE : CLIENT_SIDE;
d1021 1
a1021 1
		if (remhostname && firstack & FLG_DEBUG) {
d1027 1
a1027 1
		cryptbuf(buf, len, dec, cipher, side);
d1040 1
a1040 1
				if (remhostname)
d1063 1
a1063 1
				if (remhostname)
d1140 2
a1141 1
				ret = doserverftp(channel, dec, cipher, side,
d1174 1
a1174 1
		if (remhostname && firstack & FLG_DEBUG) {
d1180 1
a1180 1
		cryptbuf(buf, len, dec, cipher, side);
d1194 1
a1194 1
	if (remhostname == NULL && timeout) {
d1496 1
a1496 1
doclientftp(net, in, out, enc, cipher, side, mode)
d1498 1
a1498 1
int	net, enc, cipher, side, mode;
d1644 1
a1644 2
doserverftp(net, enc, cipher, side, mode, username, remhostname)
int	net, enc, cipher, side, mode;
d1646 1
a1654 4
	/* mettere logging + esteso con username & hostname */
	/* impementare change uid con getpwnam... usare setresuid() */
	/* .... */

d1657 2
a1658 1
		syslog(LOGPRI, "XFER: error sending WHAT_ACK to client");
d1664 1
a1664 1
		syslog(LOGPRI, "XFER: bad cmd from client");
d1683 1
a1683 1
		syslog(LOGPRI, "XFER: bad command from client");
d1693 2
a1694 1
		syslog(LOGPRI, "XFER %s ATTEMPTED to %s %s not authenticated, from %s!",
d1699 1
a1699 1
		strncpy(answer.message, "user not authenticated",
d1708 2
a1709 1
			syslog(LOGPRI, "XFER GET: %s: %m", cmd.filename);
d1718 2
a1719 1
			syslog(LOGPRI, "XFER GET: %s: %m", cmd.filename);
d1731 2
a1732 1
			syslog(LOGPRI, "XFER PUT: %s: %m", cmd.filename);
d1747 1
a1747 1
		syslog(LOGPRI, "XFER: error sending answer to client");
d1765 2
a1766 1
			syslog(LOGPRI, "XFER: storing %s: %m", cmd.filename);
d1774 2
a1775 2
		syslog(LOGPRI, "%s UPLOADED (%d bytes)",
						cmd.filename, len);
d1780 2
a1781 1
			syslog(LOGPRI, "XFER: sending %s: %m", cmd.filename);
d1789 2
a1790 1
		syslog(LOGPRI, "%s DOWNLOADED (%d bytes)", cmd.filename, len);
a1792 4
	/*
	syslog(LOGPRI, "doserver exiting");
	*/

d1802 4
a1805 2
	if (echo)
		cprintf("using %d bytes/hash mark\r\n", sizeof(buf));
d1816 1
a1816 1
		if (echo)
d1818 2
a1819 1
		fflush(stdout);
@


1.95
log
@safety
@
text
@d3 3
a5 3
 * $Header: /res/usr/vince/src/stel-dist/stel/RCS/makeio.c,v 1.92 1995/12/16 15:48:11 vince Exp vince $
 * $Date: 1995/12/16 15:48:11 $
 * $Revision: 1.92 $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: makeio.c,v 1.92 1995/12/16 15:48:11 vince Exp vince $";
d41 1
a41 1
#define SKEY_CMD2	"s/key"
d43 1
d45 1
d79 1
d84 2
a85 1
/* xfer stuff */
a87 1
static int		combobindport;
d89 3
d96 14
a109 2
static char		fromftpfile[256];
static char		toftpfile[256];
a118 10
#define LOGIOERROR() \
{ \
	fprintf(stderr, "%s[%d]: %s: %s\n", PRGNAME, getpid(), \
					xferfilename, sys_errlist[errno]); \
	tobexfered = 0; \
	return(1); \
}
#define MINUS_ONLCR	"stty -onlcr"
#define PLUS_ONLCR	"stty onlcr"

d120 2
a121 2
makeio(in, out, channel, firstack, remhostname, old, new, timeout)
int		in, out, channel;
d123 1
a123 1
char		*remhostname;
d166 3
d182 1
a182 2
						printf("%s[%d]: session timeout\r\n",
							PRGNAME, getpid());
d210 14
a223 1
						remhostname, timeout);
d225 1
d288 2
a289 1
		printf("\n%s[%d]> ", PRGNAME, getpid());
d318 1
a318 1
		    !strncmp(line, SKEY_CMD2, strlen(SKEY_CMD2))) {
d322 1
a322 2
				printf("%s[%d]: skey response: %s\n",
						PRGNAME, getpid(), p);
d332 1
a332 2
				printf("\r\n%s[%d]: no skey challenge found\r\n",
							PRGNAME, getpid());
d336 1
a336 2
			printf("%s[%d]: skey challenge detected, generating response\n",
							PRGNAME, getpid());
d376 1
d430 1
a430 2
			printf("%s[%d]: command is: ``%s''\n",
						PRGNAME, getpid(), buf);
d432 3
a434 5
			printf("%s[%d]: it should produce %d bytes\n",
						PRGNAME, getpid(), tobexfered);
			printf("%s[%d]: piping to %s, skipping first %d + %d bytes\n",
				PRGNAME, getpid(),
				xferfilename, tobeskipped, atoi(q));
d438 1
d443 1
a443 1
			char	*p, *q, *linep;
d445 3
d451 4
a454 2
				printf("usage: %s remote-file local-file\n",
								GET_CMD);
d459 2
a460 2
			strncpy(fromftpfile, p, strlen(p));
			strncpy(toftpfile, q, strlen(q));
d462 3
d470 1
a470 2
			comboflag |= !strncmp(line, GET_CMD, strlen(GET_CMD)) ?
				COMBO_FLG_GET : COMBO_FLG_PUT;
a471 3
			syslog(LOGPRI, "PUT/GET: from %s to %s",
						fromftpfile, toftpfile);

d601 1
a601 1
			/*
d603 3
a605 1
			*/
d636 2
a637 3
	printf(
"%s[%d]: Reminder: do not use this while logged in via telnet or dial-in\n",
							PRGNAME, getpid());
d643 2
a644 2
	else if (!strncmp(line, SKEY_CMD2, strlen(SKEY_CMD2)))
		line += strlen(SKEY_CMD2); /* skip the first word */
d647 1
a647 1
		printf("%s[%d]: sequence number, seed: ", PRGNAME, getpid());
d650 1
a650 1
			fprintf(stderr,"%s[%d]: EOF\n", PRGNAME, getpid());
d657 1
a657 1
			fprintf(stderr,"%s[%d]: no input?\n", PRGNAME, getpid());
d663 1
a663 2
		fprintf(stderr,"%s[%d]: %d not positive\n",
						PRGNAME, getpid(), n);
d668 1
a668 1
		fprintf(stderr,"%s[%d]: no seed provided?\n", PRGNAME, getpid());
d672 1
a672 2
	printf("%s[%d]: s/key %d %s: secret password: ",
				PRGNAME, getpid(), n, seed);
d693 1
a693 2
		fprintf(stderr,"%s[%d]: no password provided\n",
						PRGNAME, getpid());
d709 3
a711 4
			printf("%s[%d]: (using mjr DES padding mode)\n",
							PRGNAME, getpid());
			printf("%s[%d]: using skeypadfile %s\n",
				PRGNAME, getpid(), getenv("SKEYPADFILE"));
d715 1
a715 2
			printf("%s[%d]: use mjr DES padding mode ? ",
							PRGNAME, getpid());
d718 1
a718 2
				fprintf(stderr,"%s[%d]: EOF\n",
							PRGNAME, getpid());
d730 1
a730 1
		fprintf(stderr,"%s[%d]: key crunch failed\n", PRGNAME, getpid());
d891 1
a891 2
		printf("%s[%d]: Returning to remote\r\n",
					PRGNAME, getpid());
d950 1
a950 1
			ret = doclientftp(channel, fromftpfile, toftpfile,
d953 1
a953 1
				printf("%s[%d]: file xfer failed\r\n");
d975 1
a975 1
dochannel(channel, out, buf, firstack, remhostname, timeout)
d979 1
a979 1
char	*remhostname;
d1019 1
a1019 2
			printf("%d[%s]: hexdump buffer %d bytes: ",
						getpid(), PRGNAME, len);
d1038 1
a1038 2
					printf("%s[%d]: DATA OUT OF ORDER, possible active attack!\n\r",
						PRGNAME, getpid());
d1061 1
a1061 2
					printf("%s[%d]: GARBLED DATA, possible active attack!\n\r",
						PRGNAME, getpid());
d1068 1
a1068 3
					printf("%s[%d]: %s: %s\r\n",
						PRGNAME,
						getpid(),
d1077 1
d1126 2
a1127 2
				printf("%s[%d]: xfer completed (%s)\r\n",
					PRGNAME, getpid(), xferfilename);
d1130 1
d1138 1
a1138 1
								p[i]->flag);
d1171 1
a1171 2
			printf("%d[%s]: hexdump buffer %d bytes: ",
						getpid(), PRGNAME, len);
d1491 2
a1492 2
/* client reads (blocks) first */
doclientftp(fh, in, out, enc, cipher, side, mode)
d1494 1
a1494 1
int	fh, enc, cipher, side, mode;
d1500 1
a1500 1
	int		fhhh, len;
a1502 2
	syslog(LOGPRI, "debug: %s %s", in, out);

d1504 2
a1505 2
	if (read_data(fh, buf, strlen(WHAT_ACK)) != strlen(WHAT_ACK)) {
		syslog(LOGPRI, "bad WHAT_ACK from server");
d1513 1
a1513 1
		syslog(LOGPRI, "corrupted WHAT_ACK from server");
d1517 2
a1521 2
	/* set filename */
	strncpy(cmd.filename, in, sizeof(cmd.filename));
d1523 2
a1524 2
	/* set size when putting */
	if (mode | COMBO_FLG_PUT) {
d1527 3
d1531 2
a1532 3
			syslog(LOGPRI, "put: %s: %m", in);
			printf("%s[%d]: PUT failed: %s: %s\n",
				PRGNAME, getpid(), in, sys_errlist[errno]);
d1535 1
a1535 1
		cmd.filesize = (unsigned long)sbuf.st_size;
d1537 3
a1539 4
		if ((fhhh = open(in, O_RDONLY)) == -1) {
			syslog(LOGPRI, "put: %s: %m", in);
			printf("%s[%d]: PUT failed: %s: %s\n",
				PRGNAME, getpid(), in, sys_errlist[errno]);
d1543 6
a1548 1
	else if (mode | COMBO_FLG_GET) {
d1551 1
a1551 1
		if ((fhhh = open(out, O_WRONLY | O_CREAT | O_TRUNC,
d1553 2
a1554 3
			syslog(LOGPRI, "get: %s: %m", out);
			printf("%s[%d]: GET failed: %s: %s\n",
				PRGNAME, getpid(), out, sys_errlist[errno]);
d1558 1
a1558 1
	else {
a1559 1
	}
a1563 2
	len = cmd.filesize;

d1570 3
a1572 3
	if (write_data(fh, &cmd, sizeof(cmd)) != sizeof(cmd)) {
		syslog(LOGPRI, "error sending cmd to server");
		close(fhhh);
d1576 3
a1578 2
	if (error)
		return(-1); /* error getrs handled */
d1580 3
a1582 3
	if (read_data(fh, &answer, sizeof(answer)) != sizeof(answer)) {
		syslog(LOGPRI, "bad answer from server");
		close(fhhh);
d1588 12
a1599 2
	syslog(LOGPRI, "answer.answer: %ld\n", answer.answer);
	syslog(LOGPRI, "answer.size: %ld\n", answer.filesize);
d1601 6
a1606 5
	/* copy file to network */
	if (mode | COMBO_FLG_PUT) {
		if (streamcp(fh, fhhh, len)) {
			syslog(LOGPRI, "%s upload: %m", in);
			(void)close(fhhh);
d1609 2
a1610 2
		if (close(fhhh) == -1) {
			syslog("close(%s): %m", in);
d1613 2
a1614 2
		printf("%s[%d]: %s uploaded to %s\r\n",
						PRGNAME, getpid(), in, out);
d1616 7
a1622 5
	/* copy network to file */
	else if (mode | COMBO_FLG_GET) {
		if (streamcp(fhhh, fh, len)) {
			syslog(LOGPRI, "%s download: %m", out);
			(void)close(fhhh);
d1625 2
a1626 2
		if (close(fhhh) == -1) {
			syslog("close(%s): %m", out);
d1629 2
a1630 2
		printf("%s[%d]: %s downloaded to %s\r\n",
						PRGNAME, getpid(), in, out);
d1633 4
d1640 3
a1642 2
doserverftp(fh, enc, cipher, side, mode)
int	fh, enc, cipher, side, mode;
d1648 1
a1648 1
	int		fhhh;
d1651 3
a1653 1
	/* fork(?), change uid */
d1656 2
a1657 2
	if (write_data(fh, WHAT_ACK, strlen(WHAT_ACK)) != strlen(WHAT_ACK)) {
		syslog(LOGPRI, "error sending WHAT_ACK to client");
d1662 2
a1663 2
	if (read_data(fh, &cmd, sizeof(cmd)) != sizeof(cmd)) {
		syslog(LOGPRI, "bad cmd from client");
d1670 1
d1674 1
d1682 1
a1682 1
		syslog(LOGPRI, "bad command from client");
d1686 16
a1701 2
	answer.answer = 0; /* ok by default */
	if (mode | COMBO_FLG_GET) {
d1706 1
a1706 1
			syslog(LOGPRI, "%s: %m", cmd.filename);
d1708 2
d1712 1
a1712 1
		answer.filesize = (unsigned long)sbuf.st_size;
d1714 4
a1717 2
		if ((fhhh = open(cmd.filename, O_RDONLY)) == -1) {
			syslog(LOGPRI, "get: %s: %m", cmd.filename);
d1721 3
a1723 1
	else {
d1725 1
a1725 1
		if ((fhhh = open(cmd.filename, O_WRONLY | O_CREAT | O_TRUNC,
d1727 3
a1729 1
			syslog(LOGPRI, "get: %s: %m", cmd.filename);
d1733 2
d1741 2
a1742 2
	if (write_data(fh, &answer, sizeof(answer)) != sizeof(answer)) {
		syslog(LOGPRI, "error sending answer to client");
d1746 8
d1758 4
a1761 4
	if (mode | COMBO_FLG_PUT) {
		if (streamcp(fh, fhhh, len)) {
			syslog(LOGPRI, "storing %s: %m", cmd.filename);
			(void)close(fhhh);
d1764 2
a1765 2
		if (close(fhhh) == -1) {
			syslog("close(%s): %m", cmd.filename);
d1768 2
a1769 1
		syslog(LOGPRI, "%s uploaded", cmd.filename);
d1772 4
a1775 4
	else if (mode | COMBO_FLG_GET) {
		if (streamcp(fhhh, fh, len)) {
			syslog(LOGPRI, "sending %s: %m", cmd.filename);
			(void)close(fhhh);
d1778 2
a1779 2
		if (close(fhhh) == -1) {
			syslog("close(%s): %m", cmd.filename);
d1782 1
a1782 1
		syslog(LOGPRI, "%s downloaded\r\n", cmd.filename);
d1785 4
d1792 2
a1793 2
streamcp(from, to, size)
int	from, to, size;
d1798 4
a1801 1
	do {
d1803 1
a1803 1
		if (read_data(from, buf, toread)) != toread)
d1805 2
a1806 1
		if (write_data(to, buf, toread) != toread)
d1808 1
d1810 7
a1816 1
	} while (size > 0);
@


1.94
log
@safety
@
text
@d1481 1
a1481 1
	char		buf[MAKEIOBUF];
d1485 1
a1485 1
	int		fhhh;
d1547 2
d1575 1
a1575 1
	/* doio */
d1577 26
a1602 1
		while ((len = read(buf
d1610 1
a1610 1
	char		buf[MAKEIOBUF];
d1687 44
a1730 1
	/* doio */
@


1.93
log
@safety
@
text
@d15 1
d44 2
d90 2
d420 27
a446 5
		if (!strncmp(line, "pota", strlen(line))) {
			*len = strlen("ptototototototottotoaoaoaoaoaa");
			strcpy(buf, "ptototototototottotoaoaoaoaoaa");
			buf[*len - 1] = '\n';
			comboflag |= COMBO_FLG_GET;
d919 3
a921 1
		/* send it */
a926 3
		if (comboflag &= COMBO_FLG_GET) {
			char	buf[100];
			comboflag &= ~COMBO_FLG_GET; /* reset flag */
d928 9
a936 3
			if (read_data(channel, buf, sizeof(buf)) != sizeof(buf)) {
				syslog(LOGPRI, "write_data(pota)");
				return(1);
d938 2
a939 2
			cryptbuf(buf, 100, enc, cipher, side);
			syslog(LOGPRI, "client: received message from server: %s", buf);
a940 9
			bzero(buf, sizeof(buf));
			strcpy(buf, "CIAO SERVER, TI SENTO!");
			syslog(LOGPRI, "client: sending ack to server: %s", buf);
			cryptbuf(buf, 100, enc, cipher, side);
			if (write_data(channel, buf, sizeof(buf)) != sizeof(buf)) {
				syslog(LOGPRI, "write_data(pota)");
				return(1);
			}
		}
d1116 9
a1124 17
			if (p[i]->flag & COMBO_FLG_GET) {
				char	buf[100];
				syslog(LOGPRI, "received COMBO_FLG_GET: %s (%d)", p[i]->data, p[i]->seq);
				bzero(buf, sizeof(buf));
				strcpy(buf, "CIAO CLIENT, MI SENTI?!");
				syslog(LOGPRI, "server: sending message to client: %s", buf);
				cryptbuf(buf, 100, dec, cipher, side);
				if (write_data(channel, buf, sizeof(buf)) != sizeof(buf)) {
					syslog(LOGPRI, "write_data(pota)");
					return(1);
				}
				if (read_data(channel, buf, sizeof(buf)) != sizeof(buf)) {
					syslog(LOGPRI, "write_data(pota)");
					return(1);
				}
				cryptbuf(buf, 100, dec, cipher, side);
				syslog(LOGPRI, "server: received message from client: %s", buf);
a1125 1
				
d1475 189
@


1.92
log
@safety
@
text
@d3 3
a5 3
 * $Header: /res/usr/vince/src/stel/RCS/makeio.c,v 1.91 1995/12/15 17:40:24 vince Exp vince $
 * $Date: 1995/12/15 17:40:24 $
 * $Revision: 1.91 $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: makeio.c,v 1.91 1995/12/15 17:40:24 vince Exp vince $";
d21 1
d80 2
a81 1
static int		comboflag;
d349 1
a385 7
			/*
			*len = strlen(t) + 1;
			strcpy(buf, t);
			buf[strlen(t)] = '\n';
			buf[strlen(t) + 1] = '\0';
			*/

a392 2
			the xfer feature is highly experimental, and feedbak
			is welcome!
d414 10
d549 1
d551 1
d620 2
a621 1
	printf("%s[%d]: secret password: ", PRGNAME, getpid());
d871 1
a871 1
		set.seq = sequence;
d873 1
a873 1
		set.flag = comboflag;
d875 2
a876 2
		set.crc32 = crc32val;
		set.len = len;
d898 20
d1026 1
a1026 1
			/* log to file */
d1040 1
a1040 1
			/* xfer files */
d1093 21
d1245 1
d1252 1
d1264 1
d1276 1
@


1.91
log
@safety
@
text
@d3 3
a5 3
 * $Header: /res/usr/vince/src/stel/RCS/makeio.c,v 1.90 1995/12/15 17:32:38 vince Exp vince $
 * $Date: 1995/12/15 17:32:38 $
 * $Revision: 1.90 $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: makeio.c,v 1.90 1995/12/15 17:32:38 vince Exp vince $";
d41 1
a41 1
#define XFER_CMD	"ftp"
d77 1
a77 1
/* ftp stuff */
d101 2
d356 1
a356 1
				printf("usage: %s bytenum xskip logfile commands\n",
a357 1
				printf("notice: should do a \"stty -onlcr\" to the remote $hell\n");
d383 1
d388 5
d397 2
a398 1
			the ftp feature is highly experimental!
d407 9
a415 3
			printf("piping %d bytes to %s, skipping %d command bytes\n",
					tobexfered, xferfilename, tobeskipped);

d545 1
a545 1
			printf("ftp *		ftp surrogate\n");
d1061 2
a1062 2
				printf("%s[%d]: xfer completed\r\n",
							PRGNAME, getpid());
@


1.90
log
@safety
@
text
@d3 3
a5 3
 * $Header: /res/usr/vince/src/stel/RCS/makeio.c,v 1.89 1995/12/15 16:36:17 vince Exp vince $
 * $Date: 1995/12/15 16:36:17 $
 * $Revision: 1.89 $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: makeio.c,v 1.89 1995/12/15 16:36:17 vince Exp vince $";
d354 1
a354 1
				printf("use: %s size xskip logfile commands\n",
d356 1
a356 1
				printf("do a \"stty -onlcr\" to the shell\n");
@


1.89
log
@safety
@
text
@d3 3
a5 3
 * $Header: /res/usr/vince/src/stel-dist/stel/RCS/makeio.c,v 1.88 1995/12/14 13:05:44 vince Exp vince $
 * $Date: 1995/12/14 13:05:44 $
 * $Revision: 1.88 $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: makeio.c,v 1.88 1995/12/14 13:05:44 vince Exp vince $";
d346 1
a346 1
			char	*p, *q, *t;
d352 1
d354 1
a354 1
				printf("usage: %s size logfile commands\n",
d356 1
a363 1
			strncpy(xferfilename, q, sizeof(xferfilename));
d365 7
d387 6
a392 1
			tobeskipped = *len + 2; /* \r\n */
d398 3
@


1.88
log
@safety
@
text
@d3 3
a5 3
 * $Header: /res/usr/vince/src/stel-dist/stel/RCS/makeio.c,v 1.86 1995/12/14 10:36:13 vince Exp vince $
 * $Date: 1995/12/14 10:36:13 $
 * $Revision: 1.86 $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: makeio.c,v 1.86 1995/12/14 10:36:13 vince Exp vince $";
d40 2
a41 1
#define CAPTURE_CMD	"cap"
d73 12
a84 1
static int		tobecaptured, tobeskipped;
d88 3
d94 8
a112 1
	extern int	errno;
d318 49
a366 2
		if (!strncmp(line, CAPTURE_CMD, strlen(CAPTURE_CMD))) {
			char	*p;
d368 2
a369 8
			p = (char *)strtok(line + strlen(CAPTURE_CMD), "\t ");
			tobecaptured = atoi(p);
			p = (char *)strtok(NULL, "\"");

			printf("***** tobecaptured = %d\n", tobecaptured);
			printf("***** command = `%s'\n", p);
			if (tobecaptured < 0 || p == NULL) {
				printf("capture failed\n");
a372 1
			tobeskipped = strlen(p);
d374 11
a384 4
			*len = strlen(p) + 1;
			strcpy(buf, p);
			buf[strlen(p)] = '\n';
			buf[strlen(p) + 1] = '\0';
a389 1

d418 2
d505 1
d508 2
a509 3
			printf("return CR	return to remote system\n");
			printf("%s %s	generate skey response\n",
							SKEY_CMD, SKEY_CMD2);
d512 1
a512 2
			printf("%s		set escape character\n",
								ESCAPE_CMD);
d514 3
a516 1
			printf("!		shell escape\n");
d822 3
d835 3
d969 16
a984 2
			if (remhostname && tobecaptured > 0) {
				char		*tmp;
d986 1
a986 2
				static int	first, fh;
				static char	*fn;
d988 1
a988 11
				if (!first) {
					fn = tmpnam(NULL);
					fh = open(fn, O_WRONLY | O_CREAT, 0600);
					if (fh == -1) {
						perror(fn);
						return(1);
					}
					first = 1;
					printf("%s[%d]: saving to %s\r\n", PRGNAME, getpid(), fn);
					fflush(stdout);
				}
d990 1
d992 1
a992 1
					if (p[i]->len <= tobeskipped) {
d996 1
a996 9

					if ((tmp = (char *)malloc(p[i]->len)) == NULL) {
						perror("malloc()");
						return(1);
					}

					memcpy(tmp,  p[i]->data, p[i]->len);
					memcpy(p[i]->data, tmp + tobeskipped, p[i]->len - tobeskipped);
					free(tmp);
d1001 4
a1004 4
				if (tobecaptured >=  p[i]->len) {
					if (write(fh, p[i]->data, p[i]->len) == -1) {
						perror("write()");
						return(1);
d1006 3
a1008 3
					printf("%s[%d]: wrote %d bytes\r\n", PRGNAME, getpid(), p[i]->len);
					fflush(stdout);
					tobecaptured -= p[i]->len;
d1011 4
a1014 4

				if (write(fh, p[i]->data, tobecaptured) == -1) {
					perror("write()");
					return(1);
d1016 1
a1016 3
				printf("%s[%d]: wrote last %d bytes\r\n", PRGNAME, getpid(), tobecaptured);
				fflush(stdout);
				
d1018 1
a1018 2
					perror("malloc()");
					return(1);
d1020 3
a1022 3
				memcpy(tmp,  p[i]->data, p[i]->len);
				p[i]->len -= tobecaptured;
				memcpy(p[i]->data, tmp + tobecaptured, p[i]->len);
d1024 1
d1026 3
a1028 5
				tobecaptured = 0;
				first = 0;
				if (close(fh) == -1) {
					perror("close()");
					return(1);
d1030 4
a1033 2
				printf("%s[%d]: saved to %s\r\n", PRGNAME, getpid(), fn);
				fflush(stdout);
d1037 2
a1038 1
			if (write_data(out, p[i]->data, p[i]->len) != p[i]->len) {
d1045 3
a1047 2
			generation */
				storeskeybuf(p[i]->data, p[i]->len);
d1103 3
d1110 3
d1145 3
d1163 11
a1173 1
			memcpy(&dataseq, intbuf + readoffset, sizeof(dataseq));
d1177 7
a1183 2
				intbuf + readoffset + sizeof(dataseq),
				sizeof(datacrc32));
d1187 8
a1194 2
				intbuf + readoffset + sizeof(dataseq) + sizeof(datacrc32),
				sizeof(datalen));
d1198 3
d1207 3
d1219 3
d1245 5
d1263 2
a1264 1
			memcpy(x->data, intbuf + readoffset +
d1267 3
d1298 3
d1311 3
d1330 3
d1338 3
d1349 30
@


1.87
log
@safety
@
text
@d14 1
d40 1
d72 1
d296 20
a315 3
		if (!strncmp(line, "capture", strlen(line))) {
			strcpy(buf, "/bin/who | grep vince\n\r");
			*len += strlen("/bin/who | grep vince\n\r");
d812 1
d892 73
d974 1
a974 1
			storeskeybuf(p[i]->data, p[i]->len);
@


1.86
log
@safety
@
text
@d3 3
a5 3
 * $Header: /res/usr/vince/src/stel-dist/stel/RCS/makeio.c,v 1.85 1995/12/08 16:07:06 vince Exp vince $
 * $Date: 1995/12/08 16:07:06 $
 * $Revision: 1.85 $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: makeio.c,v 1.85 1995/12/08 16:07:06 vince Exp vince $";
d292 9
@


1.85
log
@safety
@
text
@d3 4
a6 4
 * $Header: /res/usr/vince/src/stel-dist/stel/RCS/makeio.c,v 1.84 1995/12/05 16:54:26 vince Exp $
 * $Date: 1995/12/05 16:54:26 $
 * $Revision: 1.84 $
 * $Locker:  $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: makeio.c,v 1.84 1995/12/05 16:54:26 vince Exp $";
d181 1
a181 1
#if defined(hpux) || defined(SOLARIS) || defined(IRIX)
d197 1
a197 1
#if defined(hpux) || defined(SOLARIS) || defined(IRIX)
@


1.84
log
@safety
@
text
@d3 4
a6 4
 * $Header: /res/usr/vince/src/stel/RCS/makeio.c,v 1.83 1995/12/05 15:36:22 vince Exp vince $
 * $Date: 1995/12/05 15:36:22 $
 * $Revision: 1.83 $
 * $Locker: vince $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: makeio.c,v 1.83 1995/12/05 15:36:22 vince Exp vince $";
d181 1
a181 1
#if defined(hpux) || defined(SOLARIS)
d197 1
a197 1
#if defined(hpux) || defined(SOLARIS)
@


1.83
log
@safety
@
text
@d3 3
a5 3
 * $Header: /res/usr/vince/src/stel/RCS/makeio.c,v 1.82 1995/12/04 16:44:11 vince Exp vince $
 * $Date: 1995/12/04 16:44:11 $
 * $Revision: 1.82 $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: makeio.c,v 1.82 1995/12/04 16:44:11 vince Exp vince $";
d833 2
a834 3
					printf("%s[%d]: DATA OUT OF ORDER, possible active attack! packet #%lu expected, #%lu received\n\r",
						PRGNAME, getpid(),
						sequence, p[i]->seq);
d847 1
d855 1
d954 1
d956 1
d965 1
d967 1
d1008 1
d1011 1
d1052 1
a1055 1
		/*
@


1.82
log
@safety
@
text
@d3 3
a5 3
 * $Header: /res/usr/vince/src/stel/RCS/makeio.c,v 1.81 1995/12/04 16:36:21 vince Exp vince $
 * $Date: 1995/12/04 16:36:21 $
 * $Revision: 1.81 $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: makeio.c,v 1.81 1995/12/04 16:36:21 vince Exp vince $";
d735 10
d843 12
a854 2
				syslog(LOGPRI, "garbled data, possible active attack! packet #%lu crc32 %ld expected, %ld received",
					sequence, crc32val, p[i]->crc32);
d856 2
a857 6
					printf("%s[%d]: GARBLED DATA, possible active attack! packet #%lu crc32 %ld expected, %ld received\n\r",
						PRGNAME,
						getpid(),
						sequence,
						crc32val,
						p[i]->crc32);
d931 1
d935 2
a936 1
	for (i = 0; p[i]; i++)
d938 1
a952 1
		/*
a953 1
		*/
d955 5
a959 3
		/* residue data, return to collect more data.
		at least the non-dynamic part of combopacket should fit in */
		if (!olddatalen && remaining < sizeof(dataseq) +
a961 1
			/*
a962 1
			*/
d988 1
a1002 1
			/*
a1004 1
			*/
d1035 1
a1035 1
		if (!olddatalen)
d1045 3
d1049 7
a1055 3
		syslog(LOGPRI, "extract: *x dump...");
		syslog(LOGPRI, "extract: *x dump: %lu, %ld, %d, %s\n",
			dataseq, datacrc32, datalen, x->data);
d1057 1
d1063 1
a1063 1
		if (!olddatalen) {
d1067 3
a1069 1
				 	sizeof(datacrc32),
d1079 1
d1085 2
a1086 1
	if (!olddatalen)
d1088 3
a1090 2
	else
		memcpy(intbuf, tmp + readoffset +
d1094 2
a1095 1
				MAKEIOBUF * 2 - readoffset -
@


1.81
log
@safety
@
text
@d3 4
a6 4
 * $Header: /res/usr/vince/src/stel/RCS/makeio.c,v 1.80 1995/11/29 13:18:46 vince Exp $
 * $Date: 1995/11/29 13:18:46 $
 * $Revision: 1.80 $
 * $Locker:  $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: makeio.c,v 1.80 1995/11/29 13:18:46 vince Exp $";
d836 6
a841 2
					printf("%s[%d]: GARBLED DATA, possible active attack!\n\r",
							PRGNAME, getpid());
@


1.80
log
@safety
@
text
@d3 3
a5 3
 * $Header: /res/usr/vince/src/stel/RCS/makeio.c,v 1.79 1995/11/25 16:53:41 vince Exp $
 * $Date: 1995/11/25 16:53:41 $
 * $Revision: 1.79 $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: makeio.c,v 1.79 1995/11/25 16:53:41 vince Exp $";
d97 1
d99 1
d107 4
d112 1
d150 4
d156 1
d342 4
d347 1
d355 4
d360 1
d520 1
a520 1
	if (getenv("SKEYPADFILE") != NULL) {
d625 1
d996 1
a996 1
			syslog("extract: malloc()");
@


1.79
log
@safety
@
text
@d3 3
a5 3
 * $Header: /res/usr/vince/src/stel/RCS/makeio.c,v 1.78 1995/11/24 14:04:05 vince Exp $
 * $Date: 1995/11/24 14:04:05 $
 * $Revision: 1.78 $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: makeio.c,v 1.78 1995/11/24 14:04:05 vince Exp $";
d50 1
a50 1
#include "des.h"
@


1.78
log
@safety
@
text
@d3 3
a5 3
 * $Header: /res/usr/vince/src/stel/RCS/makeio.c,v 1.77 1995/11/24 10:08:11 vince Exp $
 * $Date: 1995/11/24 10:08:11 $
 * $Revision: 1.77 $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: makeio.c,v 1.77 1995/11/24 10:08:11 vince Exp $";
d657 2
d762 2
@


1.77
log
@safety
@
text
@d3 4
a6 4
 * $Header: /res/usr/vince/src/stel/RCS/makeio.c,v 1.73 1995/11/24 08:06:44 vince Exp vince $
 * $Date: 1995/11/24 08:06:44 $
 * $Revision: 1.73 $
 * $Locker: vince $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: makeio.c,v 1.73 1995/11/24 08:06:44 vince Exp vince $";
d298 2
@


1.76
log
@safety
@
text
@d293 1
a293 1
				mode = "NOT using data encryption!";
d295 1
a295 1
				mode = "IDEA encryption enabled";
d297 1
a297 1
				mode = "SINGLE DES encryption enabled";
d299 1
a299 1
				mode = "TRIPLE DES encryption enabled";
d303 1
a303 1
			printf("Elapsed time: %d hours, %d minutes, %d seconds\n",
d308 4
a311 3
			printf("%s\n", mode);
			printf("Protection against active attacks: %s\n",
				firstack & FLG_ACTIVE_ATTACKS ? "on" : "OFF");
a779 1
		/*
a780 1
		*/
a788 8
			syslog(LOGPRI, "*x dump from FOR...");
			syslog(LOGPRI, "*x dump from FOR: %lu, %ld, %d, %s",
				p[i]->seq,
				p[i]->crc32,
				p[i]->len,
				p[i]->data);


d880 2
a881 2
	static long		olddataseq;
	static unsigned long	olddatacrc32;
d901 4
d907 6
a912 3
		if (remaining < sizeof(unsigned long) +
				sizeof(long) +
				sizeof(int))
d914 1
a920 3
		/******************************************/
		/* cryptbuf(buf, len, dec, cipher, side); */
		/******************************************/
a934 2
			/* missing: decode datalen */

d952 4
a955 1
			syslog(LOGPRI, "extract: BREAKING...");
d959 1
d961 3
a963 2
		syslog(LOGPRI, "extract: *x dump: %lu, %ld, %d\n",
			dataseq, datacrc32, datalen);
a994 1
		/* missing: decode data */
d996 1
d1000 1
a1003 1
		/* missing: deallocation! */
@


1.75
log
@safety
@
text
@d958 1
a958 1
			syslog(LOGPRI, "extract: breaking...");
d961 4
@


1.74
log
@safety
@
text
@d692 6
d702 8
a709 5
		/* encrypt data */
		cryptbuf(&sequence, sizeof(sequence), enc, cipher, side);
		cryptbuf(&crc32val, sizeof(crc32val), enc, cipher, side);
		cryptbuf(&len, sizeof(len), enc, cipher, side);
		cryptbuf(&buf, len, enc, cipher, side);
d712 1
a712 3
		if (write_data(channel, &sequence, sizeof(sequence)) != sizeof(sequence) ||
		    write_data(channel, &crc32val, sizeof(crc32val)) != sizeof(crc32val) ||
		    write_data(channel, &len, sizeof(len)) != sizeof(len) ||
d714 1
a714 1
			syslog(LOGPRI, "write_data(control+data)\n");
d779 1
d781 1
@


1.73
log
@safety
@
text
@d3 4
a6 4
 * $Header: /res/usr/vince/src/stel/RCS/makeio.c,v 1.72 1995/11/21 09:56:21 vince Exp $
 * $Date: 1995/11/21 09:56:21 $
 * $Revision: 1.72 $
 * $Locker:  $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: makeio.c,v 1.72 1995/11/21 09:56:21 vince Exp $";
d696 5
a700 4
		/* encrypt it */
		/*
		cryptbuf(&control, sizeof(control), enc, cipher, side);
		*/
d771 3
a854 4

	/****************/
	/****************/
	/****************/
@


1.72
log
@safety
@
text
@d3 2
a4 2
 * $Header: /users/vince/src/stel/RCS/makeio.c,v 1.72 1995/11/15 13:54:52 vince Exp $
 * $Date: 1995/11/15 13:54:52 $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: makeio.c,v 1.72 1995/11/15 13:54:52 vince Exp $";
a592 1

a636 1
	ctlpacket		control;
a642 1
	bzero(&control, 0);
a691 1
		control.len = len;
a693 1
		control.crc32 = crc32val;
a694 1
		control.seq = sequence;
d696 2
a697 1
		/* encrypt control packet */
d699 1
a699 10

		/* send control */
		if (write_data(channel, &control, sizeof(control)) !=
							sizeof(control)) {
			syslog(LOGPRI, "write_data(control)\n");
			return(1);
		}

		/* encrypt data buffer */
		cryptbuf(buf, len, enc, cipher, side);
d701 6
a706 2
		if (write_data(channel, buf, len) != len) {
			syslog(LOGPRI, "write_data(channel): %m");
d731 2
a732 1
	ctlpacket		control;
d734 1
a734 1
	register		len, side;
a737 1
	bzero(&control, 0);
d755 5
a759 4
		/**************************************************/
		/* must read till EOF, and process things offline */
		/**************************************************/
		len = read_data(channel, &control, sizeof(control));
a761 4
		if (len != sizeof(control)) {
			syslog(LOGPRI, "read_data(control)");
			return(1);
		}
a763 1

d765 1
a765 1
			printf("%d[%s]: hexdump control %d bytes: ",
d767 1
a767 1
			hexdump(NULL, &control, len);
d770 25
a794 2
		/* decode control */
		cryptbuf(&control, sizeof(control), dec, cipher, side);
d796 11
a806 1
		len = control.len;
d808 5
a812 2
		if (!len) /* disconnection */
			return(0);
d814 4
a817 8
		sequence++;
		if (sequence != control.seq) {
			syslog(LOGPRI, "data out of order, possible active attack! packet #%lu expected, #%lu received",
							sequence, control.seq);
			if (remhostname)
				printf("%s[%d]: DATA OUT OF ORDER, possible active attack!",
				PRGNAME, getpid(), sequence, control.seq);
			return(1);
d822 1
a822 1
		if ((len = read(channel, buf, sizeof(buf))) == -1) {
a839 1
	}
d841 2
a842 3
	if (firstack & FLG_ACTIVE_ATTACKS) {
		if (read_data(channel, buf, len) != len) {
			syslog(LOGPRI, "read_data(buffer): %m");
d846 5
a850 10
		traffic += len;

		if (remhostname && firstack & FLG_DEBUG) {
			printf("%d[%s]: hexdump buffer %d bytes: ",
						getpid(), PRGNAME, len);
			hexdump(NULL, buf, len);
		}

		/* decode buffer */
		cryptbuf(buf, len, dec, cipher, side);
d852 3
a854 11
		crc32val = 0L;
		UpdateCRC(buf, len);
		if (crc32val != control.crc32) {
			syslog(LOGPRI, "garbled data, possible active attack! packet #lu, crc32 %ld expected, %ld received",
					sequence, crc32val, control.crc32);
			if (remhostname)
				printf("%s[%d]: GARBLED DATA, possible active attack!\n",
							PRGNAME, getpid());
			return(1);
		}
	}
d861 31
a891 3
	if (write_data(out, buf, len) != len) {
		syslog(LOGPRI, "write_data(out): %m");
		return(1);
d894 131
a1024 4
	/* store output into a circular buffer, for skey
	challenge detection and skey response automatic
	generation */
	storeskeybuf(buf, len);
d1026 4
a1029 1
	return(-1);
@


1.71
log
@safety
@
text
@d3 4
a6 4
 * $Header: /res/usr/vince/src/stel/RCS/makeio.c,v 1.70 1995/08/26 09:47:35 vince Exp vince $
 * $Date: 1995/08/26 09:47:35 $
 * $Revision: 1.70 $
 * $Locker: vince $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: makeio.c,v 1.70 1995/08/26 09:47:35 vince Exp vince $";
d295 3
a297 3
				mode = "IDEA plus TRIPLE DES data encryption enabled";
			else if (firstack & FLG_USE_TRIPLE)
				mode = "TRIPLE DES data encryption enabled";
d299 1
a299 1
				mode = "single DES data encryption enabled";
d653 2
a654 2
		if (firstack & FLG_USE_TRIPLE)
			cipher = 1;
d656 3
a658 1
			cipher = 2;
d755 2
a756 2
		if (firstack & FLG_USE_TRIPLE)
			cipher = 1;
d758 3
a760 1
			cipher = 2;
d765 3
d780 1
a780 1
					getpid(), PRGNAME, len);
@


1.70
log
@safety
@
text
@d3 4
a6 4
 * $Header: /res/usr/vince/src/stel/RCS/makeio.c,v 1.69 1995/08/25 15:58:26 vince Exp $
 * $Date: 1995/08/25 15:58:26 $
 * $Revision: 1.69 $
 * $Locker:  $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: makeio.c,v 1.69 1995/08/25 15:58:26 vince Exp $";
d691 1
a691 1
	/* check integrity and synchronization */
d759 1
a759 1
	/* check integrity and synchronization */
d787 1
a787 1
			syslog(LOGPRI, "data out of sync, possible active attack! packet #%lu expected, #%lu received",
d790 1
a790 1
				printf("%s[%d]: DATA OUT OF SYNC, possible active attack!",
@


1.69
log
@safety
@
text
@d3 4
a6 4
 * $Header: /res/usr/vince/src/stel/RCS/makeio.c,v 1.67 1995/08/25 13:44:55 vince Exp vince $
 * $Date: 1995/08/25 13:44:55 $
 * $Revision: 1.67 $
 * $Locker: vince $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: makeio.c,v 1.67 1995/08/25 13:44:55 vince Exp vince $";
d20 1
a861 11
}

cryptbuf(buf, len, dec, cipher, side)
unsigned char	*buf;
int		len, dec, cipher, side;
{
	register	i;
	void		CFBcrypt();

	for (i = 0; i < len; i++)
		CFBcrypt(&buf[i], dec, cipher, side);
@


1.68
log
@safety
@
text
@d70 1
a70 1
char			*domatch();
d90 1
a90 1
	struct timeval	timeout, *tim = NULL;
d100 1
a100 1
		(void)domatch(NULL, SKEYPATTERN);
d110 3
a112 3
			timeout.tv_sec = 1;
			timeout.tv_usec = 0;
			tim = &timeout;
d153 1
a153 1
							remhostname);
d259 1
a259 1
			skeyprompt = domatch(skeybuf, NULL);
a580 2
#include "regex.h"

d582 1
a582 1
domatch(buf, pat)
d676 1
a676 1
			return(1);
d690 1
a690 1
	/* check integrity and ordering */
d731 1
a731 1
dochannel(channel, out, buf, firstack, remhostname)
d736 1
d758 1
a758 1
	/* check integrity and ordering */
d786 1
a786 1
			syslog(LOGPRI, "data out of sync! packet #%lu expected, #%lu received",
d789 1
a789 1
				printf("%s[%d]: DATA OUT OF SYNC! packet #%lu expected, #%lu received",
d836 1
a836 1
			syslog(LOGPRI, "garbled data for packet #lu: crc32 %ld expected, %ld received",
d839 1
a839 1
				printf("%s[%d]: GARBLED DATA! communication path corrupted.\n",
d846 1
a846 1
	if (remhostname == NULL)
d848 1
@


1.67
log
@safety
@
text
@d3 3
a5 3
 * $Header: /res/usr/vince/src/stel/RCS/makeio.c,v 1.66 1995/08/25 10:59:54 vince Exp vince $
 * $Date: 1995/08/25 10:59:54 $
 * $Revision: 1.66 $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: makeio.c,v 1.66 1995/08/25 10:59:54 vince Exp vince $";
a40 1
#ifdef IDLETIMEOUT
a41 1
#endif
d76 6
a81 4
makeio(in, out, channel, firstack, remhostname, old, new)
int	in, out, channel, firstack;
struct termios *old, *new;
char	*remhostname;
a87 1
#ifdef IDLETIMEOUT
a88 1
#endif
a94 1
#ifdef IDLETIMEOUT
a96 3
#else /* !IDLETIMEOUT */
	oldmask = sigblock(sigmask(SIGCLD));
#endif
d109 1
a109 6
#ifdef IDLETIMEOUT
		if (child_is_dead || idle_timeout)
#else /* !TIMEOUT */
		if (child_is_dead)
#endif
						{
a125 1
#ifdef IDLETIMEOUT
a132 1
#endif /* IDLETIMEOUT */
a180 1
#ifdef IDLETIMEOUT
a195 1
#endif /* IDLETIMEOUT */
a213 1
#ifdef IDLETIMEOUT
a214 1
#endif
a305 4
#ifdef IDLETIMEOUT
			printf("Session idle timeout: %d minutes\n",
								IDLETIMEOUT);
#endif
a327 1
#ifdef IDLETIMEOUT
a328 1
#endif
d333 1
a333 2
#ifdef IDLETIMEOUT
			(void)signal(SIGALRM, idletimeout);
a334 3
#else /* !IDLETIMEOUT */
			oldmask = sigblock(sigmask(SIGCLD));
#endif
d787 1
a787 1
			syslog(LOGPRI, "replay attack! packet #%lu expected, #%lu received",
d790 1
a790 1
				printf("%s[%d]: REPLAY ATTACK! packet #%lu expected, #%lu received",
a845 1
#ifdef IDLETIMEOUT
d847 2
a848 2
	(void)alarm(IDLETIMEOUT * 60); /* reset timer */
#endif
@


1.66
log
@safety
@
text
@d3 4
a6 4
 * $Header: /res/usr/vince/src/stel/RCS/makeio.c,v 1.65 1995/08/23 15:14:46 vince Exp $
 * $Date: 1995/08/23 15:14:46 $
 * $Revision: 1.65 $
 * $Locker:  $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: makeio.c,v 1.65 1995/08/23 15:14:46 vince Exp $";
a67 1

a68 1

d70 1
d317 1
a317 2
			printf("Connected to %s. PID = %d.\n",
							remhostname, getpid());
d319 1
a319 1
			printf("Elapsed: %d hours, %d minutes, %d seconds\n",
d321 2
d525 2
d614 2
a615 1
	static regex_t		re;
d623 3
a625 1
		(void)regcomp(&re, pat, REG_EXTENDED);
d629 3
d698 1
a698 1
	
d717 2
d796 2
d832 2
d849 2
@


1.65
log
@safety
@
text
@d3 4
a6 4
 * $Header: /res/usr/vince/src/stel/RCS/makeio.c,v 1.64 1995/08/23 15:05:54 vince Exp vince $
 * $Date: 1995/08/23 15:05:54 $
 * $Revision: 1.64 $
 * $Locker: vince $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: makeio.c,v 1.64 1995/08/23 15:05:54 vince Exp vince $";
d26 1
d29 1
d62 1
a62 1
#if defined (SOLARIS) || defined (IRIX)
d128 6
a133 1
		switch (select(32, &mask, 0, 0, tim)) {
d191 1
a191 1
        (void) signal(SIGCLD, deadchild);
d208 1
a208 1
        (void) signal(SIGALRM, idletimeout);
a372 1
			int		i;
d444 1
a444 1
	static void	restore_ttymode();
d489 4
a492 1
	tcgetattr(0, &saved_ttymode);
d494 5
a498 2
		signal(SIGINT, restore_ttymode);
	tcgetattr(0, &noecho_ttymode);
d500 4
a503 1
	tcsetattr(0, TCSANOW, &noecho_ttymode);
d513 4
a516 1
	tcsetattr(0, TCSANOW, &saved_ttymode);
d518 1
a518 1
		signal(SIGINT, oldsig);
d556 1
a556 1
static void restore_ttymode()
d558 3
a560 2
    tcsetattr(0, TCSANOW, &saved_ttymode);
    exit(1);
d563 1
d660 2
a661 2
	register		i, side;
	static			enc, dec, cipher, cipherinit;
d667 1
a667 1
		if (!(firstack & FLG_NO_ENCRYPTION)) {
d669 2
a670 5
			dec = DES_DECRYPT;
		}
		else {
			enc = dec = -1;
		}
d758 2
a759 2
	register		i, len, side;
	static			enc, dec, cipher, cipherinit;
d764 1
a764 2
		if (!(firstack & FLG_NO_ENCRYPTION)) {
			enc = DES_ENCRYPT;
d766 2
a767 4
		}
		else {
			enc = dec = -1;
		}
@


1.64
log
@safety
@
text
@d3 3
a5 3
 * $Header: /res/usr/vince/src/stel/RCS/makeio.c,v 1.62 1995/08/15 18:47:12 vince Exp vince $
 * $Date: 1995/08/15 18:47:12 $
 * $Revision: 1.62 $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: makeio.c,v 1.62 1995/08/15 18:47:12 vince Exp vince $";
d772 6
d806 6
a816 1
		/* read control */
d822 6
a846 5

	if (remhostname && firstack & FLG_DEBUG) {
		printf("%d[%s]: hexdump %d bytes: ", getpid(), PRGNAME, len);
		hexdump(NULL, buf, len);
	}
@


1.63
log
@safety
@
text
@a66 2
static unsigned long	inbytes;
static unsigned long	outbytes;
d71 1
a71 1
char	*domatch();
d82 1
a82 4
	ctlpacket	ctl0, ctl1;
	unsigned long	seq0, seq1;
	register	i;
	int		len;
d84 1
a84 1
	char		buf[4096];
d86 1
a86 1
	void		deadchild(), CFBcrypt();
a89 1
	int 		enc, dec, cipher;
a93 4
	bzero(&ctl0, sizeof(ctl0));
	bzero(&ctl1, sizeof(ctl1));
	seq0 = seq1 = 0L;

d103 1
a103 14
	if (!(firstack & FLG_NO_ENCRYPTION)) {
		enc = DES_ENCRYPT;
		dec = DES_DECRYPT;
	}
	else {
		enc = dec = -1;
	}

	cipher = 0; /* use single des by default */
	if (firstack & FLG_USE_TRIPLE)
		cipher = 1;
	else if (firstack & FLG_USE_IDEA)
		cipher = 2;

a151 3
		/**************************/
		/* read from INPUT stream */
		/**************************/
d153 2
a154 33
			if ((len = read(in, buf, sizeof(buf))) == -1) {
/* #if defined(SUNOS4) || defined(linux) */
				if (errno == EIO) /* sun EOF */
					break;
/* #endif */
				syslog(LOGPRI, "read(): %m");
				return(1);
			}
			if (!len)
				break;
			
			inbytes += (unsigned long) len;
			
			if (remhostname && /* client side */
			    len == 1 && /* prevent accidental triggering */
			    (buf[0] == escape) &&
			    !(firstack & FLG_NO_ESCAPE)) { /* esc allowed */
				int	ret;

				ret = doescape(remhostname, old, new, firstack,
								buf, &len);
				if (ret == 1) { /* terminate connection */
					/* break; */
					return(1);
				}
				printf("%s[%d]: Returning to remote\r\n",
							PRGNAME, getpid());
				if (ret == 0) { /* cont connection */
					continue;
				}
				/* if ret == -1 fall trought, so buf is
				passed on to the server */
			}
a155 34
			if (remhostname) { /* client side */
				for (i = 0; i < len; i++)
					CFBcrypt(&buf[i], enc, cipher, CLIENT_SIDE);
			}
			else { /* server side */
				for (i = 0; i < len; i++)
					CFBcrypt(&buf[i], enc, cipher, SERVER_SIDE);
			}

			/* check integrity and ordering */
			if (firstack & FLG_ACTIVE_ATTACKS) {
				ctl0.len = len;
				crc32val = 0L;
				UpdateCRC(buf, len);
				ctl0.crc32 = crc32val;
				seq0++;
				ctl0.seq = seq0;
				if (write_data(channel, &ctl0, sizeof(ctl0)) == -1) {
					syslog(LOGPRI, "cannot send ctl msg\n");
					return(1);
				}

				if (write_data(channel, buf, len) == -1) {
					syslog(LOGPRI, "write_data(net): %m");
					return(1);
				}
			}
			/**/ 
			else {
				if (write_data(channel, buf, len) != len) {
					syslog(LOGPRI, "write_data(net): %m");
					return(1);
				}
			}
d158 3
a160 81
		/****************************/
		/* read from NETWORK stream */
		/****************************/
		/* else */ if (mask & (1 << channel)) {
			/* check integrity and ordering */
			if (firstack & FLG_ACTIVE_ATTACKS) {
				if (read_data(channel, &ctl1, sizeof(ctl1)) == -1) {
					syslog(LOGPRI, "cannot read ctl msg");
					return(1);
				}
				len = ctl1.len;
				seq1++;
				if (seq1 != ctl1.seq) {
					syslog(LOGPRI, "replay attack! packet #%lu expected, #%lu received",
							seq1, ctl1.seq);
					if (remhostname)
						printf("REPLAY ATTACK detected! packet #%lu expected, #%lu received",
							seq1, ctl1.seq);
					return(1);
				}
			}
			/**/
			else {
				if ((len = read(channel, buf,
							sizeof(buf))) == -1) {
					syslog(LOGPRI, "read(): %m");
					return(1);
				}
			}

			if (!len)
				break;

			if (firstack & FLG_ACTIVE_ATTACKS) {
				if (read_data(channel, buf, len) == -1) {
					syslog(LOGPRI, "read(): %m");
					return(1);
				}

				crc32val = 0L;
				UpdateCRC(buf, len);
				if (crc32val != ctl1.crc32) {
					syslog(LOGPRI, "garbled data for packet #lu: crc32 %ld expected, %ld received",
				seq1, crc32val, ctl1.crc32);
					if (remhostname)
						printf("GARBLED DATA! communication path corrupted.\n");
					return(1);
				}
			}

			outbytes += (unsigned long) len;

#ifdef IDLETIMEOUT
			/* server side: receiving some kind of user's input */
			(void)alarm(IDLETIMEOUT * 60); /* reset timer */
#endif

			if (remhostname && firstack & FLG_DEBUG) {
				printf("%d[%s]: hexdump %d bytes: ",
						getpid(), PRGNAME, len);
				hexdump(NULL, buf, len);
			}

			if (remhostname) { /* client side */
				for (i = 0; i < len; i++)
					CFBcrypt(&buf[i], dec, cipher, SERVER_SIDE);
			}
			else { /* server side */
				for (i = 0; i < len; i++)
					CFBcrypt(&buf[i], dec, cipher, CLIENT_SIDE);
			}

			if (write_data(out, buf, len) != len) {
				syslog(LOGPRI, "write_data(out): %m");
				return(1);
			}

			/* store output into a circular buffer, for skey
			challenge detection and skey response automatic
			generation */
			storeskeybuf(buf, len);
d162 6
d314 2
a315 3
			printf("Elapsed time: %d hours, %d minutes, %d seconds\n", hrs, min, sec);
			printf("User keystrokes: %ld\n", inbytes);
			printf("Session output is %ld bytes\n", outbytes);
d321 5
a325 1
			printf("%s\n\n", mode);
d629 229
@


1.62
log
@safety
@
text
@d3 3
a5 3
 * $Header: /res/usr/vince/src/stel/RCS/makeio.c,v 1.61 1995/07/29 19:52:54 vince Exp vince $
 * $Date: 1995/07/29 19:52:54 $
 * $Revision: 1.61 $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: makeio.c,v 1.61 1995/07/29 19:52:54 vince Exp vince $";
d57 3
d84 2
d100 4
d136 1
a136 1
		   flush streams */
d175 3
d222 24
a245 3
			if (write_data(channel, buf, len) != len) {
				syslog(LOGPRI, "write_data(channel): %m");
				return(1);
d248 4
d253 24
a276 3
			if ((len = read(channel, buf, sizeof(buf))) == -1) {
				syslog(LOGPRI, "read(): %m");
				return(1);
d282 17
d329 1
a329 1
			storebuf(buf, len);
d480 4
d704 1
a704 1
storebuf(buf, len)
@


1.61
log
@safety
@
text
@d3 4
a6 4
 * $Header: /res/usr/vince/src/stel/RCS/makeio.c,v 1.60 1995/07/19 18:58:54 vince Exp $
 * $Date: 1995/07/19 18:58:54 $
 * $Revision: 1.60 $
 * $Locker:  $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: makeio.c,v 1.60 1995/07/19 18:58:54 vince Exp $";
d39 3
d76 1
a76 1
makeio(in, out, channel, firstack, remotehost, old, new)
d79 1
a79 1
char	*remotehost;
d87 3
d97 4
d102 1
d125 9
a133 6
		/* death of child detected. may be that some data arrived
		   while in the critical code, so we flush streams */
		if (child_is_dead) {
			/*
			printf("child_is_dead condition\n");
			*/
d145 9
d180 1
a180 1
			if (remotehost && /* client side */
d186 1
a186 1
				ret = doescape(remotehost, old, new, firstack,
d201 1
a201 1
			if (remotehost) { /* client side */
d226 6
a231 1
			if (remotehost && firstack & FLG_DEBUG) {
d237 1
a237 1
			if (remotehost) { /* client side */
d276 20
a295 2
doescape(remotehost, old, new, firstack, buf, len)
char		*remotehost, *buf;
d311 4
d400 1
a400 1
							remotehost, getpid());
d423 4
d430 4
d435 1
@


1.60
log
@safety
@
text
@d3 4
a6 4
 * $Header: /res/usr/vince/src/stel/RCS/makeio.c,v 1.59 1995/07/14 16:06:22 vince Exp vince $
 * $Date: 1995/07/14 16:06:22 $
 * $Revision: 1.59 $
 * $Locker: vince $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: makeio.c,v 1.59 1995/07/14 16:06:22 vince Exp vince $";
d188 1
a188 1
				syslog(LOGPRI, "write_data(): %m");
d218 2
a219 2
			if (write(out, buf, len) != len) {
				syslog(LOGPRI, "write(): %m");
@


1.59
log
@safety
@
text
@d3 3
a5 3
 * $Header: /res/usr/vince/src/stel/RCS/makeio.c,v 1.57 1995/07/14 13:58:45 vince Exp vince $
 * $Date: 1995/07/14 13:58:45 $
 * $Revision: 1.57 $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: makeio.c,v 1.57 1995/07/14 13:58:45 vince Exp vince $";
a28 11
/* garbage injection attacks protection */
/* #define CHECKSUM */

#ifdef CHECKSUM
#define CHKLEN		24
#define STARTOFPCK	12345678
#else
#define CHKLEN		0 /* no checksums */
#endif


d144 1
a144 2
			if ((len = read(in, buf + CHKLEN,
						sizeof(buf) - CHKLEN)) == -1) {
d159 1
a159 1
			    (buf[CHKLEN] == escape) &&
d164 1
a164 1
							buf + CHKLEN, &len);
a177 13
#ifdef CHECKSUM
			bzero(buf, CHKLEN);
			sprintf(buf, "%d", len);
			syslog(LOGPRI, "write: buffer len is %d", len);
			for (i = 0; i < CHKLEN + len; i++)
				CFBcrypt(&buf[i], enc, firstack);
			if (write_data(channel, buf, len + CHKLEN)
							!= len + CHKLEN) {
				syslog(LOGPRI, "write_data(): %m");
				return(1);
			}
#else /* !CHECKSUM */

a190 1
#endif
a192 34
#ifdef CHECKSUM
			int	expected, received, remain = 0;

			if ((len = read(channel, buf, sizeof(buf))) == -1) {
				syslog(LOGPRI, "read(): %m");
				return(1);
			}
			if (len <= CHKLEN)
				break;

			for (i = 0; i < len; i++)
				CFBcrypt(&buf[i], enc, firstack);

			/* checksum check goes here */
			syslog(LOGPRI, "read: buffer len is %d", atoi(buf));

			expected = atoi(buf); /* fix */
			received = len - CHKLEN;

			/* work in progress! */
			if (expected

			addbuf(buf, 

			if (write(out, buf + CHKLEN, len) != len) {
				syslog(LOGPRI, "write(): %m");
				return(1);
			}

			/* store output into a circular buffer, for skey
			challenge detection and skey response automatic
			generation */
			storebuf(buf + CHKLEN, len);
#else /* !CHECKSUM */
a226 1
#endif
a554 3
	/*
	printf("S/Key response is: %s\n", btoe(buf, key));
	*/
a574 1

@


1.58
log
@safety
@
text
@d404 1
a404 1
				mode = "IDEA plus triple DES data encryption enabled";
d406 1
a406 1
				mode = "Triple DES data encryption enabled";
d408 1
a408 1
				mode = "Single DES data encryption enabled";
d417 1
a417 1
			printf("%s\n", mode);
d487 1
a487 1
			printf("%s %s		generate skey response\n",
d528 2
d534 1
a534 1
	seqn = (char *)strtok(line, ", \t"); /* check command line arguments */
d544 1
a544 1
		seqn = (char *)strtok(buf, ", \t");
d556 1
a556 1
	seed = (char *)strtok(NULL, " \t");
@


1.57
log
@safety
@
text
@d3 3
a5 3
 * $Header: /res/usr/vince/src/stel/RCS/makeio.c,v 1.56 1995/07/14 13:31:29 vince Exp vince $
 * $Date: 1995/07/14 13:31:29 $
 * $Revision: 1.56 $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: makeio.c,v 1.56 1995/07/14 13:31:29 vince Exp vince $";
d485 4
a488 4
			printf("close, quit, ^D	close current connection\n");
			printf("return, CR	return to remote system\n");
			printf("%s		generate skey response\n",
								SKEY_CMD);
d493 1
a493 1
			printf("sendesc		send escape character\n");
a533 1

@


1.56
log
@safety
@
text
@d3 4
a6 4
 * $Header: /res/usr/vince/src/stel/RCS/makeio.c,v 1.55 1995/07/13 17:35:49 vince Exp $
 * $Date: 1995/07/13 17:35:49 $
 * $Revision: 1.55 $
 * $Locker:  $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: makeio.c,v 1.55 1995/07/13 17:35:49 vince Exp $";
d203 1
a203 1
			if (remotehost) { { /* client side */
@


1.55
log
@safety
@
text
@d3 3
a5 3
 * $Header: /res/usr/vince/src/stel/RCS/makeio.c,v 1.54 1995/07/13 11:03:57 vince Exp $
 * $Date: 1995/07/13 11:03:57 $
 * $Revision: 1.54 $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: makeio.c,v 1.54 1995/07/13 11:03:57 vince Exp $";
d203 1
a203 1
			if (remotehost) { /* client side */
d205 1
a205 5
					CFBcrypt(&buf[i], enc, cipher,
					c_ideakey,
					c_schedule1,
					c_schedule2,
					c_schedule3);
d209 1
a209 5
					CFBcrypt(&buf[i], enc, cipher,
					s_ideakey,
					s_schedule1,
					s_schedule2,
					s_schedule3);
d271 1
a271 5
					CFBcrypt(&buf[i], dec, cipher,
					s_ideakey,
					s_schedule1,
					s_schedule2,
					s_schedule3);
d275 1
a275 5
					CFBcrypt(&buf[i], dec, cipher,
					c_ideakey,
					c_schedule1,
					c_schedule2,
					c_schedule3);
@


1.54
log
@safety
@
text
@d3 3
a5 3
 * $Header: /res/usr/vince/src/stel/RCS/makeio.c,v 1.53 1995/07/12 16:44:00 vince Exp $
 * $Date: 1995/07/12 16:44:00 $
 * $Revision: 1.53 $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: makeio.c,v 1.53 1995/07/12 16:44:00 vince Exp $";
d567 2
a568 2
		fprintf(stderr,"%s[%d]: %s not positive\n",
						PRGNAME, getpid(), buf);
@


1.53
log
@safety
@
text
@d3 3
a5 3
 * $Header: /res/usr/vince/src/stel/RCS/makeio.c,v 1.52 1995/07/08 15:48:56 vince Exp $
 * $Date: 1995/07/08 15:48:56 $
 * $Revision: 1.52 $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: makeio.c,v 1.52 1995/07/08 15:48:56 vince Exp $";
d420 1
a420 1
				mode = "IDEA data encryption enabled";
@


1.52
log
@safety
@
text
@d3 4
a6 4
 * $Header: /res/usr/vince/src/stel/RCS/makeio.c,v 1.51 1995/07/05 17:31:05 vince Exp vince $
 * $Date: 1995/07/05 17:31:05 $
 * $Revision: 1.51 $
 * $Locker: vince $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: makeio.c,v 1.51 1995/07/05 17:31:05 vince Exp vince $";
d51 1
a51 1
/*
d53 4
a56 1
*/
d58 6
a63 2
extern des_key_schedule	schedule1, schedule2;
extern des_cblock	IV;
d95 1
a95 1
	int 		enc, dec;
d112 6
d195 1
a195 1
				CFBcrypt(&buf[i], dec, firstack);
d201 19
a219 3
#else
			for (i = 0; i < len; i++)
				CFBcrypt(&buf[i], dec, firstack);
d260 1
a260 1
#else
d271 23
a293 2
			for (i = 0; i < len; i++)
				CFBcrypt(&buf[i], enc, firstack);
a324 67

/*
 * Encrypts a byte of data using DES in CFB mode. ``Mode'' can be equal to
 * DES_ENCRYPT || DES_DECRYPT. Notice that inside each program (master, slave)
 * there is both encryption for outgoing bytes and decryption for incoming
 * bytes.
 * We *must* use TWO encryption queues to assure data syncronization.
 */
void			CFBcrypt(databyte, mode, firstack)
char			*databyte;
int			mode, firstack;
{
	static char	shift1[8], shift2[8], first1, first2;
	register char	*shift, add;
	register	i;

	if (mode < 0)
		return;

	switch (mode) {
	case	DES_ENCRYPT:
		if (!first1) { /* First time we use this queue? */
			(void)memcpy(shift1, IV, 8);
			first1++;
		}
		shift = shift1;
		break;
	case	DES_DECRYPT:
		if (!first2) {
			(void)memcpy(shift2, IV, 8);
			first2++;
		}
		shift = shift2;
		break;
	default	:
		return;
	}

	if (mode == DES_DECRYPT)
		add = *databyte;

	if (firstack & FLG_USE_IDEA)
		idea_ecb(shift, shift);
	else if (firstack & FLG_USE_TRIPLE) {
		des_ecb_encrypt((des_cblock *)shift, (des_cblock *)shift,
							schedule1, DES_ENCRYPT);
		des_ecb_encrypt((des_cblock *)shift, (des_cblock *)shift,
							schedule2, DES_DECRYPT);
		des_ecb_encrypt((des_cblock *)shift, (des_cblock *)shift,
							schedule1, DES_ENCRYPT);
	}
	else {
		des_ecb_encrypt((des_cblock *)shift, (des_cblock *)shift,
							schedule1, DES_ENCRYPT);
	}

	*databyte ^= shift[0];	
	
	for (i = 1; i <= 7; i++)
		shift[i - 1] = shift[i];

	if (mode == DES_ENCRYPT)
		add = *databyte;

	shift[7] = add;
}

d352 1
d354 6
a359 1
			continue;
a368 5
		/* return to remote */
		if (!strncmp(line, "return", strlen(line))) {
			break;
		}

d392 1
a392 1
			printf("\n%s[%d]: skey challenge detected, generating response\n",
d501 2
a502 2
			printf("close, quit	close current connection\n");
			printf("return		return to remote system\n");
@


1.51
log
@safety
@
text
@d3 3
a5 3
 * $Header: /res/usr/vince/src/stel/RCS/makeio.c,v 1.49 1995/07/05 15:21:22 vince Exp vince $
 * $Date: 1995/07/05 15:21:22 $
 * $Revision: 1.49 $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: makeio.c,v 1.49 1995/07/05 15:21:22 vince Exp vince $";
d29 11
d85 1
a85 1
	char		buf[4096], headerbuf[20];
d142 3
a144 2
			if ((len = read(in, buf, sizeof(buf))) == -1) {
#if defined(SUNOS4) || defined(linux)
d147 1
a147 1
#endif
d158 1
a158 1
			    (buf[0] == escape) &&
d163 1
a163 1
								buf, &len);
d168 3
a170 2
				else if (ret == 0) { /* cont connection */
					printf("[Returning to remote]\r\n");
a176 3
/* protection against active attacks */
#define CHECKSUM

d178 8
a185 8
			/*
			bzero(headerbuf, 20);
			*/
			sprintf(headerbuf, "%d", len);
			for (i = 0; i < 20; i++)
				CFBcrypt(&headerbuf[i], dec, firstack);
			if (write_data(channel, headerbuf, 20) != 20) {
				syslog(LOGPRI, "write(): %m");
d188 1
a188 2
#endif

d192 1
a192 1
				syslog(LOGPRI, "write(): %m");
d195 1
d199 3
a201 1
			if (read_data(channel, headerbuf, 20) != 20) {
d205 11
d217 4
a220 6
			for (i = 0; i < 20; i++)
				CFBcrypt(&headerbuf[i], enc, firstack);
			
			len = atoi(headerbuf);
			if (len == 0)
				break;
d222 2
a223 2
			if (read_data(channel, buf, len) != len) {
				syslog(LOGPRI, "read(): %m");
d226 5
a231 1

a238 1
#endif
d253 1
d360 1
a360 1
		printf("\n%s> ", PRGNAME);
a368 1
		/* return to remote */
d370 1
a370 1
			break;
d380 5
d389 5
a393 1
			printf("skey response: %s\n", skeyresp(line, 0));;
d442 1
a442 1
			printf("Connected to %s. local PID = %d.\n",
a469 2

			printf("[Returning to remote]\n");
d518 1
d557 2
a558 1
"Reminder -- Do not use this while logged in via telnet or dial-in\n");
d567 1
a567 1
		printf("sequence number, seed: ");
d570 1
a570 1
			fprintf(stderr,"EOF\n");
d577 1
a577 1
			fprintf(stderr,"no input?\n");
d583 2
a584 1
		fprintf(stderr,"%s not positive\n", buf);
d589 1
a589 1
		fprintf(stderr,"no seed provided?\n");
d593 1
a593 1
	printf("secret password: ");
d605 2
a606 1
		fprintf(stderr,"no password provided\n");
d619 2
a620 1
			printf("(using mjr DES padding mode)\n");
d624 2
a625 1
			printf("use mjr DES padding mode ? ");
d628 2
a629 1
				fprintf(stderr,"EOF\n");
d641 1
a641 1
		fprintf(stderr,"key crunch failed\n");
@


1.50
log
@safety
@
text
@d74 1
a74 1
	char		buf[4096];
d157 1
d164 16
a181 1

d188 19
d214 1
d365 1
a365 1
		if (!strncmp(line, "auto", strlen(line))) {
d487 1
a487 1
			printf("%s		manually generate skey response\n",
d489 1
a489 1
			printf("auto		automatically generate and send skey resp\n");
@


1.49
log
@safety
@
text
@d3 3
a5 3
 * $Header: /res/usr/vince/src/stel/RCS/makeio.c,v 1.48 1995/05/12 18:07:46 vince Exp vince $
 * $Date: 1995/05/12 18:07:46 $
 * $Revision: 1.48 $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: makeio.c,v 1.48 1995/05/12 18:07:46 vince Exp vince $";
d449 1
a449 1
			printf("Commands are:\n\n");
d451 1
a451 1
			printf("%s		generate skey response\n",
d453 1
a453 1
			printf("auto		automatic skey prompting\n");
@


1.48
log
@safety
@
text
@d3 3
a5 3
 * $Header: /res/usr/vince/src/stel/RCS/makeio.c,v 1.47 1995/05/12 18:00:14 vince Exp vince $
 * $Date: 1995/05/12 18:00:14 $
 * $Revision: 1.47 $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: makeio.c,v 1.47 1995/05/12 18:00:14 vince Exp vince $";
d288 1
a288 1
	int	quit = 0, firstchar, n;
d292 1
a292 36
	printf("\r\n%s> ", PRGNAME);
	firstchar = getchar();

	if (firstchar == CONTROL(']')) {
		char	*p;

		skeyprompt = domatch(skeybuf, NULL);
		if (!skeyprompt) {
			printf("\r\n%s[%d]: no skey challenge found\r\n",
							PRGNAME, getpid());
			return(0);
		}

		if (tcsetattr(0, TCSANOW, old) == -1) {
			perror("tcgetattr()");
			return(1);
		}

		printf("\n%s[%d]: skey challenge detected, generating response\n",
			PRGNAME, getpid());
		p = skeyresp(skeyprompt, 1);
		if (p == NULL) /* failed */
			return(0);
		*len = strlen(p) + 1;
		strcpy(buf, p);
		buf[strlen(p)] = '\n';
		buf[strlen(p) + 1] = '\0';

		if (tcsetattr(0, TCSANOW, new) == -1) {
			perror("tcgetattr()");
			return(1);
		}

		return(-1);
	}

d298 2
a299 2
	ungetc(firstchar, stdin);
	putchar(firstchar);
a300 3
	for (n = 0; ; n++) {
		if (n)
			printf("%s> ", PRGNAME);
d328 25
d453 1
d467 1
@


1.47
log
@safety
@
text
@d3 3
a5 3
 * $Header: /res/usr/vince/src/stel/RCS/makeio.c,v 1.44 1995/05/12 17:29:50 vince Exp vince $
 * $Date: 1995/05/12 17:29:50 $
 * $Revision: 1.44 $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: makeio.c,v 1.44 1995/05/12 17:29:50 vince Exp vince $";
d300 2
a301 1
			printf("\r\nskey challenge not found\r\n");
d310 2
a311 1
		printf("\nskey challenge detected, generating response\n");
d534 1
a534 1
	printf("%s[%d]: secret password: ", getpid());
@


1.46
log
@safety
@
text
@d309 1
a309 1
		printf("\n\nskey challenge detected, generating response\n");
d384 3
a386 3
			printf("Connected to %s.\n", remotehost);
			printf("Connection time: %s, PID = %d",
						ctime(&start), getpid());
d532 1
a532 1
	printf("secret password: ");
@


1.45
log
@safety
@
text
@a51 1
static int		skeyescape = CONTROL('p');
d146 1
a146 1
			    (buf[0] == escape || buf[0] == skeyescape) &&
d288 1
a288 1
	int	quit = 0, firstchar;
d292 1
a294 3
	/*
	if (buf[0] == skeyescape)
	*/
d331 2
d334 3
a336 6
	printf("\n");

	(void)ungetc(firstchar, stdin);

	for (;;) {
		printf("%s> ");
@


1.44
log
@safety
@
text
@d3 3
a5 3
 * $Header: /res/usr/vince/src/stel/RCS/makeio.c,v 1.42 1995/05/12 16:44:48 vince Exp vince $
 * $Date: 1995/05/12 16:44:48 $
 * $Revision: 1.42 $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: makeio.c,v 1.42 1995/05/12 16:44:48 vince Exp vince $";
d289 1
a289 1
	int	quit = 0;
d293 6
a298 1
	if (buf[0] == skeyescape) {
d303 1
a303 2
			printf("\r\n%s[%d]: skey challenge not found\r\n",
							PRGNAME, getpid());	
d312 1
a312 2
		printf("\n\n%s[%d]: skey challenge detected, generating response\n",
						PRGNAME, getpid(), skeyprompt);
d334 1
d337 2
d340 1
a340 1
		printf("%s[%d]> ", PRGNAME, getpid());
@


1.43
log
@safety
@
text
@d295 1
a295 1
			
d298 1
a298 1
			printf("\r\n%s[%d]: S/Key challenge not found\r\n",
d302 1
d307 4
a310 2
		printf("\r\nS/Key challenge found: `%s'\r\n", skeyprompt);
		p = skeyresp(skeyprompt);
d313 1
a313 1
		*len = strlen(p);
d315 8
d334 1
a334 1
		printf("%s> ", PRGNAME);
d358 1
a358 1
			(void)skeyresp(line);
d483 1
a483 1
skeyresp(line)
d485 1
d554 14
a567 5
		printf("use MJR DES padding mode ? ");
		(void)fflush(stdout);
		if (fgets(buf, sizeof(buf), stdin) == NULL) {
			fprintf(stderr,"EOF\n");
			return(NULL);
a568 3
		rip(buf);
		if (buf[0] == 'y')
			desmode = 1;
@


1.42
log
@safety
@
text
@d3 4
a6 4
 * $Header: /res/usr/vince/src/stel/RCS/makeio.c,v 1.40 1995/05/10 18:00:18 vince Exp $
 * $Date: 1995/05/10 18:00:18 $
 * $Revision: 1.40 $
 * $Locker:  $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: makeio.c,v 1.40 1995/05/10 18:00:18 vince Exp $";
d291 1
a291 1
	char	*control();
d294 2
d306 7
a312 6
		printf("\nS/Key challenge found: `%s'\n", skeyprompt);
		(void)skeyresp(skeyprompt);
		if (tcsetattr(0, TCSANOW, new) == -1) {
			perror("tcgetattr()");
			return(1);
		}
d471 1
d475 5
a479 4
	char	*seed, *seqn, buf[256], passwd[80];
	int	n;
	int	desmode = 0;
	char	key[8];
d497 1
a497 1
			return(1);
d504 1
a504 1
			return(1);
d510 1
a510 1
		return(1);
d515 1
a515 1
		return(1);
d531 1
a531 1
		return(1);
d546 1
a546 1
			return(1);
d557 1
a557 1
		return(1);
d562 1
d564 3
a566 1
	return 0;
@


1.41
log
@safety
@
text
@d59 4
d72 2
a73 1
	register	i, len;
d95 3
d189 5
d290 1
d294 16
a309 2
		printf("SKEY ESCAPE\n");
		return(0);
d369 2
a370 1
			printf("Connection time: %s", ctime(&start));
d537 1
a537 4
		/*
		printf("($SKEYPADFILE is set: using MJR DES padding mode)\n");
		*/
		printf("MJR DES padding mode ? ");
d557 1
a557 1
	printf("%s\n", btoe(buf, key));
d566 88
@


1.40
log
@safety
@
text
@d3 3
a5 3
 * $Header: /res/usr/vince/src/stel/RCS/makeio.c,v 1.39 1995/05/10 15:31:50 vince Exp $
 * $Date: 1995/05/10 15:31:50 $
 * $Revision: 1.39 $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: makeio.c,v 1.39 1995/05/10 15:31:50 vince Exp $";
d52 1
d138 2
a139 1
			    len == 1 && buf[0] == escape && /* ^] only */
d143 2
a144 1
				ret = doescape(remotehost, old, new, firstack);
d152 2
a153 1
				/* if ret == -1 send escape to server */
d269 2
a270 2
doescape(remotehost, old, new, firstack)
char		*remotehost;
d273 1
d279 5
d410 1
d508 1
d510 1
a510 1
		/*
a518 1
		*/
@


1.39
log
@safety
@
text
@d3 4
a6 4
 * $Header: /res/usr/vince/src/stel/RCS/makeio.c,v 1.37 1995/05/10 15:10:14 vince Exp vince $
 * $Date: 1995/05/10 15:10:14 $
 * $Revision: 1.37 $
 * $Locker: vince $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: makeio.c,v 1.37 1995/05/10 15:10:14 vince Exp vince $";
d21 8
d61 1
d182 2
a183 1
void    deadchild()
d208 1
a208 1
int			mode;
@


1.38
log
@safety
@
text
@d295 1
a295 1
		    !strncmp(line, SKEY_CMD, strlen(SKEY_CMD2))) {
d487 2
d497 1
@


1.37
log
@safety
@
text
@d3 3
a5 3
 * $Header: /res/usr/vince/src/stel/RCS/makeio.c,v 1.36 1995/05/06 15:39:00 vince Exp vince $
 * $Date: 1995/05/06 15:39:00 $
 * $Revision: 1.36 $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: makeio.c,v 1.36 1995/05/06 15:39:00 vince Exp vince $";
d27 1
d294 2
a295 1
		if (!strncmp(line, SKEY_CMD, strlen(SKEY_CMD))) {
d395 1
a395 1
			printf("close		close current connection\n");
d431 4
a434 1
	line += strlen(SKEY_CMD); /* skip the first word */
@


1.36
log
@safety
@
text
@d3 4
a6 4
 * $Header: /res/usr/vince/src/stel/RCS/makeio.c,v 1.35 1995/04/08 15:43:35 vince Exp $
 * $Date: 1995/04/08 15:43:35 $
 * $Revision: 1.35 $
 * $Locker:  $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: makeio.c,v 1.35 1995/04/08 15:43:35 vince Exp $";
d25 4
d38 1
a38 1
#ifdef SOLARIS
d293 1
a293 1
		if (!strncmp(line, "skey", strlen("skey"))) {
d355 1
a355 1
		if (!strncmp(line, "escape", strlen(line))) {
d357 13
a369 1
			printf("Current escape character is: '%s'\n",
d371 6
a376 4
			printf("Enter new escape character: ");
			(void)fflush(stdout);
			x = (unsigned char)getchar();
			if (x == '\n' || x == '\r')
d378 1
a378 1
			else
d380 3
d392 4
a395 3
			printf("Commands may be abbreviated. Commands are:\n\n");
			printf("close, quit	close current connection\n");
			printf("skey		generate skey response\n");
d397 2
a398 1
			printf("escape		set escape character\n");
d429 1
a429 1
	line += strlen("skey"); /* skip the first word */
@


1.35
log
@safety
@
text
@d3 3
a5 3
 * $Header: /res/usr/vince/src/stel/RCS/makeio.c,v 1.34 1995/04/08 11:18:38 vince Exp $
 * $Date: 1995/04/08 11:18:38 $
 * $Revision: 1.34 $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: makeio.c,v 1.34 1995/04/08 11:18:38 vince Exp $";
d281 2
a282 1
		if (!strncmp(line, "close", strlen(line))) {
d287 4
a290 3
		/* calculate skey response */
		if (!strncmp(line, "skey", strlen(line))) {
			(void)skeyresp();
d372 1
a372 1
			printf("close		close current connection\n");
d393 2
a394 1
skeyresp()
d406 11
a416 5
	printf("sequence number, seed: ");
	(void)fflush(stdout);
	if (fgets(buf, sizeof(buf), stdin) == NULL)
		return(1);
	rip(buf);
d418 6
a423 3
	seqn = (char *)strtok(buf, " \t");
	if (seqn == NULL)
		return(1);
d430 4
d446 2
a447 1
	if (fgets(passwd, sizeof(passwd), stdin) == NULL)
d449 1
d461 2
a462 1
		if (fgets(buf, sizeof(buf), stdin) == NULL)
d464 1
d474 1
a474 1
		return 1;
@


1.34
log
@safety
@
text
@d3 3
a5 3
 * $Header: /res/usr/vince/src/stel/RCS/makeio.c,v 1.33 1995/04/05 16:35:14 vince Exp $
 * $Date: 1995/04/05 16:35:14 $
 * $Revision: 1.33 $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: makeio.c,v 1.33 1995/04/05 16:35:14 vince Exp $";
a22 1

a24 1

d27 1
d29 1
a29 1

d34 3
d409 3
a411 2
	seqn = (char *)strtok(buf, " \t\n\r");
	seed = (char *)strtok(buf, NULL);
d417 1
@


1.33
log
@safety
@
text
@d3 3
a5 3
 * $Header: /res/usr/vince/src/stel/RCS/makeio.c,v 1.32 1995/03/31 19:34:43 vince Exp $
 * $Date: 1995/03/31 19:34:43 $
 * $Revision: 1.32 $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: makeio.c,v 1.32 1995/03/31 19:34:43 vince Exp $";
a29 1
extern IDEAkey		Z;
d223 1
a223 1
		cipher_idea(shift, shift, Z);
d255 1
a255 1
	static char	*control();
a388 39

/*
 * Construct a control character sequence
 * for a special character.
 */
	static char *
control(c)
	register cc_t c;
{
	static char buf[5];
	/*
	 * The only way I could get the Sun 3.5 compiler
	 * to shut up about
	 *	if ((unsigned int)c >= 0x80)
	 * was to assign "c" to an unsigned int variable...
	 * Arggg....
	 */
	register unsigned int uic = (unsigned int)c;

	if (uic == 0x7f)
		return ("^?");

	if (uic >= 0x80) {
		buf[0] = '\\';
		buf[1] = ((c>>6)&07) + '0';
		buf[2] = ((c>>3)&07) + '0';
		buf[3] = (c&07) + '0';
		buf[4] = 0;
	} else if (uic >= 0x20) {
		buf[0] = c;
		buf[1] = 0;
	} else {
		buf[0] = '^';
		buf[1] = '@@'+c;
		buf[2] = 0;
	}
	return (buf);
}

d391 1
a391 1
	char	seed[256], buf[80], passwd[256];
d399 1
a399 7
"Reminder - Do not use this while logged in via telnet or dial-in.\n");

	printf("Enter seed: ");
	(void)fflush(stdout);
	if (fgets(seed, sizeof(seed), stdin) == NULL)
		return(1);
	rip(seed);
d401 1
a401 1
	printf("enter sequence number: ");
d406 4
a409 1
	n = atoi(buf);
d415 1
a415 1
	printf("enter secret password: ");
d437 1
a437 1
		printf("use mjr DES mode [n] ? ");
@


1.32
log
@safety
@
text
@d3 3
a5 3
 * $Header: /res/usr/vince/src/stel/RCS/makeio.c,v 1.31 1995/02/27 15:03:39 vince Exp $
 * $Date: 1995/02/27 15:03:39 $
 * $Revision: 1.31 $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: makeio.c,v 1.31 1995/02/27 15:03:39 vince Exp $";
d109 1
a109 1
#if defined(SUNOS4) /* || defined(SOLARIS) */
@


1.31
log
@safety
@
text
@d3 3
a5 3
 * $Header: /res/usr/vince/src/stel/RCS/makeio.c,v 1.30 1995/02/21 17:34:49 vince Exp $
 * $Date: 1995/02/21 17:34:49 $
 * $Revision: 1.30 $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: makeio.c,v 1.30 1995/02/21 17:34:49 vince Exp $";
d14 1
a17 1
#include <termios.h>
d109 1
a109 1
#ifdef sun
@


1.30
log
@safety
@
text
@d3 3
a5 3
 * $Header: /res/usr/vince/src/stel/RCS/makeio.c,v 1.29 1995/02/20 10:10:16 vince Exp $
 * $Date: 1995/02/20 10:10:16 $
 * $Revision: 1.29 $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: makeio.c,v 1.29 1995/02/20 10:10:16 vince Exp $";
d432 1
a432 1
	int	n, cnt;
@


1.29
log
@safety
@
text
@d3 4
a6 4
 * $Header: /res/usr/vince/src/stel/RCS/makeio.c,v 1.28 1995/02/17 14:50:11 vince Exp vince $
 * $Date: 1995/02/17 14:50:11 $
 * $Revision: 1.28 $
 * $Locker: vince $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: makeio.c,v 1.28 1995/02/17 14:50:11 vince Exp vince $";
d121 7
a127 3
			/* serve escapes when client side */
			if (remotehost && len == 1 && buf[0] == escape) {
				if (doescape(remotehost, old, new, firstack)) {
d131 4
a134 1
				continue;
d362 5
d373 1
@


1.28
log
@safety
@
text
@d3 4
a6 4
 * $Header: /res/usr/vince/src/stel/RCS/makeio.c,v 1.27 1995/02/06 20:55:46 vince Exp $
 * $Date: 1995/02/06 20:55:46 $
 * $Revision: 1.27 $
 * $Locker:  $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: makeio.c,v 1.27 1995/02/06 20:55:46 vince Exp $";
a28 1
#ifdef IDEA
a29 2
#define DES_ENCRYPT	0
#define DES_DECRYPT	1
d31 1
a31 2
extern char		IV[];
#else /* DES */
d33 1
a33 4
extern des_key_schedule	schedule1;
#ifdef TRIPLE
extern des_key_schedule	schedule2;
#endif
a34 1
#endif
d47 2
a48 2
makeio(in, out, channel, mode, remotehost, old, new)
int	in, out, channel, mode;
d66 1
a66 1
	if (mode == FLG_USE_ENCRYPTION) {
d123 1
a123 1
				if (doescape(remotehost, old, new, mode)) {
d131 1
a131 1
				CFBcrypt(&buf[i], dec);
d150 1
a150 1
				CFBcrypt(&buf[i], enc);
d183 1
a183 1
void			CFBcrypt(databyte, mode)
d215 16
a230 12
#ifdef IDEA
	cipher_idea(shift, shift, Z);
#else /* triple DES encipherment */
	des_ecb_encrypt((des_cblock *)shift, (des_cblock *)shift,
						schedule1, DES_ENCRYPT);
#ifdef TRIPLE
	des_ecb_encrypt((des_cblock *)shift, (des_cblock *)shift,
						schedule2, DES_DECRYPT);
	des_ecb_encrypt((des_cblock *)shift, (des_cblock *)shift,
						schedule1, DES_ENCRYPT);
#endif
#endif
d235 1
d238 1
d242 1
a242 1
doescape(remotehost, old, new, mode)
d245 1
a245 1
int		mode;
d288 1
d295 9
d310 1
a310 11
			printf("%s data encryption is %s\n",
#ifdef IDEA
				"IDEA",
#else
#ifdef TRIPLE
				"triple DES",
#else
				"DES",
#endif
#endif
				mode == FLG_USE_ENCRYPTION ? "on" : "OFF!!!");
@


1.27
log
@safety
@
text
@d3 4
a6 4
 * $Header: /res/usr/vince/src/stel/RCS/makeio.c,v 1.26 1995/01/24 15:55:43 vince Exp vince $
 * $Date: 1995/01/24 15:55:43 $
 * $Revision: 1.26 $
 * $Locker: vince $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: makeio.c,v 1.26 1995/01/24 15:55:43 vince Exp vince $";
d428 1
a428 1
"Reminder - Do not use this while logged in via telnet or dial-in.\n\n");
@


1.26
log
@safety
@
text
@d3 4
a6 4
 * $Header: /res/usr/vince/src/stel/RCS/makeio.c,v 1.25 1995/01/24 10:04:40 vince Exp $
 * $Date: 1995/01/24 10:04:40 $
 * $Revision: 1.25 $
 * $Locker:  $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: makeio.c,v 1.25 1995/01/24 10:04:40 vince Exp $";
d132 2
a133 1
					break; /* terminate session */
@


1.25
log
@safety
@
text
@d3 3
a5 3
 * $Header: /res/usr/vince/src/stel/RCS/makeio.c,v 1.24 1995/01/21 16:44:56 vince Exp $
 * $Date: 1995/01/21 16:44:56 $
 * $Revision: 1.24 $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: makeio.c,v 1.24 1995/01/21 16:44:56 vince Exp $";
d295 6
a300 6
			printf("connected to %s.\n", remotehost);
			printf("connection time: %s", ctime(&start));
			printf("elapsed time: %d hours, %d minutes, %d seconds\n", hrs, min, sec);
			printf("user keystrokes: %ld\n", inbytes);
			printf("session output is %ld bytes\n", outbytes);
			printf("escape character is '%s'\n", control(escape));
d312 1
a312 1
			continue;
d364 1
a364 1
			printf("?		 print help information\n");
d427 1
a427 2
"Reminder - Do not generate skey responses while logged in your LOCAL\n\
system via telnet or dial-in.\n");
d429 1
a429 1
	printf("enter seed: ");
@


1.24
log
@safety
@
text
@d3 3
a5 3
 * $Header: /res/usr/vince/src/stel/RCS/makeio.c,v 1.23 1995/01/21 16:35:47 vince Exp $
 * $Date: 1995/01/21 16:35:47 $
 * $Revision: 1.23 $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: makeio.c,v 1.23 1995/01/21 16:35:47 vince Exp $";
d427 1
a427 1
"Reminder - Do not generate skey responses while logged in your local\n\
@


1.23
log
@safety
@
text
@d3 3
a5 3
 * $Header: /res/usr/vince/src/stel/RCS/makeio.c,v 1.22 1995/01/21 16:12:57 vince Exp $
 * $Date: 1995/01/21 16:12:57 $
 * $Revision: 1.22 $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: makeio.c,v 1.22 1995/01/21 16:12:57 vince Exp $";
d131 1
a131 1
				if (doescape(remotehost, old, new, mode))
d133 1
d426 3
a428 1
	printf("Reminder - You should be safely logged in your local system.\n");
d469 1
a469 1
		printf("mjr DES mode [n] ? ");
@


1.22
log
@safety
@
text
@d3 4
a6 4
 * $Header: /res/usr/vince/src/stel/RCS/makeio.c,v 1.21 1995/01/21 15:37:28 vince Exp vince $
 * $Date: 1995/01/21 15:37:28 $
 * $Revision: 1.21 $
 * $Locker: vince $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: makeio.c,v 1.21 1995/01/21 15:37:28 vince Exp vince $";
d280 1
a280 2
			if (skeyresp())
				printf("skey response generation failed.\n");
d427 1
a427 1
	printf("Enter seed (i.e., gh33358): ");
d463 1
d465 9
a473 7
	printf("\nMJR DES mode [n] ? ");
	(void)fflush(stdout);
	if (fgets(buf, sizeof(buf), stdin) == NULL)
		return(1);
	rip(buf);
	if (buf[0] == 'y')
		desmode = 1;
@


1.21
log
@safety
@
text
@d3 3
a5 3
 * $Header: /res/usr/vince/src/stel/RCS/makeio.c,v 1.17 1995/01/21 14:26:31 vince Exp vince $
 * $Date: 1995/01/21 14:26:31 $
 * $Revision: 1.17 $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: makeio.c,v 1.17 1995/01/21 14:26:31 vince Exp vince $";
d301 10
a310 1
			printf("data encryption is %s\n",
d344 2
a345 2
			printf("Current escape character is: %x\n",
						(unsigned char *)escape);
d399 1
a399 5
	/*
	if (c == (cc_t)_POSIX_VDISABLE) {
		return "off";
	}
	*/
d425 2
@


1.20
log
@safety
@
text
@a411 1

@


1.19
log
@safety
@
text
@d52 3
d280 2
a281 1
			skeyresp();
d418 3
d440 13
a452 1
	readpass(passwd, sizeof(passwd));
d454 6
a459 1
	printf("Ranum DES mode [n] ? ");
d478 7
@


1.18
log
@safety
@
text
@d20 4
d26 1
d262 1
a262 1
		line[strlen(line) - 1] = '\0';
d277 1
a277 1
			printf("This is not implemented yet. Sorry.\n");
d343 1
a343 1
		if (!strcmp(line, "?") || !strcmp(line, "help")) {
d351 1
a351 1
			printf("?, help		print help information\n");
d355 1
a355 1
		printf("?Invalid command\n");
d406 48
@


1.17
log
@safety
@
text
@d3 4
a6 4
 * $Header: /res/usr/vince/src/stel/RCS/makeio.c,v 1.15 1994/12/28 12:18:20 vince Exp $
 * $Date: 1994/12/28 12:18:20 $
 * $Revision: 1.15 $
 * $Locker:  $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: makeio.c,v 1.15 1994/12/28 12:18:20 vince Exp $";
d43 5
a47 1
makeio(in, out, channel, mode, old, new)
d50 1
d60 1
d118 3
a120 1

d122 3
a124 3
			if (old && new && len == 1 && buf[0] == escape) {
				if (doescape(old, new)) /* user termination */
					break;
d141 1
d144 3
d234 2
a235 1
doescape(old, new)
d237 1
d241 1
d251 1
a251 1
		printf("stel> ");
d253 1
a253 1
			quit = 1;
d259 1
a259 1
		/* quit connection */
a260 1
			quit = 1;
d278 16
a293 1
			printf("This is not implemented yet. Sorry.\n");
a320 1
			printf("[Returning to remote]\n");
d347 1
d358 43
@


1.16
log
@safety
@
text
@d241 1
@


1.15
log
@safety
@
text
@d3 3
a5 3
 * $Header: /res/usr/vince/src/stel/RCS/makeio.c,v 1.14 1994/11/30 08:15:06 vince Exp $
 * $Date: 1994/11/30 08:15:06 $
 * $Revision: 1.14 $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: makeio.c,v 1.14 1994/11/30 08:15:06 vince Exp $";
d39 5
a43 1
makeio(in, out, channel, mode)
d45 1
a53 1
	long		oldmask;
d112 8
d122 1
d220 108
@


1.14
log
@safety
@
text
@d3 4
a6 4
 * $Header: /res/usr/vince/src/stel/RCS/makeio.c,v 1.13 1994/11/28 18:26:12 vince Exp vince $
 * $Date: 1994/11/28 18:26:12 $
 * $Revision: 1.13 $
 * $Locker: vince $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: makeio.c,v 1.13 1994/11/28 18:26:12 vince Exp vince $";
d33 1
d35 1
d191 8
a198 3
	des_ecb_encrypt(shift, shift, schedule1, DES_ENCRYPT);
	des_ecb_encrypt(shift, shift, schedule2, DES_DECRYPT);
	des_ecb_encrypt(shift, shift, schedule1, DES_ENCRYPT);
@


1.13
log
@safety
@
text
@d3 4
a6 4
 * $Header: /res/usr/vince/src/dh/RCS/makeio.c,v 1.12 1994/11/26 15:06:48 vince Exp $
 * $Date: 1994/11/26 15:06:48 $
 * $Revision: 1.12 $
 * $Locker:  $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: makeio.c,v 1.12 1994/11/26 15:06:48 vince Exp $";
d133 1
a133 1
#ifdef hpux
d137 1
a137 1
#endif /* hpux */
@


1.12
log
@safety
@
text
@d3 3
a5 3
 * $Header: /res/usr/vince/src/dh/RCS/makeio.c,v 1.11 1994/11/26 13:15:59 vince Exp $
 * $Date: 1994/11/26 13:15:59 $
 * $Revision: 1.11 $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: makeio.c,v 1.11 1994/11/26 13:15:59 vince Exp $";
d66 2
d69 1
d71 1
d86 1
d88 1
d92 1
a92 1
		/* block signals */
@


1.11
log
@safety
@
text
@d3 4
a6 4
 * $Header: /res/usr/vince/src/dh/RCS/makeio.c,v 1.10 1994/11/26 11:26:15 vince Exp vince $
 * $Date: 1994/11/26 11:26:15 $
 * $Revision: 1.10 $
 * $Locker: vince $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: makeio.c,v 1.10 1994/11/26 11:26:15 vince Exp vince $";
a135 1
	printf("XXXXXXXXXXXXXX DEAD\n");
@


1.10
log
@safety
@
text
@d3 3
a5 3
 * $Header: /res/usr/vince/src/dh/RCS/makeio.c,v 1.9 1994/10/26 10:11:39 vince Exp vince $
 * $Date: 1994/10/26 10:11:39 $
 * $Revision: 1.9 $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: makeio.c,v 1.9 1994/10/26 10:11:39 vince Exp vince $";
d19 1
d48 1
d50 1
a50 1

d63 3
a65 1
		/*
d67 4
a70 2
			printf("CASE ONE\n");
			return(0);
d72 1
a72 1
		*/
d74 9
a82 7
		(void)sigsetmask(oldmask);

		if (select(32, &mask, 0, 0, 0) == -1) {
			if (errno == EINTR && child_is_dead) {
				/*
				printf("CASE TWO\n");
				*/
a83 3
			}
			syslog(LOGPRI, "select(): %m");
			return(1);
d86 1
a121 3
	/*
	printf("CASE THREE\n");
	*/
d136 1
@


1.9
log
@safety
@
text
@d3 4
a6 4
 * $Header: /res/usr/vince/src/dh/RCS/makeio.c,v 1.8 1994/10/24 20:19:34 vince Exp $
 * $Date: 1994/10/24 20:19:34 $
 * $Revision: 1.8 $
 * $Locker:  $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: makeio.c,v 1.8 1994/10/24 20:19:34 vince Exp $";
d46 3
d50 1
d61 6
d68 1
a68 2
		if (child_is_dead)
			return(0);
d71 4
a74 1
			if (errno == EINTR && child_is_dead)
d76 1
d81 2
d116 3
@


1.8
log
@safety
@
text
@d3 4
a6 4
 * $Header: /res/usr/vince/src/dh/RCS/makeio.c,v 1.7 1994/10/24 18:17:21 vince Exp vince $
 * $Date: 1994/10/24 18:17:21 $
 * $Revision: 1.7 $
 * $Locker: vince $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: makeio.c,v 1.7 1994/10/24 18:17:21 vince Exp vince $";
d18 1
d61 5
a65 9
		switch (select(32, &mask, 0, 0, 0)) {
			case	-1:
				if (errno == EINTR && child_is_dead)
					return(0);
				else
					return(1);
			case	0:
				(void)fprintf(stderr, "select() failed\n");
				return(1);
d74 1
a74 1
				perror("read()");
d82 1
d88 1
a88 1
				perror("read()");
d96 1
@


1.7
log
@safety
@
text
@d3 3
a5 3
 * $Header: /res/usr/vince/src/dh/RCS/makeio.c,v 1.6 1994/08/17 14:53:22 vince Exp vince $
 * $Date: 1994/08/17 14:53:22 $
 * $Revision: 1.6 $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: makeio.c,v 1.6 1994/08/17 14:53:22 vince Exp vince $";
d73 4
d90 1
@


1.6
log
@safety
@
text
@d3 3
a5 3
 * $Header: /res/usr/vince/src/dh/RCS/makeio.c,v 1.5 1994/08/17 11:20:32 vince Exp vince $
 * $Date: 1994/08/17 11:20:32 $
 * $Revision: 1.5 $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: makeio.c,v 1.5 1994/08/17 11:20:32 vince Exp vince $";
d80 1
a80 1
			if (write(channel, buf, len) != len) {
@


1.5
log
@safety
@
text
@d3 3
a5 3
 * $Header: /res/usr/vince/src/dh/RCS/makeio.c,v 1.4 1994/06/13 22:36:31 vince Exp vince $
 * $Date: 1994/06/13 22:36:31 $
 * $Revision: 1.4 $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: makeio.c,v 1.4 1994/06/13 22:36:31 vince Exp vince $";
a21 2
#include "des.h"

d24 2
d29 1
@


1.4
log
@safety
@
text
@d3 3
a5 3
 * $Header: /res/usr/vince/src/dh/RCS/makeio.c,v 1.3 1994/06/13 16:44:05 vince Exp vince $
 * $Date: 1994/06/13 16:44:05 $
 * $Revision: 1.3 $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: makeio.c,v 1.3 1994/06/13 16:44:05 vince Exp vince $";
d20 2
d24 5
a28 1
static int		child_is_dead;
d32 1
d154 3
a156 1
	/* triple DES encipherment */
d160 1
@


1.3
log
@safety
@
text
@d3 3
a5 3
 * $Header: /res/usr/vince/src/dh/RCS/makeio.c,v 1.2 1994/06/13 00:04:42 vince Exp vince $
 * $Date: 1994/06/13 00:04:42 $
 * $Revision: 1.2 $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: makeio.c,v 1.2 1994/06/13 00:04:42 vince Exp vince $";
d25 1
d32 1
a32 1
	char		buf[BUFSIZ];
a34 1
	des_cblock	IV;
a36 1
	bzero(IV, sizeof(IV));
d71 1
a71 1
				CFBcrypt(&buf[i], IV, dec);
d83 1
a83 1
				CFBcrypt(&buf[i], IV, enc);
d115 1
a115 1
void			CFBcrypt(databyte, IV, mode)
a116 1
des_cblock		*IV;
@


1.2
log
@safety
@
text
@d3 3
a5 3
 * $Header: /res/usr/vince/src/dh/RCS/makeio.c,v 1.1 1994/06/06 16:27:39 vince Exp vince $
 * $Date: 1994/06/06 16:27:39 $
 * $Revision: 1.1 $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: makeio.c,v 1.1 1994/06/06 16:27:39 vince Exp vince $";
d17 2
d23 2
a24 1
extern des_key_schedule	schedule;
d26 2
a27 2
makeio(in, out, channel)
int	in, out, channel;
d35 1
d38 1
d40 7
a46 1
	(void)signal(SIGCLD, deadchild);
d50 2
d72 1
a72 1
				CFBcrypt(&buf[i], &schedule, IV, DES_DECRYPT);
d84 1
a84 1
				CFBcrypt(&buf[i], &schedule, IV, DES_ENCRYPT);
d103 1
a104 1
        child_is_dead++;
d116 1
a116 1
void			CFBcrypt(databyte, schedule, IV, mode)
a117 1
des_key_schedule	*schedule;
d125 3
d149 4
a152 1
	des_ecb_encrypt(shift, shift, schedule, DES_ENCRYPT);
@


1.1
log
@safety
@
text
@d3 2
a4 2
 * $Header: /res/usr/vince/src/netshield/RCS/makeio.c,v 1.1 1994/05/09 00:28:23 vince Exp vince $
 * $Date: 1994/05/09 00:28:23 $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: makeio.c,v 1.1 1994/05/09 00:28:23 vince Exp vince $";
d18 1
a18 1
static int	child_is_dead;
d20 3
d26 1
a26 1
	register	len;
d30 4
a33 1
	void		deadchild();
d58 2
d70 2
d93 49
@
