head	1.101;
access;
symbols;
locks
	vince:1.101; strict;
comment	@ * @;


1.101
date	96.04.26.16.29.23;	author vince;	state Exp;
branches;
next	1.100;

1.100
date	96.04.01.16.17.21;	author vince;	state Exp;
branches;
next	1.99;

1.99
date	96.03.31.09.41.11;	author vince;	state Exp;
branches;
next	1.98;

1.98
date	96.03.30.14.58.08;	author vince;	state Exp;
branches;
next	1.97;

1.97
date	96.02.03.13.24.46;	author vince;	state Exp;
branches;
next	1.96;

1.96
date	96.01.03.18.20.26;	author vince;	state Exp;
branches;
next	1.95;

1.95
date	96.01.02.16.41.03;	author vince;	state Exp;
branches;
next	1.94;

1.94
date	95.12.21.10.58.55;	author vince;	state Exp;
branches;
next	1.93;

1.93
date	95.12.20.18.33.49;	author vince;	state Exp;
branches;
next	1.92;

1.92
date	95.12.19.08.37.40;	author vince;	state Exp;
branches;
next	1.91;

1.91
date	95.12.14.10.36.13;	author vince;	state Exp;
branches;
next	1.90;

1.90
date	95.12.08.14.38.55;	author vince;	state Exp;
branches;
next	1.89;

1.89
date	95.12.04.16.36.21;	author vince;	state Exp;
branches;
next	1.88;

1.88
date	95.11.29.14.00.27;	author vince;	state Exp;
branches;
next	1.87;

1.87
date	95.11.29.13.18.46;	author vince;	state Exp;
branches;
next	1.86;

1.86
date	95.11.28.11.12.56;	author vince;	state Exp;
branches;
next	1.85;

1.85
date	95.11.27.15.52.59;	author vince;	state Exp;
branches;
next	1.84;

1.84
date	95.11.25.19.19.41;	author vince;	state Exp;
branches;
next	1.83;

1.83
date	95.11.25.19.13.48;	author vince;	state Exp;
branches;
next	1.82;

1.82
date	95.11.25.19.08.29;	author vince;	state Exp;
branches;
next	1.81;

1.81
date	95.11.25.19.02.12;	author vince;	state Exp;
branches;
next	1.80;

1.80
date	95.11.25.18.19.51;	author vince;	state Exp;
branches;
next	1.79;

1.79
date	95.11.25.16.53.41;	author vince;	state Exp;
branches;
next	1.78;

1.78
date	95.11.24.14.07.46;	author vince;	state Exp;
branches;
next	1.77;

1.77
date	95.11.24.14.04.05;	author vince;	state Exp;
branches;
next	1.76;

1.76
date	95.11.24.12.26.47;	author vince;	state Exp;
branches;
next	1.75;

1.75
date	95.11.23.16.30.38;	author vince;	state Exp;
branches;
next	1.74;

1.74
date	95.11.21.09.56.21;	author vince;	state Exp;
branches;
next	1.73;

1.73
date	95.08.26.12.01.03;	author vince;	state Exp;
branches;
next	1.72;

1.72
date	95.08.26.09.47.35;	author vince;	state Exp;
branches;
next	1.71;

1.71
date	95.08.26.07.47.15;	author vince;	state Exp;
branches;
next	1.70;

1.70
date	95.08.25.15.58.26;	author vince;	state Exp;
branches;
next	1.69;

1.69
date	95.08.25.10.59.54;	author vince;	state Exp;
branches;
next	1.68;

1.68
date	95.08.23.19.12.23;	author vince;	state Exp;
branches;
next	1.67;

1.67
date	95.07.19.18.58.54;	author vince;	state Exp;
branches;
next	1.66;

1.66
date	95.07.14.13.58.45;	author vince;	state Exp;
branches;
next	1.65;

1.65
date	95.07.14.13.31.29;	author vince;	state Exp;
branches;
next	1.64;

1.64
date	95.07.14.11.36.25;	author vince;	state Exp;
branches;
next	1.63;

1.63
date	95.07.13.17.37.31;	author vince;	state Exp;
branches;
next	1.62;

1.62
date	95.07.13.17.35.49;	author vince;	state Exp;
branches;
next	1.61;

1.61
date	95.07.13.11.03.57;	author vince;	state Exp;
branches;
next	1.60;

1.60
date	95.07.12.16.44.00;	author vince;	state Exp;
branches;
next	1.59;

1.59
date	95.05.11.16.24.24;	author vince;	state Exp;
branches;
next	1.58;

1.58
date	95.05.10.18.00.18;	author vince;	state Exp;
branches;
next	1.57;

1.57
date	95.05.10.15.10.14;	author vince;	state Exp;
branches;
next	1.56;

1.56
date	95.05.06.15.39.00;	author vince;	state Exp;
branches;
next	1.55;

1.55
date	95.04.22.09.42.58;	author vince;	state Exp;
branches;
next	1.54;

1.54
date	95.04.21.18.27.26;	author vince;	state Exp;
branches;
next	1.53;

1.53
date	95.04.08.15.48.43;	author vince;	state Exp;
branches;
next	1.52;

1.52
date	95.04.08.11.18.38;	author vince;	state Exp;
branches;
next	1.51;

1.51
date	95.04.05.16.35.14;	author vince;	state Exp;
branches;
next	1.50;

1.50
date	95.04.04.10.27.58;	author vince;	state Exp;
branches;
next	1.49;

1.49
date	95.04.03.16.56.36;	author vince;	state Exp;
branches;
next	1.48;

1.48
date	95.04.03.16.48.51;	author vince;	state Exp;
branches;
next	1.47;

1.47
date	95.04.03.16.41.40;	author vince;	state Exp;
branches;
next	1.46;

1.46
date	95.03.31.19.34.43;	author vince;	state Exp;
branches;
next	1.45;

1.45
date	95.03.24.11.25.37;	author vince;	state Exp;
branches;
next	1.44;

1.44
date	95.02.27.15.03.39;	author vince;	state Exp;
branches;
next	1.43;

1.43
date	95.02.27.11.11.52;	author vince;	state Exp;
branches;
next	1.42;

1.42
date	95.02.27.10.51.12;	author vince;	state Exp;
branches;
next	1.41;

1.41
date	95.02.27.10.46.19;	author vince;	state Exp;
branches;
next	1.40;

1.40
date	95.02.27.07.59.00;	author vince;	state Exp;
branches;
next	1.39;

1.39
date	95.02.25.15.26.39;	author vince;	state Exp;
branches;
next	1.38;

1.38
date	95.02.23.17.14.54;	author vince;	state Exp;
branches;
next	1.37;

1.37
date	95.02.23.15.49.43;	author vince;	state Exp;
branches;
next	1.36;

1.36
date	95.02.23.13.45.13;	author vince;	state Exp;
branches;
next	1.35;

1.35
date	95.02.21.20.50.15;	author vince;	state Exp;
branches;
next	1.34;

1.34
date	95.02.20.13.33.59;	author vince;	state Exp;
branches;
next	1.33;

1.33
date	95.02.20.11.16.18;	author vince;	state Exp;
branches;
next	1.32;

1.32
date	95.02.20.10.23.35;	author vince;	state Exp;
branches;
next	1.31;

1.31
date	95.02.20.10.10.16;	author vince;	state Exp;
branches;
next	1.30;

1.30
date	95.02.17.14.50.11;	author vince;	state Exp;
branches;
next	1.29;

1.29
date	95.02.17.14.22.02;	author vince;	state Exp;
branches;
next	1.28;

1.28
date	95.02.16.18.56.47;	author vince;	state Exp;
branches;
next	1.27;

1.27
date	95.02.16.17.21.59;	author vince;	state Exp;
branches;
next	1.26;

1.26
date	95.02.16.15.42.44;	author vince;	state Exp;
branches;
next	1.25;

1.25
date	95.02.16.14.55.10;	author vince;	state Exp;
branches;
next	1.24;

1.24
date	95.02.15.15.49.15;	author vince;	state Exp;
branches;
next	1.23;

1.23
date	95.02.06.20.55.46;	author vince;	state Exp;
branches;
next	1.22;

1.22
date	95.01.19.13.43.45;	author vince;	state Exp;
branches;
next	1.21;

1.21
date	95.01.19.12.46.07;	author vince;	state Exp;
branches;
next	1.20;

1.20
date	94.12.28.12.18.20;	author vince;	state Exp;
branches;
next	1.19;

1.19
date	94.12.18.14.44.44;	author vince;	state Exp;
branches;
next	1.18;

1.18
date	94.11.30.08.15.06;	author vince;	state Exp;
branches;
next	1.17;

1.17
date	94.11.28.18.26.12;	author vince;	state Exp;
branches;
next	1.16;

1.16
date	94.11.26.15.06.48;	author vince;	state Exp;
branches;
next	1.15;

1.15
date	94.11.26.11.26.15;	author vince;	state Exp;
branches;
next	1.14;

1.14
date	94.10.26.10.11.39;	author vince;	state Exp;
branches;
next	1.13;

1.13
date	94.10.25.16.45.52;	author vince;	state Exp;
branches;
next	1.12;

1.12
date	94.10.25.15.09.38;	author vince;	state Exp;
branches;
next	1.11;

1.11
date	94.10.25.15.05.42;	author vince;	state Exp;
branches;
next	1.10;

1.10
date	94.10.25.14.43.04;	author vince;	state Exp;
branches;
next	1.9;

1.9
date	94.10.25.12.59.40;	author vince;	state Exp;
branches;
next	1.8;

1.8
date	94.10.24.18.17.21;	author vince;	state Exp;
branches;
next	1.7;

1.7
date	94.08.17.11.20.32;	author vince;	state Exp;
branches;
next	1.6;

1.6
date	94.06.13.22.36.31;	author vince;	state Exp;
branches;
next	1.5;

1.5
date	94.06.13.16.44.05;	author vince;	state Exp;
branches;
next	1.4;

1.4
date	94.06.13.00.04.42;	author vince;	state Exp;
branches;
next	1.3;

1.3
date	94.06.12.21.55.31;	author vince;	state Exp;
branches;
next	1.2;

1.2
date	94.06.06.16.27.39;	author vince;	state Exp;
branches;
next	1.1;

1.1
date	94.06.06.15.23.00;	author vince;	state Exp;
branches;
next	;


desc
@@


1.101
log
@safety
@
text
@/*
 * $Author: vince $
 * $Header: /users/vince/src/stel/RCS/sub.c,v 1.100 1996/04/01 16:17:21 vince Exp $
 * $Date: 1996/04/01 16:17:21 $
 * $Revision: 1.100 $
 * $Locker:  $
 */

#ifndef	lint
static char *rcsid = "@@(#) $Id: sub.c,v 1.100 1996/04/01 16:17:21 vince Exp $";
#endif	lint

#include <stdio.h>
#include <termios.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/types.h>
#include <netinet/in.h>
#include <sys/socket.h>
#include <netdb.h>
#include <errno.h>
#include <sys/wait.h>
#include <signal.h>
#include <sys/stat.h>
#include <sys/utsname.h>
#include <syslog.h>
#include <varargs.h>

#include "regex.h"

#ifdef HAS_SYS_PARAM_H
#include <sys/param.h>
#endif

#ifndef SOLARIS
#if (defined(BSD) && (BSD >= 199306))
#define SIGCLD  SIGCHLD
#endif
#endif

/* md5 stuff */
#include "global.h"
#include "md5.h"

#include "gmp.h"

#include "defs.h"

/* idea stuff */
#include "idea.h"
IDEAkey			s_ideakey;	/* server */
IDEAkey			c_ideakey;	/* client */

/* des stuff */
/* #include "des.h" */
des_key_schedule	s_schedule1;	/* server */
des_key_schedule	s_schedule2;	/* server */
des_key_schedule	s_schedule3;	/* server */
des_key_schedule	c_schedule1;	/* client */
des_key_schedule	c_schedule2;	/* client */
des_key_schedule	c_schedule3;	/* client */

des_cblock		s_IV;		/* server, IDEA and DES only */
des_cblock		c_IV;		/* client, IDEA and DES only */

/* rc4 stuff */
#include "rc4.h"
RC4Context		s_rc4;		/* server */
RC4Context		c_rc4;		/* client */

/* rc5 stuff */
unsigned char		s_rc5[16];	/* server */
unsigned char		c_rc5[16];	/* client */

/* initialisation variables */

/* global */
char		sessionkeyhash[8];

static char	*buildregexp();
static		oneofthese();
static		doaddrmatch();
static void	CFBcrypt();

establish(portnum)
int	portnum;
{
	struct sockaddr_in	sa;
	int			s, on = 1;
	struct servent		*serv;

	if (!portnum) {
		if ((serv = getservbyname(STELCLIENT, "tcp")) == NULL)
			portnum = PORTNUM;
		else
			portnum = serv->s_port;
	}
	
	sa.sin_family 		= AF_INET;
	sa.sin_addr.s_addr	= INADDR_ANY;
	sa.sin_port		= htons((u_short)portnum);

	if ((s = socket(AF_INET, SOCK_STREAM, 0)) == -1) {
		syslog(LOGPRI, "socket(): %m");
		return(-1);
	}

	if (setsockopt(s, SOL_SOCKET, SO_KEEPALIVE,
					(char *)&on, sizeof (on)) == -1) {
		syslog(LOGPRI, "setsockopt (SO_KEEPALIVE): %m");
		return(-1);
	}

#ifdef DEBUG
	if (setsockopt(s, SOL_SOCKET, SO_REUSEADDR,
					(char *)&on, sizeof (on)) == -1) {
		syslog(LOGPRI, "setsockopt (SO_REUSEADDR): %m");
		return(-1);
	}
#endif
	
	if (bind(s, (struct sockaddr *)&sa, sizeof(sa)) == -1) {
		perror("bind()");
		(void)fprintf(stderr, "cannot bind to port %d; may be another server is running?\n",
							portnum);
		syslog(LOGPRI, "bind(%d): %m", portnum);
		return(-1);
	}
	
	if (listen(s, 10) == -1) {
		syslog(LOGPRI, "listen(): %m");
		return(-1);
	}
	return(s);
}

getconnection(s, hostname)
int	s;
char	*hostname;
{
	struct sockaddr_in	sa;
	struct hostent		*he;
	int			t, salen;

	salen = sizeof(sa);
	if ((t = accept(s, (struct sockaddr *)&sa, &salen)) < 0) {
		return(-1);
	}
	
	if ((he = gethostbyaddr((char *)&sa.sin_addr,
				sizeof(struct in_addr), AF_INET)) == NULL)
		(void)strcpy(hostname, (char *)inet_ntoa(sa.sin_addr));
	else
		(void)strncpy(hostname, he->h_name, MAXHNAMELEN);
	return(t);
}

char *
peername(fd)
int	fd;
{
	struct sockaddr_in	addr;
	struct hostent		*he;
	static char		name[MAXHNAMELEN];
	int			addrlen = sizeof(addr);

	if (getpeername(fd, (struct sockaddr *)&addr, &addrlen) == -1)
		return(NULL);

	if ((he = gethostbyaddr((char *)&addr.sin_addr,
				sizeof(struct in_addr), AF_INET)) == NULL)
		(void)strcpy(name, (char *) inet_ntoa(addr.sin_addr));
	else
		(void)strncpy(name, he->h_name, sizeof(name));
	return(name);
}

callsocket(hostname, portnum)
char	*hostname;
int	portnum;
{
	struct sockaddr_in	sa;
	struct hostent		*hp;
	int			s, on = 1;
	extern int		errno;

	bzero(&sa, sizeof(sa));
	if ((hp = gethostbyname(hostname)) == NULL) {
		if ((sa.sin_addr.s_addr = inet_addr(hostname)) == -1) {
			(void)fprintf(stderr, "%s: unknown host\n", hostname);
			return(-1);
		}
	}
	else {
		(void)memcpy((char *) &sa.sin_addr, hp->h_addr, hp->h_length);
		strcpy(hostname, hp->h_name);
	}
	sa.sin_family = AF_INET;
	sa.sin_port = htons((u_short)portnum);

	if ((s = socket(AF_INET, SOCK_STREAM, 0)) < 0) {
		perror("socket()");
		return(-1);
	}
	if (setsockopt(s, SOL_SOCKET, SO_KEEPALIVE, (char *)&on,
							sizeof(on)) == -1) {
		perror("setsockopt(SO_KEEPALIVE)");
		return(-1);
	}
	
#if defined(SOCKS)
	if (Rconnect(s, (struct sockaddr *)&sa, sizeof(sa)) == -1) {
#else
	if (connect(s, (struct sockaddr *)&sa, sizeof(sa)) == -1) {
#endif
                perror("connect()");
                return(-1);
        }
	
	return(s);
}

void
fireman()
{
#if defined(hpux) || defined(SOLARIS) || defined(IRIX) || defined(AIX) || defined(BSDI)
	int	wstatus;
#else
	union wait      wstatus;
#endif

#ifdef SOLARIS24
	(void)wait(NULL);
#else
        while (wait3(&wstatus, WNOHANG, NULL) > 0)
                ;
#endif
	(void)signal(SIGCLD, fireman);
}

#ifdef IRIX
int	getpty(line)
char	*line;
{
	int		slave;
	char		*_getpty();
	char		*mline;

	mline = _getpty(&slave, O_RDWR, 0600, 1);
	if (mline == NULL) {
		perror("_getpty()");
		return(-1);
	}
	strcpy(line, mline);
	return(slave);
}
#else /* !IRIX */
#ifdef SOLARIS
#include <sys/stropts.h>
int	getpty(line)
char	*line;
{
	int	p;
	char	*buf;
	char	*ptsname();

	if ((p = open("/dev/ptmx", O_RDWR)) < 0) {
		puts("All network ports in use");
		return(-1);
	}
	if (grantpt(p) < 0 || unlockpt(p) < 0) {
		puts("Cannot initialize pty slave");
		return(-1);
	}

	if ((buf = ptsname(p)) == 0) {
		puts("Cannot find  pty slave");
		return(-1);
	}
	strcpy(line, buf);

	return(p);
}

#else /* !SOLARIS */
int	getpty(line)
char	*line;
{
        register int p;
        register char c, *p1, *p2;
        register int i;
	char tmp[16];

#ifdef hpux
        (void) sprintf(line, "/dev/ptym/ptyXX");
        p1 = &line[13];
        p2 = &line[14];
#else
        (void) sprintf(line, "/dev/ptyXX");
        p1 = &line[8];
        p2 = &line[9];
#endif
        for (c = 'p'; c <= 'z'; c++) {
                struct stat stb;

                *p1 = c;
                *p2 = '0';
                if (stat(line, &stb) < 0)
                        continue;
                for (i = 0; i < 16; i++) {
                        *p2 = "0123456789abcdef"[i];
                        p = open(line, O_RDWR);
			if (p > 0) {
#ifdef hpux
				sprintf(tmp, "/dev/pty/tty%c%c", *p1, *p2);
#else
				sprintf(tmp, "/dev/tty%c%c", *p1, *p2);
#endif
				if (!access(tmp, R_OK | W_OK)) {
					strcpy(line, tmp);
					return(p);
				}
                        }
                }
        }
        return(-1);
}
#endif /* SOLARIS */
#endif /* !IRIX */

/* 512 bits modulus */
char	*smallmodulostring = "\
D7EE241E121D4993D8FF64313C1B57F0388243704B98F9FABC7EFC1F\
A36803B88337E7220693839293974DD183990A5AA6FD5FCE0CC3DDED\
2CE73933B270CFA7";

/* 1024 bits modulus */
char *defaultmodulostring = "\
96F5D737535D8BC982698A80AB91DAE28E84E2982071998880C736B5\
695AF14D015401A942186B865496ECBECAFE964A5E70B7031F5756C0\
60AD53528687F4FBFF059150D529638C11FA6FAB6A58785DBD62D73D\
1001014BE3EA53E97D43944F1EF83885196E5BCDD4098744B7673B54\
BA2EB1FDB29ED2C3BA3AD8644FAFF05F";

/* 2048 bits modulo */
char *largemodulostring = "\
E269EF4E 56C7CC6B 34897619 7DD83DE3 C9BE3C34 ACE6A557 36A662E5\
F8210923 3BBF3357 5C5D4924 4AE73744 EEFDA659 884A7C63 C3BAD016\
426335E0 A4FA7B2C 323C4B0E AD4D745A 6A5DB92C 99A5D040 F6F4FBC8\
13132332 F6233C68 11AD3112 5148C55A F1B99D5A DE3531ED F68217AB\
D4B1D105 AF58A55F A2C4A1D4 A5E391DF 68C8FF1C 78C6ED6F 24D7B848\
5437E97F D71B6798 6A94DF03 9BD557D7 9D038724 382E86BF 2197E021\
516DC16E DAE86723 85FB1A84 00B9822E 4A6ADEF2 3EBC75C6 02D05FF6\
CB854914 0E7B91C3 A1011399 78A1EC83 B59EB508 F51F6098 6F4CEFF3\
BA13D59C 1136D8C8 288AB1BC A56CBD92 AAAF1CED 07D21764 FF4603FB\
4D2F6E8B";

dhexchange(s, side, firstack, rndstr)
int	s, side, firstack;
unsigned char	*rndstr;
{
	MP_INT		modulo, three, sharedsecret, mysecret,
			mypublic, hispublic;
	char		pwstr[4096], exchange[4096];
	unsigned char	randbuf[4096];
	int		i, modulobits, secretkeybits;
	MD5_CTX		mdContext;
	unsigned char	digest1[16], digest2[16];
	des_key_schedule	tmpsched;
	des_cblock	c_third, s_third;

	unsigned char	*internalrnd();

	mpz_init(&modulo);
	mpz_init(&three);
	mpz_init(&sharedsecret);
	mpz_init(&mysecret);
	mpz_init(&mypublic);
	mpz_init(&hispublic);

	mpz_set_ui(&three, 3L);
	if (firstack & FLG_LARGE_MODULUS) /* 2048 bits modulo */
		mpz_set_str(&modulo, largemodulostring, 16);
	else if (firstack & FLG_SMALL_MODULUS) /* 512 bits modulus */
		mpz_set_str(&modulo, smallmodulostring, 16);
	else /* 1024 bits modulus */
		mpz_set_str(&modulo, defaultmodulostring, 16);

	/* get randomness from system */
	strncpy(randbuf, internalrnd(), sizeof(randbuf));

	/* user-provided randomness */
	if (rndstr) {
		(void)strcat(randbuf, "\n");
		(void)strncat(randbuf, rndstr,
				sizeof(randbuf) - strlen(randbuf) - 2);
	}

	/* dh: generate a random number % modulo */
	mkrnd(randbuf, &mysecret, &modulo,
			(side == CLIENT_SIDE && firstack & FLG_DEBUG));

	modulobits = mpz_sizeinbase(&modulo, 2);
	secretkeybits = mpz_sizeinbase(&mysecret, 2);
	if (side == CLIENT_SIDE && firstack & FLG_BE_VERBOSE) {
		if (firstack & FLG_DEBUG)
			printf("\nGENERATING KEYS WITH DIFFIE-HELLMAN\n");
		printf("Using %d bits modulus, %d bits secret key\n",
						modulobits, secretkeybits);
		printf("exchanging keys with DH scheme (can be a lengthy process)...\n");
	}

	if (side == CLIENT_SIDE && firstack & FLG_BE_VERBOSE) {
		printf("x (client secret key) randomly generated\n");
		if (firstack & FLG_DEBUG) {
			printf("x (client secret key):\n");
			mpz_out_str(stdout, 10, &mysecret);
			printf("\n");
		}
	}

	/* dh: calculate exponential */
	mpz_powm(&mypublic, &three, &mysecret, &modulo);

	bzero(exchange, sizeof(exchange));
	mpz_get_str(exchange, 10, &mypublic);

	if (side == CLIENT_SIDE && firstack & FLG_BE_VERBOSE) {
		printf("3**x (client public key) exponentially generated\n");
		if (firstack & FLG_DEBUG) {
			printf("3**x (client public key):\n");
			mpz_out_str(stdout, 10, &mypublic);
			printf("\n");
		}
	}

	/* dh: exchange exponentials */
	if (write_data(s, exchange, sizeof(exchange)) != sizeof(exchange))
		return(-1);
	
	bzero(exchange, sizeof(exchange));
	if (read_data(s, exchange, sizeof(exchange)) != sizeof(exchange))
		return(-1);

	mpz_set_str(&hispublic, exchange, 10);

	if (side == CLIENT_SIDE && firstack & FLG_BE_VERBOSE) {
		printf("3**y (server public key) received from server\n");
		if (firstack & FLG_DEBUG) {
			printf("3**y (server public key):\n");
			mpz_out_str(stdout, 10, &hispublic);
			printf("\n");
		}
	}

	/* dh: calculate shared secret */
        mpz_powm(&sharedsecret, &hispublic, &mysecret, &modulo);

	if (side == CLIENT_SIDE && firstack & FLG_BE_VERBOSE) {
		printf("(3**y)**x (shared secret) exponentially generated\n");
		if (firstack & FLG_DEBUG) {
			printf("(3**y)**x (shared secret):\n");
			mpz_out_str(stdout, 10, &sharedsecret);
			printf("\n");
		}
	}
	
	/* convert shared secret to ascii decimal string, divide the
	decimal string into two halves.  the first half is the client
	one, the second one is the server one.  both halves are 
	digested by md5 in order to distill randomness and provide
	actual encryption keys.
	we use different keys for server and client in order to prevent
	false data injection, as it has been pointed out by S.Bellovin
	in Session Layer Encryption, V USENIX Symposium
	things are just natural for single DES (one 8 bytes key) and
	IDEA (one 16 bytes key), but triple des needs three 8 bytes
	keys.  we generate the 3des third key by means of the IDEA
	cipher */

	/* digest shared secret */
	bzero(pwstr, sizeof(pwstr));
	mpz_get_str(pwstr, 10, &sharedsecret);

	/* digest first half
	single des and idea client keys are based on digest1
	triple des client keys are based on digest1 and pwstr
	*/
	MD5Init(&mdContext);
	MD5Update(&mdContext, pwstr, strlen(pwstr) / 2);
	MD5Final(digest1, &mdContext);

	/* digest second half
	single des and idea server keys are based on digest2
	triple des server keys are based on digest2 and pwstr
	*/
	MD5Init(&mdContext);
	MD5Update(&mdContext, pwstr + strlen(pwstr) / 2, strlen(pwstr) / 2);
	MD5Final(digest2, &mdContext);

	/* calculate a special pwstr hash for use in the mutual authentication
	phase only.  since it is maintained in memory for use in the
	mutual auth phase, it could be eventually disclosed; this is why
	this is a one way hash, based upon a subset of the key.
	sessionkeyhash is calculated as follows: the first 8 bytes of
	digest1 are used as a des key to encrypt the first 8 bytes of
	digest2.
	*/
#ifdef DESCORE
	descore_key_sched(digest1, tmpsched);
#else
	des_set_key((des_cblock *)digest1, tmpsched);
#endif

	memcpy(sessionkeyhash, digest2, 8);

#ifdef DESCORE
	descore_ecb_encrypt(sessionkeyhash, sessionkeyhash, tmpsched, ENCRYPT);
#else
	des_ecb_encrypt((des_cblock *)sessionkeyhash,
			(des_cblock *)sessionkeyhash, tmpsched, ENCRYPT);
#endif
	bzero(tmpsched, sizeof(tmpsched));

	/* the itself key is random, so we do not need a changing IV */
	/* bzero(IV, sizeof(IV)); */

	/* set single des keys */
	if (firstack & FLG_USE_IDEA) {
		/* set client encryption key */
		init_this_key_idea(c_ideakey, digest1, FALSE);

		/* set server encryption key */
		init_this_key_idea(s_ideakey, digest2, FALSE);
	}
	/* set idea keys */
	else if (firstack & FLG_USE_SINGLE) {
		/* fold (xor) md5 digests 16 bytes into 8 bytes des keys */
		for (i = 0; i < 8; i++) {
			digest1[i] ^= digest1[i + 8];
			digest2[i] ^= digest2[i + 8];
		}

		/* set client encryption key */
#ifdef DESCORE
		descore_key_sched(digest1, c_schedule1);
#else
		des_set_key((des_cblock *)digest1, c_schedule1);
#endif

		/* set server encryption key */
#ifdef DESCORE
		descore_key_sched(digest2, s_schedule1);
#else
		des_set_key((des_cblock *)digest2, s_schedule1);
#endif

	}
	/* set rc4 keys */
	else if (firstack & FLG_USE_RC4) {
		rc4_init(&c_rc4, digest1, 16);
		rc4_init(&s_rc4, digest2, 16);
	}
	/* calculate and set triple des keys 
	triple DES is default encryption mode
	*/
	else {
		/* set client first encryption key */
#ifdef DESCORE
		descore_key_sched(digest1, c_schedule1);
#else
		des_set_key((des_cblock *)digest1, c_schedule1);
#endif

		/* set client second encryption key */
		/* fixed by Mark C. Henderson */
#ifdef DESCORE
		descore_key_sched((des_cblock *)digest1 + 1, c_schedule2);
#else
		des_set_key((des_cblock *)digest1 + 1, c_schedule2);
#endif

		/* set client third encryption key
		to calculate the third key we take advantage of the
		IDEA cipher, setting digest1 as encryption key 
		and using first digest2's half as plaintext.  the resulting
		ciphertexst is set into c_third
		*/
		init_this_key_idea(c_ideakey, digest1, FALSE);

#ifndef HIGHFIRST /* dunigan@@thdsun.epm.ornl.gov */
		{
			word16  XX[4];
			memcpy(XX, digest2, 8);
			XX[0] = XX[0] >> 8 | XX[0] << 8;
			XX[1] = XX[1] >> 8 | XX[1] << 8;
			XX[2] = XX[2] >> 8 | XX[2] << 8;
			XX[3] = XX[3] >> 8 | XX[3] << 8;
			cipher_idea(XX, XX, c_ideakey);
			XX[0] = XX[0] >> 8 | XX[0] << 8;
			XX[1] = XX[1] >> 8 | XX[1] << 8;
			XX[2] = XX[2] >> 8 | XX[2] << 8;
			XX[3] = XX[3] >> 8 | XX[3] << 8;
			memcpy(c_third, XX, 8);
		}
#else
		cipher_idea(digest2, c_third, c_ideakey);
#endif HIGHFIRST

#ifdef DESCORE
		descore_key_sched(c_third, c_schedule3);
#else
		des_set_key((des_cblock *)c_third, c_schedule3);
#endif

		/* set server first encryption key */
#ifdef DESCORE
		descore_key_sched(digest2, s_schedule1);
#else
		des_set_key((des_cblock *)digest2, s_schedule1);
#endif

		/* set server second encryption key */
		/* fixed by Mark C. Henderson */
#ifdef DESCORE
		descore_key_sched(digest2 + 8, s_schedule2);
#else
		des_set_key((des_cblock *)digest2 + 1, s_schedule2);
#endif

		/* set server third encryption key
		to calculate the third key we take advantage of the
		IDEA cipher, setting digest2 as encryption key 
		and using first digest1's half as plaintext.  the resulting
		ciphertexst is set into c_third
		*/
		init_this_key_idea(s_ideakey, digest2, FALSE);

#ifndef HIGHFIRST /* dunigan@@thdsun.epm.ornl.gov */
		{
			word16  XX[4];
			memcpy(XX, digest1, 8);
			XX[0] = XX[0] >> 8 | XX[0] << 8;
			XX[1] = XX[1] >> 8 | XX[1] << 8;
			XX[2] = XX[2] >> 8 | XX[2] << 8;
			XX[3] = XX[3] >> 8 | XX[3] << 8;
			cipher_idea(XX, XX, s_ideakey);
			XX[0] = XX[0] >> 8 | XX[0] << 8;
			XX[1] = XX[1] >> 8 | XX[1] << 8;
			XX[2] = XX[2] >> 8 | XX[2] << 8;
			XX[3] = XX[3] >> 8 | XX[3] << 8;
			memcpy(s_third, XX, 8);
		}
#else
		cipher_idea(digest1, s_third, s_ideakey);
#endif HIGHFIRST

#ifdef DESCORE
		descore_key_sched(s_third, s_schedule3);
#else
		des_set_key((des_cblock *)s_third, s_schedule3);
#endif
	}

	if (side == CLIENT_SIDE && firstack & FLG_BE_VERBOSE) {
		if (firstack & FLG_USE_IDEA) {
			hexdump("IDEA client key: ", digest1, 16);
			hexdump("IDEA server key: ", digest2, 16);
		}
		else if (firstack & FLG_USE_SINGLE) {
			hexdump("DES client key: ", digest1, 8);
			hexdump("DES server key: ", digest2, 8);
		}
		else if (firstack & FLG_USE_RC4) {
			hexdump("RC4 client key: ", digest1, 16);
			hexdump("RC4 server key: ", digest2, 16);
		}
		else { /* default is triple DES */
			hexdump("3DES client key #1: ", digest1, 8);
			hexdump("3DES client key #2: ", digest1 + 8, 8);
			hexdump("3DES client key #3: ", c_third, 8);
			hexdump("3DES server key #1: ", digest2, 8);
			hexdump("3DES server key #2: ", digest2 + 8, 8);
			hexdump("3DES server key #3: ", s_third, 8);
		}
	}

	/* delete traces */
	bzero(pwstr, sizeof(pwstr));
	bzero(digest1, 16);
	bzero(digest2, 16);
	mpz_clear(&modulo);
	mpz_clear(&three);
	mpz_clear(&sharedsecret);
	mpz_clear(&mysecret);
	mpz_clear(&mypublic);
	mpz_clear(&hispublic);
	return(0);
}

/* generate randomness by means of DES and MD5.

we have a really unpredictable strings, that is str,
which has been built by internalrnd().  we distill randomness from
str by means of the MD5 function.  we divide the digest into two
halves.  then, we repeatly copy the second half to randomstring
and DES/CBC encrypt it using the first digest as encryption key.
as a result, randomstring is now a suitably long supposed-to-be
random string which is converted into a multi-precision number
for use in the DH scheme.
yes, this is a weird method to get randomness from a unpredictable
string.  suggestions and criticism is welcome!
*/
mkrnd(str, rnd, modulo, logging)
unsigned char	*str;
MP_INT		*rnd, *modulo;
int		logging;
{
	MP_INT		value;

	MD5_CTX		mdContext;
	unsigned char	digest[16];

	IDEAkey		arandomkey;
	des_cblock	iv;

	/* the size of randomstring should be a multiple of 16, that is,
	the size of MDx digest; if sizeof(randomstring) == 512 then it
	is possible to generate up to 4096 bits numbers. in the
	present version, we only need 2048 bits longs numbers maximum.
	*/
	unsigned char	randomstring[512];

	/* digest user's input */
	MD5Init(&mdContext);
	MD5Update(&mdContext, str, strlen(str));
	MD5Final(digest, &mdContext);

	if (logging) {
		printf("\nGENERATING KEY RANDOMNESS\n");
		printf("random string: \"%s\"\n", str);
		hexdump("digest of random string: ", digest, 16);
	}

	/* build idea key */
	init_this_key_idea(arandomkey, digest, FALSE);
	/* set idea cfb */
	bzero(iv, 8);
	initcfb_idea((word16 *)iv, (byte *)arandomkey, FALSE);

	/* reset randomstring */
	bzero(randomstring, sizeof(randomstring));

	/* encrypt randomstring */
	ideacfb(randomstring, sizeof(randomstring));

	/* give a glance at the first random bytes... */
	if (logging) {
		hexdump("first 20 random bytes: ", randomstring, 20);
		hexdump("next 20 random bytes : ", randomstring + 20, 20);
		hexdump("next 20 random bytes : ", randomstring + 40, 20);
		printf("skipped all remaining random bytes (%d bytes in all)\n",
							sizeof(randomstring));
	}

#if 0
	/* build a verylong random number whose size is
	sizeof(randomstring) * 8 bits. this is accomplished in a very old
	fashioned way, but performances should not be an issue here
	*/
	mpz_set_ui(&ff, (unsigned long)256);
	mpz_set_ui(&value, (unsigned long)0);
	for (i = 0; i < sizeof(randomstring); i++) {
		int	tmp;

		/* y = 256**i */
		tmp = i;
		syslog(LOGPRI, "cycle: i = %d, tmp = %lu", i, tmp);
		mpz_pow_ui(&y, &ff, tmp);

		/* x = y * randomstring[i] */
		tmp = randomstring[i];
		mpz_mul_ui(&x, &y, (unsigned long)tmp);

		/* value = value + x */
		mpz_add(&value, &value, &x);

		/* value >= modulo ? break */
		if (mpz_cmp(&value, modulo) >= 0)
			break;
	}
#endif

	mpz_init(&value);
	str2mp(randomstring, sizeof(randomstring), &value);

	mpz_mod(rnd, &value, modulo);

	/* clear all traces */
	bzero(randomstring, sizeof(randomstring));
	bzero(str, strlen(str));
	mpz_clear(&value);
}


/* convert an ASCII string into a MP number */
str2mp(str, len, value)
char	*str;
int	len;
MP_INT	*value;
{
	MP_INT	ff, x, y;
	int	i;

	mpz_init(&ff);
	mpz_init(&x);
	mpz_init(&y);

	mpz_set_ui(&ff, (unsigned long)256);
	mpz_set_ui(value, (unsigned long)str[0]);

	i = 0;
	while (1) {
		if (i++ >= len - 1)
			break;

		mpz_pow_ui(&y, &ff, i);
		mpz_mul_ui(&x, &y, str[i]);
		mpz_add(value, value, &x);
	}

	mpz_clear(&ff);
	mpz_clear(&x);
	mpz_clear(&y);
}






#ifndef NO_IP_PROTO
killoptions(s, host)
int	s;
char	*host;
{
	unsigned char	buf[BUFSIZ / 3], *pbuf;
	char		dumpbuf[BUFSIZ], *pdump = dumpbuf;
	int		bufsiz = sizeof(buf);

	if (!getsockopt(s, IPPROTO_IP, IP_OPTIONS, (char *)buf, &bufsiz) &&
	    bufsiz != 0) { /* options are set */
		for (pbuf = buf; bufsiz > 0; pbuf++, bufsiz--, pdump += 3)
			sprintf(pdump, " %2.2x", *pbuf);
		syslog(LOGPRI,
			"connection from %s with IP_OPTIONS (ignored): %s",
							host, dumpbuf);
		if (setsockopt(s, IPPROTO_IP, IP_OPTIONS, NULL, 0)) {
			syslog(LOG_ERR, "setsockopt(IP_OPTIONS): %m");
			return(1);
		}
	}
	return(0);
}
#endif


/* build a truly random string using some sources of randomness 
inside unix computer systems.  we use computer clock, PIDs,
system names, date of files, CWD and the truerand function which
is supposed to generate physically random numbers.  each string's
individual bit has considerably less than 1 bit of entropy;
however, the string is to be digested by md5, a strong hashing
algorithm.
*/
unsigned char *
internalrnd()
{
	static unsigned char	buf[4096];
	unsigned char		tmp[512];
	struct utsname		name;
	long			t;
	char			*ctime();
	struct stat 		sbuf;
	void			(*oldsig) ();

	bzero(buf, sizeof(buf));

	/* system names */
	if (uname(&name) >= 0) {
		(void)sprintf(tmp, "unames = (%s %s %s %s %s);\n",
			name.sysname, name.nodename, name.release,
			name.machine, name.version);
		(void)strcat(buf, tmp);
	}

	/* date */
	t = time(NULL);
	(void)sprintf(tmp, "time = %ld; ctime = %s ", t, ctime(&t));
	(void)strcat(buf, tmp);

	/* pids */
	(void)sprintf(tmp, "pid = %d; getpgrp = %d; getppid = %d;\n",
					getpid(), getpgrp(), getppid());
	(void)strcat(buf, tmp);

	/* dates of frequently changing files */
	if (stat("/etc/passwd", &sbuf) != -1) {
		(void)sprintf(tmp, "/etc/passwd dates = (%ld %ld %ld);\n",
			sbuf.st_atime, sbuf.st_mtime, sbuf.st_ctime);
		(void)strcat(buf, tmp);
	}
	if (stat("/dev/tty", &sbuf) != -1) {
		(void)sprintf(tmp, "/dev/tty dates = (%ld %ld %ld);\n",
			sbuf.st_atime, sbuf.st_mtime, sbuf.st_ctime);
		(void)strcat(buf, tmp);
	}
	if (stat("/dev/console", &sbuf) != -1) {
		(void)sprintf(tmp, "/dev/console dates = (%ld %ld %ld);\n",
			sbuf.st_atime, sbuf.st_mtime, sbuf.st_ctime);
		(void)strcat(buf, tmp);
	}
	if (stat("/tmp", &sbuf) != -1) {
		(void)sprintf(tmp, "/tmp dates = (%ld %ld %ld);\n",
			sbuf.st_atime, sbuf.st_mtime, sbuf.st_ctime);
		(void)strcat(buf, tmp);
	}

	if (stat("/usr/tmp", &sbuf) != -1) {
		(void)sprintf(tmp, "/usr/tmp dates = (%ld %ld %ld);\n",
			sbuf.st_atime, sbuf.st_mtime, sbuf.st_ctime);
		(void)strcat(buf, tmp);
	}

	/* cwd */
	if (getcwd(tmp, sizeof(tmp)) != NULL) {
		strcat(buf, "cwd: ");
		(void)strcat(buf, tmp);
		strcat(buf, "\n");
	}

	/* a few ``true random'' numbers */
	oldsig = signal(SIGALRM, SIG_DFL); /* truerand modifies sigalrm */
	(void)sprintf(tmp, "a few random numbers = (%d %d %d);\n",
		truerand(),
		truerand(),
		truerand());
	(void)signal(SIGALRM, oldsig);
	(void)strcat(buf, tmp);
	
	return(buf);
}

mauth(s, authbuf, side, firstack)
int	s, side, firstack;
char	*authbuf;
{
	MD5_CTX			mdContext;
	unsigned char		digest[16];
	des_key_schedule	authsched;
	unsigned char		cookie[8], *firsthalve, *secondhalve;
	unsigned char		othercookie[8], *otherfirst, *othersecond;
	int			i;
	int			logging;
	
	logging = side == CLIENT_SIDE && firstack & FLG_DEBUG;

	/* digest content of ~/.stelsecret */
	MD5Init(&mdContext);
	MD5Update(&mdContext, authbuf, strlen(authbuf));
	MD5Final(digest, &mdContext);

	for (i = 0; i < 8; i++)
		/* xor halves together */
		digest[i] ^= digest[i + 8];

	/* set a des key */
#ifdef DESCORE
	descore_key_sched(digest, authsched);
#else
	des_set_key((des_cblock *)digest, authsched);
#endif

	/* build K_E(sessionkeyhash) */
	memcpy(cookie, sessionkeyhash, 8);
#ifdef DESCORE
	descore_ecb_encrypt(cookie, cookie, authsched, ENCRYPT);
#else
	des_ecb_encrypt((des_cblock *)cookie, (des_cblock *)cookie,
							authsched, ENCRYPT);
#endif
	if (side == SERVER_SIDE) /* encrypt twice */
#ifdef DESCORE
		descore_ecb_encrypt(cookie, cookie, authsched, ENCRYPT);
#else
		des_ecb_encrypt((des_cblock *)cookie, (des_cblock *)cookie,
							authsched, ENCRYPT);
#endif

	if (logging) {
		printf("\nMUTUAL AUTHENTICATION\n");
		printf("AX authenticator is equal to E_K(sessionkeyhash), where:\n");
		hexdump("K is a stelsecret derived DES key, equal to: ",
								digest, 8);
		hexdump("sessionkeyhash is equal to: ", sessionkeyhash, 8);
		hexdump("AX authenticator: ", cookie, 8);
		printf(\
"AX and AY are divided in two halves; AX = AX1|AX2, AY = AY1|AY2\n");
	}

	/* split it into two halves */
	firsthalve = cookie;
	secondhalve = cookie + 4;

	otherfirst = othercookie;
	othersecond = othercookie + 4;

	/* Send halves in order. We have differently encrypted the two
	cookies (double encryption has been performed by the server
	while single encryption by the client), so a replay attack
	should be infeasible for the Man In The Middle */

	if (side == CLIENT_SIDE) {
		if (logging)
			hexdump("sending AX1: ", firsthalve, 4);
		if (write_data(s, firsthalve, 4) != 4)
			return(-1);

		if (read_data(s, otherfirst, 4) != 4)
			return(-1);
		if (logging)
			hexdump("received AY1: ", otherfirst, 4);

		if (logging)
			hexdump("sending AX2: ", secondhalve, 4);
		if (write_data(s, secondhalve, 4) != 4)
			return(-1);

		if (read_data(s, othersecond, 4) != 4)
			return(-1);
		if (logging)  {
			hexdump("received AY2: ", othersecond, 4);
			hexdump("AY: ", othercookie, 8);
		}
	}
	else {
		if (read_data(s, otherfirst, 4) != 4 ||
		    write_data(s, firsthalve, 4) != 4 ||
		    read_data(s, othersecond, 4) != 4 ||
		    write_data(s, secondhalve, 4) != 4)
			return(-1);
	}

	if (side == CLIENT_SIDE) /* decrypt it once */
#ifdef DESCORE
		descore_ecb_encrypt(othercookie, othercookie, authsched, DECRYPT);
#else
		des_ecb_encrypt((des_cblock *)othercookie,
			(des_cblock *)othercookie, authsched, DECRYPT);
#endif
	else if (side == SERVER_SIDE) /* encrypt once more */
#ifdef DESCORE
		descore_ecb_encrypt(othercookie, othercookie, authsched, ENCRYPT);
#else
		des_ecb_encrypt((des_cblock *)othercookie,
			(des_cblock *)othercookie, authsched, ENCRYPT);
#endif

	if (logging) {
		printf(\
"AY is double encrypted. We decrypt it before comparing AX with AY\n");
		hexdump("AY (decrypted): ", othercookie, 8);
		hexdump("AX: ", cookie, 8);
	}
	
	if (memcmp(cookie, othercookie, 8)) {
		if (logging)
			printf("AX != AY, authentication failed\n");
		return(1);
	}

	if (logging)
		printf("AX = AY, authentication succeeded\n");

	return(0);
}

hexdump(prompt, buf, len)
char		*prompt;
unsigned char	*buf;
int		len;
{
	int	i;

	if (prompt)
		printf("%s", prompt);
	for (i = 0; i < len; i++)
		printf("%02X", buf[i]);
	(void)fflush(stdout);
	printf("\r\n");
}

/*
 * Construct a control character sequence
 * for a special character.
 */
char *
control(c)
	register cc_t c;
{
	static char buf[5];
	register unsigned int uic = (unsigned int)c;

	if (uic == 0x7f)
		return ("^?");

	if (uic >= 0x80) {
		buf[0] = '\\';
		buf[1] = ((c>>6)&07) + '0';
		buf[2] = ((c>>3)&07) + '0';
		buf[3] = (c&07) + '0';
		buf[4] = 0;
	} else if (uic >= 0x20) {
		buf[0] = c;
		buf[1] = 0;
	} else {
		buf[0] = '^';
		buf[1] = '@@'+c;
		buf[2] = 0;
	}
	return (buf);
}

/*
 * Modified read() & write() for sockets.
 * Returns: number of characters read if ok; -1 if fails.
 */
int		read_data(s, buf, n)
int		s;
char		*buf;
int		n;
{
	int		bcount;
	int		br;

	bcount= 0;
	br= 0;
	while (bcount < n) {
		if ((br = read(s, buf, n - bcount)) > 0) {
			bcount += br;
			buf += br;
		}
		else if (br < 0)
			return(-1);
		else if (!br)
			break;
	}
	return(bcount);
}

int		write_data(s, buf, n)
int		s;
char		*buf;
int		n;
{
	int		bcount;
	int		br;

	bcount= 0;
	br= 0;
	while (bcount < n) {
		if ((br = write(s, buf, n - bcount)) > 0) {
			bcount += br;
			buf += br;
		}
	else if (br < 0)
		return(-1);
	}
	return(bcount);
}


/*
 * CFB encrypt a single byte using DES, 3DES or IDEA.
 * mode: DES_ENCRYPT, DES_DECRYPT
 * cipher: DES_CIPHER, TRIPLEDES_CIPHER, IDEA_CIPHER
 * side: CLIENT_SIDE, SERVER_SIDE
 *
 * (uses global s_IV and c_IV initialisation variables) 
 */
typedef union { /* solaris needs this */
	char	octet[8];
} SHIFT;

static void
CFBcrypt(char *databyte, int mode, int cipher, int side)
{
	char	*shift1, *shift2, *first1, *first2;

	static SHIFT	c_shift1, c_shift2;
	static SHIFT	s_shift1, s_shift2;
	static char	c_first1, c_first2;
	static char	s_first1, s_first2;

	register char	*shift, add;
	register	i;

	des_key_schedule	*sched1, *sched2, *sched3;
	IDEAkey			*ideakey;
	des_cblock		*IV;

	if (databyte == NULL) { /* reset option, unused */
		bzero(&c_shift1, sizeof(SHIFT));
		bzero(&c_shift2, sizeof(SHIFT));
		bzero(&s_shift1, sizeof(SHIFT));
		bzero(&s_shift2, sizeof(SHIFT));
		c_first1 = c_first2 = s_first1 = s_first2 = 0;
	}

	if (mode < 0)
		return;

	/* rc4 is the fastests -- but probably insecure -- cipher */
	if (cipher == RC4_CIPHER) {
		*databyte ^= rc4_byte(side == CLIENT_SIDE ? &c_rc4 : &s_rc4);
		return;
	}
	
	/* we need to keep to different queues for both client
	   and server. This is done for security reasons and
	   syncronicity reasons */
	if (side == CLIENT_SIDE) {
		sched1 = &c_schedule1;
		sched2 = &c_schedule2;
		sched3 = &c_schedule3;
		ideakey = &c_ideakey;
		shift1 = (char *)&c_shift1;
		shift2 = (char *)&c_shift2;
		first1 = &c_first1;
		first2 = &c_first2;
		IV = (des_cblock *)&c_IV;
	}
	else { /* SERVER_SIDE */
		sched1 = &s_schedule1;
		sched2 = &s_schedule2;
		sched3 = &s_schedule3;
		ideakey = &s_ideakey;
		shift1 = (char *)&s_shift1;
		shift2 = (char *)&s_shift2;
		first1 = &s_first1;
		first2 = &s_first2;
		IV = (des_cblock *)&s_IV;
	}

	switch (mode) {
		case	DES_ENCRYPT:
			if (*first1 == 0) { /* First time we use this queue? */
				(void)memcpy(shift1, IV, 8);
				*first1 = 1;
			}
			shift = shift1;
			break;
		case	DES_DECRYPT:
			if (*first2 == 0) {
				(void)memcpy(shift2, IV, 8);
				*first2 = 1;
				*first2 = 2;
			}
			shift = shift2;
			break;
		default	:
			return;
	}

	if (mode == DES_DECRYPT)
		add = *databyte;

	if (cipher == IDEA_CIPHER) { /* idea */
		word16	XX[4];

		memcpy(XX, shift, 8);
		/* idea_ecb(shift, shift); */

#ifndef HIGHFIRST /* dunigan@@thdsun.epm.ornl.gov */
		XX[0] = XX[0] >> 8 | XX[0] << 8;
		XX[1] = XX[1] >> 8 | XX[1] << 8;
		XX[2] = XX[2] >> 8 | XX[2] << 8;
		XX[3] = XX[3] >> 8 | XX[3] << 8;
                cipher_idea(XX, XX, *ideakey);
		XX[0] = XX[0] >> 8 | XX[0] << 8;
		XX[1] = XX[1] >> 8 | XX[1] << 8;
		XX[2] = XX[2] >> 8 | XX[2] << 8;
		XX[3] = XX[3] >> 8 | XX[3] << 8;
#else
		cipher_idea(XX, XX, *ideakey);
#endif HIGHFIRST

		memcpy(shift, XX, 8);
	}
	else if (cipher == TRIPLEDES_CIPHER) { /* 3 DES */
#ifdef DESCORE
		descore_ecb_encrypt(shift, shift, *sched1, DES_ENCRYPT);
		descore_ecb_encrypt(shift, shift, *sched2, DES_DECRYPT);
		descore_ecb_encrypt(shift, shift, *sched3, DES_ENCRYPT);
#else
		des_ecb_encrypt((des_cblock *)shift, (des_cblock *)shift,
							*sched1, DES_ENCRYPT);
		des_ecb_encrypt((des_cblock *)shift, (des_cblock *)shift,
							*sched2, DES_DECRYPT);
		des_ecb_encrypt((des_cblock *)shift, (des_cblock *)shift,
							*sched3, DES_ENCRYPT);
#endif
	}
	else if (cipher == DES_CIPHER) { /* single DES */
#ifdef DESCORE
		des_ecb_encrypt(shift, shift, *sched1, DES_ENCRYPT);
#else
		des_ecb_encrypt((des_cblock *)shift, (des_cblock *)shift,
							*sched1, DES_ENCRYPT);
#endif
	}
	else {
		exit(1);
	}

	*databyte ^= shift[0];	

	for (i = 1; i <= 7; i++)
		shift[i - 1] = shift[i];

	if (mode == DES_ENCRYPT)
		add = *databyte;

	shift[7] = add;
}

cryptbuf(buf, len, dec, cipher, side)
char	*buf;
int	len, dec, cipher, side;
{
	register	i;

	for (i = 0; i < len; i++)
		CFBcrypt(&buf[i], dec, cipher, side);
}

static
doaddrmatch(char *pat, char *str)
{
	regex_t		re;
	regmatch_t	pm;
	char		*pattern;

	/* fix: performances */
	if ((pattern = (char *)buildregexp(pat)) == NULL) {
		syslog(LOGPRI, "buildregexp() failed");
		exit(1);
	}

	if (regcomp(&re, pattern, REG_EXTENDED | REG_ICASE)) {
		syslog(LOGPRI, "regcomp() failed");
		exit(1);
	}

	/* regexec(&re, pbuf, 1, &pm, 0 */
	if (!regexec(&re, str, 1, &pm, 0))
		return(0);
	else
		return(1);
}

static char *
buildregexp(char *str)
{
	char		*tmp1;
	static char	*tmp2;
	register	i, j;

	if ((tmp1 = (char *) malloc(strlen(str) * 2)) == NULL) {
		perror("malloc()");
		return(NULL);
	}

	/* . --> \. */
	for (i = 0, j = 0; i < strlen(str); i++) {
		if (str[i] == '.') {
			tmp1[j++] = '\\';
			tmp1[j++] = '.';
		}
		else
			tmp1[j++] = str[i];
	}
	tmp1[j] = '\0';

	if (tmp2 == NULL) {
		if ((tmp2 = (char *) malloc(strlen(tmp1) * 10)) == NULL) {
			perror("malloc()");
			return(NULL);
		}
	}
	else if ((tmp2 = (char *) realloc(tmp2, strlen(tmp1) * 10)) == NULL) {
		perror("realloc()");
		return(NULL);
	}
	/*
	 * * --> [a-z0-9]+
	 * ? --> [a-z0-9]
	 */
	j = 0;
	tmp2[j++] = '^';
	for (i = 0; i < strlen(tmp1); i++) {
		if (tmp1[i] == '*') {
			tmp2[j++] = '[';
			tmp2[j++] = '-';
			tmp2[j++] = 'a';
			tmp2[j++] = '-';
			tmp2[j++] = 'z';
			tmp2[j++] = '0';
			tmp2[j++] = '-';
			tmp2[j++] = '9';
			tmp2[j++] = ']';
			tmp2[j++] = '+';
		}
		else if (tmp1[i] == '?') {
			tmp2[j++] = '[';
			tmp2[j++] = '-';
			tmp2[j++] = 'a';
			tmp2[j++] = '-';
			tmp2[j++] = 'z';
			tmp2[j++] = '0';
			tmp2[j++] = '-';
			tmp2[j++] = '9';
			tmp2[j++] = ']';
		}
		else
			tmp2[j++] = tmp1[i];
	}
	tmp2[j++] = '$';
	tmp2[j] = '\0';

	free(tmp1);
	/*
	printf("regexp: %s --> %s\n", str, tmp2);
	*/
	return(tmp2);
}

/* host1,host2,host3,...,hostn:password */
char *
getstelsecret(char *pathname, char *hname)
{
	FILE		*fp;
	static char	authbuf[STEL_SECRET_MAX_LEN];
	char		line[STEL_SECRET_MAX_LEN];
	int		firsttoklen, linenum = 0;
	int		found = 0;
	char		*p;

	if ((fp = fopen(pathname, "r")) == NULL)
		return(NULL);

	while  (fgets(line, sizeof(line), fp) != NULL) {
		/* check address matching */
		p = (char *)strtok(line, ": \t");	

		linenum++;

		rip(p);
		if (p == NULL || *p == '#' || p == '\0')
			continue;

		/* save pointer to stel secret */
		firsttoklen = strlen(p);

		/* check that hname match any host in p */
		if (!oneofthese(hname, p))
			continue;

		/* extract stelsecret */
		p = (char *)strtok(line + firsttoklen + 1, "\n\t ");
		if (p == NULL) {
			syslog(LOGPRI, "%s syntax error on line %d\n",
							pathname, linenum);
			continue;
		}
	
		/* we found it */
		found++;
		(void)strncpy(authbuf, p, sizeof(authbuf));
		break;
	}

	(void)fclose(fp);

	if (!found)
		return(NULL);

	return(authbuf);
}

/* 0 = not found, 1 = found */
static
oneofthese(char *hname, char *hosts)
{
	char		*tmp;
	char		*p;
	int		i;
	int		found = 0;

	struct hostent	*hp;
	struct in_addr	x;
	int		j;

	if ((hp = gethostbyname(hname)) == NULL)
		return(0); /* Unknown host. should never happen */

	if ((tmp = (char *)strdup(hosts)) == NULL)
		return(0);

	i = 0;
	while ((p = (char *)strtok((i == 0 ? tmp : NULL), ", \t")) != NULL) {
		/*
		syslog(LOGPRI, "comparing %s with %s", hname, p);
		*/
		/* check official name */
		if (!doaddrmatch(p, (char *)hp->h_name)) {
			found++;
			break;
		}

		/* check aliases */
		for (j = 0; hp->h_aliases[j]; j++) {
			if (!doaddrmatch(p, hp->h_aliases[j])) {
				found++;
				break;
			}
		}

		for (j = 0; hp->h_addr_list[j]; j++) {
			memcpy((char *)&x, hp->h_addr_list[j], hp->h_length);
			if (!doaddrmatch(p, (char *)inet_ntoa(x))) {
				found++;
				break;
			}
		}
			
		if (found)
			break;
		i++;
	}

	(void)free(tmp);

	return(found);
}

char *
randomdigest()
{
	char		buf[128];
	MD5_CTX		mdContext;
	static char	digest[16];
	void		(*oldsig) ();

	oldsig = signal(SIGALRM, SIG_DFL); /* truerand modifies sigalrm */
	sprintf(buf, "%ld %d %d %d",
			time(NULL), truerand(), truerand(), getpid());
	(void)signal(SIGALRM, oldsig);
	MD5Init(&mdContext);
	MD5Update(&mdContext, buf, strlen(buf));
	MD5Final(digest, &mdContext);
	
	return(digest);
}

/* client printf */
#if defined(IRIX) || defined(SOLARIS)
cprintf(char *fmt, ...)
#else
cprintf(va_alist)
va_dcl
#endif
{
	va_list		args;
#if !defined(IRIX) && !defined(SOLARIS)
	char		*fmt;
#endif
	char		buf[128];

#if defined(IRIX) || defined(SOLARIS)
	va_start(args, fmt);
#else
	va_start(args);
	fmt = va_arg(args, char *);
#endif

	vsprintf(buf, fmt, args);
	printf("%s[%d]: %s", STELCLIENT, getpid(), buf);
	fflush(stdout);

	va_end(args);
}

#ifdef ASCIIBANNER
/* read and skip banner.  client only */
eatbanner(s)
int	s;
{
	char	buf[100], buf2[100];
	int	len;

	sprintf(buf, BANNER, VERSION);
	len = strlen(buf);
	if (read_data(s, buf, len) != len)
		return(1);
	return(0);
}

/* send banner.  used by server only */
sendbanner(s)
int	s;
{
	char	buf[100];

	sprintf(buf, BANNER, VERSION);
	if (write_data(s, buf, strlen(buf)) != strlen(buf))
		return(1);
	return(0);
}
#endif
@


1.100
log
@safety
@
text
@d3 4
a6 4
 * $Header: /users/vince/src/stel/RCS/sub.c,v 1.99 1996/03/31 09:41:11 vince Exp vince $
 * $Date: 1996/03/31 09:41:11 $
 * $Revision: 1.99 $
 * $Locker: vince $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: sub.c,v 1.99 1996/03/31 09:41:11 vince Exp vince $";
d1603 28
@


1.99
log
@safety
@
text
@d3 3
a5 3
 * $Header: /users/vince/src/stel-dist/stel/RCS/sub.c,v 1.98 1996/03/30 14:58:08 vince Exp vince $
 * $Date: 1996/03/30 14:58:08 $
 * $Revision: 1.98 $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: sub.c,v 1.98 1996/03/30 14:58:08 vince Exp vince $";
a823 1
		/* syslog(LOGPRI, "i = %d", i); */
@


1.98
log
@safety
@
text
@d3 4
a6 4
 * $Header: /users/vince/src/stel/RCS/sub.c,v 1.97 1996/02/03 13:24:46 vince Exp $
 * $Date: 1996/02/03 13:24:46 $
 * $Revision: 1.97 $
 * $Locker:  $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: sub.c,v 1.97 1996/02/03 13:24:46 vince Exp $";
d719 1
a719 2
	MP_INT		x, y, ff, value;
	int		i;
a733 7
	bzero(randomstring, 512); /**/

	mpz_init(&x);
	mpz_init(&y);
	mpz_init(&ff);
	mpz_init(&value);

d766 1
d792 1
d794 3
d802 32
a835 2
	mpz_clear(&ff);
	mpz_clear(&value);
d837 5
@


1.97
log
@safety
@
text
@d3 3
a5 3
 * $Header: /home/vince/src/stel/RCS/sub.c,v 1.96 1996/01/03 18:20:26 vince Exp $
 * $Date: 1996/01/03 18:20:26 $
 * $Revision: 1.96 $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: sub.c,v 1.96 1996/01/03 18:20:26 vince Exp $";
d226 1
a226 1
#if defined(hpux) || defined(SOLARIS) || defined(IRIX) || defined(AIX)
d232 6
a237 2
	while (wait3(&wstatus, WNOHANG, NULL) > 0)
		;
d735 2
d778 2
a779 1
	mpz_set_ui(&ff, 256L);
d785 2
a786 1
		mpz_pow_ui(&y, &ff, (unsigned long)tmp);
@


1.96
log
@safety
@
text
@d3 4
a6 4
 * $Header: /res/usr/vince/src/stel/RCS/sub.c,v 1.95 1996/01/02 16:41:03 vince Exp vince $
 * $Date: 1996/01/02 16:41:03 $
 * $Revision: 1.95 $
 * $Locker: vince $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: sub.c,v 1.95 1996/01/02 16:41:03 vince Exp vince $";
d586 17
d604 1
d634 20
a653 1
		cipher_idea(digest1, s_third, c_ideakey);
a1514 2
	if (found)
		syslog(LOGPRI, "matched pattern: %s", p);
@


1.95
log
@safety
@
text
@d3 4
a6 4
 * $Header: /res/usr/vince/src/stel/RCS/sub.c,v 1.94 1995/12/21 10:58:55 vince Exp $
 * $Date: 1995/12/21 10:58:55 $
 * $Revision: 1.94 $
 * $Locker:  $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: sub.c,v 1.94 1995/12/21 10:58:55 vince Exp $";
d867 1
a867 1
	/* oldsig = signal(SIGALRM, SIG_IGN); /* truerand modifies sigalrm */
d872 1
a872 1
	/* (void)signal(SIGALRM, oldsig); */
d1491 1
a1491 1
	oldsig = signal(SIGALRM, SIG_IGN); /* truerand modifies sigalrm */
d1503 1
a1503 1
#if defined(IRIX)
d1511 1
a1511 1
#if !defined(IRIX)
d1516 1
a1516 1
#if defined(IRIX)
d1526 2
@


1.94
log
@safety
@
text
@d3 4
a6 4
 * $Header: /res/usr/vince/src/stel/RCS/sub.c,v 1.93 1995/12/20 18:33:49 vince Exp vince $
 * $Date: 1995/12/20 18:33:49 $
 * $Revision: 1.93 $
 * $Locker: vince $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: sub.c,v 1.93 1995/12/20 18:33:49 vince Exp vince $";
d1503 3
d1508 1
d1511 1
d1513 1
d1516 3
d1521 1
@


1.93
log
@safety
@
text
@d3 4
a6 4
 * $Header: /res/usr/vince/src/stel-dist/stel/RCS/sub.c,v 1.92 1995/12/19 08:37:40 vince Exp $
 * $Date: 1995/12/19 08:37:40 $
 * $Revision: 1.92 $
 * $Locker:  $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: sub.c,v 1.92 1995/12/19 08:37:40 vince Exp $";
d1515 1
@


1.92
log
@safety
@
text
@d3 3
a5 3
 * $Header: /res/usr/vince/src/stel-dist/stel/RCS/sub.c,v 1.91 1995/12/14 10:36:13 vince Exp $
 * $Date: 1995/12/14 10:36:13 $
 * $Revision: 1.91 $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: sub.c,v 1.91 1995/12/14 10:36:13 vince Exp $";
d27 1
d93 1
a93 1
		if ((serv = getservbyname(PRGNAME, "tcp")) == NULL)
d1500 15
@


1.91
log
@safety
@
text
@d3 3
a5 3
 * $Header: /res/usr/vince/src/stel-dist/stel/RCS/sub.c,v 1.90 1995/12/08 14:38:55 vince Exp $
 * $Date: 1995/12/08 14:38:55 $
 * $Revision: 1.90 $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: sub.c,v 1.90 1995/12/08 14:38:55 vince Exp $";
d210 3
d214 4
a217 3
		perror("connect()");
		return(-1);
	}
d1206 12
d1219 2
@


1.90
log
@safety
@
text
@d3 3
a5 3
 * $Header: /res/usr/vince/src/stel/RCS/sub.c,v 1.89 1995/12/04 16:36:21 vince Exp $
 * $Date: 1995/12/04 16:36:21 $
 * $Revision: 1.89 $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: sub.c,v 1.89 1995/12/04 16:36:21 vince Exp $";
d221 1
a221 1
#if defined(hpux) || defined(SOLARIS)
d1431 1
a1431 1
		if (!doaddrmatch(p, hp->h_name)) {
@


1.89
log
@safety
@
text
@d3 4
a6 4
 * $Header: /res/usr/vince/src/stel/RCS/sub.c,v 1.88 1995/11/29 14:00:27 vince Exp vince $
 * $Date: 1995/11/29 14:00:27 $
 * $Revision: 1.88 $
 * $Locker: vince $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: sub.c,v 1.88 1995/11/29 14:00:27 vince Exp vince $";
d571 1
a571 1
		des_set_key(digest1 + 8, c_schedule2);
@


1.88
log
@safety
@
text
@d3 3
a5 3
 * $Header: /res/usr/vince/src/stel/RCS/sub.c,v 1.87 1995/11/29 13:18:46 vince Exp vince $
 * $Date: 1995/11/29 13:18:46 $
 * $Revision: 1.87 $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: sub.c,v 1.87 1995/11/29 13:18:46 vince Exp vince $";
d862 1
a862 1
	oldsig = signal(SIGALRM, SIG_IGN); /* truerand modifies sigalrm */
d867 1
a867 1
	(void)signal(SIGALRM, oldsig);
@


1.87
log
@safety
@
text
@d3 3
a5 3
 * $Header: /res/usr/vince/src/stel/RCS/sub.c,v 1.86 1995/11/28 11:12:56 vince Exp vince $
 * $Date: 1995/11/28 11:12:56 $
 * $Revision: 1.86 $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: sub.c,v 1.86 1995/11/28 11:12:56 vince Exp vince $";
d1131 1
a1131 1
	if (databyte == NULL) { /* reset option */
@


1.86
log
@safety
@
text
@d3 3
a5 3
 * $Header: /res/usr/vince/src/stel/RCS/sub.c,v 1.85 1995/11/27 15:52:59 vince Exp vince $
 * $Date: 1995/11/27 15:52:59 $
 * $Revision: 1.85 $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: sub.c,v 1.85 1995/11/27 15:52:59 vince Exp vince $";
d54 1
a54 1
#include "des.h"
d469 2
a470 3
	keys.  we generate the 3des third key by means of des_cbc_cksum,
	a des checksum function embedded in the libdes package. see below.
	*/
d500 3
d504 2
d507 4
d513 1
d536 3
d540 1
d543 3
d547 2
d560 3
d564 1
d568 5
a572 1
		des_set_key((des_cblock *)digest1 + 1, c_schedule2);
d575 4
a578 5
		to calculate the third key we take advantage of
		des_cbc_cksum, a des-cbc based hashing library function,
		using pwdstr as data stream, digest1's first half
		as encryption key and digest1's second half as initialization
		variable.
d580 6
a585 2
		(void)des_cbc_cksum((des_cblock *)pwstr, (des_cblock *)c_third,
			strlen(pwstr), c_schedule1, (des_cblock *)digest1 + 1);
d587 1
d590 3
d594 1
d598 3
d602 1
d605 4
a608 5
		to calculate the third key we take advantage of
		des_cbc_cksum, a des-cbc based hashing library function,
		using pwdstr as data stream, digest2's first half
		as encryption key and digest2's second half as initialization
		variable.
d610 5
a614 2
		(void)des_cbc_cksum((des_cblock *)pwstr, (des_cblock *)s_third,
			strlen(pwstr), s_schedule1, (des_cblock *)digest2 + 1);
d616 1
d679 2
a680 2
	des_cblock		iv;
	des_key_schedule	sched;
d705 8
a712 2
	/* build des keys, using first half of digest */
	des_set_key((des_cblock *)digest, sched);
a713 4
	/* repeatly copy second half of digest to randomstring */
	for (i = 0; i < sizeof(randomstring); i += 8)
		memcpy(randomstring + i, digest + 8, 8);
	
d715 1
a715 3
	bzero(iv, sizeof(iv));
	des_cbc_encrypt((des_cblock *)randomstring, (des_cblock *)randomstring,
		sizeof(randomstring), sched, (des_cblock *)iv, DES_ENCRYPT);
d717 1
a717 1
	/* give a glance of the first random bytes */
d897 3
d901 1
d905 3
d910 1
d912 3
d917 1
d974 3
d979 1
d981 3
d986 1
d1131 8
a1203 1
		/* fall through */
d1206 5
d1217 1
d1220 3
d1225 1
@


1.85
log
@safety
@
text
@d3 4
a6 4
 * $Header: /res/usr/vince/src/stel/RCS/sub.c,v 1.84 1995/11/25 19:19:41 vince Exp $
 * $Date: 1995/11/25 19:19:41 $
 * $Revision: 1.84 $
 * $Locker:  $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: sub.c,v 1.84 1995/11/25 19:19:41 vince Exp $";
d763 1
d821 1
d826 1
d1392 1
d1394 1
d1397 1
@


1.84
log
@safety
@
text
@d3 4
a6 4
 * $Header: /res/usr/vince/src/stel/RCS/sub.c,v 1.83 1995/11/25 19:13:48 vince Exp vince $
 * $Date: 1995/11/25 19:13:48 $
 * $Revision: 1.83 $
 * $Locker: vince $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: sub.c,v 1.83 1995/11/25 19:13:48 vince Exp vince $";
d397 2
a398 1
		printf("\nGENERATING KEYS WITH DIFFIE-HELLMAN\n");
@


1.83
log
@safety
@
text
@d3 3
a5 3
 * $Header: /res/usr/vince/src/stel/RCS/sub.c,v 1.82 1995/11/25 19:08:29 vince Exp vince $
 * $Date: 1995/11/25 19:08:29 $
 * $Revision: 1.82 $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: sub.c,v 1.82 1995/11/25 19:08:29 vince Exp vince $";
d1303 1
a1303 1
		p = (char *)strtok(line + firsttoklen + 1, "\n");
@


1.82
log
@safety
@
text
@d3 3
a5 3
 * $Header: /res/usr/vince/src/stel/RCS/sub.c,v 1.80 1995/11/25 18:19:51 vince Exp vince $
 * $Date: 1995/11/25 18:19:51 $
 * $Revision: 1.80 $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: sub.c,v 1.80 1995/11/25 18:19:51 vince Exp vince $";
d863 1
d1337 1
a1337 3

	hp = gethostbyname(hname);
	if (hp == NULL)
d1370 2
@


1.81
log
@safety
@
text
@d1352 1
d1354 1
d1356 4
a1359 6
		else {
			for (j = 0; hp->h_aliases[j]; j++) {
				if (!doaddrmatch(p, hp->h_aliases[j])) {
					found++;
					break;
				}
d1362 6
a1367 8
		else {
			for (j = 0; hp->h_addr_list[j]; j++) {
				memcpy((char *)&x, hp->h_addr_list[j],
							hp->h_length);
				if (!doaddrmatch(p, (char *)inet_ntoa(x))) {
					found++;
					break;
				}
a1370 2
		if (found)
			break;
@


1.80
log
@safety
@
text
@d3 4
a6 4
 * $Header: /res/usr/vince/src/stel/RCS/sub.c,v 1.79 1995/11/25 16:53:41 vince Exp $
 * $Date: 1995/11/25 16:53:41 $
 * $Revision: 1.79 $
 * $Locker:  $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: sub.c,v 1.79 1995/11/25 16:53:41 vince Exp $";
d1176 1
d1332 3
d1336 5
d1346 1
d1348 3
a1350 1
		if (!doaddrmatch(p, hname)) {
d1352 22
a1374 1
		}
@


1.79
log
@safety
@
text
@d3 3
a5 3
 * $Header: /res/usr/vince/src/stel/RCS/sub.c,v 1.78 1995/11/24 14:07:46 vince Exp $
 * $Date: 1995/11/24 14:07:46 $
 * $Revision: 1.78 $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: sub.c,v 1.78 1995/11/24 14:07:46 vince Exp $";
d397 1
d658 1
@


1.78
log
@safety
@
text
@d3 4
a6 4
 * $Header: /res/usr/vince/src/stel/RCS/sub.c,v 1.77 1995/11/24 14:04:05 vince Exp vince $
 * $Date: 1995/11/24 14:04:05 $
 * $Revision: 1.77 $
 * $Locker: vince $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: sub.c,v 1.77 1995/11/24 14:04:05 vince Exp vince $";
a60 1
des_cblock		IV; /* unused */
d62 3
d70 4
d506 1
a506 1
	bzero(IV, sizeof(IV));
d530 1
d583 5
a587 1
			hexdump("DES server key: ", digest2 + 8, 8);
d1040 1
a1040 1
 * (uses global IV variable) 
d1061 1
d1066 1
d1084 1
d1095 1
@


1.77
log
@safety
@
text
@d3 4
a6 4
 * $Header: /res/usr/vince/src/stel/RCS/sub.c,v 1.75 1995/11/23 16:30:38 vince Exp $
 * $Date: 1995/11/23 16:30:38 $
 * $Revision: 1.75 $
 * $Locker:  $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: sub.c,v 1.75 1995/11/23 16:30:38 vince Exp $";
d67 2
@


1.76
log
@safety
@
text
@d804 1
a804 1
	(void)sprintf(tmp, "a few random numbers = (%ld %ld %ld %ld %ld);\n",
a806 2
		truerand(),
		truerand(),
a1047 1
	RC4Context		*rc4;
d1053 1
a1053 1
		*databyte ^= rc4_byte(rc);
a1068 1
		rc4 = &c_rc4;
a1078 1
		rc4 = &s_rc4;
d1331 16
@


1.75
log
@safety
@
text
@d3 4
a6 4
 * $Header: /res/usr/vince/src/stel/RCS/sub.c,v 1.74 1995/11/21 09:56:21 vince Exp vince $
 * $Date: 1995/11/21 09:56:21 $
 * $Revision: 1.74 $
 * $Locker: vince $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: sub.c,v 1.74 1995/11/21 09:56:21 vince Exp vince $";
d63 5
d522 4
d1050 4
d1055 5
d1072 1
d1083 1
a1085 3
	if (mode < 0)
		return;
	
@


1.74
log
@safety
@
text
@d3 3
a5 3
 * $Header: /users/vince/src/stel/RCS/sub.c,v 1.76 1995/11/15 15:59:46 vince Exp vince $
 * $Date: 1995/11/15 15:59:46 $
 * $Revision: 1.76 $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: sub.c,v 1.76 1995/11/15 15:59:46 vince Exp vince $";
d495 1
a495 1
	/* calculate single des keys */
d503 1
a503 1
	/* calculate idea keys */
d517 1
a517 1
	/* calculate triple des keys 
@


1.73
log
@safety
@
text
@d3 3
a5 3
 * $Header: /res/usr/vince/src/stel/RCS/sub.c,v 1.72 1995/08/26 09:47:35 vince Exp vince $
 * $Date: 1995/08/26 09:47:35 $
 * $Revision: 1.72 $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: sub.c,v 1.72 1995/08/26 09:47:35 vince Exp vince $";
a309 1
/*
a313 1
*/
d316 1
a316 1
char *smallmodulostring = "\
d362 1
a362 1
	else /* 1024 bits modulo */
d364 2
d367 1
a367 1
	/* internal randomness */
d377 1
a377 1
	/* generate a random number % modulo */
d398 1
d413 1
d432 1
d444 15
a458 6
	/* convert shared secret to ascii decimal string, digest the
	   decimal through md5. we create *two* keys, by using two
	   different halves of the decimal string. the former key is
	   used by the client and the latter is used by the server.
	   this is to prevent false data injection as pointed out by
	   bellovin in Session Layer Encryption, V USENIX Symposium */
d462 4
d470 4
d478 8
a485 5
	/* hash encryption key, generate 8 byte hash. we use this hash
	   when performing mutual authentication.
	   Hashing is performed as follows. The first 8 bytes from
	   digest1 are used as des key to encrypt the first 8 bytes
	   from digest2. */
d492 1
a492 1
	/* the key is random, so we do not need a changing IV */
d495 1
d497 1
a497 1
		/* client key */
d500 1
a500 1
		/* server key */
d503 19
a521 2
	/* else */ if (firstack & FLG_USE_TRIPLE) {
		/* client keys */
d523 2
d527 8
a534 6
		/* we want to generate three independent keys to perform
		   triple des encryption. for the third key, we take
		   advantage of des_cbc_cksum, a des based hashing algorithm,
		   using pwdstr as data stream, the first half of pwstr's
		   md5 hash as encryption key and the second half of pwstr's
		   md5 half as iv */
d539 1
a539 1
		/* server keys */
d541 3
d545 8
a556 12
	else {
		for (i = 0; i < 8; i++) {
			/* xor halves together */
			digest1[i] ^= digest1[i + 8];
			digest2[i] ^= digest2[i + 8];
		}
		/* client key */
		des_set_key((des_cblock *)digest1, c_schedule1);

		/* server key */
		des_set_key((des_cblock *)digest2, s_schedule1);
	}
d563 5
a567 1
		/* else */ if (firstack & FLG_USE_TRIPLE) {
a574 4
		else {
			hexdump("DES client key: ", digest1, 8);
			hexdump("DES server key: ", digest2 + 8, 8);
		}
d577 1
d590 13
d615 1
a615 1
	des_key_schedule	sched1, sched2;
d618 3
a620 1
	the size of MDx digest; with size = 512 it generates 4096 bits numbers
a623 1

d639 6
a644 8
	/* build two random des keys */
	des_set_key((des_cblock *)digest, sched1);
	/* fixed by Mark C. Henderson */
	des_set_key((des_cblock *)digest + 1, sched2);

	/* repeatly copy message digest to randomstring */
	for (i = 0; i < sizeof(randomstring); i += 16)
		memcpy(randomstring + i, digest, 16);
d646 1
a646 2
	/* encrypt randomstring (using two-keys triple des encryption)
	this way distill a reasonably random string */
d649 1
a649 5
		sizeof(randomstring), sched1, (des_cblock *)iv, DES_ENCRYPT);
	des_cbc_encrypt((des_cblock *)randomstring, (des_cblock *)randomstring,
		sizeof(randomstring), sched2, (des_cblock *)iv, DES_DECRYPT);
	des_cbc_encrypt((des_cblock *)randomstring, (des_cblock *)randomstring,
		sizeof(randomstring), sched1, (des_cblock *)iv, DES_ENCRYPT);
d661 2
a662 2
	sizeof(randomstring) * 8 bits. this is accomplished in
	a very old fashioned way 
d686 1
d721 8
d740 1
a740 1
	
d780 1
d791 1
d793 9
d1101 1
a1101 2
	/* else */
	if (cipher == TRIPLEDES_CIPHER || cipher == IDEA_CIPHER) { /* 3 DES */
d1109 1
a1109 1
	else { /* cipher == DES_CIPHER */
d1112 3
@


1.72
log
@safety
@
text
@d3 3
a5 3
 * $Header: /res/usr/vince/src/stel/RCS/sub.c,v 1.71 1995/08/26 07:47:15 vince Exp vince $
 * $Date: 1995/08/26 07:47:15 $
 * $Revision: 1.71 $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: sub.c,v 1.71 1995/08/26 07:47:15 vince Exp vince $";
a1066 1
	static regex_t	storedre;
d1068 1
d1071 4
a1074 10
	if (pat) {
		if ((pattern = (char *)buildregexp(pat)) == NULL) {
			syslog(LOGPRI, "buildregexp() failed");
			exit(1);
		}
		if (regcomp(&storedre, pattern,
				REG_EXTENDED | REG_NOSUB | REG_ICASE)) {
			syslog(LOGPRI, "regcomp() failed");
			exit(1);
		}
d1076 3
d1081 2
a1082 3
	(void)memcpy(&re, &storedre, sizeof(re));

	if (!regexec(&re, str, (size_t) 0, NULL, 0))
@


1.71
log
@safety
@
text
@d3 4
a6 4
 * $Header: /res/usr/vince/src/stel/RCS/sub.c,v 1.69 1995/08/25 10:59:54 vince Exp $
 * $Date: 1995/08/25 10:59:54 $
 * $Revision: 1.69 $
 * $Locker:  $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: sub.c,v 1.69 1995/08/25 10:59:54 vince Exp $";
d28 2
d66 5
d100 1
a100 1
	/*
d106 1
a106 1
	*/
d180 1
a180 1
	else
d182 2
d950 1
a950 1
typedef union {
d953 3
a955 3
void			CFBcrypt(databyte, mode, cipher, side)
char			*databyte;
int			mode, cipher, side;
d1054 11
a1064 1
int
a1070 2
	static char	*buildregexp();

d1072 2
a1073 2
		if ((pattern = buildregexp(pat)) == NULL) {
			xprint(STDERR, "buildregexp() failed\n");
d1078 1
a1078 1
			xprint(STDERR, "regcomp() failed\n");
d1093 1
a1093 2
buildregexp(str)
char	*str;
d1170 1
a1170 3
getstelsecret(pathname, hname)
char	*pathname;
char	*hname;
d1172 1
a1172 1
	FILE		*in;
d1175 1
a1175 1
	int		firsttoklen, linenum = 0;;
d1189 1
a1189 1
		if (p == NULL || *p == '#' || p == '\0';)
d1200 1
a1200 1
		p = (char *)strtok(line + firsttoklen + 1, "\t \n");
d1222 2
a1223 3
oneofthese(hname, hosts)
char	*hname;
char	*hosts;
d1230 2
a1231 1
	if ((tmp = strdup(hosts)) == NULL)
d1235 3
a1237 2
	while ((p = strtok((i == 0 ? tmp : NULL), ", \t")) != NULL) {
		if (!domatch(*p, hname)) {
d1244 4
@


1.70
log
@safety
@
text
@d1161 1
d1163 1
a1163 1
	char		*p, 
d1171 12
a1182 1
		if (p == NULL || *p == '#')
d1184 6
a1189 3
		xxxxxxxxxx....
		if (!oneofthese(hname, hosts)) {
			found++;
a1191 3

		/* check stelsecret */
		p = (char *)strtok(
d1193 4
d1199 2
a1203 1
	rip(authbuf);
d1205 25
@


1.69
log
@safety
@
text
@d3 3
a5 3
 * $Header: /res/usr/vince/src/stel/RCS/sub.c,v 1.68 1995/08/23 19:12:23 vince Exp $
 * $Date: 1995/08/23 19:12:23 $
 * $Revision: 1.68 $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: sub.c,v 1.68 1995/08/23 19:12:23 vince Exp $";
a883 45
char *
getetcstelsecret(side)
int	side;
{
	static char	authbuf[STEL_SECRET_MAX_LEN];
	struct stat	sbuf;
	int		in;

	if (stat(ETC_STEL_SECRET_NAME, &sbuf) < 0) {
		if (errno != ENOENT) {
			if (side == CLIENT_SIDE)
				perror(ETC_STEL_SECRET_NAME);
			else
				syslog(LOGPRI, "stat(%s):%m",
							ETC_STEL_SECRET_NAME);
		}
		return(NULL);
	}

	if ((in = open(ETC_STEL_SECRET_NAME, O_RDONLY)) == -1) {
		if (side == CLIENT_SIDE)
			perror(ETC_STEL_SECRET_NAME);
		else
			syslog(LOGPRI, "open(%s):%m", ETC_STEL_SECRET_NAME);
		return(NULL);
	}

	bzero(authbuf, sizeof(authbuf));
	if (read(in, authbuf, sizeof(authbuf)) == -1) {
		if (side == CLIENT_SIDE)
			perror("read()");
		else
			syslog(LOGPRI, "read(%s):%m", ETC_STEL_SECRET_NAME);
		(void)close(in);
		return(NULL);
	}

	(void)close(in);

	rip(authbuf);
	return(authbuf);
}



d1043 145
@


1.68
log
@safety
@
text
@d3 3
a5 3
 * $Header: /res/usr/vince/src/stel/RCS/sub.c,v 1.67 1995/07/19 18:58:54 vince Exp $
 * $Date: 1995/07/19 18:58:54 $
 * $Revision: 1.67 $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: sub.c,v 1.67 1995/07/19 18:58:54 vince Exp $";
d32 1
d36 1
d101 1
a101 1
	if (bind(s, &sa, sizeof(sa)) == -1) {
d125 1
a125 1
	if ((t = accept(s, &sa, &salen)) < 0) {
a144 1
	int			on = 1;
d146 1
a146 1
	if (getpeername(fd, &addr, &addrlen) == -1)
d188 1
a188 1
	if (connect(s, &sa, sizeof(sa)) == -1) {
d337 1
a337 1
	int		i, len, modulobits, secretkeybits;
d845 2
a846 1
	printf("%s", prompt);
d986 3
d993 7
a999 3
	char		*shift1, *shift2, *first1, *first2;
	static char	c_shift1[8], c_shift2[8], c_first1, c_first2;
	static char	s_shift1[8], s_shift2[8], s_first1, s_first2;
a1005 2
	static	firsttime;

d1014 2
a1015 2
		shift1 = c_shift1;
		shift2 = c_shift2;
d1024 2
a1025 2
		shift1 = s_shift1;
		shift2 = s_shift2;
d1057 3
d1061 2
a1062 1
		cipher_idea(shift, shift, *ideakey);
@


1.67
log
@safety
@
text
@d3 3
a5 3
 * $Header: /res/usr/vince/src/stel/RCS/sub.c,v 1.66 1995/07/14 13:58:45 vince Exp $
 * $Date: 1995/07/14 13:58:45 $
 * $Revision: 1.66 $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: sub.c,v 1.66 1995/07/14 13:58:45 vince Exp $";
d59 2
a60 1
static char		sessionkeyhash[8];
@


1.66
log
@safety
@
text
@d3 4
a6 4
 * $Header: /res/usr/vince/src/stel/RCS/sub.c,v 1.64 1995/07/14 11:36:25 vince Exp vince $
 * $Date: 1995/07/14 11:36:25 $
 * $Revision: 1.64 $
 * $Locker: vince $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: sub.c,v 1.64 1995/07/14 11:36:25 vince Exp vince $";
d996 2
d1002 4
a1005 4
		sched1 = (des_key_schedule *)c_schedule1;
		sched2 = (des_key_schedule *)c_schedule2;
		sched3 = (des_key_schedule *)c_schedule3;
		ideakey = (IDEAkey *)c_ideakey;
d1012 4
a1015 4
		sched1 = (des_key_schedule *)s_schedule1;
		sched2 = (des_key_schedule *)s_schedule2;
		sched3 = (des_key_schedule *)s_schedule3;
		ideakey = (IDEAkey *)s_ideakey;
d1024 1
a1024 1

d1026 17
a1042 16
	case	DES_ENCRYPT:
		if (!*first1) { /* First time we use this queue? */
			(void)memcpy(shift1, IV, 8);
			*first1++;
		}
		shift = shift1;
		break;
	case	DES_DECRYPT:
		if (!*first2) {
			(void)memcpy(shift2, IV, 8);
			*first2++;
		}
		shift = shift2;
		break;
	default	:
		return;
d1050 1
a1050 1
		cipher_idea(shift, shift, ideakey);
d1056 1
a1056 1
							sched1, DES_ENCRYPT);
d1058 1
a1058 1
							sched2, DES_DECRYPT);
d1060 1
a1060 1
							sched3, DES_ENCRYPT);
d1064 1
a1064 1
							sched1, DES_ENCRYPT);
@


1.65
log
@safety
@
text
@d979 1
a979 4
 * ideakey: IDEAkey
 * schedule1: DES key schedule
 * schedule2: 3DES key schedule
 * schedule3: 3DES key schedule
d983 1
a983 1
void			CFBcrypt(databyte, mode, cipher, side);
d985 1
a985 3
int			mode, cipher;
IDEAkey			*ideakey;
des_key_schedule	sched1, sched2, sched3;
d987 3
a989 1
	static char	shift1[8], shift2[8], first1, first2;
d996 3
d1000 8
a1007 4
		sched1 = c_schedule1;
		sched2 = c_schedule2;
		sched3 = c_schedule3;
		ideakey = c_ideakey;
d1010 8
a1017 4
		sched1 = c_schedule1;
		sched2 = c_schedule2;
		sched3 = c_schedule3;
		ideakey = c_ideakey;
d1025 1
a1025 1
		if (!first1) { /* First time we use this queue? */
d1027 1
a1027 1
			first1++;
d1032 1
a1032 1
		if (!first2) {
d1034 1
a1034 1
			first2++;
@


1.64
log
@safety
@
text
@d3 4
a6 4
 * $Header: /res/usr/vince/src/stel/RCS/sub.c,v 1.63 1995/07/13 17:37:31 vince Exp $
 * $Date: 1995/07/13 17:37:31 $
 * $Revision: 1.63 $
 * $Locker:  $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: sub.c,v 1.63 1995/07/13 17:37:31 vince Exp $";
d986 1
a986 2
void			CFBcrypt(databyte, mode, cipher, ideakey,
					sched1, sched2, sched3)
d995 16
@


1.63
log
@safety
@
text
@d3 4
a6 4
 * $Header: /res/usr/vince/src/stel/RCS/sub.c,v 1.62 1995/07/13 17:35:49 vince Exp vince $
 * $Date: 1995/07/13 17:35:49 $
 * $Revision: 1.62 $
 * $Locker: vince $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: sub.c,v 1.62 1995/07/13 17:35:49 vince Exp vince $";
d36 2
d39 1
d100 3
a102 1
		syslog(LOGPRI, "bind(): %m");
d144 1
a144 3
	if (setsockopt(fd, SOL_SOCKET, SO_KEEPALIVE,
					(char *)&on, sizeof (on)) == -1) {
		syslog(LOGPRI, "setsockopt (SO_KEEPALIVE): %m");
a145 1
	}
a146 5
	if (getpeername(fd, &addr, &addrlen) == -1) {
		perror("getpeername()"); /* so frequent */
		syslog(LOGPRI, "getpeername() failed");
		return(NULL);
	}
d336 2
a337 1
	MD5_CTX		mdContext1, mdContext2, mdContext3;
d362 2
a363 1
		(void)strcat(randbuf, rndstr);
d439 10
a448 11
	MD5Init(&mdContext1);
	MD5Update(&mdContext1, pwstr, strlen(pwstr) / 2);
	MD5Final(&mdContext1);

	MD5Init(&mdContext2);
	MD5Update(&mdContext2, pwstr + strlen(pwstr) / 2, strlen(pwstr) / 2);
	MD5Final(&mdContext2);

	/* hash encryption key for use in the authentication step
	   we do use a hash of the key vs the key instead so it is
	   safer to keep in in memory.
d450 4
a453 3
	   the digest are used as des key to encrypt the second half. */
	des_set_key((des_cblock *)mdContext1.digest, tmpsched);
	memcpy(sessionkeyhash, mdContext1.digest + 8, 8);
d462 2
a463 2
		init_this_key_idea(c_ideakey, mdContext1.digest, FALSE);
		init_this_key_idea(s_ideakey, mdContext2.digest, FALSE);
d465 2
a466 3
		/* this was the old syntax -- delete when ok
		initcfb_idea((word16 *) IV, mdContext.digest, side);
		*/
d468 3
a470 2
	else if (firstack & FLG_USE_TRIPLE) {
		des_set_key((des_cblock *)mdContext1.digest, c_schedule1);
d472 1
a472 2
		des_set_key((des_cblock *)mdContext1.digest + 1, c_schedule2);

d476 1
a476 1
		   using *pwdstr as data stream, the first half of pwstr's
d480 2
a481 2
			strlen(pwstr), c_schedule1, (des_cblock *)mdContext1.digest + 1);
		des_set_key(&c_third, c_schedule3);
d483 3
a485 2
		des_set_key((des_cblock *)mdContext2.digest, s_schedule1);
		des_set_key((des_cblock *)mdContext2.digest + 1, s_schedule2);
d487 2
a488 2
			strlen(pwstr), s_schedule1, (des_cblock *)mdContext2.digest + 1);
		des_set_key(&s_third, s_schedule3);
d493 2
a494 2
			mdContext1.digest[i] ^= mdContext1.digest[i + 8];
			mdContext2.digest[i] ^= mdContext2.digest[i + 8];
d496 5
a500 2
		des_set_key((des_cblock *)mdContext1.digest, c_schedule1);
		des_set_key((des_cblock *)mdContext2.digest, s_schedule1);
d505 2
a506 2
			hexdump("IDEA client key: ", mdContext1.digest, 16);
			hexdump("IDEA server key: ", mdContext2.digest, 16);
d509 2
a510 2
			hexdump("3DES client key #1: ", mdContext1.digest, 8);
			hexdump("3DES client key #2: ", mdContext1.digest + 8, 8);
d512 2
a513 2
			hexdump("3DES server key #1: ", mdContext2.digest, 8);
			hexdump("3DES server key #2: ", mdContext2.digest + 8, 8);
d517 2
a518 2
			hexdump("DES client key: ", mdContext1.digest, 8);
			hexdump("DES server key: ", mdContext2.digest + 8, 8);
d523 2
a524 2
	bzero(mdContext1.digest, 16);
	bzero(mdContext2.digest, 16);
d543 1
d562 1
a562 1
	MD5Final(&mdContext);
d566 1
a566 1
		hexdump("digest of random string: ", mdContext.digest, 16);
d570 1
a570 1
	des_set_key((des_cblock *)mdContext.digest, sched1);
d572 1
a572 1
	des_set_key((des_cblock *)mdContext.digest + 1, sched2);
d576 1
a576 1
		memcpy(randomstring + i, mdContext.digest, 16);
d578 1
a578 1
	/* encrypt randomstring (triple des is better than single des)
d631 1
a631 1
#ifndef linux
d728 1
d740 1
a740 1
	MD5Final(&mdContext);
d744 1
a744 1
		mdContext.digest[i] ^= mdContext.digest[i + 8];
d747 1
a747 1
	des_set_key((des_cblock *)mdContext.digest, authsched);
d760 1
a760 1
							mdContext.digest, 8);
@


1.62
log
@safety
@
text
@d3 4
a6 4
 * $Header: /res/usr/vince/src/stel/RCS/sub.c,v 1.61 1995/07/13 11:03:57 vince Exp $
 * $Date: 1995/07/13 11:03:57 $
 * $Revision: 1.61 $
 * $Locker:  $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: sub.c,v 1.61 1995/07/13 11:03:57 vince Exp $";
d264 5
a268 1
	/*
d272 1
a272 4
	*/
        (void) sprintf(line, "/dev/ptym/ptyXX");
        p1 = &line[13];
        p2 = &line[14];
a282 1
			syslog(LOGPRI, "%s seems ok", line);
d284 1
d286 3
a292 4
				syslog(LOGPRI, "%s not ok", line);
				/*
                                line[5] = 't';
				*/
@


1.61
log
@safety
@
text
@d3 3
a5 3
 * $Header: /res/usr/vince/src/stel/RCS/sub.c,v 1.60 1995/07/12 16:44:00 vince Exp $
 * $Date: 1995/07/12 16:44:00 $
 * $Revision: 1.60 $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: sub.c,v 1.60 1995/07/12 16:44:00 vince Exp $";
d16 1
d262 1
d264 1
d268 4
d282 9
a290 1
                        if (p > 0) {
d292 1
a292 1
                                return(p);
a328 16

/* another 2048 bits suitable modulo */
/*
# ***** this one is good for for DH scheme:
D198327D D24B7B8B 0694C712 DA9CB3C9 B05A1ABE C60EF107 EA092FEE\
34F9E7CA DE32EA3F C534AB44 42FF03D2 7057CB41 C1578D33 8B824F52\
C5A281AF EC7B157E E2CA4A79 92071E17 BE7D4951 3F8D3C4E 3025C7D2\
BBB6CCFB 5944ADDF 078A8572 FCB80DC9 02A7723D D508C88F 0B4D9EB1\
4A3B738C 9BD23C9D 6DBF869C E63472D4 E0632F5F 18767F95 4782AE34\
10AE116F BF2A0FB9 09945908 FD0B73AE D1863EF6 A4F14DC2 7691F812\
7CD1549F 6E288FF3 38F29DFB 060B4195 9F8EDE39 29255053 3CD42669\
2F8CE608 F6515A36 50F9E0BF CB0C2DE2 61FD06D1 9FB4AD74 6724C88A\
3AFC5D5E 901EE390 67A14CD7 41398E38 8DC6F5BB 62FE969A 4DC1D352\
A36189FF 
*****
*/
@


1.60
log
@safety
@
text
@d3 3
a5 3
 * $Header: /res/usr/vince/src/stel/RCS/sub.c,v 1.59 1995/05/11 16:24:24 vince Exp $
 * $Date: 1995/05/11 16:24:24 $
 * $Revision: 1.59 $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: sub.c,v 1.59 1995/05/11 16:24:24 vince Exp $";
d53 1
a53 1
des_cblock		IV[8]; /* unused */
d286 1
a287 5
char	*smallmodulostring = "edcbaf322bfb0ce75dcdf9a806d\
9fd6768983c21aa4ed3f1b8ecfd8e20943fc7";
*/

/* 512 bits modulo, medium security */
d292 1
d294 2
a295 2
/* 1024 bits modulo, high security */
char *largemodulostring = "\
d302 28
d354 1
a354 1
	if (firstack & FLG_LARGE_MODULUS)
d356 1
a356 1
	else
d380 7
a386 4
	if (side == CLIENT_SIDE && firstack & FLG_DEBUG) {
		printf("x (client secret key):\n");
		mpz_out_str(stdout, 10, &mysecret);
		printf("\n");
d394 7
a400 4
	if (side == CLIENT_SIDE && firstack & FLG_DEBUG) {
		printf("3**x (client public key):\n");
		mpz_out_str(stdout, 10, &mypublic);
		printf("\n");
d412 7
a418 4
	if (side == CLIENT_SIDE && firstack & FLG_DEBUG) {
		printf("3**y (server public key):\n");
		mpz_out_str(stdout, 10, &hispublic);
		printf("\n");
d423 7
a429 4
	if (side == CLIENT_SIDE && firstack & FLG_DEBUG) {
		printf("(3**y)**x (shared secret):\n");
		mpz_out_str(stdout, 10, &sharedsecret);
		printf("\n");
d482 1
a482 1
		(void)des_cbc_cksum((des_cblock *)pwstr, &c_third,
d488 1
a488 1
		(void)des_cbc_cksum((des_cblock *)pwstr, &s_third,
d507 1
a507 1
		else if (firstack & FLG_USE_TRIPLE) {
d1022 1
d1024 2
a1025 1
	else if (cipher == TRIPLEDES_CIPHER) { /* 3 DES */
@


1.59
log
@safety
@
text
@d3 4
a6 4
 * $Header: /res/usr/vince/src/stel/RCS/sub.c,v 1.58 1995/05/10 18:00:18 vince Exp vince $
 * $Date: 1995/05/10 18:00:18 $
 * $Revision: 1.58 $
 * $Locker: vince $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: sub.c,v 1.58 1995/05/10 18:00:18 vince Exp vince $";
d42 2
d47 7
a53 3
des_key_schedule	schedule1;
des_key_schedule	schedule2;
des_cblock		IV[8]; /* used by IDEA too */
d57 2
a58 1
establish()
d61 1
a61 1
	int			s, on = 1, portnum;
d64 6
a69 4
	if ((serv = getservbyname(PRGNAME, "tcp")) == NULL)
		portnum = PORTNUM;
	else
		portnum = serv->s_port;
a70 3
	/* testing */
	portnum = 10006;

d315 1
a315 1
	MD5_CTX		mdContext;
d317 1
a345 4
/*
	mpz_random(&mysecret, 50);
	mpz_mod(&mysecret, &mysecret, &modulo);
*/
d396 5
a400 1
	   decimal through md5 */
a402 8
	MD5Init(&mdContext);
	MD5Update(&mdContext, pwstr, strlen(pwstr));
	MD5Final(&mdContext);

	/* Instead of effectively using the real session key in the
	auth step we use hash(session key), in order to be safer to keep 
	in in memory.  Hash is done as follows. The first 8 bytes from
	the digest are set as des key to encrypt the second half. */
d404 15
a418 2
	des_set_key((des_cblock *)mdContext.digest, tmpsched);
	memcpy(sessionkeyhash, mdContext.digest + 8, 8);
d423 3
d427 4
a430 2
		/* the key is random, so we do not need a changing IV */
		bzero(IV, sizeof(IV));
d432 1
d435 1
a435 1
		des_set_key((des_cblock *)mdContext.digest, schedule1);
d437 17
a453 1
		des_set_key((des_cblock *)mdContext.digest + 1, schedule2);
d456 1
a456 1
		for (i = 0; i < 8; i++)
d458 5
a462 2
			mdContext.digest[i] ^= mdContext.digest[i + 8];
		des_set_key((des_cblock *)mdContext.digest, schedule1);
d465 18
a482 4
	if (side == CLIENT_SIDE && firstack & FLG_BE_VERBOSE)
		hexdump("shared encryption key: ", mdContext.digest,
			((firstack & FLG_USE_IDEA) ||
			(firstack & FLG_USE_TRIPLE) ? 16 : 8));
d484 3
a486 1
	bzero(mdContext.digest, 16);
d807 1
a807 1
	printf("\n");
d934 75
@


1.58
log
@safety
@
text
@d3 4
a6 4
 * $Header: /res/usr/vince/src/stel/RCS/sub.c,v 1.57 1995/05/10 15:10:14 vince Exp $
 * $Date: 1995/05/10 15:10:14 $
 * $Revision: 1.57 $
 * $Locker:  $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: sub.c,v 1.57 1995/05/10 15:10:14 vince Exp $";
d403 1
a403 1
	the digest are set as des key to encrypt the second halve. */
d418 2
a419 1
		des_set_key((des_cblock *)mdContext.digest + 8, schedule2);
d479 2
a480 1
	des_set_key((des_cblock *)mdContext.digest + 8, sched2);
@


1.57
log
@safety
@
text
@d3 4
a6 4
 * $Header: /res/usr/vince/src/stel/RCS/sub.c,v 1.56 1995/05/06 15:39:00 vince Exp vince $
 * $Date: 1995/05/06 15:39:00 $
 * $Revision: 1.56 $
 * $Locker: vince $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: sub.c,v 1.56 1995/05/06 15:39:00 vince Exp vince $";
d27 8
d376 1
a376 1
	mpz_init_set_str(&hispublic, exchange, 10);
d828 51
@


1.56
log
@safety
@
text
@d3 4
a6 4
 * $Header: /res/usr/vince/src/stel/RCS/sub.c,v 1.55 1995/04/22 09:42:58 vince Exp $
 * $Date: 1995/04/22 09:42:58 $
 * $Revision: 1.55 $
 * $Locker:  $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: sub.c,v 1.55 1995/04/22 09:42:58 vince Exp $";
d53 3
d251 1
a251 1
        for (c = 'p'; c <= 's'; c++) {
@


1.55
log
@safety
@
text
@d3 3
a5 3
 * $Header: /res/usr/vince/src/stel/RCS/sub.c,v 1.54 1995/04/21 18:27:26 vince Exp $
 * $Date: 1995/04/21 18:27:26 $
 * $Revision: 1.54 $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: sub.c,v 1.54 1995/04/21 18:27:26 vince Exp $";
d43 1
a43 2
establish(portnum)
int	portnum;
d46 7
a52 1
	int			s, on = 1;
@


1.54
log
@safety
@
text
@d3 3
a5 3
 * $Header: /res/usr/vince/src/stel/RCS/sub.c,v 1.53 1995/04/08 15:48:43 vince Exp $
 * $Date: 1995/04/08 15:48:43 $
 * $Revision: 1.53 $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: sub.c,v 1.53 1995/04/08 15:48:43 vince Exp $";
d771 2
a772 1
getetcstelsecret()
d779 7
a785 2
		if (errno != ENOENT)
			syslog(LOGPRI, "stat(%s):%m", ETC_STEL_SECRET_NAME);
d790 4
a793 1
		syslog(LOGPRI, "open(%s):%m", ETC_STEL_SECRET_NAME);
d799 4
a802 1
		syslog(LOGPRI, "read(%s):%m", ETC_STEL_SECRET_NAME);
@


1.53
log
@safety
@
text
@d3 3
a5 3
 * $Header: /res/usr/vince/src/stel/RCS/sub.c,v 1.52 1995/04/08 11:18:38 vince Exp $
 * $Date: 1995/04/08 11:18:38 $
 * $Revision: 1.52 $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: sub.c,v 1.52 1995/04/08 11:18:38 vince Exp $";
d577 1
a577 1
	/* mod dates of frequently changing files */
d768 31
@


1.52
log
@safety
@
text
@d3 3
a5 3
 * $Header: /res/usr/vince/src/stel/RCS/sub.c,v 1.51 1995/04/05 16:35:14 vince Exp $
 * $Date: 1995/04/05 16:35:14 $
 * $Revision: 1.51 $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: sub.c,v 1.51 1995/04/05 16:35:14 vince Exp $";
a747 7
	/*
	 * The only way I could get the Sun 3.5 compiler
	 * to shut up about
	 *	if ((unsigned int)c >= 0x80)
	 * was to assign "c" to an unsigned int variable...
	 * Arggg....
	 */
a768 1

@


1.51
log
@safety
@
text
@d3 3
a5 3
 * $Header: /res/usr/vince/src/stel/RCS/sub.c,v 1.50 1995/04/04 10:27:58 vince Exp $
 * $Date: 1995/04/04 10:27:58 $
 * $Revision: 1.50 $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: sub.c,v 1.50 1995/04/04 10:27:58 vince Exp $";
d14 1
a33 1
IDEAkey			Z;
a395 1
		en_key_idea(mdContext.digest, Z);
d738 39
@


1.50
log
@safety
@
text
@d3 4
a6 4
 * $Header: /res/usr/vince/src/stel/RCS/sub.c,v 1.49 1995/04/03 16:56:36 vince Exp vince $
 * $Date: 1995/04/03 16:56:36 $
 * $Revision: 1.49 $
 * $Locker: vince $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: sub.c,v 1.49 1995/04/03 16:56:36 vince Exp vince $";
d264 5
d323 5
d433 1
a433 1
	register	i;
d437 1
a437 1
	des_cblock	iv;
d494 2
d497 3
a499 1
		mpz_pow_ui(&y, &ff, (unsigned long)i);
d501 3
a503 1
		mpz_mul_ui(&x, &y, (unsigned long)randomstring[i]);
d506 4
d522 1
d545 1
@


1.49
log
@safety
@
text
@d3 4
a6 4
 * $Header: /res/usr/vince/src/stel/RCS/sub.c,v 1.46 1995/03/31 19:34:43 vince Exp $
 * $Date: 1995/03/31 19:34:43 $
 * $Revision: 1.46 $
 * $Locker:  $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: sub.c,v 1.46 1995/03/31 19:34:43 vince Exp $";
a501 48
#if 0
/*
 * Modified read() & write() for sockets.
 * Returns: number of characters read if ok; -1 if fails.
 */
int		read_data(s, buf, n)
int		s;
char		*buf;
int		n;
{
	int		bcount;
	int		br;

	bcount= 0;
	br= 0;
	while (bcount < n) {
		if ((br = read(s, buf, n - bcount)) > 0) {
			bcount += br;
			buf += br;
		}
	else if (br < 0)
		return(-1);
	}
	return(bcount);
}

int		write_data(s, buf, n)
int		s;
char		*buf;
int		n;
{
	int		bcount;
	int		br;

	bcount= 0;
	br= 0;
	while (bcount < n) {
		if ((br = write(s, buf, n - bcount)) > 0) {
			bcount += br;
			buf += br;
		}
	else if (br < 0)
		return(-1);
	}
	return(bcount);
}
#endif

d559 10
@


1.48
log
@safety
@
text
@a25 1
#include "lip.h"
a278 1
#ifdef USELIP
a282 210
	verylong	modulo = 0, three = 0, sharedsecret = 0;
	verylong	mysecret = 0, mypublic = 0;
	verylong	hispublic = 0;
	char		pwstr[4096], exchange[4096];
	unsigned char	randbuf[4096];
	int		i, len, modulobits;
	MD5_CTX		mdContext;
	des_key_schedule	tmpsched;

	unsigned char	*internalrnd();

	zintoz(3, &three);
	if (firstack & FLG_LARGE_MODULUS)
		zstrtozbas(largemodulostring, 16L, &modulo);
	else
		zstrtozbas(smallmodulostring, 16L, &modulo);

	/* internal randomness */
	strncpy(randbuf, internalrnd(), sizeof(randbuf));

	/* user-provided randomness */
	if (rndstr) {
		(void)strcat(randbuf, "\n");
		(void)strcat(randbuf, rndstr);
	}

	modulobits = z2log(modulo);
	/* generate a (modulobits - 1) bits random number */
	mkrnd(randbuf, &mysecret, modulobits - 1,
			(side == CLIENT_SIDE && firstack & FLG_DEBUG));

	if (side == CLIENT_SIDE && firstack & FLG_BE_VERBOSE) {
		printf("Using %d bits modulus\n", modulobits);
		printf("exchanging keys with DH scheme (can be a lengthy process)...\n");
	}

	if (side == CLIENT_SIDE && firstack & FLG_DEBUG) {
		printf("x (client secret key):\n");
		zwriteln(mysecret);
	}

	zexpmod(three, mysecret, modulo, &mypublic);

	bzero(exchange, sizeof(exchange));

	zswrite(exchange, mypublic);

	if (side == CLIENT_SIDE && firstack & FLG_DEBUG) {
		printf("3**x (client public key):\n");
		zwriteln(mypublic);
	}

	if (write_data(s, exchange, sizeof(exchange)) != sizeof(exchange))
		return(-1);
	
	bzero(exchange, sizeof(exchange));
	if (read_data(s, exchange, sizeof(exchange)) != sizeof(exchange))
		return(-1);

	zstrtoz(exchange, &hispublic);

	if (side == CLIENT_SIDE && firstack & FLG_DEBUG) {
		printf("3**y (server public key):\n");
		zwriteln(hispublic);
	}

	zexpmod(hispublic, mysecret, modulo, &sharedsecret);

	if (side == CLIENT_SIDE && firstack & FLG_DEBUG) {
		printf("(3**y)**x (shared secret):\n");
		zwriteln(sharedsecret);
	}
	
	/* convert shared secret to ascii decimal string, digest the
	   decimal through md5 */
	bzero(pwstr, sizeof(pwstr));
	zswrite(pwstr, sharedsecret);
	MD5Init(&mdContext);
	MD5Update(&mdContext, pwstr, strlen(pwstr));
	MD5Final(&mdContext);

	/* Instead of effectively using the real session key in the
	auth step we use hash(session key), in order to be safer to keep 
	in in memory.  Hash is done as follows. The first 8 bytes from
	the digest are set as des key to encrypt the second halve. */

	des_set_key((des_cblock *)mdContext.digest, tmpsched);
	memcpy(sessionkeyhash, mdContext.digest + 8, 8);
	des_ecb_encrypt((des_cblock *)sessionkeyhash,
			(des_cblock *)sessionkeyhash, tmpsched, ENCRYPT);
	bzero(tmpsched, sizeof(tmpsched));

	if (firstack & FLG_USE_IDEA) {
		en_key_idea(mdContext.digest, Z);
		/* the key is random, so we do not need a changing IV */
		bzero(IV, sizeof(IV));
		initcfb_idea((word16 *) IV, mdContext.digest, side);
	}
	else if (firstack & FLG_USE_TRIPLE) {
		des_set_key((des_cblock *)mdContext.digest, schedule1);
		des_set_key((des_cblock *)mdContext.digest + 8, schedule2);
	}
	else {
		for (i = 0; i < 8; i++)
			/* xor halves together */
			mdContext.digest[i] ^= mdContext.digest[i + 8];
		des_set_key((des_cblock *)mdContext.digest, schedule1);
	}

	if (side == CLIENT_SIDE && firstack & FLG_BE_VERBOSE)
		hexdump("shared encryption key: ", mdContext.digest,
			((firstack & FLG_USE_IDEA) ||
			(firstack & FLG_USE_TRIPLE) ? 16 : 8));

	bzero(mdContext.digest, 16);

	return(0);
}

/* mkrnd(): generate a verylong random number using a seed
arguments:
str: a true random string (the user should be required to type in)
rnd: pointer to very long number
bits: length, in bits, of the required verylong number
*/
mkrnd(str, rnd, bits, logging)
unsigned char	*str;
verylong	*rnd;
int		bits, logging;
{
	verylong	x = 0, y = 0, ff = 0;
	verylong	value = 0;
	register	i;

	MD5_CTX		mdContext;

	des_cblock	iv;
	des_key_schedule	sched1, sched2;

	/* the size of randomstring should be a multiple of 16, that is,
	the size of MDx digest; with size = 512 it generates 4096 bits numbers
	*/
	unsigned char	randomstring[512];

	/* digest user's input */
	MD5Init(&mdContext);
	MD5Update(&mdContext, str, strlen(str));
	MD5Final(&mdContext);

	if (logging) {
		printf("random string: \"%s\"\n", str);
		hexdump("digest of random string: ", mdContext.digest, 16);
	}

	/* build two random des keys */
	des_set_key((des_cblock *)mdContext.digest, sched1);
	des_set_key((des_cblock *)mdContext.digest + 8, sched2);

	/* repeatly copy message digest to randomstring */
	for (i = 0; i < sizeof(randomstring); i += 16)
		memcpy(randomstring + i, mdContext.digest, 16);
	
	/* encrypt randomstring (triple des is better than single des)
	this way distill a reasonably random string */
	bzero(iv, sizeof(iv));
	des_cbc_encrypt((des_cblock *)randomstring, (des_cblock *)randomstring,
		sizeof(randomstring), sched1, (des_cblock *)iv, DES_ENCRYPT);
	des_cbc_encrypt((des_cblock *)randomstring, (des_cblock *)randomstring,
		sizeof(randomstring), sched2, (des_cblock *)iv, DES_DECRYPT);
	des_cbc_encrypt((des_cblock *)randomstring, (des_cblock *)randomstring,
		sizeof(randomstring), sched1, (des_cblock *)iv, DES_ENCRYPT);

	/* give a glance of the first random bytes */
	if (logging) {
		hexdump("first 20 random bytes: ", randomstring, 20);
		hexdump("next 20 random bytes : ", randomstring + 20, 20);
		hexdump("next 20 random bytes : ", randomstring + 40, 20);
		printf("skipped all remaining random bytes (%d bytes in all)\n",
							sizeof(randomstring));
	}

	/* build a verylong random number whose size is
	sizeof(randomstring) * 8 bits. this is accomplished in
	a very old fashioned way 
	*/
	zintoz(256, &ff);
	for (i = 0; i < sizeof(randomstring); i++) {
		zsexp(ff, (long)i, &y); 
		zsmul(y, (long)randomstring[i], &x);
		zadd(value, x, &value);
	}

	/* get the highest ``bits'' bits from value: I read somewhere
	(Knuth?) that the highest bits of a PNG-generated number are
	the best bits for cryptographic applications. However, being
	the string really random looking, all the bits should be good
	to our goals */
	zhighbits(value, (long)bits, rnd);

	bzero(randomstring, sizeof(randomstring));
	bzero(str, strlen(str));
	value = x = y = 0;
}

#else /* use GMP instead */

dhexchange(s, side, firstack, rndstr)
int	s, side, firstack;
unsigned char	*rndstr;
{
d502 1
a502 2
#endif /* USELIP */

@


1.47
log
@safety
@
text
@d280 1
d285 3
a287 2
	MP_INT		modulo, three, sharedsecret, mysecret,
			mypublic, hispublic;
d290 1
a290 1
	int		i, len, modulobits, secretkeybits;
d296 1
a296 8
	mpz_init(&modulo);
	mpz_init(&three);
	mpz_init(&sharedsecret);
	mpz_init(&mysecret);
	mpz_init(&mypublic);
	mpz_init(&hispublic);

	mpz_set_ui(&three, 3L);
d298 1
a298 1
		mpz_set_str(&modulo, largemodulostring, 16);
d300 1
a300 1
		mpz_set_str(&modulo, smallmodulostring, 16);
d311 3
a313 2
	/* generate a random number % modulo */
	mkrnd(randbuf, &mysecret, &modulo,
d315 1
a315 2
	modulobits = mpz_sizeinbase(&modulo, 2);
	secretkeybits = mpz_sizeinbase(&mysecret, 2);
d317 1
a317 2
		printf("Using %d bits modulus, %d bits secret key\n",
						modulobits, secretkeybits);
d323 1
a323 2
		mpz_out_str(stdout, 10, &mysecret);
		printf("\n");
d326 1
a326 1
	mpz_powm(&mypublic, &three, &mysecret, &modulo);
d329 2
a330 1
	mpz_get_str(exchange, 10, &mypublic);
d334 1
a334 2
		mpz_out_str(stdout, 10, &mypublic);
		printf("\n");
d344 1
a344 1
	mpz_init_set_str(&hispublic, exchange, 10);
d348 1
a348 2
		mpz_out_str(stdout, 10, &hispublic);
		printf("\n");
d351 1
a351 1
        mpz_powm(&sharedsecret, &hispublic, &mysecret, &modulo);
d355 1
a355 2
		mpz_out_str(stdout, 10, &sharedsecret);
		printf("\n");
d361 1
a361 1
	mpz_get_str(pwstr, 10, &sharedsecret);
d400 1
a400 6
	mpz_clear(&modulo);
	mpz_clear(&three);
	mpz_clear(&sharedsecret);
	mpz_clear(&mysecret);
	mpz_clear(&mypublic);
	mpz_clear(&hispublic);
d404 87
a490 1
#ifdef LIP
d495 2
a496 3
	verylong	modulo = 0, three = 0, sharedsecret = 0;
	verylong	mysecret = 0, mypublic = 0;
	verylong	hispublic = 0;
d499 1
a499 1
	int		i, len, modulobits;
d505 8
a512 1
	zintoz(3, &three);
d514 1
a514 1
		zstrtozbas(largemodulostring, 16L, &modulo);
d516 1
a516 1
		zstrtozbas(smallmodulostring, 16L, &modulo);
d527 2
a528 3
	modulobits = z2log(modulo);
	/* generate a (modulobits - 1) bits random number */
	mkrnd(randbuf, &mysecret, modulobits - 1,
d530 2
a531 1

d533 2
a534 1
		printf("Using %d bits modulus\n", modulobits);
d540 2
a541 1
		zwriteln(mysecret);
d544 1
a544 1
	zexpmod(three, mysecret, modulo, &mypublic);
d547 1
a547 2

	zswrite(exchange, mypublic);
d551 2
a552 1
		zwriteln(mypublic);
d562 1
a562 1
	zstrtoz(exchange, &hispublic);
d566 2
a567 1
		zwriteln(hispublic);
d570 1
a570 1
	zexpmod(hispublic, mysecret, modulo, &sharedsecret);
d574 2
a575 1
		zwriteln(sharedsecret);
d581 1
a581 1
	zswrite(pwstr, sharedsecret);
d620 6
a625 72

	return(0);
}
#else /* use GMP instead */

/*
 * Modified read() & write() for sockets.
 * Returns: number of characters read if ok; -1 if fails.
 */
int		read_data(s, buf, n)
int		s;
char		*buf;
int		n;
{
	int		bcount;
	int		br;

	bcount= 0;
	br= 0;
	while (bcount < n) {
		if ((br = read(s, buf, n - bcount)) > 0) {
			bcount += br;
			buf += br;
		}
	else if (br < 0)
		return(-1);
	}
	return(bcount);
}

int		write_data(s, buf, n)
int		s;
char		*buf;
int		n;
{
	int		bcount;
	int		br;

	bcount= 0;
	br= 0;
	while (bcount < n) {
		if ((br = write(s, buf, n - bcount)) > 0) {
			bcount += br;
			buf += br;
		}
	else if (br < 0)
		return(-1);
	}
	return(bcount);
}
#endif

killoptions(s, host)
int	s;
char	*host;
{
	unsigned char	buf[BUFSIZ / 3], *pbuf;
	char		dumpbuf[BUFSIZ], *pdump = dumpbuf;
	int		bufsiz = sizeof(buf);

	if (!getsockopt(s, IPPROTO_IP, IP_OPTIONS, (char *)buf, &bufsiz) &&
	    bufsiz != 0) { /* options are set */
		for (pbuf = buf; bufsiz > 0; pbuf++, bufsiz--, pdump += 3)
			sprintf(pdump, " %2.2x", *pbuf);
		syslog(LOGPRI,
			"connection from %s with IP_OPTIONS (ignored): %s",
							host, dumpbuf);
		if (setsockopt(s, IPPROTO_IP, IP_OPTIONS, NULL, 0)) {
			syslog(LOG_ERR, "setsockopt(IP_OPTIONS): %m");
			return(1);
		}
	}
a695 5
		/*
		zsexp(ff, (long)i, &y); 
		zsmul(y, (long)randomstring[i], &x);
		zadd(value, x, &value);
		*/
d714 1
d716 8
a723 11
#if 0
/* mkrnd(): generate a verylong random number using a seed
arguments:
str: a true random string (the user should be required to type in)
rnd: pointer to very long number
bits: length, in bits, of the required verylong number
*/
mkrnd(str, rnd, bits, logging)
unsigned char	*str;
verylong	*rnd;
int		bits, logging;
d725 2
a726 3
	verylong	x = 0, y = 0, ff = 0;
	verylong	value = 0;
	register	i;
d728 12
a739 1
	MD5_CTX		mdContext;
d741 7
a747 2
	des_cblock	iv;
	des_key_schedule	sched1, sched2;
d749 9
a757 13
	/* the size of randomstring should be a multiple of 16, that is,
	the size of MDx digest; with size = 512 it generates 4096 bits numbers
	*/
	unsigned char	randomstring[512];

	/* digest user's input */
	MD5Init(&mdContext);
	MD5Update(&mdContext, str, strlen(str));
	MD5Final(&mdContext);

	if (logging) {
		printf("random string: \"%s\"\n", str);
		hexdump("digest of random string: ", mdContext.digest, 16);
d759 3
d763 7
a769 3
	/* build two random des keys */
	des_set_key((des_cblock *)mdContext.digest, sched1);
	des_set_key((des_cblock *)mdContext.digest + 8, sched2);
d771 11
a781 21
	/* repeatly copy message digest to randomstring */
	for (i = 0; i < sizeof(randomstring); i += 16)
		memcpy(randomstring + i, mdContext.digest, 16);
	
	/* encrypt randomstring (triple des is better than single des)
	this way distill a reasonably random string */
	bzero(iv, sizeof(iv));
	des_cbc_encrypt((des_cblock *)randomstring, (des_cblock *)randomstring,
		sizeof(randomstring), sched1, (des_cblock *)iv, DES_ENCRYPT);
	des_cbc_encrypt((des_cblock *)randomstring, (des_cblock *)randomstring,
		sizeof(randomstring), sched2, (des_cblock *)iv, DES_DECRYPT);
	des_cbc_encrypt((des_cblock *)randomstring, (des_cblock *)randomstring,
		sizeof(randomstring), sched1, (des_cblock *)iv, DES_ENCRYPT);

	/* give a glance of the first random bytes */
	if (logging) {
		hexdump("first 20 random bytes: ", randomstring, 20);
		hexdump("next 20 random bytes : ", randomstring + 20, 20);
		hexdump("next 20 random bytes : ", randomstring + 40, 20);
		printf("skipped all remaining random bytes (%d bytes in all)\n",
							sizeof(randomstring));
d783 2
a784 18

	/* build a verylong random number whose size is
	sizeof(randomstring) * 8 bits. this is accomplished in
	a very old fashioned way 
	*/
	zintoz(256, &ff);
	for (i = 0; i < sizeof(randomstring); i++) {
		zsexp(ff, (long)i, &y); 
		zsmul(y, (long)randomstring[i], &x);
		zadd(value, x, &value);
	}

	/* get the highest ``bits'' bits from value: I read somewhere
	(Knuth?) that the highest bits of a PNG-generated number are
	the best bits for cryptographic applications. However, being
	the string really random looking, all the bits should be good
	to our goals */
	zhighbits(value, (long)bits, rnd);
a785 5
	bzero(randomstring, sizeof(randomstring));
	bzero(str, strlen(str));
	value = x = y = 0;
}
#endif
@


1.46
log
@safety
@
text
@d3 4
a6 4
 * $Header: /res/usr/vince/src/stel/RCS/sub.c,v 1.45 1995/03/24 11:25:37 vince Exp vince $
 * $Date: 1995/03/24 11:25:37 $
 * $Revision: 1.45 $
 * $Locker: vince $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: sub.c,v 1.45 1995/03/24 11:25:37 vince Exp vince $";
d28 1
d284 139
d541 1
a542 1
#if 0 /* already defined in skey package */
d613 90
d704 1
d789 1
@


1.45
log
@safety
@
text
@d3 4
a6 4
 * $Header: /res/usr/vince/src/stel/RCS/sub.c,v 1.44 1995/02/27 15:03:39 vince Exp $
 * $Date: 1995/02/27 15:03:39 $
 * $Revision: 1.44 $
 * $Locker:  $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: sub.c,v 1.44 1995/02/27 15:03:39 vince Exp $";
d58 2
a59 1
	if (setsockopt(s, SOL_SOCKET, SO_KEEPALIVE, &on, sizeof (on)) == -1) {
d65 2
a66 1
	if (setsockopt(s, SOL_SOCKET, SO_REUSEADDR, &on, sizeof (on)) == -1) {
d116 2
a117 1
	if (setsockopt(fd, SOL_SOCKET, SO_KEEPALIVE, &on, sizeof (on)) == -1) {
d166 1
a166 1
	if (connect(s, &sa, sizeof sa) == -1) {
d205 2
d210 26
d261 1
@


1.44
log
@safety
@
text
@d3 3
a5 3
 * $Header: /res/usr/vince/src/stel/RCS/sub.c,v 1.43 1995/02/27 11:11:52 vince Exp $
 * $Date: 1995/02/27 11:11:52 $
 * $Revision: 1.43 $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: sub.c,v 1.43 1995/02/27 11:11:52 vince Exp $";
d633 3
a635 5
	/* send halves in order. this is a modification of the original
	Rivest and Shamir idea. You see, both client and server write
	each halve at the same time in this way. But we have differently
	encrypted the cookie (double encryption has been performed by the
	server while single encryption by the client) so a replay attack
d638 5
a642 4
	if (logging)
		hexdump("writing AX1: ", firsthalve, 4);
	if (write_data(s, firsthalve, 4) != 4)
		return(-1);
d644 4
a647 4
	if (read_data(s, otherfirst, 4) != 4)
		return(-1);
	if (logging)
		hexdump("read AY1: ", otherfirst, 4);
d649 4
a652 4
	if (logging)
		hexdump("writing AX2: ", secondhalve, 4);
	if (write_data(s, secondhalve, 4) != 4)
		return(-1);
d654 13
a666 5
	if (read_data(s, othersecond, 4) != 4)
		return(-1);
	if (logging)  {
		hexdump("read AY2: ", othersecond, 4);
		hexdump("AY: ", othercookie, 8);
@


1.43
log
@safety
@
text
@d3 4
a6 4
 * $Header: /res/usr/vince/src/stel/RCS/sub.c,v 1.39 1995/02/25 15:26:39 vince Exp vince $
 * $Date: 1995/02/25 15:26:39 $
 * $Revision: 1.39 $
 * $Locker: vince $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: sub.c,v 1.39 1995/02/25 15:26:39 vince Exp vince $";
d256 1
a256 1
	int		i, j, len, modulobits;
a257 1
	long		seed;
d272 2
a273 1
	if (rndstr)
d275 1
d307 1
a307 1
	if ((len = read_data(s, exchange, sizeof(exchange))) !=sizeof(exchange))
d500 2
a501 1
		printf("skipping... (%d bytes in all)\n", sizeof(randomstring));
d541 1
a541 1
		(void)sprintf(tmp, "%s %s %s %s %s ",
d549 1
a549 1
	(void)sprintf(tmp, "%s %ld ", ctime(&t), t);
d553 2
a554 1
	(void)sprintf(tmp, "%d %d %d ", getpid(), getpgrp(), getppid());
d559 1
a559 1
		(void)sprintf(tmp, "%ld %ld %ld ",
d564 1
a564 1
		(void)sprintf(tmp, "%ld %ld %ld ",
d569 1
a569 1
		(void)sprintf(tmp, "%ld %ld %ld ",
d576 1
@


1.42
log
@safety
@
text
@d278 2
a279 1
	mkrnd(randbuf, &mysecret, modulobits - 1);
d287 1
a287 1
		printf("x (client random secret key):\n");
d447 1
a447 1
mkrnd(str, rnd, bits)
d450 1
a450 1
int		bits;
d471 5
d493 8
@


1.41
log
@safety
@
text
@d286 1
a286 1
		printf("x (client secret key):\n");
@


1.40
log
@safety
@
text
@d282 1
a282 1
		printf("Exchanging keys with DH scheme (can be a lengthy process)...\n");
d286 1
a286 1
		printf("Client secret key:\n");
d297 1
a297 1
		printf("Client public key:\n");
d311 1
a311 1
		printf("Server public key:\n");
d318 1
a318 1
		printf("Shared secret:\n");
d358 4
a361 2
	if (side == CLIENT_SIDE && firstack & FLG_BE_VERBOSE) {
		int	keylen;
a362 13
		keylen = ((firstack & FLG_USE_IDEA) ||
			  (firstack & FLG_USE_TRIPLE) ? 16 : 8);

		printf("Shared encryption key: ");
		fflush(stdout);

		for (i = 0; i < keylen; i++)
			printf("%02X", mdContext.digest[i]);

		printf("\n");
		fflush(stdout);
	}

d574 3
a582 7
	if (side == CLIENT_SIDE && firstack & FLG_DEBUG) {
		printf("Digest of ~/.stelsecret: \n");
		for (i = 0; i < 16; i++)
			printf("%02X", mdContext.digest[i]);
		(void)fflush(stdout);
	}

d598 8
a605 5
	if (side == CLIENT_SIDE && firstack & FLG_DEBUG) {
		printf("Authenticating cookie: \n");
		for (i = 0; i < 8; i++)
			printf("%02X", cookie[i]);
		(void)fflush(stdout);
d622 2
a623 6
	if (side == CLIENT_SIDE && firstack & FLG_DEBUG) {
		printf("Writing first halve: ");
		for (i = 0; i < 4; i++)
			printf("%02X", firsthalve[i]);
		(void)fflush(stdout);
	}
a626 1

d629 2
a630 6
	if (side == CLIENT_SIDE && firstack & FLG_DEBUG) {
		printf("Read server's first halve: ");
		for (i = 0; i < 4; i++)
			printf("%02X", otherfirst[i]);
		(void)fflush(stdout);
	}
d632 2
a633 6
	if (side == CLIENT_SIDE && firstack & FLG_DEBUG) {
		printf("Writing second halve: ");
		for (i = 0; i < 4; i++)
			printf("%02X", secondhalve[i]);
		(void)fflush(stdout);
	}
d639 3
a641 5
	if (side == CLIENT_SIDE && firstack & FLG_DEBUG) {
		printf("Read server's second halve: ");
		for (i = 0; i < 4; i++)
			printf("%02X", othersecond[i]);
		(void)fflush(stdout);
d651 10
a660 1
	if (memcmp(cookie, othercookie, 8))
d662 4
d668 14
@


1.39
log
@safety
@
text
@d3 4
a6 4
 * $Header: /res/usr/vince/src/stel/RCS/sub.c,v 1.38 1995/02/23 17:14:54 vince Exp $
 * $Date: 1995/02/23 17:14:54 $
 * $Revision: 1.38 $
 * $Locker:  $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: sub.c,v 1.38 1995/02/23 17:14:54 vince Exp $";
d576 2
a577 2
mauth(s, authbuf, side)
int	s, side;
d584 1
d591 11
d613 7
d633 7
d642 2
d646 13
d661 1
d664 6
@


1.38
log
@safety
@
text
@d3 4
a6 4
 * $Header: /res/usr/vince/src/stel/RCS/sub.c,v 1.37 1995/02/23 15:49:43 vince Exp vince $
 * $Date: 1995/02/23 15:49:43 $
 * $Revision: 1.37 $
 * $Locker: vince $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: sub.c,v 1.37 1995/02/23 15:49:43 vince Exp vince $";
d548 1
a548 2
	(void)sprintf(tmp, "%d %d %d %d ",
			getpid(), getpgrp(), getppid(), getpgrp2());
@


1.37
log
@safety
@
text
@d3 3
a5 3
 * $Header: /res/usr/vince/src/stel/RCS/sub.c,v 1.36 1995/02/23 13:45:13 vince Exp vince $
 * $Date: 1995/02/23 13:45:13 $
 * $Revision: 1.36 $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: sub.c,v 1.36 1995/02/23 13:45:13 vince Exp vince $";
d331 1
a331 1
	auth step we hash(session key), in order to be safer to keep 
@


1.36
log
@safety
@
text
@d3 4
a6 4
 * $Header: /res/usr/vince/src/stel/RCS/sub.c,v 1.35 1995/02/21 20:50:15 vince Exp $
 * $Date: 1995/02/21 20:50:15 $
 * $Revision: 1.35 $
 * $Locker:  $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: sub.c,v 1.35 1995/02/21 20:50:15 vince Exp $";
d611 4
a614 3
	at the same time in this way. But we have differently encrypted
	the cookie (double encryption has been performed by the server)
	so a replay attack should be infeasible */
@


1.35
log
@safety
@
text
@d3 3
a5 3
 * $Header: /res/usr/vince/src/stel/RCS/sub.c,v 1.34 1995/02/20 13:33:59 vince Exp $
 * $Date: 1995/02/20 13:33:59 $
 * $Revision: 1.34 $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: sub.c,v 1.34 1995/02/20 13:33:59 vince Exp $";
d598 1
a598 1
	if (side == SERVER_SIDE)
d623 1
a623 1
	if (side == CLIENT_SIDE)
d626 1
a626 1
	else if (side == SERVER_SIDE)
@


1.34
log
@safety
@
text
@d3 4
a6 4
 * $Header: /res/usr/vince/src/stel/RCS/sub.c,v 1.33 1995/02/20 11:16:18 vince Exp vince $
 * $Date: 1995/02/20 11:16:18 $
 * $Revision: 1.33 $
 * $Locker: vince $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: sub.c,v 1.33 1995/02/20 11:16:18 vince Exp vince $";
d41 2
d259 1
d330 11
d575 59
@


1.33
log
@safety
@
text
@d3 3
a5 3
 * $Header: /res/usr/vince/src/stel/RCS/sub.c,v 1.31 1995/02/20 10:10:16 vince Exp vince $
 * $Date: 1995/02/20 10:10:16 $
 * $Revision: 1.31 $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: sub.c,v 1.31 1995/02/20 10:10:16 vince Exp vince $";
d282 1
a282 1
	if (side == CLIENT_SIDE && firstack & FLG_BE_VERBOSE) {
d293 1
a293 1
	if (side == CLIENT_SIDE && firstack & FLG_BE_VERBOSE) {
d307 1
a307 1
	if (side == CLIENT_SIDE && firstack & FLG_BE_VERBOSE) {
d314 1
a314 1
	if (side == CLIENT_SIDE && firstack & FLG_BE_VERBOSE) {
d319 2
a320 3
	/* convert shared secret to decimal string, digest the decimal
	   string, XOR the first halve of the string with the second
	   halve.  at the end we have distilled a session key */
d499 1
a499 1
	the string really random looking all the bits should be good
@


1.32
log
@safety
@
text
@d278 2
a279 2
		printf("My SECRET key: ");
		zwriteln(mysecret);
d283 2
a284 2
		printf("Using %d bits modulus\n", modulobits);
		printf("Exchanging keys with DH scheme (can be a lengthy process)...\n");
d294 1
a294 1
		printf("My PUBLIC key: ");
a304 3
#ifdef DEBUG
	printf("read other public key: %s\n", exchange);
#endif
d307 5
d314 4
a317 4
#ifdef DEBUG
	printf("shared secret:\n");
	zhwriteln(sharedsecret);
#endif
@


1.31
log
@safety
@
text
@d3 3
a5 3
 * $Header: /res/usr/vince/src/stel/RCS/sub.c,v 1.30 1995/02/17 14:50:11 vince Exp vince $
 * $Date: 1995/02/17 14:50:11 $
 * $Revision: 1.30 $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: sub.c,v 1.30 1995/02/17 14:50:11 vince Exp vince $";
d254 1
a254 1
	int		i, len, modulobits;
a272 4
	if (side == CLIENT_SIDE) {
		printf("random string: %s\n\n", randbuf);
	}

d277 4
a280 5

#ifdef DEBUG
	printf("my secret key:\n");
	zwriteln(mysecret);
#endif
d292 6
a297 3
#ifdef DEBUG
	printf("my public key: %s\n", exchange);
#endif
@


1.30
log
@safety
@
text
@d3 3
a5 3
 * $Header: /res/usr/vince/src/stel/RCS/sub.c,v 1.28 1995/02/16 18:56:47 vince Exp vince $
 * $Date: 1995/02/16 18:56:47 $
 * $Revision: 1.28 $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: sub.c,v 1.28 1995/02/16 18:56:47 vince Exp vince $";
d31 1
a31 1
#ifdef IDEA
a32 1
char			IV[8];
d34 2
a35 1
#else /* DES */
a37 1
#ifdef TRIPLE
d39 1
a39 3
#endif
des_cblock		IV;
#endif
a229 1
#if !defined(IDEA) && !defined(TRIPLE)
d231 1
a231 1
char	*modulostring = "\
d235 1
a235 1
#else
d237 1
a237 1
char *modulostring = "\
d243 1
a243 1
#endif
d245 2
a246 2
dhexchange(s, mode, vflg, rndstr) /* ``mode'' unused if IDEA undefined */
int	s, mode, vflg;
d261 4
a264 1
	zstrtozbas(modulostring, 16L, &modulo);
d273 1
a273 1
	if (!mode) {
d287 2
a288 1
	if (vflg) {
d328 16
a343 2
	/* the key is random, so we do not need a changing IV */
	bzero(IV, sizeof(IV));
d345 2
a346 13
#ifdef IDEA
	en_key_idea(mdContext.digest, Z);
	initcfb_idea((word16 *) IV, mdContext.digest, mode);
#else
#ifdef TRIPLE
	des_set_key((des_cblock *)mdContext.digest, schedule1);
	des_set_key((des_cblock *)mdContext.digest + 8, schedule2);
#else /* !TRIPLE */

	for (i = 0; i < 8; i++)
		/* xor halves together */
		mdContext.digest[i] ^= mdContext.digest[i + 8];
#endif
d348 2
a349 2
	des_set_key((des_cblock *)mdContext.digest, schedule1);
#endif
a350 2
/* #ifdef DEBUG */
	if (vflg) {
d353 2
a354 6
#if defined(IDEA) || defined(TRIPLE)
		for (i = 0; i < 16; i++)
#else
		for (i = 0; i < 8; i++)
#endif
					{
d356 1
a356 1
		}
a359 1
/* #endif */
d455 1
a455 1
	des_cblock	IV;
d478 1
a478 1
	bzero(IV, sizeof(IV));
d480 1
a480 1
		sizeof(randomstring), sched1, (des_cblock *)IV, DES_ENCRYPT);
d482 1
a482 1
		sizeof(randomstring), sched2, (des_cblock *)IV, DES_DECRYPT);
d484 1
a484 1
		sizeof(randomstring), sched1, (des_cblock *)IV, DES_ENCRYPT);
@


1.29
log
@safety
@
text
@d268 1
a268 1
	strncpy(randbuf, internalrnd());
d274 4
a281 2
	if (!mode)
		printf("random string: %s\n\n", randbuf);
d543 1
a543 1
	/* mod dates of often changing files */
@


1.28
log
@safety
@
text
@d3 3
a5 3
 * $Header: /res/usr/vince/src/stel/RCS/sub.c,v 1.27 1995/02/16 17:21:59 vince Exp vince $
 * $Date: 1995/02/16 17:21:59 $
 * $Revision: 1.27 $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: sub.c,v 1.27 1995/02/16 17:21:59 vince Exp vince $";
d278 3
d474 1
a474 1
	/* repeatly copy input's digest to randomstring */
d478 2
a479 1
	/* encrypt randomstring; triple des is better than single des */
d501 3
a503 3
	the best bits for cryptographic applications. Should I use
	the lowest bits instead? Or just pick up the bits in the middle?
	*/
d505 4
@


1.27
log
@safety
@
text
@d3 3
a5 3
 * $Header: /res/usr/vince/src/stel/RCS/sub.c,v 1.26 1995/02/16 15:42:44 vince Exp vince $
 * $Date: 1995/02/16 15:42:44 $
 * $Revision: 1.26 $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: sub.c,v 1.26 1995/02/16 15:42:44 vince Exp vince $";
d23 1
d257 1
a257 1
	unsigned char	*random;
d267 6
a272 6
	/* if true random string is not available than generate
	   one by using internal variables */
	if (rndstr == NULL) {
		random = internalrnd();
	else
		random = rndstr;
d276 1
a276 1
	mkrnd(random, &mysecret, modulobits - 1);
a282 1
/* #ifdef DEBUG */
a285 1
/* #endif */
d297 1
a297 1

a501 3

#include <sys/utsname.h>
#include <sys/stat.h>
@


1.26
log
@safety
@
text
@d3 3
a5 3
 * $Header: /res/usr/vince/src/stel/RCS/sub.c,v 1.25 1995/02/16 14:55:10 vince Exp vince $
 * $Date: 1995/02/16 14:55:10 $
 * $Revision: 1.25 $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: sub.c,v 1.25 1995/02/16 14:55:10 vince Exp vince $";
d269 1
a269 3
		if ((random = internalrnd()) == NULL)
			return(-1);	
	}
a271 3

	if (!mode)
		printf("USING: %s\n", random);
@


1.25
log
@safety
@
text
@d3 4
a6 4
 * $Header: /res/usr/vince/src/stel/RCS/sub.c,v 1.24 1995/02/15 15:49:15 vince Exp $
 * $Date: 1995/02/15 15:49:15 $
 * $Revision: 1.24 $
 * $Locker:  $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: sub.c,v 1.24 1995/02/15 15:49:15 vince Exp $";
d250 1
a250 1
char	*rndstr;
d255 2
a256 1
	char		pwstr[4096], exchange[4096], *random;
d261 1
a261 1
	char		*getrndstr();
a265 7
	/*
	seed = (long)time(NULL) + 17L * (long)getpid();
	zrstarts(seed);

	zrandomb(modulo, &mysecret);
	*/

d268 4
a271 2
	if (rndstr == NULL)
		random = getrndstr();
d274 1
a274 1
	
a306 3
	/*
	exchange[len] = '\0';
	*/
d509 5
a513 2
char *
getrndstr()
d515 6
a520 2
	FILE		*fp;
	static char	buf[4096];
d522 40
a561 4
	if ((fp = popen(RANDCOMMAND, "r")) == NULL) {
		perror("popen()");
		syslog(LOGPRI, "popen(): %m");
		return(NULL);
d563 1
a563 8

	if ((fgets(buf, sizeof(buf), fp)) == NULL) {
		syslog(LOGPRI, "fgets(): %m");
		return(NULL);
	}

	(void)fclose(fp);

@


1.24
log
@safety
@
text
@d3 4
a6 4
 * $Header: /res/usr/vince/src/stel/RCS/sub.c,v 1.23 1995/02/06 20:55:46 vince Exp vince $
 * $Date: 1995/02/06 20:55:46 $
 * $Revision: 1.23 $
 * $Locker: vince $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: sub.c,v 1.23 1995/02/06 20:55:46 vince Exp vince $";
d248 1
a248 1
dhexchange(s, mode, vflg) /* ``mode'' unused if IDEA undefined */
d250 1
d255 2
a256 2
	char		pwstr[4096], exchange[4096];
	int		i, len;
d260 2
d265 1
a265 4
	/* THIS IS WEAK. The zrandomb() should be substituted with
	   a stronger PRG function. Secret keys should be checked to
	   be not too close to 0 or modulo. Anyway, the chances that
	   it happens are quite negiglible */
d270 16
a292 2
		printf("Diffie-Hellman modulo is %d bits, secret exponent is %d bits\n",
					z2log(modulo), z2log(mysecret));
d447 89
@


1.23
log
@safety
@
text
@d3 4
a6 4
 * $Header: /res/usr/vince/src/stel/RCS/sub.c,v 1.22 1995/01/19 13:43:45 vince Exp $
 * $Date: 1995/01/19 13:43:45 $
 * $Revision: 1.22 $
 * $Locker:  $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: sub.c,v 1.22 1995/01/19 13:43:45 vince Exp $";
a324 1
#if 0
a340 1
#endif
a358 1
	/* wipe key from memory */
a359 6

	/*
	des_set_key((des_cblock *)mdContext.digest, schedule1);
	*/
	des_set_key((des_cblock *)pwstr, schedule1);
	printf("%d: %s\n", vflg, pwstr);
@


1.22
log
@safety
@
text
@d3 4
a6 4
 * $Header: /res/usr/vince/src/stel/RCS/sub.c,v 1.21 1995/01/19 12:46:07 vince Exp vince $
 * $Date: 1995/01/19 12:46:07 $
 * $Revision: 1.21 $
 * $Locker: vince $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: sub.c,v 1.21 1995/01/19 12:46:07 vince Exp vince $";
d57 1
a57 1
	
d62 1
d69 1
a69 1

d112 6
d257 1
a258 1

a261 1
	/* fix */
d265 4
a268 2
	   is happens are quite negiglible */
	zrstarts((long)time(NULL) + (long)getpid());
d285 2
d294 1
d297 1
d299 1
d316 1
d322 1
a322 1
	/* FIX: set IV with a random, non secret value */
d325 1
d334 3
a336 1
	for (i = 0; i < 8; i++) /* xor halves together */
d338 2
a360 1

d363 6
@


1.21
log
@safety
@
text
@d3 4
a6 4
 * $Header: /res/usr/vince/src/stel/RCS/sub.c,v 1.20 1994/12/28 12:18:20 vince Exp $
 * $Date: 1994/12/28 12:18:20 $
 * $Revision: 1.20 $
 * $Locker:  $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: sub.c,v 1.20 1994/12/28 12:18:20 vince Exp $";
d62 1
d67 1
@


1.20
log
@safety
@
text
@d3 3
a5 3
 * $Header: /res/usr/vince/src/stel/RCS/sub.c,v 1.19 1994/12/18 14:44:44 vince Exp $
 * $Date: 1994/12/18 14:44:44 $
 * $Revision: 1.19 $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: sub.c,v 1.19 1994/12/18 14:44:44 vince Exp $";
a42 1
#ifdef STANDALONE
a86 1
	extern char		*inet_ntoa();
d95 1
a95 1
		(void)strcpy(hostname, inet_ntoa(sa.sin_addr));
d100 1
a100 1
#else /* !STANDALONE */
d111 1
a111 1
		perror("getpeername()"); /* so easy */
a121 2
#endif /* STANDALONE */

d394 23
@


1.19
log
@safety
@
text
@d3 4
a6 4
 * $Header: /res/usr/vince/src/stel/RCS/sub.c,v 1.18 1994/11/30 08:15:06 vince Exp vince $
 * $Date: 1994/11/30 08:15:06 $
 * $Revision: 1.18 $
 * $Locker: vince $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: sub.c,v 1.18 1994/11/30 08:15:06 vince Exp vince $";
d37 1
d39 1
d227 8
a234 4
/* 512 bits */
char	*modulostring = "D7EE241E121D4993D8FF64313C1B57F0388243704B98F9FABC7EFC1FA36803B88337E7220693839293974DD183990A5AA6FD5FCE0CC3DDED2CE73933B270CFA7";
/* 1024 bits */
/*
d241 1
a241 1
*/
d257 5
a261 3
	/* This is very weak. The zrandomb() should be substituted with
	   a stronger PRG function. Secret keys should be checked to be
	   not too close to 0 or modulo. */
d270 2
a271 3
	if (vflg)
		(void)fprintf(stderr,
		"DH modulo is %d bits; secret exponent is %d bits\n",
d273 2
d296 1
a309 13
/* #ifdef DEBUG */
	if (vflg) {
		(void)fprintf(stderr, "Encryption key: ");
		(void)fflush(stderr);
		for (i = 0; i < 16; i++) {
			(void)fprintf(stderr, "%02X", mdContext.digest[i]);
			(void)fflush(stderr);
		}
		(void)fprintf(stderr, "\n");
		(void)fflush(stderr);
	}
/* #endif */

d317 18
a334 2
	des_set_key(mdContext.digest, &schedule1);
	des_set_key(mdContext.digest + 8, &schedule2);
d336 8
@


1.18
log
@safety
@
text
@d3 3
a5 3
 * $Header: /res/usr/vince/src/stel/RCS/sub.c,v 1.17 1994/11/28 18:26:12 vince Exp vince $
 * $Date: 1994/11/28 18:26:12 $
 * $Revision: 1.17 $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: sub.c,v 1.17 1994/11/28 18:26:12 vince Exp vince $";
d97 1
a97 1
		(void)strncpy(hostname, he->h_name, MAXHOSTNAMELEN);
d107 1
a107 1
	static char		name[MAXHOSTNAMELEN];
d330 1
d376 1
@


1.17
log
@safety
@
text
@d3 4
a6 4
 * $Header: /res/usr/vince/src/dh/RCS/sub.c,v 1.16 1994/11/26 15:06:48 vince Exp $
 * $Date: 1994/11/26 15:06:48 $
 * $Revision: 1.16 $
 * $Locker:  $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: sub.c,v 1.16 1994/11/26 15:06:48 vince Exp $";
d167 1
a167 1
#ifdef hpux
@


1.16
log
@safety
@
text
@d3 3
a5 3
 * $Header: /res/usr/vince/src/dh/RCS/sub.c,v 1.15 1994/11/26 11:26:15 vince Exp $
 * $Date: 1994/11/26 11:26:15 $
 * $Revision: 1.15 $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: sub.c,v 1.15 1994/11/26 11:26:15 vince Exp $";
d237 2
a238 2
dhexchange(s, mode) /* ``mode'' unused if IDEA undefined */
int	s, mode;
d261 4
a264 2
#ifdef DEBUG
	printf("DH modulo is %d bits; secret exponent is %d bits\n",
d266 1
a266 1
#endif
d300 10
a309 6
#ifdef DEBUG
	printf("DES key: ");
	(void)fflush(stdout);
	for (i = 0; i < 16; i++) {
		printf("%02X", mdContext.digest[i]);
		(void)fflush(stdout);
d311 1
a311 3
	printf("\n");
	(void)fflush(stdout);
#endif
@


1.15
log
@safety
@
text
@d3 4
a6 4
 * $Header: /res/usr/vince/src/dh/RCS/sub.c,v 1.14 1994/10/26 10:11:39 vince Exp vince $
 * $Date: 1994/10/26 10:11:39 $
 * $Revision: 1.14 $
 * $Locker: vince $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: sub.c,v 1.14 1994/10/26 10:11:39 vince Exp vince $";
d67 1
d178 1
a178 1
#ifdef _IRIX
d194 1
a194 1
#else /* !_IRIX */
d223 1
a223 1
#endif /* !_IRIX */
@


1.14
log
@safety
@
text
@d3 4
a6 4
 * $Header: /res/usr/vince/src/dh/RCS/sub.c,v 1.13 1994/10/25 16:45:52 vince Exp $
 * $Date: 1994/10/25 16:45:52 $
 * $Revision: 1.13 $
 * $Locker:  $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: sub.c,v 1.13 1994/10/25 16:45:52 vince Exp $";
d14 1
d177 1
d181 16
d210 1
a210 1
                        break;
d213 1
a213 1
                        p = open(line, 2);
d222 1
d237 1
a237 1
int	s;
@


1.13
log
@safety
@
text
@d3 3
a5 3
 * $Header: /res/usr/vince/src/dh/RCS/sub.c,v 1.12 1994/10/25 15:09:38 vince Exp $
 * $Date: 1994/10/25 15:09:38 $
 * $Revision: 1.12 $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: sub.c,v 1.12 1994/10/25 15:09:38 vince Exp $";
d51 2
a52 1
	if ((s = socket(AF_INET, SOCK_STREAM, 0)) == -1)
d54 1
d56 2
a57 4
	if (setsockopt(s, SOL_SOCKET, SO_KEEPALIVE,
					(char *)&on, sizeof (on)) == -1 ||
	    setsockopt(s, SOL_SOCKET, SO_REUSEADDR,
					(char *)&on, sizeof (on)) == -1)
d59 5
d65 2
a66 1
	if (bind(s, &sa, sizeof(sa)) == -1)
d68 1
d70 4
a73 1
	(void)listen(s, 10);
d87 1
a87 1
	if ((t = accept(s, &sa, &salen)) < 0)
d89 1
d109 2
a110 2
		perror("getpeername()");
		syslog(LOGPRIORITY, "getpeername() failed");
@


1.12
log
@safety
@
text
@d3 3
a5 3
 * $Header: /res/usr/vince/src/dh/RCS/sub.c,v 1.11 1994/10/25 15:05:42 vince Exp $
 * $Date: 1994/10/25 15:05:42 $
 * $Revision: 1.11 $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: sub.c,v 1.11 1994/10/25 15:05:42 vince Exp $";
d98 1
d124 1
a124 1
			herror(hostname);
d133 1
a133 1
	if ((s = socket(hp->h_addrtype, SOCK_STREAM, 0)) < 0) {
@


1.11
log
@safety
@
text
@d3 3
a5 3
 * $Header: /res/usr/vince/src/dh/RCS/sub.c,v 1.10 1994/10/25 14:43:04 vince Exp $
 * $Date: 1994/10/25 14:43:04 $
 * $Revision: 1.10 $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: sub.c,v 1.10 1994/10/25 14:43:04 vince Exp $";
d210 1
a210 1
	verylong	hissecret = 0, hispublic = 0;
@


1.10
log
@safety
@
text
@d3 4
a6 4
 * $Header: /res/usr/vince/src/dh/RCS/sub.c,v 1.9 1994/10/25 12:59:40 vince Exp vince $
 * $Date: 1994/10/25 12:59:40 $
 * $Revision: 1.9 $
 * $Locker: vince $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: sub.c,v 1.9 1994/10/25 12:59:40 vince Exp vince $";
d84 1
a84 1
		(void)strcpy(hostname, he->h_name);
d94 1
a94 1
	static char		name[128];
@


1.9
log
@safety
@
text
@d3 4
a6 4
 * $Header: /res/usr/vince/src/dh/RCS/sub.c,v 1.8 1994/10/24 18:17:21 vince Exp $
 * $Date: 1994/10/24 18:17:21 $
 * $Revision: 1.8 $
 * $Locker:  $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: sub.c,v 1.8 1994/10/24 18:17:21 vince Exp $";
d22 1
d27 2
d40 1
d67 44
a161 21
}

getconnection(s, hostname)
int	s;
char	*hostname;
{
	struct sockaddr_in	sa;
	struct hostent		*he;
	int			t, salen;
	extern char		*inet_ntoa();

	salen = sizeof(sa);
	if ((t = accept(s, &sa, &salen)) < 0)
		return(-1);
	
	if ((he = gethostbyaddr((char *)&sa.sin_addr,
				sizeof(struct in_addr), AF_INET)) == NULL)
		(void)strcpy(hostname, inet_ntoa(sa.sin_addr));
	else
		(void)strcpy(hostname, he->h_name);
	return(t);
@


1.8
log
@safety
@
text
@d3 4
a6 4
 * $Header: /res/usr/vince/src/dh/RCS/sub.c,v 1.7 1994/08/17 11:20:32 vince Exp vince $
 * $Date: 1994/08/17 11:20:32 $
 * $Revision: 1.7 $
 * $Locker: vince $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: sub.c,v 1.7 1994/08/17 11:20:32 vince Exp vince $";
d72 1
d74 4
a77 2
		errno = ECONNREFUSED;
		return(-1);
d79 3
a81 4

	bzero(&sa, sizeof(sa));
	(void)memcpy((char *) &sa.sin_addr, hp->h_addr, hp->h_length);
	sa.sin_family = hp->h_addrtype;
d84 2
a85 1
	if ((s = socket(hp->h_addrtype, SOCK_STREAM, 0)) < 0)
d87 1
d89 2
a90 1
							sizeof(on)) == -1)
d92 1
d94 2
a95 1
	if (connect(s, &sa, sizeof sa) < 0)
d97 1
d166 1
d168 1
@


1.7
log
@safety
@
text
@d3 3
a5 3
 * $Header: /res/usr/vince/src/dh/RCS/sub.c,v 1.6 1994/06/13 22:36:31 vince Exp vince $
 * $Date: 1994/06/13 22:36:31 $
 * $Revision: 1.6 $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: sub.c,v 1.6 1994/06/13 22:36:31 vince Exp vince $";
d203 1
a203 1
	if (write(s, exchange, strlen(exchange)) == -1)
d206 1
a206 1
	if ((len = read(s, exchange, sizeof(exchange))) == -1)
d255 46
@


1.6
log
@safety
@
text
@d3 3
a5 3
 * $Header: /res/usr/vince/src/dh/RCS/sub.c,v 1.5 1994/06/13 16:44:05 vince Exp vince $
 * $Date: 1994/06/13 16:44:05 $
 * $Revision: 1.5 $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: sub.c,v 1.5 1994/06/13 16:44:05 vince Exp vince $";
d25 6
a31 1

d35 1
d168 1
a168 1
dhexchange(s)
d240 7
d249 1
a249 3

	/* FIX: set IV */
	bzero(IV, sizeof(IV));
@


1.5
log
@safety
@
text
@d3 3
a5 3
 * $Header: /res/usr/vince/src/dh/RCS/sub.c,v 1.4 1994/06/13 00:04:42 vince Exp vince $
 * $Date: 1994/06/13 00:04:42 $
 * $Revision: 1.4 $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: sub.c,v 1.4 1994/06/13 00:04:42 vince Exp vince $";
d27 3
a29 2
des_key_schedule schedule1;
des_key_schedule schedule2;
d186 1
a186 1
/* #ifdef DEBUG */
d189 1
a189 1
/* #endif */
d223 1
a223 1
/* #ifdef DEBUG */
d232 1
a232 1
/* #endif */
d236 3
@


1.4
log
@safety
@
text
@d3 3
a5 3
 * $Header: /res/usr/vince/src/dh/RCS/sub.c,v 1.3 1994/06/12 21:55:31 vince Exp vince $
 * $Date: 1994/06/12 21:55:31 $
 * $Revision: 1.3 $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: sub.c,v 1.3 1994/06/12 21:55:31 vince Exp vince $";
d27 2
a28 1
des_key_schedule schedule;
a167 1
	unsigned char	sessionkey[8];
d185 5
d222 16
a237 3
	for (i = 0; i < 8; i++)
		sessionkey[i] = mdContext.digest[i] ^ mdContext.digest[i + 8];
	des_set_key(sessionkey, &schedule);
@


1.3
log
@safety
@
text
@d3 3
a5 3
 * $Header: /res/usr/vince/src/dh/RCS/sub.c,v 1.2 1994/06/06 16:27:39 vince Exp vince $
 * $Date: 1994/06/06 16:27:39 $
 * $Revision: 1.2 $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: sub.c,v 1.2 1994/06/06 16:27:39 vince Exp vince $";
d25 1
d27 2
d151 8
d163 3
a165 2
	verylong	modulo, three, sharedsecret;
	verylong	mysecret, mypublic, hissecret, hispublic;
d168 1
a168 1
	int		i;
d180 1
d183 1
d187 2
d190 1
a190 1
	zswrite(exchange, mypublic);
d194 1
a194 1
	if (read(s, exchange, strlen(exchange)) == -1)
d196 3
d200 1
d204 1
d207 1
a212 1
	printf("pwd: %s\n", pwstr);
d216 2
a217 2
	printf("PASSWORD: ");
	for (i = 0; i < 8; i++) {
d219 2
a220 4
		printf("%x", sessionkey[i]);
	}
	(void)fflush(stdout);
	printf("\n");
@


1.2
log
@safety
@
text
@d3 3
a5 3
 * $Header: /res/usr/vince/src/dh/RCS/sub.c,v 1.1 1994/06/06 15:23:00 vince Exp vince $
 * $Date: 1994/06/06 15:23:00 $
 * $Revision: 1.1 $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: sub.c,v 1.1 1994/06/06 15:23:00 vince Exp vince $";
d23 3
a65 1
	/*
a66 1
	*/
d145 58
@


1.1
log
@safety
@
text
@d2 5
a6 5
 * $Author:$
 * $Header:$
 * $Date:$
 * $Revision:$
 * $Locker:$
d10 1
a10 1
static char *rcsid = "@@(#) $Id:$";
d21 1
d115 29
@
