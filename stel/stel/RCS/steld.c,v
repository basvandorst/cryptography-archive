head	1.107;
access;
symbols;
locks
	vince:1.107; strict;
comment	@ * @;


1.107
date	96.04.26.16.29.23;	author vince;	state Exp;
branches;
next	1.106;

1.106
date	96.04.03.08.40.32;	author vince;	state Exp;
branches;
next	1.105;

1.105
date	96.03.30.14.58.08;	author vince;	state Exp;
branches;
next	1.104;

1.104
date	96.01.03.18.20.26;	author vince;	state Exp;
branches;
next	1.103;

1.103
date	96.01.02.16.41.03;	author vince;	state Exp;
branches;
next	1.102;

1.102
date	95.12.21.18.00.21;	author vince;	state Exp;
branches;
next	1.101;

1.101
date	95.12.21.10.58.55;	author vince;	state Exp;
branches;
next	1.100;

1.100
date	95.12.20.18.33.49;	author vince;	state Exp;
branches;
next	1.99;

1.99
date	95.12.16.15.48.11;	author vince;	state Exp;
branches;
next	1.98;

1.98
date	95.12.15.16.36.17;	author vince;	state Exp;
branches;
next	1.97;

1.97
date	95.12.14.10.36.13;	author vince;	state Exp;
branches;
next	1.96;

1.96
date	95.12.08.14.38.55;	author vince;	state Exp;
branches;
next	1.95;

1.95
date	95.12.04.16.36.21;	author vince;	state Exp;
branches;
next	1.94;

1.94
date	95.11.29.13.18.46;	author vince;	state Exp;
branches;
next	1.93;

1.93
date	95.11.25.16.53.41;	author vince;	state Exp;
branches;
next	1.92;

1.92
date	95.11.24.14.04.05;	author vince;	state Exp;
branches;
next	1.91;

1.91
date	95.11.24.12.26.47;	author vince;	state Exp;
branches;
next	1.90;

1.90
date	95.11.21.09.56.21;	author vince;	state Exp;
branches;
next	1.89;

1.89
date	95.08.26.12.01.03;	author vince;	state Exp;
branches;
next	1.88;

1.88
date	95.08.26.09.47.35;	author vince;	state Exp;
branches;
next	1.87;

1.87
date	95.08.25.15.58.26;	author vince;	state Exp;
branches;
next	1.86;

1.86
date	95.08.25.14.06.17;	author vince;	state Exp;
branches;
next	1.85;

1.85
date	95.08.25.10.59.54;	author vince;	state Exp;
branches;
next	1.84;

1.84
date	95.08.23.19.12.23;	author vince;	state Exp;
branches;
next	1.83;

1.83
date	95.08.23.15.05.54;	author vince;	state Exp;
branches;
next	1.82;

1.82
date	95.08.23.11.16.54;	author vince;	state Exp;
branches;
next	1.81;

1.81
date	95.08.15.18.47.12;	author vince;	state Exp;
branches;
next	1.80;

1.80
date	95.07.29.19.52.54;	author vince;	state Exp;
branches;
next	1.79;

1.79
date	95.07.20.06.02.10;	author vince;	state Exp;
branches;
next	1.78;

1.78
date	95.07.19.18.58.54;	author vince;	state Exp;
branches;
next	1.77;

1.77
date	95.07.14.16.06.22;	author vince;	state Exp;
branches;
next	1.76;

1.76
date	95.07.14.13.31.29;	author vince;	state Exp;
branches;
next	1.75;

1.75
date	95.07.14.11.36.25;	author vince;	state Exp;
branches;
next	1.74;

1.74
date	95.07.13.17.35.49;	author vince;	state Exp;
branches;
next	1.73;

1.73
date	95.07.13.11.03.57;	author vince;	state Exp;
branches;
next	1.72;

1.72
date	95.07.12.16.44.00;	author vince;	state Exp;
branches;
next	1.71;

1.71
date	95.07.08.15.48.56;	author vince;	state Exp;
branches;
next	1.70;

1.70
date	95.05.10.18.00.18;	author vince;	state Exp;
branches;
next	1.69;

1.69
date	95.05.10.15.10.14;	author vince;	state Exp;
branches;
next	1.68;

1.68
date	95.05.06.15.39.00;	author vince;	state Exp;
branches;
next	1.67;

1.67
date	95.04.22.11.13.50;	author vince;	state Exp;
branches;
next	1.66;

1.66
date	95.04.22.09.42.58;	author vince;	state Exp;
branches;
next	1.65;

1.65
date	95.04.21.19.17.40;	author vince;	state Exp;
branches;
next	1.64;

1.64
date	95.04.21.18.27.26;	author vince;	state Exp;
branches;
next	1.63;

1.63
date	95.04.08.15.48.43;	author vince;	state Exp;
branches;
next	1.62;

1.62
date	95.04.08.14.38.50;	author vince;	state Exp;
branches;
next	1.61;

1.61
date	95.04.08.11.18.38;	author vince;	state Exp;
branches;
next	1.60;

1.60
date	95.04.05.16.35.14;	author vince;	state Exp;
branches;
next	1.59;

1.59
date	95.03.31.19.34.43;	author vince;	state Exp;
branches;
next	1.58;

1.58
date	95.02.27.15.05.32;	author vince;	state Exp;
branches;
next	1.57;

1.57
date	95.02.27.15.03.39;	author vince;	state Exp;
branches;
next	1.56;

1.56
date	95.02.27.11.43.39;	author vince;	state Exp;
branches;
next	1.55;

1.55
date	95.02.27.11.42.10;	author vince;	state Exp;
branches;
next	1.54;

1.54
date	95.02.27.10.46.19;	author vince;	state Exp;
branches;
next	1.53;

1.53
date	95.02.25.15.26.39;	author vince;	state Exp;
branches;
next	1.52;

1.52
date	95.02.23.17.14.54;	author vince;	state Exp;
branches;
next	1.51;

1.51
date	95.02.23.15.49.43;	author vince;	state Exp;
branches;
next	1.50;

1.50
date	95.02.21.20.50.15;	author vince;	state Exp;
branches;
next	1.49;

1.49
date	95.02.21.17.34.49;	author vince;	state Exp;
branches;
next	1.48;

1.48
date	95.02.20.13.43.47;	author vince;	state Exp;
branches;
next	1.47;

1.47
date	95.02.20.13.33.59;	author vince;	state Exp;
branches;
next	1.46;

1.46
date	95.02.20.10.10.16;	author vince;	state Exp;
branches;
next	1.45;

1.45
date	95.02.16.14.55.10;	author vince;	state Exp;
branches;
next	1.44;

1.44
date	95.02.15.16.53.25;	author vince;	state Exp;
branches;
next	1.43;

1.43
date	95.02.15.15.51.15;	author vince;	state Exp;
branches;
next	1.42;

1.42
date	95.02.15.15.49.15;	author vince;	state Exp;
branches;
next	1.41;

1.41
date	95.02.06.20.55.46;	author vince;	state Exp;
branches;
next	1.40;

1.40
date	95.01.24.15.55.43;	author vince;	state Exp;
branches;
next	1.39;

1.39
date	95.01.24.10.05.30;	author vince;	state Exp;
branches;
next	1.38;

1.38
date	95.01.24.10.04.40;	author vince;	state Exp;
branches;
next	1.37;

1.37
date	95.01.21.16.35.47;	author vince;	state Exp;
branches;
next	1.36;

1.36
date	95.01.21.15.05.14;	author vince;	state Exp;
branches;
next	1.35;

1.35
date	95.01.21.14.25.24;	author vince;	state Exp;
branches;
next	1.34;

1.34
date	95.01.19.12.46.07;	author vince;	state Exp;
branches;
next	1.33;

1.33
date	95.01.18.16.15.56;	author vince;	state Exp;
branches;
next	1.32;

1.32
date	95.01.03.11.57.27;	author vince;	state Exp;
branches;
next	1.31;

1.31
date	95.01.02.18.32.39;	author vince;	state Exp;
branches;
next	1.30;

1.30
date	94.12.30.11.23.59;	author vince;	state Exp;
branches;
next	1.29;

1.29
date	94.12.30.11.22.35;	author vince;	state Exp;
branches;
next	1.28;

1.28
date	94.12.29.17.47.18;	author vince;	state Exp;
branches;
next	1.27;

1.27
date	94.12.29.17.13.37;	author vince;	state Exp;
branches;
next	1.26;

1.26
date	94.12.28.12.18.20;	author vince;	state Exp;
branches;
next	1.25;

1.25
date	94.12.27.18.49.13;	author vince;	state Exp;
branches;
next	1.24;

1.24
date	94.12.27.18.21.04;	author vince;	state Exp;
branches;
next	1.23;

1.23
date	94.12.18.15.06.41;	author vince;	state Exp;
branches;
next	1.22;

1.22
date	94.12.18.14.44.44;	author vince;	state Exp;
branches;
next	1.21;

1.21
date	94.11.30.08.15.06;	author vince;	state Exp;
branches;
next	1.20;

1.20
date	94.11.28.18.26.12;	author vince;	state Exp;
branches;
next	1.19;

1.19
date	94.11.26.16.20.03;	author vince;	state Exp;
branches;
next	1.18;

1.18
date	94.11.26.15.55.48;	author vince;	state Exp;
branches;
next	1.17;

1.17
date	94.11.26.15.06.48;	author vince;	state Exp;
branches;
next	1.16;

1.16
date	94.11.26.13.15.59;	author vince;	state Exp;
branches;
next	1.15;

1.15
date	94.11.26.11.26.15;	author vince;	state Exp;
branches;
next	1.14;

1.14
date	94.10.26.10.11.39;	author vince;	state Exp;
branches;
next	1.13;

1.13
date	94.10.25.15.52.11;	author vince;	state Exp;
branches;
next	1.12;

1.12
date	94.10.25.15.09.38;	author vince;	state Exp;
branches;
next	1.11;

1.11
date	94.10.25.15.05.42;	author vince;	state Exp;
branches;
next	1.10;

1.10
date	94.10.25.14.43.04;	author vince;	state Exp;
branches;
next	1.9;

1.9
date	94.10.25.12.59.40;	author vince;	state Exp;
branches;
next	1.8;

1.8
date	94.10.24.20.19.34;	author vince;	state Exp;
branches;
next	1.7;

1.7
date	94.10.24.18.17.21;	author vince;	state Exp;
branches;
next	1.6;

1.6
date	94.08.17.11.20.32;	author vince;	state Exp;
branches;
next	1.5;

1.5
date	94.06.13.22.36.31;	author vince;	state Exp;
branches;
next	1.4;

1.4
date	94.06.13.16.44.05;	author vince;	state Exp;
branches;
next	1.3;

1.3
date	94.06.13.00.04.42;	author vince;	state Exp;
branches;
next	1.2;

1.2
date	94.06.12.21.55.31;	author vince;	state Exp;
branches;
next	1.1;

1.1
date	94.06.06.16.28.00;	author vince;	state Exp;
branches;
next	;


desc
@@


1.107
log
@safety
@
text
@/*
 * $Author: vince $
 * $Header: /users/vince/src/stel/RCS/steld.c,v 1.106 1996/04/03 08:40:32 vince Exp vince $
 * $Date: 1996/04/03 08:40:32 $
 * $Revision: 1.106 $
 * $Locker: vince $
 */

#ifndef	lint
static char *rcsid = "@@(#) $Id: steld.c,v 1.106 1996/04/03 08:40:32 vince Exp vince $";
#endif	lint

#include <stdio.h>
#include <termios.h>
#include <errno.h>
#include <signal.h>
#include <fcntl.h>
#include <pwd.h>
#include <syslog.h>
#include <sys/stat.h>
#include <netinet/in.h>
#ifdef SUNOS4
#include <sys/types.h>
#include <sys/label.h>
#include <sys/audit.h>
#include <pwdadj.h>
#include <utmp.h>
#endif

#ifdef HAS_SYS_PARAM_H
#include <sys/param.h>
#endif

#ifdef AIX
#include <sys/ioctl.h>
#include <sys/id.h>
#include <sys/priv.h>
#endif

#ifdef SOLARIS
#include <sys/stropts.h>
#include <shadow.h>
#endif

/* md5 stuff */
#include "global.h"
#include "md5.h"

#include "skey.h"
#include "defs.h"

#include "sys_defs.h"

#define DEFAULT_PATH	"/bin:/usr/bin:/usr/ucb"

#if defined (SUNOS4) || defined (SOLARIS)
#define ERASECHAR	(0x7f)
#define KILLCHAR	('u' & 0x1f)
#else
#define ERASECHAR	('h' & 0x1f)
#define KILLCHAR	('x' & 0x1f)
#endif

/* idea stuff */
#include "idea.h"
extern IDEAkey		c_ideakey;	/* client */

/* des stuff */
/* #include "des.h" */
extern des_key_schedule	c_schedule1;	/* client */
extern des_key_schedule	c_schedule2;	/* client */
extern des_key_schedule	c_schedule3;	/* client */

/* IVs */
extern des_cblock	s_IV, c_IV;

extern char		sessionkeyhash[];

void	fireman();
void	runshell();

static username[MAXUSERNAMELEN];
static fromhost[MAXHNAMELEN];

main(argc, argv)
int	argc;
char	*argv[];
{
	int		s, fh;
	int		i, kflg, portnum;
	int		timeout;
	extern char	*optarg;
	char		*p, *peername();

#ifdef __ultrix
	(void)openlog(STELSERVER, LOG_WARNING);
#else
	(void)openlog(STELSERVER, LOG_PID | LOG_ODELAY, LOG_DAEMON);
#endif

	kflg = 0;
	portnum = 0;
	timeout = IDLETIMEOUT;
	while ((i = getopt(argc, argv, "kp:t:")) != EOF)
		switch (i) {
			/* do not kill IP-OPTIONS (killed by default) */
			case	'k':
				kflg++;
				break;
			case	'p':
				portnum = atoi(optarg);
				break;
			case	't':
				timeout = atoi(optarg);
				break;
			case	':':
			case	'?':
				syslog(LOGPRI, "bad options, exiting");
				exit(1);
				break;
		}

	if ((p = peername(0)) != NULL) { /* run by inetd */
		if (portnum) 
			syslog(LOGPRI, "run by inetd, -p option ignored");
		strncpy(fromhost, p, sizeof(fromhost));
		syslog(LOGPRI, "incoming connection from %s", fromhost);

		if (!kflg) {
#ifndef NO_IP_PROTO
			/* kill IP_PROTO options */
			if (killoptions(0, fromhost)) {
				/* can't kill IP_OPTIONS */
				(void)shutdown(0, 2);
				(void)close(0);
				exit(1);
			}
#endif
		}

		(void)serveclient(0, timeout);
		syslog(LOGPRI, "end of connection from %s", fromhost);
		(void)shutdown(0, 2);
		(void)close(0);
		exit(0);
	}

#ifndef DEBUG
	detachfrompty();
#endif /* DEBUG */

	if (portnum == 0)
		portnum = PORTNUM;
	if ((s = establish(portnum)) == -1)
		exit(1);

	(void)signal(SIGCLD, fireman);

	printf("server[%d], id = %d, starting on port %d\n",
					getpid(), VERSION, portnum);
	syslog(LOGPRI, "server[%d], id = %d, started on port %d",
					getpid(), VERSION, portnum);

	for (; ; ) {
		if ((fh = getconnection(s, fromhost)) < 0) {
			if (errno == EINTR) /* child died */
				continue;
			syslog(LOGPRI, "accept(): %m");
			exit(1);
		}

		syslog(LOGPRI, "connection from %s", fromhost);

		if (!kflg) {
#ifndef linux
		/* kill IP_PROTO options */
			if (killoptions(fh, fromhost)) {
				/* can't kill IP_OPTIONS */
				(void)shutdown(fh, 2);
				(void)close(fh);
				continue;
			}
#endif
		}


#ifdef DEBUG
		(void)serveclient(fh, timeout);
		(void)shutdown(fh, 2);
		(void)close(fh);
		syslog(LOGPRI, "end of connection from %s", fromhost);
#else
		switch(fork()) {
			case	-1:
				syslog(LOGPRI, "fork(): %m");
				continue;
			case	0:
				(void)serveclient(fh, timeout);
				(void)shutdown(fh, 2);
				(void)close(fh);
				syslog(LOGPRI, "end of connection from %s",
							fromhost);
				exit(0);
			default:
				(void)close(fh);
				break;
		}
#endif
	}

	/*NOTREACHED*/
	return(0);
}

serveclient(fh, timeout)
int	fh;
int	timeout;
{
	cpacket		pp;
	spacket		ppp;
	int		child, firstack, sreply, pty, usepty = 0;
	int		i, ret, cipher;
	int		pfdin[2], pfdout[2], authpipe[2];
	char		ttyline[16], *p, *authbuf, *authbuf2;
	void		timeexpired();
	MD5_CTX		mdContext;
	unsigned char	digest[16];

	char		*getstelsecret();

	(void)signal(SIGALRM, timeexpired);
	(void)alarm(LOGINTIMEOUT);

	(void)strcpy((char *)username, "stillunknownuser");

#ifdef ASCIIBANNER
	if (sendbanner(fh)) {
		syslog(LOGPRI, "error sending BANNER: %m");
		return(1);
	}
#endif

	if ((i = read(fh, &firstack, sizeof(firstack))) != sizeof(firstack)) {
		if (!i)
			syslog(LOGPRI, "Client has gone away.");
		else
			syslog(LOGPRI, "read(firstack): %m");
		return(1);
	}
	firstack = ntohl(firstack);

	if (!(firstack & FLG_NO_ENCRYPTION)) { /* encryption required */
		if (dhexchange(fh, SERVER_SIDE, firstack, NULL) < 0) {
			syslog(LOGPRI, "dhexchange(): %m");
			return(1);
		}
	}

	if ((i = read_data(fh, &pp, sizeof(pp))) != sizeof(pp)) {
		if (!i)
			syslog(LOGPRI, "Client has gone away.");
		else
			syslog(LOGPRI, "read(): %m");
		return(1);
	}

	if (!(firstack & FLG_NO_ENCRYPTION)) {
		if (firstack & FLG_USE_IDEA) {
			cipher = IDEA_CIPHER;
		}
		else if (firstack & FLG_USE_SINGLE) {
			cipher = DES_CIPHER;
		}
		else if (firstack & FLG_USE_RC4) {
			cipher = RC4_CIPHER;
		}
		else { /* default */
			cipher = TRIPLEDES_CIPHER;
		}

		/* set client IV */
		memcpy(c_IV, pp.random, 8);

		/* decrypt, skipping IV */
		cryptbuf((char *)&pp + 8, sizeof(pp) - 8, DES_DECRYPT, cipher,
								CLIENT_SIDE);
	}

	/* check integrity */
	MD5Init(&mdContext);
	/* skip digest itself */
	MD5Update(&mdContext, &pp, sizeof(pp) - 16);
	MD5Final(digest, &mdContext);

	sreply = MSG_OKAY_DATA;

	if (memcmp(digest, pp.digest, 16))
		sreply = MSG_CORRUPTED_DATA; /* fail */
	else if (htonl(pp.version) != VERSION) {
		sreply = MSG_WRONG_VERSION;
	}
	else {
		struct passwd	*pwd;

		/* is ~/.stelsecret is required? */
		if ((pwd = getpwnam(pp.username)) != NULL) {
			char	spath[512];
			
			(void)sprintf(spath, "%s/%s",
						pwd->pw_dir, STEL_SECRET_NAME);
			/* ~/.stelsecret authentication required */
			p = getstelsecret(spath, fromhost);
			if (p != NULL) {
				authbuf = (char *)strdup(p);
				sreply |= MSG_LOGIN_AUTH_REQUIRED;
			}
		}
			
		/* is /etc/stelsecret authentication required? */
		if ((authbuf2 = getstelsecret(ETC_STEL_SECRET_NAME, fromhost)) != NULL)
			sreply |= MSG_SYSTEM_AUTH_REQUIRED;

		/* if authentication is requred we refuse client's requests
		not to use encryption. in other words encryption is a must
		when performing mutual authentication */
		if ((firstack & FLG_NO_ENCRYPTION) &&
		    (sreply & MSG_LOGIN_AUTH_REQUIRED ||
		     sreply & MSG_SYSTEM_AUTH_REQUIRED))
			sreply = MSG_MUST_AUTH; /* fail */
	}

	i = htonl(sreply);
	ppp.sreply = i;

	if (!(firstack & FLG_NO_ENCRYPTION)) {
		memcpy(ppp.random, (char *)randomdigest(), 16);
		/* set server IV */
		memcpy(s_IV, ppp.random, 8);
	}

	MD5Init(&mdContext);
	/* skip digest itself */
	MD5Update(&mdContext, &ppp, sizeof(ppp) - 16);
	MD5Final(ppp.digest, &mdContext);

	if (!(firstack & FLG_NO_ENCRYPTION)) {
		cryptbuf((char *)&ppp + 8, sizeof(ppp) - 8, DES_ENCRYPT,
							cipher, SERVER_SIDE);
	}

	if (write(fh, &ppp, sizeof(ppp)) != sizeof(ppp)) {
		syslog(LOGPRI, "write(): %m");
		return(1);
	}

	if (sreply == MSG_WRONG_VERSION) {
		syslog(LOGPRI, "Wrong %s version: expected %d, received %d.",
					STELSERVER, VERSION, htonl(pp.version));
		return(1);
	}

	if (sreply == MSG_CORRUPTED_DATA) {
		syslog(LOGPRI, "received CORRUPTED data from client");
		return(1);
	}

	if (sreply == MSG_MUST_AUTH) {
		syslog(LOGPRI, "NO ENCRYPTION request for client rejected");
		return(1);
	}

	if (sreply & MSG_SYSTEM_AUTH_REQUIRED) {
		ret = mauth(fh, authbuf2, SERVER_SIDE, firstack);
		if (ret == -1) {
			syslog(LOGPRI, "mauth(%s): %m", ETC_STEL_SECRET_NAME);
			return(1);
		}
		else if (ret == 1) {
			syslog(LOGPRI, "%s MUTUAL AUTHENTICATION FAILED",
							ETC_STEL_SECRET_NAME);
			return(1);
		}
		/* authentication succeeded */
	}

	if (sreply & MSG_LOGIN_AUTH_REQUIRED) {
		ret = mauth(fh, authbuf, SERVER_SIDE, firstack);
		if (ret == -1) {
			syslog(LOGPRI, "mauth(%s): %m", STEL_SECRET_NAME);
			return(1);
		}
		else if (ret == 1) {
			syslog(LOGPRI, "%s MUTUAL AUTHENTICATION FAILED",
							STEL_SECRET_NAME);
			return(1);
		}
		/* authentication succeeded */
	}

	/* read modes */
	pp.mode = ntohl(pp.mode);
	pp.rows = ntohl(pp.rows);
	pp.cols = ntohl(pp.cols);
	if (!(pp.mode & FLG_DONTUSE_PTY))
		usepty = 1;
	
	(void)strncpy(username, pp.username, sizeof(username));

	if (usepty) {
		if ((pty = getpty(ttyline)) == -1) {
			syslog(LOGPRI, "no pseudo terminal available");
			return(1);
		}
		if (pipe(authpipe) == -1) {
			syslog(LOGPRI, "pipe(pipeauth): %m");
			return(1);
		}
	}
	else {
		if (pipe(pfdin) == -1 ||
		    pipe(pfdout) == -1) {
			syslog(LOGPRI, "pipe(pfd): %m");
			return(1);
		}
	}

	switch ((child = fork())) {
		case	-1:
			syslog(LOGPRI, "fork(): %m");
			if (usepty) {
				(void)close(pty);
			}
			else {
				(void)close(pfdout[0]);
				(void)close(pfdout[1]);
				(void)close(pfdin[0]);
				(void)close(pfdin[1]);
			}
			return(1);
		case	0:
			/* alarm is cancelled by fork */
			(void)alarm(LOGINTIMEOUT);

			/* prevent user interrupts */
			(void)signal(SIGINT, SIG_IGN);
			(void)signal(SIGQUIT, SIG_IGN);

			if (close(authpipe[0]) == -1) {
				syslog(LOGPRI, "close(authpipe)");
				exit(1);
			}
		
			setterminal(usepty, ttyline, pfdin, pfdout,
						pp.rows, pp.cols);

			runshell(&pp, usepty, authpipe[1]);
			/*NOTREACHED*/
	}

	(void)alarm(0); /* this is master side */

	if (usepty) {
		struct passwd	*pw;

		if (close(authpipe[1]) == -1) {
			syslog(LOGPRI, "close(authpipe)");
			return(1);
		}

		if ((pw = getpwnam((char *)username)) == NULL) {
			syslog(LOGPRI, 
			"%s LOGIN ATTEMPTED (USER NOT EXISTENT), from %s",
							username, fromhost);
			return(1);
		}

		/* temporanely set user privileges.
		this is needed for the file xfer facilities
		*/
		if (geteuid() == 0) {
#ifdef AIX
/* this code from the latest NRL OPIE FTP. thanks to Craig Metz */
			priv_t priv;

			priv.pv_priv[0] = 0;
			priv.pv_priv[1] = 0;
			setgroups(NULL, NULL);
			if (setpriv(PRIV_SET | PRIV_INHERITED |
						PRIV_EFFECTIVE |PRIV_BEQUEATH,
			   &priv, sizeof(priv_t)) < 0 ||
			   setgidx(ID_REAL|ID_EFFECTIVE, pw->pw_gid) < 0 ||
			   setuidx(ID_REAL|ID_EFFECTIVE, pw->pw_uid) < 0 ||
			   seteuid((uid_t)pw->pw_uid) < 0) {
				syslog(LOGPRI, "seteuid(%d): %m", pw->pw_uid);
				return(1);
			}
#else
			if (setegid(pw->pw_gid) == -1 ||
			    seteuid(pw->pw_uid) == -1) {
				syslog(LOGPRI, "seteuid(%d): %m", pw->pw_uid);
				return(1);
			}
#endif
		}

		if (makeio(pty, pty, fh, authpipe[0], SERVER_SIDE, firstack,
				fromhost, NULL, NULL, timeout, username))
			syslog(LOGPRI, "lost connection from %s", fromhost);

		/* restore user privileges */
		if (geteuid() == 0 &&
		    (setuid(0) == -1 || setgid(0) == -1)) {
			syslog(LOGPRI, "setuid(0): %m");
			return(1);
		}

		/* eventually kill living child; this is necessary if
		   connection with client drops somehow */
		(void)signal(SIGCLD, fireman);
		(void)kill(child, SIGKILL);

		p = ttyline + sizeof("/dev/") - 1;
#ifdef SYSV_UTMP
		UTMP_LOGOUT(p);
		(void)chown(ttyline, 0, 0);
		(void)chmod(ttyline, 0644);
#else /* SYSV_UTMP */
		if (logout(p))
			logwtmp(p, "", "");
		(void)chmod(ttyline, 0666);
		(void)chown(ttyline, 0, 0);
		*p = 'p';
		(void)chmod(ttyline, 0666);
		(void)chown(ttyline, 0, 0);
#endif /* SYSV_UTMP */
		return(0);
	}
	else {
		(void)close(pfdin[1]); (void)close(pfdout[0]);
		if (makeio(pfdin[0], pfdout[1], fh, -1, SERVER_SIDE, firstack,
				fromhost, NULL, NULL, timeout, username)) {
			syslog(LOGPRI, "lost connection from %s", fromhost);
		}
		/* eventually kill living child; this is necessary if
		   client failed */
		(void)signal(SIGCLD, fireman);
		(void)kill(child, SIGKILL);
		return(0);
	}
	/*NOTREACHED*/
}

#if defined (hpux) || defined (IRIX)
char    mailpath[] = "/usr/mail/\0\0\0\0\0\0\0\0\0\0";
#else
char    mailpath[] = "/usr/spool/mail/\0\0\0\0\0\0\0\0\0\0";
#endif
char    minusnam[16] = "-";

void
runshell(pp, usepty, authfh)
cpacket	*pp;
int	usepty, authfh;
{
	char		*namep, *line = NULL;
	struct passwd	*pwd;
	int		status;
	struct		skey	skey;
	char		skeyprompt[80], skeybuf[80], stelkeyhash[64];
	char		*ttyname(), *tty, *ttyn;
	int		cnt, nosuchuser = 0;
#ifdef SYSV_UTMP
	/* SYSV login insists on an utmp(x) entry */
	char *MAKE_UTMP_ID(), *utmp_id;
#endif

	if (usepty) {
		if ((line = (char *)ttyname(0)) == NULL) {
			(void)fprintf(stderr, "terminal not attached!?\n");
			sleepexit(1);
		}
	}

	if ((pwd = getpwnam((char *) username)) == NULL) {
		syslog(LOGPRI,
		"%s LOGIN ATTEMPTED (USER NOT EXISTENT), from %s",
							username, fromhost);
		nosuchuser = 1;
		goto unixauth; /* make the hacker believe the user exists */
	}

	if(chdir(pwd->pw_dir) < 0) {
		if ((pwd->pw_uid == 0) && (chdir("/") == 0))
			printf("warning: $home is \"/\".\n");
		else {
			printf("unable to chdir to \"%s\"\n", pwd->pw_dir);
			sleepexit(1);
		}
	}

	if (usepty) {
		if ((chmod(line, 0622) == -1 ||
		    chown(line, pwd->pw_uid, pwd->pw_gid) == -1) &&
		    !geteuid()) {
			(void)fprintf(stderr, "cannot chown and chown terminal line\n");
			sleepexit(1);
		}
	}

	/* authentication loop */
	for (cnt = 0; ; ) {
		/* slow down guessing attacks (if ever) */
		if (++cnt >= 3) {
			if (cnt >= 10) {
				syslog(LOGPRI,
					"%s REPEATED LOGIN FAILURES from %s",
							username, fromhost);
				sleepexit(1);
			}
			sleep((u_int)((cnt - 3) * 5));
		}

		if (nosuchuser)
			goto unixauth;
#ifdef SECURID
		/* sdi securID authentication */
		if (issdiregistered(username)) {
			printf("steld: SECURID authentication required for %s\n",
								username);
			if (!sdiauth(usepty, username))
				goto authenticated;
			syslog(LOGPRI, "%s SECURID LOGIN FAILURE from %s",
						username, fromhost);
			continue;

		}
#endif /* SECURID */

		/* skey authentication */
		skeyprompt[0] = '\0';
		if (skeychallenge(&skey, (char *)username, skeyprompt)) {
			/* user is not skey registered or skey daemon
			it not responding.  default to unix authentication */
			goto unixauth;
		}
		printf("steld: S/KEY authentication required for %s\n",
								username);
			
		/* printf("[%s]\n",skeyprompt); */
		printf("%s\n",skeyprompt);

		printf("Response: ");
		(void)fflush(stdout);
		if (fgets(skeybuf, sizeof(skeybuf), stdin) == NULL)
			sleepexit(1);
		rip(skeybuf);
		if (skeyverify(&skey, skeybuf))  {
			syslog(LOGPRI, "%s SKEY LOGIN FAILURE from %s",
						username, fromhost);
			puts("Invalid response");
			continue;
		}
		else { /* skey successful */
			break;
		}
unixauth:
		if (!skeyaccess(username, line, fromhost, fromhost)) {
			syslog(LOGPRI,
				"UNIX PASSWORDS NOT PERMITTED for %s from %s",
							username, fromhost);
			puts("UNIX passwords NOT permitted.");
			sleepexit(1);
		}
		/* unix password authentication */
		printf("steld: UNIX password authentication required for %s\n",
								username);
		if (mkunixauth(usepty, nosuchuser)) {
			syslog(LOGPRI, "%s LOGIN FAILURE from %s",
							username, fromhost);
			puts("Login incorrect");
			continue;
		}
		else /* unixauth successful */
			break;
	}

#ifdef SECURID
authenticated:
#endif
	if (!login_access(username, fromhost)) {
		syslog(LOGPRI, "%s LOGIN REFUSED FROM %s", username, fromhost);
		puts("Permission denied");
		sleepexit(1);
	}

	(void)alarm(0);

	/* the following are performed by superuser only */
	if (!geteuid()) {
#ifndef SYSV_UTMP
		struct utmp utmp;
#endif

		if (usepty) {
			ttyn = ttyname(0);
			if (ttyn == NULL || *ttyn == '\0')
				ttyn = "/dev/tty??";
			if ((tty = (char *) strchr(ttyn + 1, '/')))
				++tty;
			else
				tty = ttyn;
			
#ifdef SYSV_UTMP
			utmp_id = MAKE_UTMP_ID(ttyn, "tn");
			UTMP_INIT(tty, ".telnet", utmp_id);
			if (UTMP_LOGIN(tty, username, fromhost) != 0) {
				syslog(LOGPRI, "UTMP_INIT() failed");
				sleepexit(1);
			}
#else /* SYSV_UTMP */
			memset((char *)&utmp, 0, sizeof(utmp));
			(void)time(&utmp.ut_time);
			strncpy(utmp.ut_name, username, sizeof(utmp.ut_name));
#ifndef SOLARIS
			strncpy(utmp.ut_host, fromhost, sizeof(utmp.ut_host));
#endif
			strncpy(utmp.ut_line, tty, sizeof(utmp.ut_line));
			login(&utmp);
#endif /* SYSV_UTMP */
		}
	}

	if (!geteuid()) {
#ifdef GENERICLOGIN
		if (initgroups(pwd->pw_name, -1) == -1) {
			syslog(LOGPRI, "initgroups(): %m");
			sleepexit(1);
		}
#ifdef hpux
		if (setgid(pwd->pw_gid) ||
				setresuid(pwd->pw_uid, pwd->pw_uid, 0))
#else
		if (setgid(pwd->pw_gid) || setuid(pwd->pw_uid))
#endif
							{
			(void)fprintf(stderr, "can not set user IDs");
			sleepexit(1);
		}
#endif /* GENERICLOGIN */
	}

	(void)strncat(mailpath, pwd->pw_name, 8);
	if (*pwd->pw_shell == '\0')
		pwd->pw_shell = "/bin/sh";

	/* provide a hashing of the session key */
	sprintf(stelkeyhash, "%02x%02x%02x%02x%02x%02x%02x%02x",
		(unsigned char)sessionkeyhash[0],
		(unsigned char)sessionkeyhash[1],
		(unsigned char)sessionkeyhash[2],
		(unsigned char)sessionkeyhash[3],
		(unsigned char)sessionkeyhash[4],
		(unsigned char)sessionkeyhash[5],
		(unsigned char)sessionkeyhash[6],
		(unsigned char)sessionkeyhash[7]);

	if (
	    putvar("HOME",      pwd->pw_dir)	||
	    putvar("LOGNAME",   pwd->pw_name)	||
	    putvar("USER",   	pwd->pw_name)	||
	    putvar("USERNAME", 	pwd->pw_name)	||
	    putvar("SHELL",     pwd->pw_shell)	||
	    putvar("MAIL",      mailpath)	||
	    putvar("TERM",	pp->TERM)	||
	    putvar("LINES",	pp->LINES)	||
	    putvar("COLUMNS",	pp->COLUMNS)	||
	    putvar("DISPLAY",	pp->DISPLAY)	||
	    putvar("WINDOWID",	pp->WINDOWID)	||
	    putvar("STELKEYHASH", stelkeyhash)	||
	    /* putvar("PATH",	pp->PATH)	|| */
	    putvar("PATH",	DEFAULT_PATH)
						) {
		(void)fprintf(stderr, "can not set environment\n");
		sleepexit(1);
	}

	if (line == NULL)
		line = "unattached";

	/* restore signals */
	(void)signal(SIGINT, SIG_DFL);
	(void)signal(SIGQUIT, SIG_DFL);

	if (usepty) {
		if (write(authfh, USRAUTH, strlen(USRAUTH)) != strlen(USRAUTH)) {
			syslog(LOGPRI, "write(authfh): %m");
			exit(1);
		}
		/* won't be used again */
		if (close(authfh) == -1) {
			syslog(LOGPRI, "close(authbuf): %m");
			exit(1);
		}
	}

	if (pp->command[0] == '\0') {
		if ((namep = (char *)strrchr(pwd->pw_shell, '/')) == NULL)
			namep = pwd->pw_shell;
		else
			namep++;
		(void)strcat(minusnam, namep);

		syslog(LOGPRI, "%s LOGIN from %s, %s, \"%s\"",
				username, fromhost, line, pwd->pw_shell);

#ifdef GENERICLOGIN
		(void)execl(pwd->pw_shell, minusnam, 0);
		syslog(LOGPRI, "execl(%s): %m", pwd->pw_shell);
		(void)fprintf(stderr, "no shell\n");
		sleepexit(1);
#else
		/* -f: skip a second authentication
		   -p: preserve environment
		*/
		(void)execl("/bin/login", "login", "-f", "-p", "-l",
							pwd->pw_name, NULL);
		syslog(LOGPRI, "execl(/bin/login): %m");
		(void)fprintf(stderr, "no /bin/login\n");
		sleepexit(1);
#endif
	}
	else {
#ifdef NOREMEXEC
		syslog(LOGPRI, "%s LOGIN FAILURE from %s, %s, rcmd not permitted, \"%s\"",
				username, fromhost, line, pp->command);
		printf("Remote command execution not permitted.\n");
		sleepexit(1);
#else
		syslog(LOGPRI, "%s LOGIN from %s, %s, \"%s\"",
					username, fromhost, line, pp->command);
		(void)signal(SIGCLD, SIG_DFL);
		if ((status = system(pp->command)) == -1) {
			syslog(LOGPRI, "system() failed: %m");
			sleepexit(1);
		}
		if (status & 0177 || status >> 8) {
			syslog(LOGPRI, "command failed \"%s\"", pp->command);
			sleepexit(1);
		}
		exit(0);
#endif
	}
}

putvar(name, value)
char	*name, *value;
{
	char		*p;
	size_t		size;
	
	if (!value || !*value)
		return(0);
	size = strlen(name) + strlen(value);
	size += 2; /* '=' + '\0' */
	if ((p = (char *) malloc(size)) == NULL) {
		syslog(LOGPRI, "malloc(): %m");
		return(1);
	}
	(void)sprintf(p, "%s=%s", name, value);
	(void)putenv(p);

	return(0);
}


mkunixauth(usepty, fail)
int	usepty, fail;
{
	char		*crypt(), *getpass();
	char		*p;
	struct passwd	*pwd;
	struct passwd	*shadow_getpwnam();

	if (!fail && (pwd = shadow_getpwnam((char *) username)) == NULL)
		/* non existent user */
		return(1);

	if (usepty) {
		p = getpass("Password: ");
		if (p == NULL || !strlen(p))
			return(1);
	}
	else {
		if ((p = (char *) malloc(MAXPWDLEN)) == NULL) {
			syslog(LOGPRI, "malloc(): %m");
			return(1);
		}
		fprintf(stderr, "Password (echo is on): ");
		(void)fflush(stderr);
		if (fgets(p, MAXPWDLEN, stdin) == NULL)
			return(1);
		/* p[strlen(p) - 2] = '\0'; */ /* remote \n\r */
	}

	if (fail)
		return(1);

	return(strcmp(pwd->pw_passwd, crypt(p, pwd->pw_passwd)));
}

#ifndef DEBUG
detachfrompty()
{
	if (fork() > 0)
		exit(0);
	else {
/*
#if defined(SUNOS4) || defined(SOLARIS)
		(void)setpgrp(getuid(), 0);
#else
		(void)setpgrp();
#endif
*/
		setsid();
	}
}
#endif

void
timeexpired(s)
int	s;
{
	(void)signal(s, timeexpired);
	syslog(LOGPRI, "time expired for %s from %s", username, fromhost);
	exit(1);
}

#ifdef AIX
#ifndef TIOCSWINSZ
#define TIOCSWINSZ	_IOW('t', 103, struct winsize)  /* set window size */
#endif
#endif
setterminal(usepty, ttyline, pfdin, pfdout, rows, cols)
char	*ttyline;
int	usepty, *pfdin, *pfdout;
int	rows, cols;
{
	int		i;
	struct winsize	os_window;

	/* pty attached */
	if (usepty) {
		int		t;
		struct termios	b;

		if ((t = open(ttyline, O_RDWR)) == -1) {
			syslog(LOGPRI, "open1(%s): %m", ttyline);
			exit(1);
		}

#ifdef SOLARIS
		if (ioctl(t, I_PUSH, "ptem") < 0 ||
		    ioctl(t, I_PUSH, "ldterm") < 0 ||
		    ioctl(t, I_PUSH, "ttcompat") < 0) {
			syslog(LOGPRI, "Cannot push streams modules onto pty");
			exit(1);
		}
#endif
		/* get terminal attributes */
		if (tcgetattr(t, &b) == -1) {
			syslog(LOGPRI, "tcgetattr(): %m");
			exit(1);
		}

#ifdef hpux
		b.c_lflag |= ECHO | ECHOK | ECHOE | ICANON | ISIG;
		b.c_iflag |= ICRNL | BRKINT | ISTRIP | IXON;
		b.c_iflag &= ~(IXANY | PARMRK);
		b.c_oflag |= ONLCR | OPOST;
#else
		b.c_lflag |= ECHO;
		b.c_iflag |= ICRNL;
		b.c_oflag |= ONLCR;
#endif
		b.c_cflag = B9600 | CS8 | CREAD | HUPCL;

		b.c_cc[VERASE] = ERASECHAR;
		b.c_cc[VKILL] = KILLCHAR;
		b.c_cc[VEOF] = 'd'&0x1f;
		b.c_cc[VINTR] = 0x3; /* ^C */
		b.c_cc[VEOL] = b.c_cc[VSUSP] = 0;
		if (tcsetattr(t, TCSANOW, &b) == -1) {
			syslog(LOGPRI, "tcsetattr(): %m");
			exit(1);
		}


		if (rows >= 0 && cols >= 0) {
			os_window.ws_row = rows;
			os_window.ws_col = cols;
			if (ioctl(t,TIOCSWINSZ,&os_window) == -1) {
				syslog(LOGPRI, "ioctl(): %m");
				exit(1);
			}
		}

		/* Acquire a controlling terminal */
		if (setsid() == -1) {
			syslog(LOGPRI, "setsid(): %m");
			exit(1);
		}
		i = t;
		if ((t = open(ttyline, O_RDWR)) < 0) {
			syslog(LOGPRI, "open2(ttyline): %m");
			exit(1);
		}
		(void)close(i);
		
		if (dup2(t, 0) == -1 ||
		    dup2(t, 1) == -1 ||
		    dup2(t, 2) == -1)  {
			syslog(LOGPRI, "dup2(): %m");
			exit(1);
		}

		return(t);

	}
	/* no pty attached */
	else {
		if (close(0) || close(1) || close(2)) {
			syslog(LOGPRI, "close(): %m");
			exit(1);
		}

#if defined(SUNOS4) || defined(SOLARIS)
		if (setpgrp(getuid(), 0) == -1)
#else
		if (setpgrp() == -1)
#endif
					{
			syslog(LOGPRI, "setpgrp(): %m");
			exit(1);
		}

		if (dup(pfdout[0]) != 0 || dup(pfdin[1]) != 1 ||
		    dup(pfdin[1]) != 2) {
			syslog(LOGPRI, "dup(): %m");
			exit(1);
		}

		if (close(pfdout[0]) == -1 || close(pfdout[1]) == -1 ||
		    close(pfdin[0]) == -1 || close(pfdin[1]) == -1) {
			syslog(LOGPRI, "close(): %m");
			exit(1);
		}
		
		return(-1); /* unused! */
	}
	/*NOTREACHED*/
}

struct passwd *
shadow_getpwnam(user)
char	*user;
{
	static struct passwd	*pwd;
#ifdef SUNOS4
	struct passwd_adjunct	*pa;
#else
#ifdef SOLARIS
	struct	spwd		*pa;
#endif
#endif
	if ((pwd = getpwnam(user)) == NULL)
		return(NULL);
	
#ifdef SUNOS4
	if (issecure()) {
		if ((pa = getpwanam(user)) == NULL)
			return(NULL);
		pwd->pw_passwd =  (char *)strdup(pa->pwa_passwd);
	}
#else
#ifdef SOLARIS
	if ((pa = getspnam(user)) == NULL)
		return(NULL);
	pwd->pw_passwd = (char *)strdup(pa->sp_pwdp);
#endif
#endif
	return(pwd);
}

#ifdef SECURID
#define SECURIDUSRLIST	"/etc/securid.conf"
issdiregistered(user)
char	*user;
{
	char	line[80];
	FILE	*fp;

	if ((fp = fopen(SECURIDUSRLIST, "r")) == NULL)
		return(0);
	while (fgets(line, sizeof(line), fp) != NULL) {
		rip(line);
		if (line[0] == '#')
			continue;
		if (!strcmp(user, line)) {
			(void)fclose(fp);
			return(1);
		}
	}
	(void)fclose(fp);
	return(0);
}
#endif

sleepexit(eval)
int eval;
{
	sleep((u_int)5);
	exit(eval);
}
@


1.106
log
@safety
@
text
@d3 4
a6 4
 * $Header: /users/vince/src/stel/RCS/steld.c,v 1.105 1996/03/30 14:58:08 vince Exp $
 * $Date: 1996/03/30 14:58:08 $
 * $Revision: 1.105 $
 * $Locker:  $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: steld.c,v 1.105 1996/03/30 14:58:08 vince Exp $";
a78 2
extern char		versionstring[];

d159 4
a162 4
	printf("server [%d] %s starting on port %d\n",
					getpid(), versionstring, portnum);
	syslog(LOGPRI, "server %s started on port %d",
					versionstring, portnum);
d235 7
@


1.105
log
@safety
@
text
@d3 3
a5 3
 * $Header: /users/vince/src/stel/RCS/steld.c,v 1.104 1996/01/03 18:20:26 vince Exp $
 * $Date: 1996/01/03 18:20:26 $
 * $Revision: 1.104 $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: steld.c,v 1.104 1996/01/03 18:20:26 vince Exp $";
d828 6
d846 1
@


1.104
log
@safety
@
text
@d3 4
a6 4
 * $Header: /res/usr/vince/src/stel/RCS/steld.c,v 1.103 1996/01/02 16:41:03 vince Exp vince $
 * $Date: 1996/01/02 16:41:03 $
 * $Revision: 1.103 $
 * $Locker: vince $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: steld.c,v 1.103 1996/01/02 16:41:03 vince Exp vince $";
a967 1
		b.c_oflag &= ~TAB3;
a971 1
		b.c_oflag &= ~TAB3;
@


1.103
log
@safety
@
text
@d3 4
a6 4
 * $Header: /res/usr/vince/src/stel/RCS/steld.c,v 1.102 1995/12/21 18:00:21 vince Exp $
 * $Date: 1995/12/21 18:00:21 $
 * $Revision: 1.102 $
 * $Locker:  $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: steld.c,v 1.102 1995/12/21 18:00:21 vince Exp $";
d493 2
a494 2
			if (seteuid(pw->pw_uid) == -1 ||
			    setegid(pw->pw_gid) == -1) {
@


1.102
log
@safety
@
text
@d3 3
a5 3
 * $Header: /res/usr/vince/src/stel/RCS/steld.c,v 1.101 1995/12/21 10:58:55 vince Exp $
 * $Date: 1995/12/21 10:58:55 $
 * $Revision: 1.101 $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: steld.c,v 1.101 1995/12/21 10:58:55 vince Exp $";
d36 2
a456 1
	ret = 0;
d475 24
a498 4
		if (geteuid() == 0 &&
		    (seteuid(pw->pw_uid) == -1 || setegid(pw->pw_gid) == -1)) {
			syslog(LOGPRI, "seteuid(%d): %m", pw->pw_uid);
			return(1);
d502 1
a502 1
				fromhost, NULL, NULL, timeout, username)) {
a503 2
			ret = 1;
		}
d506 3
a508 3
		if (getuid() == 0 &&
		    (seteuid(0) == -1 || setegid(0) == -1)) {
			syslog(LOGPRI, "seteuid(0): %m");
d531 1
a531 1
		return(ret);
a537 1
			ret = 1;
d543 1
a543 1
		return(1);
@


1.101
log
@safety
@
text
@d3 4
a6 4
 * $Header: /res/usr/vince/src/stel/RCS/steld.c,v 1.100 1995/12/20 18:33:49 vince Exp vince $
 * $Date: 1995/12/20 18:33:49 $
 * $Revision: 1.100 $
 * $Locker: vince $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: steld.c,v 1.100 1995/12/20 18:33:49 vince Exp vince $";
a291 1
#ifndef SYSLOGINONLY
a323 1
#endif /* !SYSLOGINONLY */
a359 1
#ifndef SYSLOGINONLY
a391 1
#endif /* !SYSLOGINONLY */
a399 1
#ifndef SYSLOGINONLY
a400 3
#else /* !SYSLOGINONLY */
	(void)strcpy((char *)username, ".stel");
#endif
a542 1
#ifndef SYSLOGINONLY
a543 1
#endif /* !SYSLOGINONLY */
a560 1
#ifndef SYSLOGINONLY
a671 1
#endif /* !SYSLOGINONLY */
a709 1
#ifndef SYSLOGINONLY
a731 1
#endif /* !SYSLOGINONLY */
a744 1
#ifndef SYSLOGINONLY
a750 1
#endif /* !SYSLOGINONLY */
d776 5
a782 7
#ifdef SYSLOGINONLY
	(void)execl("/bin/login", "login", "-p", NULL);
	syslog(LOGPRI, "execl(/bin/login): %m");
	(void)fprintf(stderr, "no /bin/login\n");
	sleepexit(1);
#else /* !SYSLOGINONLY */

a822 1
#endif /* SYSLOGINONLY */
@


1.100
log
@safety
@
text
@d3 4
a6 4
 * $Header: /res/usr/vince/src/stel-dist/stel/RCS/steld.c,v 1.99 1995/12/16 15:48:11 vince Exp $
 * $Date: 1995/12/16 15:48:11 $
 * $Revision: 1.99 $
 * $Locker:  $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: steld.c,v 1.99 1995/12/16 15:48:11 vince Exp $";
d465 2
d471 19
a489 2
		if (makeio(pty, pty, fh, firstack, NULL, NULL, NULL,
					timeout, authpipe[0], username)) {
d493 8
d524 2
a525 2
		if (makeio(pfdin[0], pfdout[1], fh, firstack, NULL, NULL, NULL,
						timeout, -1, NULL)) {
d788 1
a788 1
		if (write(authfh, "okay", 4) != 4) {
@


1.99
log
@safety
@
text
@d3 3
a5 3
 * $Header: /res/usr/vince/src/stel/RCS/steld.c,v 1.98 1995/12/15 16:36:17 vince Exp $
 * $Date: 1995/12/15 16:36:17 $
 * $Revision: 1.98 $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: steld.c,v 1.98 1995/12/15 16:36:17 vince Exp $";
d96 1
a96 1
	(void)openlog(PRGNAME, LOG_WARNING);
d98 1
a98 1
	(void)openlog(PRGNAME, LOG_PID | LOG_ODELAY, LOG_DAEMON);
d159 4
a162 4
	printf("%s[%d] %s started on port %d\n",
				PRGNAME, getpid(), versionstring, portnum);
	syslog(LOGPRI, "%s[%d] %s started on port %d",
				PRGNAME, getpid(), versionstring, portnum);
d223 1
a223 1
	int		pfdin[2], pfdout[2];
d353 1
a353 1
					PRGNAME, VERSION, htonl(pp.version));
d415 4
d423 1
a423 1
			syslog(LOGPRI, "pipe(): %m");
d449 7
a455 2
			setterminal(usepty, ttyline, pfdin, pfdout, pp.rows,
								pp.cols);
d457 1
a457 1
			runshell(&pp, usepty);
d465 6
a470 1
		if (makeio(pty, pty, fh, firstack, NULL, NULL, NULL, timeout)) {
d497 2
a498 1
		if (makeio(pfdin[0], pfdout[1], fh, firstack, NULL, NULL, NULL, timeout)) {
d519 1
a519 1
runshell(pp, usepty)
d521 1
a521 1
int	usepty;
d760 7
d917 1
a917 1
		
@


1.98
log
@safety
@
text
@d3 3
a5 3
 * $Header: /res/usr/vince/src/stel-dist/stel/RCS/steld.c,v 1.97 1995/12/14 10:36:13 vince Exp $
 * $Date: 1995/12/14 10:36:13 $
 * $Revision: 1.97 $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: steld.c,v 1.97 1995/12/14 10:36:13 vince Exp $";
d595 2
a596 1
		printf("[%s]\n",skeyprompt);
d916 1
a916 2
		b.c_lflag |= ECHO | ECHOK | ECHOE;
		b.c_lflag |= ICANON | ISIG;
d918 1
a918 2
		b.c_iflag &= ~IXANY;
		b.c_iflag &= ~PARMRK;
d920 1
d923 1
d925 1
a925 1
		b.c_iflag |= ICRNL;
a926 1
		/**/
d928 1
a928 1
		/**/
@


1.97
log
@safety
@
text
@d3 3
a5 3
 * $Header: /res/usr/vince/src/stel-dist/stel/RCS/steld.c,v 1.96 1995/12/08 14:38:55 vince Exp $
 * $Date: 1995/12/08 14:38:55 $
 * $Revision: 1.96 $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: steld.c,v 1.96 1995/12/08 14:38:55 vince Exp $";
d417 2
a418 1
		if (pipe(pfdin) == -1 || pipe(pfdout) == -1) {
d445 3
a447 1
			setterminal(usepty, ttyline, pfdin, pfdout, pp.rows, pp.cols);
d967 3
a969 1
		
d999 2
d1002 1
@


1.96
log
@safety
@
text
@d3 3
a5 3
 * $Header: /res/usr/vince/src/stel/RCS/steld.c,v 1.95 1995/12/04 16:36:21 vince Exp $
 * $Date: 1995/12/04 16:36:21 $
 * $Revision: 1.95 $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: steld.c,v 1.95 1995/12/04 16:36:21 vince Exp $";
d34 4
d874 5
@


1.95
log
@safety
@
text
@d3 3
a5 3
 * $Header: /res/usr/vince/src/stel/RCS/steld.c,v 1.94 1995/11/29 13:18:46 vince Exp $
 * $Date: 1995/11/29 13:18:46 $
 * $Revision: 1.94 $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: steld.c,v 1.94 1995/11/29 13:18:46 vince Exp $";
d567 2
a568 1
			printf("steld: SECURID authentication required\n");
d580 3
a582 1
		if (skeychallenge(&skey, (char *)username, skeyprompt))
d584 3
a586 1
		printf("steld: S/KEY authentication required\n");
d613 2
a614 1
		printf("steld: UNIX password authentication required\n");
@


1.94
log
@safety
@
text
@d3 3
a5 3
 * $Header: /res/usr/vince/src/stel/RCS/steld.c,v 1.93 1995/11/25 16:53:41 vince Exp $
 * $Date: 1995/11/25 16:53:41 $
 * $Revision: 1.93 $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: steld.c,v 1.93 1995/11/25 16:53:41 vince Exp $";
d232 5
a236 2
	if (read(fh, &firstack, sizeof(firstack)) == -1) {
		syslog(LOGPRI, "read(firstack): %m");
d248 5
a252 2
	if (read_data(fh, &pp, sizeof(pp)) != sizeof(pp)) {
		syslog(LOGPRI, "read(): %m");
@


1.93
log
@safety
@
text
@d3 3
a5 3
 * $Header: /res/usr/vince/src/stel/RCS/steld.c,v 1.92 1995/11/24 14:04:05 vince Exp $
 * $Date: 1995/11/24 14:04:05 $
 * $Revision: 1.92 $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: steld.c,v 1.92 1995/11/24 14:04:05 vince Exp $";
d63 1
a63 1
#include "des.h"
@


1.92
log
@safety
@
text
@d3 4
a6 4
 * $Header: /res/usr/vince/src/stel/RCS/steld.c,v 1.91 1995/11/24 12:26:47 vince Exp vince $
 * $Date: 1995/11/24 12:26:47 $
 * $Revision: 1.91 $
 * $Locker: vince $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: steld.c,v 1.91 1995/11/24 12:26:47 vince Exp vince $";
d68 3
d264 6
a269 2
		/* decrypt */
		cryptbuf(&pp, sizeof(pp), DES_DECRYPT, cipher, CLIENT_SIDE);
d274 2
a275 2
	/* skip digest itself and padding */
	MD5Update(&mdContext, &pp, sizeof(pp) - 16 - 8);
d283 3
d317 17
a333 4
	if (htonl(pp.version) != VERSION) {
		syslog(LOGPRI, "Wrong %s version: expected %d, received %d",
					PRGNAME, VERSION, htonl(pp.version));
		return(1);
a335 3
	i = htonl(sreply);
	ppp.sreply = i;
	memcpy(ppp.random, (char *)randomdigest(), 16);
d338 6
@


1.91
log
@safety
@
text
@d3 4
a6 4
 * $Header: /res/usr/vince/src/stel/RCS/steld.c,v 1.90 1995/11/21 09:56:21 vince Exp $
 * $Date: 1995/11/21 09:56:21 $
 * $Revision: 1.90 $
 * $Locker:  $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: steld.c,v 1.90 1995/11/21 09:56:21 vince Exp $";
d212 3
a214 2
	packet	pp;
	int		child, firstack, smessage, pty, usepty = 0;
d271 1
a271 1
	smessage = MSG_OKAY_DATA;
d274 1
a274 1
		smessage = MSG_CORRUPTED_DATA; /* fail */
d289 1
a289 1
				smessage |= MSG_LOGIN_AUTH_REQUIRED;
d295 1
a295 1
			smessage |= MSG_SYSTEM_AUTH_REQUIRED;
d301 3
a303 3
		    (smessage & MSG_LOGIN_AUTH_REQUIRED ||
		     smessage & MSG_SYSTEM_AUTH_REQUIRED))
			smessage = MSG_MUST_AUTH; /* fail */
d308 1
a308 1
		syslog(LOGPRI, "Wrong %d version: expected %d, received %d",
d313 4
a316 2
	i = htonl(smessage);
	if (write(fh, &i, sizeof(smessage)) != sizeof(smessage)) {
d321 1
a321 1
	if (smessage == MSG_CORRUPTED_DATA) {
d327 1
a327 1
	if (smessage == MSG_MUST_AUTH) {
d332 1
a332 1
	if (smessage & MSG_SYSTEM_AUTH_REQUIRED) {
d346 1
a346 1
	if (smessage & MSG_LOGIN_AUTH_REQUIRED) {
d466 1
a466 1
packet	*pp;
@


1.90
log
@safety
@
text
@d3 2
a4 2
 * $Header: /users/vince/src/stel/RCS/steld.c,v 1.90 1995/11/15 13:54:52 vince Exp $
 * $Date: 1995/11/15 13:54:52 $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: steld.c,v 1.90 1995/11/15 13:54:52 vince Exp $";
d252 3
@


1.89
log
@safety
@
text
@d3 4
a6 4
 * $Header: /res/usr/vince/src/stel/RCS/steld.c,v 1.88 1995/08/26 09:47:35 vince Exp vince $
 * $Date: 1995/08/26 09:47:35 $
 * $Revision: 1.88 $
 * $Locker: vince $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: steld.c,v 1.88 1995/08/26 09:47:35 vince Exp vince $";
d250 4
a253 1
		else if (firstack & FLG_USE_TRIPLE) {
a254 3
		}
		else {
			cipher = DES_CIPHER;
@


1.88
log
@safety
@
text
@d3 4
a6 4
 * $Header: /res/usr/vince/src/stel/RCS/steld.c,v 1.87 1995/08/25 15:58:26 vince Exp $
 * $Date: 1995/08/25 15:58:26 $
 * $Revision: 1.87 $
 * $Locker:  $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: steld.c,v 1.87 1995/08/25 15:58:26 vince Exp $";
d145 2
@


1.87
log
@safety
@
text
@d3 4
a6 4
 * $Header: /res/usr/vince/src/stel/RCS/steld.c,v 1.86 1995/08/25 14:06:17 vince Exp vince $
 * $Date: 1995/08/25 14:06:17 $
 * $Revision: 1.86 $
 * $Locker: vince $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: steld.c,v 1.86 1995/08/25 14:06:17 vince Exp vince $";
d177 7
d199 1
d278 1
a278 1
						pwd->pw_home, STEL_SECRET_NAME);
d280 3
a282 1
			if ((authbuf = getstelsecret(spath, fromhost)) != NULL)
d284 1
d288 1
a288 1
		if ((authbuf2 = getstelsecret(STEL_SECRET_NAME, fromhost)) != NULL)
d303 1
a303 1
					PRGNAME, htonl(pp.version), VERSION);
@


1.86
log
@safety
@
text
@d3 4
a6 4
 * $Header: /res/usr/vince/src/stel/RCS/steld.c,v 1.85 1995/08/25 10:59:54 vince Exp $
 * $Date: 1995/08/25 10:59:54 $
 * $Revision: 1.85 $
 * $Locker:  $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: steld.c,v 1.85 1995/08/25 10:59:54 vince Exp $";
d211 1
a211 1
	char		*getstelsecret(), *getetcstelsecret();
d263 1
a263 3
		/* ~/.stelsecret authentication required */
		if ((authbuf = getstelsecret(pp.username)) != NULL)
			smessage |= MSG_LOGIN_AUTH_REQUIRED;
d265 13
a277 2
		/* /etc/stelsecret authentication required */
		if ((authbuf2 = getetcstelsecret(SERVER_SIDE)) != NULL)
d281 1
a281 1
		not to use encryption. in other words encryption is s must
a990 45
}

char *
getstelsecret(user)
char	*user;
{
	struct passwd	*pwd;
	static char	authbuf[STEL_SECRET_MAX_LEN];
	char		filename[512];
	struct stat	sbuf;
	int		in;

	if ((pwd = getpwnam(user)) == NULL)
		return(NULL); /* no user, this will be checked later */
	
	if (strlen(pwd->pw_dir) +  strlen(STEL_SECRET_NAME) + 5 >
						sizeof(filename)) {
		syslog(LOGPRI, "homedir name for %s is too large", user);
		return(NULL);
	}

	(void)sprintf(filename, "%s/%s", pwd->pw_dir, STEL_SECRET_NAME);

	if (stat(filename, &sbuf) < 0) {
		if (errno != ENOENT)
			syslog(LOGPRI, "stat(%s):%m", filename);
		return(NULL);
	}

	if ((in = open(filename, O_RDONLY)) == -1) {
		syslog(LOGPRI, "open(%s):%m", filename);
		return(NULL);
	}

	bzero(authbuf, sizeof(authbuf));
	if (read(in, authbuf, sizeof(authbuf)) == -1) {
		syslog(LOGPRI, "read(%s):%m", filename);
		(void)close(in);
		return(NULL);
	}

	(void)close(in);

	rip(authbuf);
	return(authbuf);
@


1.85
log
@safety
@
text
@d3 3
a5 3
 * $Header: /res/usr/vince/src/stel/RCS/steld.c,v 1.84 1995/08/23 19:12:23 vince Exp $
 * $Date: 1995/08/23 19:12:23 $
 * $Revision: 1.84 $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: steld.c,v 1.84 1995/08/23 19:12:23 vince Exp $";
d84 1
d96 2
a97 1
	while ((i = getopt(argc, argv, "kp:")) != EOF)
d106 3
d134 1
a134 1
		(void)serveclient(0);
d182 1
a182 1
				(void)serveclient(fh);
d198 1
a198 1
serveclient(fh)
d200 1
d389 1
a389 1
		if (makeio(pty, pty, fh, firstack, NULL, NULL, NULL)) {
d416 1
a416 1
		if (makeio(pfdin[0], pfdout[1], fh, firstack, NULL, NULL, NULL)) {
@


1.84
log
@safety
@
text
@d3 3
a5 3
 * $Header: /res/usr/vince/src/stel/RCS/steld.c,v 1.83 1995/08/23 15:05:54 vince Exp $
 * $Date: 1995/08/23 15:05:54 $
 * $Revision: 1.83 $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: steld.c,v 1.83 1995/08/23 15:05:54 vince Exp $";
d420 1
a420 2

	return(0);
d534 1
a534 1
		if (!skeyaccess(username, tty, fromhost, fromhost)) {
d553 1
d555 1
d567 1
d569 1
@


1.83
log
@safety
@
text
@d3 4
a6 4
 * $Header: /res/usr/vince/src/stel/RCS/steld.c,v 1.82 1995/08/23 11:16:54 vince Exp vince $
 * $Date: 1995/08/23 11:16:54 $
 * $Revision: 1.82 $
 * $Locker: vince $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: steld.c,v 1.82 1995/08/23 11:16:54 vince Exp vince $";
d68 2
d442 1
a442 1
	char		skeyprompt[80], skeybuf[80];
d622 11
d647 1
@


1.82
log
@safety
@
text
@d3 3
a5 3
 * $Header: /res/usr/vince/src/stel/RCS/steld.c,v 1.81 1995/08/15 18:47:12 vince Exp vince $
 * $Date: 1995/08/15 18:47:12 $
 * $Revision: 1.81 $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: steld.c,v 1.81 1995/08/15 18:47:12 vince Exp vince $";
d240 1
a240 2
		for (i = 0; i < sizeof(pp); i++)
			CFBcrypt((char *)&pp + i, DES_DECRYPT, cipher, CLIENT_SIDE);
a593 2

	syslog(LOGPRI, "due");
@


1.81
log
@safety
@
text
@d3 3
a5 3
 * $Header: /res/usr/vince/src/stel/RCS/steld.c,v 1.80 1995/07/29 19:52:54 vince Exp vince $
 * $Date: 1995/07/29 19:52:54 $
 * $Revision: 1.80 $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: steld.c,v 1.80 1995/07/29 19:52:54 vince Exp vince $";
d501 1
a501 1
			printf("SECURID authentication required\n");
d515 1
a515 1
		printf("S/KEY authentication required\n");
d542 1
a542 1
		printf("UNIX password authentication required\n");
@


1.80
log
@safety
@
text
@d3 3
a5 3
 * $Header: /res/usr/vince/src/stel/RCS/steld.c,v 1.79 1995/07/20 06:02:10 vince Exp vince $
 * $Date: 1995/07/20 06:02:10 $
 * $Revision: 1.79 $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: steld.c,v 1.79 1995/07/20 06:02:10 vince Exp vince $";
d27 1
d206 1
a206 1
	(void)alarm(TIMEOUT);
d367 1
a367 1
			(void)alarm(TIMEOUT);
d387 1
a387 1
		   client failed */
d565 2
a583 2
			struct utmp utmp;

@


1.79
log
@safety
@
text
@d3 3
a5 3
 * $Header: /res/usr/vince/src/stel/RCS/steld.c,v 1.78 1995/07/19 18:58:54 vince Exp vince $
 * $Date: 1995/07/19 18:58:54 $
 * $Revision: 1.78 $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: steld.c,v 1.78 1995/07/19 18:58:54 vince Exp vince $";
d253 1
d271 1
d290 1
d323 1
d332 1
d334 3
d372 1
a372 2
			setterminal(usepty, ttyline, pfdin, pfdout,
							pp.rows, pp.cols);
d435 1
d437 1
d448 8
a463 7
	if (usepty) {
		if ((line = (char *)ttyname(0)) == NULL) {
			(void)fprintf(stderr, "terminal not attached!?\n");
			sleepexit(1);
		}
	}

d552 1
a552 3
	/* authenticated */
	(void)alarm(0);

d558 3
d593 1
a593 1
	
d595 1
a595 7
#ifdef AUDIT
		/* turn auditing on */
		if (!geteuid() && setaudproc(1)) {
			syslog(LOGPRI, "setaudproc(): %m");
			sleepexit(1);
		}
#endif
d597 3
d614 1
d620 5
a624 1
	if (putvar("HOME",      pwd->pw_dir)	||
d629 2
d636 3
a638 5
	    /*
	    putvar("PATH",	pp->PATH)	||
	    */
	    putvar("PATH",	DEFAULT_PATH)	||
	    putvar("MAIL",      mailpath)) {
a645 1

d650 6
a655 3
	/* FIX -- 
	(void)execl("/bin/login", "login", "-f", "-l", pwd->pw_name, NULL);
	*/
d667 1
d672 10
d697 1
@


1.78
log
@safety
@
text
@d3 3
a5 3
 * $Header: /res/usr/vince/src/stel/RCS/steld.c,v 1.77 1995/07/14 16:06:22 vince Exp vince $
 * $Date: 1995/07/14 16:06:22 $
 * $Revision: 1.77 $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: steld.c,v 1.77 1995/07/14 16:06:22 vince Exp vince $";
d401 1
a401 1
		if (makeio(pfdin[0], pfdout[1], fh, firstack, 0)) {
a414 1

d421 1
a550 8
        ttyn = ttyname(0);
        if (ttyn == NULL || *ttyn == '\0')
                ttyn = "/dev/tty??";
        if ((tty = (char *) strchr(ttyn + 1, '/')))
                ++tty;
        else
                tty = ttyn;
	
d553 9
d563 6
a568 6
		utmp_id = MAKE_UTMP_ID(ttyn, "tn");
		UTMP_INIT(tty, ".telnet", utmp_id);
		if (UTMP_LOGIN(tty, username, fromhost) != 0 && !geteuid()) {
			syslog(LOGPRI, "UTMP_INIT() failed");
			sleepexit(1);
		}
a569 1
		{
d580 1
a581 1
#endif /* SYSV_UTMP */
d759 1
a759 1
int	rows,cols;
d845 4
a848 3
		(void)close(0);
		(void)close(1);
		(void)close(2);
d860 2
a861 2
		if (dup(pfdout[0]) != 0 || dup(pfdin[1]) != 1 /* ||
		    dup(pfdin[1]) != 2 */) {
@


1.77
log
@safety
@
text
@d3 4
a6 4
 * $Header: /res/usr/vince/src/stel/RCS/steld.c,v 1.76 1995/07/14 13:31:29 vince Exp $
 * $Date: 1995/07/14 13:31:29 $
 * $Revision: 1.76 $
 * $Locker:  $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: steld.c,v 1.76 1995/07/14 13:31:29 vince Exp $";
a368 6
/*
	if (ioctl(pty, I_PUSH, "pckt") < 0) {
		syslog(LOGPRI, "Cannot push streams modules onto pty");
		return(1);
	}
*/
a471 4
	/*
	goto authenticated;
	*/

d519 1
a519 1
		else /* skey successful */
d521 1
d542 1
a542 1
authenticated:
d558 1
a558 1

d859 2
a860 2
		if (dup(pfdout[0]) != 0 || dup(pfdin[1]) != 1 ||
		    dup(pfdin[1]) != 2) {
a869 1

a872 1
/* fix: OK for SUNOS4, hpux */
@


1.76
log
@safety
@
text
@d3 4
a6 4
 * $Header: /res/usr/vince/src/stel/RCS/steld.c,v 1.75 1995/07/14 11:36:25 vince Exp vince $
 * $Date: 1995/07/14 11:36:25 $
 * $Revision: 1.75 $
 * $Locker: vince $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: steld.c,v 1.75 1995/07/14 11:36:25 vince Exp vince $";
d516 1
a516 2
		/* printf("[%s]\n",skeyprompt); */
		printf("%s\n",skeyprompt);
d601 4
a604 1
		(void)initgroups(pwd->pw_name, -1);
@


1.75
log
@safety
@
text
@d3 4
a6 4
 * $Header: /res/usr/vince/src/stel/RCS/steld.c,v 1.74 1995/07/13 17:35:49 vince Exp $
 * $Date: 1995/07/13 17:35:49 $
 * $Revision: 1.74 $
 * $Locker:  $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: steld.c,v 1.74 1995/07/13 17:35:49 vince Exp $";
d240 1
a240 1
			CFBcrypt((char *)&pp + i, DES_DECRYPT, cipher, c_ideakey, c_schedule1, c_schedule2, c_schedule3);
@


1.74
log
@safety
@
text
@d3 3
a5 3
 * $Header: /res/usr/vince/src/stel/RCS/steld.c,v 1.73 1995/07/13 11:03:57 vince Exp $
 * $Date: 1995/07/13 11:03:57 $
 * $Revision: 1.73 $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: steld.c,v 1.73 1995/07/13 11:03:57 vince Exp $";
d38 2
d41 1
d79 2
a80 2
	int	s, fh;
	int	i, iflg, kflg, portnum;
d82 1
d90 1
a90 1
	iflg = kflg = 0;
d92 1
a92 1
	while ((i = getopt(argc, argv, "ikp:")) != EOF)
a93 4
			/* Use inetd  (runs standalone by default) */
			case	'i': /* use inetd */
				iflg++;
				break;
d103 2
a104 2
				(void)fprintf(stderr, "option -%c ignored\n", i);
				syslog(LOGPRI, "option -%c ignored", i);
d108 5
a112 8
	/* inetd makes things much simpler */
	if (iflg) {
		char	*p, *peername();

		if ((p = peername(0)) == NULL)
			exit(1);
		(void)strcpy((char *)fromhost, p);
		syslog(LOGPRI, "connection from %s", fromhost);
d115 1
a116 1
#ifndef linux
a132 1

d142 4
a145 2
	printf("%s %s starting, pid: %d\n", PRGNAME, versionstring, getpid());
	syslog(LOGPRI, "%s %s started, PID = %d", PRGNAME, versionstring, getpid());
d200 1
d247 1
a247 1
	MD5Final(&mdContext);
d251 1
a251 1
	if (memcmp(mdContext.digest, pp.digest, 16))
d422 1
d424 3
@


1.73
log
@safety
@
text
@d3 3
a5 3
 * $Header: /res/usr/vince/src/stel/RCS/steld.c,v 1.72 1995/07/12 16:44:00 vince Exp $
 * $Date: 1995/07/12 16:44:00 $
 * $Revision: 1.72 $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: steld.c,v 1.72 1995/07/12 16:44:00 vince Exp $";
d467 4
a470 3
		if (chmod(line, 0622) == -1 ||
		    chown(line, pwd->pw_uid, pwd->pw_gid) == -1) {
			(void)fprintf(stderr, "cannot chown terminal line\n");
d566 2
d569 6
a574 6
	utmp_id = MAKE_UTMP_ID(ttyn, "tn");
	UTMP_INIT(tty, ".telnet", utmp_id);
        if (UTMP_LOGIN(tty, username, fromhost) != 0) {
		syslog(LOGPRI, "UTMP_INIT() failed");
                sleepexit(1);
        }
d576 2
a577 2
        {
                struct utmp utmp;
d579 3
a581 3
                memset((char *)&utmp, 0, sizeof(utmp));
                (void)time(&utmp.ut_time);
                strncpy(utmp.ut_name, username, sizeof(utmp.ut_name));
d583 1
a583 1
                strncpy(utmp.ut_host, fromhost, sizeof(utmp.ut_host));
d585 3
a587 3
                strncpy(utmp.ut_line, tty, sizeof(utmp.ut_line));
                login(&utmp);
        }
d592 5
a596 5
	/* turn auditing on */
	if (setaudproc(1)) {
		syslog(LOGPRI, "setaudproc(): %m");
		sleepexit(1);
	}
d599 1
a599 1
	(void)initgroups(pwd->pw_name, -1);
d601 2
a602 1
	if (setgid(pwd->pw_gid) || setresuid(pwd->pw_uid, pwd->pw_uid, 0))
d604 1
a604 1
	if (setgid(pwd->pw_gid) || setuid(pwd->pw_uid))
d607 3
a609 2
		(void)fprintf(stderr, "can not set user IDs");
		sleepexit(1);
d642 4
d774 1
a774 1
			syslog(LOGPRI, "open(%s): %m", ttyline);
d834 1
a834 1
			syslog(LOGPRI, "open(ttyline): %m");
@


1.72
log
@safety
@
text
@d3 3
a5 3
 * $Header: /res/usr/vince/src/stel/RCS/steld.c,v 1.71 1995/07/08 15:48:56 vince Exp $
 * $Date: 1995/07/08 15:48:56 $
 * $Revision: 1.71 $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: steld.c,v 1.71 1995/07/08 15:48:56 vince Exp $";
d86 1
a86 1
	iflg = kflg = errflg = 0;
a104 1
				errflg++;
@


1.71
log
@safety
@
text
@d3 3
a5 3
 * $Header: /res/usr/vince/src/stel/RCS/steld.c,v 1.70 1995/05/10 18:00:18 vince Exp $
 * $Date: 1995/05/10 18:00:18 $
 * $Revision: 1.70 $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: steld.c,v 1.70 1995/05/10 18:00:18 vince Exp $";
d54 5
a58 1
/* DES stuff */
d60 3
a62 2
extern des_key_schedule	schedule1, schedule2;
extern des_cblock	IV;
d77 2
a78 1
	int	i, iflg = 0, kflg = 0;
d86 3
a88 1
	while ((i = getopt(argc, argv, "i")) != EOF)
d98 3
d105 1
a108 1

d142 1
a142 1
	if ((s = establish()) == -1)
d198 1
a198 1
	int		i, ret;
d231 1
a231 1
			ideacfb(&pp, sizeof(pp));
d234 1
a234 6
			des_cbc_encrypt((des_cblock *)&pp, (des_cblock *)&pp,
				sizeof(pp), schedule1, (des_cblock *)IV, DES_DECRYPT);
			des_cbc_encrypt((des_cblock *)&pp, (des_cblock *)&pp,
				sizeof(pp), schedule2, (des_cblock *)IV, DES_ENCRYPT);
			des_cbc_encrypt((des_cblock *)&pp, (des_cblock *)&pp,
				sizeof(pp), schedule1, (des_cblock *)IV, DES_DECRYPT);
d237 1
a237 2
			des_cbc_encrypt((des_cblock *)&pp, (des_cblock *)&pp,
				sizeof(pp), schedule1, (des_cblock *)IV, DES_DECRYPT);
d239 4
@


1.70
log
@safety
@
text
@d3 3
a5 3
 * $Header: /res/usr/vince/src/stel/RCS/steld.c,v 1.69 1995/05/10 15:10:14 vince Exp $
 * $Date: 1995/05/10 15:10:14 $
 * $Revision: 1.69 $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: steld.c,v 1.69 1995/05/10 15:10:14 vince Exp $";
d59 2
d136 2
a137 2
	printf("steld starting, pid: %d\n", getpid());
	syslog(LOGPRI, "server started, PID = %d", getpid());
d264 6
d273 1
a273 1
		exit(1);
@


1.69
log
@safety
@
text
@d3 4
a6 4
 * $Header: /res/usr/vince/src/stel/RCS/steld.c,v 1.68 1995/05/06 15:39:00 vince Exp vince $
 * $Date: 1995/05/06 15:39:00 $
 * $Revision: 1.68 $
 * $Locker: vince $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: steld.c,v 1.68 1995/05/06 15:39:00 vince Exp vince $";
d29 4
a41 13
/* This is Venema's code */

#ifndef __ultrix
#ifdef HAS_UTMPX
#include <utmpx.h>
#else /* HAS_UTMPX */
#include <utmp.h>
#endif /* HAS_UTMPX */
#ifndef UT_NAMESIZE
#define UT_NAMESIZE     sizeof(((struct UTMP_STRUCT *)0)->ut_name)
#endif /* UT_NAMESIZE */
#endif

d544 1
a544 1
        if (tty = (char *) strchr(ttyn + 1, '/'))
d699 1
a699 1
		/* p[strlen(p) - 2] = '\0'; /* remote \n\r */
d728 1
@


1.68
log
@safety
@
text
@d3 4
a6 4
 * $Header: /res/usr/vince/src/stel/RCS/steld.c,v 1.67 1995/04/22 11:13:50 vince Exp $
 * $Date: 1995/04/22 11:13:50 $
 * $Revision: 1.67 $
 * $Locker:  $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: steld.c,v 1.67 1995/04/22 11:13:50 vince Exp $";
d40 1
d49 1
d81 3
d85 1
d317 2
d340 9
a348 4
			(void)close(pfdout[0]);
			(void)close(pfdout[1]);
			(void)close(pfdin[0]);
			(void)close(pfdin[1]);
d358 2
a359 1
			setterminal(usepty, ttyline, pfdin, pfdout);
d743 1
a743 1
setterminal(usepty, ttyline, pfdin, pfdout)
d746 1
d748 2
a749 1
	int	i;
d787 3
d801 7
a807 20
/*
		(void)close(0);
		(void)close(1);
		(void)close(2);

		if (dup(t) != 0 || dup(0) != 1 || dup (0) != 2)  {
			syslog(LOGPRI, "dup(): %m");
			exit(1);
		}
*/

/*
#if defined(SUNOS4) || defined(SOLARIS)
		if (setpgrp(getuid(), 0) == -1)
#else
		if (setpgrp() == -1)
#endif
					{
			syslog(LOGPRI, "setpgrp(): %m");
			exit(1);
a808 1
*/
@


1.67
log
@safety
@
text
@d3 3
a5 3
 * $Header: /res/usr/vince/src/stel/RCS/steld.c,v 1.66 1995/04/22 09:42:58 vince Exp $
 * $Date: 1995/04/22 09:42:58 $
 * $Revision: 1.66 $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: steld.c,v 1.66 1995/04/22 09:42:58 vince Exp $";
d132 1
a132 1
	if ((s = establish(PORTNUM)) == -1)
d496 2
a497 1
		fgets(skeybuf, sizeof(skeybuf), stdin);
d634 1
@


1.66
log
@safety
@
text
@d3 3
a5 3
 * $Header: /res/usr/vince/src/stel/RCS/steld.c,v 1.65 1995/04/21 19:17:40 vince Exp $
 * $Date: 1995/04/21 19:17:40 $
 * $Revision: 1.65 $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: steld.c,v 1.65 1995/04/21 19:17:40 vince Exp $";
d469 3
d674 1
a674 1
	if ((pwd = shadow_getpwnam((char *) username)) == NULL)
@


1.65
log
@safety
@
text
@d3 3
a5 3
 * $Header: /res/usr/vince/src/stel/RCS/steld.c,v 1.64 1995/04/21 18:27:26 vince Exp $
 * $Date: 1995/04/21 18:27:26 $
 * $Revision: 1.64 $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: steld.c,v 1.64 1995/04/21 18:27:26 vince Exp $";
d79 1
a79 1
	(void)openlog("steld", LOG_PID | LOG_ODELAY, LOG_DAEMON);
d253 1
a253 1
		if ((authbuf2 = getetcstelsecret()) != NULL)
d281 2
a282 2
	if (smessage & MSG_LOGIN_AUTH_REQUIRED) {
		ret = mauth(fh, authbuf, SERVER_SIDE, firstack);
d284 1
a284 1
			syslog(LOGPRI, "mauth(%s): %m", STEL_SECRET_NAME);
d289 1
a289 1
							STEL_SECRET_NAME);
d295 2
a296 2
	if (smessage & MSG_SYSTEM_AUTH_REQUIRED) {
		ret = mauth(fh, authbuf2, SERVER_SIDE, firstack);
d298 1
a298 1
			syslog(LOGPRI, "mauth(%s): %m", ETC_STEL_SECRET_NAME);
d303 1
a303 1
							ETC_STEL_SECRET_NAME);
@


1.64
log
@safety
@
text
@d3 3
a5 3
 * $Header: /res/usr/vince/src/stel/RCS/steld.c,v 1.63 1995/04/08 15:48:43 vince Exp $
 * $Date: 1995/04/08 15:48:43 $
 * $Revision: 1.63 $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: steld.c,v 1.63 1995/04/08 15:48:43 vince Exp $";
d199 1
a199 1
	(void)strcpy((char *)username, "unknown");
@


1.63
log
@safety
@
text
@d3 3
a5 3
 * $Header: /res/usr/vince/src/stel/RCS/steld.c,v 1.62 1995/04/08 14:38:50 vince Exp $
 * $Date: 1995/04/08 14:38:50 $
 * $Revision: 1.62 $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: steld.c,v 1.62 1995/04/08 14:38:50 vince Exp $";
d79 1
a79 1
	(void)openlog(PRGNAME, LOG_PID | LOG_ODELAY, LOG_DAEMON);
d137 1
a137 1
	printf("%s starting, pid: %d\n", PRGNAME, getpid());
d190 1
a190 1
	char		ttyline[16], *p, *authbuf;
d194 1
a194 1
	char		*getstelsecret();
d246 17
a262 9
		smessage = MSG_CORRUPTED_DATA;
	/* if ~/.stelsecret exists we refuse client's requests not to
	use encryption. stelsecret is considered as an addictional
	protection to the user's account */
	else if ((authbuf = getstelsecret(pp.username)) != NULL) {
		if (firstack & FLG_NO_ENCRYPTION)
			smessage = MSG_MUST_AUTH;
		else
			smessage = MSG_AUTH_REQUIRED;
d271 9
a279 3
	switch (smessage) {
		case	MSG_OKAY_DATA:
			break;
d281 9
a289 2
		case	MSG_CORRUPTED_DATA:
			syslog(LOGPRI, "received CORRUPTED data from client");
d291 3
d295 9
a303 15
		case	MSG_AUTH_REQUIRED:
			ret = mauth(fh, authbuf, SERVER_SIDE, firstack);
			if (ret == -1) {
				syslog(LOGPRI, "mauth(): %m");
				return(1);
			}
			else if (ret == 1) {
				syslog(LOGPRI, "MUTUAL AUTHENTICATION FAILED");
				return(1);
			}
			/* authentication succeeded */
			break;

		case	MSG_MUST_AUTH:
			syslog(LOGPRI, "Client NO ENCRYPTION request rejected");
d305 2
d933 1
a933 1
	(void)sprintf(filename, "%s/.%s", pwd->pw_dir, STEL_SECRET_NAME);
@


1.62
log
@safety
@
text
@d3 4
a6 4
 * $Header: /res/usr/vince/src/stel/RCS/steld.c,v 1.61 1995/04/08 11:18:38 vince Exp vince $
 * $Date: 1995/04/08 11:18:38 $
 * $Revision: 1.61 $
 * $Locker: vince $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: steld.c,v 1.61 1995/04/08 11:18:38 vince Exp vince $";
d466 1
a466 5
		if (usepty)
			printf("S/KEY authentication required (erase character is '%s')\n",
						control(ERASECHAR));
		else
			printf("S/KEY authentication required\n");
d468 1
a468 3
		/*
		printf("[%s]\n",skeyprompt);
		*/
d470 1
@


1.61
log
@safety
@
text
@d3 4
a6 4
 * $Header: /res/usr/vince/src/stel/RCS/steld.c,v 1.60 1995/04/05 16:35:14 vince Exp $
 * $Date: 1995/04/05 16:35:14 $
 * $Revision: 1.60 $
 * $Locker:  $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: steld.c,v 1.60 1995/04/05 16:35:14 vince Exp $";
d453 1
a453 1
			if (!sdiauth(username))
d466 2
a467 1
		printf("S/KEY authentication required (erase character is '%s')\n",
d469 3
d670 1
a670 3
		fprintf(stderr, "WARNING: terminal echo turned ON!\n");
		(void)fflush(stderr);
		fprintf(stderr, "Password: ");
a750 1

@


1.60
log
@safety
@
text
@d3 3
a5 3
 * $Header: /res/usr/vince/src/stel/RCS/steld.c,v 1.59 1995/03/31 19:34:43 vince Exp $
 * $Date: 1995/03/31 19:34:43 $
 * $Revision: 1.59 $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: steld.c,v 1.59 1995/03/31 19:34:43 vince Exp $";
d53 8
d249 1
a249 1
	account protection */
d466 3
a468 1
		printf("S/KEY authentication required\n");
d470 2
d750 2
a751 2
		b.c_cc[VERASE] = 0x7f;
		b.c_cc[VKILL] = 'u'&0x1f;
d753 1
a753 1
		b.c_cc[VINTR] = 0x3;
@


1.59
log
@safety
@
text
@d3 3
a5 3
 * $Header: /res/usr/vince/src/stel/RCS/steld.c,v 1.58 1995/02/27 15:05:32 vince Exp $
 * $Date: 1995/02/27 15:05:32 $
 * $Revision: 1.58 $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: steld.c,v 1.58 1995/02/27 15:05:32 vince Exp $";
d21 1
d102 1
d109 1
d143 1
d151 1
d179 2
a180 1
	int		child, firstack, smessage, pty, usepty = 0, ret;
d197 1
d249 2
a250 1
	if (write(fh, &smessage, sizeof(smessage)) != sizeof(smessage)) {
d282 1
@


1.58
log
@safety
@
text
@d3 3
a5 3
 * $Header: /res/usr/vince/src/stel/RCS/steld.c,v 1.56 1995/02/27 11:43:39 vince Exp $
 * $Date: 1995/02/27 11:43:39 $
 * $Revision: 1.56 $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: steld.c,v 1.56 1995/02/27 11:43:39 vince Exp $";
d14 1
a16 1
#include <termios.h>
d21 1
a21 1
#ifdef sun
d28 5
a37 1
#include "sys_defs.h"
d48 2
d312 6
d666 2
a667 1
#ifdef sun
d672 2
d690 2
d697 2
a698 7
#ifdef sun
		if (setpgrp(getuid(), 0) == -1)
#else
		if (setpgrp() == -1)
#endif
					{
			syslog(LOGPRI, "setpgrp(): %m");
d702 5
a706 2
		if ((t = open(ttyline, O_RDWR)) == -1) {
			syslog(LOGPRI, "open(%s): %m", ttyline);
d709 1
a709 1

d715 1
d728 1
d739 2
d749 32
d789 1
a789 1
#ifdef sun
d814 1
a814 1
/* fix: OK for sun, hpux */
d820 1
a820 1
#ifdef sun
d822 4
d830 1
a830 1
#ifdef sun
d836 6
@


1.57
log
@safety
@
text
@d263 1
a263 1
			syslog(LOGPRI, "-n option from client rejected");
@


1.56
log
@safety
@
text
@d3 4
a6 4
 * $Header: /res/usr/vince/src/stel/RCS/steld.c,v 1.55 1995/02/27 11:42:10 vince Exp vince $
 * $Date: 1995/02/27 11:42:10 $
 * $Revision: 1.55 $
 * $Locker: vince $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: steld.c,v 1.55 1995/02/27 11:42:10 vince Exp vince $";
d261 4
d817 2
a818 2
getstelsecret(username)
char	*username;
d826 1
a826 1
	if ((pwd = getpwnam(username)) == NULL)
d831 1
a831 1
		syslog(LOGPRI, "homedir name for %s is too large", username);
@


1.55
log
@safety
@
text
@d3 4
a6 4
 * $Header: /res/usr/vince/src/stel/RCS/steld.c,v 1.54 1995/02/27 10:46:19 vince Exp $
 * $Date: 1995/02/27 10:46:19 $
 * $Revision: 1.54 $
 * $Locker:  $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: steld.c,v 1.54 1995/02/27 10:46:19 vince Exp $";
d226 1
a226 1
	/* if ~/.stelsecret exists we refuse client's request no to
@


1.54
log
@safety
@
text
@d3 3
a5 3
 * $Header: /res/usr/vince/src/stel/RCS/steld.c,v 1.53 1995/02/25 15:26:39 vince Exp $
 * $Date: 1995/02/25 15:26:39 $
 * $Revision: 1.53 $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: steld.c,v 1.53 1995/02/25 15:26:39 vince Exp $";
d226 9
a234 2
	else if ((authbuf = getstelsecret(pp.username)) != NULL)
		smessage = MSG_AUTH_REQUIRED;
@


1.53
log
@safety
@
text
@d3 3
a5 3
 * $Header: /res/usr/vince/src/stel/RCS/steld.c,v 1.52 1995/02/23 17:14:54 vince Exp $
 * $Date: 1995/02/23 17:14:54 $
 * $Revision: 1.52 $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: steld.c,v 1.52 1995/02/23 17:14:54 vince Exp $";
d243 1
a243 1
			ret = mauth(fh, authbuf, SERVER_SIDE);
@


1.52
log
@safety
@
text
@d3 4
a6 4
 * $Header: /res/usr/vince/src/stel/RCS/steld.c,v 1.51 1995/02/23 15:49:43 vince Exp vince $
 * $Date: 1995/02/23 15:49:43 $
 * $Revision: 1.51 $
 * $Locker: vince $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: steld.c,v 1.51 1995/02/23 15:49:43 vince Exp vince $";
d44 2
d535 1
@


1.51
log
@safety
@
text
@d3 4
a6 4
 * $Header: /res/usr/vince/src/stel/RCS/steld.c,v 1.50 1995/02/21 20:50:15 vince Exp $
 * $Date: 1995/02/21 20:50:15 $
 * $Revision: 1.50 $
 * $Locker:  $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: steld.c,v 1.50 1995/02/21 20:50:15 vince Exp $";
d197 1
a197 1
		if (firstack & FLG_USE_IDEA)
d199 1
d391 1
d393 1
@


1.50
log
@safety
@
text
@d3 4
a6 4
 * $Header: /res/usr/vince/src/stel/RCS/steld.c,v 1.49 1995/02/21 17:34:49 vince Exp vince $
 * $Date: 1995/02/21 17:34:49 $
 * $Revision: 1.49 $
 * $Locker: vince $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: steld.c,v 1.49 1995/02/21 17:34:49 vince Exp vince $";
d527 1
d529 1
d814 1
a814 1
		syslog(LOGPRI, "home dir for %s too large", username);
@


1.49
log
@safety
@
text
@d3 4
a6 4
 * $Header: /res/usr/vince/src/stel/RCS/steld.c,v 1.48 1995/02/20 13:43:47 vince Exp $
 * $Date: 1995/02/20 13:43:47 $
 * $Revision: 1.48 $
 * $Locker:  $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: steld.c,v 1.48 1995/02/20 13:43:47 vince Exp $";
d20 1
d166 1
a166 1
	int		child, firstack, pty, usepty = 0, ret;
d168 1
a168 1
	char		ttyline[16], *p;
d172 2
d219 32
a250 3
	if (memcmp(mdContext.digest, pp.digest, 16)) {
		syslog(LOGPRI, "received CORRUPTED data from client");
		return(1);
d795 45
@


1.48
log
@safety
@
text
@d3 3
a5 3
 * $Header: /res/usr/vince/src/stel/RCS/steld.c,v 1.47 1995/02/20 13:33:59 vince Exp $
 * $Date: 1995/02/20 13:33:59 $
 * $Revision: 1.47 $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: steld.c,v 1.47 1995/02/20 13:33:59 vince Exp $";
d59 1
a59 1
	int	i, iflg = 0;;
d65 2
a66 1
			case	'i':
d69 4
d90 8
a97 3
		/* kill IP_PROTO options */
		if (killoptions(0, fromhost)) { /* can't kill IP_OPTIONS */
			exit(1);
d130 1
d132 6
a137 4
		if (killoptions(fh, fromhost)) { /* can't kill IP_OPTIONS */
			(void)shutdown(fh, 2);
			(void)close(fh);
			continue;
@


1.47
log
@safety
@
text
@d3 3
a5 3
 * $Header: /res/usr/vince/src/stel/RCS/steld.c,v 1.46 1995/02/20 10:10:16 vince Exp $
 * $Date: 1995/02/20 10:10:16 $
 * $Revision: 1.46 $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: steld.c,v 1.46 1995/02/20 10:10:16 vince Exp $";
d344 2
@


1.46
log
@safety
@
text
@d3 3
a5 3
 * $Header: /res/usr/vince/src/stel/RCS/steld.c,v 1.45 1995/02/16 14:55:10 vince Exp $
 * $Date: 1995/02/16 14:55:10 $
 * $Revision: 1.45 $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: steld.c,v 1.45 1995/02/16 14:55:10 vince Exp $";
d26 2
d152 5
a156 6
	int	child, firstack, pty, usepty = 0;
	int	pfdin[2], pfdout[2];
	char	ttyline[16];
	int	ret;
	void	timeexpired();
	char	*p;
d195 11
@


1.45
log
@safety
@
text
@d3 4
a6 4
 * $Header: /res/usr/vince/src/stel/RCS/steld.c,v 1.44 1995/02/15 16:53:25 vince Exp vince $
 * $Date: 1995/02/15 16:53:25 $
 * $Revision: 1.44 $
 * $Locker: vince $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: steld.c,v 1.44 1995/02/15 16:53:25 vince Exp vince $";
d41 1
a41 1
#ifndef IDEA
d43 1
a43 2

extern des_key_schedule	schedule1;
a44 1
#endif
d150 1
a150 1
	int	child, cryptflg, pty, usepty = 0, transfermode = 0;
d162 2
a163 2
	if (read(fh, &cryptflg, sizeof(cryptflg)) == -1) {
		syslog(LOGPRI, "read(cryptflg): %m");
d167 2
a168 2
	if (cryptflg == FLG_USE_ENCRYPTION) {
		if (dhexchange(fh, 1, 0, NULL) < 0) {
d179 15
a193 7
	if (cryptflg == FLG_USE_ENCRYPTION) {
#ifdef IDEA
		ideacfb(&pp, sizeof(pp));
#else
		des_cbc_encrypt((des_cblock *)&pp, (des_cblock *)&pp,
			sizeof(pp), schedule1, (des_cblock *)IV, DES_DECRYPT);
#endif
a198 2
	if (pp.mode & FLG_TRANSFER_MODE)
		transfermode = 1;
d232 1
a232 1
			runshell(&pp, usepty, transfermode);
d240 1
a240 1
		if (makeio(pty, pty, fh, cryptflg, NULL, NULL, NULL)) {
d267 1
a267 1
		if (makeio(pfdin[0], pfdout[1], fh, cryptflg, 0)) {
d285 1
a285 1
runshell(pp, usepty, transfermode)
d287 1
a287 1
int	usepty, transfermode;
d386 1
a386 1
		if (mkunixauth(usepty, transfermode, nosuchuser)) {
d533 2
a534 2
mkunixauth(usepty, transfermode, fail)
int	usepty, transfermode, fail;
d555 4
a558 6
		if (!transfermode) {
			fprintf(stderr, "WARNING: terminal echo turned ON!\n");
			(void)fflush(stderr);
			fprintf(stderr, "Password: ");
		}
		(void)fflush(stdout);
@


1.44
log
@safety
@
text
@d3 4
a6 4
 * $Header: /res/usr/vince/src/stel/RCS/steld.c,v 1.43 1995/02/15 15:51:15 vince Exp $
 * $Date: 1995/02/15 15:51:15 $
 * $Revision: 1.43 $
 * $Locker:  $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: steld.c,v 1.43 1995/02/15 15:51:15 vince Exp $";
d170 1
a170 1
		if (dhexchange(fh, 1, 0) < 0) {
a372 1
		/* fix: dotted notation, 4th field */
@


1.43
log
@safety
@
text
@d3 4
a6 4
 * $Header: /res/usr/vince/src/stel/RCS/steld.c,v 1.42 1995/02/15 15:49:15 vince Exp vince $
 * $Date: 1995/02/15 15:49:15 $
 * $Revision: 1.42 $
 * $Locker: vince $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: steld.c,v 1.42 1995/02/15 15:49:15 vince Exp vince $";
d155 1
a155 1

d157 1
d234 1
a235 3
		char	*p;
		int	ret = 0;

a236 2
			(void)signal(SIGCLD, fireman);
			(void)kill(child, SIGKILL);
d240 5
a263 2
			(void)signal(SIGCLD, fireman);
			(void)kill(child, SIGKILL);
d265 1
a265 1
			return(1);
d267 5
@


1.42
log
@safety
@
text
@d3 3
a5 3
 * $Header: /res/usr/vince/src/stel/RCS/steld.c,v 1.41 1995/02/06 20:55:46 vince Exp vince $
 * $Date: 1995/02/06 20:55:46 $
 * $Revision: 1.41 $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: steld.c,v 1.41 1995/02/06 20:55:46 vince Exp vince $";
a347 2

		pause();
@


1.41
log
@safety
@
text
@d3 3
a5 3
 * $Header: /res/usr/vince/src/stel/RCS/steld.c,v 1.40 1995/01/24 15:55:43 vince Exp vince $
 * $Date: 1995/01/24 15:55:43 $
 * $Revision: 1.40 $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: steld.c,v 1.40 1995/01/24 15:55:43 vince Exp vince $";
d156 1
a156 1
	void	timeout();
d158 1
a158 1
	(void)signal(SIGALRM, timeout);
d349 2
a368 1

d582 1
a582 1
timeout(s)
d584 1
a584 1
	(void)signal(s, timeout);
@


1.40
log
@safety
@
text
@d3 3
a5 3
 * $Header: /res/usr/vince/src/stel/RCS/steld.c,v 1.39 1995/01/24 10:05:30 vince Exp vince $
 * $Date: 1995/01/24 10:05:30 $
 * $Revision: 1.39 $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: steld.c,v 1.39 1995/01/24 10:05:30 vince Exp vince $";
d92 2
a93 1

d222 4
d470 4
@


1.39
log
@safety
@
text
@d3 3
a5 3
 * $Header: /res/usr/vince/src/stel/RCS/steld.c,v 1.38 1995/01/24 10:04:40 vince Exp vince $
 * $Date: 1995/01/24 10:04:40 $
 * $Revision: 1.38 $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: steld.c,v 1.38 1995/01/24 10:04:40 vince Exp vince $";
d70 2
a71 3
				(void)fprintf(stderr, "option - %c ignored\n",
								optopt);
				syslog(LOGPRI, "option - %c ignored", optopt);
d456 1
@


1.38
log
@safety
@
text
@d3 4
a6 4
 * $Header: /res/usr/vince/src/stel/RCS/steld.c,v 1.37 1995/01/21 16:35:47 vince Exp $
 * $Date: 1995/01/21 16:35:47 $
 * $Revision: 1.37 $
 * $Locker:  $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: steld.c,v 1.37 1995/01/21 16:35:47 vince Exp $";
d290 1
a290 1
		"%s LOGIN attempted (user not existent), from %s",
@


1.37
log
@safety
@
text
@d3 3
a5 3
 * $Header: /res/usr/vince/src/stel/RCS/steld.c,v 1.36 1995/01/21 15:05:14 vince Exp $
 * $Date: 1995/01/21 15:05:14 $
 * $Revision: 1.36 $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: steld.c,v 1.36 1995/01/21 15:05:14 vince Exp $";
d282 1
a282 1
	int		cnt;
d289 2
a290 1
		syslog(LOGPRI, "%s non existent in /etc/passwd, from %s",
d292 2
a293 2
		puts("Login incorrect");
		sleepexit(1);
d375 1
a375 1
		if (mkunixauth(usepty, transfermode)) {
d517 2
a518 2
mkunixauth(usepty, transfermode)
int	usepty;
d549 3
@


1.36
log
@safety
@
text
@d3 3
a5 3
 * $Header: /res/usr/vince/src/stel/RCS/steld.c,v 1.35 1995/01/21 14:25:24 vince Exp $
 * $Date: 1995/01/21 14:25:24 $
 * $Revision: 1.35 $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: steld.c,v 1.35 1995/01/21 14:25:24 vince Exp $";
a320 2
		break;

@


1.35
log
@safety
@
text
@d3 3
a5 3
 * $Header: /res/usr/vince/src/stel/RCS/steld.c,v 1.34 1995/01/19 12:46:07 vince Exp $
 * $Date: 1995/01/19 12:46:07 $
 * $Revision: 1.34 $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: steld.c,v 1.34 1995/01/19 12:46:07 vince Exp $";
d233 1
a233 1
		if (makeio(pty, pty, fh, cryptflg, NULL, NULL)) {
@


1.34
log
@safety
@
text
@d3 4
a6 4
 * $Header: /res/usr/vince/src/stel/RCS/steld.c,v 1.33 1995/01/18 16:15:56 vince Exp vince $
 * $Date: 1995/01/18 16:15:56 $
 * $Revision: 1.33 $
 * $Locker: vince $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: steld.c,v 1.33 1995/01/18 16:15:56 vince Exp vince $";
d233 1
a233 1
		if (makeio(pty, pty, fh, cryptflg)) {
d257 1
a257 1
		if (makeio(pfdin[0], pfdout[1], fh, cryptflg)) {
@


1.33
log
@safety
@
text
@d3 4
a6 4
 * $Header: /res/usr/vince/src/stel/RCS/steld.c,v 1.32 1995/01/03 11:57:27 vince Exp $
 * $Date: 1995/01/03 11:57:27 $
 * $Revision: 1.32 $
 * $Locker:  $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: steld.c,v 1.32 1995/01/03 11:57:27 vince Exp $";
a52 1
static connection;
d54 3
a56 1
main()
a57 1
#ifdef STANDALONE
d59 1
d61 37
a101 2
	(void)openlog(PRGNAME, LOG_PID | LOG_ODELAY, LOG_DAEMON);

d118 9
a126 2
		syslog(LOGPRI, "incoming connection from %s", fromhost);
		connection++;
d135 2
a136 2
				syslog(LOGPRI, "closed connection #%d from %s",
							connection, fromhost);
a142 12
#else /* !STANDALONE */
	char	*p, *peername();

	if ((p = peername(0)) == NULL)
		exit(1);
	(void)strcpy(fromhost, p);
	syslog(LOGPRI, "connection from %s", fromhost);
	(void)serveclient(0);
	syslog(LOGPRI, "closed connection #%d from %s", connection, fromhost);

	exit(0);
#endif /* STANDALONE */
d223 1
a223 1
			runshell(pp.command, usepty, transfermode);
d236 1
a236 2
			syslog(LOGPRI, "lost connection #%d from %s",
							connection, fromhost);
d260 1
a260 2
			syslog(LOGPRI, "lost connection #%d from %s",
							connection, fromhost);
a268 1
#define MAX_ENV_NUM     15
a270 1
char    *envinit[MAX_ENV_NUM] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
d272 2
a273 2
runshell(command, usepty, transfermode)
char	*command;
d289 3
a291 2
		(void)fprintf(stderr, "%s non-existent in /etc/passwd\n",	
								username);
d321 2
d327 2
a328 2
			"%s REPEATED LOGIN FAILURES from %s, connection #%d",
					username, fromhost, connection);
d339 2
a340 3
			syslog(LOGPRI,
			"%s SECURID LOGIN FAILURE from %s, connection #%d",
					username, fromhost, connection);
d357 2
a358 3
			syslog(LOGPRI,
			"%s SKEY LOGIN FAILURE from %s, connection #%d",
					username, fromhost, connection);
d369 2
a370 2
		"UNIX PASSWORDS NOT PERMITTED for %s, from %s, connection #%d",
				username, fromhost, connection);
d377 2
a378 3
			syslog(LOGPRI,
			"%s LOGIN FAILURE from %s, connection #%d",
					username, fromhost, connection);
d453 5
a457 1
	    putvar("TERM",	getenv("TERM"))	||
d467 1
a467 1
	if (command[0] == '\0') {
d474 2
a475 2
		syslog(LOGPRI, "%s LOGIN from %s, %s, \"%s\", connection #%d",
			username, fromhost, line, pwd->pw_shell, connection);
d477 2
a478 2
		(void)execle(pwd->pw_shell, minusnam, 0, &envinit[0]);
		syslog(LOGPRI, "execle(%s): %m", pwd->pw_shell);
d483 3
a485 3
		syslog(LOGPRI, "%s LOGIN from %s, %s, \"%s\", connection #%d",
			username, fromhost, line, command, connection);
		if ((status = system(command)) == -1) {
d490 1
a490 2
			syslog(LOGPRI, "command failed \"%s\", connection #%d",
				command, connection);
a500 1
	static int	envcount;
a506 2
	if (envcount == MAX_ENV_NUM - 1)	
		return(1);
d512 2
a513 1
	envinit[envcount++] = p;
d573 1
a573 2
	syslog(LOGPRI, "time expired for %s from %s, connection #%d",
				username, fromhost, connection);
@


1.32
log
@safety
@
text
@d3 3
a5 3
 * $Header: /res/usr/vince/src/stel/RCS/steld.c,v 1.30 1994/12/30 11:23:59 vince Exp $
 * $Date: 1994/12/30 11:23:59 $
 * $Revision: 1.30 $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: steld.c,v 1.30 1994/12/30 11:23:59 vince Exp $";
d355 2
@


1.31
log
@safety
@
text
@d331 1
a331 1
			puts("Invalid response.");
d352 1
a352 1
			puts("Login incorrect.");
d362 1
a362 1
		puts("Permission denied.");
@


1.30
log
@safety
@
text
@d3 3
a5 3
 * $Header: /res/usr/vince/src/stel/RCS/steld.c,v 1.27 1994/12/29 17:13:37 vince Exp $
 * $Date: 1994/12/29 17:13:37 $
 * $Revision: 1.27 $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: steld.c,v 1.27 1994/12/29 17:13:37 vince Exp $";
d255 1
d264 1
a264 1
		exit(1);
d270 1
a270 1
			exit(1);
d279 1
a279 1
			exit(1);
d287 1
a287 1
			exit(1);
d291 12
a302 4
	/*
	goto authenticated;
	*/

d304 7
a310 6
	/* sdi securID authentication */
	if (issdiregistered(username)) {
		printf("SECURID authentication required\n");
		if (!sdiauth(username))
			goto authenticated;
		syslog(LOGPRI, "%s SECURID LOGIN FAILURE from %s, connection #%d",
d312 1
a312 1
		exit(1);
d314 1
a314 1
	}
d317 13
a329 12
	/* skey authentication */
	skeyprompt[0] = '\0';
	if (skeychallenge(&skey, (char *)username, skeyprompt))
		goto unixauth;
	printf("S/KEY authentication required\n");
	printf("[%s]\n",skeyprompt);
	printf("Response: ");
	(void)fflush(stdout);
	fgets(skeybuf, sizeof(skeybuf), stdin);
	rip(skeybuf);
	if (skeyverify(&skey, skeybuf))  {
		syslog(LOGPRI, "%s SKEY LOGIN FAILURE from %s, connection #%d",
d331 5
a335 5
		puts("Invalid response.");
		exit(1);
	}
	else
		goto authenticated;
d338 3
a340 2
	if (!skeyaccess(username, tty, fromhost, fromhost)) {
		syslog(LOGPRI,
d342 9
a350 8
			username, fromhost, connection);
		puts("UNIX passwords NOT permitted.");
		exit(1);
	}
	/* unix password authentication */
	printf("UNIX password authentication required\n");
	if (mkunixauth(usepty, transfermode)) {
		syslog(LOGPRI, "%s LOGIN FAILURE from %s, connection #%d",
d352 3
a354 2
		puts("Login incorrect.");
		exit(1);
d363 1
a363 1
		exit(1);
d379 1
a379 1
                exit(1);
d401 1
a401 1
		exit(1);
d413 1
a413 1
		exit(1);
d427 1
a427 1
		exit(1);
d447 1
a447 1
		exit(1);
d454 1
a454 1
			exit(1);
d459 1
a459 1
			exit(1);
d685 7
@


1.29
log
@safety
@
text
@d3 4
a6 4
 * $Header: /res/usr/vince/src/stel/RCS/steld.c,v 1.28 1994/12/29 17:47:18 vince Exp vince $
 * $Date: 1994/12/29 17:47:18 $
 * $Revision: 1.28 $
 * $Locker: vince $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: steld.c,v 1.28 1994/12/29 17:47:18 vince Exp vince $";
d295 10
a304 2
	/* SecurID authentication goes here */
	/* goto authenticated; */
d311 1
a311 1
	printf("(s/key required)\n");
d335 1
d642 1
a642 1
		pwd->pw_passwd = (char *) strdup(pa->pwa_passwd);
d647 24
@


1.28
log
@safety
@
text
@d3 4
a6 4
 * $Header: /res/usr/vince/src/stel/RCS/steld.c,v 1.27 1994/12/29 17:13:37 vince Exp $
 * $Date: 1994/12/29 17:13:37 $
 * $Revision: 1.27 $
 * $Locker:  $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: steld.c,v 1.27 1994/12/29 17:13:37 vince Exp $";
d303 1
@


1.27
log
@safety
@
text
@d3 3
a5 3
 * $Header: /res/usr/vince/src/stel/RCS/steld.c,v 1.26 1994/12/28 12:18:20 vince Exp $
 * $Date: 1994/12/28 12:18:20 $
 * $Revision: 1.26 $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: steld.c,v 1.26 1994/12/28 12:18:20 vince Exp $";
d632 1
a632 1
		pwd->pw_passwd = strdup(pa->pwa_passwd);
@


1.26
log
@safety
@
text
@d3 3
a5 3
 * $Header: /res/usr/vince/src/stel/RCS/steld.c,v 1.25 1994/12/27 18:49:13 vince Exp $
 * $Date: 1994/12/27 18:49:13 $
 * $Revision: 1.25 $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: steld.c,v 1.25 1994/12/27 18:49:13 vince Exp $";
d20 6
d302 1
a302 1
		goto unixauth; /* user not registered or file error */
d309 1
a309 1
		syslog(LOGPRI, "SKEY FAILED for %s from %s, connection #%d",
d318 7
d327 1
a327 1
		syslog(LOGPRI, "UNIXAUTH FAILED for %s from %s, connection #%d",
d336 6
d470 1
d472 1
a472 2
	/* fix: shadow passwords */
	if ((pwd = getpwnam((char *) username)) == NULL)
d614 22
@


1.25
log
@safety
@
text
@d3 4
a6 4
 * $Header: /res/usr/vince/src/stel/RCS/steld.c,v 1.24 1994/12/27 18:21:04 vince Exp vince $
 * $Date: 1994/12/27 18:21:04 $
 * $Revision: 1.24 $
 * $Locker: vince $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: steld.c,v 1.24 1994/12/27 18:21:04 vince Exp vince $";
d147 2
a148 2
		des_cbc_encrypt(&pp, &pp, sizeof(pp), &schedule1, IV,
						DES_DECRYPT);
d239 3
a241 1
runshell(char *command, int usepty, int transfermode)
d284 1
d286 1
d313 1
a313 1
	if (unixauth(usepty, transfermode)) {
d326 1
a326 1
        if (tty = strchr(ttyn + 1, '/'))
d335 2
a336 3
                printf("No utmpx entry.  You must exec \"login\" from the lowest
 level \"sh\".\n");
                exit(0);
d345 1
d347 1
d378 2
d402 1
d409 7
a415 2
		status = system(command);
		if (status & 0177 || status >> 8)
d417 1
d445 1
a445 1
unixauth(usepty, transfermode)
@


1.24
log
@safety
@
text
@d3 4
a6 4
 * $Header: /res/usr/vince/src/stel/RCS/steld.c,v 1.23 1994/12/18 15:06:41 vince Exp $
 * $Date: 1994/12/18 15:06:41 $
 * $Revision: 1.23 $
 * $Locker:  $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: steld.c,v 1.23 1994/12/18 15:06:41 vince Exp $";
d66 1
a66 1
	syslog(LOGPRI, "server started");
d299 1
a299 1
		syslog(LOGPRI, "skey failed for %s from %s, connection #%d",
d310 1
a310 1
		syslog(LOGPRI, "unixauth failed for %s from %s, connection #%d",
d391 1
a391 1
		syslog(LOGPRI, "%s login from %s, %s, \"%s\", connection #%d",
d399 1
a399 1
		syslog(LOGPRI, "%s login from %s, %s, \"%s\", connection #%d",
@


1.23
log
@safety
@
text
@d3 4
a6 4
 * $Header: /res/usr/vince/src/stel/RCS/steld.c,v 1.22 1994/12/18 14:44:44 vince Exp vince $
 * $Date: 1994/12/18 14:44:44 $
 * $Revision: 1.22 $
 * $Locker: vince $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: steld.c,v 1.22 1994/12/18 14:44:44 vince Exp vince $";
d23 12
d43 1
a43 1
void	login();
d186 1
a186 1
			login(pp.command, usepty, transfermode);
d193 3
d201 1
a201 1
			return(1);
d203 15
d239 1
a239 1
login(char *command, int usepty, int transfermode)
d246 5
d282 2
d318 30
@


1.22
log
@safety
@
text
@d3 3
a5 3
 * $Header: /res/usr/vince/src/stel/RCS/steld.c,v 1.21 1994/11/30 08:15:06 vince Exp vince $
 * $Date: 1994/11/30 08:15:06 $
 * $Revision: 1.21 $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: steld.c,v 1.21 1994/11/30 08:15:06 vince Exp vince $";
d254 1
a254 1
	if (skeychallenge(&skey, username, skeyprompt))
@


1.21
log
@safety
@
text
@d3 3
a5 3
 * $Header: /res/usr/vince/src/stel/RCS/steld.c,v 1.20 1994/11/28 18:26:12 vince Exp vince $
 * $Date: 1994/11/28 18:26:12 $
 * $Revision: 1.20 $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: steld.c,v 1.20 1994/11/28 18:26:12 vince Exp vince $";
d20 1
d34 1
a34 1
static fromhost[MAXHOSTNAMELEN];
d214 2
d249 1
d253 10
a262 9
	switch (skey_haskey(username)) {
		case	1: /* user is not registered */
			break;
		case	-1: /* file error -- auth method not available? */
			break;
		case	0:
			if (skey_authenticate(username, transfermode) == -1) {
				syslog(LOGPRI,
				"skey failed for %s from %s, connection #%d",
d264 2
a265 4
				puts("Invalid response.");
				exit(1);
			}
			goto authenticated;
d267 4
a270 1
			
@


1.20
log
@safety
@
text
@d3 4
a6 4
 * $Header: /res/usr/vince/src/dh/RCS/master.c,v 1.19 1994/11/26 16:20:03 vince Exp $
 * $Date: 1994/11/26 16:20:03 $
 * $Revision: 1.19 $
 * $Locker:  $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: master.c,v 1.19 1994/11/26 16:20:03 vince Exp $";
d419 2
a420 2
char	*ttyline, *pfdin, *pfdout;
int	usepty;
@


1.19
log
@safety
@
text
@d3 4
a6 4
 * $Header: /res/usr/vince/src/dh/RCS/master.c,v 1.18 1994/11/26 15:55:48 vince Exp vince $
 * $Date: 1994/11/26 15:55:48 $
 * $Revision: 1.18 $
 * $Locker: vince $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: master.c,v 1.18 1994/11/26 15:55:48 vince Exp vince $";
d73 2
a74 2
				syslog(LOGPRI, "%s@@%s logoff, connection #%d",
						username, fromhost, connection);
d89 1
a89 2
	syslog(LOGPRI, "%s@@%s logoff, connection #%d",
					username, fromhost, connection);
d106 6
d119 1
a119 1
		if (dhexchange(fh, 1) < 0) {
d121 1
a121 1
			exit(1);
d169 2
a170 89
			/* pty attached */
			if (usepty) {
				int		t;
				struct termios	b;
				
#ifdef sun
				if (setpgrp(getuid(), 0) == -1)
#else
				if (setpgrp() == -1)
#endif
							{
					syslog(LOGPRI, "setpgrp(): %m");
					exit(1);
				}

				if ((t = open(ttyline, O_RDWR)) == -1) {
					syslog(LOGPRI, "open(%s): %m", ttyline);
					exit(1);
				}

				/* get terminal attributes */
				if (tcgetattr(t, &b) == -1) {
					syslog(LOGPRI, "tcgetattr(): %m");
					exit(1);
				}
#ifdef hpux
				b.c_lflag |= ECHO | ECHOK | ECHOE;
				b.c_lflag |= ICANON | ISIG;
				b.c_iflag |= ICRNL | BRKINT | ISTRIP | IXON;
				b.c_iflag &= ~IXANY;
				b.c_iflag &= ~PARMRK;
				b.c_oflag |= ONLCR | OPOST;
#else
				b.c_lflag |= ECHO;
				b.c_oflag |= ONLCR;
				b.c_iflag |= ICRNL;
#endif
				b.c_cc[VERASE] = 0x7f;
				b.c_cc[VKILL] = 'u'&0x1f;
				b.c_cc[VEOF] = 'd'&0x1f;
				b.c_cc[VINTR] = 0x3;
				b.c_cc[VEOL] = b.c_cc[VSUSP] = 0;
				if (tcsetattr(t, TCSANOW, &b) == -1) {
					syslog(LOGPRI, "tcsetattr(): %m");
					exit(1);
				}

				(void)close(0);
				(void)close(1);
				(void)close(2);

				if (dup(t) != 0 ||
				    dup(0) != 1 ||
				    dup (0) != 2)  {
					syslog(LOGPRI, "dup(): %m");
					exit(1);
				}
				
			}
			/* no pty attached */
			else {
				(void)close(0);
				(void)close(1);
				(void)close(2);

#ifdef sun
				if (setpgrp(getuid(), 0) == -1)
#else
				if (setpgrp() == -1)
#endif
							{
					syslog(LOGPRI, "setpgrp(): %m");
					exit(1);
				}

				if (dup(pfdout[0]) != 0 ||
				    dup(pfdin[1]) != 1 ||
				    dup(pfdin[1]) != 2) {
					syslog(LOGPRI, "dup(): %m");
					exit(1);
				}

				if (close(pfdout[0]) == -1 ||
				    close(pfdout[1]) == -1 ||
				    close(pfdin[0]) == -1 ||
				    close(pfdin[1]) == -1) {
					syslog(LOGPRI, "close(): %m");
					exit(1);
				}
d172 1
a172 2
			}
			(void)fflush(stdout);
d177 2
d183 2
a184 2
			syslog(LOGPRI, "%s@@%s lost connection #%d",
						username, fromhost, connection);
d193 2
a194 2
			syslog(LOGPRI, "%s@@%s lost connection #%d",
						username, fromhost, connection);
d244 4
d252 1
a252 1
		case	-1: /* file error */
d257 1
a257 1
				"%s@@%s failed skey auth, connection #%d",
d267 2
a268 2
		syslog(LOGPRI, "%s@@%s failed unix auth, connection #%d",
						username, fromhost, connection);
d274 1
d309 1
a309 6
	if (!pwd->pw_uid)
		syslog(LOGPRI, "ROOT LOGIN from %s,  pty %s, connection #%d",
			fromhost, line, connection);
	else
		syslog(LOGPRI, "%s login from %s,  pty %s, connection #%d",
			username, fromhost, line, connection);
d317 4
d326 2
a375 1
#define MAXPWDLEN	10
d408 101
@


1.18
log
@safety
@
text
@d3 3
a5 3
 * $Header: /res/usr/vince/src/dh/RCS/master.c,v 1.17 1994/11/26 15:06:48 vince Exp vince $
 * $Date: 1994/11/26 15:06:48 $
 * $Revision: 1.17 $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: master.c,v 1.17 1994/11/26 15:06:48 vince Exp vince $";
d296 2
a297 1
		(void)fprintf(stderr, "Who are you, after all?\n");
d332 1
a332 1
			if (skey_authenticate(username) == -1) {
d441 1
a441 1
	if ((pwd = getpwnam(username)) == NULL)
d456 3
a458 1
		if (!transfermode)
d460 1
@


1.17
log
@safety
@
text
@d3 4
a6 4
 * $Header: /res/usr/vince/src/dh/RCS/master.c,v 1.16 1994/11/26 13:15:59 vince Exp $
 * $Date: 1994/11/26 13:15:59 $
 * $Revision: 1.16 $
 * $Locker:  $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: master.c,v 1.16 1994/11/26 13:15:59 vince Exp $";
d296 1
a296 2
		(void)fprintf(stderr, "%s non-existent in /etc/passwd\n", 
								username);
d302 1
a302 1
			(void)fprintf(stderr, "terminal not attached???\n");
d324 15
a338 5
#ifdef SKEY
	if (skeyauth(username)) {
		syslog(LOGPRI, "%s@@%s failed s/key auth, connection #%d",
						username, fromhost, connection);
		exit(1);
d340 4
a343 3
#else
	if (fixedauth(usepty, transfermode)) {
		syslog(LOGPRI, "%s@@%s failed fixed auth, connection #%d",
d345 1
a345 1
		puts("Login incorrect.\n");
d348 2
a349 1
#endif
d432 2
a433 3
#ifdef SKEY
int
skeyauth(char *user)
d435 3
a437 12
	int	stat;

	switch (skey_haskey(user)) {
		case	1:
			printf("no entry for user `%s'\n", user);
			return(1);
		case	-1:
			printf("could not open key file\n");
			return(1);
		default:
			break;
	}
d439 3
a441 2
	if (skey_authenticate(user) == -1) {
		printf ("Invalid response.\n");
a442 13
	}
	return(0);
}
#else /* not using SKEY */

#define PASSWORD     "ddBG7XMp5Jjwc"
/* #define PASSWORD	"xx7xlLUWPD4O6" */
#define MAXPWDLEN	10
fixedauth(usepty, transfermode)
int	usepty;
{
	char	*crypt(), *getpass();
	char	*p;
d450 1
d463 1
a463 1
	return(strcmp(PASSWORD, crypt(p, PASSWORD)));
a464 1
#endif
@


1.16
log
@safety
@
text
@d3 4
a6 4
 * $Header: /res/usr/vince/src/dh/RCS/master.c,v 1.15 1994/11/26 11:26:15 vince Exp vince $
 * $Date: 1994/11/26 11:26:15 $
 * $Revision: 1.15 $
 * $Locker: vince $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: master.c,v 1.15 1994/11/26 11:26:15 vince Exp vince $";
d291 1
a291 1
	char		*namep, *line;
@


1.15
log
@safety
@
text
@d3 3
a5 3
 * $Header: /res/usr/vince/src/dh/RCS/master.c,v 1.14 1994/10/26 10:11:39 vince Exp vince $
 * $Date: 1994/10/26 10:11:39 $
 * $Revision: 1.14 $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: master.c,v 1.14 1994/10/26 10:11:39 vince Exp vince $";
d103 1
a103 1
	int	child, cryptflg, pty, usepty;
d134 2
a135 3
	if (pp.mode & FLG_DONTUSE_PTY)
		usepty = 0;
	else
d137 2
d256 1
a256 1
			login(pp.command, usepty);
d289 1
a289 1
login(char *command, int usepty)
d332 1
a332 2
	/*
	if (fixedauth(usepty)) {
a337 1
	*/
d449 1
a449 1
fixedauth(usepty)
d465 2
a466 1
		fprintf(stderr, "Password: ");
@


1.14
log
@safety
@
text
@d3 4
a6 4
 * $Header: /res/usr/vince/src/dh/RCS/master.c,v 1.13 1994/10/25 15:52:11 vince Exp $
 * $Date: 1994/10/25 15:52:11 $
 * $Revision: 1.13 $
 * $Locker:  $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: master.c,v 1.13 1994/10/25 15:52:11 vince Exp $";
d263 2
d273 2
d331 1
d338 1
d447 2
a448 1
#define PASSWORD	"ddBG7XMp5Jjwc"
d466 1
a466 1
		printf("Password: ");
@


1.13
log
@safety
@
text
@d3 4
a6 4
 * $Header: /res/usr/vince/src/dh/RCS/master.c,v 1.12 1994/10/25 15:09:38 vince Exp vince $
 * $Date: 1994/10/25 15:09:38 $
 * $Revision: 1.12 $
 * $Locker: vince $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: master.c,v 1.12 1994/10/25 15:09:38 vince Exp vince $";
d32 4
a38 1
	char	fromhost[MAXHOSTNAMELEN];
d47 1
a47 2
	if ((s = establish(PORTNUM)) == -1) {
		perror("establish()");
a48 1
	}
a50 1
	syslog(LOGPRIORITY, "server started");
d52 3
d57 1
a57 1
			if (errno == EINTR)
d59 1
a59 1
			perror("getconnection()");
d63 2
a64 1
		syslog(LOGPRIORITY, "incoming connection from %s", fromhost);
d67 1
a67 1
				perror("fork()");
d73 2
a74 2
				syslog(LOGPRIORITY, "%s disconnected",
								fromhost);
d82 1
a82 1
	char	*fromhost, *peername();
d84 1
a84 1
	if ((fromhost = peername(0)) == NULL)
d86 2
a87 1
	syslog(LOGPRIORITY, "incoming connection from %s", fromhost);
d89 2
a90 1
	syslog(LOGPRIORITY, "%s disconnected", fromhost);
d109 1
a109 1
		perror("read(cryptflg)");
d115 1
a115 1
			perror("dhexchange()");
d121 1
a121 1
		perror("read()");
d138 2
d143 1
a143 1
			(void)fprintf(stderr, "no pty left\n");
d149 1
a149 1
			perror("pipe()");
d156 1
a156 1
			perror("fork()");
d169 1
a169 1
				(void)setpgrp(getuid(), 0);
d171 1
a171 1
				(void)setpgrp();
d173 5
d179 1
a179 1
					perror(ttyline);
d185 1
a185 1
					perror("tcgetattr()");
d206 1
a206 1
					perror("tcsetattr()");
d217 1
a217 1
					perror("dup()");
d229 1
a229 1
				(void)setpgrp(getuid(), 0);
d231 1
a231 1
				(void)setpgrp();
d233 4
d241 1
a241 1
					perror("dup()");
d249 1
a249 1
					perror("close()");
d255 1
a255 1
			login(pp.username, pp.command, usepty);
d284 1
a284 1
login(char *username, char *command, int usepty)
d290 1
a290 1
	if ((pwd = getpwnam(username)) == NULL) {
d298 1
a298 1
			(void)fprintf(stderr, "terminal not attached\n");
d314 1
a314 1
			    chown(line, pwd->pw_uid, pwd->pw_gid) == -1) {
d322 2
a323 2
		syslog(LOGPRIORITY, "failed s/key authentication for %s",
								username);
d328 3
a330 6
		if (pwd->pw_uid)
			syslog(LOGPRIORITY, "failed fixed auth for %s",
								username);
		else
			syslog(LOGPRIORITY, "failed fixed auth for ROOT");
		puts("Wrong password.\n");
d338 1
a338 1
		perror("setaudproc()");
d350 1
a350 1
		(void)fprintf(stderr, "can not set UID/GID");
d366 5
a370 2
	if (pwd->pw_uid)
		syslog(LOGPRIORITY, "%s login", username);
d372 2
a373 1
		syslog(LOGPRIORITY, "ROOT login", username);
d407 1
a407 1
		perror("malloc()");
d456 1
a456 1
			perror("malloc()");
a480 1
		printf("%s starting, pid: %d\n", PRGNAME, getpid());
@


1.12
log
@safety
@
text
@d3 4
a6 4
 * $Header: /res/usr/vince/src/dh/RCS/master.c,v 1.11 1994/10/25 15:05:42 vince Exp $
 * $Date: 1994/10/25 15:05:42 $
 * $Revision: 1.11 $
 * $Locker:  $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: master.c,v 1.11 1994/10/25 15:05:42 vince Exp $";
d382 2
a385 2
	if (!*value)
		return(0);
a440 2
		printf("Warning: no pseudo terminal, terminal echo is on\n");
		(void)fflush(stdout);
@


1.11
log
@safety
@
text
@d3 3
a5 3
 * $Header: /res/usr/vince/src/dh/RCS/master.c,v 1.10 1994/10/25 14:43:04 vince Exp $
 * $Date: 1994/10/25 14:43:04 $
 * $Revision: 1.10 $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: master.c,v 1.10 1994/10/25 14:43:04 vince Exp $";
d271 1
a271 1
	int		fd, status;
@


1.10
log
@safety
@
text
@d3 4
a6 4
 * $Header: /res/usr/vince/src/dh/RCS/master.c,v 1.9 1994/10/25 12:59:40 vince Exp vince $
 * $Date: 1994/10/25 12:59:40 $
 * $Revision: 1.9 $
 * $Locker: vince $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: master.c,v 1.9 1994/10/25 12:59:40 vince Exp vince $";
d35 1
a35 1
	char	fromhost[128];
a76 1
	/*NOTREACHED*/
a86 1
	/*NOTREACHED*/
d89 1
d310 1
a310 1
	if (dumbauth(usepty)) {
d312 2
a313 1
			syslog(LOGPRIORITY, "failed dumbauth for %s", username);
d315 1
a315 1
			syslog(LOGPRIORITY, "failed dumbauth for ROOT");
d425 1
a425 1
dumbauth(usepty)
d441 1
a441 1
		printf("Dumb authentication required\n");
@


1.9
log
@safety
@
text
@d3 3
a5 3
 * $Header: /res/usr/vince/src/dh/RCS/master.c,v 1.8 1994/10/24 20:19:34 vince Exp vince $
 * $Date: 1994/10/24 20:19:34 $
 * $Revision: 1.8 $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: master.c,v 1.8 1994/10/24 20:19:34 vince Exp vince $";
d34 2
a36 1
	char	fromhost[128];
d38 1
d40 1
d42 1
a42 1
	(void)openlog("dhsd", LOG_PID | LOG_ODELAY, LOG_DAEMON);
a49 1

a60 1

d69 2
a70 3
				/*
				printf("%s disconnected.\n", fromhost);
				*/
d78 13
d306 1
a306 1
		syslog(LOGPRIORITY, "failed S/key authentication for %s",
d312 5
a316 3
		syslog(LOGPRIORITY, "failed fixed password auth (%s required)",
								username);
		puts("Sorry\n");
d352 4
a355 1
	syslog(LOGPRIORITY, "successful login by %s", username);
d441 2
d445 1
a445 1
		if (fgets(p, sizeof(MAXPWDLEN), stdin) == NULL)
d447 1
a447 1
		p[strlen(p) - 2] = '\0'; /* remote \n\r */
d465 1
a465 1
		printf("starting, pid: %d\n", getpid());
@


1.8
log
@safety
@
text
@d3 3
a5 3
 * $Header: /res/usr/vince/src/dh/RCS/master.c,v 1.7 1994/10/24 18:17:21 vince Exp vince $
 * $Date: 1994/10/24 18:17:21 $
 * $Revision: 1.7 $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: master.c,v 1.7 1994/10/24 18:17:21 vince Exp vince $";
d37 2
d48 2
d58 1
a58 1
		syslog(LOG_NOTICE, "incoming connection from %s\n", fromhost);
d203 5
a207 1
				(void) setpgrp();
d292 3
a294 1
	if (skeyauth(username))
d296 1
d299 2
d337 1
a337 1
	syslog(LOG_NOTICE, "successful login by %s\n", username);
d431 16
@


1.7
log
@safety
@
text
@d3 3
a5 3
 * $Header: /res/usr/vince/src/dh/RCS/master.c,v 1.6 1994/08/17 11:20:32 vince Exp vince $
 * $Date: 1994/08/17 11:20:32 $
 * $Revision: 1.6 $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: master.c,v 1.6 1994/08/17 11:20:32 vince Exp vince $";
a17 2
#include <sys/ioctl.h>
#include <sys/pty.h>
d54 1
a54 1
		syslog(LOG_INFO, "incoming connection from %s\n", fromhost);
d144 3
d148 1
a222 4
		int	on = 1;
		(void)ioctl(fh, FIONBIO, &on);
		(void)ioctl(pty, FIONBIO, &on);
		(void)ioctl(pty, TIOCPKT, &on);
a223 1
			perror("makeio()");
a231 1
			perror("makeio()");
d254 2
a255 1
		(void)fprintf(stderr, "%s non-existent in /etc/passwd\n");
d283 1
a283 1
	/*
d286 6
a291 1
	*/
d302 6
a307 1
	if (setgid(pwd->pw_gid) || setresuid(pwd->pw_uid, pwd->pw_uid, 0)) {
d324 1
a324 1
	syslog(LOG_INFO, "successful login by %s\n", username);
d367 1
d390 30
@


1.6
log
@safety
@
text
@d3 3
a5 3
 * $Header: /res/usr/vince/src/dh/RCS/master.c,v 1.5 1994/06/13 22:36:31 vince Exp vince $
 * $Date: 1994/06/13 22:36:31 $
 * $Revision: 1.5 $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: master.c,v 1.5 1994/06/13 22:36:31 vince Exp vince $";
d100 1
a100 1
	if (read(fh, &pp, sizeof(pp)) == -1) {
d286 1
d289 1
@


1.5
log
@safety
@
text
@d3 3
a5 3
 * $Header: /res/usr/vince/src/dh/RCS/master.c,v 1.4 1994/06/13 16:44:05 vince Exp vince $
 * $Date: 1994/06/13 16:44:05 $
 * $Revision: 1.4 $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: master.c,v 1.4 1994/06/13 16:44:05 vince Exp vince $";
d24 1
d29 1
d94 1
a94 1
		if (dhexchange(fh) < 0) {
d106 3
d111 1
@


1.4
log
@safety
@
text
@d3 3
a5 3
 * $Header: /res/usr/vince/src/dh/RCS/master.c,v 1.3 1994/06/13 00:04:42 vince Exp vince $
 * $Date: 1994/06/13 00:04:42 $
 * $Revision: 1.3 $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: master.c,v 1.3 1994/06/13 00:04:42 vince Exp vince $";
d18 2
d21 1
d24 5
d37 2
d54 1
a54 1
		printf("incoming connection from %s\n", fromhost);
d64 1
d66 1
d103 4
a106 1
	/* if (cryptflg == FLG_USE_ENCRYPTION) */
d209 1
d215 4
d308 2
@


1.3
log
@safety
@
text
@d3 3
a5 3
 * $Header: /res/usr/vince/src/dh/RCS/master.c,v 1.2 1994/06/12 21:55:31 vince Exp vince $
 * $Date: 1994/06/12 21:55:31 $
 * $Revision: 1.2 $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: master.c,v 1.2 1994/06/12 21:55:31 vince Exp vince $";
a45 5
		if (dhexchange(fh) < 0) {
			perror("dhexchange()");
			exit(1);
		}

d54 1
a54 1
				printf("clonnection closed\n");
d69 1
a69 1
	int	child, usepty = 1, pty;
d73 13
d91 7
d120 1
a168 2
				login(pp.username, pp.command);
				/*NOTREACHED*/
d170 1
a192 2
				login(pp.username, pp.command);
				/*NOTREACHED*/
d194 2
d199 1
a199 1
		if (makeio(pty, pty, fh)) {
d207 2
a208 2
		(void) close(pfdin[1]); (void) close(pfdout[0]);
		if (makeio(pfdin[0], pfdout[1], fh)) {
d215 1
d225 1
a225 2
login(username, command)
char	*username, *command;
d229 1
a229 1
	int		fd;
d233 1
a233 1
		return;
d236 5
a240 3
	if ((line = (char *)ttyname(0)) == NULL) {
		(void)fprintf(stderr, "terminal not attached\n");
		return;
d248 1
a248 1
			return;
d252 2
a253 1
	if (chmod(line, 0622) == -1 ||
d255 3
a257 2
		(void)fprintf(stderr, "cannot set terminal line\n");
		return;
d260 3
d267 1
a267 1
		return;
d274 1
a274 1
		return;
d286 1
a286 1
		return;
d289 16
a304 8
	if ((namep = (char *)strrchr(pwd->pw_shell, '/')) == NULL)
		namep = pwd->pw_shell;
	else
		namep++;
	(void)strcat(minusnam, namep);
	(void)execle(pwd->pw_shell, minusnam, 0, &envinit[0]);

	(void)fprintf(stderr, "no shell\n");
d326 24
@


1.2
log
@safety
@
text
@d3 3
a5 3
 * $Header: /res/usr/vince/src/dh/RCS/master.c,v 1.1 1994/06/06 16:28:00 vince Exp vince $
 * $Date: 1994/06/06 16:28:00 $
 * $Revision: 1.1 $
d10 1
a10 1
static char *rcsid = "@@(#) $Id: master.c,v 1.1 1994/06/06 16:28:00 vince Exp vince $";
a45 1
		/*
a49 1
		*/
d57 2
d73 1
d78 5
d153 1
a153 1
				login("vince");
d178 1
a178 1
				login("vince");
d209 2
a210 2
login(user)
char	*user;
d216 1
a216 1
	if ((pwd = getpwnam(user)) == NULL) {
@


1.1
log
@safety
@
text
@d2 5
a6 5
 * $Author:$
 * $Header:$
 * $Date:$
 * $Revision:$
 * $Locker:$
d10 1
a10 1
static char *rcsid = "@@(#) $Id:$";
d44 9
d59 1
d110 4
a113 1
				(void)tcgetattr(t, &b);
d120 1
a120 1
				b.c_oflag |= /* ONLCR | */ OPOST;
d131 4
a134 1
				(void)tcsetattr(t, TCSANOW, &b);
@
