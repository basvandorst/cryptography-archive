From sqwest.wimsey.bc.ca!mch@wimsey.com  Tue May 31 14:35:08 1994
Received: from wolfe.wimsey.com by scss3.cl.msu.edu (4.1/4.7)  id AA19476; Tue, 31 May 94 14:35:08 EDT
Received: by wolfe.wimsey.com (Smail3.1.28.1)
	id m0q8YeZ-0008BOC; Tue, 31 May 94 11:35 PDT
Received: by sqwest.west.sq.com (5.65c/IDA-AIX32)
	id AA25364; Tue, 31 May 1994 18:25:43 GMT
Message-Id: <199405311825.AA25364@sqwest.west.sq.com>
From: mch@sqwest.wimsey.bc.ca (Mark C. Henderson)
Date: Tue, 31 May 1994 11:25:43 -0700
X-Subliminal-Message: J<:@N/EMACS/;-1A-4@I//RRD3R2D0A+2@I//R-1A+15@I//R-D>$$
X-Editor: TECO
X-Mailer: Mail User's Shell (7.2.3 5/22/91)
To: ripem-dev@ripem.msu.edu, mrr@ripem.msu.edu
Subject: patch for rsaref-2.0+

Thanks to Richard Outerbridge for discovering a bug in my Montgomery
Multipication code. (it almost never would have actually been triggered
by RIPEM).

*** nn.c.1	Mon May 30 11:08:05 1994
--- nn.c	Mon May 30 14:24:21 1994
***************
*** 465,489 ****
    NN_AssignZero(one,nDigits); one[0] = 1;
  
    k = NN_Digits(n,nDigits);
!   NN_AssignZero(r,nDigits+1); r[k] = 1; /* r = B^k, where B=2^{NN_DIGIT_BITS}*/
  
    /* v = -(1/n) mod B */
!   v=NN_Mod2Inv(n,nDigits); /* we don't really need nDigits in this routine */
  
    /* a1 = a*r mod n */
!   NN_AssignZero(t1,2*nDigits+1);;
!   for (i = 0; i < nDigits; i++) 
      t1[i+k] = a[i];
!   NN_Mod(a1,t1,2*nDigits+1,n,nDigits);
  
    /* t = r mod n */
!   NN_Mod(t,r,nDigits+1,n,nDigits);
  
    cDigits = NN_Digits (c, cDigits);
    if (cDigits < NN_THRESH) {   /* take bits of exponent two at a time */
!         NN_Assign (aPower[0], a1, nDigits);
!         monpro (aPower[1], aPower[0], a1, n, nDigits, v,k);
!         monpro (aPower[2], aPower[1], a1, n, nDigits, v,k);
          
          for (i = cDigits - 1; i >= 0; i--) {
              ci = c[i];
--- 465,489 ----
    NN_AssignZero(one,nDigits); one[0] = 1;
  
    k = NN_Digits(n,nDigits);
!   NN_AssignZero(r,k+1); r[k] = 1; /* r = B^k, where B=2^{NN_DIGIT_BITS}*/
  
    /* v = -(1/n) mod B */
!   v=NN_Mod2Inv(n,k); /* we don't really need nDigits in this routine */
  
    /* a1 = a*r mod n */
!   NN_AssignZero(t1,2*k+1);;
!   for (i = 0; i < k; i++) 
      t1[i+k] = a[i];
!   NN_Mod(a1,t1,2*k+1,n,nDigits);
  
    /* t = r mod n */
!   NN_Mod(t,r,k+1,n,nDigits);
  
    cDigits = NN_Digits (c, cDigits);
    if (cDigits < NN_THRESH) {   /* take bits of exponent two at a time */
!         NN_Assign (aPower[0], a1, k);
!         monpro (aPower[1], aPower[0], a1, n, k, v,k);
!         monpro (aPower[2], aPower[1], a1, n, k, v,k);
          
          for (i = cDigits - 1; i >= 0; i--) {
              ci = c[i];
***************
*** 499,508 ****
              }
  
              for (j = 0; j < ciBits; j += 2, ci <<= 2) {
!                 monpro (t, t, t, n, nDigits, v,k);
!                 monpro (t, t, t, n, nDigits, v,k);
                  if (s = DIGIT_2MSB (ci))
!                     monpro (t, t, aPower[s-1], n, nDigits, v,k);
              }
          }
      }
--- 499,508 ----
              }
  
              for (j = 0; j < ciBits; j += 2, ci <<= 2) {
!                 monpro (t, t, t, n, k, v,k);
!                 monpro (t, t, t, n, k, v,k);
                  if (s = DIGIT_2MSB (ci))
!                     monpro (t, t, aPower[s-1], n, k, v,k);
              }
          }
      }
***************
*** 509,529 ****
      else { /* process exponent nibble by nibble */
  
          /* precompute */
!         NN_Assign (aPower[0], a1, nDigits);
!         monpro (aPower[1], aPower[0], a1, n, nDigits, v,k);   
!         monpro (aPower[2], aPower[1], a1, n, nDigits, v,k);  
!         monpro (aPower[3], aPower[2], a1, n, nDigits, v,k);   
!         monpro (aPower[4], aPower[3], a1, n, nDigits, v,k);  
!         monpro (aPower[5], aPower[4], a1, n, nDigits, v,k); 
!         monpro (aPower[6], aPower[5], a1, n, nDigits, v,k);
!         monpro (aPower[7], aPower[6], a1, n, nDigits, v,k);
!         monpro (aPower[8], aPower[7], a1, n, nDigits, v,k);  
!         monpro (aPower[9], aPower[8], a1, n, nDigits, v,k);   
!         monpro (aPower[10], aPower[9], a1, n, nDigits, v,k);  
!         monpro (aPower[11], aPower[10], a1, n, nDigits, v,k); 
!         monpro (aPower[12], aPower[11], a1, n, nDigits, v,k); 
!         monpro (aPower[13], aPower[12], a1, n, nDigits, v,k); 
!         monpro (aPower[14], aPower[13], a1, n, nDigits, v,k); 
          
          for (i = cDigits - 1; i >= 0; i--) {
              ci = c[i];
--- 509,529 ----
      else { /* process exponent nibble by nibble */
  
          /* precompute */
!         NN_Assign (aPower[0], a1, k);
!         monpro (aPower[1], aPower[0], a1, n, k, v,k);   
!         monpro (aPower[2], aPower[1], a1, n, k, v,k);  
!         monpro (aPower[3], aPower[2], a1, n, k, v,k);   
!         monpro (aPower[4], aPower[3], a1, n, k, v,k);  
!         monpro (aPower[5], aPower[4], a1, n, k, v,k); 
!         monpro (aPower[6], aPower[5], a1, n, k, v,k);
!         monpro (aPower[7], aPower[6], a1, n, k, v,k);
!         monpro (aPower[8], aPower[7], a1, n, k, v,k);  
!         monpro (aPower[9], aPower[8], a1, n, k, v,k);   
!         monpro (aPower[10], aPower[9], a1, n, k, v,k);  
!         monpro (aPower[11], aPower[10], a1, n, k, v,k); 
!         monpro (aPower[12], aPower[11], a1, n, k, v,k); 
!         monpro (aPower[13], aPower[12], a1, n, k, v,k); 
!         monpro (aPower[14], aPower[13], a1, n, k, v,k); 
          
          for (i = cDigits - 1; i >= 0; i--) {
              ci = c[i];
***************
*** 539,555 ****
              }
  
              for (j = 0; j < ciBits; j += 4, ci <<= 4) {
!                 monpro(t,t,t,n,nDigits, v,k);
!                 monpro(t,t,t,n,nDigits, v,k);
!                 monpro(t,t,t,n,nDigits, v,k);
!                 monpro(t,t,t,n,nDigits, v,k);
                  if (s = DIGIT_4MSB (ci))
!                     monpro (t, t, aPower[s-1], n, nDigits,v,k);
              }
          }
      }
!   
!   monpro(x,t,one,n,nDigits,v,k);
    
    /* Zeroize potentially sensitive information.
     */
--- 539,556 ----
              }
  
              for (j = 0; j < ciBits; j += 4, ci <<= 4) {
!                 monpro(t,t,t,n,k, v,k);
!                 monpro(t,t,t,n,k, v,k);
!                 monpro(t,t,t,n,k, v,k);
!                 monpro(t,t,t,n,k, v,k);
                  if (s = DIGIT_4MSB (ci))
!                     monpro (t, t, aPower[s-1], n, k,v,k);
              }
          }
      }
!  
!   NN_AssignZero(x,nDigits); 
!   monpro(x,t,one,n,k,v,k);
    
    /* Zeroize potentially sensitive information.
     */

-- 
Mark Henderson, SoftQuad Inc., 108-10070 King George Hwy, Surrey, B.C. V3T 2W4
Internet: mch@sqwest.wimsey.bc.ca, markh@wimsey.bc.ca   Voice: +1 604 585 8394
Fax: +1 604 585 1926    RIPEM MD5OfPublicKey: F1F5F0C3984CBEAF3889ADAFA2437433
ViaCryptPGP Key fingerprint = C4 EC 2F 6C 1B ED F6 06  1D E9 08 E4 E5 F9 FA 16 
From mrr@cl-next3.cl.msu.edu  Tue May 31 15:55:05 1994
Received: from cl-next3.cl.msu.edu by scss3.cl.msu.edu (4.1/4.7)  id AA19674; Tue, 31 May 94 15:55:05 EDT
Received: by cl-next3.cl.msu.edu (NX5.67c/4.7)  id AA09284; Tue, 31 May 94 15:55:06 -0400
Date: Tue, 31 May 94 15:55:06 -0400
From: Mark Riordan <mrr@cl-next3.cl.msu.edu>
Message-Id: <9405311955.AA09284@cl-next3.cl.msu.edu>
To: ripem-dev@cl-next3.cl.msu.edu
Subject: patch for rsaref-2.0+

MCH says:
> Thanks to Richard Outerbridge for discovering a bug in my Montgomery
> Multipication code. (it almost never would have actually been triggered
> by RIPEM).

Thanks.  I have patched this into my working copy of RIPEM source.
/mrr
From mrr@cl-next3.cl.msu.edu  Tue May 31 23:18:59 1994
Received: from cl-next3.cl.msu.edu by scss3.cl.msu.edu (4.1/4.7)  id AA20322; Tue, 31 May 94 23:18:59 EDT
Received: by cl-next3.cl.msu.edu (NX5.67c/4.7)  id AA09545; Tue, 31 May 94 23:19:00 -0400
Date: Tue, 31 May 94 23:19:00 -0400
From: Mark Riordan <mrr@cl-next3.cl.msu.edu>
Message-Id: <9406010319.AA09545@cl-next3.cl.msu.edu>
To: ripem-dev@cl-next3.cl.msu.edu
Subject: Re: Latest 68K Mods

> 94/05/31 19:42:04 EDST
> Inside of this is a uuencoded, compressed, tarchive of text files.
> All [Mac] CR's were turned into [UNIX] LF's during tarring.

Richard,
I have merged your mods into my RIPEM source tree.
Only r_encode.c and prime.c got put into the general tree.
The others went into mac68K/.  I assume that's what you
wanted.   (I only merged the RSAREF2 mods.)
/mrr
