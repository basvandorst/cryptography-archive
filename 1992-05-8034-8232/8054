Path: msuinfo!uchinews!ncar!ames!elroy.jpl.nasa.gov!news.claremont.edu!ucivax!noiro.acs.uci.edu!cerritos.edu!arizona.edu!arizona!rcs
Newsgroups: sci.crypt
Subject: "NSA inspired" computer instructions
Message-ID: <16002@optima.cs.arizona.edu>
From: rcs@cs.arizona.edu (Richard Schroeppel)
Date: 30 Apr 92 22:34:18 GMT
Reply-To: rcs@cs.arizona.edu (Richard Schroeppel)
Sender: news@cs.arizona.edu
Organization: U of Arizona, CS Dept, Tucson
Lines: 58

Another use for the population-count instruction is in character
recognition:  XOR your actual character image with the "should-be"
image, and count the mismatched bits.

Find-first-one appears in any bit-table allocation subroutine.

Bit-reverse shows up in some Fourier transform algorithms.
I used a similar instruction in a program to count magic squares;
I needed to find the solutions to A+B=N, given N; A and B were supplied
as bit-masks which denoted available values for A and B.  ANDing A
with shift(bit-reverse(B)) gave me a bit-pattern for the usable
subset of the As.

The IBM 360 had a translate instruction which translated bytes with
a translation table.  This made eminent sense in a world with
ASCII, EBCDIC, BCD, FIODEC, and who knows what next?  No NSA inspiration
seems necessary.  There was a related instruction, translate-and-test,
which scanned a character string, classifying characters, stopping
when a particular class character was found.  This seems like the
perfect instruction for token scanning and all the other lexical tasks
a compiler (or assembler) must do.

One may object that the translate instructions are a bad use of CPU
complexity resources, and hence evidence of NSA influence.  The history
tends to show otherwise:  the 1401 had instructions for blanking the
leading 0s of a character string, and merging a digit string with a
punctuation string of commas, periods, and asterisks.  We would write
a subroutine today, but those instructions made life a lot easier for
the (assembly language) programmers, and probably sold machines.
There was a lot of experimentation with new instructions in the 1960s
and 1970s-- the last DEC20 had some complicated instructions for
manipulating character strings; the VAX had instructions for evaluating
polynomials, and for computing CRC checksums.  Each of these makes
sense from the right perspective, depending on memory speed vs. logic
speed, programmer skill & customs, intended market, etc.

I've heard stories that three instructions for the 7094 were NSA
inspired, but I don't have any supporting evidence:  they were the
convert-by-replacement-from-the-AC, ...-MQ, and a similar third one
that somehow involved addition.  The first two of these are just
character-translation instructions, and don't seem to require the
NSA theory.  I never figured out exactly what the last one did though;
it might have been useful for simulating a rotor machine(?).

Knuth mentions two instructions from Russian computers that did some
bit interleaving tasks:  they had names like gather and scatter:
gather uses the 1 bits in its first operand to indicate which bits of
a second operand should be collected to form the result.  This might
be used to collect some bits from a device-status register and dispatch
on the combination.  Scatter is an inverse of gather; the only uses I
can imagine are bit rearrangement, for hashing or crypto work.
Perhaps the end of the cold war will bring a sequel to "The Codebreakers",
with some Russian contributions.

Rich Schroeppel   rcs@cs.arizona.edu



