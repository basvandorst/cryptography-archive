Xref: msuinfo comp.arch:30534 sci.crypt:8052
Path: msuinfo!uchinews!ncar!destroyer!gumby!yale!yale.edu!spool.mu.edu!uunet!ftpbox!motsrd!mothost!merlin.dev.cdx.mot.com!pjd.dev.cdx.mot.com!peterd
From: peterd@pjd.dev.cdx.mot.com (Peter Desnoyers)
Newsgroups: comp.arch,sci.crypt
Subject: Re: The NSA Instruction
Message-ID: <peterd.704657586@pjd.dev.cdx.mot.com>
Date: 30 Apr 92 18:13:06 GMT
Article-I.D.: pjd.peterd.704657586
References: <29354@hoptoad.uucp> <1992Apr29.214606.28406@dcc.uchile.cl> <1992Apr30.042559.17794@craycos.com> <1992Apr30.074159.12226@m.cs.uiuc.edu>
Sender: news@merlin.dev.cdx.mot.com (USENET News System)
Organization: Motorola Codex, Canton, Massachusetts
Lines: 80
Nntp-Posting-Host: pjd.dev.cdx.mot.com

gillies@m.cs.uiuc.edu (Don Gillies) writes:

>Here is the magic routine, transcribed from DEC-10 assembler into C
>source code.  This subject comes up every year in comp.lang.c or
>elsewhere.

>-------------------------------------------------------------------------
>/*
> * This function counts the number of bits in a long.
> * It is limited to 63 bit longs, but a minor mod can cope with 511 bits.
> *
> * It is so magic, an explanation is required:
> * Consider a 3 bit number as being
> *	4a+2b+c
> * if we shift it right 1 bit, we have
> *	2a+b
> * subtracting this from the original gives
> *	2a+b+c
> * if we shift the original 2 bits right we get
> *	a
> * and so with another subtraction we have
> *	a+b+c
> * which is the number of bits in the original number.

[... then you add adjacent octal digits, then sum 6-bit digits by
 "casting out 63s" ...]

On many machines the modulo 63 operation is going to be rather slow.
Unfortunately, this algorithm cannot be applied repetitively to
combine octal digits, as it only works in binary. (it requires 1 ==
base-1)

A somewhat different (but related) algorithm:

To add the digits in an N-digit number in base B, add all adjacent
pairs of digits, forming an N/2-digit number in base B^2, and then add
the digits in the resulting base B^2 number.

I.e. for 16 bits:

x = (x&0x5555) + ((x&0xAAAA) >> 1);
x = (x&0x3333) + ((x&0xCCCC) >> 2);
x = (x&0x0F0F) + ((x&0xF0F0) >> 4);
x = (x&0x00FF) + (x >> 8);	/* or x = x % 255 */

This takes 4*log2(N) - 1 instructions, where N is the word length in
bits. (3*log2(N)-1 if you have a barrel shifter)

You can apply the modulus trick after 3 steps, so the answer won't
overflow.  However, it may not be quicker - I've tested the two
approaches on a decstation 2100 with 32-bit words, and even though
casting out 255s saves 6 instructions, it runs slower.

Note that you could combine these two algorithms - for instance, you
could do 48 bits in 5 steps by using the HAKMEM trick to get 16 octal
counts, then using the binary algorithm above to combine them.

Another observation is that divide-and-conquer algorithms like this,
using shifts and masks, can be used for a number of other bitwise
operations, such as bit reversal:

x = ((x&0x5555)<<1) | ((x&0xAAAA) >> 1);
x = ((x&0x3333)<<2) | ((x&0xCCCC) >> 2);
...

or finding highest bit set:

if (x & 0xFF00) {n += 8; x &= 0xFF00}
if (x & 0xF0F0) {n += 4; x &= 0xF0F0} /* or n += table[x%255] */
...

If you have a fast modulus operator, you could take x after the first
step above, cast out 255s, and then look up in a 256-element table to
get the rest of the answer.

				Peter Desnoyers



-- 
