Xref: msuinfo comp.arch:30511 sci.crypt:8042
Path: msuinfo!uchinews!linac!att!rutgers!igor.rutgers.edu!cadenza.rutgers.edu!masticol
From: masticol@cadenza.rutgers.edu (Steve Masticola)
Newsgroups: comp.arch,sci.crypt
Subject: Software population count (was Re: The NSA Instruction)
Message-ID: <Apr.30.08.52.58.1992.16912@cadenza.rutgers.edu>
Date: 30 Apr 92 12:53:04 GMT
References: <29354@hoptoad.uucp> <1992Apr29.214606.28406@dcc.uchile.cl> <1992Apr30.042559.17794@craycos.com> <1992Apr30.074159.12226@m.cs.uiuc.edu>
Followup-To: comp.arch
Organization: Rutgers Univ., New Brunswick, N.J.
Lines: 24

gillies@m.cs.uiuc.edu (Don Gillies) writes:

]/*
] * This function counts the number of bits in a long.
] * It is limited to 63 bit longs, but a minor mod can cope with 511 bits.

[ Explanation deleted - see previous article ]

] */
]int bitcnt(n)
]register unsigned long n;
]{
]	register unsigned long tmp;
]
]	tmp = n - ((n >> 1) & 033333333333) - ((n >> 2) & 011111111111);
]	return ((tmp + (tmp >> 3)) & 030707070707) % 63;
]}

Correct me if I'm wrong, but mod 63 implies a division by 63, doesn't
it? And division is still pretty expensive, more so than doing a
population count directly by shift-add-mask, isn't it? So where's the
savings?

- Steve (masticol@cs.rutgers.edu)
