Path: msuinfo!netnews.upenn.edu!jvnc.net!darwin.sura.net!mips!zaphod.mps.ohio-state.edu!rpi!ghost.dsi.unimi.it!vince
From: vince@ghost.dsi.unimi.it (David Vincenzetti)
Newsgroups: sci.crypt
Subject: Re: Unix PGP
Keywords: caution
Message-ID: <1992May8.162611.26010@ghost.dsi.unimi.it>
Date: 8 May 92 16:26:11 GMT
References: <l0k641INN3pa@exodus.Eng.Sun.COM>
Organization: Computer Science Dep. - Milan University
Lines: 645

wdorsey@lila.Eng.Sun.COM (William Dorsey) writes:

>I just downloaded the Unix version of PGP 1.0 from ghost.dsi.unimi.it
>and noted a potentially serious problem with it.  The original MSDOS
>version generated stochastic (?) random numbers by measuring the time
>between users keystrokes.  This is not easy to do in a portable manner
>on Unix machines, and oftentimes a high-resolution timer is not
>available making the number of random bits that can be accumulated from
>each keystroke small.

Agreed. I have just written the following program, which is supposed to
produce TRUE random numbers. It is a fast hack, the code is dirty and could
be severely enhanced, anyway something of it could be include in PGP.

WHAT DO YOU THINK OF IT? Waiting for your remarks --

Ciao,	David

--cut_here--cut_here--cut_here--cut_here--cut_here--cut_here--cut_here--

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of shell archive."
# Wrapped by vince@c700-3 on Fri May  8 17:01:30 1992
# Contents:  md4.c random.c Makefile md4.h
# Existing files will not be overwritten.
# Error checking via wc(1) will be performed.

overwrite_check()
{
	echo Ok to overwrite existing file $1 \? \\c
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f $1
	if test -f $1
	then
		echo Error: could not remove $1, aborting
		exit 1
	fi
}

test "${1}" != "-c"
overwrite_opt=$?
LANG=""; export LANG
PATH=/bin:/usr/bin:$PATH; export PATH

if test -f md4.c -a $overwrite_opt -eq 0
then
	overwrite_check md4.c
fi
echo x - md4.c
sed "s/^X//" > md4.c <<'@EOF'
X/*
X ***********************************************************************
X ** md4.c                                                             **
X ** RSA Data Security, Inc. MD4 Message-Digest Algorithm              **
X ** Created: 2/17/90 RLR                                              **
X ** Revised: 1/91 SRD,AJ,BSK,JT Reference C Version                   **
X ***********************************************************************
X */
X
X/*
X ***********************************************************************
X ** Copyright (C) 1990, RSA Data Security, Inc. All rights reserved.  **
X **                                                                   **
X ** License to copy and use this software is granted provided that    **
X ** it is identified as the "RSA Data Security, Inc. MD4 Message      **
X ** Digest Algorithm" in all material mentioning or referencing this  **
X ** software or this function.                                        **
X **                                                                   **
X ** License is also granted to make and use derivative works          **
X ** provided that such works are identified as "derived from the RSA  **
X ** Data Security, Inc. MD4 Message-Digest Algorithm" in all          **
X ** material mentioning or referencing the derived work.              **
X **                                                                   **
X ** RSA Data Security, Inc. makes no representations concerning       **
X ** either the merchantability of this software or the suitability    **
X ** of this software for any particular purpose.  It is provided "as  **
X ** is" without express or implied warranty of any kind.              **
X **                                                                   **
X ** These notices must be retained in any copies of any part of this  **
X ** documentation and/or software.                                    **
X ***********************************************************************
X */
X
X#include "md4.h"
X
X/* forward declaration */
Xstatic void Transform ();
X
Xstatic unsigned char PADDING[64] = {
X  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
X  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
X  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
X  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
X  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
X  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
X  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
X  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
X};
X
X/* F, G and H are basic MD4 functions: selection, majority, parity */
X#define F(x, y, z) (((x) & (y)) | ((~x) & (z)))
X#define G(x, y, z) (((x) & (y)) | ((x) & (z)) | ((y) & (z)))
X#define H(x, y, z) ((x) ^ (y) ^ (z))
X/* ROTATE_LEFT rotates x left n bits */
X#define ROTATE_LEFT(x, n) (((x) << (n)) | ((x) >> (32-(n))))
X
X/* FF, GG and HH are MD4 transformations for rounds 1, 2 and 3 */
X/* Rotation is separate from addition to prevent recomputation */
X#define FF(a, b, c, d, x, s) \
X  {(a) += F ((b), (c), (d)) + (x); \
X   (a) = ROTATE_LEFT ((a), (s));}
X#define GG(a, b, c, d, x, s) \
X  {(a) += G ((b), (c), (d)) + (x) + (UINT4)0x5A827999; \
X   (a) = ROTATE_LEFT ((a), (s));}
X#define HH(a, b, c, d, x, s) \
X  {(a) += H ((b), (c), (d)) + (x) + (UINT4)0x6ED9EBA1; \
X   (a) = ROTATE_LEFT ((a), (s));}
X
Xvoid MD4Init (mdContext)
XMD4_CTX *mdContext;
X{
X  mdContext->i[0] = mdContext->i[1] = (UINT4)0;
X
X  /* Load magic initialization constants.
X   */
X  mdContext->buf[0] = (UINT4)0x67452301;
X  mdContext->buf[1] = (UINT4)0xefcdab89;
X  mdContext->buf[2] = (UINT4)0x98badcfe;
X  mdContext->buf[3] = (UINT4)0x10325476;
X}
X
Xvoid MD4Update (mdContext, inBuf, inLen)
XMD4_CTX *mdContext;
Xunsigned char *inBuf;
Xunsigned int inLen;
X{
X  UINT4 in[16];
X  int mdi;
X  unsigned int i, ii;
X
X  /* compute number of bytes mod 64 */
X  mdi = (int)((mdContext->i[0] >> 3) & 0x3F);
X
X  /* update number of bits */
X  if ((mdContext->i[0] + ((UINT4)inLen << 3)) < mdContext->i[0])
X    mdContext->i[1]++;
X  mdContext->i[0] += ((UINT4)inLen << 3);
X  mdContext->i[1] += ((UINT4)inLen >> 29);
X
X  while (inLen--) {
X    /* add new character to buffer, increment mdi */
X    mdContext->in[mdi++] = *inBuf++;
X
X    /* transform if necessary */
X    if (mdi == 0x40) {
X      for (i = 0, ii = 0; i < 16; i++, ii += 4)
X        in[i] = (((UINT4)mdContext->in[ii+3]) << 24) |
X                (((UINT4)mdContext->in[ii+2]) << 16) |
X                (((UINT4)mdContext->in[ii+1]) << 8) |
X                ((UINT4)mdContext->in[ii]);
X      Transform (mdContext->buf, in);
X      mdi = 0;
X    }
X  }
X}
X
Xvoid MD4Final (mdContext)
XMD4_CTX *mdContext;
X{
X  UINT4 in[16];
X  int mdi;
X  unsigned int i, ii;
X  unsigned int padLen;
X
X  /* save number of bits */
X  in[14] = mdContext->i[0];
X  in[15] = mdContext->i[1];
X
X  /* compute number of bytes mod 64 */
X  mdi = (int)((mdContext->i[0] >> 3) & 0x3F);
X
X  /* pad out to 56 mod 64 */
X  padLen = (mdi < 56) ? (56 - mdi) : (120 - mdi);
X  MD4Update (mdContext, PADDING, padLen);
X
X  /* append length in bits and transform */
X  for (i = 0, ii = 0; i < 14; i++, ii += 4)
X    in[i] = (((UINT4)mdContext->in[ii+3]) << 24) |
X            (((UINT4)mdContext->in[ii+2]) << 16) |
X            (((UINT4)mdContext->in[ii+1]) << 8) |
X            ((UINT4)mdContext->in[ii]);
X  Transform (mdContext->buf, in);
X
X  /* store buffer in digest */
X  for (i = 0, ii = 0; i < 4; i++, ii += 4) {
X    mdContext->digest[ii] = (unsigned char)(mdContext->buf[i] & 0xFF);
X    mdContext->digest[ii+1] =
X      (unsigned char)((mdContext->buf[i] >> 8) & 0xFF);
X    mdContext->digest[ii+2] =
X      (unsigned char)((mdContext->buf[i] >> 16) & 0xFF);
X    mdContext->digest[ii+3] =
X      (unsigned char)((mdContext->buf[i] >> 24) & 0xFF);
X  }
X}
X
X/* Basic MD4 step. Transform buf based on in.
X */
Xstatic void Transform (buf, in)
XUINT4 *buf;
XUINT4 *in;
X{
X  UINT4 a = buf[0], b = buf[1], c = buf[2], d = buf[3];
X
X  /* Round 1 */
X  FF (a, b, c, d, in[ 0],  3);
X  FF (d, a, b, c, in[ 1],  7);
X  FF (c, d, a, b, in[ 2], 11);
X  FF (b, c, d, a, in[ 3], 19);
X  FF (a, b, c, d, in[ 4],  3);
X  FF (d, a, b, c, in[ 5],  7);
X  FF (c, d, a, b, in[ 6], 11);
X  FF (b, c, d, a, in[ 7], 19);
X  FF (a, b, c, d, in[ 8],  3);
X  FF (d, a, b, c, in[ 9],  7);
X  FF (c, d, a, b, in[10], 11);
X  FF (b, c, d, a, in[11], 19);
X  FF (a, b, c, d, in[12],  3);
X  FF (d, a, b, c, in[13],  7);
X  FF (c, d, a, b, in[14], 11);
X  FF (b, c, d, a, in[15], 19);
X
X  /* Round 2 */
X  GG (a, b, c, d, in[ 0],  3);
X  GG (d, a, b, c, in[ 4],  5);
X  GG (c, d, a, b, in[ 8],  9);
X  GG (b, c, d, a, in[12], 13);
X  GG (a, b, c, d, in[ 1],  3);
X  GG (d, a, b, c, in[ 5],  5);
X  GG (c, d, a, b, in[ 9],  9);
X  GG (b, c, d, a, in[13], 13);
X  GG (a, b, c, d, in[ 2],  3);
X  GG (d, a, b, c, in[ 6],  5);
X  GG (c, d, a, b, in[10],  9);
X  GG (b, c, d, a, in[14], 13);
X  GG (a, b, c, d, in[ 3],  3);
X  GG (d, a, b, c, in[ 7],  5);
X  GG (c, d, a, b, in[11],  9);
X  GG (b, c, d, a, in[15], 13);
X
X  /* Round 3 */
X  HH (a, b, c, d, in[ 0],  3);
X  HH (d, a, b, c, in[ 8],  9);
X  HH (c, d, a, b, in[ 4], 11);
X  HH (b, c, d, a, in[12], 15);
X  HH (a, b, c, d, in[ 2],  3);
X  HH (d, a, b, c, in[10],  9);
X  HH (c, d, a, b, in[ 6], 11);
X  HH (b, c, d, a, in[14], 15);
X  HH (a, b, c, d, in[ 1],  3);
X  HH (d, a, b, c, in[ 9],  9);
X  HH (c, d, a, b, in[ 5], 11);
X  HH (b, c, d, a, in[13], 15);
X  HH (a, b, c, d, in[ 3],  3);
X  HH (d, a, b, c, in[11],  9);
X  HH (c, d, a, b, in[ 7], 11);
X  HH (b, c, d, a, in[15], 15);
X
X  buf[0] += a;
X  buf[1] += b;
X  buf[2] += c;
X  buf[3] += d;
X}
X
X/*
X ***********************************************************************
X ** End of md4.c                                                      **
X ******************************** (cut) ********************************
X */
@EOF
set `wc -lwc <md4.c`
if test $1$2$3 != 22811997675
then
	echo ERROR: wc results of md4.c are $* should be 228 1199 7675
fi

chmod 600 md4.c

if test -f random.c -a $overwrite_opt -eq 0
then
	overwrite_check random.c
fi
echo x - random.c
sed "s/^X//" > random.c <<'@EOF'
X/*
X * $Author: vince $
X * $Header: /staff/vince/src/create_randomness/RCS/random.c,v 1.1 1992/05/08 15:00:28 vince Exp vince $
X * $Date: 1992/05/08 15:00:28 $
X * $Revision: 1.1 $
X * $Locker: vince $
X * $Log: random.c,v $
X * Revision 1.1  1992/05/08  15:00:28  vince
X * AUTOMATIC
X *
X */
X
X#ifndef	lint
Xstatic char *rcsid = "@(#) $Id: random.c,v 1.1 1992/05/08 15:00:28 vince Exp vince $";
X#endif	lint
X
X
X#include <stdio.h>
X#include <signal.h>
X#include <time.h>
X#include <termio.h>
X#include <errno.h>
X#include "md4.h"
X
X#ifdef SIGSET
X#define signal		sigset
X#endif
X
X#define RANDCOMMAND	"/bin/ps -elf"	/* Place here the most verbose
X					** unix command which generates
X					** `unpredictable' output.
X					*/
X
Xvoid		counter(), getdelete();
Xunsigned long	globalcounter = 0L;
Xint		updatepattern = 0;
X
X/*ARGSUSED*/
Xint	main(argc, argv)
Xint	argc;
Xchar	*argv[];
X{
X	unsigned char	random[16];
X	register	i;
X	
X	if (createrandom1(random, sizeof(random)) ||
X	    createrandom2(random, sizeof(random)) ||
X	    createrandom3(random, sizeof(random)))
X		fprintf(stderr, "Failed\n"), exit(1);
X
X	printf("\n## Random pattern: ");
X	for (i = 0; i < sizeof(random); i++)
X		printf("%x", random[i]);
X	(void) putchar('\n');
X
X	return(0);
X}
X
X
X/*
X * Try to generate random values hashing the output of a Unix command whose
X * output is `unpredictable'.
X * After this we XOR with a long random value (see below).
X *
X * Returns: bolean.
X */
Xint		createrandom1(random, randomlen)
Xunsigned char	*random;
Xint		randomlen;
X{
X	FILE		*fp;
X	MD4_CTX		mdContext;
X	register	i;
X	long		morerandom;
X	char		line[256];
X
X	puts("## Using hashing of `unpredictable' data...");
X
X	if (randomlen > 16)
X		return(1);
X
X	if ((fp = popen(RANDCOMMAND, "r")) == NULL) {
X		perror(RANDCOMMAND);
X		return(1);
X	}
X
X	MD4Init(&mdContext);
X	while (fgets(line, sizeof(line), fp) != NULL)
X		MD4Update(&mdContext, line, strlen(line));
X	(void) fclose(fp);
X	MD4Final(&mdContext);
X	
X	/* 
X	 * Yes men, I know this is silly and probabily does not make
X	 * thinks much more secure, but I have a couple more sources
X	 * of randomness and I am going to use them all.
X	 */
X	morerandom = time(NULL) + getpid() * 9;
X
X	for (i = 0; i < randomlen; i++)
X		random[i] = mdContext.digest[i] ^ ((char) morerandom & 0xff);
X	return(0);
X}
X
X/*
X * Generate randomness using delays between keystrokes.
X *
X * Returns: boolean;
X */
Xint		createrandom2(random, randomlen)
Xunsigned char	*random;
Xint		randomlen;
X{
X	register		i, n;
X	char			c;
X	struct itimerval	udt, old_udt;
X	struct termio		tty, otty;
X
X	puts("## Using delays in key stroking with setitimer()");
X
X	if (ioctl(0, TCGETA, &tty) == -1 || ioctl(0, TCGETA, &otty) == -1) {
X		perror("ioctl()");
X		return(1);
X	}
X
X	/* Raw mode */
X        tty.c_cc[VTIME] = 0;
X        tty.c_cc[VMIN]  = 0;
X        tty.c_lflag &= ~(ECHO | ISIG | ICANON);
X        tty.c_oflag &= ~(ONLCR | OPOST);
X        tty.c_iflag &= ~(INLCR | ICRNL | IXON | IXOFF | IUCLC |
X                                                ISTRIP | BRKINT);
X	if (ioctl(0, TCSETA, &tty) == -1) {
X		perror("ioctl()");
X		return(1);
X	}
X
X	udt.it_value.tv_sec = 0;
X	udt.it_value.tv_usec = 1;
X	udt.it_interval.tv_sec = 0;
X	udt.it_interval.tv_usec = 1;
X
X	printf("(Hit any key %d times)\n\r", randomlen);
X        (void) signal(SIGALRM, counter);
X	if (setitimer(ITIMER_REAL, &udt, (struct itimerval *) 0) == -1) {
X		perror("setitimer()");
X		return(1);
X	}
X	for (i = 0; i < randomlen; i++) {
X		for (; ; ) {
X			if ((n = read(0, &c, 1)) == -1) {
X				if (errno == EINTR)
X					continue;
X				else
X					fprintf(stderr, "read() error\n");
X					return(1);
X			}
X			else if (n == 0)
X				continue;
X			else
X				break;
X		}
X		printf("value: %ld\n\r", ((char) globalcounter & 0xff));
X		random[i] ^= ((char) globalcounter & 0xff);
X	}
X	if (ioctl(0, TCSETA, &otty) == -1) {
X		perror("ioctl()");
X		return(1);
X	}
X	return(0);
X}
X
Xvoid	counter()
X{
X#ifndef SIGSET
X	(void) signal(SIGALRM, counter);
X#endif
X	globalcounter++;
X	return;
X}
X
X/*
X * Like createrandom2(), but poll for characters.
X *
X * Returns: boolean.
X */
Xint		createrandom3(random, randomlen)
Xunsigned char	*random;
Xint		randomlen;
X{
X	register	i;
X	puts("## Using delays in key DELETE with polling");
X	printf("(Hit DELETE key %d times)\n", randomlen);
X
X	(void) signal(SIGINT, getdelete);
X	globalcounter = 0L;
X	for (i = 0; i < 16; ) {
X		globalcounter++;
X		if (updatepattern) {
X			updatepattern = 0;
X			random[i++] = ((char) globalcounter & 0xff);
X			printf("value: %d\n", ((char) globalcounter & 0xff));
X		}
X	}
X	return(0);
X}
X
Xvoid	getdelete()
X{
X#ifndef SIGSET
X	(void) signal(SIGINT, getdelete);
X#endif
X	updatepattern = 1;
X}
@EOF
set `wc -lwc <random.c`
if test $1$2$3 != 2146154547
then
	echo ERROR: wc results of random.c are $* should be 214 615 4547
fi

chmod 600 random.c

if test -f Makefile -a $overwrite_opt -eq 0
then
	overwrite_check Makefile
fi
echo x - Makefile
sed "s/^X//" > Makefile <<'@EOF'
X###
X### Makefile for the ``true'' random generator
X###
X
XCFLAGS	= -O $(DEFINES)
X
X
X# If you have BSD's sigset()
XLDFLAGS	= -s
XDEFINES	= -DSIGSET
XLIBS	= -lV3
X
X# otherwise
X#LDFLAGS	= -s
X#DEFINES	= 
X#LIBS		= 
X
XOBJ	= md4.o random.o
XSRC	= md4.c random.c
XETC	= Makefile md4.h
X
Xrandom	: $(OBJ)
X	cc $(LDFLAGS) -o $@  $(OBJ) $(LIBS)
X
Xci	:
X	ci -l -mAUTOMATIC -q  $(SRC) $(ETC)
X
Xlint	:
X	lint $(SRC)
X
Xshar	:
X	shar > create_random.shar $(SRC) $(ETC)
X
Xclean	:
X	/bin/rm -f core random $(OBJ)
@EOF
set `wc -lwc <Makefile`
if test $1$2$3 != 3584474
then
	echo ERROR: wc results of Makefile are $* should be 35 84 474
fi

chmod 600 Makefile

if test -f md4.h -a $overwrite_opt -eq 0
then
	overwrite_check md4.h
fi
echo x - md4.h
sed "s/^X//" > md4.h <<'@EOF'
X/*
X ***********************************************************************
X ** md4.h -- Header file for implementation of MD4                    **
X ** RSA Data Security, Inc. MD4 Message-Digest Algorithm              **
X ** Created: 2/17/90 RLR                                              **
X ** Revised: 12/27/90 SRD,AJ,BSK,JT Reference C version               **
X ***********************************************************************
X */
X
X/*
X ***********************************************************************
X ** Copyright (C) 1990, RSA Data Security, Inc. All rights reserved.  **
X **                                                                   **
X ** License to copy and use this software is granted provided that    **
X ** it is identified as the "RSA Data Security, Inc. MD4 Message      **
X ** Digest Algorithm" in all material mentioning or referencing this  **
X ** software or this function.                                        **
X **                                                                   **
X ** License is also granted to make and use derivative works          **
X ** provided that such works are identified as "derived from the RSA  **
X ** Data Security, Inc. MD4 Message-Digest Algorithm" in all          **
X ** material mentioning or referencing the derived work.              **
X **                                                                   **
X ** RSA Data Security, Inc. makes no representations concerning       **
X ** either the merchantability of this software or the suitability    **
X ** of this software for any particular purpose.  It is provided "as  **
X ** is" without express or implied warranty of any kind.              **
X **                                                                   **
X ** These notices must be retained in any copies of any part of this  **
X ** documentation and/or software.                                    **
X ***********************************************************************
X */
X
X/* typedef a 32 bit type */
Xtypedef unsigned long int UINT4;
X
X/* Data structure for MD4 (Message-Digest) computation */
Xtypedef struct {
X  UINT4 i[2];                   /* number of _bits_ handled mod 2^64 */
X  UINT4 buf[4];                                    /* scratch buffer */
X  unsigned char in[64];                              /* input buffer */
X  unsigned char digest[16];     /* actual digest after MD4Final call */
X} MD4_CTX;
X
Xvoid MD4Init ();
Xvoid MD4Update ();
Xvoid MD4Final ();
X
X/*
X ***********************************************************************
X ** End of md4.h                                                      **
X ******************************** (cut) ********************************
X */
@EOF
set `wc -lwc <md4.h`
if test $1$2$3 != 532902705
then
	echo ERROR: wc results of md4.h are $* should be 53 290 2705
fi

chmod 600 md4.h

echo shar: End of shell archive.
exit 0
-- 
David Vincenzetti              EMAIL: vince@ghost.dsi.unimi.it
|"We live as we dream: alone"| SNAIL: 8th street 39, 20090 Segrate, ITALY
|          --Joseph Conrad   |   ORG: DSI, Universita` degli Studi di Milano
