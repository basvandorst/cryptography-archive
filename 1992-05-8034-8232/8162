Newsgroups: sci.crypt
Path: msuinfo!caen!nigel.msen.com!yale.edu!jvnc.net!darwin.sura.net!Sirius.dfn.de!zrz.tu-berlin.de!math.fu-berlin.de!NewsServ!zeisset
From: zeisset@Informatik.TU-Muenchen.DE (Stephan Zeisset)
Subject: Re: Random Generator for encryption
References:   <1992May15.115345.1882@Informatik.TU-Muenchen.DE> <1992May15.140309.5577@nntpd.lkg.dec.com>
Originator: zeisset@hphalle2i.informatik.tu-muenchen.de
Sender: news@Informatik.TU-Muenchen.DE (USENET Newssystem)
Organization: TU M"unchen (FRG)
Date: Tue, 19 May 1992 10:32:23 GMT
Message-ID: <1992May19.103223.25828@Informatik.TU-Muenchen.DE>
Lines: 27


In article <1992May15.140309.5577@nntpd.lkg.dec.com>, palmer@tallis.enet.dec.com (Colonel Mode) writes:
|> Have you actually tested the output of your RNJ using a battery of statistical
|> tests for randomness? I did not completely follow what you were doing in your
|> diagram step #2, can you determine the period of the RNJ? I suspect that this
|> generator will not pass a spectral analysis or have an adequately long period.

The period length of this generator should be something near
to 2^b^l where b is the wordsize of the table entries and l
the number of entries.
Take b=8 (Byte entries) and l=256.
This gives you something like 2^2048 which should suffice for
not getting the same sequence twice till doomsday.

The idea behind this is that due to the backcoupling of
the output into the table index, the state of the advanced
random generator extends to the whole table.

The main goal of steps 2) and 3) is to hide away the
original G_i's state from an observer who knows large
parts of the plaintext and ciphertext.
This is done by increasing the state (2) and mixing the output
of different A_i's (3), so you get an enourmous amount of
possibilities, where the actual random number came from.

Stephan.

