Xref: msuinfo comp.arch:30490 sci.crypt:8036
Path: msuinfo!uchinews!linac!pacific.mps.ohio-state.edu!zaphod.mps.ohio-state.edu!mips!swrinde!gatech!willis.cis.uab.edu!hyatt
From: hyatt@cis.uab.edu (Robert Hyatt)
Newsgroups: comp.arch,sci.crypt
Subject: Re: The NSA Instruction
Message-ID: <1992Apr30.015802.15355@cis.uab.edu>
Date: 30 Apr 92 01:58:02 GMT
References: <29354@hoptoad.uucp> <1992Apr29.214606.28406@dcc.uchile.cl>
Sender: root@cis.uab.edu (Bruce Williams)
Organization: University of Alabama at Birmingham
Lines: 40

In article <1992Apr29.214606.28406@dcc.uchile.cl> pchris@pehuen.dcc.uchile.cl (Chris Perleberg) writes:
>In article <29354@hoptoad.uucp>, gnu@hoptoad.uucp (John Gilmore) writes:
>> It occurred to me to wonder just how many architectures have the following
>> instructions:
>> 
>> 	Population Count -- tell me how many 1-bits are in this word
>> 
>> 	Find First One (or Zero) -- can speed up emulation
>> 				    of popcount on machines without it
>> 
>> I have gotten the impression that the Pop Count instruction has been
>> added to more than one architecture upon direct request from the US National
>> Security Agency, because it apparently occurs frequently in their inner
>> loops, but is slow to emulate in software (table lookup on parts of the word,
>> followed by addition of the table entries, seems best to me).
>
>More than once I've needed this instruction (Population Count) for 
>text pattern matching algorithms.  But I've never encountered a machine 
>that supported it, and doing table lookup on parts of the word is too 
>costly....  Then you have the problem of how to specify in C that you 
>want to use this instruction....
>
>	Chris Perleberg
>	pchris@dcc.uchile.cl


Check out the Crays for the Pop count instruction.  Several in years past
had a shift searching or some such instruction that would count leading
zeroes or ones, depending on how you coded it.  Haven't assem. programmed
a vax in 8 years or so but seem to recall such an instruction was the
reason the current unix kernel uses it's 32 run queues that use a single
bit to indicate that a queue is non-empty, (each queue is 4 or more priority
classes lumped together, you test a bit rather than testing 4 separate linked
lists, but you don't have to test each bit sequentially, but count the
leading zeroes, add one and that is the run queue that is non-empty.)


-- 
!Robert Hyatt                    Computer and Information Sciences   !
!hyatt@cis.uab.edu               University of Alabama at Birmingham !
