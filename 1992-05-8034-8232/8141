Newsgroups: sci.crypt
Path: msuinfo!caen!zaphod.mps.ohio-state.edu!mips!darwin.sura.net!Sirius.dfn.de!math.fu-berlin.de!NewsServ!zeisset
From: zeisset@Informatik.TU-Muenchen.DE (Stephan Zeisset)
Subject: Random Generator for encryption
Originator: zeisset@hphalle8.informatik.tu-muenchen.de
Sender: news@Informatik.TU-Muenchen.DE (USENET Newssystem)
Organization: TU M"unchen (FRG)
Date: Fri, 15 May 1992 11:53:45 GMT
Message-ID: <1992May15.115345.1882@Informatik.TU-Muenchen.DE>
Lines: 100


What do you think of the following method for generating
pseudo-random numbers ?:

1) Take some simple generators G_i, i=1..n 
   which are based on the linear congruential method x` = (m*x+c) mod b
   or on a (short) table of random numbers.

2) Now increase the number of states of these generators
   by using an intermediate table with an back-coupled index
   (to increase also the cycle length).

   So you get advanced random generators A_i:

   --------------  upper bits
  |     G_i      | ----------- XOR -------- previous number 
   --------------               |                 ^
         | lower bits		|                 |
         |			|index i          |
         |			v                 |
         |                  ---------             |
         |                 |   z0    |            |
         |		    ---------             |
         |                 |   z1    |            |
         |		    ---------             |
         |                     ...                |
         |      replace     ---------             |
         +---------------> |   zi    | -----------+---------------->
			    ---------                        output
			       ... 
                            ---------
			   |   zl    | 
			    ---------

3) Use the andvanced generators A_i to hide the plaintext, e.g:

    -------------
   |     A_1     |------+      plain text
    -------------       |           |
                        |           |
    -------------       |           | 
   |     A_2     |-----XOR---------XOR
    -------------       |    Rx     |
                        |           |
    -------------       |           |
   |     A_3     |------+           v
    -------------              ciphertext


Now we can start by:
- Setting the initial state of the simple generators
  to KEY xor MESSAGE NUMBER      
  The Message Number is incremented after each process,
  so two Messages won't have the same coding.
  The Message Number can be sent in plaintext
- Doing some loops (say 1000000) to initialize the intermediate
  tables
- Coding the plain text / Decoding the ciphertext

One might improve the scheme by partitioning the input stream
into blocks and using one of the A_i`s for permutating it
before XORing the data with the other A_i`s.
For further security couple the input stream back into the
G_i`s (e.g. take more G_i`s than A_i`s and let the input
stream select, which G_i feeds which A_i)

On my 486` I get a hand-coded en/decryption rate of 1 MByte/s,
using n=3 and the following G_i`s:

          last number <----+
              |            |
	      |index       |
	      V            |
          ---------        |
         |         |       |
	  ---------        |
	     ...           |
          ---------        |
         |         |-------+-----------> 
	  ---------              output
             ...
          ---------
         |         |
	  ---------

Table of a random permutation of 1..k

This gives a cycle lenght of k.
In my implementation the tables are generated by first
using the linear congruential method for the G_i`s,
initializing the tables with the generated Rx`s and then
switching to the above generators for speeds sake (You
wouldn't believe, how much cycles multiplications
and divisions take on an i486 microprocessor)

If you consider this a good method, save this article, so no
one can patent it and later forbid it`s use.
If not, tell me why.

Stephan Zeisset
