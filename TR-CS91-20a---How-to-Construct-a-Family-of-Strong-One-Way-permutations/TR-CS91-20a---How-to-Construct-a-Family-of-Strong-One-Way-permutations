                              How to Construct
                A Family of Strong One Way Permutations *


                              Babak Sadeghiyan
                                Yuliang Zheng
                                Josef Pieprzyk


                      Department of Computer Science,
                              University College,
                       University of New South Wales,
                     Australian Defence Force Academy,
                      Canberra, A.C.T. 2600, Australia.


                                   Abstract

          Much effort has been spent to identify the hard bits of
       one way functions, such as RSA and Rabin encryption
       functions. These efforts have been restricted to O(log n) hard
       bits. In this paper, we propose practical solutions for
       constructing a family of strong one way permutations such
       that when a member is chosen uniformly at random, with a
       high probability we get a one way permutation m, with
       t < n - O(log n), the maximum number of simultaneous hard
       bits. We propose two schemes. In the first scheme m is
       constructed with O(log n) fold iteration of f O g, where f is
       any one way permutation, g 2r G and G is a strongly
       universal2   family of polynomials in Galois field. In the
       second scheme m = f O g O h, where h is a hiding
       permutation. We suggest a practical solution based on this
       scheme. The strong one way permutations can be applied as
       an efficient tool to build pseudorandom bit generators and
       universal one way hash functions.
________________________________*
     Support for this project was provided in part by TELECOM Aus-
tralia under the contract number 7027 and by ARC Grant under reference
number A48830241.

                                        1


1   Introduction


One way functions are those functions which are, roughly speaking easy
to compute but hard to invert. One way functions are primitive tools for
many cryptographic applications such as pseudorandom bit generation,
hashing schemes and so on. In [7 ], it is proved that the existence of any
one way function is a necessary and sufficient condition for the existence
of pseudorandom bit generators. And in [9 ], it is shown that the
existence of one way functions is also a necessary and sufficient condition
for the existence of one way hash functions and secure signature schemes.
On the other hand, Blum and Micali [2 ] discovered the hard predicates b
of one way functions f and applied it for the construction of
pseudorandom bit generators (PBG). Such a b(x), is hard to evaluate,
when the value of f (x) is given. They applied the hard core predicate b
to extract some bits from each iteration of f . Some one way functions
have the interesting feature of existence of hard  bits in their argument.
These bits cannot be computed by any family of probabilistic polynomial
time algorithms with a probability of success better than by flipping a
coin. In other words, hard bits are those bits of the argument of a one
way function that distinguishing them from random bits is as difficult as
inverting the one way function itself. If such a one way function is
applied in the Blum-Micali pseudorandom bit generator scheme, a
function which extracts the hard bit of the one way function could be
used as a hard core predicate. The efficiency of Blum-Micali
pseudorandom bit generator can be improved if a longer string of bits
could be extracted with b.
In [14 ], a duality between pseudorandom bit generators and one way
hash functions was revealed. Applying the revealed duality, a universal
one way hash function scheme, which is the dual of the Blum-Micali
pseudorandom bit generator is proposed. This scheme is based on a
insertion function which substitutes a bit of the position of a hard bit
with a bit of the string of the message. The efficiency of the proposed
scheme also can be improved if the applied one way permutation has
more hard bits. So if there was a one way permutation which had more
hard bits, a more efficient pseudorandom bit generator and also a more
efficient universal one way hash function could be constructed.
Much effort has been spent to identify hard bits of some specific number
theoretic one way functions. In [1 ], it is shown that the O(log n) least
siginficant bits of the RSA and Rabin encryption functions are
individually hard, and that those O(log n) bits are also simultaneously
hard. In addition, it is shown in [8 ] that the exponentiation function, i.e.
f (x) = gx (mod  P ), where P is a prime and g is a generator of Z*P, has
also O(log n) hard bits. Both these works take advantage of complicated
techniques based on number theoretic approaches.


A breakthrough in this area is due to Goldreich and Levin [5 ] who have
shown how to build a hard core predicate for all one way functions.
They have extended the construction to show that O(log n)
pseudorandom bits could be extracted from any one way function. Their
result cannot be improved without imposing additional assumptions on
the one way function [5 ], leaving the problem of constructing a function
with O(n) simultaneous hard bits open. However, if a one way function
is proven to have a better security, then more number of pseudorandom
bits could be extracted with the same method.
In [3 ], [6 ] a construction for a probabilistic encryption function has been
presented, for which all the bits of the presented one way function are
simultaneously hard. This construction is based on the composition of
hard bits from many one way functions.
Another significant work in this area is due to Schrift and Shamir. They
have shown in [11 ] that half of the input bits of exponentiation function
modulo a Blum integer, i.e. f (x) = gx (mod  N ) where N is a Blum
integer, are simultaneously hard and almost all bits are individually hard
to evaluate. This work also take advantage of complicated techniques.
As a result exponentiation modulo a Blum integer is yet the only natural
function with O(n) proven simultaneous hard bits.
In [10 ], a n-bit one way permutation such that each input bits is
individually hard and any t < n - O(log n) input bits are simultaneously
hard is called a strong one-way permutation 1.
In this paper, we show how to construct a family of strong one way
permutations, such that when a member is chosen uniformly at random,
a one way function that all its input bits are hard and any
t < n - O(log n) input bits is indistinguishable from a random string is
obtained, with a high probability. In contrast with [6 ], which composes
hard bits of many one way functions, we compose the one way
permutations to get a strong one way permutation. Two practical
schemes has been proposed. Both schemes take avdantage of the family
of polynomials in Galois field. The first scheme is based on the existence
of any one way function and is constructed with O( _n___logn) fold
composition of the one way function and a randomly chosen element of
the family of polynomials in Galois field. The second scheme is based on
the existence of a hiding one way permutation, and is constructed with a
three layer structure applying a hiding one way permutation, a randomly
chosen element of the family of polynomials in Galois field and any one
way permutation.
Section 2 provides the notation used in the paper. Section 3 gives
preliminary definitions and represents the concept of hard bits. In
________________________________
    1Note that the term of strongly one-way permutation has been used

in [4 ], with a different meaning.


section 4, first the definition for strong one way permutations are given,
then some properties of polynomials in Galois field have been
investigated, and finally the proposed constructions have been studied.


2   Notations


The notation we use here is similar to [14 ]. The set of all integers is
denoted by N. Let   = {0; 1} be the alphabet we consider. For n 2 N ,
 n is the set of all binary strings of length n. The concatenation of two
binary strings x; y is denoted by x k y. The bit-by-bit exclusive-or of x; y
is denoted by x   y. The length of a string x is denoted by | x |. The
number of elements in a set S is denoted by #S.
Let l be a monotone increasingSfunction from N toSN and f a function
from D to R, where D =   n Dn , Dn    n and R =   n Rn , Rn    l(n).
D is called the domain and R the range of f . Denote by fn the
restriction of f on  n . f is a permutation if each fn is a 1 to 1 and onto
function. f is polynomial time computable if there is a polynomial time
algorithm computing f (x) for all x 2 D. The composition of two
functions f and g is defined as f O g(x) = f (g(x)). The i-fold
composition of f is denoted by f (i).
A (probability) ensemble E, with length l(n), is a family of probability
distributions {En | En :  l(n) ! [0; 1]; n 2 N }. The uniform ensemble U
with length l(n) is the family of uniform probability distributions Un ,
where each Un is defined as Un (x) = __1__2l(n), for all x 2  l(n). By
x 2E   l(n) we mean that x is randomly selected from  l(n) according to
En , and in particular by x 2r S we mean that x is chosen from the set S
uniformly at random.


3   Preliminaries


Definition  1    A  statistical__test____ is  a  probabilistic  algorithm
T  that  on  an  input  x,  where  x  is  an  n-bit  string,  halts  in
O(nt)  and  outputs  a  bit  0=1,  where  t  is  some  fixed  positive
integer.


Definition  2    Let  l  be  a  polynomial,  and  E1  and  E2  be
ensembles  both  with  length  l(n).   E1  and  E2  are  called
indistinguishable______ from  each  other,  if  for  each  statistical
test  T ,  for  each  polynomial  Q,  for  all  sufficiently  large
n,

              | P rob{T (x1) = 1} - P rob{T (x2) = 1} |< __1___Q(n)


where  x1 2E1   l(n),  x2 2E2   l(n).

                                             S                S
Definition  3    Let  f : D ! R,  where  D =   n  n  and  R =   n  l(n),
be  a  polynomial  time  computable  function.   We  say  that  f  is
one-way___ if  for  each  probabilistic  polynomial  time  algorithm
M ,  for  each  polynomial  Q  and  for  all  sufficiently  large  n,


                   P rob{fn (M (fn (x))) = fn (x)} < __1___Q(n)


where  x 2U  Dn .


Note that the one-way property of a function is relative to a specific
model of computation with a specific amount of computing resources.
For the remaining of this paper, we assume that we have a computing
resource for at most 2k(n) operations, where k(n) = O(log n) bits. We
also assume k+ (n) is a function with a growth rate slightly more than
k(n) such that n - k+  > k. As an example, consider
k+ (n) = O(log1:01(n)).
If a function f is one-way then given f (x) the argument x must be
unpredictable. If every bit of the argument x were easily computable
from f (x), then f would not be a one-way function. Hard bits are some
specific bits of the argument which are unpredictable and cannot also be
guessed with a probability better than by flipping a coin [2 ], [14 ].


DefinitionS 4    Let Sf : D ! R  be  a  one-way  function,  where
R =   n  n  and  D =   n  l(n).   Let  i(n)  be  a  function  from  N  to
N  with  1   i(n)   n.   If  for  each  probabilistic  polynomial
time  algorithm  M ,  for  each  Q  and  for  all  sufficiently  large
n,

                    P rob{M (fn (x)) = x0i(n)} < 1_2+ __1___Q(n)


where  x 2r  n  and  x0i(n)is  the  i(n)-th  bit  of  an  x0 2  n
satisfying  f (x) = f (x0),  then  i(n)-th  bit  is  a  hard__bit__of  f .


It can be shown that all the hard bits are independent of one another,
and any string of t   k hard bits is indistinguishable from a random
string, when only f (x) is given. Such strings of bits which are
indistinguishable from random strings bits are called simultaneous hard
bits.
Note that, there may exist some one way functions which do not have
any hard bit. Note also that, any one-way function should have more
than k(n) = O(log n) bits which are unpredictable, although they can be
biased.
Blum and Micali discovered the hard core predicates of functions and
applied it to construct pseudorandom bit generators (PBG) [2 ]. If a one
way permutation f had t = n - k+  (the maximum possible) known


simultaneous hard bits, it could be used for the Blum-Micali
pseudorandom bit generator scheme to get maximum number of bits per
iteration of f . We call such a one way permutation a strong one way
permutation or simply a strong permutation.


4   Strong  One  Way  Permutations


In this section we construct a strong one-way permutation. First, we give
a formal definition for strong one way permutations, which achieve the
maximum number of simultaneous hard bits.


Definition S5    Assume  that  m : D ! D  is  a  one-way  permutation,
where  D =   n  n .   Also  assume  that  I = {i1; i2; : :;:it}  where
i1; i2; : :;:it are  functions  from  N  to  N ,  with  1   ij(n)   n  for
each  1   j < n - k.   Denote  by  EIn and  ERn the  probability
distributions  defined  by  the  random  variables  xit(n): :x:i2(n)
xi1(n) k m(x)  and  rt : :r:2 r1 k m(x)  respectively,  where  x 2r  n ,
xij(n) is  the  ij(n)-th  bit  of  x  and  rj 2r  .   Let
EI = {EIn| n 2 N }  and  ER  = {ERn | n 2 N }.   We  call  m  a
strong__one__way__permutation______ if  EI  and  ER  are
indistinguishable  from  each  other,  for  any  I.


In other words, given m(x), any string of t < n - k bits of x is
indistinguishable from a random string.
In the proposed schemes for the construction of strong one way
permutations, we take advantage of polynomials over Galois field
GF (2n ). In the following, some properties of these polynomials which are
of our interest are presented. First, we consider the notion of strongly
universal   2 hash functions, presented by Carter and Wegman in [13 ].


Definition  6    Suppose  G  is  a  set  of  functions  and  each
element  of  G  being  a  function  from  A  to  B.   G  is
strongly__universal__2___ if  given  any  two  distinct  elements  a1,  a2

of  A  and  any  two  elements  b1,  b2  of  B,  then  (#G)__(#B)2functions
take  a1  to  b1  and  a2  to  b2.


In other words, the values of g(x) and g(y) are independently and
uniformly distributed in B for every x; y 2 A, when g 2 G is chosen
uniformly at random. Strongly universal   2 sets of functions can be
created using polynomials over finite fields. As the simplest example
consider G = {g | g(x) = px + q; p; q 2 GF  (2n )} in the finite field GF  (2n )
[13 ].
Here, we give the definition of complete permutations, which is a design
criteria for good encrypting functions.


Definition  7    We  say  a  permutation  v  is  complete___if  each
output  bit  depends  on  all  input  bits  and  vice-versa.   In
other  words,  the  Boolean  expression  for  each  output  bit
contains  all  the  input  bits,  and  vice-versa.


Since the operation in Galois field GF  (2n ) is done modulo an irreducible
polynomial the resultant permutation is also complete, due to the
properties of operations in Galois fields.
Example: We investigate the case for GF  (23). Here, x is a string of
three bits, i.e. x2; x1; x0, and is presented as the polynomial
x2z2 + x1z + x0 and p is presented as p2z2 + p1z + p0 and q as
q2z2 + q1z + q0. There are two irreducible polynomial in GF  (23), which
are z3 = z + 1 and z3 = z2 + 1.
For z3 = z + 1:



     g(x) = px + q =          (q2 + p2x0_+_p1x1_+_p0x2___+ p2x2)z2

                         +    (q1 + p1x0_+_p0x1_+_p2x2___+ p2x1 + p1x2)z

                         +    (q0 + p0x0_+_p2x1_+_p1x2___)


and for z3 = z2 + 1:



     g(x) = px + q =         (q2 + p2x0_+_p1x1_+_p0x2___+ p2x2 + p2x1)z2

                         +   (q1 + p1x0_+_p0x1_+_p2x2___)z

                         +   (q0 + p0x0_+_p2x1_+_p1x2___+ p2x2)


Either irreducible polynomial has produced some common terms, which
are functions of all the input bits, and some different terms in the
coefficients of g(x). So, it is clear that polynomials in GF  (2n ) result in a
complete permutation. This would happen if the operation performed in
any GF  (2n ). Notice that when p; q are chosen at random, for every x; y
the outputs would be uniformly and independently distributed.
When we are operating in GF  (2) the multiplication is equivalent to
`AND' operation and addition is equivalent to `XOR' operation. So each
coefficient in g(x) is the inner product of x with a different string
obtained from p. Note that, if we present x and g(x) as two vectors, they
can be related to each other with a system of n linear equations. In the
above example when the irreducible polynomial is z3 = z + 1 the above
equations can be represented as
              0 2                          3 2      3   2     3 1
                   p0 + p2      p1      p2      x2         q2
g(x) = px+q = @ 4  p1 + p2   p0 + p2    p1 5 4  x1  5 + 4  q1 5 A     z2   z1  *
 * z0
                      p1        p2      p0      x0         q0


If we had applied polynomials of higher degrees, such as
g(x) = ffx2 + fix + fl, a similar result would be obtained. For the
remaining of the paper, we use the simplest case g(x) = px + q, although
all the following lemmas and theorems are also true when g is of a higher
degree. Notice that the above relation can be stated in a vector
representation as
                                 g_(x_) = p_x_+ q_

Moreover, p_and q_can be modified in a way such that g_and x_become
related to each other through a Toeplitz matrix, where a Toeplitz matrix
is a matrix M such that Mi;j= Mi+1;j+1  for all i; j. For the above
example, we may write
       2                                               3  2     3   2     3
          p0 + p2 + r2         p1             p2            x2         q02
   g_= 4  p1 + p2 + r1   p0 + p2 + r2         p1       5  4 x1  5 + 4  q015
             p1 + r0     p1 + p2 + r1    p0 + p2 + r2       x0         q00

          2     3
             r2
where r_= 4  r1 5  is a randomly chosen vector, and q02= q2 + r2x2 and
             r0
q01= q1 + r1x2 + r2x1 and q00= q0 + r0x2 + (p1 + r1)x1 + (p2 + r2)x0.


Lemma  1   If  g(x) = px + q,  where  p; q 2 GF  (2n )  are  chosen
randomly  and  are  known,  and  n - k+  bits  of  the  g(x)  is  known
(or  its  k+  bits  are  unknown),  then  the  overall  probability
to  guess  each  bit  of  x  is  equal  to  _1__2k+.



Proof  :  Assume that there is an algorithm L that given p; q and some
bits of g(x) lists all possible values of x. Since g is a permutation, if one
bit of g(x) is given, L would list all possible values of x which would be
2n-1  elements on average. In general, given i bits of g(x), L lists 2n-i
possible values of x. If n - k+  bits of g(x) is given, L would list 2k+
possible elements for x. One can guess the correct value of x with a
probability of __1_2k+. Since g is a complete permutation and p and q are
chosen randomly, the probability of guessing any bit of x is equal to the
probability of guessing the value of x.                                    2

Note that, for some specific values of p; q some bits of x could be guessed
efficiently, but when we consider the probability of guessing any bit of x
over all values of p; q, it is equal to __1_2k+.


LemmaS 2   Let  m : D ! D  be  a  one-way  permutation  where
D =   n  n  and  m = f O g,  where  f  is  a  one-way  permutation,
and  g = px + q  where  p; q 2r GF  (2n ).   Also  assume  that
i1; i2; : :;:ik  are  functions  from  N  to  N ,  with  1   ij(n)   n  for


each  1   j   k  and  k = O(log n).   Denote  by  E1n and  E2n the
probability  distributions  defined  by  the  random  variables
xik(n): : :xi2(n) xi1(n) k m(x)  and  rk : :r:2 r1 k m(x)  respectively,
where  x 2r  n ,  xij(n) is  the  ij(n)-th  bit  of  x  and  rj 2r  .   Let
E1 = {E1n| n 2 N }  and  E2 = {E2n| n 2 N },  then  E1  and  E2  are
indistinguishable  from  each  other.


In other words, given m(x), the probability of distinguishing any k-bit
string of x from random strings is less than _1_2k, where k = O(log n) when
the probability is calculated over all values of p; q.
Note that Lemma 2 virtually says that, given  f (x0)  and
p0; q0 2r GF  (2n )  it  is  hard  to  guess  any  O(log n)  bits  of  x,
where  f (x0) = f O g(x) = m(x). As x = p0x0 + q0 is the inverse of
g(x) = x0 = px + q, p; q 2r GF  (2n ). So x is actually the concatenation of
the inner products of x0 with n different strings obtained from p0.

Proof  :  Goldreich and Levin [5 ] showed that:
given  f (x0)  and  p0,  where  f  is  any  one  way  function  and
| p0 |=| x0 |  and  p0 is  an  arbitrary  string,  the  inner  product  of
x0 and  p0 is  an  hard-core  predicate  of  f ,  and  cannot  be
guessed  with  a  probability  better  than  1_2+ __1____Q(|x0|)= 1_2+ __1__Q(n*
 *)for
each  probabilistic  polynomial  time  algorithm  and  for  each  Q.
They also extended their result and showed that O(log n) hard bits can
be obtained from any one way function, where the simultaneous hard
bits are the inner product of O(log n) different n-bit strings with x0.
According to [5 ], the set of strings may also form a Toeplitz matrix,
where a Toeplitz matrix is a matrix M such that for all i; j
Mi;j= Mi+1;j+1 . As mentioned earlier, the matrix which relates x to
g(x) can be rearranged into a Toeplitz matrix, so the same sort of proof
that has been given in [5 ] could similarly be presented here to show that
any k bit of x is indistinguishable from a random string when m(x) is
given.
As a simple and informal justification, assume that f is a one way
permutation which acts on k+  bits and keeps the other bits unchanged.
So, given m(x) = f O g(x), it is hard to guess k+  bits of g(x), but n - k+
bits of g(x) can be guessed efficiently. As it was suggested earlier, x and
g(x) are related to each other with a system of n equations with n
variables. When n - k+  bits of g(x) are known, the system of equations
would be reduced to a system of k+  variables. However, if any k+ -bit
string of x is given, the system of equations can be solved and the values
of k+  unknown bits of g(x) would be revealed. Since there is no
algorithm which can invert f with a probability better than __1_2k+, any bit

of x cannot be guessed with an overall probability better than 1_2+ _1__2k+.
Moreover, any probabilistic algorithm M that could distinguish any t   k


bit string of x from a random string with a probability better than __1_2k+,
                                                                    t
would be able to invert f with an overall probability better than _2__2k+
which contradicts our assumption that f is a one way permutation.    2

The result of Lemma 2 can be compared with the results of Vazirani and
Vazirani [12 ], where it is shown that the XOR of any non-empty subset
of hard bits is also hard to guess. Altogether, it can be concluded that
all bits of x are individually hard, and any k = O(log n) bits of x are
simultaneously hard bits of f O g and cannot be distinguished from a
random string with a probability of success better than _1_2k, when the
probability is computed over all values of p; q.


4.1    A  scheme  for  the  construction  of  strong  permutations

With Goldreich-Levin method, only O(log n) pseudorandom bits could
be extracted from any one way function. This number of pseudorandom
bits cannot be improved without additional assumptions. The reason is
that a one way function which cannot be inverted with a probability
better than __1__Q(n), may act only on log Q(n) of the bits of x and leave the
rest unchanged [5 ]. In Lemma 2, we constructed a one way permutation
f O g such that any k input bits cannot be distinguished from a random
string. If we apply f O g as a one way permutation in the Blum-Micali
pseudorandom bit generator, any k bits can be extracted per iteration of
f O g. We take advantage of such a one way permutation to construct a
family of strong permutations.
In the following, we suggest two schemes to obtain strong permutations
and present the theorems behind them. The first scheme is based on the
t fold composition of the f O g.


TheoremS 1   Let  m : D ! D  be  a  one-way  permutation  where
D =   n  n  and  m = (f O g)s = (f_O_g)_O_:_:O:(f-Ozg)_______",  where  f  is  a

                                        s times
one-way  permutation,  and  s = O( _n___logn),  and  g = px + q  where
p; q 2r GF  (2n ).   Then  m  is  a  strong  one  way  permutation.



Proof  :  First, we show that (f O g)2 = f O g O f O g has 2k hard bits.
Let's notate the first k bits string of x as x 1 , its second k bits as x 2
and so on, and consider y = f O g(x). Given (f O g)2(x), x 2  k y 1  is
indistinguishable from a random string, since according to Blum-Micali
pseudorandom bit generator [2 ] the concatenation of hard bits from each
iteration would be indistinguishable from a random string, and according
to Lemma 2 any k bit of f O g is indistinguishable from a random string.
As x 2  k y 1  forms a 2k-bit string, then x   y has 2k bits which cannot


be guessed efficiently. Since any k bit of f O g is indistinguishable from a
random string, any 2k-bit string of x   y is indistinguishable from a
random string. So, for each probabilistic polynomial time algorithm M


                    Prob {M [(f O g)2(x)] = x   y} < __1__+
                                                     22k

In the following, it is shown that the above relation implies that:


                      Prob {M [(f O g)2(x)] = x} < __1__+
                                                   22k

To justify the above claim, by contradiction assume that there is an
probabilistic algorithm M 0that can compute x with a probability better
than _1_22k, we apply M 0in another probabilistic algorithm M 00to compute
the value of x   y with a probability better than _1_22k. M 00first runs M 0

on (f O g)2(x) to get the value of x. As the description of f and g is
known, then M 00runs f O g on x to find the value of y. M 00gives x   y as
its output. If the value of x is correct, the value of y would be correct
with probability 1. Hence, M 00outputs the correct value for x   y with a
probability better than _1_22k. This contradicts our assumtion that x   y
cannot be guessed with a probability better than _1_22k. So, it can be
concluded that for each probabilistic polynomial time algorithm M


                      Prob {M [(f O g)2(x)] = x} < __1__+
                                                   22k

As the number of pseudorandom bits extracted from a one way function
with Goldreich-Levin method is confined to the security parameter of the
one way function, then 2k simultaneous hard bits could be extracted
from (f O g)2. This can be done by choosing a random 2k x n Toeplitz
matrix, and multiplying it by x. Notice that, since p; q are chosen
randomly and independently, the matrix which relates g(x) to x can be
arranged in a Toeplitz matrix form. In addition, the matrix could be
arranged in a way that for any determined 2k bits of x, the
corresponding rows form a Toeplitz matrix. Hence, given (f O g)2(x), any
2k bit of x cannot be distinguished from a random string. This completes
the proof that two fold iteration of f O g produces a one way function
such that every 2k input bits are indistinguishable from a random string.
By induction method and performing a proof similar as above, it can be
shown that for (f O g)i(x), each input bit is individually a hard bit and
any ik input bits are simultaneous hard bits. Therefore, to obtain a one
way permutation with any n - k input bits simultaneously hard, it is
enough to constructian n_kfoldjof f O g. With k = O(log n), a

construction of O   _n___lognfold of f O g is needed, which would be

performed in polynomial time anyhow.                                   2
