
6.3   Parametrization

Since the hash function presented in corollary 5 is a universal one-way
hash function, we should parametrize it to make it secure in a practical
scenario. The parametrization can be done in two different ways:


   1. we can parametrize h by selecting v from a family of k + 1-bit
      perfect permutations. Then H = {h = chop tO f O v O f | v 2 Vn }
      where Vn is the k + 1-bit perfect permutation family and chop t
      simply chops the t last bits.

   2. we can parametrize h by selecting the function for the compressing
      procedure from a family of hash functions. we may consider this
      family to be a family of chop  functions. In this case, the number of
      bits required to specify a member of the family is at most equal to
      (n - k - 1) log2n. However, we may also consider this family to be
      a family of t to 1 strongly universal hash function, as proposed in
      [8].


6.4   Compressing Arbitrary Length Messages

One of the main properties of hash functions is that they should be
applied to any argument of any size. Damgard suggested a design
principle in [4] based on fixed size collision free hash functions. Another
method has been appeared in [13 ] and is the dual of Blum-Micali
pseudorandom bit generator (let us call it ZMI method). We show that
using the perfect one-way permutation proposed in theorem 4, these two
methods actually yield one scheme for hashing long messages.
Damgard's design principle: Let l(n) be a polynomial with l(n) > n,
let f be a collision free one-way hash function f :  n+t !  n , ff 2r  n ,
split l(n)-bit message x into t bit blocks, let the blocks be denoted by
x1; x2; : :;:x l(n)_t. Let y0 = ff and yi+1 = f(yi k xi+1), then h(x) = y l(n)_t

would be the hash value of the long message x.
ZMI method: Let f be a one-way permutation f :  n+t !  n+t , let
I(n) = (i1; i2; : :;:it) denote the known simultaneously hard bits of f, let
x = xt: : :x2x1 2  t, b 2  n , define:


                    ins I(n)(b; x) = : :b:ix1bi-1 : :b:2b1


Let z 2  n+t , denote by drop I(n)(z) a function dropping the i1-th, : :,:
it-th bits of z. Let l be a polynomial with l(n) > n, ff 2  n , split l(n)-bit
message x into t bit blocks be denoted by x1; x2; : :;:x l(n)_t, where xi 2  t

for each 1   i   l(n)_t. Let


              y0   =   ff



                                    12


                    ..
                    .

               yi  =   drop I(n)(f(ins I(n)(yi-1; x l(n)_t-i+1)))


then h(x) = y l(n)_t= drop I(n)(f(ins I(n)(y l(n)_t-1; x1))), (in the original

ZMI scheme h(x) = f(ins I(n)(y l(n)_t-1; x1))).

If we use the strong one-way permutation m in ZMI scheme for f, since
the t least significant bits are simultaneously hard bits, then drop I(n)
function performs identically to the chop tfunction defined in corollary 5.
So, drop I(n)(f(x)) in ZMI method would be identical to chop t(m(x)) of
corollary 5, which is a universal one-way hash function from  n+t to  n .
On the other hand, when t last bits of a function are simultaneously
hard bits, then ins I(n)(y0; x l(n)_t) would yield the same result as

(y0 k x l(n)_t). So, practicing the strong one-way permutation with ZMI

scheme, would yield the same result as either practicing the one-way
hash function proposed in corollary 5 with Damgard's design principle,
when the message blocks are fed in a similar order.


6.5   A Single construction for PBG and UOWHF

Each iteration of the pseudorandom bit generator presented in theorem 5
is identical to the hash function presented in corollary 5. Assume that
we have a computational resource for at most k=63 bits. For the
construction of the PBG of theorem 5, an algorithm should extract at
most n - k - 1 bits, and throw away at least k + 1 bits on each iteration.
On the other hand, for the construction of the one-way hash function
according to corollary 5, we may chop at most n - k - 1 bits, and leave
k + 1 bits as the hash value. If n = 512 and we choose 64   t   448, then
the algorithm can be used both for pseudorandom bit generation and
universal one-way hashing.


7   Conclusion and Extension


   1. We constructed a strong permutation with a k + 1-bit perfect
      permutation, namely a complete permutation whose k + 1 output
      bits are independent. A k + 1-bit perfect permutation can be
      constructed easily as follows:


                       v(x) = c(x)   P BG k+1 (xl; : :;:x1)


      where x 2  n , and c(x) is a complete permutation, and
      P BG  k+1(xl; : :;:x1) denotes k + 1 output bits of a pseudorandom
      bit generator where the seed is l bits of the x. Then, we constructed
      a UOWHF and also an efficient pseudorandom bit generator with



                                    13


      the strong permutation. This confirms_Naor and Yung's conjecture
      [8] that if pseudorandom bit generators exist then UOWHF exist.

   2. For the construction of the strong permutation we assumed that
      the position of k + 1 hard bits of the one-way function f complies
      with k + 1 independent bits of v. The following generalisation can
      easily be shown to be true.


      Lemma 5   If v  is a perfect permutation then m = f O v O f
      is a strong one-way permutation, where f  is a one way
      permutation.


      In other words, there is no need to know the exact positions of
      hard bits of f. The running time of a perfect permutation based on
      an extended DES structure for large enough n, e.g., n=512, is
      rather big. A reasonable question is whether we can apply some
      simpler mathematical functions or a compositions of such functions
      for v, for example y = (aix)3 mod  m, and/or y = (ax + b) mod  m.


References


 [1] W. Alexi, B. Chor, O. Goldreich, and C. P. Schnorr. RSA and
     Rabin functions: Certain parts are as hard as the whole. SIAM
     Journal on Computing, 17(2):194-209, 1988.

 [2] M. Blum and S. Micali. How to generate cryptographically strong
     sequences of pseudo-random bits. SIAM Journal on Computing,
     13(4):850-864, 1984.

 [3] J. L. Carter and M. N. Wegman. Universal classes of hash functions.
     Journal of Computer and System Sciences, 18:143-154, 1979.

 [4] I. B. Damgard. A design principle for hash functions. In Advances
     in Cryptology - CRYPTO '89, volume 435 of Lecture Notes in
     Computer Science, pages 416-427. Springer-Verlag, 1989.

 [5] O. Goldreich, S. Goldwasser, and S. Micali. How to construct
     random functions. Journal of the ACM, 33(4):792-807, 1986.

 [6] J. B. Kam and G. I. Davida. Structured design of
     substitution-permutation encryption networks. IEEE Transactions
     on Computers, 28(10):747-753, 1979.

 [7] R. C. Merkle. One way hash functions and DES. In Advances in
     Cryptology - CRYPTO '89, volume 435 of Lecture Notes in
     Computer Science, pages 428-446. Springer-Verlag, 1989.



                                    14


 [8] Moni Naor and Moti Yung. Universal one-way hash functions and
     their cryptographic applications. In the 21st ACM Symposium on
     Theory of Computing, pages 33-43, 1989.

 [9] J. Rompel. One-way functions are necessary and sufficient for secure
     signatures. In the 22nd ACM Symposium on Theory of
     Computing, pages 387-394, 1990.

[10] A. F. Webster and S. E. Tavares. On the design of S-boxes. In
     Advances in Cryptology - CRYPTO '85, Lecture Notes in
     Computer Science, pages 523-534. Springer-Verlag, 1985.

[11] M. N. Wegman and J. L. Carter. New hash functions and their use
     in authentication and set equality. Journal of Computer and
     System Sciences, 22:265-279, 1981.

[12] A. C. Yao. Theory and applications of trapdoor functions. In the
     23rd IEEE Symposium on the Foundations of Computer
     Science, pages 80-91, 1982.

[13] Y. Zheng, T. Matsumoto, and H. Imai. Duality between Two
     Cryptographic Primitives. In the 8-th International
     Conference on Applied Algebra, Algebraic Algorithms and
     Error Correcting Codes, page 15, 1990.

                                    15

