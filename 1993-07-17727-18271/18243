Path: msuinfo!agate!howland.reston.ans.net!noc.near.net!uunet!munnari.oz.au!foxhound.dsto.gov.au!fang.dsto.gov.au!yoyo.aarnet.edu.au!news.adelaide.edu.au!wattle.itd.adelaide.edu.au!ross
From: ross@wattle.itd.adelaide.edu.au (Ross Williams)
Newsgroups: sci.crypt,comp.compression
Subject: How to own a protocol without patenting it.
Followup-To: sci.crypt
Date: 30 Jul 1993 04:22:30 GMT
Organization: Rocksoft Pty Ltd
Lines: 158
Distribution: world
Message-ID: <23a7m6$3s2@huon.itd.adelaide.edu.au>
NNTP-Posting-Host: wattle.itd.adelaide.edu.au
Summary: How to own a protocol without patenting it.
Keywords: protocol software patents data compression data format
Xref: msuinfo sci.crypt:18243 comp.compression:8420


HOW TO OWN A PROTOCOL WITHOUT PATENTING IT
==========================================
Author : Ross N. Williams.
Net    : ross@guest.adelaide.edu.au.
Fax    : +61 8 373-4911 (c/- Internode Systems).
Snail  : Rocksoft Pty Ltd, 16 Lerwick Avenue, Hazelwood Park 5066, Australia.
Date   : 30 July 1993.
Status : Copyright (C) Ross Williams 1993. However, permission is granted to
         make and distribute verbatim copies of this document provided
         that this copyright notice is included.

Note: I had this idea at 2:42am on 30-Jul-1993 Adelaide time. This
might be an old idea (I don't follow sci.crypt very closely), but as
far as I know, it's original.


Abstract
--------
The temptation currently exists for companies to secure "ownership" of
a protocol by making the protocol dependent upon an algorithm that has
been created and patented specifically for this purpose. This document
proposes a simple method, using public domain cryptographic message
digests and copyright law, that enables a published protocol (or data
format) to be owned without having to patent any part of it.


Ownership of Protocols
----------------------
In order to "own" a protocol or data format, you have to be able to
legally prevent others ("opponents") from creating and disseminating
pieces of software that speak that protocol. This is difficult because
no matter what the protocol is, someone can always reverse engineer it
and create their own piece of software that speaks the protocol. As
far as I am aware, the only currently known way to own a protocol is
to patent some mechanism required to speak the protocol so that you
can hit anyone who is vending software that speaks the protocol with a
patent lawsuit. If the patent and the protocol are tight enough, then
to a technical mind at least, the very fact that other piece of
software speaks the protocol successfully is evidence of patent
infringement.


Cryptographic Hash Functions (Message Digests)
----------------------------------------------
The technique about to be described relies on cryptographic hash
functions, also called message digests, so they are briefly reviewed
here.

A message digest algorithm takes a "message" string of bytes and
generates a digest of the string. Digests are usually 16 bytes long.
Like a checksum, the digest then acts as a summary or representative
of the message. The special thing about digests is that, assuming the
digest has not been broken, 1) it is computationally infeasible to
generate two messages having the same digest, 2) given a digest, it is
computationally infeasible to generate a message having that digest.

Digests are amazing things because they act as a cryptographic proof
of the existence of information. This property, combined with
copyright law provides a way to own protocols without software
patents.

The Idea
--------
The idea is to create a block of data that you place under copyright
protection and then engineer the protocol using digests so that it is
impossible to speak the protocol without access to a copy of the block
of data. Here's how it's done:

1. Create a block of data X. It can be anything: random numbers, an
English document, anything, so long as it is largeish, and you own the
copyright for it.

2. Design the protocol so that instead of sending checksums of the
data (as might be included in a communications protocol or a data
format), each transmitter/writer sends digests of the data. However,
instead of sending digests of the raw data M, send digests of MX.

3. As a result, it is virtually impossible for a piece of software to
speak the protocol without access to X. But X is copyrighted, so if
anyone is vending software that speaks the protocol, they must have a
copy of X somewhere in their software, and so they are violating your
copyright and you can take them to court.

Additional Notes
----------------
1. In the above, it is very important that the digest be of MX, not
XM. If the digest is of XM, then the opponent could simply run the
digest algorithm over X and embed the intermediate state of the digest
algorithm in the software. This would probably not infringe copyright.

2. To carry weight in the copyright courts, X should be quite large.
For example, it should be at least half the size of the computer
program in which it is embedded. Accusing an opponent of copying 30
bytes of one's megabyte program looks pathetic. However, copying half
of it looks very bad indeed. X could even be the computer program
itself (but this would prevent it from ever being modified even by its
creator).

3. If X is large, computing MX for each M will be very inefficient for
small M. To overcome this problem, calculate YXM instead, where Y is a
128-bit randomly chosen salt mutually agreed upon by the communicating
parties when the conversation starts (e.g. each could choose 64 bits
of it or in a data format, the writer could choose, or Y could be the
first 16 bytes of the data). This way, at run time, each party can
apply the digest algorithm to YX, save the intermediate state, and
then run the algorithm from that state repeatedly over each M at full
speed.

4. To avoid a copyright suit, the opponent might compress, encrypt, or
in some other way hide X in his program so that it is not directly
visible as a substring. However, from a cryptographic informational
point of view, if the software speaks the protocol, it is almost a
certainty (i.e. subject to the digest algorithm being unbroken etc)
that it has reconstructed X somehow and processed all of the bytes of
X sequentially. I'm not sure how this would go down legally, but from
a technical point of view, the proof seems solid. If the law accepts
this, then all that one would need to prove copyright infringement
would be 1) that the protocol uses this scheme, and 2) that the
opponent's software successfully speaks the protocol.

5. There are a number of high quality public domain or nearly public
domain digest algorithms that could be used. For example NIST's SHS
(Secure Hashing Standard).

6. A similar idea that doesn't require digests is simply to require,
in the protocol, that each parties transmit X to each other before
communicating. However, in order to activate copyright law, X has to
be reasonably large and so this would be too inefficient. However,
digests are small and so can be transmitted efficiently.

7. Another similar idea is for the protocol to require the use of a
large table, which is then copyrighted. This mechanism is probably
enforceable under copyright law, but might be easier to circumvent
using alternative mechanisms and representations. To my mind it does
not provide the cut and dried proof of use of data that delivery of a
digest does.

8. I am not sure what the law's view on all this is. It's just an
idea. Do not treat this document as legal advice or legal opinion of
any kind. If pain persists, see your attorney.


Final Note
----------
I wasn't sure whether it was a good idea to make this idea public.
However, I am doing so because:

   1) it might prevent some software patents from being created
   unneccessarily.

   2) some company might think of this and somehow patent THIS idea,
   which would allow only that company to use this technique.

   3) you can't stop "progress" :-) and it seems best to get this idea
   out into the open where it can be discussed.

--<End of Document>--
