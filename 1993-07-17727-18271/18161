Path: msuinfo!agate!howland.reston.ans.net!gatech!purdue!not-for-mail
From: spaf@cs.purdue.edu (Gene Spafford)
Newsgroups: sci.crypt
Subject: Re: Unix Security (please read)
Date: 26 Jul 1993 01:08:04 -0500
Organization: Department of Computer Sciences, Purdue University
Lines: 84
Message-ID: <22vsc4INN233@uther.cs.purdue.edu>
References: <strnlghtCALttq.KsE@netcom.com>
	<CAMvDq.Cpo@informatik.uni-hamburg.de>
NNTP-Posting-Host: uther.cs.purdue.edu
In-reply-to: bontchev@news.informatik.uni-hamburg.de's message of Fri, 23 Jul 1993 19:56:13 GMT

To follow up on Vesselin's numbers...

There are actually 120 characters that can be used in a Unix password.
You cannot use the erase or kill, control S or Q, carriage return or
newline.  You shouldn't use the bell.  You can't use the null.  All
other characters are fair game (although the break may or may not be
usable). 

So, if we look at all possible passwords up to and including length 8,
we get:

120+14400+1728000+207360000+24883200000+2985984000000+358318080000000+
42998169600000000
	= 43359498756302520
           (4.34 E 16)

To build a dictionary of these in advance would require 4096 times
this many strings, because of the salt.  Thus, we would have
177600506905815121920 strings to store (1.78 E 20).

Let's assume you have a set of machines that will do 1 billion
password encryptions per second.  That is clearly better than the best
we have today.  To build your dictionary would require 5628 years
177600506905815121920 / (1000000000*60*60*24*365.24)

How about storing all those passwords? Each pasword represents 64
bits. (The password algorithm uses the user password to encrypt a
64-bit block of zero bits.  The result is what is stored in the
/etc/passwd file.)  To store each word, then, requires 8 bytes, not
the 9 Vesselin assumed (we don't need a trailing line delimiter as all
words are the same length).

Thus, to store all the encrypted passwords, we get
1420804055246520975360 bytes of storage.  That is just over
1323226890756 GB (1.32 E 12).  This, of course, doesn't include any
indexing -- it's pure data.

Assume you had some marvelous disks that required no overhead for
timing marks, sector headers, etc.  Assume each disk will hold 10 GB
(10E10).  Now assume that each of those disks and all the cabling
needed is only one pound in weight.  As I said, these are remarkable
disks!  If you calculate it out, you will find that you have 8.88
MILLION TONS of disk to worry about. (Optical disks don't buy you
anything, either, because they would all have to be on-line or in a
changer to do you much good; you'd still have several million tons of
storage.)


I think it safe to say that no one has precomputed all the possible
passwords for Unix!


Now there is the argument that we don't need to store the passwords --
we simply calculate them as we try to break a password.

Well, that does make a small difference.  Again, assume we have our 1
billion per second password engine.  Assume we are trying to break one
password that has been chosen at random from the space of all
available passwords.  On average, we will need to calculate 1/2 of all
the passwords before we find it.  Thus, it will take us 2814 years.

How about if we have managed to snarf the whole password file with 100
passwords in it?  Well, if we assume that the passwords are again
randomly distributed, the task is now much easier -- it will take us a
little over 28 years, on average, to break 1 of the passwords -- but
that's trying 1 billion per second!  So long as we change our password
every 5 or 10 years, we should be safe. :-)

====================

Okay, so with all those large numbers, why do people still break into
Unix systems by breaking the passwords?  Because people do *NOT* pick
passwords at random that are well-distributed throughout the entire
password space.  Instead, they pick from a small universe of patterns
that may be searchable by ordinary computers in a few weeks of CPU
time (or less).  If people picked passwords that made full use of the
character set, the problem would not be present.  Users tend to pick
from a pattern space that may only comprise less than 10 E 9 patterns
--- less than one-thousandth of 1 percent of the available passwords.
-- 
Gene Spafford, COAST Project Director
Software Engineering Research Center & Dept. of Computer Sciences
Purdue University, W. Lafayette IN 47907-1398
Internet:  spaf@cs.purdue.edu	phone:  (317) 494-7825
