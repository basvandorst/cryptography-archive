Path: msuinfo!uwm.edu!wupost!uunet!math.fu-berlin.de!unidus.rz.uni-duesseldorf.de!lannert.rz.uni-duesseldorf.de!TSOS
From: TSOS@uni-duesseldorf.de (Detlef Lannert)
Newsgroups: sci.crypt
Subject: Re: secure one-way-hashfunctions
Date: Wed, 21 Jul 1993 08:41:48 GMT
Organization: Universitaetsrechenzentrum, Heinrich-Heine-Universitaet, Duesseldorf
Lines: 60
Message-ID: <TSOS.533.743244108@uni-duesseldorf.de>
References: <RNIFBQDD@gwdu03.gwdg.de> <TSOS.529.743159779@uni-duesseldorf.de> <22hro2INN7nb@elang06.acslab.umbc.edu>
NNTP-Posting-Host: lannert.rz.uni-duesseldorf.de

In article <22hro2INN7nb@elang06.acslab.umbc.edu> olson@umbc.edu (Bryan G. Olson; CMSC (G)) writes:

>In article <TSOS.529.743159779@uni-duesseldorf.de>, TSOS@uni-duesseldorf.de (Detlef Lannert) writes:
>|> 
>|> Cryptosystems like RSA or ElGamal can be used as one-way hash functions 
>|> if the secret key is unknown to any attackers (or if it is completely 
>|> "lost"): If you encrypt, for instance, the first text block, XOR the result 
>|> with the second block and encrypt again etc. etc., it will be infeasible to 
>|> reconstruct any such intermediate results from the final checksum. Thus an 
>|> attacker cannot make modifications to the text that leave the checksum 
>|> intact; he or she would have to solve the factoring/discrete log problem 
>|> first. 
>|> 
>
>Suppose you give me a two block message  B1,B2  and your one block
>RSA() function. 
>
>I choose an arbitrary C1, and choose C2 so that:
>                        C2= RSA(C1) xor RSA(B1) xor B2. 
>
>now       RSA(C1) xor C2  =  RSA(C1) xor RSA(C1) xor RSA(B1) xor B2
>                          =                          RSA(B1) xor B2
>
>so  RSA( RSA(C1) xor C2 ) = RSA( RSA(B1) xor B2 )
>thus    my message's hash = your message's hash. 
>
>
>It's easy to miss things like this, but I think the origion question
>was asking for a hash which could be proven to be secure given some
>assumption.  Always be suspicious until you have the proof.

Sorry for being too con- and not precise. I wouldn't fill the blocks, 
which are fed into the hash algorithm, with message data up to the last 
bit, of course. If we use an RSA modulus of n bits length and use (n-d) 
message bits for each step, there is a 1-in-2^d probability that my 
(authentic) intermediate checksum RSA(B1) agrees in those d bits with your 
(fake) intermediate checksum RSA(C1). You can select an arbitrary C2 
(which wouldn't make any sense anyway) but can never get these d bits 
right. Thus RSA(RSA(C1) xor C2) could not match RSA(RSA(B1) xor B2). 
Since the RSA modulus has to be pretty large and the overall "cost" of 
this method is awfully high already, d can be chosen to match the actual 
security needs. 

I also didn't mention that it would be impractical to use the result of 
the final RSA operation as a checksum because it is unnecessarily long; 
it should suffice to use a substring (of d bits, for instance!).

[Note: A variation of this scheme could replace the xor operation by a 
concatenation of the d-bit message digest of all previous blocks and the 
next (n-d) bit message portion. The xor, however, promotes a message 
modification through to the final checksum, even if the intermediate 
d-bit digest _happens_ to be the same. Thus it adds not much to the 
security at not much extra cost; the return on investment might be ok. ;-)]

--
Detlef Lannert      DC3EK      E-Mail: tsos@rz.uni-duesseldorf.de
PGP 2.x key available (finger lannert@clio.rz.uni-duesseldorf.de)
Die Mathematiker sind eine Art Franzosen:  Redet man zu ihnen, so
uebersetzen sie es in ihre Sprache, und dann ist es alsobald ganz
etwas anderes.                         Johann Wolfgang von Goethe
