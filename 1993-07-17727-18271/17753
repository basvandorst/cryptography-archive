Newsgroups: sci.crypt
Path: msuinfo!agate!spool.mu.edu!uunet!math.fu-berlin.de!jiri
From: jiri@spider.chemie.fu-berlin.de (Jiri Pittner)
Subject: Re: File wiper? SOURCE INCLUDED HERE
Message-ID: <7GZEBSMG@math.fu-berlin.de>
Sender: news@math.fu-berlin.de (Math Department)
Organization: Free University of Berlin, Germany
References: <C9HzMn.Lr5@hpcvsnz.cv.hp.com>
Date: Fri, 2 Jul 1993 09:41:19 GMT
Lines: 113

ericb@lsid.hp.com (Eric Backus) writes:

>I am looking for a program that will "wipe" a file, so that the file
>can never be recovered.  I know, the only way to be sure is to destroy
>the media, but I'm looking for something less extreme.  I want a
>program which:

>	* Overwrites every character in the file, possibly several
>	  times, with either with constant data or with random data.
>	* Overwrites the filename (by moving the file so some other
>	  name).
>	* Removes the file.
>	* And in general makes it as difficult as possible to recover
>	  the file.

>I could write this program myself, it would be quite simple.  But this
>seems like an obvious idea, which probably has been done many times
>before.  I'm looking for source code, so that I can use this on both
>my UNIX workstation and my PC at home.

>Can anyone help me?
>--
>				Eric Backus
>				ericb@lsid.hp.com
>				(206) 335-2495




Here is the program I'm using on HP755 and Convex computers. To modify it
on PC should not be difficult, but I don't know the systems calls there at all.

You can modify it to overwrite the buffer several times and to overwrite the name
in the directory, which is not done here.

CAUTION: The program is based on the crucial assumption, that when you
write to any file which already exists data of the same size as the file has,
the filesystem does NOT allocate new blocks for the new content of the file,
but writes  just over the old contents. 
I am not a system programmer, but I think it is most logical if the system behaves
in this way.
Can anybody confirm me this assumption?

Jiri Pittner

=======================

#include <stdio.h>
#include <string.h>
#include <unistd.h>



#include <sys/types.h>
#include <sys/stat.h>
#include <sys/file.h>
#if __stdc__
#include <stdlib.h>
#include <errno.h>
#else
extern char *malloc();
extern int free();
extern int errno;
#endif


main(argc,argv)
int argc; char **argv;
{
int fd,len,ok;
struct stat buf;
char *mbuf /*,com[256]*/;

if(argc !=2) {fprintf(stderr,"Usage: %s file_to_be_destroyed\n",argv[0]); exit(10);}

ok=1;
if((fd=open(argv[1],2,0700))<=0) {fprintf(stderr,"%s: can't open %s\n",argv[0],argv[1]); exit(10);}

fstat(fd,&buf);
len= (int) buf.st_size;

if((mbuf = (char*) malloc((unsigned)len)) != NULL) 
	{
	register char z;
	register int i;
	z=0x55;
	for(i=0; i<len; i++) mbuf[i]= (z ^= 0xff);
	if (len != write(fd,mbuf,len)) 
		{fprintf(stderr,"%s: error during writing to file %s\n",argv[0],argv[1]); ok=0;}
	(void)free(mbuf);
	}
else
	{
	register int i,f;
	char z= 0x55;
	f=0;
	for(i=1; i<=len;i++) if(f=(1-write(fd,&z,1))) break; else z ^= 0xff;
	if (f) {fprintf(stderr,"%s: error during writing to file %s\n",argv[0],argv[1]); ok=0;}
	}

if(fsync(fd)) {ok=0; perror("wipe: cannot sync");} else fprintf(stderr,"%s: file %s cleaned!\n",argv[0],argv[1]);
close(fd);
errno=0;
if(ok) remove(argv[1]); else fprintf(stderr,"%s: WARNING - %s not removed\n",argv[0],argv[1]);
if(errno) perror(argv[0]);


if(ok) exit(0); else exit(20);
}
--
-------------------------------------------------------------------------------
Jiri Pittner
jiri@hpsiepsi.chemie.fu-berlin.de
