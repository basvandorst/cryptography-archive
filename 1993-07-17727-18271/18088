Newsgroups: sci.crypt
Path: msuinfo!uwm.edu!wupost!mont!mizzou1.missouri.edu!C445585
From: C445585@mizzou1.missouri.edu (John Kelsey)
Subject: Re: Generating random bits: practical questions
Message-ID: <16C11F57F.C445585@mizzou1.missouri.edu>
Sender: news@mont.cs.missouri.edu
Nntp-Posting-Host: mizzou1.missouri.edu
Organization: University of Missouri
References: <1993Jul19.164311.28040@sun1x.res.utc.com> <22g2nnINNoo7@iskut.ucs.ubc.ca>
Date: Tue, 20 Jul 93 17:27:20 CDT
Lines: 42

   Hmmm.   I believe the original question was about generating some high-
quality random bits *without* running afoul of any of the export restrictions.
My suggestion would be to use some combination of ralatively low-quality
data with some randomness in it, maybe a  reasonably good PRNG, and a really
good one-way hash function, such as MD5 or the SHA.  Source code to both of
these is available by anonymous  FTP from various places.  (MD5 is available
from rsa.com, I believe.)  I don't think there are any export restrictions
on hash functions, though I *really* don't want to start another contentless
flamewar about it in sci.crypt.
 
   A couple ways of doing this that I can see:
 
   Use your microphone, or whatever, to capture as much low-quality random
data  as you can.  (Higher quality is better, naturally.)  Maintain this in
a buffer somewhere.  If possible, you might want to try to figure out roughly
how much entropy per bit this low-quality random data contains.
 
   From there, you can decide how many bytes of low-quality random data to
hash together at a time, to "distill" the randomness out.  The more of your
microphone-sampled bits you hash together into a shorter hash value, the
closer to random the value ought to be.  If you don't care much about time,
you may want to simply collect all day for one hash value, or at least as
long as you can keep collecting before you run out of buffer space.
 
   If you're concerned about your sampled data having a *really low* amount
of randomness, then you might want to have the user pre-fill the buffer each
morning, by typing for a few minutes.  Use a  PGP-like scheme to catch some
random-looking bits from that.  Maybe you can use the system startup time,
if the PC you're running this on has an independent clock.
 
   Additionally, you could make an attempt to detect any pattern in the
distilled bits more difficult, by applying your hash function to different
parts of the buffer multiple times, XORing or appending the hash values to
the buffer, then doing some simple transformation of the buffer (like XORing
against a simple PRNG), then hashing it again to make an attack on any
patterns in your distilled bits more computationally demanding.  Or, you
could  combine multiple  hash functions (say, MD5, N-HASH, and the SHA).
Use the output from one as part of the input to the next, etc.
 
   Good luck....
 
   --John Kelsey, c445585@mizzou1.missouri.edu
