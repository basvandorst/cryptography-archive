/******************************************************************* * * This file was generated by TIS/ASN1COMP Ver. 4.0, an ASN.1 compiler. * TIS/ASN1COMP is Copyright (c) 1998, TIS Labs at Network Associates, Inc. * * This file was AUTOMATICALLY GENERATED on Fri Jan 15 15:22:21 1999 * ******************************************************************/#include <string.h>#include "pkcsreq_asn.h"/******************************************************************* * * Code for manipulating ASN.1 DER data and structure. * *  NewXXX: Allocate the top level of a structure. * *  FreeXXX: Release all the data of an ASN structure. * *  SizeofXXX: Return the size of the DER block that would *               be created from the structure. * *  PackXXX: Take an ASN structure and return the DER. * *  unPackXXX: Take the DER and return an ASN structure. * ******************************************************************//****************************************************************** * Routines for CertRep ******************************************************************/PKICertRep *PKINewCertRep(    PKICONTEXT *ctx){    PKICertRep *f;    if (ctx == NULL)        return NULL;    f = (PKICertRep *)PKIAlloc(ctx->memMgr, sizeof(PKICertRep));    if (f != NULL)        (void)memset(f, 0, sizeof(PKICertRep));    return (f);} /* PKINewCertRep */void PKIFreeCertRep(    PKICONTEXT *ctx,    PKICertRep *f){    if (ctx == NULL)        return;    PKIDropInPlaceCertRep(ctx, f);    if (f != NULL)        PKIFree(ctx->memMgr, f);} /* PKIFreeCertRep */size_t PKISizeofCertRep(    PKICONTEXT *ctx,    PKICertRep *asnstruct,    int outerSizeFlag){    (void)ctx; /* for future use */    return(PKISizeofCertRepInternal(asnstruct, outerSizeFlag, PKIFALSE));} /* PKISizeofCertRep */size_t PKIPackCertRep(    PKICONTEXT *ctx,    unsigned char *buf,    size_t buflen,    PKICertRep *asnstruct,    int *erret ){    return(PKIPackCertRepInternal(ctx, buf, buflen, asnstruct, PKIID_CertRep, erret));} /* PKIPackCertRep */size_t PKIUnpackCertRep(    PKICONTEXT *ctx,    PKICertRep **asnstruct,    const unsigned char *buf,    size_t buflen,    int *erret){    return(PKIUnpackCertRepInternal(ctx, asnstruct, buf, buflen,                      PKIID_CertRep, erret));}/****************************************************************** * Routines for GetCRL ******************************************************************/PKIGetCRL *PKINewGetCRL(    PKICONTEXT *ctx){    PKIGetCRL *f;    if (ctx == NULL)        return NULL;    f = (PKIGetCRL *)PKIAlloc(ctx->memMgr, sizeof(PKIGetCRL));    if (f != NULL)        (void)memset(f, 0, sizeof(PKIGetCRL));    return (f);} /* PKINewGetCRL */void PKIFreeGetCRL(    PKICONTEXT *ctx,    PKIGetCRL *f){    if (ctx == NULL)        return;    PKIDropInPlaceGetCRL(ctx, f);    if (f != NULL)        PKIFree(ctx->memMgr, f);} /* PKIFreeGetCRL */size_t PKISizeofGetCRL(    PKICONTEXT *ctx,    PKIGetCRL *asnstruct,    int outerSizeFlag){    (void)ctx; /* for future use */    return(PKISizeofGetCRLInternal(asnstruct, outerSizeFlag, PKIFALSE));} /* PKISizeofGetCRL */size_t PKIPackGetCRL(    PKICONTEXT *ctx,    unsigned char *buf,    size_t buflen,    PKIGetCRL *asnstruct,    int *erret ){    return(PKIPackGetCRLInternal(ctx, buf, buflen, asnstruct, PKIID_GetCRL, erret));} /* PKIPackGetCRL */size_t PKIUnpackGetCRL(    PKICONTEXT *ctx,    PKIGetCRL **asnstruct,    const unsigned char *buf,    size_t buflen,    int *erret){    return(PKIUnpackGetCRLInternal(ctx, asnstruct, buf, buflen,                      PKIID_GetCRL, erret));}/****************************************************************** * Routines for GetCert ******************************************************************/PKIGetCert *PKINewGetCert(    PKICONTEXT *ctx){    PKIGetCert *f;    if (ctx == NULL)        return NULL;    f = (PKIGetCert *)PKIAlloc(ctx->memMgr, sizeof(PKIGetCert));    if (f != NULL)        (void)memset(f, 0, sizeof(PKIGetCert));    return (f);} /* PKINewGetCert */void PKIFreeGetCert(    PKICONTEXT *ctx,    PKIGetCert *f){    if (ctx == NULL)        return;    PKIDropInPlaceGetCert(ctx, f);    if (f != NULL)        PKIFree(ctx->memMgr, f);} /* PKIFreeGetCert */size_t PKISizeofGetCert(    PKICONTEXT *ctx,    PKIGetCert *asnstruct,    int outerSizeFlag){    (void)ctx; /* for future use */    return(PKISizeofGetCertInternal(asnstruct, outerSizeFlag, PKIFALSE));} /* PKISizeofGetCert */size_t PKIPackGetCert(    PKICONTEXT *ctx,    unsigned char *buf,    size_t buflen,    PKIGetCert *asnstruct,    int *erret ){    return(PKIPackGetCertInternal(ctx, buf, buflen, asnstruct, PKIID_GetCert, erret));} /* PKIPackGetCert */size_t PKIUnpackGetCert(    PKICONTEXT *ctx,    PKIGetCert **asnstruct,    const unsigned char *buf,    size_t buflen,    int *erret){    return(PKIUnpackGetCertInternal(ctx, asnstruct, buf, buflen,                      PKIID_GetCert, erret));}/****************************************************************** * Routines for IssuerAndSubject ******************************************************************/PKIIssuerAndSubject *PKINewIssuerAndSubject(    PKICONTEXT *ctx){    PKIIssuerAndSubject *f;    if (ctx == NULL)        return NULL;    f = (PKIIssuerAndSubject *)PKIAlloc(ctx->memMgr, sizeof(PKIIssuerAndSubject));    if (f != NULL)        (void)memset(f, 0, sizeof(PKIIssuerAndSubject));    return (f);} /* PKINewIssuerAndSubject */void PKIFreeIssuerAndSubject(    PKICONTEXT *ctx,    PKIIssuerAndSubject *f){    if (ctx == NULL)        return;    PKIDropInPlaceIssuerAndSubject(ctx, f);    if (f != NULL)        PKIFree(ctx->memMgr, f);} /* PKIFreeIssuerAndSubject */size_t PKISizeofIssuerAndSubject(    PKICONTEXT *ctx,    PKIIssuerAndSubject *asnstruct,    int outerSizeFlag){    (void)ctx; /* for future use */    return(PKISizeofIssuerAndSubjectInternal(asnstruct, outerSizeFlag, PKIFALSE));} /* PKISizeofIssuerAndSubject */size_t PKIPackIssuerAndSubject(    PKICONTEXT *ctx,    unsigned char *buf,    size_t buflen,    PKIIssuerAndSubject *asnstruct,    int *erret ){    return(PKIPackIssuerAndSubjectInternal(ctx, buf, buflen, asnstruct, PKIID_IssuerAndSubject, erret));} /* PKIPackIssuerAndSubject */size_t PKIUnpackIssuerAndSubject(    PKICONTEXT *ctx,    PKIIssuerAndSubject **asnstruct,    const unsigned char *buf,    size_t buflen,    int *erret){    return(PKIUnpackIssuerAndSubjectInternal(ctx, asnstruct, buf, buflen,                      PKIID_IssuerAndSubject, erret));}/****************************************************************** * Routines for PKCSReq ******************************************************************/PKIPKCSReq *PKINewPKCSReq(    PKICONTEXT *ctx){    PKIPKCSReq *f;    if (ctx == NULL)        return NULL;    f = (PKIPKCSReq *)PKIAlloc(ctx->memMgr, sizeof(PKIPKCSReq));    if (f != NULL)        (void)memset(f, 0, sizeof(PKIPKCSReq));    return (f);} /* PKINewPKCSReq */void PKIFreePKCSReq(    PKICONTEXT *ctx,    PKIPKCSReq *f){    if (ctx == NULL)        return;    PKIDropInPlacePKCSReq(ctx, f);    if (f != NULL)        PKIFree(ctx->memMgr, f);} /* PKIFreePKCSReq */size_t PKISizeofPKCSReq(    PKICONTEXT *ctx,    PKIPKCSReq *asnstruct,    int outerSizeFlag){    (void)ctx; /* for future use */    return(PKISizeofPKCSReqInternal(asnstruct, outerSizeFlag, PKIFALSE));} /* PKISizeofPKCSReq */size_t PKIPackPKCSReq(    PKICONTEXT *ctx,    unsigned char *buf,    size_t buflen,    PKIPKCSReq *asnstruct,    int *erret ){    return(PKIPackPKCSReqInternal(ctx, buf, buflen, asnstruct, PKIID_PKCSReq, erret));} /* PKIPackPKCSReq */size_t PKIUnpackPKCSReq(    PKICONTEXT *ctx,    PKIPKCSReq **asnstruct,    const unsigned char *buf,    size_t buflen,    int *erret){    return(PKIUnpackPKCSReqInternal(ctx, asnstruct, buf, buflen,                      PKIID_PKCSReq, erret));}/****************************************************************** * Routines for GetCertInitial ******************************************************************/PKIGetCertInitial *PKINewGetCertInitial(    PKICONTEXT *ctx){    PKIGetCertInitial *f;    if (ctx == NULL)        return NULL;    f = (PKIGetCertInitial *)PKIAlloc(ctx->memMgr, sizeof(PKIGetCertInitial));    if (f != NULL)        (void)memset(f, 0, sizeof(PKIGetCertInitial));    return (f);} /* PKINewGetCertInitial */void PKIFreeGetCertInitial(    PKICONTEXT *ctx,    PKIGetCertInitial *f){    if (ctx == NULL)        return;    PKIDropInPlaceGetCertInitial(ctx, f);    if (f != NULL)        PKIFree(ctx->memMgr, f);} /* PKIFreeGetCertInitial */size_t PKISizeofGetCertInitial(    PKICONTEXT *ctx,    PKIGetCertInitial *asnstruct,    int outerSizeFlag){    (void)ctx; /* for future use */    return(PKISizeofGetCertInitialInternal(asnstruct, outerSizeFlag, PKIFALSE));} /* PKISizeofGetCertInitial */size_t PKIPackGetCertInitial(    PKICONTEXT *ctx,    unsigned char *buf,    size_t buflen,    PKIGetCertInitial *asnstruct,    int *erret ){    return(PKIPackGetCertInitialInternal(ctx, buf, buflen, asnstruct, PKIID_GetCertInitial, erret));} /* PKIPackGetCertInitial */size_t PKIUnpackGetCertInitial(    PKICONTEXT *ctx,    PKIGetCertInitial **asnstruct,    const unsigned char *buf,    size_t buflen,    int *erret){    return(PKIUnpackGetCertInitialInternal(ctx, asnstruct, buf, buflen,                      PKIID_GetCertInitial, erret));}