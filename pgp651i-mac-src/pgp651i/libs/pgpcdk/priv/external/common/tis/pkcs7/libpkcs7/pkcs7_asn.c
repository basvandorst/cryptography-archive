/******************************************************************* * * This file was generated by TIS/ASN1COMP Ver. 4.0, an ASN.1 compiler. * TIS/ASN1COMP is Copyright (c) 1998, TIS Labs at Network Associates, Inc. * * This file was AUTOMATICALLY GENERATED on Wed Nov 18 16:32:31 1998 * ******************************************************************/#include <string.h>#include "pkcs7_asn.h"/******************************************************************* * * Code for manipulating ASN.1 DER data and structure. * *  NewXXX: Allocate the top level of a structure. * *  FreeXXX: Release all the data of an ASN structure. * *  SizeofXXX: Return the size of the DER block that would *               be created from the structure. * *  PackXXX: Take an ASN structure and return the DER. * *  unPackXXX: Take the DER and return an ASN structure. * ******************************************************************//****************************************************************** * Routines for CertificateRevocationLists ******************************************************************/PKICertificateRevocationLists *PKINewCertificateRevocationLists(    PKICONTEXT *ctx){    PKICertificateRevocationLists *f;    if (ctx == NULL)        return NULL;    f = (PKICertificateRevocationLists *)PKIAlloc(ctx->memMgr, sizeof(PKICertificateRevocationLists));    if (f != NULL)        (void)memset(f, 0, sizeof(PKICertificateRevocationLists));    return (f);} /* PKINewCertificateRevocationLists */void PKIFreeCertificateRevocationLists(    PKICONTEXT *ctx,    PKICertificateRevocationLists *f){    if (ctx == NULL)        return;    PKIDropInPlaceCertificateRevocationLists(ctx, f);    if (f != NULL)        PKIFree(ctx->memMgr, f);} /* PKIFreeCertificateRevocationLists */size_t PKISizeofCertificateRevocationLists(    PKICONTEXT *ctx,    PKICertificateRevocationLists *asnstruct,    int outerSizeFlag){    (void)ctx; /* for future use */    return(PKISizeofCertificateRevocationListsInternal(asnstruct, outerSizeFlag, PKIFALSE));} /* PKISizeofCertificateRevocationLists */size_t PKIPackCertificateRevocationLists(    PKICONTEXT *ctx,    unsigned char *buf,    size_t buflen,    PKICertificateRevocationLists *asnstruct,    int *erret ){    return(PKIPackCertificateRevocationListsInternal(ctx, buf, buflen, asnstruct, PKIID_CertificateRevocationLists, erret));} /* PKIPackCertificateRevocationLists */size_t PKIUnpackCertificateRevocationLists(    PKICONTEXT *ctx,    PKICertificateRevocationLists **asnstruct,    unsigned char *buf,    size_t buflen,    int *erret){    return(PKIUnpackCertificateRevocationListsInternal(ctx, asnstruct, buf, buflen,                      PKIID_CertificateRevocationLists, erret));}/****************************************************************** * Routines for ContentInfo ******************************************************************/PKIContentInfo *PKINewContentInfo(    PKICONTEXT *ctx){    PKIContentInfo *f;    if (ctx == NULL)        return NULL;    f = (PKIContentInfo *)PKIAlloc(ctx->memMgr, sizeof(PKIContentInfo));    if (f != NULL)        (void)memset(f, 0, sizeof(PKIContentInfo));    return (f);} /* PKINewContentInfo */void PKIFreeContentInfo(    PKICONTEXT *ctx,    PKIContentInfo *f){    if (ctx == NULL)        return;    PKIDropInPlaceContentInfo(ctx, f);    if (f != NULL)        PKIFree(ctx->memMgr, f);} /* PKIFreeContentInfo */size_t PKISizeofContentInfo(    PKICONTEXT *ctx,    PKIContentInfo *asnstruct,    int outerSizeFlag){    (void)ctx; /* for future use */    return(PKISizeofContentInfoInternal(asnstruct, outerSizeFlag, PKIFALSE));} /* PKISizeofContentInfo */size_t PKIPackContentInfo(    PKICONTEXT *ctx,    unsigned char *buf,    size_t buflen,    PKIContentInfo *asnstruct,    int *erret ){    return(PKIPackContentInfoInternal(ctx, buf, buflen, asnstruct, PKIID_ContentInfo, erret));} /* PKIPackContentInfo */size_t PKIUnpackContentInfo(    PKICONTEXT *ctx,    PKIContentInfo **asnstruct,    unsigned char *buf,    size_t buflen,    int *erret){    return(PKIUnpackContentInfoInternal(ctx, asnstruct, buf, buflen,                      PKIID_ContentInfo, erret));}/****************************************************************** * Routines for ExtendedCertificateInfo ******************************************************************/PKIExtendedCertificateInfo *PKINewExtendedCertificateInfo(    PKICONTEXT *ctx){    PKIExtendedCertificateInfo *f;    if (ctx == NULL)        return NULL;    f = (PKIExtendedCertificateInfo *)PKIAlloc(ctx->memMgr, sizeof(PKIExtendedCertificateInfo));    if (f != NULL)        (void)memset(f, 0, sizeof(PKIExtendedCertificateInfo));    return (f);} /* PKINewExtendedCertificateInfo */void PKIFreeExtendedCertificateInfo(    PKICONTEXT *ctx,    PKIExtendedCertificateInfo *f){    if (ctx == NULL)        return;    PKIDropInPlaceExtendedCertificateInfo(ctx, f);    if (f != NULL)        PKIFree(ctx->memMgr, f);} /* PKIFreeExtendedCertificateInfo */size_t PKISizeofExtendedCertificateInfo(    PKICONTEXT *ctx,    PKIExtendedCertificateInfo *asnstruct,    int outerSizeFlag){    (void)ctx; /* for future use */    return(PKISizeofExtendedCertificateInfoInternal(asnstruct, outerSizeFlag, PKIFALSE));} /* PKISizeofExtendedCertificateInfo */size_t PKIPackExtendedCertificateInfo(    PKICONTEXT *ctx,    unsigned char *buf,    size_t buflen,    PKIExtendedCertificateInfo *asnstruct,    int *erret ){    return(PKIPackExtendedCertificateInfoInternal(ctx, buf, buflen, asnstruct, PKIID_ExtendedCertificateInfo, erret));} /* PKIPackExtendedCertificateInfo */size_t PKIUnpackExtendedCertificateInfo(    PKICONTEXT *ctx,    PKIExtendedCertificateInfo **asnstruct,    unsigned char *buf,    size_t buflen,    int *erret){    return(PKIUnpackExtendedCertificateInfoInternal(ctx, asnstruct, buf, buflen,                      PKIID_ExtendedCertificateInfo, erret));}/****************************************************************** * Routines for IssuerAndSerialNumber ******************************************************************/PKIIssuerAndSerialNumber *PKINewIssuerAndSerialNumber(    PKICONTEXT *ctx){    PKIIssuerAndSerialNumber *f;    if (ctx == NULL)        return NULL;    f = (PKIIssuerAndSerialNumber *)PKIAlloc(ctx->memMgr, sizeof(PKIIssuerAndSerialNumber));    if (f != NULL)        (void)memset(f, 0, sizeof(PKIIssuerAndSerialNumber));    return (f);} /* PKINewIssuerAndSerialNumber */void PKIFreeIssuerAndSerialNumber(    PKICONTEXT *ctx,    PKIIssuerAndSerialNumber *f){    if (ctx == NULL)        return;    PKIDropInPlaceIssuerAndSerialNumber(ctx, f);    if (f != NULL)        PKIFree(ctx->memMgr, f);} /* PKIFreeIssuerAndSerialNumber */size_t PKISizeofIssuerAndSerialNumber(    PKICONTEXT *ctx,    PKIIssuerAndSerialNumber *asnstruct,    int outerSizeFlag){    (void)ctx; /* for future use */    return(PKISizeofIssuerAndSerialNumberInternal(asnstruct, outerSizeFlag, PKIFALSE));} /* PKISizeofIssuerAndSerialNumber */size_t PKIPackIssuerAndSerialNumber(    PKICONTEXT *ctx,    unsigned char *buf,    size_t buflen,    PKIIssuerAndSerialNumber *asnstruct,    int *erret ){    return(PKIPackIssuerAndSerialNumberInternal(ctx, buf, buflen, asnstruct, PKIID_IssuerAndSerialNumber, erret));} /* PKIPackIssuerAndSerialNumber */size_t PKIUnpackIssuerAndSerialNumber(    PKICONTEXT *ctx,    PKIIssuerAndSerialNumber **asnstruct,    unsigned char *buf,    size_t buflen,    int *erret){    return(PKIUnpackIssuerAndSerialNumberInternal(ctx, asnstruct, buf, buflen,                      PKIID_IssuerAndSerialNumber, erret));}/****************************************************************** * Routines for DigestAlgorithmIdentifiers ******************************************************************/PKIDigestAlgorithmIdentifiers *PKINewDigestAlgorithmIdentifiers(    PKICONTEXT *ctx){    PKIDigestAlgorithmIdentifiers *f;    if (ctx == NULL)        return NULL;    f = (PKIDigestAlgorithmIdentifiers *)PKIAlloc(ctx->memMgr, sizeof(PKIDigestAlgorithmIdentifiers));    if (f != NULL)        (void)memset(f, 0, sizeof(PKIDigestAlgorithmIdentifiers));    return (f);} /* PKINewDigestAlgorithmIdentifiers */void PKIFreeDigestAlgorithmIdentifiers(    PKICONTEXT *ctx,    PKIDigestAlgorithmIdentifiers *f){    if (ctx == NULL)        return;    PKIDropInPlaceDigestAlgorithmIdentifiers(ctx, f);    if (f != NULL)        PKIFree(ctx->memMgr, f);} /* PKIFreeDigestAlgorithmIdentifiers */size_t PKISizeofDigestAlgorithmIdentifiers(    PKICONTEXT *ctx,    PKIDigestAlgorithmIdentifiers *asnstruct,    int outerSizeFlag){    (void)ctx; /* for future use */    return(PKISizeofDigestAlgorithmIdentifiersInternal(asnstruct, outerSizeFlag, PKIFALSE));} /* PKISizeofDigestAlgorithmIdentifiers */size_t PKIPackDigestAlgorithmIdentifiers(    PKICONTEXT *ctx,    unsigned char *buf,    size_t buflen,    PKIDigestAlgorithmIdentifiers *asnstruct,    int *erret ){    return(PKIPackDigestAlgorithmIdentifiersInternal(ctx, buf, buflen, asnstruct, PKIID_DigestAlgorithmIdentifiers, erret));} /* PKIPackDigestAlgorithmIdentifiers */size_t PKIUnpackDigestAlgorithmIdentifiers(    PKICONTEXT *ctx,    PKIDigestAlgorithmIdentifiers **asnstruct,    unsigned char *buf,    size_t buflen,    int *erret){    return(PKIUnpackDigestAlgorithmIdentifiersInternal(ctx, asnstruct, buf, buflen,                      PKIID_DigestAlgorithmIdentifiers, erret));}/****************************************************************** * Routines for DigestInfo ******************************************************************/PKIDigestInfo *PKINewDigestInfo(    PKICONTEXT *ctx){    PKIDigestInfo *f;    if (ctx == NULL)        return NULL;    f = (PKIDigestInfo *)PKIAlloc(ctx->memMgr, sizeof(PKIDigestInfo));    if (f != NULL)        (void)memset(f, 0, sizeof(PKIDigestInfo));    return (f);} /* PKINewDigestInfo */void PKIFreeDigestInfo(    PKICONTEXT *ctx,    PKIDigestInfo *f){    if (ctx == NULL)        return;    PKIDropInPlaceDigestInfo(ctx, f);    if (f != NULL)        PKIFree(ctx->memMgr, f);} /* PKIFreeDigestInfo */size_t PKISizeofDigestInfo(    PKICONTEXT *ctx,    PKIDigestInfo *asnstruct,    int outerSizeFlag){    (void)ctx; /* for future use */    return(PKISizeofDigestInfoInternal(asnstruct, outerSizeFlag, PKIFALSE));} /* PKISizeofDigestInfo */size_t PKIPackDigestInfo(    PKICONTEXT *ctx,    unsigned char *buf,    size_t buflen,    PKIDigestInfo *asnstruct,    int *erret ){    return(PKIPackDigestInfoInternal(ctx, buf, buflen, asnstruct, PKIID_DigestInfo, erret));} /* PKIPackDigestInfo */size_t PKIUnpackDigestInfo(    PKICONTEXT *ctx,    PKIDigestInfo **asnstruct,    unsigned char *buf,    size_t buflen,    int *erret){    return(PKIUnpackDigestInfoInternal(ctx, asnstruct, buf, buflen,                      PKIID_DigestInfo, erret));}/****************************************************************** * Routines for EncryptedContentInfo ******************************************************************/PKIEncryptedContentInfo *PKINewEncryptedContentInfo(    PKICONTEXT *ctx){    PKIEncryptedContentInfo *f;    if (ctx == NULL)        return NULL;    f = (PKIEncryptedContentInfo *)PKIAlloc(ctx->memMgr, sizeof(PKIEncryptedContentInfo));    if (f != NULL)        (void)memset(f, 0, sizeof(PKIEncryptedContentInfo));    return (f);} /* PKINewEncryptedContentInfo */void PKIFreeEncryptedContentInfo(    PKICONTEXT *ctx,    PKIEncryptedContentInfo *f){    if (ctx == NULL)        return;    PKIDropInPlaceEncryptedContentInfo(ctx, f);    if (f != NULL)        PKIFree(ctx->memMgr, f);} /* PKIFreeEncryptedContentInfo */size_t PKISizeofEncryptedContentInfo(    PKICONTEXT *ctx,    PKIEncryptedContentInfo *asnstruct,    int outerSizeFlag){    (void)ctx; /* for future use */    return(PKISizeofEncryptedContentInfoInternal(asnstruct, outerSizeFlag, PKIFALSE));} /* PKISizeofEncryptedContentInfo */size_t PKIPackEncryptedContentInfo(    PKICONTEXT *ctx,    unsigned char *buf,    size_t buflen,    PKIEncryptedContentInfo *asnstruct,    int *erret ){    return(PKIPackEncryptedContentInfoInternal(ctx, buf, buflen, asnstruct, PKIID_EncryptedContentInfo, erret));} /* PKIPackEncryptedContentInfo */size_t PKIUnpackEncryptedContentInfo(    PKICONTEXT *ctx,    PKIEncryptedContentInfo **asnstruct,    unsigned char *buf,    size_t buflen,    int *erret){    return(PKIUnpackEncryptedContentInfoInternal(ctx, asnstruct, buf, buflen,                      PKIID_EncryptedContentInfo, erret));}/****************************************************************** * Routines for ExtendedCertificate ******************************************************************/PKIExtendedCertificate *PKINewExtendedCertificate(    PKICONTEXT *ctx){    PKIExtendedCertificate *f;    if (ctx == NULL)        return NULL;    f = (PKIExtendedCertificate *)PKIAlloc(ctx->memMgr, sizeof(PKIExtendedCertificate));    if (f != NULL)        (void)memset(f, 0, sizeof(PKIExtendedCertificate));    return (f);} /* PKINewExtendedCertificate */void PKIFreeExtendedCertificate(    PKICONTEXT *ctx,    PKIExtendedCertificate *f){    if (ctx == NULL)        return;    PKIDropInPlaceExtendedCertificate(ctx, f);    if (f != NULL)        PKIFree(ctx->memMgr, f);} /* PKIFreeExtendedCertificate */size_t PKISizeofExtendedCertificate(    PKICONTEXT *ctx,    PKIExtendedCertificate *asnstruct,    int outerSizeFlag){    (void)ctx; /* for future use */    return(PKISizeofExtendedCertificateInternal(asnstruct, outerSizeFlag, PKIFALSE));} /* PKISizeofExtendedCertificate */size_t PKIPackExtendedCertificate(    PKICONTEXT *ctx,    unsigned char *buf,    size_t buflen,    PKIExtendedCertificate *asnstruct,    int *erret ){    return(PKIPackExtendedCertificateInternal(ctx, buf, buflen, asnstruct, PKIID_ExtendedCertificate, erret));} /* PKIPackExtendedCertificate */size_t PKIUnpackExtendedCertificate(    PKICONTEXT *ctx,    PKIExtendedCertificate **asnstruct,    unsigned char *buf,    size_t buflen,    int *erret){    return(PKIUnpackExtendedCertificateInternal(ctx, asnstruct, buf, buflen,                      PKIID_ExtendedCertificate, erret));}/****************************************************************** * Routines for RecipientInfo ******************************************************************/PKIRecipientInfo *PKINewRecipientInfo(    PKICONTEXT *ctx){    PKIRecipientInfo *f;    if (ctx == NULL)        return NULL;    f = (PKIRecipientInfo *)PKIAlloc(ctx->memMgr, sizeof(PKIRecipientInfo));    if (f != NULL)        (void)memset(f, 0, sizeof(PKIRecipientInfo));    return (f);} /* PKINewRecipientInfo */void PKIFreeRecipientInfo(    PKICONTEXT *ctx,    PKIRecipientInfo *f){    if (ctx == NULL)        return;    PKIDropInPlaceRecipientInfo(ctx, f);    if (f != NULL)        PKIFree(ctx->memMgr, f);} /* PKIFreeRecipientInfo */size_t PKISizeofRecipientInfo(    PKICONTEXT *ctx,    PKIRecipientInfo *asnstruct,    int outerSizeFlag){    (void)ctx; /* for future use */    return(PKISizeofRecipientInfoInternal(asnstruct, outerSizeFlag, PKIFALSE));} /* PKISizeofRecipientInfo */size_t PKIPackRecipientInfo(    PKICONTEXT *ctx,    unsigned char *buf,    size_t buflen,    PKIRecipientInfo *asnstruct,    int *erret ){    return(PKIPackRecipientInfoInternal(ctx, buf, buflen, asnstruct, PKIID_RecipientInfo, erret));} /* PKIPackRecipientInfo */size_t PKIUnpackRecipientInfo(    PKICONTEXT *ctx,    PKIRecipientInfo **asnstruct,    unsigned char *buf,    size_t buflen,    int *erret){    return(PKIUnpackRecipientInfoInternal(ctx, asnstruct, buf, buflen,                      PKIID_RecipientInfo, erret));}/****************************************************************** * Routines for SignerInfo ******************************************************************/PKISignerInfo *PKINewSignerInfo(    PKICONTEXT *ctx){    PKISignerInfo *f;    if (ctx == NULL)        return NULL;    f = (PKISignerInfo *)PKIAlloc(ctx->memMgr, sizeof(PKISignerInfo));    if (f != NULL)        (void)memset(f, 0, sizeof(PKISignerInfo));    return (f);} /* PKINewSignerInfo */void PKIFreeSignerInfo(    PKICONTEXT *ctx,    PKISignerInfo *f){    if (ctx == NULL)        return;    PKIDropInPlaceSignerInfo(ctx, f);    if (f != NULL)        PKIFree(ctx->memMgr, f);} /* PKIFreeSignerInfo */size_t PKISizeofSignerInfo(    PKICONTEXT *ctx,    PKISignerInfo *asnstruct,    int outerSizeFlag){    (void)ctx; /* for future use */    return(PKISizeofSignerInfoInternal(asnstruct, outerSizeFlag, PKIFALSE));} /* PKISizeofSignerInfo */size_t PKIPackSignerInfo(    PKICONTEXT *ctx,    unsigned char *buf,    size_t buflen,    PKISignerInfo *asnstruct,    int *erret ){    return(PKIPackSignerInfoInternal(ctx, buf, buflen, asnstruct, PKIID_SignerInfo, erret));} /* PKIPackSignerInfo */size_t PKIUnpackSignerInfo(    PKICONTEXT *ctx,    PKISignerInfo **asnstruct,    unsigned char *buf,    size_t buflen,    int *erret){    return(PKIUnpackSignerInfoInternal(ctx, asnstruct, buf, buflen,                      PKIID_SignerInfo, erret));}/****************************************************************** * Routines for EncryptedData ******************************************************************/PKIEncryptedData *PKINewEncryptedData(    PKICONTEXT *ctx){    PKIEncryptedData *f;    if (ctx == NULL)        return NULL;    f = (PKIEncryptedData *)PKIAlloc(ctx->memMgr, sizeof(PKIEncryptedData));    if (f != NULL)        (void)memset(f, 0, sizeof(PKIEncryptedData));    return (f);} /* PKINewEncryptedData */void PKIFreeEncryptedData(    PKICONTEXT *ctx,    PKIEncryptedData *f){    if (ctx == NULL)        return;    PKIDropInPlaceEncryptedData(ctx, f);    if (f != NULL)        PKIFree(ctx->memMgr, f);} /* PKIFreeEncryptedData */size_t PKISizeofEncryptedData(    PKICONTEXT *ctx,    PKIEncryptedData *asnstruct,    int outerSizeFlag){    (void)ctx; /* for future use */    return(PKISizeofEncryptedDataInternal(asnstruct, outerSizeFlag, PKIFALSE));} /* PKISizeofEncryptedData */size_t PKIPackEncryptedData(    PKICONTEXT *ctx,    unsigned char *buf,    size_t buflen,    PKIEncryptedData *asnstruct,    int *erret ){    return(PKIPackEncryptedDataInternal(ctx, buf, buflen, asnstruct, PKIID_EncryptedData, erret));} /* PKIPackEncryptedData */size_t PKIUnpackEncryptedData(    PKICONTEXT *ctx,    PKIEncryptedData **asnstruct,    unsigned char *buf,    size_t buflen,    int *erret){    return(PKIUnpackEncryptedDataInternal(ctx, asnstruct, buf, buflen,                      PKIID_EncryptedData, erret));}/****************************************************************** * Routines for ExtendedCertificateOrCertificate ******************************************************************/PKIExtendedCertificateOrCertificate *PKINewExtendedCertificateOrCertificate(    PKICONTEXT *ctx){    PKIExtendedCertificateOrCertificate *f;    if (ctx == NULL)        return NULL;    f = (PKIExtendedCertificateOrCertificate *)PKIAlloc(ctx->memMgr, sizeof(PKIExtendedCertificateOrCertificate));    if (f != NULL)        (void)memset(f, 0, sizeof(PKIExtendedCertificateOrCertificate));    return (f);} /* PKINewExtendedCertificateOrCertificate */void PKIFreeExtendedCertificateOrCertificate(    PKICONTEXT *ctx,    PKIExtendedCertificateOrCertificate *f){    if (ctx == NULL)        return;    PKIDropInPlaceExtendedCertificateOrCertificate(ctx, f);    if (f != NULL)        PKIFree(ctx->memMgr, f);} /* PKIFreeExtendedCertificateOrCertificate */size_t PKISizeofExtendedCertificateOrCertificate(    PKICONTEXT *ctx,    PKIExtendedCertificateOrCertificate *asnstruct,    int outerSizeFlag){    (void)ctx; /* for future use */    return(PKISizeofExtendedCertificateOrCertificateInternal(asnstruct, outerSizeFlag, PKIFALSE));} /* PKISizeofExtendedCertificateOrCertificate */size_t PKIPackExtendedCertificateOrCertificate(    PKICONTEXT *ctx,    unsigned char *buf,    size_t buflen,    PKIExtendedCertificateOrCertificate *asnstruct,    int *erret ){    return(PKIPackExtendedCertificateOrCertificateInternal(ctx, buf, buflen, asnstruct, PKIID_ExtendedCertificateOrCertificate, erret));} /* PKIPackExtendedCertificateOrCertificate */size_t PKIUnpackExtendedCertificateOrCertificate(    PKICONTEXT *ctx,    PKIExtendedCertificateOrCertificate **asnstruct,    unsigned char *buf,    size_t buflen,    int *erret){    return(PKIUnpackExtendedCertificateOrCertificateInternal(ctx, asnstruct, buf, buflen,                      PKIID_ExtendedCertificateOrCertificate, erret));}/****************************************************************** * Routines for RecipientInfos ******************************************************************/PKIRecipientInfos *PKINewRecipientInfos(    PKICONTEXT *ctx){    PKIRecipientInfos *f;    if (ctx == NULL)        return NULL;    f = (PKIRecipientInfos *)PKIAlloc(ctx->memMgr, sizeof(PKIRecipientInfos));    if (f != NULL)        (void)memset(f, 0, sizeof(PKIRecipientInfos));    return (f);} /* PKINewRecipientInfos */void PKIFreeRecipientInfos(    PKICONTEXT *ctx,    PKIRecipientInfos *f){    if (ctx == NULL)        return;    PKIDropInPlaceRecipientInfos(ctx, f);    if (f != NULL)        PKIFree(ctx->memMgr, f);} /* PKIFreeRecipientInfos */size_t PKISizeofRecipientInfos(    PKICONTEXT *ctx,    PKIRecipientInfos *asnstruct,    int outerSizeFlag){    (void)ctx; /* for future use */    return(PKISizeofRecipientInfosInternal(asnstruct, outerSizeFlag, PKIFALSE));} /* PKISizeofRecipientInfos */size_t PKIPackRecipientInfos(    PKICONTEXT *ctx,    unsigned char *buf,    size_t buflen,    PKIRecipientInfos *asnstruct,    int *erret ){    return(PKIPackRecipientInfosInternal(ctx, buf, buflen, asnstruct, PKIID_RecipientInfos, erret));} /* PKIPackRecipientInfos */size_t PKIUnpackRecipientInfos(    PKICONTEXT *ctx,    PKIRecipientInfos **asnstruct,    unsigned char *buf,    size_t buflen,    int *erret){    return(PKIUnpackRecipientInfosInternal(ctx, asnstruct, buf, buflen,                      PKIID_RecipientInfos, erret));}/****************************************************************** * Routines for SignerInfos ******************************************************************/PKISignerInfos *PKINewSignerInfos(    PKICONTEXT *ctx){    PKISignerInfos *f;    if (ctx == NULL)        return NULL;    f = (PKISignerInfos *)PKIAlloc(ctx->memMgr, sizeof(PKISignerInfos));    if (f != NULL)        (void)memset(f, 0, sizeof(PKISignerInfos));    return (f);} /* PKINewSignerInfos */void PKIFreeSignerInfos(    PKICONTEXT *ctx,    PKISignerInfos *f){    if (ctx == NULL)        return;    PKIDropInPlaceSignerInfos(ctx, f);    if (f != NULL)        PKIFree(ctx->memMgr, f);} /* PKIFreeSignerInfos */size_t PKISizeofSignerInfos(    PKICONTEXT *ctx,    PKISignerInfos *asnstruct,    int outerSizeFlag){    (void)ctx; /* for future use */    return(PKISizeofSignerInfosInternal(asnstruct, outerSizeFlag, PKIFALSE));} /* PKISizeofSignerInfos */size_t PKIPackSignerInfos(    PKICONTEXT *ctx,    unsigned char *buf,    size_t buflen,    PKISignerInfos *asnstruct,    int *erret ){    return(PKIPackSignerInfosInternal(ctx, buf, buflen, asnstruct, PKIID_SignerInfos, erret));} /* PKIPackSignerInfos */size_t PKIUnpackSignerInfos(    PKICONTEXT *ctx,    PKISignerInfos **asnstruct,    unsigned char *buf,    size_t buflen,    int *erret){    return(PKIUnpackSignerInfosInternal(ctx, asnstruct, buf, buflen,                      PKIID_SignerInfos, erret));}/****************************************************************** * Routines for EnvelopedData ******************************************************************/PKIEnvelopedData *PKINewEnvelopedData(    PKICONTEXT *ctx){    PKIEnvelopedData *f;    if (ctx == NULL)        return NULL;    f = (PKIEnvelopedData *)PKIAlloc(ctx->memMgr, sizeof(PKIEnvelopedData));    if (f != NULL)        (void)memset(f, 0, sizeof(PKIEnvelopedData));    return (f);} /* PKINewEnvelopedData */void PKIFreeEnvelopedData(    PKICONTEXT *ctx,    PKIEnvelopedData *f){    if (ctx == NULL)        return;    PKIDropInPlaceEnvelopedData(ctx, f);    if (f != NULL)        PKIFree(ctx->memMgr, f);} /* PKIFreeEnvelopedData */size_t PKISizeofEnvelopedData(    PKICONTEXT *ctx,    PKIEnvelopedData *asnstruct,    int outerSizeFlag){    (void)ctx; /* for future use */    return(PKISizeofEnvelopedDataInternal(asnstruct, outerSizeFlag, PKIFALSE));} /* PKISizeofEnvelopedData */size_t PKIPackEnvelopedData(    PKICONTEXT *ctx,    unsigned char *buf,    size_t buflen,    PKIEnvelopedData *asnstruct,    int *erret ){    return(PKIPackEnvelopedDataInternal(ctx, buf, buflen, asnstruct, PKIID_EnvelopedData, erret));} /* PKIPackEnvelopedData */size_t PKIUnpackEnvelopedData(    PKICONTEXT *ctx,    PKIEnvelopedData **asnstruct,    unsigned char *buf,    size_t buflen,    int *erret){    return(PKIUnpackEnvelopedDataInternal(ctx, asnstruct, buf, buflen,                      PKIID_EnvelopedData, erret));}/****************************************************************** * Routines for ExtendedCertificatesAndCertificates ******************************************************************/PKIExtendedCertificatesAndCertificates *PKINewExtendedCertificatesAndCertificates(    PKICONTEXT *ctx){    PKIExtendedCertificatesAndCertificates *f;    if (ctx == NULL)        return NULL;    f = (PKIExtendedCertificatesAndCertificates *)PKIAlloc(ctx->memMgr, sizeof(PKIExtendedCertificatesAndCertificates));    if (f != NULL)        (void)memset(f, 0, sizeof(PKIExtendedCertificatesAndCertificates));    return (f);} /* PKINewExtendedCertificatesAndCertificates */void PKIFreeExtendedCertificatesAndCertificates(    PKICONTEXT *ctx,    PKIExtendedCertificatesAndCertificates *f){    if (ctx == NULL)        return;    PKIDropInPlaceExtendedCertificatesAndCertificates(ctx, f);    if (f != NULL)        PKIFree(ctx->memMgr, f);} /* PKIFreeExtendedCertificatesAndCertificates */size_t PKISizeofExtendedCertificatesAndCertificates(    PKICONTEXT *ctx,    PKIExtendedCertificatesAndCertificates *asnstruct,    int outerSizeFlag){    (void)ctx; /* for future use */    return(PKISizeofExtendedCertificatesAndCertificatesInternal(asnstruct, outerSizeFlag, PKIFALSE));} /* PKISizeofExtendedCertificatesAndCertificates */size_t PKIPackExtendedCertificatesAndCertificates(    PKICONTEXT *ctx,    unsigned char *buf,    size_t buflen,    PKIExtendedCertificatesAndCertificates *asnstruct,    int *erret ){    return(PKIPackExtendedCertificatesAndCertificatesInternal(ctx, buf, buflen, asnstruct, PKIID_ExtendedCertificatesAndCertificates, erret));} /* PKIPackExtendedCertificatesAndCertificates */size_t PKIUnpackExtendedCertificatesAndCertificates(    PKICONTEXT *ctx,    PKIExtendedCertificatesAndCertificates **asnstruct,    unsigned char *buf,    size_t buflen,    int *erret){    return(PKIUnpackExtendedCertificatesAndCertificatesInternal(ctx, asnstruct, buf, buflen,                      PKIID_ExtendedCertificatesAndCertificates, erret));}/****************************************************************** * Routines for SignedData ******************************************************************/PKISignedData *PKINewSignedData(    PKICONTEXT *ctx){    PKISignedData *f;    if (ctx == NULL)        return NULL;    f = (PKISignedData *)PKIAlloc(ctx->memMgr, sizeof(PKISignedData));    if (f != NULL)        (void)memset(f, 0, sizeof(PKISignedData));    return (f);} /* PKINewSignedData */void PKIFreeSignedData(    PKICONTEXT *ctx,    PKISignedData *f){    if (ctx == NULL)        return;    PKIDropInPlaceSignedData(ctx, f);    if (f != NULL)        PKIFree(ctx->memMgr, f);} /* PKIFreeSignedData */size_t PKISizeofSignedData(    PKICONTEXT *ctx,    PKISignedData *asnstruct,    int outerSizeFlag){    (void)ctx; /* for future use */    return(PKISizeofSignedDataInternal(asnstruct, outerSizeFlag, PKIFALSE));} /* PKISizeofSignedData */size_t PKIPackSignedData(    PKICONTEXT *ctx,    unsigned char *buf,    size_t buflen,    PKISignedData *asnstruct,    int *erret ){    return(PKIPackSignedDataInternal(ctx, buf, buflen, asnstruct, PKIID_SignedData, erret));} /* PKIPackSignedData */size_t PKIUnpackSignedData(    PKICONTEXT *ctx,    PKISignedData **asnstruct,    unsigned char *buf,    size_t buflen,    int *erret){    return(PKIUnpackSignedDataInternal(ctx, asnstruct, buf, buflen,                      PKIID_SignedData, erret));}