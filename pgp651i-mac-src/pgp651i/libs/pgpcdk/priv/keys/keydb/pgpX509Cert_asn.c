/******************************************************************* * * This file was generated by TIS/ASN1COMP Ver. 4.2, an ASN.1 compiler. * TIS/ASN1COMP is Copyright (c) 1998, TIS Labs at Network Associates, Inc. * * This file was AUTOMATICALLY GENERATED on Tue May 18 17:09:45 1999 * ******************************************************************/#include <string.h>#include "pgpX509Cert_asn.h"/******************************************************************* * * Code for manipulating ASN.1 DER data and structure. * *  NewXXX: Allocate the top level of a structure. * *  FreeXXX: Release all the data of an ASN structure. * *  SizeofXXX: Return the size of the DER block that would *               be created from the structure. * *  PackXXX: Take an ASN structure and return the DER. * *  unPackXXX: Take the DER and return an ASN structure. * ******************************************************************/size_t pgpasn_PackBMPString(    PGPASN_CONTEXT *ctx,    unsigned char *buf,    size_t buflen,    PGPASN_BMPString *asnstruct,    int *erret ){    return(pgpasn_PackBMPStringInternal(ctx, buf, buflen, asnstruct, PGPASN_ID_BMPString, erret));} /* pgpasn_PackBMPString */size_t pgpasn_UnpackBMPString(    PGPASN_CONTEXT *ctx,    PGPASN_BMPString **asnstruct,    const unsigned char *buf,    size_t buflen,    int *erret){    size_t bytesused;    bytesused=pgpasn_UnpackBMPStringInternal(ctx, asnstruct, buf, buflen,                      PGPASN_ID_BMPString, erret);    if(*erret==0 && bytesused==0)        PGPASN_ERR(kPGPASNError_ErrUnpackUnderrun);    return bytesused;}size_t pgpasn_PackUTF8String(    PGPASN_CONTEXT *ctx,    unsigned char *buf,    size_t buflen,    PGPASN_UTF8String *asnstruct,    int *erret ){    return(pgpasn_PackUTF8StringInternal(ctx, buf, buflen, asnstruct, PGPASN_ID_UTF8String, erret));} /* pgpasn_PackUTF8String */size_t pgpasn_UnpackUTF8String(    PGPASN_CONTEXT *ctx,    PGPASN_UTF8String **asnstruct,    const unsigned char *buf,    size_t buflen,    int *erret){    size_t bytesused;    bytesused=pgpasn_UnpackUTF8StringInternal(ctx, asnstruct, buf, buflen,                      PGPASN_ID_UTF8String, erret);    if(*erret==0 && bytesused==0)        PGPASN_ERR(kPGPASNError_ErrUnpackUnderrun);    return bytesused;}size_t pgpasn_PackUniversalString(    PGPASN_CONTEXT *ctx,    unsigned char *buf,    size_t buflen,    PGPASN_UniversalString *asnstruct,    int *erret ){    return(pgpasn_PackUniversalStringInternal(ctx, buf, buflen, asnstruct, PGPASN_ID_UniversalString, erret));} /* pgpasn_PackUniversalString */size_t pgpasn_UnpackUniversalString(    PGPASN_CONTEXT *ctx,    PGPASN_UniversalString **asnstruct,    const unsigned char *buf,    size_t buflen,    int *erret){    size_t bytesused;    bytesused=pgpasn_UnpackUniversalStringInternal(ctx, asnstruct, buf, buflen,                      PGPASN_ID_UniversalString, erret);    if(*erret==0 && bytesused==0)        PGPASN_ERR(kPGPASNError_ErrUnpackUnderrun);    return bytesused;}/****************************************************************** * Routines for AlgorithmIdentifier ******************************************************************/PGPASN_AlgorithmIdentifier *pgpasn_NewAlgorithmIdentifier(    PGPASN_CONTEXT *ctx){    PGPASN_AlgorithmIdentifier *f;    if (ctx == NULL)        return NULL;    f = (PGPASN_AlgorithmIdentifier *)PGPASN_Alloc(ctx->memMgr, sizeof(PGPASN_AlgorithmIdentifier));    if (f != NULL)        (void)memset(f, 0, sizeof(PGPASN_AlgorithmIdentifier));    return (f);} /* pgpasn_NewAlgorithmIdentifier */void pgpasn_FreeAlgorithmIdentifier(    PGPASN_CONTEXT *ctx,    PGPASN_AlgorithmIdentifier *f){    if (ctx == NULL)        return;    pgpasn_DropInPlaceAlgorithmIdentifier(ctx, f);    if (f != NULL)        PGPASN_Free(ctx->memMgr, f);} /* pgpasn_FreeAlgorithmIdentifier */size_t pgpasn_SizeofAlgorithmIdentifier(    PGPASN_CONTEXT *ctx,    PGPASN_AlgorithmIdentifier *asnstruct,    int outerSizeFlag){    (void)ctx; /* for future use */    return(pgpasn_SizeofAlgorithmIdentifierInternal(asnstruct, outerSizeFlag, PGPASN_FALSE));} /* pgpasn_SizeofAlgorithmIdentifier */size_t pgpasn_PackAlgorithmIdentifier(    PGPASN_CONTEXT *ctx,    unsigned char *buf,    size_t buflen,    PGPASN_AlgorithmIdentifier *asnstruct,    int *erret ){    return(pgpasn_PackAlgorithmIdentifierInternal(ctx, buf, buflen, asnstruct, PGPASN_ID_AlgorithmIdentifier, erret));} /* pgpasn_PackAlgorithmIdentifier */size_t pgpasn_UnpackAlgorithmIdentifier(    PGPASN_CONTEXT *ctx,    PGPASN_AlgorithmIdentifier **asnstruct,    const unsigned char *buf,    size_t buflen,    int *erret){    size_t bytesused;    bytesused=pgpasn_UnpackAlgorithmIdentifierInternal(ctx, asnstruct, buf, buflen,                      PGPASN_ID_AlgorithmIdentifier, erret);    if(*erret==0 && bytesused==0)        PGPASN_ERR(kPGPASNError_ErrUnpackUnderrun);    return bytesused;}/****************************************************************** * Routines for AttributeTypeAndValue ******************************************************************/PGPASN_AttributeTypeAndValue *pgpasn_NewAttributeTypeAndValue(    PGPASN_CONTEXT *ctx){    PGPASN_AttributeTypeAndValue *f;    if (ctx == NULL)        return NULL;    f = (PGPASN_AttributeTypeAndValue *)PGPASN_Alloc(ctx->memMgr, sizeof(PGPASN_AttributeTypeAndValue));    if (f != NULL)        (void)memset(f, 0, sizeof(PGPASN_AttributeTypeAndValue));    return (f);} /* pgpasn_NewAttributeTypeAndValue */void pgpasn_FreeAttributeTypeAndValue(    PGPASN_CONTEXT *ctx,    PGPASN_AttributeTypeAndValue *f){    if (ctx == NULL)        return;    pgpasn_DropInPlaceAttributeTypeAndValue(ctx, f);    if (f != NULL)        PGPASN_Free(ctx->memMgr, f);} /* pgpasn_FreeAttributeTypeAndValue */size_t pgpasn_SizeofAttributeTypeAndValue(    PGPASN_CONTEXT *ctx,    PGPASN_AttributeTypeAndValue *asnstruct,    int outerSizeFlag){    (void)ctx; /* for future use */    return(pgpasn_SizeofAttributeTypeAndValueInternal(asnstruct, outerSizeFlag, PGPASN_FALSE));} /* pgpasn_SizeofAttributeTypeAndValue */size_t pgpasn_PackAttributeTypeAndValue(    PGPASN_CONTEXT *ctx,    unsigned char *buf,    size_t buflen,    PGPASN_AttributeTypeAndValue *asnstruct,    int *erret ){    return(pgpasn_PackAttributeTypeAndValueInternal(ctx, buf, buflen, asnstruct, PGPASN_ID_AttributeTypeAndValue, erret));} /* pgpasn_PackAttributeTypeAndValue */size_t pgpasn_UnpackAttributeTypeAndValue(    PGPASN_CONTEXT *ctx,    PGPASN_AttributeTypeAndValue **asnstruct,    const unsigned char *buf,    size_t buflen,    int *erret){    size_t bytesused;    bytesused=pgpasn_UnpackAttributeTypeAndValueInternal(ctx, asnstruct, buf, buflen,                      PGPASN_ID_AttributeTypeAndValue, erret);    if(*erret==0 && bytesused==0)        PGPASN_ERR(kPGPASNError_ErrUnpackUnderrun);    return bytesused;}/****************************************************************** * Routines for AttributeValues ******************************************************************/PGPASN_AttributeValues *pgpasn_NewAttributeValues(    PGPASN_CONTEXT *ctx){    PGPASN_AttributeValues *f;    if (ctx == NULL)        return NULL;    f = (PGPASN_AttributeValues *)PGPASN_Alloc(ctx->memMgr, sizeof(PGPASN_AttributeValues));    if (f != NULL)        (void)memset(f, 0, sizeof(PGPASN_AttributeValues));    return (f);} /* pgpasn_NewAttributeValues */void pgpasn_FreeAttributeValues(    PGPASN_CONTEXT *ctx,    PGPASN_AttributeValues *f){    if (ctx == NULL)        return;    pgpasn_DropInPlaceAttributeValues(ctx, f);    if (f != NULL)        PGPASN_Free(ctx->memMgr, f);} /* pgpasn_FreeAttributeValues */size_t pgpasn_SizeofAttributeValues(    PGPASN_CONTEXT *ctx,    PGPASN_AttributeValues *asnstruct,    int outerSizeFlag){    (void)ctx; /* for future use */    return(pgpasn_SizeofAttributeValuesInternal(asnstruct, outerSizeFlag, PGPASN_FALSE));} /* pgpasn_SizeofAttributeValues */size_t pgpasn_PackAttributeValues(    PGPASN_CONTEXT *ctx,    unsigned char *buf,    size_t buflen,    PGPASN_AttributeValues *asnstruct,    int *erret ){    return(pgpasn_PackAttributeValuesInternal(ctx, buf, buflen, asnstruct, PGPASN_ID_AttributeValues, erret));} /* pgpasn_PackAttributeValues */size_t pgpasn_UnpackAttributeValues(    PGPASN_CONTEXT *ctx,    PGPASN_AttributeValues **asnstruct,    const unsigned char *buf,    size_t buflen,    int *erret){    size_t bytesused;    bytesused=pgpasn_UnpackAttributeValuesInternal(ctx, asnstruct, buf, buflen,                      PGPASN_ID_AttributeValues, erret);    if(*erret==0 && bytesused==0)        PGPASN_ERR(kPGPASNError_ErrUnpackUnderrun);    return bytesused;}/****************************************************************** * Routines for BasicConstraints ******************************************************************/PGPASN_BasicConstraints *pgpasn_NewBasicConstraints(    PGPASN_CONTEXT *ctx){    PGPASN_BasicConstraints *f;    if (ctx == NULL)        return NULL;    f = (PGPASN_BasicConstraints *)PGPASN_Alloc(ctx->memMgr, sizeof(PGPASN_BasicConstraints));    if (f != NULL)        (void)memset(f, 0, sizeof(PGPASN_BasicConstraints));    return (f);} /* pgpasn_NewBasicConstraints */void pgpasn_FreeBasicConstraints(    PGPASN_CONTEXT *ctx,    PGPASN_BasicConstraints *f){    if (ctx == NULL)        return;    pgpasn_DropInPlaceBasicConstraints(ctx, f);    if (f != NULL)        PGPASN_Free(ctx->memMgr, f);} /* pgpasn_FreeBasicConstraints */size_t pgpasn_SizeofBasicConstraints(    PGPASN_CONTEXT *ctx,    PGPASN_BasicConstraints *asnstruct,    int outerSizeFlag){    (void)ctx; /* for future use */    return(pgpasn_SizeofBasicConstraintsInternal(asnstruct, outerSizeFlag, PGPASN_FALSE));} /* pgpasn_SizeofBasicConstraints */size_t pgpasn_PackBasicConstraints(    PGPASN_CONTEXT *ctx,    unsigned char *buf,    size_t buflen,    PGPASN_BasicConstraints *asnstruct,    int *erret ){    return(pgpasn_PackBasicConstraintsInternal(ctx, buf, buflen, asnstruct, PGPASN_ID_BasicConstraints, erret));} /* pgpasn_PackBasicConstraints */size_t pgpasn_UnpackBasicConstraints(    PGPASN_CONTEXT *ctx,    PGPASN_BasicConstraints **asnstruct,    const unsigned char *buf,    size_t buflen,    int *erret){    size_t bytesused;    bytesused=pgpasn_UnpackBasicConstraintsInternal(ctx, asnstruct, buf, buflen,                      PGPASN_ID_BasicConstraints, erret);    if(*erret==0 && bytesused==0)        PGPASN_ERR(kPGPASNError_ErrUnpackUnderrun);    return bytesused;}/****************************************************************** * Routines for CertificateValidityDate ******************************************************************/PGPASN_CertificateValidityDate *pgpasn_NewCertificateValidityDate(    PGPASN_CONTEXT *ctx){    PGPASN_CertificateValidityDate *f;    if (ctx == NULL)        return NULL;    f = (PGPASN_CertificateValidityDate *)PGPASN_Alloc(ctx->memMgr, sizeof(PGPASN_CertificateValidityDate));    if (f != NULL)        (void)memset(f, 0, sizeof(PGPASN_CertificateValidityDate));    return (f);} /* pgpasn_NewCertificateValidityDate */void pgpasn_FreeCertificateValidityDate(    PGPASN_CONTEXT *ctx,    PGPASN_CertificateValidityDate *f){    if (ctx == NULL)        return;    pgpasn_DropInPlaceCertificateValidityDate(ctx, f);    if (f != NULL)        PGPASN_Free(ctx->memMgr, f);} /* pgpasn_FreeCertificateValidityDate */size_t pgpasn_SizeofCertificateValidityDate(    PGPASN_CONTEXT *ctx,    PGPASN_CertificateValidityDate *asnstruct,    int outerSizeFlag){    (void)ctx; /* for future use */    return(pgpasn_SizeofCertificateValidityDateInternal(asnstruct, outerSizeFlag, PGPASN_FALSE));} /* pgpasn_SizeofCertificateValidityDate */size_t pgpasn_PackCertificateValidityDate(    PGPASN_CONTEXT *ctx,    unsigned char *buf,    size_t buflen,    PGPASN_CertificateValidityDate *asnstruct,    int *erret ){    return(pgpasn_PackCertificateValidityDateInternal(ctx, buf, buflen, asnstruct, PGPASN_ID_CertificateValidityDate, erret));} /* pgpasn_PackCertificateValidityDate */size_t pgpasn_UnpackCertificateValidityDate(    PGPASN_CONTEXT *ctx,    PGPASN_CertificateValidityDate **asnstruct,    const unsigned char *buf,    size_t buflen,    int *erret){    size_t bytesused;    bytesused=pgpasn_UnpackCertificateValidityDateInternal(ctx, asnstruct, buf, buflen,                      PGPASN_ID_CertificateValidityDate, erret);    if(*erret==0 && bytesused==0)        PGPASN_ERR(kPGPASNError_ErrUnpackUnderrun);    return bytesused;}/****************************************************************** * Routines for ContentInfo ******************************************************************/PGPASN_ContentInfo *pgpasn_NewContentInfo(    PGPASN_CONTEXT *ctx){    PGPASN_ContentInfo *f;    if (ctx == NULL)        return NULL;    f = (PGPASN_ContentInfo *)PGPASN_Alloc(ctx->memMgr, sizeof(PGPASN_ContentInfo));    if (f != NULL)        (void)memset(f, 0, sizeof(PGPASN_ContentInfo));    return (f);} /* pgpasn_NewContentInfo */void pgpasn_FreeContentInfo(    PGPASN_CONTEXT *ctx,    PGPASN_ContentInfo *f){    if (ctx == NULL)        return;    pgpasn_DropInPlaceContentInfo(ctx, f);    if (f != NULL)        PGPASN_Free(ctx->memMgr, f);} /* pgpasn_FreeContentInfo */size_t pgpasn_SizeofContentInfo(    PGPASN_CONTEXT *ctx,    PGPASN_ContentInfo *asnstruct,    int outerSizeFlag){    (void)ctx; /* for future use */    return(pgpasn_SizeofContentInfoInternal(asnstruct, outerSizeFlag, PGPASN_FALSE));} /* pgpasn_SizeofContentInfo */size_t pgpasn_PackContentInfo(    PGPASN_CONTEXT *ctx,    unsigned char *buf,    size_t buflen,    PGPASN_ContentInfo *asnstruct,    int *erret ){    return(pgpasn_PackContentInfoInternal(ctx, buf, buflen, asnstruct, PGPASN_ID_ContentInfo, erret));} /* pgpasn_PackContentInfo */size_t pgpasn_UnpackContentInfo(    PGPASN_CONTEXT *ctx,    PGPASN_ContentInfo **asnstruct,    const unsigned char *buf,    size_t buflen,    int *erret){    size_t bytesused;    bytesused=pgpasn_UnpackContentInfoInternal(ctx, asnstruct, buf, buflen,                      PGPASN_ID_ContentInfo, erret);    if(*erret==0 && bytesused==0)        PGPASN_ERR(kPGPASNError_ErrUnpackUnderrun);    return bytesused;}/****************************************************************** * Routines for DirectoryString ******************************************************************/PGPASN_DirectoryString *pgpasn_NewDirectoryString(    PGPASN_CONTEXT *ctx){    PGPASN_DirectoryString *f;    if (ctx == NULL)        return NULL;    f = (PGPASN_DirectoryString *)PGPASN_Alloc(ctx->memMgr, sizeof(PGPASN_DirectoryString));    if (f != NULL)        (void)memset(f, 0, sizeof(PGPASN_DirectoryString));    return (f);} /* pgpasn_NewDirectoryString */void pgpasn_FreeDirectoryString(    PGPASN_CONTEXT *ctx,    PGPASN_DirectoryString *f){    if (ctx == NULL)        return;    pgpasn_DropInPlaceDirectoryString(ctx, f);    if (f != NULL)        PGPASN_Free(ctx->memMgr, f);} /* pgpasn_FreeDirectoryString */size_t pgpasn_SizeofDirectoryString(    PGPASN_CONTEXT *ctx,    PGPASN_DirectoryString *asnstruct,    int outerSizeFlag){    (void)ctx; /* for future use */    return(pgpasn_SizeofDirectoryStringInternal(asnstruct, outerSizeFlag, PGPASN_FALSE));} /* pgpasn_SizeofDirectoryString */size_t pgpasn_PackDirectoryString(    PGPASN_CONTEXT *ctx,    unsigned char *buf,    size_t buflen,    PGPASN_DirectoryString *asnstruct,    int *erret ){    return(pgpasn_PackDirectoryStringInternal(ctx, buf, buflen, asnstruct, PGPASN_ID_DirectoryString, erret));} /* pgpasn_PackDirectoryString */size_t pgpasn_UnpackDirectoryString(    PGPASN_CONTEXT *ctx,    PGPASN_DirectoryString **asnstruct,    const unsigned char *buf,    size_t buflen,    int *erret){    size_t bytesused;    bytesused=pgpasn_UnpackDirectoryStringInternal(ctx, asnstruct, buf, buflen,                      PGPASN_ID_DirectoryString, erret);    if(*erret==0 && bytesused==0)        PGPASN_ERR(kPGPASNError_ErrUnpackUnderrun);    return bytesused;}/****************************************************************** * Routines for DssParms ******************************************************************/PGPASN_DssParms *pgpasn_NewDssParms(    PGPASN_CONTEXT *ctx){    PGPASN_DssParms *f;    if (ctx == NULL)        return NULL;    f = (PGPASN_DssParms *)PGPASN_Alloc(ctx->memMgr, sizeof(PGPASN_DssParms));    if (f != NULL)        (void)memset(f, 0, sizeof(PGPASN_DssParms));    return (f);} /* pgpasn_NewDssParms */void pgpasn_FreeDssParms(    PGPASN_CONTEXT *ctx,    PGPASN_DssParms *f){    if (ctx == NULL)        return;    pgpasn_DropInPlaceDssParms(ctx, f);    if (f != NULL)        PGPASN_Free(ctx->memMgr, f);} /* pgpasn_FreeDssParms */size_t pgpasn_SizeofDssParms(    PGPASN_CONTEXT *ctx,    PGPASN_DssParms *asnstruct,    int outerSizeFlag){    (void)ctx; /* for future use */    return(pgpasn_SizeofDssParmsInternal(asnstruct, outerSizeFlag, PGPASN_FALSE));} /* pgpasn_SizeofDssParms */size_t pgpasn_PackDssParms(    PGPASN_CONTEXT *ctx,    unsigned char *buf,    size_t buflen,    PGPASN_DssParms *asnstruct,    int *erret ){    return(pgpasn_PackDssParmsInternal(ctx, buf, buflen, asnstruct, PGPASN_ID_DssParms, erret));} /* pgpasn_PackDssParms */size_t pgpasn_UnpackDssParms(    PGPASN_CONTEXT *ctx,    PGPASN_DssParms **asnstruct,    const unsigned char *buf,    size_t buflen,    int *erret){    size_t bytesused;    bytesused=pgpasn_UnpackDssParmsInternal(ctx, asnstruct, buf, buflen,                      PGPASN_ID_DssParms, erret);    if(*erret==0 && bytesused==0)        PGPASN_ERR(kPGPASNError_ErrUnpackUnderrun);    return bytesused;}/****************************************************************** * Routines for DssSigValue ******************************************************************/PGPASN_DssSigValue *pgpasn_NewDssSigValue(    PGPASN_CONTEXT *ctx){    PGPASN_DssSigValue *f;    if (ctx == NULL)        return NULL;    f = (PGPASN_DssSigValue *)PGPASN_Alloc(ctx->memMgr, sizeof(PGPASN_DssSigValue));    if (f != NULL)        (void)memset(f, 0, sizeof(PGPASN_DssSigValue));    return (f);} /* pgpasn_NewDssSigValue */void pgpasn_FreeDssSigValue(    PGPASN_CONTEXT *ctx,    PGPASN_DssSigValue *f){    if (ctx == NULL)        return;    pgpasn_DropInPlaceDssSigValue(ctx, f);    if (f != NULL)        PGPASN_Free(ctx->memMgr, f);} /* pgpasn_FreeDssSigValue */size_t pgpasn_SizeofDssSigValue(    PGPASN_CONTEXT *ctx,    PGPASN_DssSigValue *asnstruct,    int outerSizeFlag){    (void)ctx; /* for future use */    return(pgpasn_SizeofDssSigValueInternal(asnstruct, outerSizeFlag, PGPASN_FALSE));} /* pgpasn_SizeofDssSigValue */size_t pgpasn_PackDssSigValue(    PGPASN_CONTEXT *ctx,    unsigned char *buf,    size_t buflen,    PGPASN_DssSigValue *asnstruct,    int *erret ){    return(pgpasn_PackDssSigValueInternal(ctx, buf, buflen, asnstruct, PGPASN_ID_DssSigValue, erret));} /* pgpasn_PackDssSigValue */size_t pgpasn_UnpackDssSigValue(    PGPASN_CONTEXT *ctx,    PGPASN_DssSigValue **asnstruct,    const unsigned char *buf,    size_t buflen,    int *erret){    size_t bytesused;    bytesused=pgpasn_UnpackDssSigValueInternal(ctx, asnstruct, buf, buflen,                      PGPASN_ID_DssSigValue, erret);    if(*erret==0 && bytesused==0)        PGPASN_ERR(kPGPASNError_ErrUnpackUnderrun);    return bytesused;}/****************************************************************** * Routines for ELGParms ******************************************************************/PGPASN_ELGParms *pgpasn_NewELGParms(    PGPASN_CONTEXT *ctx){    PGPASN_ELGParms *f;    if (ctx == NULL)        return NULL;    f = (PGPASN_ELGParms *)PGPASN_Alloc(ctx->memMgr, sizeof(PGPASN_ELGParms));    if (f != NULL)        (void)memset(f, 0, sizeof(PGPASN_ELGParms));    return (f);} /* pgpasn_NewELGParms */void pgpasn_FreeELGParms(    PGPASN_CONTEXT *ctx,    PGPASN_ELGParms *f){    if (ctx == NULL)        return;    pgpasn_DropInPlaceELGParms(ctx, f);    if (f != NULL)        PGPASN_Free(ctx->memMgr, f);} /* pgpasn_FreeELGParms */size_t pgpasn_SizeofELGParms(    PGPASN_CONTEXT *ctx,    PGPASN_ELGParms *asnstruct,    int outerSizeFlag){    (void)ctx; /* for future use */    return(pgpasn_SizeofELGParmsInternal(asnstruct, outerSizeFlag, PGPASN_FALSE));} /* pgpasn_SizeofELGParms */size_t pgpasn_PackELGParms(    PGPASN_CONTEXT *ctx,    unsigned char *buf,    size_t buflen,    PGPASN_ELGParms *asnstruct,    int *erret ){    return(pgpasn_PackELGParmsInternal(ctx, buf, buflen, asnstruct, PGPASN_ID_ELGParms, erret));} /* pgpasn_PackELGParms */size_t pgpasn_UnpackELGParms(    PGPASN_CONTEXT *ctx,    PGPASN_ELGParms **asnstruct,    const unsigned char *buf,    size_t buflen,    int *erret){    size_t bytesused;    bytesused=pgpasn_UnpackELGParmsInternal(ctx, asnstruct, buf, buflen,                      PGPASN_ID_ELGParms, erret);    if(*erret==0 && bytesused==0)        PGPASN_ERR(kPGPASNError_ErrUnpackUnderrun);    return bytesused;}/****************************************************************** * Routines for Extension ******************************************************************/PGPASN_Extension *pgpasn_NewExtension(    PGPASN_CONTEXT *ctx){    PGPASN_Extension *f;    if (ctx == NULL)        return NULL;    f = (PGPASN_Extension *)PGPASN_Alloc(ctx->memMgr, sizeof(PGPASN_Extension));    if (f != NULL)        (void)memset(f, 0, sizeof(PGPASN_Extension));    return (f);} /* pgpasn_NewExtension */void pgpasn_FreeExtension(    PGPASN_CONTEXT *ctx,    PGPASN_Extension *f){    if (ctx == NULL)        return;    pgpasn_DropInPlaceExtension(ctx, f);    if (f != NULL)        PGPASN_Free(ctx->memMgr, f);} /* pgpasn_FreeExtension */size_t pgpasn_SizeofExtension(    PGPASN_CONTEXT *ctx,    PGPASN_Extension *asnstruct,    int outerSizeFlag){    (void)ctx; /* for future use */    return(pgpasn_SizeofExtensionInternal(asnstruct, outerSizeFlag, PGPASN_FALSE));} /* pgpasn_SizeofExtension */size_t pgpasn_PackExtension(    PGPASN_CONTEXT *ctx,    unsigned char *buf,    size_t buflen,    PGPASN_Extension *asnstruct,    int *erret ){    return(pgpasn_PackExtensionInternal(ctx, buf, buflen, asnstruct, PGPASN_ID_Extension, erret));} /* pgpasn_PackExtension */size_t pgpasn_UnpackExtension(    PGPASN_CONTEXT *ctx,    PGPASN_Extension **asnstruct,    const unsigned char *buf,    size_t buflen,    int *erret){    size_t bytesused;    bytesused=pgpasn_UnpackExtensionInternal(ctx, asnstruct, buf, buflen,                      PGPASN_ID_Extension, erret);    if(*erret==0 && bytesused==0)        PGPASN_ERR(kPGPASNError_ErrUnpackUnderrun);    return bytesused;}/****************************************************************** * Routines for OtherName ******************************************************************/PGPASN_OtherName *pgpasn_NewOtherName(    PGPASN_CONTEXT *ctx){    PGPASN_OtherName *f;    if (ctx == NULL)        return NULL;    f = (PGPASN_OtherName *)PGPASN_Alloc(ctx->memMgr, sizeof(PGPASN_OtherName));    if (f != NULL)        (void)memset(f, 0, sizeof(PGPASN_OtherName));    return (f);} /* pgpasn_NewOtherName */void pgpasn_FreeOtherName(    PGPASN_CONTEXT *ctx,    PGPASN_OtherName *f){    if (ctx == NULL)        return;    pgpasn_DropInPlaceOtherName(ctx, f);    if (f != NULL)        PGPASN_Free(ctx->memMgr, f);} /* pgpasn_FreeOtherName */size_t pgpasn_SizeofOtherName(    PGPASN_CONTEXT *ctx,    PGPASN_OtherName *asnstruct,    int outerSizeFlag){    (void)ctx; /* for future use */    return(pgpasn_SizeofOtherNameInternal(asnstruct, outerSizeFlag, PGPASN_FALSE));} /* pgpasn_SizeofOtherName */size_t pgpasn_PackOtherName(    PGPASN_CONTEXT *ctx,    unsigned char *buf,    size_t buflen,    PGPASN_OtherName *asnstruct,    int *erret ){    return(pgpasn_PackOtherNameInternal(ctx, buf, buflen, asnstruct, PGPASN_ID_OtherName, erret));} /* pgpasn_PackOtherName */size_t pgpasn_UnpackOtherName(    PGPASN_CONTEXT *ctx,    PGPASN_OtherName **asnstruct,    const unsigned char *buf,    size_t buflen,    int *erret){    size_t bytesused;    bytesused=pgpasn_UnpackOtherNameInternal(ctx, asnstruct, buf, buflen,                      PGPASN_ID_OtherName, erret);    if(*erret==0 && bytesused==0)        PGPASN_ERR(kPGPASNError_ErrUnpackUnderrun);    return bytesused;}/****************************************************************** * Routines for RSAKey ******************************************************************/PGPASN_RSAKey *pgpasn_NewRSAKey(    PGPASN_CONTEXT *ctx){    PGPASN_RSAKey *f;    if (ctx == NULL)        return NULL;    f = (PGPASN_RSAKey *)PGPASN_Alloc(ctx->memMgr, sizeof(PGPASN_RSAKey));    if (f != NULL)        (void)memset(f, 0, sizeof(PGPASN_RSAKey));    return (f);} /* pgpasn_NewRSAKey */void pgpasn_FreeRSAKey(    PGPASN_CONTEXT *ctx,    PGPASN_RSAKey *f){    if (ctx == NULL)        return;    pgpasn_DropInPlaceRSAKey(ctx, f);    if (f != NULL)        PGPASN_Free(ctx->memMgr, f);} /* pgpasn_FreeRSAKey */size_t pgpasn_SizeofRSAKey(    PGPASN_CONTEXT *ctx,    PGPASN_RSAKey *asnstruct,    int outerSizeFlag){    (void)ctx; /* for future use */    return(pgpasn_SizeofRSAKeyInternal(asnstruct, outerSizeFlag, PGPASN_FALSE));} /* pgpasn_SizeofRSAKey */size_t pgpasn_PackRSAKey(    PGPASN_CONTEXT *ctx,    unsigned char *buf,    size_t buflen,    PGPASN_RSAKey *asnstruct,    int *erret ){    return(pgpasn_PackRSAKeyInternal(ctx, buf, buflen, asnstruct, PGPASN_ID_RSAKey, erret));} /* pgpasn_PackRSAKey */size_t pgpasn_UnpackRSAKey(    PGPASN_CONTEXT *ctx,    PGPASN_RSAKey **asnstruct,    const unsigned char *buf,    size_t buflen,    int *erret){    size_t bytesused;    bytesused=pgpasn_UnpackRSAKeyInternal(ctx, asnstruct, buf, buflen,                      PGPASN_ID_RSAKey, erret);    if(*erret==0 && bytesused==0)        PGPASN_ERR(kPGPASNError_ErrUnpackUnderrun);    return bytesused;}/****************************************************************** * Routines for RSAPrivateKey ******************************************************************/PGPASN_RSAPrivateKey *pgpasn_NewRSAPrivateKey(    PGPASN_CONTEXT *ctx){    PGPASN_RSAPrivateKey *f;    if (ctx == NULL)        return NULL;    f = (PGPASN_RSAPrivateKey *)PGPASN_Alloc(ctx->memMgr, sizeof(PGPASN_RSAPrivateKey));    if (f != NULL)        (void)memset(f, 0, sizeof(PGPASN_RSAPrivateKey));    return (f);} /* pgpasn_NewRSAPrivateKey */void pgpasn_FreeRSAPrivateKey(    PGPASN_CONTEXT *ctx,    PGPASN_RSAPrivateKey *f){    if (ctx == NULL)        return;    pgpasn_DropInPlaceRSAPrivateKey(ctx, f);    if (f != NULL)        PGPASN_Free(ctx->memMgr, f);} /* pgpasn_FreeRSAPrivateKey */size_t pgpasn_SizeofRSAPrivateKey(    PGPASN_CONTEXT *ctx,    PGPASN_RSAPrivateKey *asnstruct,    int outerSizeFlag){    (void)ctx; /* for future use */    return(pgpasn_SizeofRSAPrivateKeyInternal(asnstruct, outerSizeFlag, PGPASN_FALSE));} /* pgpasn_SizeofRSAPrivateKey */size_t pgpasn_PackRSAPrivateKey(    PGPASN_CONTEXT *ctx,    unsigned char *buf,    size_t buflen,    PGPASN_RSAPrivateKey *asnstruct,    int *erret ){    return(pgpasn_PackRSAPrivateKeyInternal(ctx, buf, buflen, asnstruct, PGPASN_ID_RSAPrivateKey, erret));} /* pgpasn_PackRSAPrivateKey */size_t pgpasn_UnpackRSAPrivateKey(    PGPASN_CONTEXT *ctx,    PGPASN_RSAPrivateKey **asnstruct,    const unsigned char *buf,    size_t buflen,    int *erret){    size_t bytesused;    bytesused=pgpasn_UnpackRSAPrivateKeyInternal(ctx, asnstruct, buf, buflen,                      PGPASN_ID_RSAPrivateKey, erret);    if(*erret==0 && bytesused==0)        PGPASN_ERR(kPGPASNError_ErrUnpackUnderrun);    return bytesused;}/****************************************************************** * Routines for XIssuerAndSerialNumber ******************************************************************/PGPASN_XIssuerAndSerialNumber *pgpasn_NewXIssuerAndSerialNumber(    PGPASN_CONTEXT *ctx){    PGPASN_XIssuerAndSerialNumber *f;    if (ctx == NULL)        return NULL;    f = (PGPASN_XIssuerAndSerialNumber *)PGPASN_Alloc(ctx->memMgr, sizeof(PGPASN_XIssuerAndSerialNumber));    if (f != NULL)        (void)memset(f, 0, sizeof(PGPASN_XIssuerAndSerialNumber));    return (f);} /* pgpasn_NewXIssuerAndSerialNumber */void pgpasn_FreeXIssuerAndSerialNumber(    PGPASN_CONTEXT *ctx,    PGPASN_XIssuerAndSerialNumber *f){    if (ctx == NULL)        return;    pgpasn_DropInPlaceXIssuerAndSerialNumber(ctx, f);    if (f != NULL)        PGPASN_Free(ctx->memMgr, f);} /* pgpasn_FreeXIssuerAndSerialNumber */size_t pgpasn_SizeofXIssuerAndSerialNumber(    PGPASN_CONTEXT *ctx,    PGPASN_XIssuerAndSerialNumber *asnstruct,    int outerSizeFlag){    (void)ctx; /* for future use */    return(pgpasn_SizeofXIssuerAndSerialNumberInternal(asnstruct, outerSizeFlag, PGPASN_FALSE));} /* pgpasn_SizeofXIssuerAndSerialNumber */size_t pgpasn_PackXIssuerAndSerialNumber(    PGPASN_CONTEXT *ctx,    unsigned char *buf,    size_t buflen,    PGPASN_XIssuerAndSerialNumber *asnstruct,    int *erret ){    return(pgpasn_PackXIssuerAndSerialNumberInternal(ctx, buf, buflen, asnstruct, PGPASN_ID_XIssuerAndSerialNumber, erret));} /* pgpasn_PackXIssuerAndSerialNumber */size_t pgpasn_UnpackXIssuerAndSerialNumber(    PGPASN_CONTEXT *ctx,    PGPASN_XIssuerAndSerialNumber **asnstruct,    const unsigned char *buf,    size_t buflen,    int *erret){    size_t bytesused;    bytesused=pgpasn_UnpackXIssuerAndSerialNumberInternal(ctx, asnstruct, buf, buflen,                      PGPASN_ID_XIssuerAndSerialNumber, erret);    if(*erret==0 && bytesused==0)        PGPASN_ERR(kPGPASNError_ErrUnpackUnderrun);    return bytesused;}/****************************************************************** * Routines for XXCertificate ******************************************************************/PGPASN_XXCertificate *pgpasn_NewXXCertificate(    PGPASN_CONTEXT *ctx){    PGPASN_XXCertificate *f;    if (ctx == NULL)        return NULL;    f = (PGPASN_XXCertificate *)PGPASN_Alloc(ctx->memMgr, sizeof(PGPASN_XXCertificate));    if (f != NULL)        (void)memset(f, 0, sizeof(PGPASN_XXCertificate));    return (f);} /* pgpasn_NewXXCertificate */void pgpasn_FreeXXCertificate(    PGPASN_CONTEXT *ctx,    PGPASN_XXCertificate *f){    if (ctx == NULL)        return;    pgpasn_DropInPlaceXXCertificate(ctx, f);    if (f != NULL)        PGPASN_Free(ctx->memMgr, f);} /* pgpasn_FreeXXCertificate */size_t pgpasn_SizeofXXCertificate(    PGPASN_CONTEXT *ctx,    PGPASN_XXCertificate *asnstruct,    int outerSizeFlag){    (void)ctx; /* for future use */    return(pgpasn_SizeofXXCertificateInternal(asnstruct, outerSizeFlag, PGPASN_FALSE));} /* pgpasn_SizeofXXCertificate */size_t pgpasn_PackXXCertificate(    PGPASN_CONTEXT *ctx,    unsigned char *buf,    size_t buflen,    PGPASN_XXCertificate *asnstruct,    int *erret ){    return(pgpasn_PackXXCertificateInternal(ctx, buf, buflen, asnstruct, PGPASN_ID_XXCertificate, erret));} /* pgpasn_PackXXCertificate */size_t pgpasn_UnpackXXCertificate(    PGPASN_CONTEXT *ctx,    PGPASN_XXCertificate **asnstruct,    const unsigned char *buf,    size_t buflen,    int *erret){    size_t bytesused;    bytesused=pgpasn_UnpackXXCertificateInternal(ctx, asnstruct, buf, buflen,                      PGPASN_ID_XXCertificate, erret);    if(*erret==0 && bytesused==0)        PGPASN_ERR(kPGPASNError_ErrUnpackUnderrun);    return bytesused;}/****************************************************************** * Routines for Attribute ******************************************************************/PGPASN_Attribute *pgpasn_NewAttribute(    PGPASN_CONTEXT *ctx){    PGPASN_Attribute *f;    if (ctx == NULL)        return NULL;    f = (PGPASN_Attribute *)PGPASN_Alloc(ctx->memMgr, sizeof(PGPASN_Attribute));    if (f != NULL)        (void)memset(f, 0, sizeof(PGPASN_Attribute));    return (f);} /* pgpasn_NewAttribute */void pgpasn_FreeAttribute(    PGPASN_CONTEXT *ctx,    PGPASN_Attribute *f){    if (ctx == NULL)        return;    pgpasn_DropInPlaceAttribute(ctx, f);    if (f != NULL)        PGPASN_Free(ctx->memMgr, f);} /* pgpasn_FreeAttribute */size_t pgpasn_SizeofAttribute(    PGPASN_CONTEXT *ctx,    PGPASN_Attribute *asnstruct,    int outerSizeFlag){    (void)ctx; /* for future use */    return(pgpasn_SizeofAttributeInternal(asnstruct, outerSizeFlag, PGPASN_FALSE));} /* pgpasn_SizeofAttribute */size_t pgpasn_PackAttribute(    PGPASN_CONTEXT *ctx,    unsigned char *buf,    size_t buflen,    PGPASN_Attribute *asnstruct,    int *erret ){    return(pgpasn_PackAttributeInternal(ctx, buf, buflen, asnstruct, PGPASN_ID_Attribute, erret));} /* pgpasn_PackAttribute */size_t pgpasn_UnpackAttribute(    PGPASN_CONTEXT *ctx,    PGPASN_Attribute **asnstruct,    const unsigned char *buf,    size_t buflen,    int *erret){    size_t bytesused;    bytesused=pgpasn_UnpackAttributeInternal(ctx, asnstruct, buf, buflen,                      PGPASN_ID_Attribute, erret);    if(*erret==0 && bytesused==0)        PGPASN_ERR(kPGPASNError_ErrUnpackUnderrun);    return bytesused;}/****************************************************************** * Routines for Extensions ******************************************************************/PGPASN_Extensions *pgpasn_NewExtensions(    PGPASN_CONTEXT *ctx){    PGPASN_Extensions *f;    if (ctx == NULL)        return NULL;    f = (PGPASN_Extensions *)PGPASN_Alloc(ctx->memMgr, sizeof(PGPASN_Extensions));    if (f != NULL)        (void)memset(f, 0, sizeof(PGPASN_Extensions));    return (f);} /* pgpasn_NewExtensions */void pgpasn_FreeExtensions(    PGPASN_CONTEXT *ctx,    PGPASN_Extensions *f){    if (ctx == NULL)        return;    pgpasn_DropInPlaceExtensions(ctx, f);    if (f != NULL)        PGPASN_Free(ctx->memMgr, f);} /* pgpasn_FreeExtensions */size_t pgpasn_SizeofExtensions(    PGPASN_CONTEXT *ctx,    PGPASN_Extensions *asnstruct,    int outerSizeFlag){    (void)ctx; /* for future use */    return(pgpasn_SizeofExtensionsInternal(asnstruct, outerSizeFlag, PGPASN_FALSE));} /* pgpasn_SizeofExtensions */size_t pgpasn_PackExtensions(    PGPASN_CONTEXT *ctx,    unsigned char *buf,    size_t buflen,    PGPASN_Extensions *asnstruct,    int *erret ){    return(pgpasn_PackExtensionsInternal(ctx, buf, buflen, asnstruct, PGPASN_ID_Extensions, erret));} /* pgpasn_PackExtensions */size_t pgpasn_UnpackExtensions(    PGPASN_CONTEXT *ctx,    PGPASN_Extensions **asnstruct,    const unsigned char *buf,    size_t buflen,    int *erret){    size_t bytesused;    bytesused=pgpasn_UnpackExtensionsInternal(ctx, asnstruct, buf, buflen,                      PGPASN_ID_Extensions, erret);    if(*erret==0 && bytesused==0)        PGPASN_ERR(kPGPASNError_ErrUnpackUnderrun);    return bytesused;}/****************************************************************** * Routines for RelativeDistinguishedName ******************************************************************/PGPASN_RelativeDistinguishedName *pgpasn_NewRelativeDistinguishedName(    PGPASN_CONTEXT *ctx){    PGPASN_RelativeDistinguishedName *f;    if (ctx == NULL)        return NULL;    f = (PGPASN_RelativeDistinguishedName *)PGPASN_Alloc(ctx->memMgr, sizeof(PGPASN_RelativeDistinguishedName));    if (f != NULL)        (void)memset(f, 0, sizeof(PGPASN_RelativeDistinguishedName));    return (f);} /* pgpasn_NewRelativeDistinguishedName */void pgpasn_FreeRelativeDistinguishedName(    PGPASN_CONTEXT *ctx,    PGPASN_RelativeDistinguishedName *f){    if (ctx == NULL)        return;    pgpasn_DropInPlaceRelativeDistinguishedName(ctx, f);    if (f != NULL)        PGPASN_Free(ctx->memMgr, f);} /* pgpasn_FreeRelativeDistinguishedName */size_t pgpasn_SizeofRelativeDistinguishedName(    PGPASN_CONTEXT *ctx,    PGPASN_RelativeDistinguishedName *asnstruct,    int outerSizeFlag){    (void)ctx; /* for future use */    return(pgpasn_SizeofRelativeDistinguishedNameInternal(asnstruct, outerSizeFlag, PGPASN_FALSE));} /* pgpasn_SizeofRelativeDistinguishedName */size_t pgpasn_PackRelativeDistinguishedName(    PGPASN_CONTEXT *ctx,    unsigned char *buf,    size_t buflen,    PGPASN_RelativeDistinguishedName *asnstruct,    int *erret ){    return(pgpasn_PackRelativeDistinguishedNameInternal(ctx, buf, buflen, asnstruct, PGPASN_ID_RelativeDistinguishedName, erret));} /* pgpasn_PackRelativeDistinguishedName */size_t pgpasn_UnpackRelativeDistinguishedName(    PGPASN_CONTEXT *ctx,    PGPASN_RelativeDistinguishedName **asnstruct,    const unsigned char *buf,    size_t buflen,    int *erret){    size_t bytesused;    bytesused=pgpasn_UnpackRelativeDistinguishedNameInternal(ctx, asnstruct, buf, buflen,                      PGPASN_ID_RelativeDistinguishedName, erret);    if(*erret==0 && bytesused==0)        PGPASN_ERR(kPGPASNError_ErrUnpackUnderrun);    return bytesused;}/****************************************************************** * Routines for SubjectPublicKeyInfo ******************************************************************/PGPASN_SubjectPublicKeyInfo *pgpasn_NewSubjectPublicKeyInfo(    PGPASN_CONTEXT *ctx){    PGPASN_SubjectPublicKeyInfo *f;    if (ctx == NULL)        return NULL;    f = (PGPASN_SubjectPublicKeyInfo *)PGPASN_Alloc(ctx->memMgr, sizeof(PGPASN_SubjectPublicKeyInfo));    if (f != NULL)        (void)memset(f, 0, sizeof(PGPASN_SubjectPublicKeyInfo));    return (f);} /* pgpasn_NewSubjectPublicKeyInfo */void pgpasn_FreeSubjectPublicKeyInfo(    PGPASN_CONTEXT *ctx,    PGPASN_SubjectPublicKeyInfo *f){    if (ctx == NULL)        return;    pgpasn_DropInPlaceSubjectPublicKeyInfo(ctx, f);    if (f != NULL)        PGPASN_Free(ctx->memMgr, f);} /* pgpasn_FreeSubjectPublicKeyInfo */size_t pgpasn_SizeofSubjectPublicKeyInfo(    PGPASN_CONTEXT *ctx,    PGPASN_SubjectPublicKeyInfo *asnstruct,    int outerSizeFlag){    (void)ctx; /* for future use */    return(pgpasn_SizeofSubjectPublicKeyInfoInternal(asnstruct, outerSizeFlag, PGPASN_FALSE));} /* pgpasn_SizeofSubjectPublicKeyInfo */size_t pgpasn_PackSubjectPublicKeyInfo(    PGPASN_CONTEXT *ctx,    unsigned char *buf,    size_t buflen,    PGPASN_SubjectPublicKeyInfo *asnstruct,    int *erret ){    return(pgpasn_PackSubjectPublicKeyInfoInternal(ctx, buf, buflen, asnstruct, PGPASN_ID_SubjectPublicKeyInfo, erret));} /* pgpasn_PackSubjectPublicKeyInfo */size_t pgpasn_UnpackSubjectPublicKeyInfo(    PGPASN_CONTEXT *ctx,    PGPASN_SubjectPublicKeyInfo **asnstruct,    const unsigned char *buf,    size_t buflen,    int *erret){    size_t bytesused;    bytesused=pgpasn_UnpackSubjectPublicKeyInfoInternal(ctx, asnstruct, buf, buflen,                      PGPASN_ID_SubjectPublicKeyInfo, erret);    if(*erret==0 && bytesused==0)        PGPASN_ERR(kPGPASNError_ErrUnpackUnderrun);    return bytesused;}/****************************************************************** * Routines for Validity ******************************************************************/PGPASN_Validity *pgpasn_NewValidity(    PGPASN_CONTEXT *ctx){    PGPASN_Validity *f;    if (ctx == NULL)        return NULL;    f = (PGPASN_Validity *)PGPASN_Alloc(ctx->memMgr, sizeof(PGPASN_Validity));    if (f != NULL)        (void)memset(f, 0, sizeof(PGPASN_Validity));    return (f);} /* pgpasn_NewValidity */void pgpasn_FreeValidity(    PGPASN_CONTEXT *ctx,    PGPASN_Validity *f){    if (ctx == NULL)        return;    pgpasn_DropInPlaceValidity(ctx, f);    if (f != NULL)        PGPASN_Free(ctx->memMgr, f);} /* pgpasn_FreeValidity */size_t pgpasn_SizeofValidity(    PGPASN_CONTEXT *ctx,    PGPASN_Validity *asnstruct,    int outerSizeFlag){    (void)ctx; /* for future use */    return(pgpasn_SizeofValidityInternal(asnstruct, outerSizeFlag, PGPASN_FALSE));} /* pgpasn_SizeofValidity */size_t pgpasn_PackValidity(    PGPASN_CONTEXT *ctx,    unsigned char *buf,    size_t buflen,    PGPASN_Validity *asnstruct,    int *erret ){    return(pgpasn_PackValidityInternal(ctx, buf, buflen, asnstruct, PGPASN_ID_Validity, erret));} /* pgpasn_PackValidity */size_t pgpasn_UnpackValidity(    PGPASN_CONTEXT *ctx,    PGPASN_Validity **asnstruct,    const unsigned char *buf,    size_t buflen,    int *erret){    size_t bytesused;    bytesused=pgpasn_UnpackValidityInternal(ctx, asnstruct, buf, buflen,                      PGPASN_ID_Validity, erret);    if(*erret==0 && bytesused==0)        PGPASN_ERR(kPGPASNError_ErrUnpackUnderrun);    return bytesused;}/****************************************************************** * Routines for XCertificate ******************************************************************/PGPASN_XCertificate *pgpasn_NewXCertificate(    PGPASN_CONTEXT *ctx){    PGPASN_XCertificate *f;    if (ctx == NULL)        return NULL;    f = (PGPASN_XCertificate *)PGPASN_Alloc(ctx->memMgr, sizeof(PGPASN_XCertificate));    if (f != NULL)        (void)memset(f, 0, sizeof(PGPASN_XCertificate));    return (f);} /* pgpasn_NewXCertificate */void pgpasn_FreeXCertificate(    PGPASN_CONTEXT *ctx,    PGPASN_XCertificate *f){    if (ctx == NULL)        return;    pgpasn_DropInPlaceXCertificate(ctx, f);    if (f != NULL)        PGPASN_Free(ctx->memMgr, f);} /* pgpasn_FreeXCertificate */size_t pgpasn_SizeofXCertificate(    PGPASN_CONTEXT *ctx,    PGPASN_XCertificate *asnstruct,    int outerSizeFlag){    (void)ctx; /* for future use */    return(pgpasn_SizeofXCertificateInternal(asnstruct, outerSizeFlag, PGPASN_FALSE));} /* pgpasn_SizeofXCertificate */size_t pgpasn_PackXCertificate(    PGPASN_CONTEXT *ctx,    unsigned char *buf,    size_t buflen,    PGPASN_XCertificate *asnstruct,    int *erret ){    return(pgpasn_PackXCertificateInternal(ctx, buf, buflen, asnstruct, PGPASN_ID_XCertificate, erret));} /* pgpasn_PackXCertificate */size_t pgpasn_UnpackXCertificate(    PGPASN_CONTEXT *ctx,    PGPASN_XCertificate **asnstruct,    const unsigned char *buf,    size_t buflen,    int *erret){    size_t bytesused;    bytesused=pgpasn_UnpackXCertificateInternal(ctx, asnstruct, buf, buflen,                      PGPASN_ID_XCertificate, erret);    if(*erret==0 && bytesused==0)        PGPASN_ERR(kPGPASNError_ErrUnpackUnderrun);    return bytesused;}/****************************************************************** * Routines for Attributes ******************************************************************/PGPASN_Attributes *pgpasn_NewAttributes(    PGPASN_CONTEXT *ctx){    PGPASN_Attributes *f;    if (ctx == NULL)        return NULL;    f = (PGPASN_Attributes *)PGPASN_Alloc(ctx->memMgr, sizeof(PGPASN_Attributes));    if (f != NULL)        (void)memset(f, 0, sizeof(PGPASN_Attributes));    return (f);} /* pgpasn_NewAttributes */void pgpasn_FreeAttributes(    PGPASN_CONTEXT *ctx,    PGPASN_Attributes *f){    if (ctx == NULL)        return;    pgpasn_DropInPlaceAttributes(ctx, f);    if (f != NULL)        PGPASN_Free(ctx->memMgr, f);} /* pgpasn_FreeAttributes */size_t pgpasn_SizeofAttributes(    PGPASN_CONTEXT *ctx,    PGPASN_Attributes *asnstruct,    int outerSizeFlag){    (void)ctx; /* for future use */    return(pgpasn_SizeofAttributesInternal(asnstruct, outerSizeFlag, PGPASN_FALSE));} /* pgpasn_SizeofAttributes */size_t pgpasn_PackAttributes(    PGPASN_CONTEXT *ctx,    unsigned char *buf,    size_t buflen,    PGPASN_Attributes *asnstruct,    int *erret ){    return(pgpasn_PackAttributesInternal(ctx, buf, buflen, asnstruct, PGPASN_ID_Attributes, erret));} /* pgpasn_PackAttributes */size_t pgpasn_UnpackAttributes(    PGPASN_CONTEXT *ctx,    PGPASN_Attributes **asnstruct,    const unsigned char *buf,    size_t buflen,    int *erret){    size_t bytesused;    bytesused=pgpasn_UnpackAttributesInternal(ctx, asnstruct, buf, buflen,                      PGPASN_ID_Attributes, erret);    if(*erret==0 && bytesused==0)        PGPASN_ERR(kPGPASNError_ErrUnpackUnderrun);    return bytesused;}/****************************************************************** * Routines for DigestAlgorithmIdentifiers ******************************************************************/PGPASN_DigestAlgorithmIdentifiers *pgpasn_NewDigestAlgorithmIdentifiers(    PGPASN_CONTEXT *ctx){    PGPASN_DigestAlgorithmIdentifiers *f;    if (ctx == NULL)        return NULL;    f = (PGPASN_DigestAlgorithmIdentifiers *)PGPASN_Alloc(ctx->memMgr, sizeof(PGPASN_DigestAlgorithmIdentifiers));    if (f != NULL)        (void)memset(f, 0, sizeof(PGPASN_DigestAlgorithmIdentifiers));    return (f);} /* pgpasn_NewDigestAlgorithmIdentifiers */void pgpasn_FreeDigestAlgorithmIdentifiers(    PGPASN_CONTEXT *ctx,    PGPASN_DigestAlgorithmIdentifiers *f){    if (ctx == NULL)        return;    pgpasn_DropInPlaceDigestAlgorithmIdentifiers(ctx, f);    if (f != NULL)        PGPASN_Free(ctx->memMgr, f);} /* pgpasn_FreeDigestAlgorithmIdentifiers */size_t pgpasn_SizeofDigestAlgorithmIdentifiers(    PGPASN_CONTEXT *ctx,    PGPASN_DigestAlgorithmIdentifiers *asnstruct,    int outerSizeFlag){    (void)ctx; /* for future use */    return(pgpasn_SizeofDigestAlgorithmIdentifiersInternal(asnstruct, outerSizeFlag, PGPASN_FALSE));} /* pgpasn_SizeofDigestAlgorithmIdentifiers */size_t pgpasn_PackDigestAlgorithmIdentifiers(    PGPASN_CONTEXT *ctx,    unsigned char *buf,    size_t buflen,    PGPASN_DigestAlgorithmIdentifiers *asnstruct,    int *erret ){    return(pgpasn_PackDigestAlgorithmIdentifiersInternal(ctx, buf, buflen, asnstruct, PGPASN_ID_DigestAlgorithmIdentifiers, erret));} /* pgpasn_PackDigestAlgorithmIdentifiers */size_t pgpasn_UnpackDigestAlgorithmIdentifiers(    PGPASN_CONTEXT *ctx,    PGPASN_DigestAlgorithmIdentifiers **asnstruct,    const unsigned char *buf,    size_t buflen,    int *erret){    size_t bytesused;    bytesused=pgpasn_UnpackDigestAlgorithmIdentifiersInternal(ctx, asnstruct, buf, buflen,                      PGPASN_ID_DigestAlgorithmIdentifiers, erret);    if(*erret==0 && bytesused==0)        PGPASN_ERR(kPGPASNError_ErrUnpackUnderrun);    return bytesused;}/****************************************************************** * Routines for PGPExtension ******************************************************************/PGPASN_PGPExtension *pgpasn_NewPGPExtension(    PGPASN_CONTEXT *ctx){    PGPASN_PGPExtension *f;    if (ctx == NULL)        return NULL;    f = (PGPASN_PGPExtension *)PGPASN_Alloc(ctx->memMgr, sizeof(PGPASN_PGPExtension));    if (f != NULL)        (void)memset(f, 0, sizeof(PGPASN_PGPExtension));    return (f);} /* pgpasn_NewPGPExtension */void pgpasn_FreePGPExtension(    PGPASN_CONTEXT *ctx,    PGPASN_PGPExtension *f){    if (ctx == NULL)        return;    pgpasn_DropInPlacePGPExtension(ctx, f);    if (f != NULL)        PGPASN_Free(ctx->memMgr, f);} /* pgpasn_FreePGPExtension */size_t pgpasn_SizeofPGPExtension(    PGPASN_CONTEXT *ctx,    PGPASN_PGPExtension *asnstruct,    int outerSizeFlag){    (void)ctx; /* for future use */    return(pgpasn_SizeofPGPExtensionInternal(asnstruct, outerSizeFlag, PGPASN_FALSE));} /* pgpasn_SizeofPGPExtension */size_t pgpasn_PackPGPExtension(    PGPASN_CONTEXT *ctx,    unsigned char *buf,    size_t buflen,    PGPASN_PGPExtension *asnstruct,    int *erret ){    return(pgpasn_PackPGPExtensionInternal(ctx, buf, buflen, asnstruct, PGPASN_ID_PGPExtension, erret));} /* pgpasn_PackPGPExtension */size_t pgpasn_UnpackPGPExtension(    PGPASN_CONTEXT *ctx,    PGPASN_PGPExtension **asnstruct,    const unsigned char *buf,    size_t buflen,    int *erret){    size_t bytesused;    bytesused=pgpasn_UnpackPGPExtensionInternal(ctx, asnstruct, buf, buflen,                      PGPASN_ID_PGPExtension, erret);    if(*erret==0 && bytesused==0)        PGPASN_ERR(kPGPASNError_ErrUnpackUnderrun);    return bytesused;}/****************************************************************** * Routines for RDNSequence ******************************************************************/PGPASN_RDNSequence *pgpasn_NewRDNSequence(    PGPASN_CONTEXT *ctx){    PGPASN_RDNSequence *f;    if (ctx == NULL)        return NULL;    f = (PGPASN_RDNSequence *)PGPASN_Alloc(ctx->memMgr, sizeof(PGPASN_RDNSequence));    if (f != NULL)        (void)memset(f, 0, sizeof(PGPASN_RDNSequence));    return (f);} /* pgpasn_NewRDNSequence */void pgpasn_FreeRDNSequence(    PGPASN_CONTEXT *ctx,    PGPASN_RDNSequence *f){    if (ctx == NULL)        return;    pgpasn_DropInPlaceRDNSequence(ctx, f);    if (f != NULL)        PGPASN_Free(ctx->memMgr, f);} /* pgpasn_FreeRDNSequence */size_t pgpasn_SizeofRDNSequence(    PGPASN_CONTEXT *ctx,    PGPASN_RDNSequence *asnstruct,    int outerSizeFlag){    (void)ctx; /* for future use */    return(pgpasn_SizeofRDNSequenceInternal(asnstruct, outerSizeFlag, PGPASN_FALSE));} /* pgpasn_SizeofRDNSequence */size_t pgpasn_PackRDNSequence(    PGPASN_CONTEXT *ctx,    unsigned char *buf,    size_t buflen,    PGPASN_RDNSequence *asnstruct,    int *erret ){    return(pgpasn_PackRDNSequenceInternal(ctx, buf, buflen, asnstruct, PGPASN_ID_RDNSequence, erret));} /* pgpasn_PackRDNSequence */size_t pgpasn_UnpackRDNSequence(    PGPASN_CONTEXT *ctx,    PGPASN_RDNSequence **asnstruct,    const unsigned char *buf,    size_t buflen,    int *erret){    size_t bytesused;    bytesused=pgpasn_UnpackRDNSequenceInternal(ctx, asnstruct, buf, buflen,                      PGPASN_ID_RDNSequence, erret);    if(*erret==0 && bytesused==0)        PGPASN_ERR(kPGPASNError_ErrUnpackUnderrun);    return bytesused;}/****************************************************************** * Routines for RevokedCertificate ******************************************************************/PGPASN_RevokedCertificate *pgpasn_NewRevokedCertificate(    PGPASN_CONTEXT *ctx){    PGPASN_RevokedCertificate *f;    if (ctx == NULL)        return NULL;    f = (PGPASN_RevokedCertificate *)PGPASN_Alloc(ctx->memMgr, sizeof(PGPASN_RevokedCertificate));    if (f != NULL)        (void)memset(f, 0, sizeof(PGPASN_RevokedCertificate));    return (f);} /* pgpasn_NewRevokedCertificate */void pgpasn_FreeRevokedCertificate(    PGPASN_CONTEXT *ctx,    PGPASN_RevokedCertificate *f){    if (ctx == NULL)        return;    pgpasn_DropInPlaceRevokedCertificate(ctx, f);    if (f != NULL)        PGPASN_Free(ctx->memMgr, f);} /* pgpasn_FreeRevokedCertificate */size_t pgpasn_SizeofRevokedCertificate(    PGPASN_CONTEXT *ctx,    PGPASN_RevokedCertificate *asnstruct,    int outerSizeFlag){    (void)ctx; /* for future use */    return(pgpasn_SizeofRevokedCertificateInternal(asnstruct, outerSizeFlag, PGPASN_FALSE));} /* pgpasn_SizeofRevokedCertificate */size_t pgpasn_PackRevokedCertificate(    PGPASN_CONTEXT *ctx,    unsigned char *buf,    size_t buflen,    PGPASN_RevokedCertificate *asnstruct,    int *erret ){    return(pgpasn_PackRevokedCertificateInternal(ctx, buf, buflen, asnstruct, PGPASN_ID_RevokedCertificate, erret));} /* pgpasn_PackRevokedCertificate */size_t pgpasn_UnpackRevokedCertificate(    PGPASN_CONTEXT *ctx,    PGPASN_RevokedCertificate **asnstruct,    const unsigned char *buf,    size_t buflen,    int *erret){    size_t bytesused;    bytesused=pgpasn_UnpackRevokedCertificateInternal(ctx, asnstruct, buf, buflen,                      PGPASN_ID_RevokedCertificate, erret);    if(*erret==0 && bytesused==0)        PGPASN_ERR(kPGPASNError_ErrUnpackUnderrun);    return bytesused;}/****************************************************************** * Routines for XTBSCertificate ******************************************************************/PGPASN_XTBSCertificate *pgpasn_NewXTBSCertificate(    PGPASN_CONTEXT *ctx){    PGPASN_XTBSCertificate *f;    if (ctx == NULL)        return NULL;    f = (PGPASN_XTBSCertificate *)PGPASN_Alloc(ctx->memMgr, sizeof(PGPASN_XTBSCertificate));    if (f != NULL)        (void)memset(f, 0, sizeof(PGPASN_XTBSCertificate));    return (f);} /* pgpasn_NewXTBSCertificate */void pgpasn_FreeXTBSCertificate(    PGPASN_CONTEXT *ctx,    PGPASN_XTBSCertificate *f){    if (ctx == NULL)        return;    pgpasn_DropInPlaceXTBSCertificate(ctx, f);    if (f != NULL)        PGPASN_Free(ctx->memMgr, f);} /* pgpasn_FreeXTBSCertificate */size_t pgpasn_SizeofXTBSCertificate(    PGPASN_CONTEXT *ctx,    PGPASN_XTBSCertificate *asnstruct,    int outerSizeFlag){    (void)ctx; /* for future use */    return(pgpasn_SizeofXTBSCertificateInternal(asnstruct, outerSizeFlag, PGPASN_FALSE));} /* pgpasn_SizeofXTBSCertificate */size_t pgpasn_PackXTBSCertificate(    PGPASN_CONTEXT *ctx,    unsigned char *buf,    size_t buflen,    PGPASN_XTBSCertificate *asnstruct,    int *erret ){    return(pgpasn_PackXTBSCertificateInternal(ctx, buf, buflen, asnstruct, PGPASN_ID_XTBSCertificate, erret));} /* pgpasn_PackXTBSCertificate */size_t pgpasn_UnpackXTBSCertificate(    PGPASN_CONTEXT *ctx,    PGPASN_XTBSCertificate **asnstruct,    const unsigned char *buf,    size_t buflen,    int *erret){    size_t bytesused;    bytesused=pgpasn_UnpackXTBSCertificateInternal(ctx, asnstruct, buf, buflen,                      PGPASN_ID_XTBSCertificate, erret);    if(*erret==0 && bytesused==0)        PGPASN_ERR(kPGPASNError_ErrUnpackUnderrun);    return bytesused;}/****************************************************************** * Routines for Name ******************************************************************/PGPASN_Name *pgpasn_NewName(    PGPASN_CONTEXT *ctx){    PGPASN_Name *f;    if (ctx == NULL)        return NULL;    f = (PGPASN_Name *)PGPASN_Alloc(ctx->memMgr, sizeof(PGPASN_Name));    if (f != NULL)        (void)memset(f, 0, sizeof(PGPASN_Name));    return (f);} /* pgpasn_NewName */void pgpasn_FreeName(    PGPASN_CONTEXT *ctx,    PGPASN_Name *f){    if (ctx == NULL)        return;    pgpasn_DropInPlaceName(ctx, f);    if (f != NULL)        PGPASN_Free(ctx->memMgr, f);} /* pgpasn_FreeName */size_t pgpasn_SizeofName(    PGPASN_CONTEXT *ctx,    PGPASN_Name *asnstruct,    int outerSizeFlag){    (void)ctx; /* for future use */    return(pgpasn_SizeofNameInternal(asnstruct, outerSizeFlag, PGPASN_FALSE));} /* pgpasn_SizeofName */size_t pgpasn_PackName(    PGPASN_CONTEXT *ctx,    unsigned char *buf,    size_t buflen,    PGPASN_Name *asnstruct,    int *erret ){    return(pgpasn_PackNameInternal(ctx, buf, buflen, asnstruct, PGPASN_ID_Name, erret));} /* pgpasn_PackName */size_t pgpasn_UnpackName(    PGPASN_CONTEXT *ctx,    PGPASN_Name **asnstruct,    const unsigned char *buf,    size_t buflen,    int *erret){    size_t bytesused;    bytesused=pgpasn_UnpackNameInternal(ctx, asnstruct, buf, buflen,                      PGPASN_ID_Name, erret);    if(*erret==0 && bytesused==0)        PGPASN_ERR(kPGPASNError_ErrUnpackUnderrun);    return bytesused;}/****************************************************************** * Routines for PrivateKeyInfo ******************************************************************/PGPASN_PrivateKeyInfo *pgpasn_NewPrivateKeyInfo(    PGPASN_CONTEXT *ctx){    PGPASN_PrivateKeyInfo *f;    if (ctx == NULL)        return NULL;    f = (PGPASN_PrivateKeyInfo *)PGPASN_Alloc(ctx->memMgr, sizeof(PGPASN_PrivateKeyInfo));    if (f != NULL)        (void)memset(f, 0, sizeof(PGPASN_PrivateKeyInfo));    return (f);} /* pgpasn_NewPrivateKeyInfo */void pgpasn_FreePrivateKeyInfo(    PGPASN_CONTEXT *ctx,    PGPASN_PrivateKeyInfo *f){    if (ctx == NULL)        return;    pgpasn_DropInPlacePrivateKeyInfo(ctx, f);    if (f != NULL)        PGPASN_Free(ctx->memMgr, f);} /* pgpasn_FreePrivateKeyInfo */size_t pgpasn_SizeofPrivateKeyInfo(    PGPASN_CONTEXT *ctx,    PGPASN_PrivateKeyInfo *asnstruct,    int outerSizeFlag){    (void)ctx; /* for future use */    return(pgpasn_SizeofPrivateKeyInfoInternal(asnstruct, outerSizeFlag, PGPASN_FALSE));} /* pgpasn_SizeofPrivateKeyInfo */size_t pgpasn_PackPrivateKeyInfo(    PGPASN_CONTEXT *ctx,    unsigned char *buf,    size_t buflen,    PGPASN_PrivateKeyInfo *asnstruct,    int *erret ){    return(pgpasn_PackPrivateKeyInfoInternal(ctx, buf, buflen, asnstruct, PGPASN_ID_PrivateKeyInfo, erret));} /* pgpasn_PackPrivateKeyInfo */size_t pgpasn_UnpackPrivateKeyInfo(    PGPASN_CONTEXT *ctx,    PGPASN_PrivateKeyInfo **asnstruct,    const unsigned char *buf,    size_t buflen,    int *erret){    size_t bytesused;    bytesused=pgpasn_UnpackPrivateKeyInfoInternal(ctx, asnstruct, buf, buflen,                      PGPASN_ID_PrivateKeyInfo, erret);    if(*erret==0 && bytesused==0)        PGPASN_ERR(kPGPASNError_ErrUnpackUnderrun);    return bytesused;}/****************************************************************** * Routines for revokedCertificates_SEQ_OF ******************************************************************/PGPASN_revokedCertificates_SEQ_OF *pgpasn_NewrevokedCertificates_SEQ_OF(    PGPASN_CONTEXT *ctx){    PGPASN_revokedCertificates_SEQ_OF *f;    if (ctx == NULL)        return NULL;    f = (PGPASN_revokedCertificates_SEQ_OF *)PGPASN_Alloc(ctx->memMgr, sizeof(PGPASN_revokedCertificates_SEQ_OF));    if (f != NULL)        (void)memset(f, 0, sizeof(PGPASN_revokedCertificates_SEQ_OF));    return (f);} /* pgpasn_NewrevokedCertificates_SEQ_OF */void pgpasn_FreerevokedCertificates_SEQ_OF(    PGPASN_CONTEXT *ctx,    PGPASN_revokedCertificates_SEQ_OF *f){    if (ctx == NULL)        return;    pgpasn_DropInPlacerevokedCertificates_SEQ_OF(ctx, f);    if (f != NULL)        PGPASN_Free(ctx->memMgr, f);} /* pgpasn_FreerevokedCertificates_SEQ_OF */size_t pgpasn_SizeofrevokedCertificates_SEQ_OF(    PGPASN_CONTEXT *ctx,    PGPASN_revokedCertificates_SEQ_OF *asnstruct,    int outerSizeFlag){    (void)ctx; /* for future use */    return(pgpasn_SizeofrevokedCertificates_SEQ_OFInternal(asnstruct, outerSizeFlag, PGPASN_FALSE));} /* pgpasn_SizeofrevokedCertificates_SEQ_OF */size_t pgpasn_PackrevokedCertificates_SEQ_OF(    PGPASN_CONTEXT *ctx,    unsigned char *buf,    size_t buflen,    PGPASN_revokedCertificates_SEQ_OF *asnstruct,    int *erret ){    return(pgpasn_PackrevokedCertificates_SEQ_OFInternal(ctx, buf, buflen, asnstruct, PGPASN_ID_revokedCertificates_SEQ_OF, erret));} /* pgpasn_PackrevokedCertificates_SEQ_OF */size_t pgpasn_UnpackrevokedCertificates_SEQ_OF(    PGPASN_CONTEXT *ctx,    PGPASN_revokedCertificates_SEQ_OF **asnstruct,    const unsigned char *buf,    size_t buflen,    int *erret){    size_t bytesused;    bytesused=pgpasn_UnpackrevokedCertificates_SEQ_OFInternal(ctx, asnstruct, buf, buflen,                      PGPASN_ID_revokedCertificates_SEQ_OF, erret);    if(*erret==0 && bytesused==0)        PGPASN_ERR(kPGPASNError_ErrUnpackUnderrun);    return bytesused;}/****************************************************************** * Routines for CertificationRequestInfo ******************************************************************/PGPASN_CertificationRequestInfo *pgpasn_NewCertificationRequestInfo(    PGPASN_CONTEXT *ctx){    PGPASN_CertificationRequestInfo *f;    if (ctx == NULL)        return NULL;    f = (PGPASN_CertificationRequestInfo *)PGPASN_Alloc(ctx->memMgr, sizeof(PGPASN_CertificationRequestInfo));    if (f != NULL)        (void)memset(f, 0, sizeof(PGPASN_CertificationRequestInfo));    return (f);} /* pgpasn_NewCertificationRequestInfo */void pgpasn_FreeCertificationRequestInfo(    PGPASN_CONTEXT *ctx,    PGPASN_CertificationRequestInfo *f){    if (ctx == NULL)        return;    pgpasn_DropInPlaceCertificationRequestInfo(ctx, f);    if (f != NULL)        PGPASN_Free(ctx->memMgr, f);} /* pgpasn_FreeCertificationRequestInfo */size_t pgpasn_SizeofCertificationRequestInfo(    PGPASN_CONTEXT *ctx,    PGPASN_CertificationRequestInfo *asnstruct,    int outerSizeFlag){    (void)ctx; /* for future use */    return(pgpasn_SizeofCertificationRequestInfoInternal(asnstruct, outerSizeFlag, PGPASN_FALSE));} /* pgpasn_SizeofCertificationRequestInfo */size_t pgpasn_PackCertificationRequestInfo(    PGPASN_CONTEXT *ctx,    unsigned char *buf,    size_t buflen,    PGPASN_CertificationRequestInfo *asnstruct,    int *erret ){    return(pgpasn_PackCertificationRequestInfoInternal(ctx, buf, buflen, asnstruct, PGPASN_ID_CertificationRequestInfo, erret));} /* pgpasn_PackCertificationRequestInfo */size_t pgpasn_UnpackCertificationRequestInfo(    PGPASN_CONTEXT *ctx,    PGPASN_CertificationRequestInfo **asnstruct,    const unsigned char *buf,    size_t buflen,    int *erret){    size_t bytesused;    bytesused=pgpasn_UnpackCertificationRequestInfoInternal(ctx, asnstruct, buf, buflen,                      PGPASN_ID_CertificationRequestInfo, erret);    if(*erret==0 && bytesused==0)        PGPASN_ERR(kPGPASNError_ErrUnpackUnderrun);    return bytesused;}/****************************************************************** * Routines for GeneralName ******************************************************************/PGPASN_GeneralName *pgpasn_NewGeneralName(    PGPASN_CONTEXT *ctx){    PGPASN_GeneralName *f;    if (ctx == NULL)        return NULL;    f = (PGPASN_GeneralName *)PGPASN_Alloc(ctx->memMgr, sizeof(PGPASN_GeneralName));    if (f != NULL)        (void)memset(f, 0, sizeof(PGPASN_GeneralName));    return (f);} /* pgpasn_NewGeneralName */void pgpasn_FreeGeneralName(    PGPASN_CONTEXT *ctx,    PGPASN_GeneralName *f){    if (ctx == NULL)        return;    pgpasn_DropInPlaceGeneralName(ctx, f);    if (f != NULL)        PGPASN_Free(ctx->memMgr, f);} /* pgpasn_FreeGeneralName */size_t pgpasn_SizeofGeneralName(    PGPASN_CONTEXT *ctx,    PGPASN_GeneralName *asnstruct,    int outerSizeFlag){    (void)ctx; /* for future use */    return(pgpasn_SizeofGeneralNameInternal(asnstruct, outerSizeFlag, PGPASN_FALSE));} /* pgpasn_SizeofGeneralName */size_t pgpasn_PackGeneralName(    PGPASN_CONTEXT *ctx,    unsigned char *buf,    size_t buflen,    PGPASN_GeneralName *asnstruct,    int *erret ){    return(pgpasn_PackGeneralNameInternal(ctx, buf, buflen, asnstruct, PGPASN_ID_GeneralName, erret));} /* pgpasn_PackGeneralName */size_t pgpasn_UnpackGeneralName(    PGPASN_CONTEXT *ctx,    PGPASN_GeneralName **asnstruct,    const unsigned char *buf,    size_t buflen,    int *erret){    size_t bytesused;    bytesused=pgpasn_UnpackGeneralNameInternal(ctx, asnstruct, buf, buflen,                      PGPASN_ID_GeneralName, erret);    if(*erret==0 && bytesused==0)        PGPASN_ERR(kPGPASNError_ErrUnpackUnderrun);    return bytesused;}/****************************************************************** * Routines for IssuerAndSerialNumber ******************************************************************/PGPASN_IssuerAndSerialNumber *pgpasn_NewIssuerAndSerialNumber(    PGPASN_CONTEXT *ctx){    PGPASN_IssuerAndSerialNumber *f;    if (ctx == NULL)        return NULL;    f = (PGPASN_IssuerAndSerialNumber *)PGPASN_Alloc(ctx->memMgr, sizeof(PGPASN_IssuerAndSerialNumber));    if (f != NULL)        (void)memset(f, 0, sizeof(PGPASN_IssuerAndSerialNumber));    return (f);} /* pgpasn_NewIssuerAndSerialNumber */void pgpasn_FreeIssuerAndSerialNumber(    PGPASN_CONTEXT *ctx,    PGPASN_IssuerAndSerialNumber *f){    if (ctx == NULL)        return;    pgpasn_DropInPlaceIssuerAndSerialNumber(ctx, f);    if (f != NULL)        PGPASN_Free(ctx->memMgr, f);} /* pgpasn_FreeIssuerAndSerialNumber */size_t pgpasn_SizeofIssuerAndSerialNumber(    PGPASN_CONTEXT *ctx,    PGPASN_IssuerAndSerialNumber *asnstruct,    int outerSizeFlag){    (void)ctx; /* for future use */    return(pgpasn_SizeofIssuerAndSerialNumberInternal(asnstruct, outerSizeFlag, PGPASN_FALSE));} /* pgpasn_SizeofIssuerAndSerialNumber */size_t pgpasn_PackIssuerAndSerialNumber(    PGPASN_CONTEXT *ctx,    unsigned char *buf,    size_t buflen,    PGPASN_IssuerAndSerialNumber *asnstruct,    int *erret ){    return(pgpasn_PackIssuerAndSerialNumberInternal(ctx, buf, buflen, asnstruct, PGPASN_ID_IssuerAndSerialNumber, erret));} /* pgpasn_PackIssuerAndSerialNumber */size_t pgpasn_UnpackIssuerAndSerialNumber(    PGPASN_CONTEXT *ctx,    PGPASN_IssuerAndSerialNumber **asnstruct,    const unsigned char *buf,    size_t buflen,    int *erret){    size_t bytesused;    bytesused=pgpasn_UnpackIssuerAndSerialNumberInternal(ctx, asnstruct, buf, buflen,                      PGPASN_ID_IssuerAndSerialNumber, erret);    if(*erret==0 && bytesused==0)        PGPASN_ERR(kPGPASNError_ErrUnpackUnderrun);    return bytesused;}/****************************************************************** * Routines for TBSCertList ******************************************************************/PGPASN_TBSCertList *pgpasn_NewTBSCertList(    PGPASN_CONTEXT *ctx){    PGPASN_TBSCertList *f;    if (ctx == NULL)        return NULL;    f = (PGPASN_TBSCertList *)PGPASN_Alloc(ctx->memMgr, sizeof(PGPASN_TBSCertList));    if (f != NULL)        (void)memset(f, 0, sizeof(PGPASN_TBSCertList));    return (f);} /* pgpasn_NewTBSCertList */void pgpasn_FreeTBSCertList(    PGPASN_CONTEXT *ctx,    PGPASN_TBSCertList *f){    if (ctx == NULL)        return;    pgpasn_DropInPlaceTBSCertList(ctx, f);    if (f != NULL)        PGPASN_Free(ctx->memMgr, f);} /* pgpasn_FreeTBSCertList */size_t pgpasn_SizeofTBSCertList(    PGPASN_CONTEXT *ctx,    PGPASN_TBSCertList *asnstruct,    int outerSizeFlag){    (void)ctx; /* for future use */    return(pgpasn_SizeofTBSCertListInternal(asnstruct, outerSizeFlag, PGPASN_FALSE));} /* pgpasn_SizeofTBSCertList */size_t pgpasn_PackTBSCertList(    PGPASN_CONTEXT *ctx,    unsigned char *buf,    size_t buflen,    PGPASN_TBSCertList *asnstruct,    int *erret ){    return(pgpasn_PackTBSCertListInternal(ctx, buf, buflen, asnstruct, PGPASN_ID_TBSCertList, erret));} /* pgpasn_PackTBSCertList */size_t pgpasn_UnpackTBSCertList(    PGPASN_CONTEXT *ctx,    PGPASN_TBSCertList **asnstruct,    const unsigned char *buf,    size_t buflen,    int *erret){    size_t bytesused;    bytesused=pgpasn_UnpackTBSCertListInternal(ctx, asnstruct, buf, buflen,                      PGPASN_ID_TBSCertList, erret);    if(*erret==0 && bytesused==0)        PGPASN_ERR(kPGPASNError_ErrUnpackUnderrun);    return bytesused;}/****************************************************************** * Routines for TBSCertificate ******************************************************************/PGPASN_TBSCertificate *pgpasn_NewTBSCertificate(    PGPASN_CONTEXT *ctx){    PGPASN_TBSCertificate *f;    if (ctx == NULL)        return NULL;    f = (PGPASN_TBSCertificate *)PGPASN_Alloc(ctx->memMgr, sizeof(PGPASN_TBSCertificate));    if (f != NULL)        (void)memset(f, 0, sizeof(PGPASN_TBSCertificate));    return (f);} /* pgpasn_NewTBSCertificate */void pgpasn_FreeTBSCertificate(    PGPASN_CONTEXT *ctx,    PGPASN_TBSCertificate *f){    if (ctx == NULL)        return;    pgpasn_DropInPlaceTBSCertificate(ctx, f);    if (f != NULL)        PGPASN_Free(ctx->memMgr, f);} /* pgpasn_FreeTBSCertificate */size_t pgpasn_SizeofTBSCertificate(    PGPASN_CONTEXT *ctx,    PGPASN_TBSCertificate *asnstruct,    int outerSizeFlag){    (void)ctx; /* for future use */    return(pgpasn_SizeofTBSCertificateInternal(asnstruct, outerSizeFlag, PGPASN_FALSE));} /* pgpasn_SizeofTBSCertificate */size_t pgpasn_PackTBSCertificate(    PGPASN_CONTEXT *ctx,    unsigned char *buf,    size_t buflen,    PGPASN_TBSCertificate *asnstruct,    int *erret ){    return(pgpasn_PackTBSCertificateInternal(ctx, buf, buflen, asnstruct, PGPASN_ID_TBSCertificate, erret));} /* pgpasn_PackTBSCertificate */size_t pgpasn_UnpackTBSCertificate(    PGPASN_CONTEXT *ctx,    PGPASN_TBSCertificate **asnstruct,    const unsigned char *buf,    size_t buflen,    int *erret){    size_t bytesused;    bytesused=pgpasn_UnpackTBSCertificateInternal(ctx, asnstruct, buf, buflen,                      PGPASN_ID_TBSCertificate, erret);    if(*erret==0 && bytesused==0)        PGPASN_ERR(kPGPASNError_ErrUnpackUnderrun);    return bytesused;}/****************************************************************** * Routines for Certificate ******************************************************************/PGPASN_Certificate *pgpasn_NewCertificate(    PGPASN_CONTEXT *ctx){    PGPASN_Certificate *f;    if (ctx == NULL)        return NULL;    f = (PGPASN_Certificate *)PGPASN_Alloc(ctx->memMgr, sizeof(PGPASN_Certificate));    if (f != NULL)        (void)memset(f, 0, sizeof(PGPASN_Certificate));    return (f);} /* pgpasn_NewCertificate */void pgpasn_FreeCertificate(    PGPASN_CONTEXT *ctx,    PGPASN_Certificate *f){    if (ctx == NULL)        return;    pgpasn_DropInPlaceCertificate(ctx, f);    if (f != NULL)        PGPASN_Free(ctx->memMgr, f);} /* pgpasn_FreeCertificate */size_t pgpasn_SizeofCertificate(    PGPASN_CONTEXT *ctx,    PGPASN_Certificate *asnstruct,    int outerSizeFlag){    (void)ctx; /* for future use */    return(pgpasn_SizeofCertificateInternal(asnstruct, outerSizeFlag, PGPASN_FALSE));} /* pgpasn_SizeofCertificate */size_t pgpasn_PackCertificate(    PGPASN_CONTEXT *ctx,    unsigned char *buf,    size_t buflen,    PGPASN_Certificate *asnstruct,    int *erret ){    return(pgpasn_PackCertificateInternal(ctx, buf, buflen, asnstruct, PGPASN_ID_Certificate, erret));} /* pgpasn_PackCertificate */size_t pgpasn_UnpackCertificate(    PGPASN_CONTEXT *ctx,    PGPASN_Certificate **asnstruct,    const unsigned char *buf,    size_t buflen,    int *erret){    size_t bytesused;    bytesused=pgpasn_UnpackCertificateInternal(ctx, asnstruct, buf, buflen,                      PGPASN_ID_Certificate, erret);    if(*erret==0 && bytesused==0)        PGPASN_ERR(kPGPASNError_ErrUnpackUnderrun);    return bytesused;}/****************************************************************** * Routines for CertificateRevocationList ******************************************************************/PGPASN_CertificateRevocationList *pgpasn_NewCertificateRevocationList(    PGPASN_CONTEXT *ctx){    PGPASN_CertificateRevocationList *f;    if (ctx == NULL)        return NULL;    f = (PGPASN_CertificateRevocationList *)PGPASN_Alloc(ctx->memMgr, sizeof(PGPASN_CertificateRevocationList));    if (f != NULL)        (void)memset(f, 0, sizeof(PGPASN_CertificateRevocationList));    return (f);} /* pgpasn_NewCertificateRevocationList */void pgpasn_FreeCertificateRevocationList(    PGPASN_CONTEXT *ctx,    PGPASN_CertificateRevocationList *f){    if (ctx == NULL)        return;    pgpasn_DropInPlaceCertificateRevocationList(ctx, f);    if (f != NULL)        PGPASN_Free(ctx->memMgr, f);} /* pgpasn_FreeCertificateRevocationList */size_t pgpasn_SizeofCertificateRevocationList(    PGPASN_CONTEXT *ctx,    PGPASN_CertificateRevocationList *asnstruct,    int outerSizeFlag){    (void)ctx; /* for future use */    return(pgpasn_SizeofCertificateRevocationListInternal(asnstruct, outerSizeFlag, PGPASN_FALSE));} /* pgpasn_SizeofCertificateRevocationList */size_t pgpasn_PackCertificateRevocationList(    PGPASN_CONTEXT *ctx,    unsigned char *buf,    size_t buflen,    PGPASN_CertificateRevocationList *asnstruct,    int *erret ){    return(pgpasn_PackCertificateRevocationListInternal(ctx, buf, buflen, asnstruct, PGPASN_ID_CertificateRevocationList, erret));} /* pgpasn_PackCertificateRevocationList */size_t pgpasn_UnpackCertificateRevocationList(    PGPASN_CONTEXT *ctx,    PGPASN_CertificateRevocationList **asnstruct,    const unsigned char *buf,    size_t buflen,    int *erret){    size_t bytesused;    bytesused=pgpasn_UnpackCertificateRevocationListInternal(ctx, asnstruct, buf, buflen,                      PGPASN_ID_CertificateRevocationList, erret);    if(*erret==0 && bytesused==0)        PGPASN_ERR(kPGPASNError_ErrUnpackUnderrun);    return bytesused;}/****************************************************************** * Routines for CertificationRequest ******************************************************************/PGPASN_CertificationRequest *pgpasn_NewCertificationRequest(    PGPASN_CONTEXT *ctx){    PGPASN_CertificationRequest *f;    if (ctx == NULL)        return NULL;    f = (PGPASN_CertificationRequest *)PGPASN_Alloc(ctx->memMgr, sizeof(PGPASN_CertificationRequest));    if (f != NULL)        (void)memset(f, 0, sizeof(PGPASN_CertificationRequest));    return (f);} /* pgpasn_NewCertificationRequest */void pgpasn_FreeCertificationRequest(    PGPASN_CONTEXT *ctx,    PGPASN_CertificationRequest *f){    if (ctx == NULL)        return;    pgpasn_DropInPlaceCertificationRequest(ctx, f);    if (f != NULL)        PGPASN_Free(ctx->memMgr, f);} /* pgpasn_FreeCertificationRequest */size_t pgpasn_SizeofCertificationRequest(    PGPASN_CONTEXT *ctx,    PGPASN_CertificationRequest *asnstruct,    int outerSizeFlag){    (void)ctx; /* for future use */    return(pgpasn_SizeofCertificationRequestInternal(asnstruct, outerSizeFlag, PGPASN_FALSE));} /* pgpasn_SizeofCertificationRequest */size_t pgpasn_PackCertificationRequest(    PGPASN_CONTEXT *ctx,    unsigned char *buf,    size_t buflen,    PGPASN_CertificationRequest *asnstruct,    int *erret ){    return(pgpasn_PackCertificationRequestInternal(ctx, buf, buflen, asnstruct, PGPASN_ID_CertificationRequest, erret));} /* pgpasn_PackCertificationRequest */size_t pgpasn_UnpackCertificationRequest(    PGPASN_CONTEXT *ctx,    PGPASN_CertificationRequest **asnstruct,    const unsigned char *buf,    size_t buflen,    int *erret){    size_t bytesused;    bytesused=pgpasn_UnpackCertificationRequestInternal(ctx, asnstruct, buf, buflen,                      PGPASN_ID_CertificationRequest, erret);    if(*erret==0 && bytesused==0)        PGPASN_ERR(kPGPASNError_ErrUnpackUnderrun);    return bytesused;}/****************************************************************** * Routines for GeneralNames ******************************************************************/PGPASN_GeneralNames *pgpasn_NewGeneralNames(    PGPASN_CONTEXT *ctx){    PGPASN_GeneralNames *f;    if (ctx == NULL)        return NULL;    f = (PGPASN_GeneralNames *)PGPASN_Alloc(ctx->memMgr, sizeof(PGPASN_GeneralNames));    if (f != NULL)        (void)memset(f, 0, sizeof(PGPASN_GeneralNames));    return (f);} /* pgpasn_NewGeneralNames */void pgpasn_FreeGeneralNames(    PGPASN_CONTEXT *ctx,    PGPASN_GeneralNames *f){    if (ctx == NULL)        return;    pgpasn_DropInPlaceGeneralNames(ctx, f);    if (f != NULL)        PGPASN_Free(ctx->memMgr, f);} /* pgpasn_FreeGeneralNames */size_t pgpasn_SizeofGeneralNames(    PGPASN_CONTEXT *ctx,    PGPASN_GeneralNames *asnstruct,    int outerSizeFlag){    (void)ctx; /* for future use */    return(pgpasn_SizeofGeneralNamesInternal(asnstruct, outerSizeFlag, PGPASN_FALSE));} /* pgpasn_SizeofGeneralNames */size_t pgpasn_PackGeneralNames(    PGPASN_CONTEXT *ctx,    unsigned char *buf,    size_t buflen,    PGPASN_GeneralNames *asnstruct,    int *erret ){    return(pgpasn_PackGeneralNamesInternal(ctx, buf, buflen, asnstruct, PGPASN_ID_GeneralNames, erret));} /* pgpasn_PackGeneralNames */size_t pgpasn_UnpackGeneralNames(    PGPASN_CONTEXT *ctx,    PGPASN_GeneralNames **asnstruct,    const unsigned char *buf,    size_t buflen,    int *erret){    size_t bytesused;    bytesused=pgpasn_UnpackGeneralNamesInternal(ctx, asnstruct, buf, buflen,                      PGPASN_ID_GeneralNames, erret);    if(*erret==0 && bytesused==0)        PGPASN_ERR(kPGPASNError_ErrUnpackUnderrun);    return bytesused;}/****************************************************************** * Routines for SignerInfo ******************************************************************/PGPASN_SignerInfo *pgpasn_NewSignerInfo(    PGPASN_CONTEXT *ctx){    PGPASN_SignerInfo *f;    if (ctx == NULL)        return NULL;    f = (PGPASN_SignerInfo *)PGPASN_Alloc(ctx->memMgr, sizeof(PGPASN_SignerInfo));    if (f != NULL)        (void)memset(f, 0, sizeof(PGPASN_SignerInfo));    return (f);} /* pgpasn_NewSignerInfo */void pgpasn_FreeSignerInfo(    PGPASN_CONTEXT *ctx,    PGPASN_SignerInfo *f){    if (ctx == NULL)        return;    pgpasn_DropInPlaceSignerInfo(ctx, f);    if (f != NULL)        PGPASN_Free(ctx->memMgr, f);} /* pgpasn_FreeSignerInfo */size_t pgpasn_SizeofSignerInfo(    PGPASN_CONTEXT *ctx,    PGPASN_SignerInfo *asnstruct,    int outerSizeFlag){    (void)ctx; /* for future use */    return(pgpasn_SizeofSignerInfoInternal(asnstruct, outerSizeFlag, PGPASN_FALSE));} /* pgpasn_SizeofSignerInfo */size_t pgpasn_PackSignerInfo(    PGPASN_CONTEXT *ctx,    unsigned char *buf,    size_t buflen,    PGPASN_SignerInfo *asnstruct,    int *erret ){    return(pgpasn_PackSignerInfoInternal(ctx, buf, buflen, asnstruct, PGPASN_ID_SignerInfo, erret));} /* pgpasn_PackSignerInfo */size_t pgpasn_UnpackSignerInfo(    PGPASN_CONTEXT *ctx,    PGPASN_SignerInfo **asnstruct,    const unsigned char *buf,    size_t buflen,    int *erret){    size_t bytesused;    bytesused=pgpasn_UnpackSignerInfoInternal(ctx, asnstruct, buf, buflen,                      PGPASN_ID_SignerInfo, erret);    if(*erret==0 && bytesused==0)        PGPASN_ERR(kPGPASNError_ErrUnpackUnderrun);    return bytesused;}/****************************************************************** * Routines for CertificateRevocationLists ******************************************************************/PGPASN_CertificateRevocationLists *pgpasn_NewCertificateRevocationLists(    PGPASN_CONTEXT *ctx){    PGPASN_CertificateRevocationLists *f;    if (ctx == NULL)        return NULL;    f = (PGPASN_CertificateRevocationLists *)PGPASN_Alloc(ctx->memMgr, sizeof(PGPASN_CertificateRevocationLists));    if (f != NULL)        (void)memset(f, 0, sizeof(PGPASN_CertificateRevocationLists));    return (f);} /* pgpasn_NewCertificateRevocationLists */void pgpasn_FreeCertificateRevocationLists(    PGPASN_CONTEXT *ctx,    PGPASN_CertificateRevocationLists *f){    if (ctx == NULL)        return;    pgpasn_DropInPlaceCertificateRevocationLists(ctx, f);    if (f != NULL)        PGPASN_Free(ctx->memMgr, f);} /* pgpasn_FreeCertificateRevocationLists */size_t pgpasn_SizeofCertificateRevocationLists(    PGPASN_CONTEXT *ctx,    PGPASN_CertificateRevocationLists *asnstruct,    int outerSizeFlag){    (void)ctx; /* for future use */    return(pgpasn_SizeofCertificateRevocationListsInternal(asnstruct, outerSizeFlag, PGPASN_FALSE));} /* pgpasn_SizeofCertificateRevocationLists */size_t pgpasn_PackCertificateRevocationLists(    PGPASN_CONTEXT *ctx,    unsigned char *buf,    size_t buflen,    PGPASN_CertificateRevocationLists *asnstruct,    int *erret ){    return(pgpasn_PackCertificateRevocationListsInternal(ctx, buf, buflen, asnstruct, PGPASN_ID_CertificateRevocationLists, erret));} /* pgpasn_PackCertificateRevocationLists */size_t pgpasn_UnpackCertificateRevocationLists(    PGPASN_CONTEXT *ctx,    PGPASN_CertificateRevocationLists **asnstruct,    const unsigned char *buf,    size_t buflen,    int *erret){    size_t bytesused;    bytesused=pgpasn_UnpackCertificateRevocationListsInternal(ctx, asnstruct, buf, buflen,                      PGPASN_ID_CertificateRevocationLists, erret);    if(*erret==0 && bytesused==0)        PGPASN_ERR(kPGPASNError_ErrUnpackUnderrun);    return bytesused;}/****************************************************************** * Routines for Certificates ******************************************************************/PGPASN_Certificates *pgpasn_NewCertificates(    PGPASN_CONTEXT *ctx){    PGPASN_Certificates *f;    if (ctx == NULL)        return NULL;    f = (PGPASN_Certificates *)PGPASN_Alloc(ctx->memMgr, sizeof(PGPASN_Certificates));    if (f != NULL)        (void)memset(f, 0, sizeof(PGPASN_Certificates));    return (f);} /* pgpasn_NewCertificates */void pgpasn_FreeCertificates(    PGPASN_CONTEXT *ctx,    PGPASN_Certificates *f){    if (ctx == NULL)        return;    pgpasn_DropInPlaceCertificates(ctx, f);    if (f != NULL)        PGPASN_Free(ctx->memMgr, f);} /* pgpasn_FreeCertificates */size_t pgpasn_SizeofCertificates(    PGPASN_CONTEXT *ctx,    PGPASN_Certificates *asnstruct,    int outerSizeFlag){    (void)ctx; /* for future use */    return(pgpasn_SizeofCertificatesInternal(asnstruct, outerSizeFlag, PGPASN_FALSE));} /* pgpasn_SizeofCertificates */size_t pgpasn_PackCertificates(    PGPASN_CONTEXT *ctx,    unsigned char *buf,    size_t buflen,    PGPASN_Certificates *asnstruct,    int *erret ){    return(pgpasn_PackCertificatesInternal(ctx, buf, buflen, asnstruct, PGPASN_ID_Certificates, erret));} /* pgpasn_PackCertificates */size_t pgpasn_UnpackCertificates(    PGPASN_CONTEXT *ctx,    PGPASN_Certificates **asnstruct,    const unsigned char *buf,    size_t buflen,    int *erret){    size_t bytesused;    bytesused=pgpasn_UnpackCertificatesInternal(ctx, asnstruct, buf, buflen,                      PGPASN_ID_Certificates, erret);    if(*erret==0 && bytesused==0)        PGPASN_ERR(kPGPASNError_ErrUnpackUnderrun);    return bytesused;}/****************************************************************** * Routines for DistributionPointName ******************************************************************/PGPASN_DistributionPointName *pgpasn_NewDistributionPointName(    PGPASN_CONTEXT *ctx){    PGPASN_DistributionPointName *f;    if (ctx == NULL)        return NULL;    f = (PGPASN_DistributionPointName *)PGPASN_Alloc(ctx->memMgr, sizeof(PGPASN_DistributionPointName));    if (f != NULL)        (void)memset(f, 0, sizeof(PGPASN_DistributionPointName));    return (f);} /* pgpasn_NewDistributionPointName */void pgpasn_FreeDistributionPointName(    PGPASN_CONTEXT *ctx,    PGPASN_DistributionPointName *f){    if (ctx == NULL)        return;    pgpasn_DropInPlaceDistributionPointName(ctx, f);    if (f != NULL)        PGPASN_Free(ctx->memMgr, f);} /* pgpasn_FreeDistributionPointName */size_t pgpasn_SizeofDistributionPointName(    PGPASN_CONTEXT *ctx,    PGPASN_DistributionPointName *asnstruct,    int outerSizeFlag){    (void)ctx; /* for future use */    return(pgpasn_SizeofDistributionPointNameInternal(asnstruct, outerSizeFlag, PGPASN_FALSE));} /* pgpasn_SizeofDistributionPointName */size_t pgpasn_PackDistributionPointName(    PGPASN_CONTEXT *ctx,    unsigned char *buf,    size_t buflen,    PGPASN_DistributionPointName *asnstruct,    int *erret ){    return(pgpasn_PackDistributionPointNameInternal(ctx, buf, buflen, asnstruct, PGPASN_ID_DistributionPointName, erret));} /* pgpasn_PackDistributionPointName */size_t pgpasn_UnpackDistributionPointName(    PGPASN_CONTEXT *ctx,    PGPASN_DistributionPointName **asnstruct,    const unsigned char *buf,    size_t buflen,    int *erret){    size_t bytesused;    bytesused=pgpasn_UnpackDistributionPointNameInternal(ctx, asnstruct, buf, buflen,                      PGPASN_ID_DistributionPointName, erret);    if(*erret==0 && bytesused==0)        PGPASN_ERR(kPGPASNError_ErrUnpackUnderrun);    return bytesused;}/****************************************************************** * Routines for SignerInfos ******************************************************************/PGPASN_SignerInfos *pgpasn_NewSignerInfos(    PGPASN_CONTEXT *ctx){    PGPASN_SignerInfos *f;    if (ctx == NULL)        return NULL;    f = (PGPASN_SignerInfos *)PGPASN_Alloc(ctx->memMgr, sizeof(PGPASN_SignerInfos));    if (f != NULL)        (void)memset(f, 0, sizeof(PGPASN_SignerInfos));    return (f);} /* pgpasn_NewSignerInfos */void pgpasn_FreeSignerInfos(    PGPASN_CONTEXT *ctx,    PGPASN_SignerInfos *f){    if (ctx == NULL)        return;    pgpasn_DropInPlaceSignerInfos(ctx, f);    if (f != NULL)        PGPASN_Free(ctx->memMgr, f);} /* pgpasn_FreeSignerInfos */size_t pgpasn_SizeofSignerInfos(    PGPASN_CONTEXT *ctx,    PGPASN_SignerInfos *asnstruct,    int outerSizeFlag){    (void)ctx; /* for future use */    return(pgpasn_SizeofSignerInfosInternal(asnstruct, outerSizeFlag, PGPASN_FALSE));} /* pgpasn_SizeofSignerInfos */size_t pgpasn_PackSignerInfos(    PGPASN_CONTEXT *ctx,    unsigned char *buf,    size_t buflen,    PGPASN_SignerInfos *asnstruct,    int *erret ){    return(pgpasn_PackSignerInfosInternal(ctx, buf, buflen, asnstruct, PGPASN_ID_SignerInfos, erret));} /* pgpasn_PackSignerInfos */size_t pgpasn_UnpackSignerInfos(    PGPASN_CONTEXT *ctx,    PGPASN_SignerInfos **asnstruct,    const unsigned char *buf,    size_t buflen,    int *erret){    size_t bytesused;    bytesused=pgpasn_UnpackSignerInfosInternal(ctx, asnstruct, buf, buflen,                      PGPASN_ID_SignerInfos, erret);    if(*erret==0 && bytesused==0)        PGPASN_ERR(kPGPASNError_ErrUnpackUnderrun);    return bytesused;}/****************************************************************** * Routines for DistributionPoint ******************************************************************/PGPASN_DistributionPoint *pgpasn_NewDistributionPoint(    PGPASN_CONTEXT *ctx){    PGPASN_DistributionPoint *f;    if (ctx == NULL)        return NULL;    f = (PGPASN_DistributionPoint *)PGPASN_Alloc(ctx->memMgr, sizeof(PGPASN_DistributionPoint));    if (f != NULL)        (void)memset(f, 0, sizeof(PGPASN_DistributionPoint));    return (f);} /* pgpasn_NewDistributionPoint */void pgpasn_FreeDistributionPoint(    PGPASN_CONTEXT *ctx,    PGPASN_DistributionPoint *f){    if (ctx == NULL)        return;    pgpasn_DropInPlaceDistributionPoint(ctx, f);    if (f != NULL)        PGPASN_Free(ctx->memMgr, f);} /* pgpasn_FreeDistributionPoint */size_t pgpasn_SizeofDistributionPoint(    PGPASN_CONTEXT *ctx,    PGPASN_DistributionPoint *asnstruct,    int outerSizeFlag){    (void)ctx; /* for future use */    return(pgpasn_SizeofDistributionPointInternal(asnstruct, outerSizeFlag, PGPASN_FALSE));} /* pgpasn_SizeofDistributionPoint */size_t pgpasn_PackDistributionPoint(    PGPASN_CONTEXT *ctx,    unsigned char *buf,    size_t buflen,    PGPASN_DistributionPoint *asnstruct,    int *erret ){    return(pgpasn_PackDistributionPointInternal(ctx, buf, buflen, asnstruct, PGPASN_ID_DistributionPoint, erret));} /* pgpasn_PackDistributionPoint */size_t pgpasn_UnpackDistributionPoint(    PGPASN_CONTEXT *ctx,    PGPASN_DistributionPoint **asnstruct,    const unsigned char *buf,    size_t buflen,    int *erret){    size_t bytesused;    bytesused=pgpasn_UnpackDistributionPointInternal(ctx, asnstruct, buf, buflen,                      PGPASN_ID_DistributionPoint, erret);    if(*erret==0 && bytesused==0)        PGPASN_ERR(kPGPASNError_ErrUnpackUnderrun);    return bytesused;}/****************************************************************** * Routines for IssuingDistributionPoint ******************************************************************/PGPASN_IssuingDistributionPoint *pgpasn_NewIssuingDistributionPoint(    PGPASN_CONTEXT *ctx){    PGPASN_IssuingDistributionPoint *f;    if (ctx == NULL)        return NULL;    f = (PGPASN_IssuingDistributionPoint *)PGPASN_Alloc(ctx->memMgr, sizeof(PGPASN_IssuingDistributionPoint));    if (f != NULL)        (void)memset(f, 0, sizeof(PGPASN_IssuingDistributionPoint));    return (f);} /* pgpasn_NewIssuingDistributionPoint */void pgpasn_FreeIssuingDistributionPoint(    PGPASN_CONTEXT *ctx,    PGPASN_IssuingDistributionPoint *f){    if (ctx == NULL)        return;    pgpasn_DropInPlaceIssuingDistributionPoint(ctx, f);    if (f != NULL)        PGPASN_Free(ctx->memMgr, f);} /* pgpasn_FreeIssuingDistributionPoint */size_t pgpasn_SizeofIssuingDistributionPoint(    PGPASN_CONTEXT *ctx,    PGPASN_IssuingDistributionPoint *asnstruct,    int outerSizeFlag){    (void)ctx; /* for future use */    return(pgpasn_SizeofIssuingDistributionPointInternal(asnstruct, outerSizeFlag, PGPASN_FALSE));} /* pgpasn_SizeofIssuingDistributionPoint */size_t pgpasn_PackIssuingDistributionPoint(    PGPASN_CONTEXT *ctx,    unsigned char *buf,    size_t buflen,    PGPASN_IssuingDistributionPoint *asnstruct,    int *erret ){    return(pgpasn_PackIssuingDistributionPointInternal(ctx, buf, buflen, asnstruct, PGPASN_ID_IssuingDistributionPoint, erret));} /* pgpasn_PackIssuingDistributionPoint */size_t pgpasn_UnpackIssuingDistributionPoint(    PGPASN_CONTEXT *ctx,    PGPASN_IssuingDistributionPoint **asnstruct,    const unsigned char *buf,    size_t buflen,    int *erret){    size_t bytesused;    bytesused=pgpasn_UnpackIssuingDistributionPointInternal(ctx, asnstruct, buf, buflen,                      PGPASN_ID_IssuingDistributionPoint, erret);    if(*erret==0 && bytesused==0)        PGPASN_ERR(kPGPASNError_ErrUnpackUnderrun);    return bytesused;}/****************************************************************** * Routines for SignedData ******************************************************************/PGPASN_SignedData *pgpasn_NewSignedData(    PGPASN_CONTEXT *ctx){    PGPASN_SignedData *f;    if (ctx == NULL)        return NULL;    f = (PGPASN_SignedData *)PGPASN_Alloc(ctx->memMgr, sizeof(PGPASN_SignedData));    if (f != NULL)        (void)memset(f, 0, sizeof(PGPASN_SignedData));    return (f);} /* pgpasn_NewSignedData */void pgpasn_FreeSignedData(    PGPASN_CONTEXT *ctx,    PGPASN_SignedData *f){    if (ctx == NULL)        return;    pgpasn_DropInPlaceSignedData(ctx, f);    if (f != NULL)        PGPASN_Free(ctx->memMgr, f);} /* pgpasn_FreeSignedData */size_t pgpasn_SizeofSignedData(    PGPASN_CONTEXT *ctx,    PGPASN_SignedData *asnstruct,    int outerSizeFlag){    (void)ctx; /* for future use */    return(pgpasn_SizeofSignedDataInternal(asnstruct, outerSizeFlag, PGPASN_FALSE));} /* pgpasn_SizeofSignedData */size_t pgpasn_PackSignedData(    PGPASN_CONTEXT *ctx,    unsigned char *buf,    size_t buflen,    PGPASN_SignedData *asnstruct,    int *erret ){    return(pgpasn_PackSignedDataInternal(ctx, buf, buflen, asnstruct, PGPASN_ID_SignedData, erret));} /* pgpasn_PackSignedData */size_t pgpasn_UnpackSignedData(    PGPASN_CONTEXT *ctx,    PGPASN_SignedData **asnstruct,    const unsigned char *buf,    size_t buflen,    int *erret){    size_t bytesused;    bytesused=pgpasn_UnpackSignedDataInternal(ctx, asnstruct, buf, buflen,                      PGPASN_ID_SignedData, erret);    if(*erret==0 && bytesused==0)        PGPASN_ERR(kPGPASNError_ErrUnpackUnderrun);    return bytesused;}/****************************************************************** * Routines for CRLDistPointsSyntax ******************************************************************/PGPASN_CRLDistPointsSyntax *pgpasn_NewCRLDistPointsSyntax(    PGPASN_CONTEXT *ctx){    PGPASN_CRLDistPointsSyntax *f;    if (ctx == NULL)        return NULL;    f = (PGPASN_CRLDistPointsSyntax *)PGPASN_Alloc(ctx->memMgr, sizeof(PGPASN_CRLDistPointsSyntax));    if (f != NULL)        (void)memset(f, 0, sizeof(PGPASN_CRLDistPointsSyntax));    return (f);} /* pgpasn_NewCRLDistPointsSyntax */void pgpasn_FreeCRLDistPointsSyntax(    PGPASN_CONTEXT *ctx,    PGPASN_CRLDistPointsSyntax *f){    if (ctx == NULL)        return;    pgpasn_DropInPlaceCRLDistPointsSyntax(ctx, f);    if (f != NULL)        PGPASN_Free(ctx->memMgr, f);} /* pgpasn_FreeCRLDistPointsSyntax */size_t pgpasn_SizeofCRLDistPointsSyntax(    PGPASN_CONTEXT *ctx,    PGPASN_CRLDistPointsSyntax *asnstruct,    int outerSizeFlag){    (void)ctx; /* for future use */    return(pgpasn_SizeofCRLDistPointsSyntaxInternal(asnstruct, outerSizeFlag, PGPASN_FALSE));} /* pgpasn_SizeofCRLDistPointsSyntax */size_t pgpasn_PackCRLDistPointsSyntax(    PGPASN_CONTEXT *ctx,    unsigned char *buf,    size_t buflen,    PGPASN_CRLDistPointsSyntax *asnstruct,    int *erret ){    return(pgpasn_PackCRLDistPointsSyntaxInternal(ctx, buf, buflen, asnstruct, PGPASN_ID_CRLDistPointsSyntax, erret));} /* pgpasn_PackCRLDistPointsSyntax */size_t pgpasn_UnpackCRLDistPointsSyntax(    PGPASN_CONTEXT *ctx,    PGPASN_CRLDistPointsSyntax **asnstruct,    const unsigned char *buf,    size_t buflen,    int *erret){    size_t bytesused;    bytesused=pgpasn_UnpackCRLDistPointsSyntaxInternal(ctx, asnstruct, buf, buflen,                      PGPASN_ID_CRLDistPointsSyntax, erret);    if(*erret==0 && bytesused==0)        PGPASN_ERR(kPGPASNError_ErrUnpackUnderrun);    return bytesused;}