#!/bin/sh
# to extract, remove the header and type "sh filename"
if `test ! -s ./Makefile`
then
echo "writing ./Makefile"
cat > ./Makefile << '\Rogue\Monster\'
#
#	Makefile - for LOKI routines
#
#	major targets are:
#		make all	- compile binaries in this directory
#		make clean	- remove all object files
#		make clobber	- remove all files except original source
#
#	Copyright 1988 Lawrence Brown and CITRAD
#
#	Compiler Defines:
#	-----------------
#	    if this program is compiled on a little-endian machine (eg Vax)
#		define '-DLITTLE_ENDIAN' in CFLAGS & LINTF
#		in order to enable the byte swapping  routines, 
#		which will incur a time penalty
#
#	    if compiled on a machine requiring strict alignment of words/longs
#		and cannot guarantee that the 8 char blocks passed are aligned
#		define '-DSTRICT_ALIGN' in CFLAGS & LINTF
#		this will incure about an 5% time penalty for each encryption
#
#	    if a detailed trace of LOKI function f is required for debugging
#		define '-DTRACE=1', '-DTRACE=2' or '-DTRACE=3' in CFLAGS & LINTF
#               for increasingly detailed diagnostics from the loki64 routines.

CFLAGS=-O

PROGS = cert89 cert91
OBJS  = lokicert.o loki89.o loki91.o

all: ${PROGS}

cert89: lokicert.o loki89.o
	${CC} ${CFLAGS} lokicert.o loki89.o -o cert89

cert91: lokicert.o loki91.o
	${CC} ${CFLAGS} lokicert.o loki91.o -o cert91

${OBJS}:	loki.h

clean:
	-rm ${OBJS} a.out core

clobber:	clean
	-rm ${PROGS}

.c.o: 
	${CC} ${CFLAGS} -c $*.c


\Rogue\Monster\
else
  echo "will not over write ./Makefile"
fi
if `test ! -s ./README`
then
echo "writing ./README"
cat > ./README << '\Rogue\Monster\'
This directory contains the Unix source for the original LOKI89 and for
LOKI91, the upgraded version of LOKI.
The files it contains are -

	README		- This file
	loki.h		- Interface specification include file for LOKI89 & 91
	loki.i		- LOKI S & P box definition file for LOKI89 & 91
	loki89.c	- Source code for LOKI89
	loki91.c	- Source code for LOKI91
	lokicert.c	- Certification program
	triples89	- LOKI89 certification triplets
	triples91	- LOKI91 certification triplets
	single89, single91 - single LOKI89 & LOKI91 certification triplets
	log.single89, log.single91 - logs of the certification runs on
			single89 & single91 with TRACE=2 defined

To compile the certification program for LOKI89 & 91 use
(note comments in each re DEFINE targets for various options and
architectures):

	cc loki89.c lokicert.c -o cert89
	cc loki91.c lokicert.c -o cert91

To run the certification use

	cert89 < triples89
	cert91 < triples91

LOKI91 differs from LOKI89 in that the key schedule uses 13 bit
rotations instead of 12, and the S-boxes are generated by a slightly
different function. In LOKI89 the base for Galois Field exponentiation
was
	b = col ^ row

In LOKI91 it is

	b = (col + ((row * 17) ^ 0xff)) & 0xff

Otherwise the algorithms are identical. The E-boxes and permutation
functions are unchanged.

Lawrie Brown & Matthew Kwan
\Rogue\Monster\
else
  echo "will not over write ./README"
fi
if `test ! -s ./log.single89`
then
echo "writing ./log.single89"
cat > ./log.single89 << '\Rogue\Monster\'
  keyinit(5b5a5767, 6a56676e)
  enloki(675a6967, 5e5a6b5a)
  f(340c0c34, 5b5a5767) = P.S(6f565b53) = P(e11a0f7d) = 8995736b
  f(b5954d6b, 6a56676e) = P.S(dfc32a05) = P(e98c7f93) = daa3e63b
  f(eeafea0f, a57675b5) = P.S(4bd99fba) = P(99a044ff) = d3599319
  f(66ccde72, 6676e6a5) = P.S(00ba38d7) = P(a5e2d8d7) = f7c32959
  f(196cc356, 675b5a57) = P.S(7e379901) = P(387a99b7) = 34dfe153
  f(52133f21, 6e6a5667) = P.S(3c796946) = P(2b0753fe) = 139395fe
  f(0aff56a8, b5a57675) = P.S(bf5a20dd) = P(2cc4b838) = 64b3bc00
  f(36a08321, a56676e6) = P.S(93c6f5c7) = P(ead11b65) = cd96a1a7
  f(c769f70f, 57675b5a) = P.S(900eac55) = P(830107eb) = 911012bf
  f(a7b0919e, 676e6a56) = P.S(c0defbc8) = P(824e3573) = 853346d3
  f(425ab1dc, 75b5a576) = P.S(37ef14aa) = P(b705ac86) = b0a82f9c
  f(1718be02, e6a56676) = P.S(f1bdd874) = P(c8f8f5fb) = ff77d213
  f(bd2d63cf, 5a57675b) = P.S(e77a0494) = P(49325f07) = 0a46a37b
  f(1d5e1d79, 56676e6a) = P.S(4b397313) = P(5ad61743) = 4d0e86f3
  f(f023e53c, 7675b5a5) = P.S(86565099) = P(7c93853a) = 689d9a56
  f(75c3872f, 76e6a566) = P.S(03252249) = P(8559ca28) = a614782c
  enloki returns 3c61fa7e, 2e99d048
  deloki(3c61fa7e, 2e99d048)
  f(75c3872f, 76e6a566) = P.S(03252249) = P(8559ca28) = a614782c
  f(f023e53c, 7675b5a5) = P.S(86565099) = P(7c93853a) = 689d9a56
  f(1d5e1d79, 56676e6a) = P.S(4b397313) = P(5ad61743) = 4d0e86f3
  f(bd2d63cf, 5a57675b) = P.S(e77a0494) = P(49325f07) = 0a46a37b
  f(1718be02, e6a56676) = P.S(f1bdd874) = P(c8f8f5fb) = ff77d213
  f(425ab1dc, 75b5a576) = P.S(37ef14aa) = P(b705ac86) = b0a82f9c
  f(a7b0919e, 676e6a56) = P.S(c0defbc8) = P(824e3573) = 853346d3
  f(c769f70f, 57675b5a) = P.S(900eac55) = P(830107eb) = 911012bf
  f(36a08321, a56676e6) = P.S(93c6f5c7) = P(ead11b65) = cd96a1a7
  f(0aff56a8, b5a57675) = P.S(bf5a20dd) = P(2cc4b838) = 64b3bc00
  f(52133f21, 6e6a5667) = P.S(3c796946) = P(2b0753fe) = 139395fe
  f(196cc356, 675b5a57) = P.S(7e379901) = P(387a99b7) = 34dfe153
  f(66ccde72, 6676e6a5) = P.S(00ba38d7) = P(a5e2d8d7) = f7c32959
  f(eeafea0f, a57675b5) = P.S(4bd99fba) = P(99a044ff) = d3599319
  f(b5954d6b, 6a56676e) = P.S(dfc32a05) = P(e98c7f93) = daa3e63b
  f(340c0c34, 5b5a5767) = P.S(6f565b53) = P(e11a0f7d) = 8995736b
  deloki returns 675a6967, 5e5a6b5a
Test  1,  K: 5b5a57676a56676e  P: 675a69675e5a6b5a  C: 3c61fa7e2e99d048 OK
lokicert: 0 failures in 1 tests
\Rogue\Monster\
else
  echo "will not over write ./log.single89"
fi
if `test ! -s ./log.single91`
then
echo "writing ./log.single91"
cat > ./log.single91 << '\Rogue\Monster\'
  keyinit(3849674c, 2602319e)
  enloki(126898d5, 5e911500)
  f(5e911500, 3849674c) = P.S(66d8724c) = P(f87162a9) = 9efc9025
  f(8c9408f0, 9674c384) = P.S(1ae0cb74) = P(33922c03) = 40ac22d9
  f(1e3d37d9, 2602319e) = P.S(383f0647) = P(09581c84) = 1406e308
  f(9892ebf8, 2319e260) = P.S(bb8b0998) = P(bb39254c) = 81ecd38e
  f(9fd1e457, 987092ce) = P.S(07a17699) = P(f3060821) = 889824c9
  f(100acf31, 092ce987) = P.S(192626b6) = P(c965744b) = 8f62961d
  f(10b3724a, 3c4c0463) = P.S(2cff7629) = P(9f55c124) = a61c8d8e
  f(b61642bf, c04633c4) = P.S(7650717b) = P(964f0840) = 85086cc4
  f(95bb1e8e, 9d30e125) = P.S(088bffab) = P(ad7e306f) = 85f6dd59
  f(33e09fe6, 0e1259d3) = P.S(3df2c635) = P(d5950b95) = d80d2d2f
  f(4db633a1, c6789808) = P.S(8bceaba9) = P(c7fcaaf0) = fd756ca8
  f(ce95f34e, 89808c67) = P.S(47157f29) = P(a20c6292) = 92a144b0
  f(df177711, 4b3a61c2) = P.S(942d16d3) = P(4ddad7ce) = 7f06db7a
  f(b1932834, a61c24b3) = P.S(178f0c87) = P(137d6e14) = 066d67ac
  f(d97a10bd, 118cf130) = P.S(c8f6e18d) = P(0d92618c) = 5224994a
  f(e3b7b17e, cf130118) = P.S(2ca4b066) = P(0d171eea) = 1116be7c
  enloki returns c86caec1, e3b7b17e
  deloki(c86caec1, e3b7b17e)
  f(e3b7b17e, cf130118) = P.S(2ca4b066) = P(0d171eea) = 1116be7c
  f(d97a10bd, 118cf130) = P.S(c8f6e18d) = P(0d92618c) = 5224994a
  f(b1932834, a61c24b3) = P.S(178f0c87) = P(137d6e14) = 066d67ac
  f(df177711, 4b3a61c2) = P.S(942d16d3) = P(4ddad7ce) = 7f06db7a
  f(ce95f34e, 89808c67) = P.S(47157f29) = P(a20c6292) = 92a144b0
  f(4db633a1, c6789808) = P.S(8bceaba9) = P(c7fcaaf0) = fd756ca8
  f(33e09fe6, 0e1259d3) = P.S(3df2c635) = P(d5950b95) = d80d2d2f
  f(95bb1e8e, 9d30e125) = P.S(088bffab) = P(ad7e306f) = 85f6dd59
  f(b61642bf, c04633c4) = P.S(7650717b) = P(964f0840) = 85086cc4
  f(10b3724a, 3c4c0463) = P.S(2cff7629) = P(9f55c124) = a61c8d8e
  f(100acf31, 092ce987) = P.S(192626b6) = P(c965744b) = 8f62961d
  f(9fd1e457, 987092ce) = P.S(07a17699) = P(f3060821) = 889824c9
  f(9892ebf8, 2319e260) = P.S(bb8b0998) = P(bb39254c) = 81ecd38e
  f(1e3d37d9, 2602319e) = P.S(383f0647) = P(09581c84) = 1406e308
  f(8c9408f0, 9674c384) = P.S(1ae0cb74) = P(33922c03) = 40ac22d9
  f(5e911500, 3849674c) = P.S(66d8724c) = P(f87162a9) = 9efc9025
  deloki returns 126898d5, 5e911500
Test  1,  K: 3849674c2602319e  P: 126898d55e911500  C: c86caec1e3b7b17e OK
lokicert: 0 failures in 1 tests
\Rogue\Monster\
else
  echo "will not over write ./log.single91"
fi
if `test ! -s ./loki.h`
then
echo "writing ./loki.h"
cat > ./loki.h << '\Rogue\Monster\'
/*
 *  loki.h - specifies the interface to the LOKI encryption routines.
 *      This library proviloki routines to expand a key, encrypt and
 *      decrypt 64-bit data blocks.  The LOKI Data Encryption Algorithm
 *      is a block cipher which ensures that its output is a complex
 *      function of its input and the key.
 *
 *  Authors:	Lawrie Brown <Lawrie.Brown@adfa.oz.au>	Aug 1989
 *		Matthew Kwan <mkwan@cs.adfa.oz.au>	Sep 1991
 *
 *      Computer Science, UC UNSW, Australian Defence Force Academy,
 *          Canberra, ACT 2600, Australia.
 *
 *  Version:
 *      v1.0 - of loki64.o is current 7/89 lpb
 *	v2.0 - of loki64.c is current 9/91 mkwan
 *	v3.0 - now have loki89.c & loki91.c 10/92 lpb
 *
 *  Copyright 1989 by Lawrie Brown and UNSW. All rights reserved.
 *      This program may not be sold or used as inducement to buy a
 *      product without the written permission of the author.
 *
 *  Description:
 *  The routines provided by the library are:
 *
 *  lokikey(key)	    - expands a key into subkey, for use in 
 *    char  key[8];             encryption and decryption operations.
 *
 *  enloki(b)		    - main LOKI encryption routine, this routine 
 *    char  b[8];               encrypts one 64-bit block b with subkey
 *
 *  deloki(b)		    - main LOKI decryption routine, this routine 
 *    char  b[8];               decrypts one 64-bit block b with subkey
 *
 *  The 64-bit data & key blocks used in the algorithm are specified as eight
 *      unsigned chars. For the purposes of implementing the LOKI algorithm,
 *      these MUST be word aligned with bits are numbered as follows:
 *        [63..56] [55..48] 		...		[7..0]
 *      in  b[0]     b[1]  b[2]  b[3]  b[4]  b[5]  b[6]  b[7]
 */

#define LOKIBLK	8		/* No of bytes in a LOKI data-block          */
#define ROUNDS	16		/* No of LOKI rounds             	     */

typedef unsigned long	Long;   /* type specification for aligned LOKI blocks */

extern Long	lokikey[2];	/* 64-bit key used by LOKI routines          */
extern char	*loki_lib_ver;	/* String with version no. & copyright       */

#ifdef __STDC__			/* declare prototypes for library functions  */
extern void enloki(char b[LOKIBLK]);
extern void deloki(char b[LOKIBLK]);
extern void setlokikey(char key[LOKIBLK]);
#else				/* else just declare library functions extern */
extern void enloki(), deloki(), setlokikey();
#endif __STDC__
\Rogue\Monster\
else
  echo "will not over write ./loki.h"
fi
if `test ! -s ./loki.i`
then
echo "writing ./loki.i"
cat > ./loki.i << '\Rogue\Monster\'
/*
 *	loki.i - contains the fixed permutation and substitution tables 
 *			for a 64 bit LOKI89 & LOKI91 implementations.
 *
 *  Modifications:
 *	v1.0	original tables                       	Aug 1989 lpb
 *	v2.0	add various speed/size versions		Apr 1990 lpb
 *	v2.1	install into RCS system for production control 5/90 lpb
 *	v3.0	LOKI89 & LOKI91 now supported		10/92 lpb
 *
 *  Author:	Lawrence Brown <lpb@csadfa.oz>		Aug 1989
 *		Computer Science, UC UNSW, ADFA, Canberra, ACT 2600, Australia.
 *
 *  Copyright 1989 by Lawrence Brown and UNSW. All rights reserved.
 *      This program may not be sold or used as inducement to buy a
 *      product without the written permission of the author.
 */

/* 32-bit permutation function P */
/*   specifies which input bit is permuted to output bits */
/*   31 30 29 ... 2 1 0 respectively (ie in MSB to LSB order) */
char P[32] = {
	31, 23, 15, 7, 30, 22, 14, 6,
	29, 21, 13, 5, 28, 20, 12, 4,
	27, 19, 11, 3, 26, 18, 10, 2,
	25, 17, 9, 1, 24, 16, 8, 0
	};

/*
 *	sfn_desc - a desriptor table specifying which irreducible polynomial
 *		and exponent is to be used for each of the 16 S functions in
 *		the Loki S-box
 */
typedef	struct {
	short	gen;		/* irreducible polynomial used in this field */
	short	exp;		/* exponent used to generate this s function */
	} sfn_desc;

/*
 *	sfn - the table specifying the irreducible polys & exponents used
 *		in the Loki S-boxes for the Loki algorithm
 */
sfn_desc sfn[] = {
	{ /* 101110111 */ 375, 31},
	{ /* 101111011 */ 379, 31},
	{ /* 110000111 */ 391, 31},
	{ /* 110001011 */ 395, 31},
	{ /* 110001101 */ 397, 31},
	{ /* 110011111 */ 415, 31},
	{ /* 110100011 */ 419, 31},
	{ /* 110101001 */ 425, 31},
	{ /* 110110001 */ 433, 31},
	{ /* 110111101 */ 445, 31},
	{ /* 111000011 */ 451, 31},
	{ /* 111001111 */ 463, 31},
	{ /* 111010111 */ 471, 31},
	{ /* 111011101 */ 477, 31},
	{ /* 111100111 */ 487, 31},
	{ /* 111110011 */ 499, 31},
	{ 00, 00}
	};
\Rogue\Monster\
else
  echo "will not over write ./loki.i"
fi
if `test ! -s ./loki89.c`
then
echo "writing ./loki89.c"
cat > ./loki89.c << '\Rogue\Monster\'
/*
 *	loki89.c - library routines for a 64 bit LOKI89 implementation
 *
 *  Author:	Lawrence Brown <lpb@csadfa.oz>		Aug 1989
 *		Computer Science, UC UNSW, ADFA, Canberra, ACT 2600, Australia.
 *
 *  Modifications:
 *		v1.0 - original set of code (based on des64.c v4.0) 9/89 lpb
 *		v2.0 - include conditionals for various speed/sizes 4/90 lpb
 *		v2.1 - use RCS system for production control	5/90 lpb
 *		v3.0 - support both LOKI89 & LOKI91 versions   10/92 lpb
 *
 *  Copyright 1989 by Lawrence Brown and UNSW. All rights reserved.
 *      This program may not be sold or used as inducement to buy a
 *      product without the written permission of the author.
 *
 *	nb: if this program is compiled on a little-endian machine (eg Vax)
 *		#define LITTLE_ENDIAN
 *		in order to enable the byte swapping  routines 
 *
 *	    if a detailed trace of LOKI89 function f is required for debugging
 *		#define TRACE=n		n=1 print blocks, n=2 print fn f also
 *                                      n=3 print individual S-box calcs also
 *
 *	    these routines assume that the 8-byte char arrays used to pass
 *		the 64-bit blocks fall on a word boundary, so that the blocks
 *		may be read as longwords for efficiency reasons. If this is
 *		not true, the load & save of the parameters will need changing.
 */
#include <stdio.h>
#include "loki.h"	/* include Interface Specification header file       */
#include "loki.i"	/* include LOKI89 Permutation, Subs & Key tables*/

/*
 *	string specifying version and copyright message
 */
char	*loki_lib_ver = "LOKI89 library v3.0, Copyright (C) 1990 Lawrence Brown & UNSW";

static Long	f();	/* declare LOKI89 function f		     */
static short	s();	/* declare LOKI89 s-box routine (for small ver) */

/*
 *	lokikey - the 64-bit key for the LOKI89 library routines
 */
Long	lokikey[2] = {0, 0};


/*
 *	ROL12(b) - macro to rotate 32-bit block b left  by 12 bits
 *	ROR12(b) - macro to rotate 32-bit block b right by 12 bits
 */
#define ROL12(b) b = ((b << 12) | (b >> 20));
#define ROR12(b) b = ((b >> 12) | (b << 20));

/*
 *      bswap(b) - exchanged bytes in each longword of a 64-bit data block
 *                      on little-endian machines where byte order is reversed
 */
#ifdef  LITTLE_ENDIAN
#define bswap(cb) {                             \
        register char   c;                      \
        c = cb[0]; cb[0] = cb[3]; cb[3] = c;    \
        c = cb[1]; cb[1] = cb[2]; cb[2] = c;    \
        c = cb[4]; cb[4] = cb[7]; cb[7] = c;    \
        c = cb[5]; cb[5] = cb[6]; cb[6] = c;    \
}
#endif

/*
 *	setlokikey(key) - save 64-bit key for use in encryptions & decryptions
 */

void
setlokikey(key)
char	key[LOKIBLK];		/* Key to use, stored as an array of Longs    */
{
#ifdef LITTLE_ENDIAN
	bswap(key);			/* swap bytes round if little-endian */
#endif

	lokikey[0] = ((Long *)key)[0];
	lokikey[1] = ((Long *)key)[1];

#if	TRACE >= 1
	fprintf(stderr,"  keyinit(%08lx, %08lx)\n", lokikey[0], lokikey[1]);
#endif

#ifdef LITTLE_ENDIAN
	bswap(key);			/* swap bytes back if little-endian */
#endif
}


/*
 *	enloki(b) - main LOKI89 encryption routine, this routine encrypts one 
 *		64-bit block b using the LOKI89 algorithm with lokikey
 *
 *		The encryption operation involves XOR'ing the input block with
 *		the key, applying a LOKI89 round sixteen times
 *		(which ensures the output is a complex function of the input,
 *		and the key), and finally XOR'ing the input block with the key
 *
 *		Each round performs the following calculation using a 48-bit
 *		subkeys:
 *			L(i) = R(i-1)
 *			R(i) = L(i-1) XOR f(R(i-1), K(i))
 *
 *		To save swapping, alternate calls to f use L & R respectively
 *
 *		nb: The 64-bit block is passed as two longwords. For the
 *			purposes of the LOKI89 algorithm, the bits are numbered:
 *			    [63 62 .. 33 32] [31 30 ... 1 0]
 *			The L (left) half is b[0], the R (right) half is b[1]
 *
 */
void
enloki(b)
char	b[LOKIBLK];
{
	register Long	L, R;			/* left & right data halves  */
	register Long	KL, KR;			/* left & right key  halves  */

#ifdef LITTLE_ENDIAN
	bswap(b);			/* swap bytes round if little-endian */
#endif

#if	TRACE >= 1
	fprintf(stderr,"  enloki(%08lx, %08lx)\n", ((Long *)b)[0], ((Long *)b)[1]);
#endif

	KL = lokikey[0];			/* load keys in register vars */
	KR = lokikey[1];

	L = ((Long *)b)[0] ^ KL;		/* LR = X XOR K */
	R = ((Long *)b)[1] ^ KR;

	/* Perform the 16 rounds using sub-keys in usual order               */
	L ^= f(R, KL);	ROL12(KL);		
	R ^= f(L, KR);	ROL12(KR);
	L ^= f(R, KL);	ROL12(KL);		
	R ^= f(L, KR);	ROL12(KR);
	L ^= f(R, KL);	ROL12(KL);		
	R ^= f(L, KR);	ROL12(KR);
	L ^= f(R, KL);	ROL12(KL);		
	R ^= f(L, KR);	ROL12(KR);
	L ^= f(R, KL);	ROL12(KL);		
	R ^= f(L, KR);	ROL12(KR);
	L ^= f(R, KL);	ROL12(KL);		
	R ^= f(L, KR);	ROL12(KR);
	L ^= f(R, KL);	ROL12(KL);		
	R ^= f(L, KR);	ROL12(KR);
	L ^= f(R, KL);	ROL12(KL);		
	R ^= f(L, KR);	ROL12(KR);

	((Long *)b)[0] = R ^ KR;		/* Y = swap(LR) XOR K */
	((Long *)b)[1] = L ^ KL;

#if	TRACE >= 1
	fprintf(stderr,"  enloki returns %08lx, %08lx\n", ((Long *)b)[0], ((Long *)b)[1]);
#endif

#ifdef LITTLE_ENDIAN
	bswap(b);			/* swap bytes round if little-endian */
#endif
}


/*
 *	deloki(b) - main LOKI89 decryption routine, this routine decrypts one 
 *		64-bit block b using the LOKI89 algorithm with lokikey
 *
 *		Decryption uses the same algorithm as encryption, except that
 *		the subkeys are used in reverse order.
 */
void
deloki(b)
char	b[LOKIBLK];
{
	register Long	L, R;			/* left & right data halves  */
	register Long	KL, KR;			/* left & right key  halves  */

#ifdef LITTLE_ENDIAN
	bswap(b);			/* swap bytes round if little-endian */
#endif

#if	TRACE >= 1
	fprintf(stderr,"  deloki(%08lx, %08lx)\n", ((Long *)b)[0], ((Long *)b)[1]);
#endif

	KL = lokikey[0];			/* load keys in register vars */
	KR = lokikey[1];

	L = ((Long *)b)[0] ^ KR;		/* LR = X XOR K */
	R = ((Long *)b)[1] ^ KL;

	/* Perform the 16 rounds using sub-keys in usual order               */
	ROR12(KR);	L ^= f(R, KR);
	ROR12(KL);	R ^= f(L, KL);
	ROR12(KR);	L ^= f(R, KR);
	ROR12(KL);	R ^= f(L, KL);
	ROR12(KR);	L ^= f(R, KR);
	ROR12(KL);	R ^= f(L, KL);
	ROR12(KR);	L ^= f(R, KR);
	ROR12(KL);	R ^= f(L, KL);
	ROR12(KR);	L ^= f(R, KR);
	ROR12(KL);	R ^= f(L, KL);
	ROR12(KR);	L ^= f(R, KR);
	ROR12(KL);	R ^= f(L, KL);
	ROR12(KR);	L ^= f(R, KR);
	ROR12(KL);	R ^= f(L, KL);
	ROR12(KR);	L ^= f(R, KR);
	ROR12(KL);	R ^= f(L, KL);

	((Long *)b)[0] = R ^ KL;		/* Y = LR XOR K */
	((Long *)b)[1] = L ^ KR;

#if	TRACE >= 1
	fprintf(stderr,"  deloki returns %08lx, %08lx\n", ((Long *)b)[0], ((Long *)b)[1]);
#endif

#ifdef LITTLE_ENDIAN
	bswap(b);			/* swap bytes round if little-endian */
#endif
}


/*
 *	f(r, k) - is the complex non-linear LOKI89 function, whose output
 *		is a complex function of both input data and sub-key.
 *		The input data R(i-1) is:
 *			added modulo 2 to the key K(i)
 *			expanded to 48-bits via expansion fn E
 *			substituted into the S-boxes
 *			permuted by P.
 *		ie the calculation is:
 *			A = E(R(i-1) XOR K(i))		(a 48-bit value)
 *			B = S(A)			(a 32-bit value)
 *			f = P(B)			(a 32-bit value)
 *
 *	nb: the 12-bit S-box input value [x x x x 11 10 9 ... 3 2 1 0]
 *	    is interpreted as:
 *		bits [11 10 1 0] select 1 of 16 rows within each box,
 *		bits [9 8 ... 3 2] then select a column within that row
 */

#define MASK12	0x0fff			/* 12 bit mask for expansion E */

static Long
f(r, k)
register Long	r;	/* Data value R(i-1) */
Long		k;	/* Key     K(i)   */
{
	Long	a, b, c;		/* 32 bit S-box output, & P output */

	a = r ^ k;			/* A = R(i-1) XOR K(i) */

	/* want to use slow speed/small size version */
	b = ((Long)s((a         & MASK12))      ) | /* B = S(E(R(i-1))^K(i)) */
	    ((Long)s(((a >>  8) & MASK12)) <<  8) |
	    ((Long)s(((a >> 16) & MASK12)) << 16) |
	    ((Long)s((((a >> 24) | (a << 8)) & MASK12)) << 24);

	perm32(&c, &b, P);		/* C = P(S( E(R(i-1)) XOR K(i))) */

#if	TRACE >= 2	/* If Tracing, dump A, K(i), and f(R(i-1),K(i)) */
	fprintf(stderr,"  f(%08lx, %08lx) = P.S(%08lx) = P(%08lx) = %08lx\n",
		r, k, a, b, c);
#endif

	return(c);			/* f returns the result C */
}


/*
 *	s(i) - return S-box value for input i
 */
static short s(i)
register Long i;	/* return S-box value for input i */
{
	register short	r, c, v, t;
	short	exp8();		/* exponentiation routine for GF(2^8) */
	
	r = ((i>>8) & 0xc) | (i & 0x3);		/* row value */
	c = (i>>2) & 0xff;			/* column value */
	t = c ^ r;				/* base value for Sfn */
	v = exp8(t, sfn[r].exp, sfn[r].gen);	/* Sfn[r] = t ^ exp mod gen */
#if TRACE >= 3
	fprintf(stderr, "   s(%lx=[%d,%d]) = %x sup %d mod %d = %x\n",
			i, r, c, t, sfn[r].exp, sfn[r].gen, v);
#endif
	return(v);
}

/*
 *	perm32(out, in, perm) is the general permutation of a 32-bit input
 *		block to a 32-bit output block, under the control of a 
 *		permutation array perm. Each element of perm specifies which
 *		input bit is to be permuted to the output bit with the same
 *		index as the array element.
 *
 *	nb: to set bits in the output word, as mask with a single 1 in it is
 *		used. On each step, the 1 is shifted into the next location
 */

#define	MSB	0x80000000L		/* MSB of 32-bit word */

perm32(out, in , perm)
Long	*out;		/* Output 32-bit block to be permuted                */
Long	*in;		/* Input  32-bit block after permutation             */
char	perm[32]; 	/* Permutation array                                 */
{
	Long	mask = MSB;		/* mask used to set bit in output    */
	register int	i, o, b;	/* input bit no, output bit no, value */
	register char	*p = perm;	/* ptr to permutation array  */

	*out = 0;			/* clear output block */
	for (o=0; o<32; o++) {		/* For each output bit position o */	
		i =(int)*p++;		/* get input bit permuted to output o */
		b = (*in >> i) & 01;	/* value of input bit i */
		if (b)			/* If the input bit i is set */
			*out |= mask;		/*  OR in mask to output i */
		mask >>= 1;			/* Shift mask to next bit    */
	}
}

/*
 *	mult8(a, b, gen) - returns the product of two binary
 *		strings a and b using the generator gen as the modulus
 *			mult = a * b mod gen
 *		gen generates a suitable Galois field in GF(2^8)
 */

#define SIZE 256		/* 256 elements in GF(2^8) */

short mult8(a, b, gen)
short	a, b;		/* operands for multiply */
short	gen;		/* irreducible polynomial generating Galois Field */
{
	short	product = 0;		/* result of multiplication */

	while(b != 0) {			/* while multiplier is non-zero */
		if (b & 01)
			product ^= a;	/*   add multiplicand if LSB of b set */
		a <<= 1;		/*   shift multiplicand one place */
		if (a >= SIZE)
			a ^= gen;	/*   and modulo reduce if needed */
		b >>= 1;		/*   shift multiplier one place  */
	}
	return(product);
}

/*
 *	exp8(base, exponent, gen) - returns the result of
 *		exponentiation given the base, exponent, generator of GF,
 *			exp = base ^ exp mod gen
 */

short exp8(base, exponent, gen)
short	base;		/* base of exponentiation 	*/
short	exponent;	/* exponent			*/
short	gen;		/* irreducible polynomial generating Galois Field */
{
	short	accum = base;	/* superincreasing sequence of base */
	short	result = 1;	/* result of exponentiation	    */

	if (base == 0)		/* if zero base specified then      */
		return(0);	/* the result is "0" if base = 0    */

	while (exponent != 0) {	/* repeat while exponent non-zero */
		if (( exponent & 0x0001) == 0x0001)	/* multiply if exp 1 */
			result = mult8(result, accum, gen);
		exponent >>= 1;		/* shift exponent to next digit */
		accum = mult8(accum, accum, gen);	/* & square  */
	}
	return(result);
}
\Rogue\Monster\
else
  echo "will not over write ./loki89.c"
fi
if `test ! -s ./loki91.c`
then
echo "writing ./loki91.c"
cat > ./loki91.c << '\Rogue\Monster\'
/*
 *	loki91.c - library routines for a 64 bit LOKI89 implementation
 *
 * Designed by  Matthew Kwan <mkwan@crypto.cs.adfa.oz.au> and
 *		Lawrence Brown <lpb@cs.adfa.oz.au>

 *  Modifications:
 *		v2.0 - original set of code by mkwan 9/91
 *		v3.0 - support both LOKI89 & LOKI91 versions   10/92 lpb
 *
 *  Copyright 1991 by Lawrence Brown and UNSW. All rights reserved.
 *      This program may not be sold or used as inducement to buy a
 *      product without the written permission of the author.
 *
 *	nb: if this program is compiled on a little-endian machine (eg Vax)
 *		#define LITTLE_ENDIAN
 *		in order to enable the byte swapping  routines 
 *
 *	    if a detailed trace of LOKI91 function f is required for debugging
 *		#define TRACE=n		n=1 print blocks, n=2 print fn f also
 *                                      n=3 print individual S-box calcs also
 *
 *	    these routines assume that the 8-byte char arrays used to pass
 *		the 64-bit blocks fall on a word boundary, so that the blocks
 *		may be read as longwords for efficiency reasons. If this is
 *		not true, the load & save of the parameters will need changing.
 */


#include <stdio.h>
#include "loki.h"	/* include Interface Specification header file */
#include "loki.i"	/* include Interface Specification header file */

/*
 *	string specifying version and copyright message
 */
char	*loki_lib_ver = "LOKI91 library v3.0, Copyright (C) 1991 Lawrence Brown & UNSW";

Long	loki_subkeys[ROUNDS];		/* subkeys at the 16 rounds */
static Long	f();			/* declare LOKI function f */
static short	s();			/* declare LOKI S-box fn s */


/*
 *	ROL12(b) - macro to rotate 32-bit block b left by 12 bits
 *	ROL13(b) - macro to rotate 32-bit block b left by 13 bits
 */

#define ROL12(b) b = ((b << 12) | (b >> 20));
#define ROL13(b) b = ((b << 13) | (b >> 19));

/*
 *      bswap(b) - exchanged bytes in each longword of a 64-bit data block
 *                      on little-endian machines where byte order is reversed
 */
#ifdef  LITTLE_ENDIAN
#define bswap(cb) {                             \
        register char   c;                      \
        c = cb[0]; cb[0] = cb[3]; cb[3] = c;    \
        c = cb[1]; cb[1] = cb[2]; cb[2] = c;    \
        c = cb[4]; cb[4] = cb[7]; cb[7] = c;    \
        c = cb[5]; cb[5] = cb[6]; cb[6] = c;    \
}
#endif

/*
 *	setlokikey(key) - save 64-bit key for use in encryptions & decryptions
 *			  and compute sub-keys using the key schedule 
 */

void
setlokikey(key)
char	key[LOKIBLK];		/* Key to use, stored as an array of Longs    */
{
	register	i;
	register Long	KL, KR;

#ifdef LITTLE_ENDIAN
	bswap(key);			/* swap bytes round if little-endian */
#endif

#if	TRACE >= 1
	fprintf(stderr,"  keyinit(%08lx, %08lx)\n", ((Long *)key)[0], ((Long *)key)[1]);
#endif

	KL = ((Long *)key)[0];
	KR = ((Long *)key)[1];

	for (i=0; i<ROUNDS; i+=4) {	/* Generate the 16 subkeys */
	    loki_subkeys[i] = KL;
	    ROL12 (KL);
	    loki_subkeys[i+1] = KL;
	    ROL13 (KL);
	    loki_subkeys[i+2] = KR;
	    ROL12 (KR);
	    loki_subkeys[i+3] = KR;
	    ROL13 (KR);
	}

#ifdef LITTLE_ENDIAN
	bswap(key);			/* swap bytes back if little-endian */
#endif
}


/*
 *	enloki(b) - main LOKI91 encryption routine, this routine encrypts one 
 *		64-bit block b using the LOKI91 algorithm with loki_subkeys
 *
 *		nb: The 64-bit block is passed as two longwords. For the
 *			purposes of the LOKI89 algorithm, the bits are numbered:
 *			    [63 62 .. 33 32] [31 30 ... 1 0]
 *			The L (left) half is b[0], the R (right) half is b[1]
 *
 */

void
enloki (b)
char	b[LOKIBLK];
{
	register	i;
	register Long	L, R;		/* left & right data halves  */

#ifdef LITTLE_ENDIAN
	bswap(b);			/* swap bytes round if little-endian */
#endif

#if	TRACE >= 1
	fprintf(stderr,"  enloki(%08lx, %08lx)\n", ((Long *)b)[0], ((Long *)b)[1]);
#endif

	L = ((Long *)b)[0];
	R = ((Long *)b)[1];

	for (i=0; i<ROUNDS; i+=2) {	/* Encrypt with the 16 subkeys */
	    L ^= f (R, loki_subkeys[i]);
	    R ^= f (L, loki_subkeys[i+1]);
	}

	((Long *)b)[0] = R;		/* Y = swap(LR) */
	((Long *)b)[1] = L;

#if	TRACE >= 1
	fprintf(stderr,"  enloki returns %08lx, %08lx\n", ((Long *)b)[0], ((Long *)b)[1]);
#endif

#ifdef LITTLE_ENDIAN
	bswap(b);			/* swap bytes round if little-endian */
#endif
}


/*
 *	deloki(b) - main LOKI91 decryption routine, this routine decrypts one 
 *		64-bit block b using the LOKI91 algorithm with loki_subkeys
 *
 *		Decryption uses the same algorithm as encryption, except that
 *		the subkeys are used in reverse order.
 */
void
deloki(b)
char	b[LOKIBLK];
{
	register	i;
	register Long	L, R;			/* left & right data halves  */

#ifdef LITTLE_ENDIAN
	bswap(b);			/* swap bytes round if little-endian */
#endif

#if	TRACE >= 1
	fprintf(stderr,"  deloki(%08lx, %08lx)\n", ((Long *)b)[0], ((Long *)b)[1]);
#endif

	L = ((Long *)b)[0];			/* LR = X XOR K */
	R = ((Long *)b)[1];

	for (i=ROUNDS; i>0; i-=2) {		/* subkeys in reverse order */
	    L ^= f(R, loki_subkeys[i-1]);
	    R ^= f(L, loki_subkeys[i-2]);
	}

	((Long *)b)[0] = R;			/* Y = LR XOR K */
	((Long *)b)[1] = L;

#if	TRACE >= 1
	fprintf(stderr,"  deloki returns %08lx, %08lx\n", ((Long *)b)[0], ((Long *)b)[1]);
#endif

#ifdef LITTLE_ENDIAN
	bswap(b);			/* swap bytes round if little-endian */
#endif
}


/*
 *	f(r, k) - is the complex non-linear LOKI function, whose output
 *		is a complex function of both input data and sub-key.
 *
 *	The data is XORed with the subkey, then expanded into 4 x 12-bit
 *	values, which are fed into the S-boxes. The 4 x 8-bit outputs
 *	from the S-boxes are permuted together to form the 32-bit value
 *	which is returned.
 *
 *	In this implementation the outputs from the S-boxes have been
 *	pre-permuted and stored in lookup tables.
 */

#define MASK12	0x0fff			/* 12 bit mask for expansion E */

static Long
f(r, k)
register Long	r;	/* Data value R(i-1) */
Long		k;	/* Key     K(i)   */
{
	Long	a, b, c;		/* 32 bit S-box output, & P output */

	a = r ^ k;			/* A = R(i-1) XOR K(i) */

	/* want to use slow speed/small size version */
	b = ((Long)s((a         & MASK12))      ) | /* B = S(E(R(i-1))^K(i)) */
	    ((Long)s(((a >>  8) & MASK12)) <<  8) |
	    ((Long)s(((a >> 16) & MASK12)) << 16) |
	    ((Long)s((((a >> 24) | (a << 8)) & MASK12)) << 24);

	perm32(&c, &b, P);		/* C = P(S( E(R(i-1)) XOR K(i))) */

#if	TRACE >= 2	/* If Tracing, dump A, K(i), and f(R(i-1),K(i)) */
	fprintf(stderr,"  f(%08lx, %08lx) = P.S(%08lx) = P(%08lx) = %08lx\n",
		r, k, a, b, c);
#endif

	return(c);			/* f returns the result C */
}


/*
 *	s(i) - return S-box value for input i
 */
static short s(i)
register Long i;	/* return S-box value for input i */
{
	register short	r, c, v, t;
	short	exp8();		/* exponentiation routine for GF(2^8) */
	
	r = ((i>>8) & 0xc) | (i & 0x3);		/* row value-top 2 & bottom 2 */
	c = (i>>2) & 0xff;			/* column value-middle 8 bits */
	t = (c + ((r * 17) ^ 0xff)) & 0xff;	/* base value for Sfn */
	v = exp8(t, sfn[r].exp, sfn[r].gen);	/* Sfn[r] = t ^ exp mod gen */
#if TRACE >= 3
	fprintf(stderr, "   s(%lx=[%d,%d]) = %x sup %d mod %d = %x\n",
			i, r, c, t, sfn[r].exp, sfn[r].gen, v);
#endif
	return(v);
}

/*
 *	perm32(out, in, perm) is the general permutation of a 32-bit input
 *		block to a 32-bit output block, under the control of a 
 *		permutation array perm. Each element of perm specifies which
 *		input bit is to be permuted to the output bit with the same
 *		index as the array element.
 *
 *	nb: to set bits in the output word, as mask with a single 1 in it is
 *		used. On each step, the 1 is shifted into the next location
 */

#define	MSB	0x80000000L		/* MSB of 32-bit word */

perm32(out, in , perm)
Long	*out;		/* Output 32-bit block to be permuted                */
Long	*in;		/* Input  32-bit block after permutation             */
char	perm[32]; 	/* Permutation array                                 */
{
	Long	mask = MSB;		/* mask used to set bit in output    */
	register int	i, o, b;	/* input bit no, output bit no, value */
	register char	*p = perm;	/* ptr to permutation array  */

	*out = 0;			/* clear output block */
	for (o=0; o<32; o++) {		/* For each output bit position o */	
		i =(int)*p++;		/* get input bit permuted to output o */
		b = (*in >> i) & 01;	/* value of input bit i */
		if (b)			/* If the input bit i is set */
			*out |= mask;		/*  OR in mask to output i */
		mask >>= 1;			/* Shift mask to next bit    */
	}
}


/*
 *	mult8(a, b, gen) - returns the product of two binary
 *		strings a and b using the generator gen as the modulus
 *			mult = a * b mod gen
 *		gen generates a suitable Galois field in GF(2^8)
 */

#define SIZE 256		/* 256 elements in GF(2^8) */

short mult8(a, b, gen)
short	a, b;		/* operands for multiply */
short	gen;		/* irreducible polynomial generating Galois Field */
{
	short	product = 0;		/* result of multiplication */

	while(b != 0) {			/* while multiplier is non-zero */
		if (b & 01)
			product ^= a;	/*   add multiplicand if LSB of b set */
		a <<= 1;		/*   shift multiplicand one place */
		if (a >= SIZE)
			a ^= gen;	/*   and modulo reduce if needed */
		b >>= 1;		/*   shift multiplier one place  */
	}
	return(product);
}

/*
 *	exp8(base, exponent, gen) - returns the result of
 *		exponentiation given the base, exponent, generator of GF,
 *			exp = base ^ exp mod gen
 */

short exp8(base, exponent, gen)
short	base;		/* base of exponentiation 	*/
short	exponent;	/* exponent			*/
short	gen;		/* irreducible polynomial generating Galois Field */
{
	short	accum = base;	/* superincreasing sequence of base */
	short	result = 1;	/* result of exponentiation	    */

	if (base == 0)		/* if zero base specified then      */
		return(0);	/* the result is "0" if base = 0    */

	while (exponent != 0) {	/* repeat while exponent non-zero */
		if (( exponent & 0x0001) == 0x0001)	/* multiply if exp 1 */
			result = mult8(result, accum, gen);
		exponent >>= 1;		/* shift exponent to next digit */
		accum = mult8(accum, accum, gen);	/* & square  */
	}
	return(result);
}
\Rogue\Monster\
else
  echo "will not over write ./loki91.c"
fi
if `test ! -s ./lokicert.c`
then
echo "writing ./lokicert.c"
cat > ./lokicert.c << '\Rogue\Monster\'
/*
 *	lokicert.c - invoke the LOKI library with data from a certification
 *		database, to validate its correct operation.
 *
 *  Author: Lawrence Brown <lpb@cs.adfa.oz.au>      Dec 1987
 *      Computer Science, UC UNSW, Australian Defence Force Academy,
 *          Canberra, ACT 2600, Australia.
 *
 *	Based on PD program by Phil Karn, KA9Q <karn@flash.bellcore.com>
 *
 *  Copyright 1989 by Lawrence Brown and UNSW. All rights reserved.
 *      This program may not be sold or used as inducement to buy a
 *      product without the written permission of the author.
 */


#include "loki.h"
#include <stdio.h>

#ifndef lint
static char rcsid[]  = "$Header: lokicert.c,v 2.1 90/07/18 10:51:41 lpb Exp $";
#endif

char	*Name = "";		/* name this program was called by */
char	*usage = "lokicert [testfile]";
FILE	*filein = stdin;	/* input file to be processed                */

main(argc, argv)
int	argc;
char	**argv;
{
	char	ikey[20], iplain[20], ianswer[20];
	Long	key[2],plain[2],cipher[2],answer[2];
	int	test = 0,			/* current test number*/
		fail = 0,			/* failure indicator  */
		failcnt = 0;			/* count of failures  */
	char	buf[256];			/* input buffer, hex block */

	/* parse input args if any */
	Name = argv[0];
	if (argc > 1) {			/* get input file name */
        	if ((filein = fopen(argv[1], "r")) == NULL) {
                	fprintf(stderr,"%s: unable to open input file %s\n",
				Name, argv[1]);
			perror(Name);
			exit(1);
		}
	}

	while ( fgets(buf, sizeof(buf), filein) != NULL) { /* read next line  */
		if (buf[0] == '#')
			continue;	/* skip comment lines                 */
		test++;
	    	sscanf(buf, "%s %s %s", ikey, iplain, ianswer);
		get8(ikey, (char *)key);
		get8(iplain, (char *)plain);
		get8(ianswer, (char *)answer);

		printf("Test %2d, ", test);
		printf(" K: "); put8((char *)key);
		printf(" P: "); put8((char *)plain);
		printf(" C: "); put8((char *)answer);

		setlokikey((char *)key);

		cipher[0] = plain[0]; cipher[1] = plain[1];
		enloki((char *)cipher);

		fail = 0;
		if ((cipher[0] != answer[0]) || (cipher[1] != answer[1])) {
			printf("Encrypt failed, got: "); 
			put8((char *)cipher);
			fail++;
		} 

		deloki((char *)cipher);

		if ((cipher[0] != plain[0]) || (cipher[1] != plain[1])) {
			printf("Decrypt failed, got: "); 
			put8((char *)cipher);
			fail++;
		}

		if (!fail)
			printf("OK");
		else
			failcnt++;
		printf("\n");
		fflush(stdout);
	}
	printf("lokicert: %d failures in %d tests\n", failcnt, test);
	exit(failcnt);				/* exit with status set */
}

get8(inp, cp)
char *inp, *cp;
{
	int i,t[8];

	sscanf(inp, "%2x%2x%2x%2x%2x%2x%2x%2x",
		&t[0], &t[1], &t[2], &t[3], &t[4], &t[5], &t[6], &t[7]);
	for(i=0;i<8;i++){
		cp[i] = t[i];
	}
}

put8(cp)
char *cp;
{
	int i;

	for(i=0;i<8;i++){
		printf("%02x",*cp++ & 0xff);
	}
	putchar(' ');
}
\Rogue\Monster\
else
  echo "will not over write ./lokicert.c"
fi
if `test ! -s ./single89`
then
echo "writing ./single89"
cat > ./single89 << '\Rogue\Monster\'
#	Single LOKI89 Certification triplet
#		data is saved as (key, plaintext, ciphertext) triplets
#
5b5a57676a56676e 675a69675e5a6b5a 3c61fa7e2e99d048 
\Rogue\Monster\
else
  echo "will not over write ./single89"
fi
if `test ! -s ./single91`
then
echo "writing ./single91"
cat > ./single91 << '\Rogue\Monster\'
#	Single LOKI91 Certification triplet
#		data is saved as (key, plaintext, ciphertext) triplets
#
3849674c2602319e 126898d55e911500 c86caec1e3b7b17e 
\Rogue\Monster\
else
  echo "will not over write ./single91"
fi
if `test ! -s ./triples89`
then
echo "writing ./triples89"
cat > ./triples89 << '\Rogue\Monster\'
#
#       LOKI89 Validation Data Suite Triples
#       data is saved as (key, plaintext, ciphertext) triplets
#
0000000000000000 0000000000000000 0000000000000000 
0000000000000000 355550b2150e2451 8e2a251b94704c69 
0000000000000000 35a7bae825c0d73b 8ca64de9c1b123a7 
0000000000000000 8ca64de9c1b123a7 35a7bae825c0d73b 
0000000000000000 8e2a251b94704c69 355550b2150e2451 
0000000000000000 ffffffffffffffff 61f38c55061e3161 
0101010101010101 0123456789abcdef f60b54c240d7ed14 
0101010101010101 617b3a0ce8f07100 38ae088ae853f7fb 
0101010101010101 9b38f6ce85aab9c3 617b3a0ce8f07100 
0113b970fd34f2ce 059b5e0851cf143a 88c37b8c809c6dcd 
0113b970fd34f2ce 7514cdb961b6760d 86a560f10ec6d85b 
0113b970fd34f2ce 86a560f10ec6d85b 23e9b229fdea123f 
0123456789abcdef 0000000000000000 d853533a6c1beb30 
0123456789abcdef 1111111111111111 c4d29774e5d5247c 
0123456789abcdef 17668dfc7292532d cc9feed345a9f7a1 
0123456789abcdef 23c086665917b8e1 17668dfc7292532d 
0123456789abcdef d5d44ff720683d0d 13d2967efa3aa3c2 
0123456789abcdef fce30226576320bd d5d44ff720683d0d 
0131d9619dc1376e 5cd54ca83def57da c251a566d109cfc2 
0131d9619dc1376e 65e160aed7b773a9 7a389d10354bd271 
0131d9619dc1376e 7a389d10354bd271 94c33356f2ee1adf 
0170f175468fb5e6 0756d8e0774761d2 49a480651f03b452 
0170f175468fb5e6 0cd3da020021dc09 afec86ec719000ad 
0170f175468fb5e6 914c1806fccbce33 0cd3da020021dc09 
018310dc409b26d6 1d9d5c5018f728c2 87bd17440173768b 
018310dc409b26d6 5a0bf934fd6009f8 5f4c038ed12b2e41 
018310dc409b26d6 5f4c038ed12b2e41 773740aa56ef058e 
025816164629b007 480d39006ee762f2 719ebffea9a16c35 
025816164629b007 a1f9915541020b56 16f949d4011073b5 
025816164629b007 ec92e65da168b46f a1f9915541020b56 
04689104c2fd3b2f 26955f6835af609a 8139b3c65393ea37 
04689104c2fd3b2f 5265227fe08a28ec 5c513c9c4886c088 
04689104c2fd3b2f 5c513c9c4886c088 bfd4c8c383533bdb 
04b915ba43feb5b6 42fd443059577fa2 e7244bf3b0e5715d 
04b915ba43feb5b6 a483ea7ccf2e0e5a af37fb421f8c4095 
04b915ba43feb5b6 af37fb421f8c4095 762bd5f9b296f82e 
07a1133e4a0b2686 0248d43806f67172 dd02c943fb4537a3 
07a1133e4a0b2686 624f2e2dfa008142 868ebb51cab4599a 
07a1133e4a0b2686 868ebb51cab4599a 235c5997034a503d 
07a7137045da2a16 28e686668c3bd6d9 dfd64a815caf1a0f 
07a7137045da2a16 3bdd119049372802 3de59f157f8b6bf9 
07a7137045da2a16 dfd64a815caf1a0f 00b3f10e6f1063ed 
1111111111111111 0123456789abcdef b0c9897c2765e214 
1111111111111111 1111111111111111 f0a12c83c4529223 
1111111111111111 24900548c21a3567 f40379ab9e0ec533 
1111111111111111 8a5ae1f81ab8f2dd a273d7cb7d390531 
1111111111111111 a273d7cb7d390531 8a5ae1f81ab8f2dd 
1111111111111111 f40379ab9e0ec533 24900548c21a3567 
1c587f1c13924fef 305532286d6f295a 8b62933a45dcf71f 
1c587f1c13924fef 63fac0d034d9f793 b061dff8054771a8 
1c587f1c13924fef f63de067f58c38ed 63fac0d034d9f793 
1f08260d1ac2465e 2c0a241eb9f05999 ef1bf03e5dfa575a 
1f08260d1ac2465e 6b056e18759f5cca c07261a9596039c3 
1f08260d1ac2465e ef1bf03e5dfa575a b8705cc3a19ae567 
1f1f1f1f0e0e0e0e 0123456789abcdef 16be5183d694e578 
1f1f1f1f0e0e0e0e 322f206b2d39d65d db958605f8c8c606 
1f1f1f1f0e0e0e0e db958605f8c8c606 1c37794afacf9e4e 
3000000000000000 1000000000000001 85884d224ec9e63d 
3000000000000000 958e6e627a05557b 389b4e8dc846c4aa 
3000000000000000 d3c4539579b96231 958e6e627a05557b 
37d06bb516cb7546 0a2aeeae3ff4ab77 45127fb1f43c5304 
37d06bb516cb7546 164d5e404f275232 70f6cf2136677443 
37d06bb516cb7546 19acae3136c0bc7c 0a2aeeae3ff4ab77 
3849674c2602319e 126898d55e911500 7178876e01f19b2a 
3849674c2602319e 51454b582ddf440a 57df30a9420a50ee 
3849674c2602319e 7178876e01f19b2a 9ca72dbcd502b0ba 
43297fad38e373fe 4c974f1caa59f5d4 ea676b2cb7db2b7a 
43297fad38e373fe 762514b829bf486a 1d3eba477e45f553 
43297fad38e373fe ea676b2cb7db2b7a 547018835947a9b3 
49793ebc79b3258f 437540c8698f3cfa 7ce143bcd1108178 
49793ebc79b3258f 6fbf1cafcffd0556 315e66ab98b26ded 
49793ebc79b3258f a0cb2871752053f0 6fbf1cafcffd0556 
49e95d6d4ca229bf 00b0024eaac70ae3 5a6b612cc26cce4a 
49e95d6d4ca229bf 02fe55778117f12a 85028e1e6b858ec4 
49e95d6d4ca229bf 5a6b612cc26cce4a 1b1789391a840fea 
4fb05e1515ab73a7 072d43a077075292 cfeeb0bdeb67fef4 
4fb05e1515ab73a7 2f22e49bab7ca1ac 237c628bb6892693 
4fb05e1515ab73a7 ad87789bc00718c2 2f22e49bab7ca1ac 
584023641aba6176 004bd6ef09176062 fcdebb14f3b2babb 
584023641aba6176 88bf0db6d70dee56 d09730ee2f16f0d1 
584023641aba6176 c7d2845ea6d01c70 88bf0db6d70dee56 
5b5a57676a56676e 974affbf86022d1f 429941c32d5126e8 
7ca110454a1a6e57 01a1d6d039776742 098c16c1e1f4a681 
7ca110454a1a6e57 690f5b0d9a26939b c10935a58a249fbb 
7ca110454a1a6e57 ecd1c2f929f33ced 690f5b0d9a26939b 
e0fee0fef1fef1fe 0123456789abcdef e29d11faf2d133ce 
e0fee0fef1fef1fe b7687facf9b1a656 edbfd1c66c29ccc7 
e0fee0fef1fef1fe edbfd1c66c29ccc7 c0f43c83cce0e0df 
fedcba9876543210 0123456789abcdef cfee5c8eb79153d9 
fedcba9876543210 2a2bb008df97c2f2 63f983b15c642726 
fedcba9876543210 7f46aa73f7fcde02 2a2bb008df97c2f2 
fedcba9876543210 c44c1b3668a0f2cf ed39d950fa74bcc4 
fedcba9876543210 ed39d950fa74bcc4 7420eb3d2a7aa178 
fedcba9876543210 ffffffffffffffff fce524b60ec5b3fc 
ffffffffffffffff 0000000000000000 0000000000000000 
ffffffffffffffff 16b15028f06a5ab8 caaaaf4deaf1dbae 
ffffffffffffffff 3c7188775253884d 7359b2163e4edc58 
ffffffffffffffff 7359b2163e4edc58 3c7188775253884d 
ffffffffffffffff caaaaf4deaf1dbae 16b15028f06a5ab8 
ffffffffffffffff ffffffffffffffff 61f38c55061e3161 
\Rogue\Monster\
else
  echo "will not over write ./triples89"
fi
if `test ! -s ./triples91`
then
echo "writing ./triples91"
cat > ./triples91 << '\Rogue\Monster\'
#
#       LOKI91 Validation Data Suite Triples
#       data is saved as (key, plaintext, ciphertext) triplets
#
# List of weak and semi-weak keys
#
#  Weak Keys
#
0000000000000000 0000000000000000 bd84a2085ef609c7 
0000000000000000 bd84a2085ef609c7 0000000000000000 
ffffffffffffffff 0000000000000000 5c77e002d1991c4d 
ffffffffffffffff 5c77e002d1991c4d 0000000000000000 
55555555aaaaaaaa 0000000000000000 71fd6dc44bf4e881 
55555555aaaaaaaa 71fd6dc44bf4e881 0000000000000000 
aaaaaaaa55555555 0000000000000000 65b38fdc551b2576 
aaaaaaaa55555555 65b38fdc551b2576 0000000000000000 
#
# Semi-Weak Keys
#
0000000055555555 0000000000000000 85d84cad08342044 
0000000055555555 8621ccb894705f8f 0000000000000000 
aaaaaaaa00000000 0000000000000000 8621ccb894705f8f 
aaaaaaaa00000000 85d84cad08342044 0000000000000000 
#
00000000aaaaaaaa 0000000000000000 971fe23b8904399b 
00000000aaaaaaaa e10c4efc9d4c9b52 0000000000000000 
5555555500000000 0000000000000000 e10c4efc9d4c9b52 
5555555500000000 971fe23b8904399b 0000000000000000 
#
00000000ffffffff 0000000000000000 ca30a526e3bf6fe9 
00000000ffffffff 9cc24ace4d477f39 0000000000000000 
ffffffff00000000 0000000000000000 9cc24ace4d477f39 
ffffffff00000000 ca30a526e3bf6fe9 0000000000000000 
#
5555555555555555 0000000000000000 bc85de5e486d7ddb 
5555555555555555 504d4c4fea439b63 0000000000000000 
aaaaaaaaaaaaaaaa 0000000000000000 504d4c4fea439b63 
aaaaaaaaaaaaaaaa bc85de5e486d7ddb 0000000000000000 
#
55555555ffffffff 0000000000000000 0bef28021cd23fcb 
55555555ffffffff baa5521bd8ff9f75 0000000000000000 
ffffffffaaaaaaaa 0000000000000000 baa5521bd8ff9f75 
ffffffffaaaaaaaa 0bef28021cd23fcb 0000000000000000 
#
aaaaaaaaffffffff 0000000000000000 a78c6f84509c4d9a 
aaaaaaaaffffffff 05dac4a04d83c0ab 0000000000000000 
ffffffff55555555 0000000000000000 05dac4a04d83c0ab 
ffffffff55555555 a78c6f84509c4d9a 0000000000000000 
#
# Inversion of all the key and plaintext bits results
#  in the inversion of all the ciphertext bits
#
0123456789abcdef 0000000000000000 d26de3321aaa29f6 
0123456789abcdef fcf597b7da5a3a3d 0000000000000000 
fedcba9876543210 ffffffffffffffff 2d921ccde555d609 
fedcba9876543210 030a684825a5c5c2 ffffffffffffffff 
#
# Other assorted values
#
0000000000000000 0000000000000000 bd84a2085ef609c7 
0000000000000000 bd84a2085ef609c7 0000000000000000 
0000000000000000 355550b2150e2451 3644dd20d5ba5d10 
0000000000000000 3644dd20d5ba5d10 355550b2150e2451 
0000000000000000 35a7bae825c0d73b 826ff28db7edf0a3 
0000000000000000 826ff28db7edf0a3 35a7bae825c0d73b 
0000000000000000 8ca64de9c1b123a7 fb3038a35a93646b 
0000000000000000 fb3038a35a93646b 8ca64de9c1b123a7 
0000000000000000 8e2a251b94704c69 4829a2faf34973e8 
0000000000000000 4829a2faf34973e8 8e2a251b94704c69 
0000000000000000 ffffffffffffffff a3881ffd2e66e3b2 
0000000000000000 a3881ffd2e66e3b2 ffffffffffffffff 
0101010101010101 0123456789abcdef 7935b683eada00f4 
0101010101010101 ec5960c9d3bf1e1e 0123456789abcdef 
0101010101010101 617b3a0ce8f07100 a6090c5f651d84ff 
0101010101010101 8eeb7798a291b0b3 617b3a0ce8f07100 
0101010101010101 9b38f6ce85aab9c3 2165fc9b5a4430d4 
0101010101010101 2143badadbd4f539 9b38f6ce85aab9c3 
0113b970fd34f2ce 059b5e0851cf143a f1f6daa4368d32c0 
0113b970fd34f2ce 313b8c589bcf2955 059b5e0851cf143a 
0113b970fd34f2ce 7514cdb961b6760d a2f3f0e425f6cd30 
0113b970fd34f2ce 31b8050defd959ce 7514cdb961b6760d 
0113b970fd34f2ce 86a560f10ec6d85b a27506525cf66e5c 
0113b970fd34f2ce 6566f294daf82c26 86a560f10ec6d85b 
0123456789abcdef 0000000000000000 d26de3321aaa29f6 
0123456789abcdef fcf597b7da5a3a3d 0000000000000000 
0123456789abcdef 1111111111111111 e1dd3b59134f32ab 
0123456789abcdef c7c0ea4a6a9d3360 1111111111111111 
0123456789abcdef 17668dfc7292532d 7aab3b9a42feceb2 
0123456789abcdef 0a9462fa8fee7f4a 17668dfc7292532d 
0123456789abcdef 23c086665917b8e1 9fbc1a193dcee02d 
0123456789abcdef 1cb728f0c1b26f75 23c086665917b8e1 
0123456789abcdef d5d44ff720683d0d 621f20a1884677f3 
0123456789abcdef c8c9a1ace8cf89dc d5d44ff720683d0d 
0123456789abcdef fce30226576320bd 5da683da7e9fd159 
0123456789abcdef 5edf1c8466ce6cca fce30226576320bd 
0131d9619dc1376e 5cd54ca83def57da 018781deb9ea97cc 
0131d9619dc1376e bd1084a4b6d1ab38 5cd54ca83def57da 
0131d9619dc1376e 65e160aed7b773a9 57e3c651e72c6d99 
0131d9619dc1376e aeab88168e9c0e3e 65e160aed7b773a9 
0131d9619dc1376e 7a389d10354bd271 5520951007ac3123 
0131d9619dc1376e 78eaddbfcb1ca8f2 7a389d10354bd271 
0170f175468fb5e6 0756d8e0774761d2 ab786040f925d13e 
0170f175468fb5e6 b7c1284ca7043dcb 0756d8e0774761d2 
0170f175468fb5e6 0cd3da020021dc09 77ce52c63517b689 
0170f175468fb5e6 802191063dd8ff06 0cd3da020021dc09 
0170f175468fb5e6 914c1806fccbce33 dd546f5263780633 
0170f175468fb5e6 5356fadab9832b2c 914c1806fccbce33 
018310dc409b26d6 1d9d5c5018f728c2 80d1106e854f7296 
018310dc409b26d6 0eb06d867b7034b3 1d9d5c5018f728c2 
018310dc409b26d6 5a0bf934fd6009f8 f67c664125809846 
018310dc409b26d6 9c1edf390e47f09a 5a0bf934fd6009f8 
018310dc409b26d6 5f4c038ed12b2e41 20a61c3bc186b0b2 
018310dc409b26d6 e93ae52452b20098 5f4c038ed12b2e41 
025816164629b007 480d39006ee762f2 8197cc96e066f971 
025816164629b007 8e67efe514fa5985 480d39006ee762f2 
025816164629b007 a1f9915541020b56 0e1b15aa45daad23 
025816164629b007 7b1bd88c59347ee4 a1f9915541020b56 
025816164629b007 ec92e65da168b46f fd5d36553cc7cdad 
025816164629b007 10f09ce8ec84f207 ec92e65da168b46f 
04689104c2fd3b2f 26955f6835af609a 082133fd6bfa1e88 
04689104c2fd3b2f 36153da8e8e4a67a 26955f6835af609a 
04689104c2fd3b2f 5265227fe08a28ec 1b03084901b20c14 
04689104c2fd3b2f f2e7e1a4678d10a7 5265227fe08a28ec 
04689104c2fd3b2f 5c513c9c4886c088 db8e496a8aa4eae8 
04689104c2fd3b2f 49a2827db6293c72 5c513c9c4886c088 
04b915ba43feb5b6 42fd443059577fa2 b794c8fec41d93fd 
04b915ba43feb5b6 688762c5782c8d46 42fd443059577fa2 
04b915ba43feb5b6 a483ea7ccf2e0e5a 1319804d5e6477fb 
04b915ba43feb5b6 a4407673e0289704 a483ea7ccf2e0e5a 
04b915ba43feb5b6 af37fb421f8c4095 5e1fbeca6d3dd240 
04b915ba43feb5b6 76f8a9d3d646b45a af37fb421f8c4095 
07a1133e4a0b2686 0248d43806f67172 bdc50f07265f98bb 
07a1133e4a0b2686 5352ea74d4f98d17 0248d43806f67172 
07a1133e4a0b2686 624f2e2dfa008142 43966fba71697d9e 
07a1133e4a0b2686 94e8f64562868d44 624f2e2dfa008142 
07a1133e4a0b2686 868ebb51cab4599a 2bc4d7ac9f09e2cf 
07a1133e4a0b2686 38df7d98c5841cb1 868ebb51cab4599a 
07a7137045da2a16 28e686668c3bd6d9 5ddb3c7fc1c8ce22 
07a7137045da2a16 a725d943d567693c 28e686668c3bd6d9 
07a7137045da2a16 3bdd119049372802 3f0db5539d36d6ff 
07a7137045da2a16 e617587ef5ec4992 3bdd119049372802 
07a7137045da2a16 dfd64a815caf1a0f a4af3b0773dad9be 
07a7137045da2a16 3000a06acca1e95c dfd64a815caf1a0f 
1111111111111111 0123456789abcdef 75f0c8bc2bafd309 
1111111111111111 46b19d48d8569e55 0123456789abcdef 
1111111111111111 1111111111111111 cc8a79bccae0bb7e 
1111111111111111 d96e387165e701bc 1111111111111111 
1111111111111111 24900548c21a3567 93f5dbd7f154b9ba 
1111111111111111 66b41b7d36c436de 24900548c21a3567 
1111111111111111 8a5ae1f81ab8f2dd 20f677bebabe1775 
1111111111111111 d96faf34f9f90454 8a5ae1f81ab8f2dd 
1111111111111111 a273d7cb7d390531 70ab8b1bc85a3535 
1111111111111111 44260ee8c8eeb426 a273d7cb7d390531 
1111111111111111 f40379ab9e0ec533 06f8080ae1393c2f 
1111111111111111 9ae34de86300215f f40379ab9e0ec533 
1c587f1c13924fef 305532286d6f295a 2fc181b0cb6b30b7 
1c587f1c13924fef e9eef1eb68e8c676 305532286d6f295a 
1c587f1c13924fef 63fac0d034d9f793 e3f0d7afe60812b2 
1c587f1c13924fef 7409d13ab01f25f6 63fac0d034d9f793 
1c587f1c13924fef f63de067f58c38ed 3f4913280d2793fc 
1c587f1c13924fef 0109eccd8a9c40dd f63de067f58c38ed 
1f08260d1ac2465e 2c0a241eb9f05999 e86f92ac2ec186f3 
1f08260d1ac2465e 2dbafaaf1eb7b072 2c0a241eb9f05999 
1f08260d1ac2465e 6b056e18759f5cca 02dd8970249255f1 
1f08260d1ac2465e 377f235592b45ca9 6b056e18759f5cca 
1f08260d1ac2465e ef1bf03e5dfa575a 98e1e5771c4a9455 
1f08260d1ac2465e f489970bb6e8a94e ef1bf03e5dfa575a 
1f1f1f1f0e0e0e0e 0123456789abcdef 1998d96b0bb0add6 
1f1f1f1f0e0e0e0e 7454d8d7c56be016 0123456789abcdef 
1f1f1f1f0e0e0e0e 322f206b2d39d65d 0b636eb981e987c0 
1f1f1f1f0e0e0e0e 0b926c6049361bff 322f206b2d39d65d 
1f1f1f1f0e0e0e0e db958605f8c8c606 5a153aea62bdd0cb 
1f1f1f1f0e0e0e0e 2c7bf241aa0b2c97 db958605f8c8c606 
3000000000000000 1000000000000001 12f2d0471de69a16 
3000000000000000 b0ef21ad8b82dd0a 1000000000000001 
3000000000000000 958e6e627a05557b 4be1b16ef2c9524a 
3000000000000000 437b3ac6a2a027c8 958e6e627a05557b 
3000000000000000 d3c4539579b96231 bbfcaf9cc8cd9e46 
3000000000000000 7b8b6b2e19e13c69 d3c4539579b96231 
37d06bb516cb7546 0a2aeeae3ff4ab77 32a65f25341d17f0 
37d06bb516cb7546 90d6dcee0f2f8d62 0a2aeeae3ff4ab77 
37d06bb516cb7546 164d5e404f275232 782a69ec6256c642 
37d06bb516cb7546 1dabf24c62f0fd89 164d5e404f275232 
37d06bb516cb7546 19acae3136c0bc7c 9cd87a6a8ea4c562 
37d06bb516cb7546 f8bf4d34438681a2 19acae3136c0bc7c 
3849674c2602319e 126898d55e911500 c86caec1e3b7b17e 
3849674c2602319e d8d28161851ed6d6 126898d55e911500 
3849674c2602319e 51454b582ddf440a 8904c12a608bac74 
3849674c2602319e 562de7a88b1f4877 51454b582ddf440a 
3849674c2602319e 7178876e01f19b2a ba940cd1789e92fd 
3849674c2602319e 295ece9867b10e95 7178876e01f19b2a 
43297fad38e373fe 4c974f1caa59f5d4 71a64728851d6e14 
43297fad38e373fe f386803c5a434216 4c974f1caa59f5d4 
43297fad38e373fe 762514b829bf486a 6684fb847e1283c0 
43297fad38e373fe bf8e6fbf6c48ec44 762514b829bf486a 
43297fad38e373fe ea676b2cb7db2b7a 5a2d250d39eb8fc1 
43297fad38e373fe 6d42d3b3b5a9abcc ea676b2cb7db2b7a 
49793ebc79b3258f 437540c8698f3cfa 0b46e6cd65118775 
49793ebc79b3258f b9d425d544c1ce71 437540c8698f3cfa 
49793ebc79b3258f 6fbf1cafcffd0556 50bfa6e233cef0af 
49793ebc79b3258f 000c45276715001d 6fbf1cafcffd0556 
49793ebc79b3258f a0cb2871752053f0 af27090a887c7e3e 
49793ebc79b3258f 51fc08afec3c8f1a a0cb2871752053f0 
49e95d6d4ca229bf 00b0024eaac70ae3 6f2421dc83df9ba2 
49e95d6d4ca229bf 82537ce99e3476de 00b0024eaac70ae3 
49e95d6d4ca229bf 02fe55778117f12a bd6bb416626be321 
49e95d6d4ca229bf 417b8cdd1c64b3e7 02fe55778117f12a 
49e95d6d4ca229bf 5a6b612cc26cce4a 73cb63595026b590 
49e95d6d4ca229bf a90f566d8f4e3e41 5a6b612cc26cce4a 
4fb05e1515ab73a7 072d43a077075292 ac6174b535bcad69 
4fb05e1515ab73a7 2d139d3801a19346 072d43a077075292 
4fb05e1515ab73a7 2f22e49bab7ca1ac 86019dd993c46cbe 
4fb05e1515ab73a7 44fef33e6971a69b 2f22e49bab7ca1ac 
4fb05e1515ab73a7 ad87789bc00718c2 733b12f600953a98 
4fb05e1515ab73a7 8341990d8ba44544 ad87789bc00718c2 
584023641aba6176 004bd6ef09176062 6ceca0e2d5351cd1 
584023641aba6176 9c6aedffd92b1cca 004bd6ef09176062 
584023641aba6176 88bf0db6d70dee56 b3a4719eca678ecc 
584023641aba6176 bb39bb8bdf9db594 88bf0db6d70dee56 
584023641aba6176 c7d2845ea6d01c70 2932e00da18db422 
584023641aba6176 2217a63228e547c1 c7d2845ea6d01c70 
5b5a57676a56676e 974affbf86022d1f 6b6413098aaa7f2b 
5b5a57676a56676e daabfab98dea5e78 974affbf86022d1f 
7ca110454a1a6e57 01a1d6d039776742 0200c0b643578183 
7ca110454a1a6e57 1405433e91265b1b 01a1d6d039776742 
7ca110454a1a6e57 690f5b0d9a26939b d6173b3a2f754508 
7ca110454a1a6e57 9f7c523c7bfe7586 690f5b0d9a26939b 
7ca110454a1a6e57 ecd1c2f929f33ced a5d38784ef7973ee 
7ca110454a1a6e57 c6642999c37b99b3 ecd1c2f929f33ced 
e0fee0fef1fef1fe 0123456789abcdef e09ca157c6dfe236 
e0fee0fef1fef1fe 20bc4d004e45c048 0123456789abcdef 
e0fee0fef1fef1fe b7687facf9b1a656 eb2c523be4dedd8a 
e0fee0fef1fef1fe c21c42ef608f5ae6 b7687facf9b1a656 
e0fee0fef1fef1fe edbfd1c66c29ccc7 d7a84a5234f98995 
e0fee0fef1fef1fe cb3f0e23d4ad3760 edbfd1c66c29ccc7 
fedcba9876543210 0123456789abcdef 480f0eac8d4c6cbc 
fedcba9876543210 25d00012f501adaf 0123456789abcdef 
fedcba9876543210 2a2bb008df97c2f2 9de0df5e77b9880c 
fedcba9876543210 37365e5317307623 2a2bb008df97c2f2 
fedcba9876543210 7f46aa73f7fcde02 f6b3c639d4588687 
fedcba9876543210 286334c90fc54d99 7f46aa73f7fcde02 
fedcba9876543210 c44c1b3668a0f2cf f1fbe0db72af2072 
fedcba9876543210 4da710ea766dddb4 c44c1b3668a0f2cf 
fedcba9876543210 ed39d950fa74bcc4 1529a5409e492728 
fedcba9876543210 ba2fcbdf566d6b40 ed39d950fa74bcc4 
fedcba9876543210 ffffffffffffffff 2d921ccde555d609 
fedcba9876543210 030a684825a5c5c2 ffffffffffffffff 
ffffffffffffffff 0000000000000000 5c77e002d1991c4d 
ffffffffffffffff 5c77e002d1991c4d 0000000000000000 
ffffffffffffffff 16b15028f06a5ab8 c594d15528f44560 
ffffffffffffffff c594d15528f44560 16b15028f06a5ab8 
ffffffffffffffff 3c7188775253884d ac490aef39a87b61 
ffffffffffffffff ac490aef39a87b61 3c7188775253884d 
ffffffffffffffff 7359b2163e4edc58 04cfc75ca56c9b94 
ffffffffffffffff 04cfc75ca56c9b94 7359b2163e4edc58 
ffffffffffffffff caaaaf4deaf1dbae c9bb22df2a45a2ef 
ffffffffffffffff c9bb22df2a45a2ef caaaaf4deaf1dbae 
ffffffffffffffff ffffffffffffffff 427b5df7a109f638 
ffffffffffffffff 427b5df7a109f638 ffffffffffffffff 
\Rogue\Monster\
else
  echo "will not over write ./triples91"
fi
echo "Finished archive 1 of 1"
exit
