<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<!--NewPage-->
<html>
<head>
<!-- Generated by javadoc on Sat Jul 31 23:41:12 GMT-04:00 1999 -->
<title>
  Class cryptix.util.math.TrinomialLFSR
</title>
</head>
<body>
<a name="_top_"></a>
<pre>
<a href="packages.html">All Packages</a>  <a href="tree.html">Class Hierarchy</a>  <a href="Package-cryptix.util.math.html">This Package</a>  <a href="cryptix.util.math.Prime.html#_top_">Previous</a>  <a href="Package-cryptix.util.math.html">Next</a>  <a href="AllNames.html">Index</a></pre>
<hr>
<h1>
  Class cryptix.util.math.TrinomialLFSR
</h1>
<pre>
java.lang.Object
   |
   +----<a href="cryptix.util.math.BigRegister.html#_top_">cryptix.util.math.BigRegister</a>
           |
           +----cryptix.util.math.TrinomialLFSR
</pre>
<hr>
<dl>
  <dt> public class <b>TrinomialLFSR</b>
  <dt> extends <a href="cryptix.util.math.BigRegister.html#_top_">BigRegister</a>
  <dt> implements Cloneable, Serializable
</dl>
A class that implements a special category of Linear Feedback Shift
 Register (LFSR). Formally speaking, it implements a <i>Fibonacci</i>
 LFSR --LFSR(II)-- with a Monic, Non-Singular, Trinomial Connection
 (Characteristic) function of the form <i>f(x) = x<font size="-1">
 <sup>L</sup></font> + x<font size="-1"><sup>K</sup></font> + 1</i>.
 <p>
 <a href="#HAC"><cite>Menezes et al.</cite></a> define a generalised
 LFSR --with an L-degree connection polynomial-- as follows:
 <p>
 An LFSR of length L consists of L <i>stages</i> (or <i>delay
 elements</i>) numbered 0, 1, ..., L-1, each capable of storing one
 bit and having one input and one output; and a <i>clock</i> which
 controls the movement of data. During each unit of time the following
 operations are performed:
 <ul>
     <li>the contents of <i>stage</i> 0 is output and forms part
     of the <i>output sequence</i>;
     <li>the contents of <i>stage i</i> is moved to <i>stage i-1</i>
     for each <i>i, 1 <= i <= L-1</i>; and
     <li>the new contents of <i>stage L-1</i> is the <i>feedback bit
     s<font size="-1"><sub>j</sub></font></i> which is calculated by
     adding together modulo 2 the previous contents of a fixed subset
     of <i>stages 0, 1, ..., L-1</i> also called <i>taps</i>.
 </ul><p>
 Such an LFSR, referred to as a <i>Fibonacci LFSR</i>, <i>Type II LFSR
 </i>, or simply <i>LFSR(II)</i>, is denoted by <i>&lt;L, C(D)&gt</i>,
 where <i>C(D)</i> is called the <i>connection</i> or <i>characteristic
 polynomial</i> and is defined as:<br>
 <blockquote>
     C(D) = 1 + c<sub><font size="-1">1</font></sub>D + c<sub>
     <font size="-1">2</font></sub>D<sup><font size="-1">2</font></sup>
     + ... + c<sub><font size="-1">L</font></sub>D<sup><font size="-1">L
     </font></sup> <font face="Symbol">&Icirc;</FONT> Z<sub><font size=
     "-1">2</font></sub>[D]<br>
 </blockquote>
 A Linear Feedback Shift Register (LFSR) with a trinomial function of
 the form <i>1 + x<font size="-1"><sup>K</sup></font> + x<font size=
 "-1"><sup>L</sup></font></i> as its <i>connection polynomial</i> can
 be schematised as follows:
 <blockquote><pre>
  +--------------------XOR<-------------------------------+
  |                     ^                                 |
  |                     |                                 |
  |   +-----+-----+-----+-----+-----+-----+-----+-----+   |
  |   |stage|     |stage|stage|     |stage|stage|stage|   |
  +---| L-1 | ... | L-K |L-K-1| ... |  2  |  1  |  0  |---+--> output
      +-----+-----+-----+-----+-----+-----+-----+-----+
        K+1         L-1    0          K-3   K-2   K-1
      <------- Powers of the polynomial terms -------->
 </pre></blockquote>
 The following, collected from the references, are properties and
 <i>curiosities</i> inherent to such objects:
 <ul>
     <li>Choosing a primitive trinomial over <i>Z<font size="-1">
     <sub>2</sub></font></i>, ensures that each of the LFSR's <i>2<font
     size="-1"><sup>L</sup></font> - 1</i> initial states produces an
     output sequence with maximum possible period <i>2<font size="-1">
     <sup>L</sup></font> - 1</i>.
     <li>If <i>2<font size="-1"><sup>L</sup></font> - 1</i> is a prime
     (a <i>Mersenne prime</i>), then every irreducible polynomial of
     degree <i>L</i> in <i>Z<font size="-1"><sub>2</sub></font>[x]</i>
     is also primitive.
     <li>Irreducible trinomials, <i>f(x)</i>, of degree <i>L</i> can
     be used to represent the elements of the finite field <i>F<font
     size="-1"><sub>2</sub>L</font> = Z<font size="-1"><sub>2</sub></font>
     [x]/(f(x))</i>, the set of all polynomials in <i>Z<font size="-1">
     <sub>2</sub></font>[x]</i> of degree less than <i>L</i> where the
     addition and multiplication of polynomials is performed modulo
     <i>f(x)</i>.
     <li>If <i>f(x)</i> is a primitive polynomial of degree <i>L</i>,
     then <i>x<font size="-1"><sup>L</sup></font> f(x<font size="-1">
     <sup>-1</sup></font>) = f'(x)</i> is also a primitive polynomial.
     This is easily shown using the definition of a primitive polynomial,
     and the properties of modulo-2 arithmetic. A little thought shows
     that the register taps of <i>f'(x)</i> are the mirror image of those
     of <i>f(x)</i>. And the sequence produced by the tap-reversed
     generator is the time reversal of the original.
 </ul><p>
 Some terms and conventions associated with LFSRs, and used in this
 implementation, are:
 <ul>
     <li><b>tap-sequence</b>: the powers of the terms of the
     polynomial. In a monic (starts with <i>1 + ...</i>), non-
     singular (the term <i>x<sup><font size="-1">L</font></sup></i>
     for an <i>L</i>-long register is part of the polynomial function)
     trinomial, the sequence consists of 3 elements: 0, K, and L.
     <li><b>mid-tap</b>: the second/middle value of the tap sequence
     of a monic, non-singular trinomial.
     <li><b>state</b>: the value of the LFSR's contents. Also used
     to represent the coefficients of a polynomial in the field
     <i>F<font size="-1"><sub>2</sub>L</font></i>.
     <li><b>terms of a polynomial</b>: the correspondence between
     the LFSR <i>stages</i> and the powers of <i>x</i> (the polynomial
     invariate) in the <i>GF[<font size="-1"><sub>2</sub>L</font>]</i>
     with <i>f(x) = x<font size="-1"><sup>L</sup></font> + x<font size=
     "-1"><sup>K</sup></font> + 1</i> is such that the term with degree
     0 is at <i>stage L - K - 1</i>; the term with degree 1 is at <i>
     stage L - K - 2</i>, etc... After <i>stage</i> 0, the relationship
     restarts from <code>stage</code> <i>L - 1</i>. The reason for this
     gymnastic is to facilitate computing the successive powers of <i>x
     </i> --based on the mathematical fact that <i>g(x) = x</i> is a
     generator of the monic primitive <i>f(x)</i>-- which in turn are
     used in the computation of polynomial multiplication modulo <i>f(x)
     </i>. When so ordered, multiplying a polynomial <i>p(x)</i> by <i>x
     <font size="-1"><sup>t</sup></font></i> modulo <i>f(x)</i> is as
     simple as loading the LFSR's register with the terms of the
     polynomial, and clocking it by <i>t</i> cycles.
 </ul>
 Finally, <a href="#HAC"><cite>Menezes et al.</cite></a> lists (Table 4.9,
 p.162) some primitive polynomials of degree <i>m</i> over <i>Z<font size=
 "-1"><sub>2</sub></font>, 2<font size="-1"><sup>m</sup></font> - 1</i> a
 <i>Mersenne prime</i>. The following is an excerpt from this table for
 values of <i>m, m <= 4096</i> and <i>k, 1 <= k <= m/2</i>, for which the
 monic, non-singular trinomial <i>x<font size="-1"><sup>m</sup></font>
 + x<font size="-1"><sup>k</sup></font> + 1</i> is irreducible over <i>
 Z<font size="-1"><sub>2</sub></font></i>.
 <blockquote><pre>
    m  |  k
 ------+------------------------------
    2  |    1
    3  |    1
    5  |    2
    7  |    1,    3
   17  |    3,    5,     6
   31  |    3,    6,     7,   13
   89  |   38
  127  |    1,    7,    15,   30,  63
  521  |   32,   48,   158,  168
  607  |  105,  147,   273
 1279  |  216,  418
 2281  |  715,  915,  1029
 3217  |   67,  576
 </pre></blockquote>
 <b>Implementation Notes:</b>
 <p>
 In order to increase performance of this class, and since it's extending
 <code>BigRegister</code>, which assumes a bit numbering using bit index
 0 as the rightmost one, our LFSR will actually look like so:
 <blockquote><pre>
     +------------------->XOR--------------------------------+
     |                     ^                                 |
     |                     |                                 |
     |   +-----+-----+-----+-----+-----+-----+-----+-----+   |
     |   | bit |     | bit | bit |     | bit | bit | bit |   |
  <--+---| L-1 | ... | L-K |L-K-1| ... |  2  |  1  |  0  |<--+
         +-----+-----+-----+-----+-----+-----+-----+-----+
           K-1          0    L-1         K+2   K+1    K
         <------- Powers of the polynomial terms -------->
 </pre></blockquote>
 Obtaining a normal representation of the powers of the polynomial
 is done by left rotating the LFSR's contents by <i>K</i> positions.
 <p>
 Clocking the LFSR consists of executing the following pseudo-code:
 <pre>
     out = getBit(L-1);
     in = out ^ getBit(L-K-1);
     shiftLeft(1);
     if (in == 1) setBit(0);
 </pre>
 <p>
 <b>References:</b>
 <ol>
   <li> <a name="HAC">[HAC]</a>
        A. J. Menezes, P. C. van Oorschot, S. A. Vanstone,
        <cite>Handbook of Applied Cryptography</cite>
        CRC Press 1997, pp 195-212.
        <p>
   <li> <a name="AC2">[AC2]</a>
        Bruce Schneier,
        <cite>Applied Cryptography, 2nd edition</cite>,
        John Wiley &amp; Sons, Inc. 1996, pp 372-428.
        <p>
   <li> <a name="LFSR">[LFSR]</a>
        Arthur H. M. Ross,
        <cite>Linear Feedback Shift Registers</cite>,
        WWW page <a href="http://www.cdg.org/a_ross/LFSR.html">
        www.cdg.org/a_ross/LFSR.html</a>
 </ol>
 <p>
 <b>Copyright</b> &copy; 1995-1997
 <a href="http://www.systemics.com/">Systemics Ltd</a> on behalf of the
 <a href="http://www.systemics.com/docs/cryptix/">Cryptix Development Team</a>.
 <br>All rights reserved.
 <p>
 <b>$Revision: 1.2 $</b>
<p>
<dl>
  <dt> <b>Author:</b>
  <dd> Raif S. Naffah
</dl>
<hr>
<a name="index"></a>
<h2>
  <img src="images/constructor-index.gif" width=275 height=38 alt="Constructor Index">
</h2>
<dl>
  <dt> <img src="images/yellow-ball-small.gif" width=6 height=6 alt=" o ">
	<a href="#TrinomialLFSR(int, int)"><b>TrinomialLFSR</b></a>(int, int)
  <dd>  Define an LFSR with <code>L</code> stages and with a connection
 trinomial of the form: <i>x<font size="-1"><sup>L</sup></font> +
 x<font size="-1"><sup>K</sup></font> + 1.</i>

 
</dl>
<h2>
  <img src="images/method-index.gif" width=207 height=38 alt="Method Index">
</h2>
<dl>
  <dt> <img src="images/red-ball-small.gif" width=6 height=6 alt=" o ">
	<a href="#add(cryptix.util.math.TrinomialLFSR)"><b>add</b></a>(TrinomialLFSR)
  <dd>  Compute <code>this += gx (mod f(x))</code>.
  <dt> <img src="images/red-ball-small.gif" width=6 height=6 alt=" o ">
	<a href="#clock(int)"><b>clock</b></a>(int)
  <dd>  Repeatedly invoke the <code>engineClock()</code> method until
 the LFSR has been clocked <code>ticks</code> times.
  <dt> <img src="images/red-ball-small.gif" width=6 height=6 alt=" o ">
	<a href="#clone()"><b>clone</b></a>()
  <dd> Return a reference to a duplicate of <code>this</code>.
  <dt> <img src="images/red-ball-small.gif" width=6 height=6 alt=" o ">
	<a href="#compareTo(cryptix.util.math.TrinomialLFSR)"><b>compareTo</b></a>(TrinomialLFSR)
  <dd>  Compare this LFSR to the argument, returning -1, 0 or 1 for
 less than, equal to, or greater than comparison.
  <dt> <img src="images/red-ball-small.gif" width=6 height=6 alt=" o ">
	<a href="#degreeAt(int)"><b>degreeAt</b></a>(int)
  <dd>  Return the power of the term <i>x<font size="-1"><sup>result</sup>
 </font></i> relative to the given register's index.
  <dt> <img src="images/red-ball-small.gif" width=6 height=6 alt=" o ">
	<a href="#engineClock(int)"><b>engineClock</b></a>(int)
  <dd>  Clock the register <i>ticks</i> steps.
  <dt> <img src="images/red-ball-small.gif" width=6 height=6 alt=" o ">
	<a href="#getMidTap()"><b>getMidTap</b></a>()
  <dd>  Return the degree/power of the <i>mid-tap</i> element in this LFSR.
  <dt> <img src="images/red-ball-small.gif" width=6 height=6 alt=" o ">
	<a href="#getSize()"><b>getSize</b></a>()
  <dd>  Return the number of <i>elements</i> in this LFSR, which is also
 the <i>degree</i> of the trinomial.
  <dt> <img src="images/red-ball-small.gif" width=6 height=6 alt=" o ">
	<a href="#getSlice()"><b>getSlice</b></a>()
  <dd>  Return the maximum number of meaningful bits in this LFSR, which
 is also the maximum number of bits that can be processed in one
 operation without loss of desired output sequence.
  <dt> <img src="images/red-ball-small.gif" width=6 height=6 alt=" o ">
	<a href="#indexOfX(int)"><b>indexOfX</b></a>(int)
  <dd>  Return the register's index relative to the polynomial
 term <i>x<font size="-1"><sup>degree</sup></font></i>.
  <dt> <img src="images/red-ball-small.gif" width=6 height=6 alt=" o ">
	<a href="#isSameGroup(cryptix.util.math.TrinomialLFSR)"><b>isSameGroup</b></a>(TrinomialLFSR)
  <dd>  Return true iff the argument is a polynomial that belongs to
 the same <i>Group</i> as <code>this</code>.
  <dt> <img src="images/red-ball-small.gif" width=6 height=6 alt=" o ">
	<a href="#isSameValue(cryptix.util.math.TrinomialLFSR)"><b>isSameValue</b></a>(TrinomialLFSR)
  <dd>  Return true if the TrinomialLFSR <i>x</i> has equal characteristics
 and contents to this one; false otherwise.
  <dt> <img src="images/red-ball-small.gif" width=6 height=6 alt=" o ">
	<a href="#multiply(cryptix.util.math.TrinomialLFSR)"><b>multiply</b></a>(TrinomialLFSR)
  <dd>  Compute <code>this *= gx (mod f(x))</code>.
  <dt> <img src="images/green-ball-small.gif" width=6 height=6 alt=" o ">
	<a href="#multiply(cryptix.util.math.TrinomialLFSR, cryptix.util.math.TrinomialLFSR)"><b>multiply</b></a>(TrinomialLFSR, TrinomialLFSR)
  <dd>  Return the product of the two arguments modulo <i>f(x))</i>, where
 both arguments are members of the same polynomial group with the
 same monic trinomial <i>f(x)</i>.
  <dt> <img src="images/red-ball-small.gif" width=6 height=6 alt=" o ">
	<a href="#next(int)"><b>next</b></a>(int)
  <dd>  Return the value of the leftmost <code>count</code> bits of
 this LFSR and clock it by as many ticks.
  <dt> <img src="images/red-ball-small.gif" width=6 height=6 alt=" o ">
	<a href="#pow(cryptix.util.math.BigRegister)"><b>pow</b></a>(BigRegister)
  <dd>  Raise <code>this</code> to the <code>n</code>th power modulo
 <i>f(x))</i>.
  <dt> <img src="images/red-ball-small.gif" width=6 height=6 alt=" o ">
	<a href="#resetX(int)"><b>resetX</b></a>(int)
  <dd>  Set the LFSR's initial state to a value that corresponds
 to the polynomial term of the designated degree.
  <dt> <img src="images/red-ball-small.gif" width=6 height=6 alt=" o ">
	<a href="#setX(int)"><b>setX</b></a>(int)
  <dd>  Set (to one) </code>this</code> LFSR's polynomial term of
 the given degree.
  <dt> <img src="images/red-ball-small.gif" width=6 height=6 alt=" o ">
	<a href="#subtract(cryptix.util.math.TrinomialLFSR)"><b>subtract</b></a>(TrinomialLFSR)
  <dd>  Compute <code>this -= gx (mod f(x))</code>.
  <dt> <img src="images/red-ball-small.gif" width=6 height=6 alt=" o ">
	<a href="#toBigRegister()"><b>toBigRegister</b></a>()
  <dd>  Return the state of <code>this</code> LFSR as a <code>BigRegister
 </code> object where now the powers of the polynomial terms are
 ordered in ascending succession starting from power 0 at index 0.
  <dt> <img src="images/red-ball-small.gif" width=6 height=6 alt=" o ">
	<a href="#toPolynomial()"><b>toPolynomial</b></a>()
  <dd>  Return a formatted <code>String</code> representation of the
 polynomial form represented by <code>this</code> LFSR's state.
  <dt> <img src="images/red-ball-small.gif" width=6 height=6 alt=" o ">
	<a href="#toString()"><b>toString</b></a>()
  <dd>  Return a formatted <code>String</code> representation of the binary
 contents of <code>this</code>.
  <dt> <img src="images/red-ball-small.gif" width=6 height=6 alt=" o ">
	<a href="#trinomialOne()"><b>trinomialOne</b></a>()
  <dd>  Return a <code>TrinomialLFSR</code> object whose state is set
 to the powers of the polynomial <i>p(x)</i> such that <i>p(x)
 = 1</i> in the polynomial <i>Group</i> defined over the trinomial
 function of <code>this</code> object.
  <dt> <img src="images/red-ball-small.gif" width=6 height=6 alt=" o ">
	<a href="#trinomialX()"><b>trinomialX</b></a>()
  <dd>  Return a <code>TrinomialLFSR</code> object whose state is set
 to the powers of the polynomial <i>p(x)</i> such that <i>p(x)
 = x</i> in the polynomial <i>Group</i> defined over the trinomial
 function of <code>this</code> object.
</dl>
<a name="constructors"></a>
<h2>
  <img src="images/constructors.gif" width=231 height=38 alt="Constructors">
</h2>
<a name="TrinomialLFSR"></a>
<a name="TrinomialLFSR(int, int)"><img src="images/yellow-ball.gif" width=12 height=12 alt=" o "></a>
<b>TrinomialLFSR</b>
<pre>
 public TrinomialLFSR(int l,
                      int k)
</pre>
<dl>
  <dd> Define an LFSR with <code>L</code> stages and with a connection
 trinomial of the form: <i>x<font size="-1"><sup>L</sup></font> +
 x<font size="-1"><sup>K</sup></font> + 1.</i>
<p>
  <dd><dl>
    <dt> <b>Parameters:</b>
    <dd> l - Size of the register; ie. number of levels/stages
         of this LFSR. Is also the <i>degree</i> of the <i>
         connection trinomial</i>.
    <dd> k - Degree/power of the <i>mid-tap</i> within the LFSR.
    <dt> <b>Throws:</b> IllegalArgumentException
    <dd> If k <= 0 or k >= l.
  </dl></dd>
</dl>
<a name="methods"></a>
<h2>
  <img src="images/methods.gif" width=151 height=38 alt="Methods">
</h2>
<a name="clone()"><img src="images/red-ball.gif" width=12 height=12 alt=" o "></a>
<a name="clone"><b>clone</b></a>
<pre>
 public Object clone()
</pre>
<dl>
  <dd> Return a reference to a duplicate of <code>this</code>.
<p>
  <dd><dl>
    <dt> <b>Overrides:</b>
    <dd> <a href="cryptix.util.math.BigRegister.html#clone()">clone</a> in class <a href="cryptix.util.math.BigRegister.html#_top_">BigRegister</a>
  </dl></dd>
</dl>
<a name="clock(int)"><img src="images/red-ball.gif" width=12 height=12 alt=" o "></a>
<a name="clock"><b>clock</b></a>
<pre>
 public void clock(int ticks)
</pre>
<dl>
  <dd> Repeatedly invoke the <code>engineClock()</code> method until
 the LFSR has been clocked <code>ticks</code> times.
<p>
  <dd><dl>
    <dt> <b>Parameters:</b>
    <dd> ticks - Number of steps to clock the FSR by. If it is
         &lt;= 0 nothing happens.
  </dl></dd>
</dl>
<a name="engineClock(int)"><img src="images/red-ball.gif" width=12 height=12 alt=" o "></a>
<a name="engineClock"><b>engineClock</b></a>
<pre>
 protected void engineClock(int ticks)
</pre>
<dl>
  <dd> Clock the register <i>ticks</i> steps.
<p>
  <dd><dl>
    <dt> <b>Parameters:</b>
    <dd> ticks - Number of steps to clock the register. It is the
         responsibility of the caller to ensure that this value
         never exceeds that of <code>slice</code>.
  </dl></dd>
</dl>
<a name="next(int)"><img src="images/red-ball.gif" width=12 height=12 alt=" o "></a>
<a name="next"><b>next</b></a>
<pre>
 public long next(int count)
</pre>
<dl>
  <dd> Return the value of the leftmost <code>count</code> bits of
 this LFSR and clock it by as many ticks. Note however that
 only the minimum of <code>count</code> and <code>slice</code>
 bits, among those returned, are meaningful.
<p>
  <dd><dl>
    <dt> <b>Parameters:</b>
    <dd> count - Number of leftmost bits to consider. If this
         value is zero then return 0.
    <dt> <b>Returns:</b>
    <dd> The value of the leftmost <code>count</code> bits
         right justified in a <code>long</code>.
  </dl></dd>
</dl>
<a name="add(cryptix.util.math.TrinomialLFSR)"><img src="images/red-ball.gif" width=12 height=12 alt=" o "></a>
<a name="add"><b>add</b></a>
<pre>
 public void add(<a href="#_top_">TrinomialLFSR</a> gx)
</pre>
<dl>
  <dd> Compute <code>this += gx (mod f(x))</code>. Note that this
 operation is only meaningful, when the monic trinomial is primitive.
<p>
  <dd><dl>
    <dt> <b>Parameters:</b>
    <dd> gx - A representation of the terms of a polynomial to add
         to <code>this</code>.
    <dt> <b>Throws:</b> IllegalArgumentException
    <dd> If the argument is not in
         the same group as <code>this</code>.
  </dl></dd>
</dl>
<a name="subtract(cryptix.util.math.TrinomialLFSR)"><img src="images/red-ball.gif" width=12 height=12 alt=" o "></a>
<a name="subtract"><b>subtract</b></a>
<pre>
 public void subtract(<a href="#_top_">TrinomialLFSR</a> gx)
</pre>
<dl>
  <dd> Compute <code>this -= gx (mod f(x))</code>. Note that this
 operation is only meaningful, when the monic trinomial is
 primitive. When such is the case the result is the same as
 that obtained by the <code>add()</code> method since in <i>
 F<font size="-1"><sub>2</sub>n</font></i> every polynomial is
 its own additive inverse.
<p>
  <dd><dl>
    <dt> <b>Parameters:</b>
    <dd> gx - A representation of the terms of a polynomial to
         subtract from <code>this</code>.
    <dt> <b>Throws:</b> IllegalArgumentException
    <dd> If the argument is not
         in the same group as <code>this</code>.
  </dl></dd>
</dl>
<a name="multiply(cryptix.util.math.TrinomialLFSR)"><img src="images/red-ball.gif" width=12 height=12 alt=" o "></a>
<a name="multiply"><b>multiply</b></a>
<pre>
 public void multiply(<a href="#_top_">TrinomialLFSR</a> gx)
</pre>
<dl>
  <dd> Compute <code>this *= gx (mod f(x))</code>. Note that this
 operation is only meaningful, when the monic trinomial is primitive.
<p>
  <dd><dl>
    <dt> <b>Parameters:</b>
    <dd> gx - A representation of the terms of a polynomial to
         multiply by <code>this</code>.
    <dt> <b>Throws:</b> IllegalArgumentException
    <dd> If the argument is not in
         the same group as <code>this</code>.
  </dl></dd>
</dl>
<a name="multiply(cryptix.util.math.TrinomialLFSR, cryptix.util.math.TrinomialLFSR)"><img src="images/green-ball.gif" width=12 height=12 alt=" o "></a>
<a name="multiply"><b>multiply</b></a>
<pre>
 public static <a href="#_top_">TrinomialLFSR</a> multiply(<a href="#_top_">TrinomialLFSR</a> p,
                                      <a href="#_top_">TrinomialLFSR</a> q)
</pre>
<dl>
  <dd> Return the product of the two arguments modulo <i>f(x))</i>, where
 both arguments are members of the same polynomial group with the
 same monic trinomial <i>f(x)</i>. Note that this operation is only
 meaningful, when the monic trinomial is primitive.
<p>
  <dd><dl>
    <dt> <b>Parameters:</b>
    <dd> p - A representation of the terms of the first polynomial
         multiplicand.
    <dd> q - A representation of the terms of the second polynomial
         multiplicand.
    <dt> <b>Returns:</b>
    <dd> The product of the two arguments modulo <i>f(x))</i>.
    <dt> <b>Throws:</b> IllegalArgumentException
    <dd> If the arguments are not
         from the same group.
  </dl></dd>
</dl>
<a name="pow(cryptix.util.math.BigRegister)"><img src="images/red-ball.gif" width=12 height=12 alt=" o "></a>
<a name="pow"><b>pow</b></a>
<pre>
 public void pow(<a href="cryptix.util.math.BigRegister.html#_top_">BigRegister</a> n)
</pre>
<dl>
  <dd> Raise <code>this</code> to the <code>n</code>th power modulo
 <i>f(x))</i>. Note that this operation is only meaningful,
 when the monic trinomial is primitive.
<p>
  <dd><dl>
    <dt> <b>Parameters:</b>
    <dd> n - Bit representation of the power to raise this
         polynomial representation to.
    <dt> <b>Throws:</b> IllegalArgumentException
    <dd> If the argument's <code>
         size</code> is greater than that of <code>this</code>.
  </dl></dd>
</dl>
<a name="resetX(int)"><img src="images/red-ball.gif" width=12 height=12 alt=" o "></a>
<a name="resetX"><b>resetX</b></a>
<pre>
 public void resetX(int n)
</pre>
<dl>
  <dd> Set the LFSR's initial state to a value that corresponds
 to the polynomial term of the designated degree.
<p>
  <dd><dl>
    <dt> <b>Parameters:</b>
    <dd> n - Reset the register's contents to all zeroes except
         for a <i>1</i> at the index position corresponding to
         the term x<font size="-1"><sup>n</sup></font></i>.
    <dt> <b>Throws:</b> IllegalArgumentException
    <dd> If the argument value
         is negative or greater than or equal to <code>this</code>
         LFSR's trinomial degree.
  </dl></dd>
</dl>
<a name="setX(int)"><img src="images/red-ball.gif" width=12 height=12 alt=" o "></a>
<a name="setX"><b>setX</b></a>
<pre>
 public void setX(int n)
</pre>
<dl>
  <dd> Set (to one) </code>this</code> LFSR's polynomial term of
 the given degree. The other <code>stages</code>, in contrast
 to the <code>resetX()</code> method, are unaffected.
<p>
  <dd><dl>
    <dt> <b>Parameters:</b>
    <dd> n - Set (to one) the register position of the term
         x<font size="-1"><sup>n</sup></font></i>.
    <dt> <b>Throws:</b> IllegalArgumentException
    <dd> If the argument value
         is negative or greater than or equal to <code>this</code>
         LFSR's trinomial degree.
  </dl></dd>
</dl>
<a name="indexOfX(int)"><img src="images/red-ball.gif" width=12 height=12 alt=" o "></a>
<a name="indexOfX"><b>indexOfX</b></a>
<pre>
 public int indexOfX(int degree)
</pre>
<dl>
  <dd> Return the register's index relative to the polynomial
 term <i>x<font size="-1"><sup>degree</sup></font></i>.
<p>
  <dd><dl>
    <dt> <b>Parameters:</b>
    <dd> degree - The power of the invariate <i>x</i>, for which
         the register's index is to be found.
    <dt> <b>Returns:</b>
    <dd> The register's index relative to the polynomial term
         <i>x<font size="-1"><sup>degree</sup></font></i>.
    <dt> <b>Throws:</b> IllegalArgumentException
    <dd> If the argument value
         is negative or greater than or equal to <code>this</code>
         LFSR's trinomial degree.
  </dl></dd>
</dl>
<a name="degreeAt(int)"><img src="images/red-ball.gif" width=12 height=12 alt=" o "></a>
<a name="degreeAt"><b>degreeAt</b></a>
<pre>
 public int degreeAt(int index)
</pre>
<dl>
  <dd> Return the power of the term <i>x<font size="-1"><sup>result</sup>
 </font></i> relative to the given register's index.
<p>
  <dd><dl>
    <dt> <b>Parameters:</b>
    <dd> index - The register's index relative to the polynomial term
         <i>x<font size="-1"><sup>result</sup></font></i>.
    <dt> <b>Returns:</b>
    <dd> The power of the invariate <i>x</i> relative to the given
         register's index.
    <dt> <b>Throws:</b> IllegalArgumentException
    <dd> If the argument value
         is negative or greater than or equal to <code>this</code>
         LFSR's trinomial degree.
  </dl></dd>
</dl>
<a name="trinomialOne()"><img src="images/red-ball.gif" width=12 height=12 alt=" o "></a>
<a name="trinomialOne"><b>trinomialOne</b></a>
<pre>
 public <a href="#_top_">TrinomialLFSR</a> trinomialOne()
</pre>
<dl>
  <dd> Return a <code>TrinomialLFSR</code> object whose state is set
 to the powers of the polynomial <i>p(x)</i> such that <i>p(x)
 = 1</i> in the polynomial <i>Group</i> defined over the trinomial
 function of <code>this</code> object.
<p>
  <dd><dl>
    <dt> <b>Returns:</b>
    <dd> A <code>TrinomialLFSR</code> object whose state is set
         to the powers of the polynomial <i>p(x)</i> such that
         <i>p(x) = 1</i> in the polynomial <i>Group</i> defined
         over the trinomial function of <code>this</code> object.
  </dl></dd>
</dl>
<a name="trinomialX()"><img src="images/red-ball.gif" width=12 height=12 alt=" o "></a>
<a name="trinomialX"><b>trinomialX</b></a>
<pre>
 public <a href="#_top_">TrinomialLFSR</a> trinomialX()
</pre>
<dl>
  <dd> Return a <code>TrinomialLFSR</code> object whose state is set
 to the powers of the polynomial <i>p(x)</i> such that <i>p(x)
 = x</i> in the polynomial <i>Group</i> defined over the trinomial
 function of <code>this</code> object.
<p>
  <dd><dl>
    <dt> <b>Returns:</b>
    <dd> A <code>TrinomialLFSR</code> object whose state is set
         to the powers of the polynomial <i>p(x)</i> such that
         <i>p(x) = x</i> in the polynomial <i>Group</i> defined
         over the trinomial function of <code>this</code> object.
  </dl></dd>
</dl>
<a name="getSize()"><img src="images/red-ball.gif" width=12 height=12 alt=" o "></a>
<a name="getSize"><b>getSize</b></a>
<pre>
 public int getSize()
</pre>
<dl>
  <dd> Return the number of <i>elements</i> in this LFSR, which is also
 the <i>degree</i> of the trinomial.
<p>
  <dd><dl>
    <dt> <b>Returns:</b>
    <dd> The number of <i>elements</i> in this LFSR.
    <dt> <b>Overrides:</b>
    <dd> <a href="cryptix.util.math.BigRegister.html#getSize()">getSize</a> in class <a href="cryptix.util.math.BigRegister.html#_top_">BigRegister</a>
  </dl></dd>
</dl>
<a name="getMidTap()"><img src="images/red-ball.gif" width=12 height=12 alt=" o "></a>
<a name="getMidTap"><b>getMidTap</b></a>
<pre>
 public int getMidTap()
</pre>
<dl>
  <dd> Return the degree/power of the <i>mid-tap</i> element in this LFSR.
<p>
  <dd><dl>
    <dt> <b>Returns:</b>
    <dd> The degree/power of the <i>mid-tap</i> element in this LFSR.
  </dl></dd>
</dl>
<a name="getSlice()"><img src="images/red-ball.gif" width=12 height=12 alt=" o "></a>
<a name="getSlice"><b>getSlice</b></a>
<pre>
 public int getSlice()
</pre>
<dl>
  <dd> Return the maximum number of meaningful bits in this LFSR, which
 is also the maximum number of bits that can be processed in one
 operation without loss of desired output sequence.
<p>
  <dd><dl>
    <dt> <b>Returns:</b>
    <dd> The maximum number of meaningful bits in this LFSR.
  </dl></dd>
</dl>
<a name="isSameValue(cryptix.util.math.TrinomialLFSR)"><img src="images/red-ball.gif" width=12 height=12 alt=" o "></a>
<a name="isSameValue"><b>isSameValue</b></a>
<pre>
 public boolean isSameValue(<a href="#_top_">TrinomialLFSR</a> x)
</pre>
<dl>
  <dd> Return true if the TrinomialLFSR <i>x</i> has equal characteristics
 and contents to this one; false otherwise.
 <p>
 NOTE: the <code>equals</code> method is not used, because this is
 a mutable object (see the requirements for equals in the Java Language
 Spec).
<p>
  <dd><dl>
    <dt> <b>Returns:</b>
    <dd> true iff x has equal characteristics and contents.
  </dl></dd>
</dl>
<a name="compareTo(cryptix.util.math.TrinomialLFSR)"><img src="images/red-ball.gif" width=12 height=12 alt=" o "></a>
<a name="compareTo"><b>compareTo</b></a>
<pre>
 public int compareTo(<a href="#_top_">TrinomialLFSR</a> x)
</pre>
<dl>
  <dd> Compare this LFSR to the argument, returning -1, 0 or 1 for
 less than, equal to, or greater than comparison.
<p>
  <dd><dl>
    <dt> <b>Returns:</b>
    <dd> -1, 0, +1 If the contents of this object are
         respectively less than, equal to, or greater than
         those of the argument.
  </dl></dd>
</dl>
<a name="isSameGroup(cryptix.util.math.TrinomialLFSR)"><img src="images/red-ball.gif" width=12 height=12 alt=" o "></a>
<a name="isSameGroup"><b>isSameGroup</b></a>
<pre>
 public boolean isSameGroup(<a href="#_top_">TrinomialLFSR</a> x)
</pre>
<dl>
  <dd> Return true iff the argument is a polynomial that belongs to
 the same <i>Group</i> as <code>this</code>.
<p>
  <dd><dl>
    <dt> <b>Returns:</b>
    <dd> true iff the argument is a polynomial that belongs to
         the same <i>Group</i> as <code>this</code>.
  </dl></dd>
</dl>
<a name="toBigRegister()"><img src="images/red-ball.gif" width=12 height=12 alt=" o "></a>
<a name="toBigRegister"><b>toBigRegister</b></a>
<pre>
 public <a href="cryptix.util.math.BigRegister.html#_top_">BigRegister</a> toBigRegister()
</pre>
<dl>
  <dd> Return the state of <code>this</code> LFSR as a <code>BigRegister
 </code> object where now the powers of the polynomial terms are
 ordered in ascending succession starting from power 0 at index 0.
<p>
  <dd><dl>
    <dt> <b>Returns:</b>
    <dd> The state of <code>this</code> LFSR as a <code>BigRegister
         </code> object where now the powers of the polynomial terms
         are ordered in ascending succession starting from power 0
         at index 0.
  </dl></dd>
</dl>
<a name="toString()"><img src="images/red-ball.gif" width=12 height=12 alt=" o "></a>
<a name="toString"><b>toString</b></a>
<pre>
 public String toString()
</pre>
<dl>
  <dd> Return a formatted <code>String</code> representation of the binary
 contents of <code>this</code>.
<p>
  <dd><dl>
    <dt> <b>Returns:</b>
    <dd> A formatted string representation of the binary contents
         of <code>this</code>.
    <dt> <b>Overrides:</b>
    <dd> <a href="cryptix.util.math.BigRegister.html#toString()">toString</a> in class <a href="cryptix.util.math.BigRegister.html#_top_">BigRegister</a>
  </dl></dd>
</dl>
<a name="toPolynomial()"><img src="images/red-ball.gif" width=12 height=12 alt=" o "></a>
<a name="toPolynomial"><b>toPolynomial</b></a>
<pre>
 public String toPolynomial()
</pre>
<dl>
  <dd> Return a formatted <code>String</code> representation of the
 polynomial form represented by <code>this</code> LFSR's state.
<p>
  <dd><dl>
    <dt> <b>Returns:</b>
    <dd> A formatted string representation of the binary contents
         of <code>this</code>.
  </dl></dd>
</dl>
<hr>
<pre>
<a href="packages.html">All Packages</a>  <a href="tree.html">Class Hierarchy</a>  <a href="Package-cryptix.util.math.html">This Package</a>  <a href="cryptix.util.math.Prime.html#_top_">Previous</a>  <a href="Package-cryptix.util.math.html">Next</a>  <a href="AllNames.html">Index</a></pre>
</body>
</html>
