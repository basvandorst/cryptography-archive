Path: msuinfo!caen!sdd.hp.com!swrinde!network.ucsd.edu!qualcom.qualcomm.com!qualcom.qualcomm.com!karn
From: karn@qualcom.qualcomm.com (Phil Karn)
Newsgroups: sci.crypt
Subject: Re: Khufu and Khafre
Message-ID: <1992Feb26.040743.26780@qualcomm.com>
Date: 26 Feb 92 04:07:43 GMT
References: <1992Feb13.231223.8159@cs.aukuni.ac.nz> <1992Feb14.034519.15459@qualcomm.com> <GAFTER.92Feb25144758@sun131.mri.com>
Sender: news@qualcomm.com
Reply-To: karn@chicago.qualcomm.com
Organization: Qualcomm, Inc
Lines: 56
Nntp-Posting-Host: qualcom.qualcomm.com

In article <GAFTER.92Feb25144758@sun131.mri.com>, gafter@mri.com (Neal Gafter) writes:
|> Hint: consider the single-block messages
|> 
|>     A,B
|> 
|> and then
|> 
|>     A,C
|> 
|> If the opponent knows the plain and cleartext of the first message,
|> and knows half the plaintext of the second message, he can trivially
|> compute the full plaintext of the second message.
|> 

Thanks Neal, this is the first real feedback I've gotten on this
scheme. It certainly proves the point that I often make that the
design of any new cipher must withstand a full public review before
you can even think about relying on it.

It also shows that some attacks do not necessarily have to recover the
encryption key to be at least partially successful.

But I wouldn't exactly characterize this vulnerability as completely
"breaking" this scheme. Or at least I'm not quite ready to give up and
add two more rounds just to protect against this special case because
that would halve the overall execution speed. I would first like to
consider ways of preventing an attacker from ever having the
opportunity to use this attack. This implies that I must ensure that
the hash function is never given the same input twice, regardless of
the message content.

I could do this by using cipher block chaining to effectively
randomize all but the first block of plaintext in a multi-block
message. Since the cipher blocks are so large (32 bytes), the chances
of any one half-block (16 bytes) occurring more than once in any
message would be infintesimal for practical message sizes; by the
birthday formulas, a message would have to be on the order of 2^64
blocks long before this would have a 50% chance of happening. Even
then, to exploit it you would have to know the corresponding plaintext
for the half-block in question, and the most you could do with it is
to determine the plaintext for the half-block paired with it.

Changing the CBC initialization vector with each message could then
take care of the first block. The IV could either be considered to be
part of a one-time session key or even sent in the clear at the
beginning of a message. It could be randomly chosen or it could be a
simple time-of-day counter -- as long as the IV components that affect
both halves of the first input block always change from message to
message.  Since my ultimate goal is to put this cipher into a datagram
network security protocol, using a clock-based IV and sending it in
the clear with each packet would also help the receiver guard against
replay attacks.

Comments?

Phil
