Xref: msuinfo comp.databases:15713 comp.compression:2415 sci.crypt:7435
Path: msuinfo!uchinews!ncar!asuvax!cs.utexas.edu!uunet!mcsun!uknet!stl!dww
From: dww@bnr.co.uk (David Wright)
Newsgroups: comp.databases,comp.compression,sci.crypt
Subject: Does anyone know a hashing method for multiple keywords?
Message-ID: <5436@stl.co.uk>
Date: 22 Feb 92 15:46:09 GMT
Sender: news@bnr.co.uk
Reply-To: dww@bnr.co.uk (David Wright)
Followup-To: poster
Organization: BNR Europe Limited, London Road, Harlow, Essex, GB
Lines: 46

We have a problem that some of you might have ideas or references on.

We need a hashing function for keyword lookup in a large database which
maps several possible key values to a single record.   We need to keep any
index records short.  Note that in this article I use 'key' to mean a value
used to search for data, not a value used to encrypt data.  I am
cross-posting as although the problem is one of database design, its
solution may involve compression and/or encryption techniques.

With a conventional hashing method, one might choose a function which maps
a possibly variable length string s into a shorter fixed size value k with
good statistical spread such that f(s1) = f(s2) for s1=s2 but only a small
proportion h of cases where s1 <> s2.   We then have a hit rate of 1-h, and
most non-matches are detected by the hash value without further search.

In our case we need a hashing function f over a list L = s1,s2,s3,,,
such that we can predict whether s is a component of L from inspection of
f(L).   The size of the list is small but not fixed.   The real data
pointed to by the index record contains sufficient information to reject
false hits, but we need a hash function which will give a good hit rate and
not give too many false matches leading to expensive wasted disk accesses.

A trivial method would be to concatenate the list then test whether s is a
substring of L.   Unfortunately this would give a long and variable length
key, which we must avoid.

One form of the problem involves a list of 32-bit integers, the other a
list of text strings.  This second case is actually a list of subsets of
strings which are variants on each other in the form abcd, abcde, acbdef, ...

To give an instance for clarification, a list of keywords might be
CROYDON,STREET,WEST and we would want to be certain of a match for test
strings C or CR or CROY or STREE or a combination like CROYD WEST but be
unlikely to get a match for ROAD or X or ROYDON.   The combination case
would be checked by testing each keyword in turn.  In the simpler integer
case, we want a match for any integer value in the set.

Does anyone know a solution to this problem?   We do have one at the moment
but it is inelegant and very inefficient (I won't give it here as I think
it's a dead end but if anyone really wants to know, ask).

Please reply by mail, I'll post a summary of the replies.

Regards,        "None shall be enslaved by poverty, ignorance or conformity"
       David Wright  BNR Europe Ltd, London Road, Harlow, Essex CM17 9NA, UK
dww@bnr.co.uk <or> ...uunet!mcsun!ukc!stl!dww <or> PSI%234237100122::DWW
