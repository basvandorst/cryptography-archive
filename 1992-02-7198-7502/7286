Path: msuinfo!uchinews!linac!pacific.mps.ohio-state.edu!zaphod.mps.ohio-state.edu!usc!aero.org!gumby.dsd.trw.com!deneva!buckeye
From: buckeye@spf.trw.com (John Wallace)
Newsgroups: sci.crypt
Subject: Re: Multiple encryption with simple XORed keys
Keywords: XOR encryption
Message-ID: <299354EC.470@deneva.sdd.trw.com>
Date: 8 Feb 92 03:56:27 GMT
References: <1992Feb5.050356.7316@cs.umn.edu> <676@kepler1.kepler.com>
Sender: news@deneva.sdd.trw.com
Distribution: usa
Organization: TRW Data Systems Center, Redondo Beach, CA
Lines: 86

In article <676@kepler1.kepler.com> andrew@kepler1.UUCP (Andrew Mullhaupt) writes:
>In article <1992Feb5.050356.7316@cs.umn.edu> dege@cs.umn.edu (Dege Jeffrey Charles) writes:
>
>(Describes xor'ing a repeated key with message...)
>
>> 
>>   Now for the question.  Is it easier to break such an encryption scheme
>>than one using a single encryption with a key with length equal to the
>>product?  That is, is it easier to break a file that was encrypted with
>>keys of length 5 and 7 than it is to break a file that was encrypted
>>with a key of length 35?  In particular, if we do a multi-pass encryption
>>with keys of length that provide a repeat cycle longer than the length of
>
>I should think that since the brute force attack (I try to decode your
>message by using each possible key in turn) is a lot easier for the combination
>5-length and 7-length key than for the 35-length key that the 35-length key
>offers more security. (Suppose there are k possible values for each part of
>a key. Then there are k^35 keys of length 35 but the combination key consists
>of a choice from a k^5 set, and a k^7 set, for a total of k^12 combination
>keys.)
>
>If all one could do was guess keys, this would be the answer. However, if
>your message is much longer than the key used, then I can actually get a lot
>of information by guessing the period p, and computing the xor of the encrypted
>message with itself, shifted by the period. The xor will cancel out the 
>key, and I will be looking at exactly what I would have got had I xorred
>the plaintext with itself shifted over by the key period. Now I can by this
>trick obtain the value of x[i + mp] xor x[i + np] for any i, m and n, where
>x[1], x[2], ... is the plaintext. If I know that the plaintext is English
>text, I can guess that the most frequent value in the sequence
>
>	x[i] xor x[i+p], x[i] xor x[i+2p], ...
>
>is x[i] xor 'e'. I can then compute all the other values in this sequence. I
>only need to do this for the values i=1, ..., p, etc. Now in reality, I will
>base my guess of x[i], x[i+p], ... by matching the histogram of all the
>sequence elements with the plaintext, which will be a pretty good guess if
>the sequence is long. Now I can use the frequencies of two-grams to increase
>my chances as i goes to i+1. If my guess for the period is bad, I'll be
>seeing sequences with wacky statistics, so I'll be able to home in on the
>period pretty quickly. It would seem that I may be able to break this code
>based only on the fact that there is a period smaller than the message, 
>regardless of how this period arose, so picking an arbitrary 35 length
>key is not much better than a 5 and a 7, if at all.
>
>So I think that unless the key is longer than the message, essentially like
>a one time pad, that it probably doesn't matter how you pick the keys. If
>the keys are long enough, then you should pick them from the bigger set, which
>discourages combining small keys.
>
>Later,
>Andrew Mullhaupt
>

Couldn't you greatly increase the period by using the 35 character key
as the initial state of an additive congruential random number
generator (actually you may want to increase its length to 55 if you
believe Knuth).  In this type of random number generator, we have

key[i] = (key[i-b] + key[i-c]) mod m.

Assuming m = 256, then we can compute our output as

for j = 1 to inputSize do
{
    i=j+55;
    key[i] = key[i-b] + key[i-c];
    output[j] = output[j] ^ key[i];
}

Knuth in his Art of Computer Programming recommends values of b=31 
and c=55 to yield a table with an extremely long cycle (at least 
2^^55 - 1 even when the modulus is small).  It seems that this would 
make it closer to a one time pad.  You still have the problem that 
if they have a plain-text copy of the source, they can xor it to the 
encrypted text to reveal the key, but it is much harder to use brute 
force techniques to discover it.

I was planning to use this for a simple encryptor.  Is there any way
to beef it up so that the plain-text copy isn't such a problem?

Cheers!
John

-----
John Wallace		buckeye@spf.trw.com
