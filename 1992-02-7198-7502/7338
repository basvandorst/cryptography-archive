Xref: msuinfo alt.security:5319 sci.crypt:7338
Path: msuinfo!uchinews!linac!uwm.edu!spool.mu.edu!yale.edu!think.com!ames!network.ucsd.edu!qualcom.qualcomm.com!chicago.qualcomm.com!karn
From: karn@chicago.qualcomm.com (Phil Karn)
Newsgroups: alt.security,sci.crypt
Subject: Re: secure telnetd password encryption & authentication techniques
Message-ID: <1992Feb13.190458.20395@qualcomm.com>
Date: 13 Feb 92 19:04:58 GMT
Article-I.D.: qualcomm.1992Feb13.190458.20395
References: <kpktkuINN8nn@early-bird.think.com> <1992Feb13.142942.25610@news.iastate.edu> <kpl2hgINNcnj@neuro.usc.edu>
Sender: news@qualcomm.com
Organization: Qualcomm, Inc
Lines: 53
Nntp-Posting-Host: chicago.qualcomm.com


In addition to Kerberos, there are also new TELNET options for
authentication and encryption. Dunno if the servers/clients are
available yet, though.

But having watched the various IETF groups working on enhancing
Internet security with cryptography, I'm beginning to wonder if it's
being done the wrong way.  There's Telnet authentication and
encryption, there's Kerberos for rlogin/rsh like services, there's
authentication for SNMP, and so forth -- one authentication or
encryption method per application protocol, each one doing essentially
the same thing in a slightly different, application-specific way.

Aren't authentication and secrecy fundamental enough services to
deserve common, shared mechanisms to provide them? Why can't we add
them to IP as options so that not only would any application be able
to use them, but transport protocols like TCP would be protected as
well?

Here's how I would do it. One IP option would carry an authenticator,
probably produced by using MD-5 to hash the body of the datagram
concatenated with a secret key shared by the two systems. The option
field might also carry a key identifier, in case the systems share
more than one key. For encryption, there are two possibilities.  You
could simply encrypt everything starting with the transport (e.g.,
TCP) header and add an IP option saying "this packet is encrypted with
keyid x".  Or, to deny an eavesdropper even the knowledge of what
transport protocol you're using, create a "pseudo transport protocol"
that would sit between IP and the transport protocol. The actual
protocol ID (e.g., 6 for TCP) would be moved into this pseudo
transport protocol that would be encrypted.

The authentication and encryption options could both be used in the
same packet. The authentication of an incoming packet could be done
either before or after the packet is decrypted -- any thoughts on
which way might be better?

Each application could set a flag specifying whether it demands
authentication and/or encryption from its peers.

I've intentionally excluded key management issues from this layer.
They are complex enough to deserve a protocol of their own, perhaps
built on UDP and running as a user task. Two machines wishing to
communicate securely might use RSA or Diffie-Hellman or manual
agreement or whatever to establish a secret key which would then be
installed in the IP layer by a system call. Keys would be kept in the
kernel for each active machine pair, and they could be "aged out"
(requiring the key manager task to establish a new key) from time to
time.

Comments?

Phil
