Path: msuinfo!uchinews!linac!pacific.mps.ohio-state.edu!zaphod.mps.ohio-state.edu!mips!public!grady
From: grady@public.BTR.COM (Grady Ward  grady@btr.com)
Newsgroups: sci.crypt
Subject: RSA and Mathematica
Message-ID: <5449@public.BTR.COM>
Date: 6 Feb 92 02:45:04 GMT
Organization: BTR Public Access UNIX, MtnView CA. Contact: Customer Service cs@BTR.COM
Lines: 39

Alas, I do not have a program to _prove_ primes
in a reasonable amount of time (especially
for, say, 300 digit numbers).  I wish I did. :-)

Mathematica 2.0 uses the Rabin strong pseudoprime
test and the Lucas test (according to the documentation) .

Here is an example M2.0 to find a "good" prime:

p = {type in a long seed number here (toss a ten-sided die 100-200 times)}
If[EvenQ[p],p++]
While[(!PrimeQ[p] || !PrimeQ[p-1)/2]),
p +=2]
Print[p]

Note that I do more work than I actually need to do, for example,
I do not need to check if numbers ending with five are prime...

Repeat the above for a second number, q.

Then calculate b = p * q;  { b is your public modulus }

Then let a = {an abitrary seed greater than p and q but less than b}
and find the first pseudo prime greater than a;

Your private key, "c," is simply PowerMod(a,-1,(p-1)*(q-1))

You use the PowerMod function to encode and decode, as:

Encrypted = PowerMod(Plaintext,a,b);
Decrypted = PowerMod(Ciphertext,c,b);

In the five-line version, the plaintext is expressed as a block of
concatenated decimal ASCII; MM2.0 implements pipes, so it's
all rather easy.


-- 
Grady Ward  grady@btr.com  KD6ETH @ K6LY.#NOCAL.CA.USA.NA  Moby Lexicons
