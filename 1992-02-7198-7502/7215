Path: msuinfo!caen!sdd.hp.com!cs.utexas.edu!milano!cactus.org!ritter
From: ritter@cactus.org (Terry Ritter)
Newsgroups: sci.crypt
Subject: Re: Pretty Good (tm) Privacy
Message-ID: <10346@cactus.org>
Date: 1 Feb 92 05:57:47 GMT
References: <10541@lectroid.sw.stratus.com> <10585@lectroid.sw.stratus.com> <1992Jan31.194242.14474@talon.ucs.orst.edu>
Organization: Capital Area Central Texas Unix Society, Austin, TX
Lines: 82


 In <1992Jan31.194242.14474@talon.ucs.orst.edu> johng@oce.orst.edu
 (John Gregor) writes:

>In article <10297@cactus.org> ritter@cactus.org (Terry Ritter) writes:

>>  If I broadcast my public key over a network, it is possible that my
>>  key may be deliberately modified in transit -- changed, in fact, to
>>  someone else's key.  Then any response to me which uses the changed key
>>  may be deciphered and then re-enciphered in my correct key before I see
>>  it.  And neither I nor my correspondent need be any the wiser.

>Not necessarily.  If you encrypt your message (or at least your
>signature) with both the other party's public key AND your private key
>then the person in the middle won't be able to spoof unless he has
>intercepted both party's broadcasts or cracked both of their private
>keys.

> . . .

>Or have I missed something?


 Yes, I think so.

 If this signature protocol were a program, I would say that it has
 an "uninitialized variable."  That variable is your public key.
 If the other party can use your public key to sign their public
 key, how did they get your public key?  How do they know it is
 really *your* public key?


 Part of my point is that our store-and-forward network is inherently
 a problem, especially for naive public-key crypto.  In this network,
 messages can be modified in transit, with nobody nominally the wiser.
 If the other party sends you his or her public key, the key you get
 may not be the key which was sent.  That party cannot double-encrypt
 by using your public key until they *get* your key.  Somebody has to
 go first.  Whoever does is vulnerable.


 Another part of my point is that public keys must be changed
 periodically, just like private keys.  This is not because the
 cipher has some magic period of security (in computer-days) after
 which it may have been penetrated, but rather that public key
 ciphers -- like private key ciphers -- depend upon the physical
 security of a private key.  Employee turnover, accidental key loss,
 accidental viewing by a guest, fire, burglary, or equipment theft;
 in all these cases I must invalidate the old pair of keys and
 produce a new pair.

 The problem is that the rest of the world thinks that my compromised
 key is still valid.  Any messages in that key may actually pass
 through a subverted network node and be re-enciphered in my new key,
 giving both me and the other party no cause for concern.  I cannot
 use my compromised key to sign a message giving my new key, because
 whoever compromised my key could do exactly the same thing.

 Any printed compilation of public keys will contain many old,
 replaced, and potentially (or actually) insecure public keys.
 Anyone using those keys uses an insecure system.  Even signing a
 message depends upon a knowledge that the signing key has not been
 compromised.  Casual protocols which simply broadcast a public
 key through many channels still must handle the situation of
 updating compromised keys.  Anyone who misses an update is
 vulnerable.


 I suspect we will find some way to handle this.  But (and this
 was the point of my original response), it will not be the simple
 public-key scheme usually described.  Public key by itself does
 not make cryptography trivial.  Public key is just a tool.
 Cryptography lives in the details.

 Note that any solution probably must rest on a basis of physical
 security far beyond that in common use.  Given the strength of
 modern ciphers, it would be *far* easier to compromise security
 in any way *other* than trying to attack the cipher itself.

 ---
 Terry Ritter   cs.utexas.edu!cactus.org!ritter   (512) 892-0494

