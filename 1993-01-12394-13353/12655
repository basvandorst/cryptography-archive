Path: msuinfo!caen!uunet!usna!math3!mdm
From: mdm@math3.sma.usna.navy.mil (Mark D. Meyerson -- math  FACULTY <mdm@sma.usna.navy.mil>)
Newsgroups: comp.theory,sci.crypt,sci.math,rec.puzzles
Subject: Re: Looking for random permutation generation algorithms
Message-ID: <2614@usna.NAVY.MIL>
Date: 8 Jan 93 21:33:46 GMT
References: <1993Jan6.014749.15323@ee.ubc.ca> <1993Jan7.165939.11149@cs.cornell.edu> <2607@usna.NAVY.MIL> <1993Jan8.163909.20820@cs.cornell.edu>
Sender: news@usna.NAVY.MIL
Reply-To: mdm@math3.sma.usna.navy.mil (Mark D. Meyerson -- math  FACULTY <mdm@sma.usna.navy.mil>)
Followup-To: comp.theory
Lines: 13
Xref: msuinfo comp.theory:6186 sci.crypt:12655 sci.math:37978 rec.puzzles:20255

In article <1993Jan8.163909.20820@cs.cornell.edu>, karr@cs.cornell.edu
(David Karr) writes:
|> This is really the major omission from the algorithm.  I had meant
|> to compute both k mod b *and* k div b.  k mod b is used to index the
|> array for the current selection; k div b is then copied to k for the
|> next round.
|> 

I agree now.  This seems to be equivalent to the 
straightforward but perhaps harder to code recursive
method.  I've coded and checked Karr's algorithm
for N=1 to 6.
     Mark D. Meyerson
