Newsgroups: comp.theory,sci.crypt,rec.puzzles
Path: msuinfo!caen!zaphod.mps.ohio-state.edu!howland.reston.ans.net!bogus.sura.net!udel!gatech!usenet.ins.cwru.edu!news.csuohio.edu!vmcms.csuohio.edu!R0264
From: R0264@vmcms.csuohio.edu
Subject: Re: Generating a Random Permutation
Message-ID: <16B65ED55.R0264@vmcms.csuohio.edu>
Sender: news@news.csuohio.edu (USENET News System)
Organization: CSU
References: <sumner.727366153@milo.math.scarolina.edu> <4fKlI4200WB8Aps_9A@andrew.cmu.edu> <C1FpMw.4Ip@ccu.umanitoba.ca>
Date: Fri, 29 Jan 1993 21:52:29 GMT
Lines: 60
Xref: msuinfo comp.theory:6299 sci.crypt:13325 rec.puzzles:20663

In article <C1FpMw.4Ip@ccu.umanitoba.ca>
sbloch@silver.cs.umanitoba.ca (Stephen Bloch) writes:
 
>
>sumner@math.scarolina.edu (David Sumner) writes:
>>> In an earlier post I wrote that an easy way to generate a
>>> random permutation of the integers 1-n was:
>>> >      ++++++++++++++
>>> >  Initialize  A[n] as the array [1, 2, 3, 4,..., n]
>>> >        for i=1 to n
>>> >        z = random(n)
>>> >        t = a[i]
>>> >        a[i] = a[z]
>>> >        a[z] = t
>>> >        next i
>>> >    ++++++++++++++
>>> There is a typo in this. The line 'z = random(n)' should
>>> be 'z = random(i)'
>
>and "Thomas W. Strong, Jr." <strong+@CMU.EDU> replies:
>>I have to agree with the algorithm as originally presented.  What it
>>effectively does is it takes each item and puts it in a random position.
>>(it may put it back where it started from (1 in n chance) or it may move
>>some item twice, but every item has an equal chance to be in any
>>position.  If you replace the random(n) with random(i), the lower
>>numbered elements will tent to be near the beginning of the array, since
>>the only way they can be moved forward is if one of the later swaps
>>happens to exchange with them.
>
>No, the original algorithm is incorrect (for the simple combinatorial
>reason several people have posted).  I THINK (but am not sure) the
>corrected one is also incorrect, for the reasons Thomas states.  I
>would re-correct it as follows:
>
>initialize as before
>for i = 1 to n
>  z = random(n-i+1)+i-1
>  swap(a[i],a[z])
>
>To decipher the expression on line 3,...
>The first time z is uniformly chosen from 1...n
>The second time z is uniformly chosen from 2...n
>The third time z is uniformly chosen from 3...n
>and so on.  Thus on the first iteration a[1] is swapped with a random
>element (and never changes again), and is therefore uniformly distributed
>over 1...n.  The remaining n-1 slots hold the remaining n-1 values.  Then
>by the same reasoning, on the second iteration a[2] gets uniformly
>distributed over the remaining values.  And so on.
>
>If that proof is valid (as I think it is), can we get off this subject?
>
>--
>					Stephen Bloch
>				sbloch@silver.cs.umanitoba.ca
The last is correct, and the first is "wrong", for reasons shown by
Castellan (Behavior Research Methods, Instruments, & Computers, 1992,
24,72-77.  However, the last step (i=n) in the last one is unnecessary
and the loop only needs to go to n-1.
 
needs only go to n-1.
