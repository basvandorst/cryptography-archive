Path: msuinfo!netnews.upenn.edu!dsinc!spool.mu.edu!uunet!mcsun!chsun!bernina!caronni
From: caronni@nessie.cs.id.ethz.ch (Germano Caronni)
Newsgroups: sci.crypt
Subject: Re: About spoof's again
Message-ID: <1993Jan18.170802.15444@bernina.ethz.ch>
Date: 18 Jan 93 17:08:02 GMT
References: <C11AM5.Bw1@dcs.ed.ac.uk> <1993Jan18.070144.20359@netcom.com>
Sender: news@bernina.ethz.ch (USENET News System)
Organization: Swiss Federal Institute of Technology (ETH), Zurich, CH
Lines: 93

In article <1993Jan18.070144.20359@netcom.com> rcain@netcom.com (Robert Cain) writes:
>...
>The thing that keeps tickling at me is that we *do* have a piece of
>information in a logical sense if we use Diffie-Hellman.  If there is
>no spoof, we are using the same key.  If so we aren't.  There is
>...

(But the Spoofer has all the information we have... This makes it
somewhat difficult to detect the spoofer, I guess)

First i try to define 'spoofing' so that we are sure, i talk about the
thing you do ;-)
A sends a msg M to B. A encrypts these msg using key ea (encrypt key of a)
This is for example the public key of B. So A actually sends E(ea,M)
(Encrypted text)
S (the spoof;-)) does an D(da,M) (da is decrypt key of a (this would be
B's private key)) then an E(eb,M) and forwards the msg. to B.
B gets the msg and can successfully D(db,M) and get the original or 
modified text M. (This works assuming that S knows all public and all
secret keys, or that S introduced a false public key ea to A insted of
giving A the real public key eb, and enables S to read and/or modify
successfully the msg M.
Did I get this right ?
Now we want a) to find out if we are being spoofed, b) want to hinder it.
This can be divided in making a connection theoretically spoof-proof
or just practically, in a way in which we require immediate Reaction
and pose a problem that would be computationally difficil for S.

Let's assume the spoofer does not know the secret-keys of A and B.
If A would place a checksum of it's public key in his msg M, S
would remark this, and replace it with it's own checksum. (and so on)

So hashes and so on won't give you any security, as S can forge them.

Unless the spoofer is not able to recognize such a hash. This would imply
security through obscurity ? Why is this NOT practical ?

We have to design a msg from A to B which S cannot forge. Or which S
can not forge in sufficent time.

Take a time-stamp + B's public key and encrypt it 10000 times 
with B's public key. This can take, that doesn't matter. Then when
the time of the chossen time-stamp arrives,
send the msg to B. If B receives it in less than <choose your margin>
he can decrypt to the time-stamp and check his public key.
If the msg takes longer than the choosen margin to reach B, he can
*suspect* that the msg-path is corrupt.

This is not secure, I agree, and does not use the fact that A and B
share some sort of information, but that S has to do some substantial
sort of work...

I guess there are many similiar ways to overload a potential spoofer,
and so to become aware of a) apparently uncorrect messages or b)
get an unexplainable delay in the connection.
Just at the moment I can not figure out how it would be possible to make
the connection theoretically spoof-proof, as the spoofer S actually
impersonates A to B and vice versa. (So S _IS_ (in regards to shared
information between A and B) identical to B, and identical to A) in respect
to the poster of the msg M.)
if you assume that A and B share knowledge that S does not have, then
I can imagine ''practicable'' ways to let A check B's key. And naturally
this can be easily done, if you can use more than one channel,
and not all of them are spoofed.

(
This ''practicable'' check could look like this:
The secret key of A is 01 
B asks A: Do you know Martha Rosenthal ? (B knows that A knows Martha
Rosental) So A would reply with 1(yes) XOR 0 (first bit of secret key)
gives 1
Then B asks A: Do you like Spaghetti? (A likes Spaghetti) 1 XOR 1
gives 0
So now B knows the secret key of A, and can verify if the public key
of A is correct to this secret key.
)

This is just no help for us, then former knowledge would involve that A
and B could easily have exchanged a 'codebook' and thus are not vulnerable
to spoofing ...

This is the best I can think of now (the computational problem for S
mentioned above) but I'd like to hear other, more qualified opinions...

Friendly greetings,

	Germano Caronni

-- 
Instruments register only through things they're designed to register.
Space still contains infinite unknowns.

Germano Caronni    caronni@nessie.cs.id.ethz.ch
