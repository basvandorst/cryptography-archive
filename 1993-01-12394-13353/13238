Path: msuinfo!netnews.upenn.edu!newsserver.jvnc.net!darwin.sura.net!haven.umd.edu!uunet!newsflash.concordia.ca!mizar.cc.umanitoba.ca!silver.cs.umanitoba.ca!sbloch
From: sbloch@silver.cs.umanitoba.ca (Stephen Bloch)
Newsgroups: comp.theory,sci.crypt,rec.puzzles
Subject: Re: Generating a Random Permutation
Message-ID: <C1FpMw.4Ip@ccu.umanitoba.ca>
Date: 26 Jan 93 00:06:32 GMT
References: <sumner.727366153@milo.math.scarolina.edu> <4fKlI4200WB8Aps_9A@andrew.cmu.edu>
Sender: news@ccu.umanitoba.ca
Organization: Computer Science, University of Manitoba, Winnipeg, Canada
Lines: 50
Nntp-Posting-Host: silver.cs.umanitoba.ca
Xref: msuinfo comp.theory:6271 sci.crypt:13238 rec.puzzles:20499

sumner@math.scarolina.edu (David Sumner) writes:
>> In an earlier post I wrote that an easy way to generate a
>> random permutation of the integers 1-n was:
>> >      ++++++++++++++
>> >  Initialize  A[n] as the array [1, 2, 3, 4,..., n]
>> >        for i=1 to n
>> >        z = random(n)
>> >        t = a[i]
>> >        a[i] = a[z]
>> >        a[z] = t
>> >        next i
>> >    ++++++++++++++
>> There is a typo in this. The line 'z = random(n)' should
>> be 'z = random(i)'

and "Thomas W. Strong, Jr." <strong+@CMU.EDU> replies:
>I have to agree with the algorithm as originally presented.  What it
>effectively does is it takes each item and puts it in a random position.
>(it may put it back where it started from (1 in n chance) or it may move
>some item twice, but every item has an equal chance to be in any
>position.  If you replace the random(n) with random(i), the lower
>numbered elements will tent to be near the beginning of the array, since
>the only way they can be moved forward is if one of the later swaps
>happens to exchange with them.

No, the original algorithm is incorrect (for the simple combinatorial
reason several people have posted).  I THINK (but am not sure) the
corrected one is also incorrect, for the reasons Thomas states.  I
would re-correct it as follows:

initialize as before
for i = 1 to n
  z = random(n-i+1)+i-1
  swap(a[i],a[z])

To decipher the expression on line 3,...
The first time z is uniformly chosen from 1...n
The second time z is uniformly chosen from 2...n
The third time z is uniformly chosen from 3...n
and so on.  Thus on the first iteration a[1] is swapped with a random
element (and never changes again), and is therefore uniformly distributed
over 1...n.  The remaining n-1 slots hold the remaining n-1 values.  Then
by the same reasoning, on the second iteration a[2] gets uniformly
distributed over the remaining values.  And so on.

If that proof is valid (as I think it is), can we get off this subject?

-- 
					Stephen Bloch
				sbloch@silver.cs.umanitoba.ca
