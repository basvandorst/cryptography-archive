Path: msuinfo!netnews.upenn.edu!dsinc!spool.mu.edu!howland.reston.ans.net!cs.utexas.edu!swrinde!sgiblab!sgigate.sgi.com!olivea!grapevine.lcs.mit.edu!PIRANHA.LCS.MIT.EDU!douzzer
From: douzzer@PIRANHA.LCS.MIT.EDU (Daniel G. Pouzzner)
Newsgroups: sci.crypt
Subject: Re: who knows message autenticity codes?
Date: 28 Jan 1994 20:28:31 GMT
Organization: gaia
Lines: 196
Sender: douzzer@athena.mit.edu
Distribution: world
Message-ID: <2ibshf$kcn@GRAPEVINE.LCS.MIT.EDU>
References: <59FLBMXI@gwdu03.gwdg.de>
NNTP-Posting-Host: piranha.lcs.mit.edu
Summary: treatise of sorts on host integrity issues
Keywords: hashing, signature, virus, smartcard, kerberos, host integrity


In <59FLBMXI@gwdu03.gwdg.de> slucks@gwdu03.gwdg.de (Stefan Lucks ) writes:

[...]
>I want to protect program codes P1, P2, ... (or other data) from 
>changes (e.g. by a virus). Together with the Program Code Pi I 
>store its message autenticity code MAC(Pi). Only me (or a 
>protected part of the OS) must be able to compute the function MAC. 
>(Therefore MAC should make use of a secret key k).
>
>Attackers can know arbitrary many pairs (Pi, MAC(Pi)).
>
>No attacker should be able to forge a pair (P', MAC(P')).
>
>One possibility to do this is to use a hash function in combination
>with a digital signature scheme. Digital signatures are a very 
>powerful cryptographic tool, since they can be veryfied without the 
>knowledge of the secret key. 
>
>If I don't bother about this property, there should be a easier and
>more efficient solution than digital signing. For example any 
>modification of MD5, using a secret key.
>
>What I am looking for is no ad hoc solution, but a trustworthy one,
>where the security can be proved under a basic assumption. 
>(For example: "If MD5 is collision free, then MAC is secure.")
>
>Does anyone know a scheme like this? Any suggestions?
>
>-- 
>Stefan Lucks  Institut f"ur Numerische und Angewandte Mathematik,
>              Lotzestra\3e 16-18,   37083 G"ottingen,   Germany
>e-mail: lucks@namu01.gwdg.de (oder slucks@gwdu03.gwdg.de)

the task you've set out to accomplish is certainly cryptographic in
nature, but if you're truly looking for "no ad hoc solution," your
problem is more difficult in practice than it might at first appear.

what you're dealing with is fundamentally the "client/host integrity"
issue. in real-world cryptography, you have to trust *something*. this
is where you draw your boundaries. if you're concerned about the
integrity of a message originating somewhere at the other end of a
network, by default you trust your own machine in contrast to your
distrust of the network. if, as perhaps is the case in your situation,
it's a message on your own machine for which you have distrust, then
clearly an extra wrinkle is introduced.

as you describe the schemes you've already considered, they rely on a
trust of the host's integrity. since the possibility you're attempting
to guard against is a violation of just this integrity, you've got an
insoluble conundrum without backing out another level. specifically,
you need some sort of modified operating system and/or smart card
(that is, unless you want to perform cryptographic transformations by
hand on paper every time you begin a session).

why is this necessary? if the tool with which you verify the integrity
of {P1, P2, ...} is, in fact, as vulnerable to attack as {P1, P2, ...}
itself (which seems a reasonable assumption if both are actually just
programs running on the same host), then you don't know if you're
verifying {P1, P2, ...} or getting a dummy verification with a
violated certification binary and a violated {P1, P2, ...}.

basically, if you're calling your trust of the host into question,
then you have to be complete about it. half-assed cryptographic
measures are value-free unless you have no problem with being subject
to eventual compromise. ideally you use an essentially separate
computer, which engages in a dialogue with the host whose integrity is
in question. in a very simple case, you might generate a signature for
a binary image in a "secure" environment, i.e. on the separate
computer. you would later verify the binary on a secure machine,
feeding it the binary image and signature as given by the machine in
question.  this still isn't sufficient, however.

the operating system can have a major impact on the potential for
bonafide, i.e. non-ad-hoc integrity verification. in the case of
bsd4.3-like operating systems, if the priviliges of "root" can be
attained by an attacker, then the game is over. the operating system
could be made to give conflicting values for a path when a read is
requested or an execute is requested. it could pass all keystrokes to
the net, encrypted for disguise. in short it's hopeless. get a new
operating system and reformat the hard drive.

bear in mind that, in the typical unix implementation, root is not an
unattainable holy grail for an attacker. it's actually fairly easy to
attain. it should be noted that bsd4.4 makes some significant
improvements in terms of kernel integrity maintenance: arbitrary
access to "core" is no longer permitted. instead a system call
interface is provided that allows only those accesses deemed
"appropriate," i.e. those necessary for the functionalities of "ps,"
"netstat," etc. thus even root setuid programs, typical backdoors for
crackers, don't result in the total compromise of the host unless a
reboot is performed (which would hopefully be noticed). other unices
with which i am less familiar, for example sysVr4-like implementations
with their /proc virtual filesystem, might provide similar protection.
can anyone expand on this?

the single-user single-thread unprotected-address-space OS's, like
MS-DOS or MacOS, are significantly easier to deal with, if only
because they are simpler and aren't nearly as open to attacks
originating on a network. of course, anyone with physical access to
the machine can thwart any and all efforts to secure the host. this is
clearly also the case for a unix-based host.

a practical failsafe host integrity guarantee would need to include
the following:

-prevention of "hot" kernel modification
-an message certification mechanism integrated into the kernel as some
  sort of device driver 
-detection of reboots. typical "NOC" service will detect this on
  networked machines, since a reboot invariably involves a shutdown
  and reset of the network interface. during the shutdown interval the
  host will no longer be IP-compliant and thus will not answer quorum
  calls from the NOC server. since the network interface at this level
  is handled by the kernel, the cracker cannot avoid a brief black
  hole if he/she (never heard of a female cracker, actually..) reboots
  the host. 
-physical security. a laptop with an ethernet interface could be
  plopped in place of the host under attack, made to announce the
  address of the host under attack, and made to forge the IP quorum
  response to the NOC call. this actually means the entire LAN must be
  physically secure, but in general this isn't too much more difficult
  than securing access to the host itself, at least in theory. well..
  cryptography rapidly becomes a tad obsessive..

the preceding is sufficient, but higher-security installations
frequently augment such measures, or compensate for susceptible hosts,
with measures such as:

-network firewalls. these typically include packet filtering by port
  and/or origin. in unix systems, this is a *very* good idea, though
  it carries penalties of efficiency and functionality. in practice,
  at least some of the allowed packet varieties (say, port 25..
  *cough* *cough*) will give the determined cracker sufficient
  ammunition to undermine network segregation efforts. in general,
  though, well-implemented firewalls are effective. 
-removeable media. sensitive data is only written to a removeable disk
  which is locked up when the console is not occupied. considering the
  speed penalty of typical removeable media, it's reasonable to assume
  most such systems keep the kernel, swap space, etc., on permanent
  media, thus making the entire measure value-free. it's also terribly
  inconvenient. 
-smart cards. these are very small computers that variously rely on
  you to pass information between the host and the card, or interface
  directly with the host through a serial port or somesuch. the
  biggest plus of the smart card is that secret information never sits
  in the host's memory, even briefly. a password is never entered
  into the host (and thus can *never* be violated by a net-bound
  attacker), and an unencrypted private key never sits on the host
  (providing similar protection for the various big secret numbers of
  the public key algorithms). it also provides a secure environment
  for the certification of signatures: the program the card runs isn't
  subject to modification, etc. 
  a properly implemented smart card is incapable of revealing any
  secret information it holds, will perform no operations requiring
  secret information until some form of input verifies the identity of
  the user (a password), and automatically times out a session based
  on preset criteria. presumably, the card's ability to perform
  operations requiring secret information is restricted by
  cryptographically robust mechanisms, i.e. the private key(s) are
  themselves encrypted in [a hash of] your passphrase, which is itself
  never stored in the card (though present for a fleeting few moments
  of calculation, clearly).

subsidiary costs are associated with reliable maintenance of host and
LAN integrity. all the hosts and associated network hardware to be
protected have to be on uninterruptible power, for one thing, and this
ain't cheap. theoretically, the users of the system needn't be too
aware of the web of trust/distrust underlying the environment, but
practically, they usually are. this is a failing of software
implementors more or less. the worst-case scenario is a weapons design
facility or somesuch, where the distrust extends to the legitimate
users themselves. then you get coming-and-going body searches, metal
detectors, etc. what a nightmare. if the software security folk had
done their job right none of this would make a pint of difference.
can't very well make the users forget what they were working on when
they leave, then magically remember it the next morning when they come
back to work.

one major caveat to all this discussion is that if your host will be
exposed to the internet, you've got to be using a kerberos-like system
religiously. that's the easiest thing of all to accomplish, more or
less, and only makes sense. kerberos offers a fundamental starting
point for identity verification and guarantees of net-bound message
integrity and privacy, without any loss of functionality. it's also
come to be supported by vendors with decent integration into their
distributed OS releases.

if this is my $.02, then clearly i'm using those giant incan stone
coins... :-)

-- 
-daniel	(douzzer@athena.mit.edu)  i've been here and i've been there and
 key  0B 99 0D 4F E8 55 9A 95     i've been inbetween. i talk to the wind,
print 43 C1 7F B5 DF 8F E3 33     my words are all carried away.
key: finger douzzer@ai.mit.edu    the wind cannot hear.
