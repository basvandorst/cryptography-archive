Path: msuinfo!agate!howland.reston.ans.net!europa.eng.gtefsd.com!uunet!ax!elsewhere!ron
From: ron@elsewhere.UUCP (Ronaldo E Bartl)
Newsgroups: sci.crypt
Subject: Re: Challenge/response auth methods.
Message-ID: <Ep1KtAtEBh107h@elsewhere.UUCP>
Date: Wed, 5 Jan 94 21:24:36 -0300
References: <2f66vt$eod@mailhost.interaccess.com> <JIS.93Dec19023537@big-screw.MIT.EDU> <phrCI0tps.4BC@netcom.com> <1993Dec13.204000.4737@cc.ic.ac.uk> <bbosenCIEt6G.A9x@netcom.com>
Organization: Airtight Software
Lines: 56

In <bbosenCIEt6G.A9x@netcom.com> bbosen@netcom.com (Bob Bosen) writes:

>I am _seriously_ considering offering general-purpose support for
>"algebraicilly-defined" arbitrary authentication algorithms in my
>company's user authentication software products. If we decide to go
>ahead with this, supervisors could assign any kind of mathematical
>algorithm they could describe, for use by any user. Users could then
>use any means at their disposal to satisfy the challenge. I'm still
>soliciting opinions on this idea....

If you're willing to spend a bit more on a programmable calculator,
you could try something from fractal theory. For example, take the
equation defining Julia Sets:

       2
z  = z    + c
 n    n-1

where z and c are complex numbers. You could assign a c to each user,
challenge them with a z (2 10-digit numbers). The answer would be the
number of iterations needed to determine if the equation converges or
not, modulus 100 (or whatever). It's what produces the kind of fractal
graphics you see in magazines. The strength of this method resides in:

a) there are 10^20   possible "passwords" -- values of c (assuming 10 digits)

b) there are no known shortcuts - the attacker would have to try all
   possible passwords, which is quite time consuming, and would get
   10^18 possible answers on average (assuming an uniform distribution
   of values, probably wrong, but not by that much)

c) fractals are _very_ sensitive to rounding errors, so the attacker 
   would have to emulate your calculator exactly, which could cost
   some time. (caveat - you have to do it also, but you only have to
   compute _one_ point; it can take a few miliseconds more)

d) after observing about 10 challenge/responses the attacker has all
   the data he needs; but he would have to calculate a bit over 10^21
   points to get the answer. Assuming 10^3 operations per point (all
   double precision floating-point) and he could be doing 10^9 (a GIGA
   flop) per second (not on _my_ PC), he would spend 10^15 seconds to
   get the key. This is on the order of a 'few' million years... Enough
   to make me feel safe.

You could make some changes if you feel that a 1% chance of breaking in
is to high - for example, the response could be the last x digits after
y iterations. This reduces the amount of data an attacker needs to guess
the key, but he would still have to compute >10^20 points.

Any comments??? Feel free to mail me or post

Ron

-- 
Ronaldo E. Bartl   
ron%elsewhere@ibase.br
