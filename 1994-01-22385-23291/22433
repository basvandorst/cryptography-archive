Path: msuinfo!agate!howland.reston.ans.net!europa.eng.gtefsd.com!uunet!noc.near.net!news.delphi.com!usenet
From: Ted Kaliszewski <TED89@delphi.com>
Newsgroups: sci.crypt
Subject: Factoring N+P*Q when (e,N,d) is known.
Date: Sun, 2 Jan 94 13:01:28 EST
Organization: Delphi Internet
Lines: 29
Message-ID: <940102.46888.TED89@delphi.com>
NNTP-Posting-Host: delphi.com


      Readers of my previous postings on the subject of "Easy Factoring"
have asked that I demonstrate in some detail the DeLaurentis algorithm.
While there is no substitute for reading the author's article(1) an example
might suffice at this time. As they say, numbers speak louder than words!
Here is a 49-digit example(e,N and d are parameters of a RSA cryptosystem):
      e=65537
      N=115 333 506 305 204 886 095 452 340 816 896 880 529 383 747 320 3
      d=790 230 826 423 077 071 765 594 530 106433 838 132 672 090 433
      e*d-1=2^k*delta=m*phi(N)
In our example,
      k=6 and delta is an odd integer
Obviously, if (a,N)=1 and 1<a<N-1 then
      a^phi(N)=1(mod N), always.
If for 1<k'<k
      a^(2^k'-1)*delta=b(mod N)
then
      (b-1,N)=P or Q
The algorithm factors N for k'=2, a=632 299 400 82752 in, about, 10 minutes
on my 16-MHz PC. If you can do better with, say, the CF or Pollard's (p-1)
factoring method, please, let me hear about it.
Reference:
      1. John M. DeLaurentis
         A Further Weakness in the Common Modulus Protocol
         for the RSA Cryptoalgorithm
         Cryptologia,8(3),253-259,1984



