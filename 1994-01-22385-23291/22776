Newsgroups: sci.crypt
Path: msuinfo!agate!library.ucla.edu!europa.eng.gtefsd.com!uunet!olivea!sgigate.sgi.com!sgi!wdl1!io!koontzd
From: koontzd@io.lrcs.loral.com (David Koontz )
Subject: Re: Initial Permutation, DES
Message-ID: <1994Jan11.200952.29008@wdl.loral.com>
Originator: koontzd@io
Sender: news@wdl.loral.com
Organization: Loral Rolm Computer Systems
Distribution: usa
Date: Tue, 11 Jan 1994 20:09:52 GMT
Lines: 51



>You could use the scheme table1[block.byte[i]], if your willing to shift
>the result by 1 of 8 distances (including zero):
>
>        for (i = 0; i < 8; i++) {
>            pblock.w32[0] |= table1[block.byte[i]] << (i * 4);
>            pblock.w32[1] |= table2[block.byte[i]] << (i * 4);
>	}
>
>( direction of shift subject to your whim as to endianness )
>

You could also get away with a single 256 byte table by targetting which
byte of pblock you drop the result in instead of shifting by 4 * i.

union block_64 { 
    unsigned long w32[2];
    unsigned char byte[8];
};

unsigned char input_byte[8]; /* input block in bytes */

int i;	/* input/output block byte pointer */
int j;  /* byte within L/R block pointer */ 

#define LEFT 0;
#define RIGHT 1;

static unsigned char ip_table[256] = {....};

static union block_64 lrblock;

    lrblock.w32[LEFT] = lrblock.w32[RIGHT] = 0;

/* initial permutation */

    for ( i = 0,j = 0; j < 4; j++ ) {
	lrblock.byte[j]   |= ip_table[input_byte[i] ] );
	lrblock.byte[j+4] |= ip_table[input_byte[i++] >> 1 ] );
	lrblock.byte[j]   |= ip_table[input_byte[i] ] << 4;
	lrblock.byte[j+4] |= ip_table[input_byte[i++] >> 1 ] << 4;
    }

/* (which can be unfolded to get rid of i and j) */

/* des round code goes here */

/* inverse initial (final) permutation */

   ....
