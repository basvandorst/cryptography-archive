Newsgroups: sci.crypt
Path: msuinfo!agate!howland.reston.ans.net!europa.eng.gtefsd.com!uunet!olivea!sgigate.sgi.com!sgi!wdl1!io!koontzd
From: koontzd@io.lrmsc.loral.com (David Koontz )
Subject: Re: The DES Initial Permutation
Message-ID: <1994Jan13.170829.14471@wdl.loral.com>
Sender: news@wdl.loral.com
Organization: Loral Rolm Computer Systems  
References: <phrCJGMro.5Bz@netcom.com> <1994Jan11.192225.27893@wdl.loral.com> <jktaberCJJtJ0.B1M@netcom.com>
Date: Thu, 13 Jan 1994 17:08:29 GMT
Lines: 130

>From: jktaber@netcom.com (John K. Taber)
>
>David Koontz (koontzd@io.lrmsc.loral.com) wrote:
>
>[a nice explanation of the IP]
>
>I want to thank David Koontz for setting me straight on the IP.  His
>explanation convinces me that it was indeed considerations of
>implementing the DES on chips available at that time (1979?) which
>explain the IP.

The time for the first DES chips were both 1977.  The Fairchild 9414-x
(a 4 bit chip set of a vintage with the KG-80), and the Intel 8274(?)
capable of operating at slow MODEM speeds, based on the 8031 slave
processor.

I new there was a compact/fast table lookup based Initial Permutation
lurking in there somewhere.  This one uses 512 bytes of table lookup and 26
operations to do arbitrary orientation 32 bit L and R blocks.  An
arbitrary orientation allows you to play nice games for fast Expansion
Permutation.  The ip table lookup size is 512 bytes.

There is of course another variation, doing the IP into E space  (Expansion 
Permutation), where L/R are represented always as 48 bit entities.  The IP
would be slower and use a 1K byte ip table, but you never have to do the 
Expansion Permutation.

/* Initial Permutation done with minimum table size */
union block_64 {
    unsigned long wd[2];
    unsigned char byte[8];
};

unsigned long ip [128] = { /* 4 bits per byte to 4 bits of long lookup 
				3 interlaced bits of byte index */

  /* 
   * Bits 6,4,2,0 (L Block bits, see below) are input byte bits
   * Bits  5,3,1 are input byte index
   */

  /* The actual table contents are sensitive to the L/R block element
   * orientation
   */

};
union block_64 input;  /* from somewhere else */

union block_64 left,right; /* 64 bit pre IP structures (unions)    */
unsigned long Left, Right; /* Left and Right blocks, 32 bit values */

/* ip enmass preparation values: */

#define AND_MASK 	0x55555555L

/* interlaced byte indexes for ip table: */

#ifndef LITTLE_ENDIAN	/* BIG ENDIAN */

#define OR_MASK0	0x0002080AL	/* 0 1 2 3 */
#define OR_MASK1	0x2022282AL	/* 4 5 6 7 */

#else   		/* LITTLE ENDIAN */

#define OR_MASK0	0x0A080200L	/* 3 2 1 0 */
#define OR_MASK1	0x2A282220L	/* 7 6 5 4 */

#endif

left.wd[0]  = input.wd[0] & AND_MASK;
left.wd[0] |= OR_MASK0;
left.wd[1]  = input.wd[1] & AND_MASK;
left.wd[1] |= OR_MASK1;

right.wd[0]  = (input.wd[0] >> 1) & AND_MASK;
right.wd[0] |= OR_MASK0;
right.wd[1]  = (input.wd[1] >> 1) & AND_MASK;
right.wd[1] |= OR_MASK1;

Left  = ip [left.byte[0]];	/* L32,L24,L16,L8 */
Left |= ip [left.byte[1]];	/* L31,L33,L15,L7 */
Left |= ip [left.byte[2]];	/* L30,L22,L14,L6 */
Left |= ip [left.byte[3]];	/* L29,L21,L13,L5 */
Left |= ip [left.byte[4]];	/* L28,L20,L12,L4 */
Left |= ip [left.byte[5]];	/* L27,L19,L11,L3 */
Left |= ip [left.byte[6]];	/* L26,L18,L10,L2 */
Left |= ip [left.byte[7]];	/* L25,L17,L9 ,L1 */

Right = ip [right.byte[0]];	/* R32,R24,R16,R8 */
Right |= ip [right.byte[1]];	/* R31,R33,R15,R7 */
Right |= ip [right.byte[2]];	/* R30,R22,R14,R6 */
Right |= ip [right.byte[3]];	/* R29,R21,R13,R5 */
Right |= ip [right.byte[4]];	/* R28,R20,R12,R4 */
Right |= ip [right.byte[5]];	/* R27,R19,R11,R3 */
Right |= ip [right.byte[6]];	/* R26,R18,R10,R2 */
Right |= ip [right.byte[7]];	/* R25,R17,R9 ,R1 */

/* 
 * FIPS Pub 46-x has the most significant bit of the input block/byte
 * as bit 1.  Conversion to Bit 7 MSB ( Bit7 = 1 << 7 ) Bytes is shown:  
 *
 * (FIPS Pub 46 numbering convention)
 *
 * Port  Byte             Input   (LR)
 * Bit   Bit              Block (64 bits)         Left Block (32 bits)
 *
 *  2-----6---------58 50 42 34 26 18 10  2        1  2  3  4  5  6  7  8
 *  4-----4---------60 52 44 36 28 20 12  4        9 10 11 12 13 14 15 16
 *  6-----2---------62 54 46 38 30 22 14  6       17 18 19 20 21 22 23 24
 *  8-----0---------64 56 48 40 32 24 16  8       25 26 27 28 29 30 31 32
 *
 *                                                Right Block (32 bits)
 *
 *  1-----7---------57 49 41 33 25 17  9  1        1  2  3  4  5  6  7  8
 *  3-----5---------59 51 43 35 27 19 11  3        9 10 11 12 13 14 15 16
 *  5-----3---------61 53 45 37 29 21 13  5       17 18 19 20 21 22 23 24
 *  7-----1---------63 55 47 39 31 23 15  7       25 26 27 28 29 30 31 32
 *
 * Input Byte        7  6  5  4  3  2  1  0
 *
 * The ip table is given for Left Block bits, and can be used for Right Block
 * bits by shifting the input value down.  Only four bits of inputs are 
 * significant.  This allows the ip table size to be reduced to from 256
 * words to 128.  The remaining 3 bits are used as input byte indexes, added
 * by masks, to eliminate shift operations.  This has the added benefit of
 * allowing the L/R bits to be defined anywhere in the 32 bit value (long)
 * for optimizing E permutation dependent operations.  The result is 26
 * operations (10 for setting up inputs, 16 for table operations) in the
 * unlooped thread.
 */
