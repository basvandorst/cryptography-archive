Newsgroups: sci.crypt
Path: msuinfo!agate!howland.reston.ans.net!europa.eng.gtefsd.com!uunet!olivea!decwrl!decwrl!amd!netcomsv!netcomsv!netcom.com!straits
From: straits@netcom.com (Stewart C. Strait)
Subject: Re: Xor encryption
Message-ID: <straitsCJx4BM.B79@netcom.com>
Organization: NETCOM On-line Communication Services (408 241-9760 guest)
X-Newsreader: TIN [version 1.2 PL1]
References: <1994Jan12.143159.20474@ericsson.se>
Date: Thu, 20 Jan 1994 07:47:46 GMT
Lines: 97

Here are some ways to break the periodic XOR cipher.  Pencil and
paper will be adequate in many cases.  The reader may wish to
write a program to implement some of these methods.

Before we start, here is pseudocode for the cipher, mainly
to make sure that the reader knows exactly what system is
being discussed.

N is length of message in bytes
L is length of key in bytes
p[i]=(i+1)st byte of plaintext
c[i]=(i+1)st byte of ciphertext
k[i]=(i+1)st byte of key

loop for i=0 to L-1
    c[i]=p[i] xor k[i mod L]
end of loop

This pseudocode can be used either to encipher or decipher.
Note that a xor b xor b = a for any a and b.

1.  Periodic XOR can sometimes be broken by a single glance at the
ciphertext.

Example:

  Ciphertext: sesamesesamesesamesesamese{unreadable}

If the plaintext begins with many spaces (hex 20) and the key is
"SESAME", we will get this ciphertext.  XORing an alphabetic character
with a space gives the same character except lower and upper case
are reversed.  If the ciphertext has a word or phrase repeated, or many
repeated fragments of the word or phrase, the key is almost certainly
the word or phrase (case reversed), and the plaintext has many blocks
of consecutive spaces.  (Thanks to Richard Villanueva for pointing
this out to me.)

2.  If the plaintext is unknown, we can begin by finding L.

Example:
  Hex key:          F9 BA 5A
  Ascii Plaintext:  N  o  w
                       i  s
                       t  h
                    e     t
                    i  m  e
                       f  o
                    r     a
                    l  l
                    g  o  o
                    d     m
                    e  n
                    t  o
                    c  o  m
                    e     t
                    o
  (Now is the time for all good men to come to...)
Note that every byte in the first column is XORed with F9.  Every
plaintext byte is XORed with the key byte in its column.  Note that
there are two occurances of "e t" starting in the first column and
two occurances of "me" starting in the last column.  Both "e t"
strings will give the same ciphertext.  Both "me" strings will also.

In general, if plaintext is repeated at intervals divisible by L, then
the plaintext will be in the same columns and the ciphertext is also
repeated.  This means that if you find all (or many) repeated strings
in the ciphertext, many of the intervals between repetitions are divisible
by L.  The Kasiski method is to pick L to be a common factor of many
of the repetition intervals.  Some repetitions are accidents, so we
can't just take the greatest common factor of all the intervals--that
usually is 1.

3.  Once we know L, we write the ciphertext in L columns.  Now we break
each column separately.  We find, perhaps by exhaustion, the key that
makes the plaintext for that column have byte frequencies that we
expect for plaintext.  For ASCII English text, this means that <space>
is most common, followed by "e" and "t", with very few bytes >=hex 80.
A shortcut is to find the most common byte in the column and XOR it
with hex 20, which is a space, to get the key.  If the column really
had more spaces than anything else this will work.  (With ASCII text,
this is practically certain.)

If the plaintext has all the spaces removed, we may need to
assume that "e" or "t" or some other character is the most common.
Removing the spaces is a traditional precaution.  In modern terminology
it is a form of slightly lossy compression.

If the plaintext has very odd frequency behavior, breaking the cipher
will require partial knowledge of this behavior.  If the plaintext
is so odd you can't recognize that it _is_ plaintext, solution is
impossible.  This is unlikely--usually the plaintext would be machine
language or some other standard binary file format and you could
learn to recognize such things.

-- 
Stewart C. Strait
straits@netcom.com
