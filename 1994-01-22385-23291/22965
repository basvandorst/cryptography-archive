Path: msuinfo!uwm.edu!csd4.csd.uwm.edu!mjk
From: mjk@csd4.csd.uwm.edu (Melinda J Kanavas)
Newsgroups: sci.crypt
Subject: Question about the weakness of a scrambling encryption scheme
Date: 18 Jan 1994 20:34:03 GMT
Organization: Computing Services Division, University of Wisconsin - Milwaukee
Lines: 90
Distribution: usa
Message-ID: <2hhh3rINNd1m@uwm.edu>
NNTP-Posting-Host: 129.89.7.4
Originator: mjk@csd4.csd.uwm.edu


	I was wondering about the weakness of a mini-encryption scheme
that I have developed.  I will attempt to simply describe it here.  It
calles on a random_number_generator() function which I will call
rng().  Now I think that a simple linear congruential random number
generator would be sufficient for my algorithm, but let's just say
that the rng() function operates on 16 global seeds and returns the
sum mod 10^10 and then divides that by 10^10 to produce a number from
0 to 1.
	First of all, a password array contains a user-entered
numerical password, or more likely a secure hash function on a pass
phrase.  It would be about length 16, with each number ranging from 0
to 10^10.  The first operation it does is initialize the rng()
variables from the given password array.

1) Erase the seed array or start it with given random numbers.
2) Start loop from 1 to 16 - store current in C.
3) Start another loop from 1 to 16 - store current in B.
4) Perform an operation on each seed, each calling on the rng()
function.  Say the old value of the global seed was X.
Then take (mod 10^10): X+(X mod 10^5)*(rng()*10^5)+int(x/10^5)*(rng()*10^5)
+(C*263+B*33)*X+Password(int(rng()*16)+1)... and so on.  The general
rule is that the random numbers do not repeat every 16*n times where n
is an integer - if they don't do this, then there will be few
redundancies.
Maybe I'm not exactly making myself clear when I say 'and so on'.
Basically, it just takes the upper portion of the next password entry
and multiplies it by a random number.  The key principle is that there
is no recognizable correlation between the random number and the
password value - they aren't dependent on each other.
5) Close the loops.

This is the function seed().
Then basically it generates an entire random number sequence the same
length as the message using the same idea - but NOT depending on the
data itself - just on the random seeds, rng() function, and password
values.  The same type of operations are performed - like (rng*10^5) *
a password value + (rng*10^5) * an already stored random number.  So
they could also recursively call on other stored random numbers.
Then after this array of random numbers was generated, a scramble
function would be called on to reduce the correlation between a given
random number and the next one after that.  Basically, according to
the rng() function, it would go from start to finish, swapping digits
at random places.  Now I would modify this algorithm if I was more
sure that the method was secure.

	After it completed scrambling the random numbers, it would add
those to the data, mod 10^10.
	Then it would scramble the data itself to reduce redundancies
in the data - the same idea would be used - swapping the current digit
with a random one.  However, to decrypt, each value must be stored,
because you can't generate the random numbers in reverse order.  As a
result, I would just do a basic scramble - only the digits at the same
number in the array could be scrambled.
	Now I have tried this method, and with a good rng() function,
it produces well scrambled data - there is a very good distribution of
the data.
	I can see how computers and cryptanalysis can predict one
random number from the previous, but when the actual order is changed,
I do not see any alternative but a brute force attack in order to
attempt to crack it.  There is little or no redundancies, and guessing
plaintext does not help that much, because the order is dependent on
the password.
	In order to prevent possible weaknesses, I could modify so
that the output would be different each time - (by encrypting a random
array of password data under the user's password, and encrypting the
data using the random array - these random numbers would be from a
truly random source - like keystrokes or something.  Then, in
encrypted form, the random password would be added to the message, and
possibly scrambled along with it, as I have implemented.)
	The following part is optional, but to check that the message
was not altered, and that the password is correct, a hash function
would be performed on the plaintext and then added to the end.  But
without this, no one could ever be completely sure that they have
recovered the correct plaintext - if they were sending truly random
numbers, for example, for a new password - then, without this hash
function, the encryption algorithm would be more secure.  Please
correct me if I am wrong.
	Then, is there any major weakness with the generate and
scramble method that I have described.  Has it been described before?
You may send e-mail or just post a response.









