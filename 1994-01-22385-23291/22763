Newsgroups: sci.crypt
Path: msuinfo!uwm.edu!news.moneng.mei.com!howland.reston.ans.net!europa.eng.gtefsd.com!uunet!decwrl!decwrl!netcomsv!netcom.com!phr
From: phr@netcom.com (Paul Rubin)
Subject: Re: The DES Initial Permutation
Message-ID: <phrCJGMro.5Bz@netcom.com>
Organization: Netcom - Online Communication Services (408 241-9760 guest)
References: <jktaberCJ6tx7.9Cw@netcom.com> <CJ7tnv.AB2@cbfsb.cb.att.com> <1994Jan7.110304.7359@devvax.mincom.oz.au>
Date: Tue, 11 Jan 1994 10:07:00 GMT
Lines: 16

In article <1994Jan7.110304.7359@devvax.mincom.oz.au> eay@mincom.oz.au (Eric Young) writes:
>Most fast DES implementations take 10 shifts, 5 ands and 15 xors to do the
>IP and the same to do the FP.
>On a quick test run on a 486/50 (gcc) these 60 instructions cause a %12
>slowdown on the des library I use which has 4k S table lookup.  For the
>versions of DES with bigger lookup tables, the performace hit would be
>a much larger percentage.

I would have thought the obvious way to do the IP/FP was
	union {long int w32[2], byte[8]; };
	for (i = 0; i < 8; i++) {
		pblock.w32[0] |= table1[block.byte[i]];
		pblock.w32[1] |= table2[block.byte[i]];
	}
with the loop unrolled, of course.  I think it comes out a few
instructions shorter if the right address modes are used.
