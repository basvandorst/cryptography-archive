Newsgroups: sci.crypt
Path: msuinfo!uwm.edu!vixen.cso.uiuc.edu!howland.reston.ans.net!cs.utexas.edu!uunet!olivea!sgigate.sgi.com!sgi!wdl1!io!koontzd
From: koontzd@io.lrmsc.loral.com (David Koontz )
Subject: Re: The DES Initial Permutation
Message-ID: <1994Jan11.192225.27893@wdl.loral.com>
Sender: news@wdl.loral.com
Organization: Loral Rolm Computer Systems  
References: <CJ7tnv.AB2@cbfsb.cb.att.com> <1994Jan7.110304.7359@devvax.mincom.oz.au> <phrCJGMro.5Bz@netcom.com>
Date: Tue, 11 Jan 1994 19:22:25 GMT
Lines: 128

>From: phr@netcom.com (Paul Rubin)
>
>In article <1994Jan7.110304.7359@devvax.mincom.oz.au> eay@mincom.oz.au (Eric
>You
>ng) writes:
>>zMost fast DES implementations take 10 shifts, 5 ands and 15 xors to do the
>>IP and the same to do the FP.
>>On a quick test run on a 486/50 (gcc) these 60 instructions cause a %12
>>slowdown on the des library I use which has 4k S table lookup.  For the
>>versions of DES with bigger lookup tables, the performace hit would be
>>a much larger percentage.
>
>I would have thought the obvious way to do the IP/FP was
>        union {long int w32[2], byte[8]; };
>        for (i = 0; i < 8; i++) {
>                pblock.w32[0] |= table1[block.byte[i]];
>                pblock.w32[1] |= table2[block.byte[i]];
>        }
>with the loop unrolled, of course.  I think it comes out a few
>instructions shorter if the right address modes are used.


Seems to be missing the index into the two tables (table1,table2) showing
which byte the input is:

table1[i][block.byte[i]], etc., each byte of input goes to unique locations
in two w32s (R and L blocks).

The tables are 256 (byte size) X 8 (number of bytes contributing to each
block) X 4 (bytes in a w32):

unsigned long ip_table1[8][256], ip_table2[8][256];
unsigned long fp_table1[8][256], fp_table2[8][256];

or

unsigned long ip_table[8][256][2];
unsigned long fp_table[8][256][2];

for keeping keeping them close together.

You could use the scheme table1[block.byte[i]], if your willing to shift
the result by 1 of 8 distances (including zero):

        for (i = 0; i < 8; i++) {
            pblock.w32[0] |= table1[block.byte[i]] << (i * 4);
            pblock.w32[1] |= table2[block.byte[i]] << (i * 4);
	}

( direction of shift subject to your whim as to endianness )

This has the advantage of smaller tables, easier on cache.  You can get
it down to one table by doing a shift right by 1 on the input value.  The
256 byte table is set up for odd bits (numbered 1 thru 8 per FIPS Pub 46),
shifting the bits down (toward MSB) by one allows you to use the same 
table for the second block.  You end up with a single 256 entry table of
32 bit values.  The FP table will be the same size.

Consider a byte wide interface with the bits numbered 1-8.
The even numbered bits go to the L block, and the odd number of bits
go to the R block.

Input Byte to 32 bit value:

(FIPS Pub 46 numbering convention)

Port                    Input   (LR)            Left
 Bit                    Block (64 bits)         Block (32 bits)

  2---------------58 50 42 34 26 18 10  2        1  2  3  4  5  6  7  8
  4---------------60 52 44 36 28 20 12  4        9 10 11 12 13 14 15 16
  6---------------62 54 46 38 30 22 14  6       17 18 19 20 21 22 23 24
  8---------------64 56 48 40 32 24 16  8       25 26 27 28 29 30 31 32

                                                Right
                                                Block (32 bits)

  1---------------57 49 41 33 25 17  9  1        1  2  3  4  5  6  7  8
  3---------------59 51 43 35 27 19 11  3        9 10 11 12 13 14 15 16
  5---------------61 53 45 37 29 21 13  5       17 18 19 20 21 22 23 24
  7---------------63 55 47 39 31 23 15  7       25 26 27 28 29 30 31 32

Input Byte         8  7  6  5  4  3  2  1

R16L16 to Output Byte:

Right                     Output (R16L16)                    Port
Block (32 bits)           Block (64 bits)                     Bit

 1  2  3  4  5  6  7  8    1  2  3  4  5  6  7  8--------------2
 9 10 11 12 13 14 15 16    9 10 11 12 13 14 15 16--------------4
17 18 19 20 21 22 23 24   17 18 19 20 21 22 23 24--------------6
25 26 27 28 29 30 31 32   25 26 27 28 29 30 31 32--------------8

Left
Block (32 bits)

 1  2  3  4  5  6  7  8   33 34 35 36 37 38 39 40--------------1
 9 10 11 12 13 14 15 16   41 42 43 44 45 46 47 48--------------3
17 18 19 20 21 22 23 24   49 50 51 52 53 54 55 56--------------5
25 26 27 28 29 30 31 32   57 58 59 60 61 62 63 64--------------7

Output Byte                8  7  6  5  4  3  2  1

>From Fips 46:

Final Permutation IP-1:
                          Output Byte
40  8 48 16 56 24 64 32         1
39  7 47 15 55 23 63 31         2
38  6 46 14 54 22 62 30         3
37  5 45 13 53 21 61 29         4
36  4 44 12 52 20 60 28         5
35  3 43 11 51 19 59 27         6
34  2 42 10 50 18 58 26         7
33  1 41  9 49 17 57 25         8

 1  2  3  4  5  6  7  8 Port Bit

Without checking code I wrote long ago, the convention is that bit 8
is Least signficant and bit 1 is most significant for purposes of
test values (FIPS Special Pub 5000-20) and connecting to ASCII.

pblock needs both members cleared before the first use and each subsequent
use.  Two 256 entry tables of longs ain't that bad.



