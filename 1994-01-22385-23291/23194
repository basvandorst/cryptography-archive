Path: msuinfo!agate!howland.reston.ans.net!sol.ctr.columbia.edu!news.kei.com!bloom-beacon.mit.edu!senator-bedfellow.mit.edu!athena.mit.edu!pshuang
From: pshuang@athena.mit.edu (Ping-Shun Huang)
Newsgroups: alt.comp.compression,comp.compression,sci.crypt
Subject: Re: 60 characters to 10 (or 25 or 6 to 4)
Date: 27 Jan 1994 02:59:41 GMT
Organization: Massachusetts Institute of Technology
Lines: 24
Message-ID: <PSHUANG.94Jan26215940@ninja.mit.edu>
References: <CK5Mn8.E8I@lehman.com>
NNTP-Posting-Host: ninja.mit.edu
In-reply-to: cvalcarc@lehman.com's message of Mon, 24 Jan 1994 22:04:19 GMT
Xref: msuinfo alt.comp.compression:620 comp.compression:10417 sci.crypt:23194

In article <CK5Mn8.E8I@lehman.com> cvalcarc@lehman.com (Carlos Valcarcel) writes:

 > I have a string that can be up to 60 characters long.
 > I need a unique string that is approx. 10 characters long
 > (can be longer, but we would like something compact).

You can use a hashing algorithm to perform this "reduction". For
example, calculating a "standard" CRC-32 is easy to do, there should be
some code freely available to do so. Calculating three CRC-32's using a
different prepended seed each time will give you 12 bytes. However, most
hashing algorithms will not guarantee that the result will be unique.
You can easily see that there are 2^480 possible 60-character strings
(assuming character means 8-bit byte), but only 2^80 possible
10-character strings, hence a unique, e.g., bijective, hash function
that yields a shorter string than its argument is impossible.

To guarantee uniqueness, you must keep track of previous "hash" values.
But if you must keep track, then you might just want to dump the hash
entirely and number 60-character strings consecutively in order that
they are encountered/used.

--
Ping Huang (INTERNET: pshuang@mit.edu), probably speaking for himself

