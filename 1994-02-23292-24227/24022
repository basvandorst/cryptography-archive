Newsgroups: comp.arch.storage,sci.crypt
Path: msuinfo!harbinger.cc.monash.edu.au!bunyip.cc.uq.oz.au!cxbne!rick
From: rick@cxbne.cx.OZ.AU (Ulrich Mack)
Subject: Re: Secure disk erasing
Organization: Comperex Australia Pty Limited
Date: Tue, 22 Feb 1994 22:53:24 GMT
Message-ID: <1994Feb22.225324.16172@cxbne.cx.OZ.AU>
References: <1994Feb22.140344.16667@mnemosyne.cs.du.edu>
Lines: 257
Xref: msuinfo comp.arch.storage:2711 sci.crypt:24022

colin@nyx10.cs.du.edu (Colin Plumb) writes:

>I'm trying to work out the best way to securely erase sensitive data
>from a magnetic disk, in software, in such a way that there is no hope
>of ever recovering it, including by such methods as taking the disk
>apart, attaching fine iron filings, and examining the result under
>an electron microscope.  (Or any other very aggressive data-recovery
>technique you care to think about.)

>While I hear it's possible in some situations, destroying the disk
>in software is not desirable, either.

>For small amounts of data erased infrequently, many, many overwrites can
>be done in a reasonable amount of time.  That's the basic technique I'm
>trying to explore, but figuring what is the best way to do those overwrites,
>especially in a random PC hardware box where you don't know a lot about
>the underlying hardware, is interesting.

>I'd like advice on how to do it (note the crossposting).  To give you
>some place to start, the following is my current thinking.  Comments
>are very welcome!  (Floppy ideas are also welcome, although they are
>much more of a known system and so easier to work with.)

>How to overwrite a disk

>This is an attempt at defining a maximum-overkill pattern for wiping 
>data from hard disks.  Obviously, a single overwrite will make it 
>much more difficult to recover the data, but some advanced drives
>can offset the head when reading (usually used when retrying a failed
>read, it is often available via SCSI commands for diagnostic purposes),
>and I have heard reports that people have recovered overwritten data
>from software using this.

>Even more aggressive, you can take the drive apart and go at it with 
>special equipment to try to recover several layers back in the writing.  
>Historically, this has been done on magnetic tape, and one must presume 
>that similar things are possible with magnetic disks.

>Government standards for declassifying hard drive seem to involve 
>physical removal of the oxide layer (with acids or abrasives).  As this 
>limits the drive's future usefulness, it is usually unacceptable for 
>individual users.  Nonetheless, individual users might want an
>inexpensive way to ensure that data has been erased beyond the reach of
>even a very powerful opponent.

>I'm looking for something that will irretrievably wipe sensitive data 
>from a hard disk.  As long as it's only used for small amounts of data 
>(say, master encryption keys), it will have reasonable performance, and 
>if you want to wipe a whole disk more thoroughly than reformatting, well 
>it'll take a fair bit longer than reformatting.

>The first thing to do is to try to cover the entire track area.  Every 
>disk write has to hit the centre of the track so that later reads can 
>find it, but there is some inaccuracy resulting in erratic covering
>of the fringes.

>There are thermal expansion issues and a number of other parameters that 
>affect head alignment but essentially impossible to measure or control 
>in software.  I can't account for them, except to advise rerunning the 
>wipe in different ambient temperatures (such as different times of day).

>But head play due to seeks can be affected by software, and I think it's
>worth exploiting.  I would, between passes of overwriting, perform seeks
>in both directions, both small and large.  On the theory that large 
>seeks are more or less interchangable, I'd try 1, 2, 4, 8, 16, 32, 64, 
>128, 256, ... tracks from the current position, then back.  An 
>unresolved question is whether reading from different heads on the same 
>cylinder is of any use.  In embedded-servo systems (each surface has its 
>own alignment markings), I'd think that would tend to offset the head a 
>little, too.  Or is a seek just as good?  Well, there is the point that
>a drive doesn't wait to settle as long between switching heads.  Thus,
>the disk might actually be more out of alignment.  Comments?

>Another possible pattern is the Fibonacci sequence, which is also 
>geometric, just with a different multiplier.  Of course, seeks should
>be performed in both directions from the centre.

>Then we come to the issue of patterns.  The basis of erasing is to use a 
>high-frequency oscillating field.  Thus, we want the disk head 
>oscillating at the highest possible frequency.  Here, things get 
>interesting.

>Magnetic media are limited in their ability to store high-frequency
>oscillations.  (That's why it works for erasing.)  If you want reliable
>readback (we don't, but the disk assumes we do, so we have to work 
>within that), you can't place transitions too closely together.  You
>also can't place them too far apart, or you lose track of where you are.
>Hard drives deal with this by encoding the user data with a family
>of codes called run-length limited (RLL) codes.  There are three RLL 
>codes in common use on hard drives:

>(1,3) RLL, also known as MFM
>(2,7) RLL, the "RLL" that was all the rage some years back
>(1,7) RLL, which is common on newer hard drives

>Fortunately, each of these has very standard coding tables and we can
>construct sequences which exercise the head as much as possible.

>At the lowest level on a disk, a 1 bit is represented by a transition
>(change in polarity) and a 0 bit is represented by none.  The desired
>erasing pattern is as many transitions as possible, or 111111111.....
>Unfortunately, all of these patterns are run-length-limited, meaning
>that there is always a run of zeros between adjacent one bits, so
>you can't get that.  For the (1,x) codes, the best you can do is 
>1010101..., and for the (2,7) code, the best is 100100100....

>So the next best thing is to write the densest pattern, phase-shifted.
>That is, write 10101010... followed by 01010101....  Or for (2,7) RLL,
>100100100, 010010010, and then 001001001.

>The problem then reduces to finding the user data pattern that will be
>encoded into the desired "raw" patterns.  This is made trickier by
>the fact that there are various eqivalently good ways to implement the
>codes, so a drive could use a variant.  Fortunately, the codes seem,
>in all the references I've seen, to be pretty standard.  MFM is 
>absolutely standard, the (2,7) RLL encodings seem to be agreed upon,
>and there while there are two sensible implementations of (1,7) RLL, 
>they are equivalent to inverting the input data and that turns out
>not to be a problem.

>For MFM, it's easy.  The patterns are all ones and all zeros.  
>Alternating these gives good erasure.

>For (1,7) RLL drives, the pattern is 00110011..., and its complement.
>The pattern 10011001... does NOT give a maximum-density erasure, but
>drive makers seem to like to keep things byte-aligned, so that sort
>of bit misalignment is unlikely to happen.  If it's a concern, you
>can add that pattern and its complement.

>For (2,7) RLL drives, you need three patterns.  Also, the byte 
>endianness question rears its head.  The previous two cases are
>not significantly affected by shifting the bytes around, but this
>one is.  Fortunately, thanks to the strong influence of IBM mainframe 
>drives, everything seems to be uniformly big-endian within bytes.  That 
>is, the most significant bit is written to the disk first.

>For (2,7) RLL, assuming the standard tables:

>10   -> 0100
>11   -> 1000
>000  -> 00100
>010  -> 100100
>011  -> 001000
>0010 -> 00100100
>0011 -> 00001000

>(This may look odd, but if you call the bit string a[0]b[0]a[1]b[1]a[2]b[2]...,
>then each decoded bit d[i] = a[i-1] | a[i]&~b[i+1] + b[i] & (a[i-2] | b[i-2]).
>This is fairly simple to implement in hardware and there's no remembered
>state, so small errors aren't magnified.)

>...the bit patterns 100100100..., 010010010... and 001001001... will 
>encode into the maximum-frequency encoded strings 010010010010...,
>100100100100..., and 001001001001....  Writing all three will cover
>all the bases.

>For the newest hard drives that use things like PRML (partial-response 
>maximum likelihood, which may be roughly equated to the trellis decoding 
>done by V.32 modems in that it's effective but computationally 
>expansive) techniques, the encoding may be one of the above, but may 
>also be modified in ways too obscure to second-guess.  Fortunately, if
>these drives require sophisticated signal processing just to read the 
>most recently written data, reading overwritten layers is also 
>correspondingly more difficult.  A good scrubbing with random data will
>do about as well as can be expected.

>After having gone through all that, it's time to suggest an overwrite 
>patten that incorporates them all.  Lots of random data is also 
>included, to make sure you can't apply some sort of "echo cancellation"
>which uses knowledge of the data to compute the effect of writing it
>and then corrects for that effect.  For that reason, cryptographically
>secure random data is preferred.

>So to deal with all these different types of drives in one overwrite
>pattern, I suggest the following 24-pattern sequence:

> 1) Random
> 2) 0000..., hopefully MFM encoded to 01010101...
> 3) 1111..., hopefully MFM encoded to 10101010...
> 4) Random
> 5) 010010..., hopefully (2,7) RLL encoded to 100100100100...
> 6) 100100..., hopefully (2,7) RLL encoded to 010010010010...
> 7) 001001..., hopefully (2,7) RLL encoded to 001001001001...
> 8) Random
> 9) 00110011..., hopefully (1,7) RLL encoded to 010101010101...
>10) 11001100..., hopefully (1,7) RLL encoded to 101010101010...
>11) Random
>12) 1111..., hopefully MFM encoded to 10101010...
>13) 0000..., hopefully MFM encoded to 01010101...
>14) Random
>15) 001001..., hopefully (2,7) RLL encoded to 001001001001...
>16) 100100..., hopefully (2,7) RLL encoded to 010010010010...
>17) 010010..., hopefully (2,7) RLL encoded to 100100100100...
>18) Random
>19) 11001100..., hopefully (1,7) RLL encoded to 101010101010...
>20) 00110011..., hopefully (1,7) RLL encoded to 010101010101...
>21) Random
>22) 0000..., hopefully MFM encoded to 01010101...
>23) 1111..., hopefully MFM encoded to 10101010...
>24) Random

>All patterns are repeated twice, once in each order, and MFM is repeted 
>three times, because MFM drives are generally the lowest density, and thus 
>particularly easy to examine, so I stomp on them extra hard.

>I'm trying to figure out where the seeks should go.  Between each pass 
>is best, and on a good hard drive these days, two short seeks can fit
>into the 16.6 ms (or even 11.1 ms) rotation time of the platter, so it
>doesn't actually add to the time.  But on an older, slower drive, it
>slows things down, and if it is necessary to actually read of a sector
>to force a seek, that will waste a revolution much of the time.
>Does it make more sense to do more seeks, or more writing passes?
>I'm not very clear, and would like guidance.

>I think that power of two sizes for seeks covers all ranges pretty
>well and will explore the backlash range of the head mechanism
>fairly thoroughly.  But does anyone who knows hard drive innards
>have anything else to say?

>Other question: Does it make sense to group patterns optimized for a 
>single type of encoding together, as it is done here, or should they
>all be interleaved?  Should seeks be preferentially between groups, or
>within groups?  Is the raw data 101010... and 010101..., which isn't 
>awful with any encoding scheme (it is worst-vase with MFM, but even
>that isn't too bad, since it's only a run length of 3) worth adding?

>Is there anything else I'm missing?

>The advice of those who are knowlegeable is appreciated.
>-- 
>	-Colin

It amazes me that no one has put the hard word on individual hard disk 
manufacturers about this problem. A powerful high frequency magnetic
field can irretrievably wipe ahard disk. Unfortunately it also destroys
all the servo information on the servo platter, making the disk useless.

And yet, many disk repair facilities can replace platters and re-servo the
disk with the appropriate equipment. Surely the government could set up
a disk erasing/re-servoing facilty. A 1-2 tesla magnetic field (such as
those prodiced by your average NMI system) is at least as effective in
destroying data as acid, and physically much less destructive.



Ulrich Mack
--
Email:  rick@cxbne.cx.oz.au        ,-_|\
Phone:  +61 7 252 3788            /     * 
Fax:    +61 7 257 1480            \_,-._/      Comperex Australia Pty Ltd
                                       v

-- 

Ulrich Mack
--
Email:  rick@cxbne.cx.oz.au        ,-_|\
