Path: msuinfo!uwm.edu!spool.mu.edu!howland.reston.ans.net!cs.utexas.edu!rutgers!psinntp!psinntp!barilvm!vms.huji.ac.il!radai
From: radai@vms.huji.ac.il
Newsgroups: sci.crypt
Subject: Re: who knows message autenticity codes?
Message-ID: <1994Jan31.184436.2963@vms.huji.ac.il>
Date: 31 Jan 94 18:44:36 GMT
References: <59FLBMXI@gwdu03.gwdg.de> <1994Jan28.132432.28138@infodev.cam.ac.uk>
Organization: The Hebrew University of Jerusalem
Lines: 73

Stefan Lucks (slucks@gwdu03.gwdg.de) wrote:
>> I want to protect program codes P1, P2, ... (or other data) from
>> changes (e.g. by a virus). Together with the Program Code Pi I
>> store its message autenticity code MAC(Pi). Only me (or a
>> protected part of the OS) must be able to compute the function MAC.
>> (Therefore MAC should make use of a secret key k).
>>
>> Attackers can know arbitrary many pairs (Pi, MAC(Pi)).
>>
>> No attacker should be able to forge a pair (P', MAC(P')).
                               .....
>> If I don't bother about [verifying without knowledge of a secret key],
>> there should be a easier and
>> more efficient solution than digital signing. For example any
>> modification of MD5, using a secret key.
>>
>> What I am looking for is no ad hoc solution, but a trustworthy one,
>> where the security can be proved under a basic assumption.
>> (For example>> "If MD5 is collision free, then MAC is secure.")
>>
>> Does anyone know a scheme like this? Any suggestions?

 Andrew Haley replies:
> There are a number of ways that you could do this; you could XOR your
> plaintext with a secret key, or concatenate your plaintext with the
> secret key and compute the message digest of the resulting plaintext.
> The problem with this is that both the signer and the verifier need to
> know the secret key; in your cas this may be no obstacle.  In general,
> it's better if the verifier only knows a public key; this offers much
> better security, since even if an attacker can read the verifying
> program he gains no advantage.

When speaking of detecting changes due to a *virus*, as Stefan specifies,
the main risk is from modifications made to files and boot records *on a
given machine*, not during communication of texts between machines.  (Crypto
people almost always assume the latter scenario; I doubt that is what Stefan
is referring to here.)  In this case, there are no separate "signer" and
"verifier" involved, there is no need for digital signatures, and there is
no need for the user to share his secret key with anyone else.

  What Stefan wants is an MAC instead of an MDC, i.e. a cryptographically
secure hash function such as MD5, but dependent on a secret key.  One
possibility would be to replace MD5's buffer initialization constants by a
randomly chosen user-dependent secret key.  However, unless research into
this shows otherwise, it might be that many choices are significantly weaker
than the built-in choice.  Therefore if MD5 is to be used as a basis, a
better solution would be to append the key to the file and apply MD5 to
their concatenation (as was mentioned by Andrew).
  However, it is not necessary to modify an MDC.  There are several existing
algorithms for MACs, one being ANSI X9.9, which is essentially DES in CBC
mode, with the initial block being equal to all zeros and the hash value
being the left half of the final block of the ciphertext.  (32 bits is quite
sufficient for an MAC.)  This algorithm, however, is *very* slow.  A much
faster algorithm is the MAA of the ISO 8731-2 report, which, like ANSI X9.9,
has been standardized for use in the banking world.

  Finally, in the viral environment the stipulation that attackers should be
assumed to know arbitrarily many pairs (P, MAC(P)) is not nearly as impor-
tant or practical as is commonly believed (for reasons which I can give if
asked), and if Stefan drops this requirement, then it is possible to use the
CRC algorithm, which is still faster.  If the generator polynomial for CRC
is randomly chosen by each user, it can be used as the secret key, and
(contrary to popular opinion in crypto circles) CRC is then provably secure,
in the sense that if the degree k of the generator is reasonably large, and
the generator itself is unknown (and file-checksum pairs for computing it
are inaccessible), so that the attacker has no way of attack other than to
construct a file which has the same checksum as the given file with respect
to *all possible* generators of degree k, it can be proven that such a file
would have to be infeasibly large.

                                     Y. Radai
                                     Hebrew Univ. of Jerusalem, Israel
                                     RADAI@VMS.HUJI.AC.IL
