Newsgroups: sci.crypt
Path: msuinfo!uwm.edu!math.ohio-state.edu!cs.utexas.edu!uunet!mnemosyne.cs.du.edu!nyx10!colin
From: colin@nyx10.cs.du.edu (Colin Plumb)
Subject: Re: Is this scheme solid ?
Message-ID: <1994Feb13.041608.17616@mnemosyne.cs.du.edu>
X-Disclaimer: Nyx is a public access Unix system run by the University
 	of Denver for the Denver community.  The University has neither
 	control over nor responsibility for the opinions of users.
Sender: usenet@mnemosyne.cs.du.edu (netnews admin account)
Organization: Nyx, Public Access Unix at U. of Denver Math/CS dept.
References: <1994Feb6.135534.25250@cs.nott.ac.uk>
Date: Sun, 13 Feb 94 04:16:08 GMT
Lines: 112

In article <1994Feb6.135534.25250@cs.nott.ac.uk>,
Andrew Brown <asb@cs.nott.ac.uk> wrote:
>I'm about to release for testing an encrypted file system for a
>certain free Unix, and would like to know if the implementation method
>that I have chosen could be improved before I release it.

It's not bad, but it could definitely be improved.

>I get the passphrase from the user (up to 1023 characters) and hash it
>with MD5. The resulting hash is used as the 128 bit IDEA key. I hash
>the passphrase again with MD4 and keep only 64 bits to use as an IV.
>Are there any problems here ? Would it help to iterate MD5 about
>10,000 times to slow down a brute force passphrase search ?

There's no particular need to keep the IV secret.  If you're encrypting
a series of plaintext blocks x[0..n] into ciphertext blocks y[0..n],
then chaining modes use both x[i] and y[i-1] to produce y[i].  To
produce y[0] you need x[0][ and a y[-1].  This is the IV.  Every other
y[i] is exposed, so the first one doesn't matter.  You can just
compute it based on some RNG and store it.

What is important, however, is that it be *different* for each text you
encrypt, especially if you're using the same key.  In this case, the
"text" is a disk block.  Usually the device-level block number is added
to a global IV to produce the IV for a given block.

However, there is still a possible attack based on modifying files in place.
If you change part of the block, since the prefix leading up to that
has the same key, IV, and plaintext as the previous version, an
attacker who can capture ciphertext copies of the disk periodically
can figure out where on ther disk changed to 8-byte (assuming 64-bit
blocks) granularity.  That may be of use.

Also, if you are using cipher feedback mode (CFB), as you have to if
you're using MD5 as the block cipher (for speed), then the attacker can get
the XOR of the before x[i] and after x'[i].  As you know, it is not too hard
to recover two english texts that have been xored together.  Doing it in
8-byte chunks is harder, but that's still leaking a lot.

My solution to that is to make the IV for encryption depend on each bit
of the plaintext.  This seems impossible, but not so.  First, note
that only y[i] and y[i-1] are needed to find x[i].  Thus, the IV is
only needed to recover x[0].  But I promised that the IV would depend
on each bit in the block, including x[0].  So how to recover the IV
without x[0]?

The answer is to hash together x[0] through x[n-1] and XOR the result
into x[n].  That is the IV.  On decryption, use the stored x[n] as
the IV to decrypt x[0], then hash x[0] through x[n-1] together and xor
it into x[n] again to recover the original plaintext.

This is sort of a double encryption, but the first pass is very
simple.  Oh, merge the block number and some other IV material
into the hash as well, so that each block's IV is guaranteed to differ.

Someone could design a plaintext to defeat the IV-randomization feature
and leak information, but if you assume the user isn't going to try
that, then the hash need not be cryptographically strong.

My preferred technique is a scrambler polynomial done word-wise.
If you have a 2-word block, then load up a and b with the basic IV
and do:

for (i = 0; i <= n; i++) {
	t = x[i] ^= a ^ b;
	a = b;
	b = t;
}

Of course, assuming you're processing an even number of blocks, you
can do:

for (i = 0; i <= n; i += 2) {
	a = x[i] ^= a ^ b;
	b = x[i+1] ^= b ^ a;
}

In any case, when you're done, a and b are the IV you use to do the
encryption.  To descramble at the end, you just do:

for (i = 0; i <= n; i++) {
	t = x[i];
	x[i] = t ^ a ^ b;
	a = b;
	b = t;
}

after decryption.  You can also substitute addition and subtraction in place
of XOR if you like.  The result becomes the Fibonacci random number generator.

>Each block in the fs (1024 bytes) is encrypted as an independent unit,
>using the key and IV generated above using IDEA in CBC mode. This
>means that identical blocks will encipher to identical ciphertext - is
>this a problem ?

Well, it's noce to fix it if you can.  Also, making passphrase-guessing
attacks more expensive never hurts.  How about concatenating the passphrase
with itself until you've exceeded 10K, and taking the MD5 of that?
Of course, you just call MD5Update on your one buffer repeatedly, as in:

MD5_CTX ctx;
char *buf;
int i, len;
unsigned char key[16];

len = strlen(buf)+1;	/* To make null passwords not loop forever */
MD5Init(&ctx);
for (i = 0; i < 10240; i += len)
	MD5Update(&ctx, buf, len);
MD5Final(key, &ctx);
-- 
	-Colin
