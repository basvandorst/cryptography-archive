Path: msuinfo!news.mtu.edu!sol.ctr.columbia.edu!howland.reston.ans.net!vixen.cso.uiuc.edu!audi.ncsa.uiuc.edu!mitchell
From: David Mitchell <mitchell@ncsa.uiuc.edu>
Newsgroups: sci.crypt
Subject: Re: Ladder DES
Date: 25 Feb 1994 20:44:41 GMT
Organization: #include <std.disclaimer>
Lines: 62
Distribution: world
Message-ID: <2klnvp$p2k@vixen.cso.uiuc.edu>
References: <1994Feb22.083353.26012@cactus.org> <762000669snz@eloka.demon.co.uk> <1994Feb25.175146.1205@cactus.org> <1994Feb25.175256.1510@cactus.org>
NNTP-Posting-Host: audi.ncsa.uiuc.edu
X-UserAgent: Version 1.1.3
X-XXMessage-ID: <A9926F66F0010611@audi.ncsa.uiuc.edu>
X-XXDate: Thu, 24 Feb 94 14:51:18 GMT

In article <1994Feb25.175146.1205@cactus.org> Terry Ritter,
ritter@cactus.org writes:
> >An interesting post, but begs a question on why don't we want to
> >use IDEA to replace DES?
> 
>  Speaking for myself, I have trouble *believing* that IDEA (or PES
>  or IPES) is strong.  I am of course aware that my intuition of
>  strength has little to do with reality.  However, since we cannot
>  *test* or *prove* strength, the mere *feeling* of weakness is what
>  every formal attack must be before it is born.

The question is one of how to measure the complexity of a given binary
function.  I recently asked on comp.theory about methods for manipulating
binary/boolean functions and was given a pointer to the following article
which I highly recommend.

"Graph-Based Algorithms for Boolean Function Manipulation"
Randal E. Bryant
IEEE Trans. on Computers
1986
Vol C-35
Num 8
pp 677-691

The paper talks about representing a given boolean function as a directed
acyclic graph (a tree), refered to as a Binary Deceision Diagram (BDD for
short.)  Any crypto function can be represented as a number of these
graphs.  For example, DES would require 64 graphs, one for each output
bit (actually, it's possible to combine a number of functions into one
graph, but I'm simplifying for clarity.)  Each tree would have a height
of 64 (data bits) + 56 (key bits) + 1 (terminal nodes, one each for 1 and
0) = 121.

The complexity of the function can be related to the number of nodes in
the BDD.  In the worst case, the BDD blows up to the size of a full
binary tree of the given height.  Often times, the graph is actually much
smaller.  However, there is a complication.  The size of the tree also
depends on the ordering of the variables, and it can be expensive to find
the optimal ordering.  In most applications though, there are good
heuristics for finding pretty good orderings.  With addition, for
example, you would want to start with the low order bits, not the high
order bits.  Well, with that out of the way, I'll discuss the
relationship to IDEA.

One of the interesting points that Bryant makes in the paper is that
multiplication will always blow up into a very large tree for at least
one output bit, irrespective of the order of the variables.  This seems
to me to indicate that the complexity of IDEA may be very high, since it
relies on 32-bit multiplications.  Of course, it is possible that some of
the complexity cancels out somewhere else in the algorithm.  I haven't
checked it out yet.  Either way, it should be difficult to impossible to
compute the BDD's for IDEA because of the explosive growth of
multiplications.  This is, IMHO, a good thing, as having access to the
BDD's for a cryptosystem would make cryptanalysis relativly easy.  For
example, with the BDD's, any type of known-plaintext attack should be
very fast.  Probably as fast as any method other than a complete lookup
table.

Anyway, there's a little food for thought for everyone.  I do highly
recommend that you try and get your hands on a copy of Bryant's article.

-David Mitchell
