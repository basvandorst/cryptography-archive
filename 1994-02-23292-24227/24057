Path: msuinfo!agate!howland.reston.ans.net!cs.utexas.edu!swrinde!dptspd!ephsa!bbs
From: jburrell@ephsa.sat.tx.us
Newsgroups: sci.crypt
Subject: Digital Cash
Message-ID: <266@ephsa.sat.tx.us>
Date: 23 Feb 94 03:00:08 GMT
Sender: news@ephsa.sat.tx.us
Lines: 109


 I'm assuming that this is the general way digital cash works:

 There are three systems. The first is the server, the second is BoB,
 and the third is Alice. The server somehow generates digital money out
 of thin air. It generates 5 coins totalling 100 credits. (20 credits
 per coin, for denominations of 20). The server sends these 5 20 credit
 coins to Bob. Each coin is given a serial number and such:

  Serial #:Server ID:Series number:Denomination

 That header is the escense of the coin. The header of each individual
 coin is clearsigned by the server using its own public key. Then
 the 5 coins are zipped into a packet and sent to Bob.

 Bob gets the packet, decrypts it, and runs his client server which
 unzips and verifies the packets (if they're faulty, the process aborts.
 It doesn't matter if Bob somehow forged these as you'll see in a
 minute). For the purpose of discussion, the signatures on the coin
 headers are found to be good. Now, if Bob is happy with the 20 credit
 denominations, all is well. If Bob wants, say, 10 credit denominations,
 he tells his client.

 The client program makes a control header at the front of the envelope
 saying that Bob would like to exchange these 5 20 credit coins for 10
 10 credit coins. It is then PGP'ed and sent back to the server.

 Again, the server receives the packet, and checks for a control header.
 Now, it checks each coin to make sure that the signatures made
 previously by the server are valid. If they are, the process continues:

 If the control header says "Exchange these coins for 10 10 credit
 coins" the server *VOIDS* the serial numbers, and then generates 10 new
 coins of 10 credits a piece, totalling 100 credits. Each coin is again
 signed (clear) by the server and zipped into an envelope. Then the
 coins are PGP'ed and sent back to Bob.

 Now the same thing happens as before, except that now Bob has 10 coins
 with TOTALLY different serial numbers (his old ones are voided).

 Now Bob wants to send 50 credits to Alice. He tells his client program
 that he wants to take 50 credits and send it to Alice. He is given
 a list of the available denominations and chooses the ones he wants,
 totalling 50 credits. The client zips the packet and encrypts it with
 Alice's key. If Alice's key is unavailable, an option is given.

     Since the server must have Alice's key anyway, an option is given
     to generate a control header telling the server to send the money
     to Alice. If this is chosen, the envelope (packet) is encrypted to
     the server and the server sends it to Alice.

 Now, however it happened, Alice has her 50 credits. How does Alice know
 that these 50 credits are good? For the purpose of this discussion,
 say she gets 5 10 credit coins. Say that she wants to exchange them for
 one 50 credit coin. No problem. Alice tells her client program that she
 wants to verify the coins and that she would like a 50 credit coin
 back.

 The server receives Alice's coins and her request. The server checks
 the serial numbers and series numbers to make sure that the coins have
 not been spent already, that they are from the current series (more on
 that explained below) and that the server's signature is intact. If it
 is, the serial numbers for these coins are VOIDED and 1 50 credit coin
 is generated and sent to Alice.

 Now, Alice can simply be content and not send the coins to the server.
 She should be aware, though, that Bob could have sent the same coins to
 two or more people, or has already spent them. If she doesn't verify
 them, they may be worthless (i.e. already spent) before she knows. If
 she is told that they are already used, she can seek appropriate action
 against Bob.

 Each packet has:

 Serial number: Series Number: Server ID: Denomination

 The serial number is a unique number given to each coin within the
 series.

 The series is a wee bit more complicated. Since after a while all these
 voided numbers take up room, the server operator can send an automated
 message to everyone saying "If you have coins, exchange them now." The
 users then tell their client program to exchange the coins. The client
 program sends a control header into the server saying something like
 "Exchange my coins." The coins are voided and the series number is
 incremented. Then the server signs it as always.

 Each time the server checks a coin, it makes sure that the Series
 Number is the current one, and that the serial number is valid. It can
 also check for its optional Server ID, although thats probably of
 little use. Then, it looks at the denomination for obvious reasons.

 The server ID is simply a number that each server operator gives
 his server. (Or that the server generates randomly) This really isn't
 of much use because of the key signatures, but who knows.

 The denomination is obvious.

 Any suggestions? Weaknesses? Stupid mistakes or stupid ideas on my part?








... MONEY TALKS ...   but all mine ever says is GOODBYE!
___ Blue Wave/QWK v2.12
                                                                                                          
