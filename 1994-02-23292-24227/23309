Path: msuinfo!netnews.upenn.edu!dsinc!spool.mu.edu!sol.ctr.columbia.edu!news.kei.com!eff!linus!linus.mitre.org!linus!mbunix!eachus
From: eachus@spectre.mitre.org (Robert I. Eachus)
Newsgroups: sci.crypt
Subject: Re: who knows message autenticity codes?
Date: 31 Jan 94 14:17:27
Organization: The Mitre Corp., Bedford, MA.
Lines: 64
Message-ID: <EACHUS.94Jan31141727@spectre.mitre.org>
References: <59FLBMXI@gwdu03.gwdg.de>
NNTP-Posting-Host: spectre.mitre.org
In-reply-to: slucks@gwdu03.gwdg.de's message of Thu, 27 Jan 1994 21:39:42 GMT

In article <59FLBMXI@gwdu03.gwdg.de> slucks@gwdu03.gwdg.de (Stefan Lucks ) writes:

  > I want to protect program codes P1, P2, ... (or other data) from 
  > changes (e.g. by a virus). Together with the Program Code Pi I 
  > store its message autenticity code MAC(Pi). Only me (or a 
  > protected part of the OS) must be able to compute the function MAC. 
  > (Therefore MAC should make use of a secret key k).

  > Attackers can know arbitrary many pairs (Pi, MAC(Pi)).

  > No attacker should be able to forge a pair (P', MAC(P')).

  > One possibility to do this is to use a hash function in combination
  > with a digital signature scheme. Digital signatures are a very 
  > powerful cryptographic tool, since they can be veryfied without the 
  > knowledge of the secret key...

    I'm assuming that you are looking for a method for software
distribution where the channel is not trusted, but there is an initial
trusted communcation...

    A paper by Sheperd, Sanders, and Stockel in July 1993 Cryptologia
list as a disadvantage of the Blum, Blum, and Shub algorithm (a.k.a.
the Quadratic Residue Cipher) that it can't be used to provide digital
signatures.   This seems to be a special case where BBS provides
better digital signatures that RSA.  (I have some criticisms of the
SSS paper, but this is not one of them, you can't do "traditional"
cryptographic signatures with BBS.)

   Here is the idea: 

    Compute one of several good cryptograhic hash functions of
program.  The authenticator is the fourth root of the square of the
hash modulo the public key.  (The public key is a Blum Integer.)  The
progam can be authenticated by generating the hash, squaring it, and
comparing it with the authenticator squared twice.  (Whether or not
the hash itself is a quadratic residue mod the key is irrelevant.)

    As long as the hash value is large compared to the key size this
will work fine.  (Adding a predefined value to the hash can guarantee
this, for example always append a one bit on the left.  If you want to
use a 512-bit hash and a 1024-bit key, add an addition squaring on
both sides.)  RSA with the same key size and e=3 will take about as
long, but is open to additional attacks.  RSA with a larger e will
take longer, and is still not quite as (theoretically) secure.

    Of course, the largest time cost will be in generating the hash of
the program, so you may want to trade time for security there, but be
careful.  Since your hypothetical adversary wants to slip in a Trojan
which can contain lots of junk bits, so you definitely do need a
cryptographically secure hash.  I'm just saying that the risk that
someone may create a program which has the same hash as a known
message is that they can forge a replacement for a message.  If they
compromise the authentication algorithm, they can forge messages with
new authenticators.  (A good rule might be that a recipient keeps a
log of authenticators received and rejects any duplicates.)

--

					Robert I. Eachus

with Standard_Disclaimer;
use  Standard_Disclaimer;
function Message (Text: in Clever_Ideas) return Better_Ideas is...
