Path: msuinfo!agate!linus!linus.mitre.org!linus!mbunix!eachus
From: eachus@spectre.mitre.org (Robert I. Eachus)
Newsgroups: sci.crypt
Subject: Re: Factoring N=P*Q vs. general factoring
Date: 15 Feb 94 18:26:35
Organization: The Mitre Corp., Bedford, MA.
Lines: 73
Message-ID: <EACHUS.94Feb15182635@spectre.mitre.org>
References: <2jqpre$6j1@fbi-news.informatik.uni-dortmund.de>
	<SR.94Feb15171640@zen.mp.co.umist.ac.uk>
NNTP-Posting-Host: spectre.mitre.org
In-reply-to: sr@zen.mp.co.umist.ac.uk's message of Tue, 15 Feb 1994 17:16:40 GMT

In article <SR.94Feb15171640@zen.mp.co.umist.ac.uk> sr@zen.mp.co.umist.ac.uk (Simon Read) writes:

  > So far as I am aware there is no direct evidence that factoring primes
  > is hard, except that no-one can find an easy way of doing it, which I
  > think answers HALF of your question.

  Factoring primes is easy, for any prime p, the factors are p and 1.
;-)  Couldn't resist, I've made the same mistake myself.  There is no
easy way to say, finding the factors of a composite number which is
the product of two large primes...  Enough of that, on to the real
meat.

 > There is an implicit part to your question which is "Is it easier to
 > factor a number which is he product of only two primes than to do
 > general factoring." Well, again as far as I'm aware, no one has
 > admitted to looking at the problem from the "only two primes"
 > viewpoint. It is almost certainly going to be slightly easier,
 > although there is no general theory.

   I think there is a publish transformation proof that factoring the
product of two large primes is in the same complexity class as the
more general problem.  If not, I could whip one up.  But more
importantly, even though the problems are in the same complexity
class, in general, the smaller the number of factors, the harder it is
to find one.

 > In any case the real issue is can the improvement in the complexity
 > functions of modular exponentiation algorithms keep pace with the
 > prime factoring algorithms because in most practical applications the
 > key length can be increased.

  Hmmm... Not the right way to state this.  If factoring IS in NP,
then any speedups can be beaten by making the key longer, since the
ratio of speeds greatly favors the defender.

 > For the moment the answer is, I think, that the evidence is empirical,
 > but I'm not even sure HOW you would go about showing anything else.

     It is tied up in P=NP.  P=NP is the question of whether their
exist problems that can be solved in polynomial time but require
non-polynominal time on average.  Polynomial time means that the time
required to solve an instance of the problem is bounded by a
polynomial expression in the length of the statement of the instance.
For example for the factoring problem, the instance statement is the
number of bits in the binary representation of the number to be
factored--or the number of digits, it just changes a constant.  If I
have had an algorithm which took eight times as long to factor a
number twice as long, the polynomial would be n cubed.  There is an NP
(non-deterministic polynomial time) algorithm for factoring--just
guess one of the factors (correctly!) and divide.  So even without
fast multiplication algorithms, the complexity in NP of factoring is n
squared.

     If P=NP, then RSA and just about any other existing cryptosystem
falls.  If P/=NP, then it is possible that factoring could be in P,
but it is highly unlikely.  If P=NP is unprovable, then not only is
that fact unprovable, but it is very likely that factoring in P is not
provable.  So when mathematicians say this isn't provable, what they
are really saying, is more like:

     "We have always fairly sure that eventually someone would prove
Fermat's Last Theorem.  So what if it takes a few centuries.  But a
lot of mathematicians won't even look at P=NP any more.  They think it
is a waste of time."  (See above.  If you prove that P=NP is
unprovable, then you have proven that no counterexample exists,
therefore P=NP is true!)
--

					Robert I. Eachus

with Standard_Disclaimer;
use  Standard_Disclaimer;
function Message (Text: in Clever_Ideas) return Better_Ideas is...
