Path: msuinfo!uwm.edu!wupost!howland.reston.ans.net!gatech!psuvax1!rutgers!igor.rutgers.edu!zodiac.rutgers.edu!leichter
From: leichter@zodiac.rutgers.edu
Newsgroups: sci.crypt,sci.math
Subject: Re: "Card-shuffling" algorithms
Message-ID: <1993Mar4.184800.1@zodiac.rutgers.edu>
Date: 4 Mar 93 23:48:00 GMT
References: <1993Feb25.201917.1717@ee.eng.ohio-state.edu> <1mmhpqINNhr5@uwm.edu>
Sender: news@igor.rutgers.edu
Followup-To: sci.crypt
Organization: Rutgers University Department of Computer Science
Lines: 65
Nntp-Posting-Host: pisces.rutgers.edu
Xref: msuinfo sci.crypt:13979 sci.math:40514

In article <1mmhpqINNhr5@uwm.edu>, markh@csd4.csd.uwm.edu (Mark) writes:
| In article <1993Feb25.201917.1717@ee.eng.ohio-state.edu> butzerd@columbia.eng.ohio-state.edu (Dane C. Butzer) writes:
||Does anybody know of an algorithm that will randomly shuffle a deck in one
||pass, with one random number chosen per card, given a "good" random number
||generator?  Is such an algorithm even believed to be possible?
| 
| 
| Impossible.  Shuffling is the inverse of sorting, which is an N log(N) process.
| Therefore you need log(N) passes at the very least.
| 
| Take any comparison-based sorting algorithm at all.  Replace the comparison
| operation:
| 
| Compare(A, B) = 0 if A <= B
|                 1 if A | B
| 
| with the randomizer
| 
| Random(A, B) = 0 or 1 with equal probability.
| 
| The result is a shuffling algorithm.
| 
| The converse is true too.  Take any transposition-based random shuffling
| algorithm.  Replace the random transposition function
| 
| Transpose(A, B) = (A, B) or (B, A) with equal probability
| 
| with a comparison-based transposition function:
| 
| Permute(A, B) = (A, B) if A <= B, or (B, A) if A | B.
| 
| The result is a sorting algorithm.

Nice argument, but you made a BIG assumption along the way, one which was not
in the original problem statement:  That the random shuffle was "transposition
based".  Whatever exactly that means.

It is in fact trivial to provide an algorithm that does exactly what the
original problem requires:

	Shuffling one card is easy.
	To shuffle n cards, first shuffle the first n-1.  Then choose
		with uniform probability an integer r between 0 and n-1.
		Count off r cards from the already-shuffled deck, insert the
		remaining card, and append the remaining cards.

It is easy to see - using your connection between sorting and shuffling, for
example - that the random number generator makes "as few choices as possible".

It is also easy to see that one BIT per card is not nearly enough (since
2^n < n! for n > 3).

(This algorithm is the equivalent of the following "optimal" sorting
	algorithm:

	Sorting one element is easy.
	To sort n elements, sort the first n-1, then insert the nth after
		a binary search.

I say "optimal" since it uses log n! COMPARISONS - the theoretical optimum -
but O(n^2) MOVES to insert an element into the array needed to do a binary
search.  One can use a binary tree to make the whole thing O(n log n); the
same limitation, and fixup technique, works for the shuffler.)

							-- Jerry
