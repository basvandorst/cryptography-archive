Path: msuinfo!uwm.edu!cs.utexas.edu!zaphod.mps.ohio-state.edu!ub!acsu.buffalo.edu!boyd
From: boyd@acsu.buffalo.edu (Daniel F Boyd)
Newsgroups: sci.crypt
Subject: Re: Identifying / Securing Files
Message-ID: <C4nuI5.D78@acsu.buffalo.edu>
Date: 29 Mar 93 17:13:17 GMT
References: <C4MI2p.57u.1@cs.cmu.edu>
Sender: nntp@acsu.buffalo.edu
Organization: UB
Lines: 77
Nntp-Posting-Host: autarch.acsu.buffalo.edu

In article <C4MI2p.57u.1@cs.cmu.edu> Marc.Ringuette@GS80.SP.CS.CMU.EDU writes:
> Part of the difficulty is that it's a hard problem to formalize.  Here's
> a crack at it.  Can you prove anything about the following two problems?
> 
>  1. A program P computes a function f(i) over the integers.
>     The program is expressed in terms of a simple machine language.
>     Does there exist an obfuscating process Obf(P) which produces a
>     new program P' which computes f(i) but guarantees to give away no
>     more information on any single run than the value of f(i)?



What do you mean by 'give away information'?  This still needs to be
formalized.

A formal statement: someone supplies me with a program P that computes
a function f(i) over the integers.  Assume I can set an upper
bound M on the size of the data I want to work on; thus, I know the
largest 'i' that I will ever need.  So I wrap a loop around P and
compute f(0), f(1), f(2), etc. until I have computed f(x) for all x
such that 0 < x <= M.  Now I have stolen P; someone could take P away
but I can still look in my table of the values that it computed.  In
fact, I can write program Q which computes the same function as P for
all x in [0,M].

You're not looking for practical answers, so it doesn't matter how
long it takes for me to calculate f(i) and so on.  If you once supply
me with P', you cannot take it away again.



>  2. A program P computes a function f(i) over the integers.
>     The user's machine is in constant communications with the
>     software author's machine.  Is it possible to rewrite P
>     so that (a) it requires at least one communication with the
>     author's machine per run, and (b) the amount of communications
>     per run is small, even if i and/or f(i) are large?



It is possible to rewrite P so that it requires at least one small
communication with the author's machine per run.  So what.

The question you want to ask is, is it possible to write P so that:

(a) P requires a communication with the author's machine
(b) P cannot be rewritten to not require the communication

The answer is no.



> I'm imagining some code which munges the input unrecognizably, does
> incomprehensible things to it, and through some kind of magic,
> finally XOR's the answer out of thin air on the last instruction of
> the program...

This is fine if what we were trying to hide were the data that P is
working on -- if the enemy were watching the inside of our computer as
it works and we don't want him to know what we're doing (assume that
we have a secure device for output) -- but what we're trying to
protect is P' itself.

Now, we know there's no algorithmic procedure that will even tell us
if P' will halt, so if you could formalize the notion of 'give away
information' you'd probably find that it's similarly undecidable.

Besides -- someone could still copy the program P'; I don't see how
making the internals confusing keeps it from being copied.



-- 
Daniel F. "Not Economically Viable" Boyd -- boyd@cs.buffalo.edu 

"Here, a piece of the True Cross.  And in this case, we have the skull
of John the Baptist at the age of twelve."
