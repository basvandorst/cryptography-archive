Path: msuinfo!caen!sol.ctr.columbia.edu!howland.reston.ans.net!paladin.american.edu!news.univie.ac.at!hp4at!mcsun!sun4nl!cwi.nl!dik
From: dik@cwi.nl (Dik T. Winter)
Newsgroups: sci.crypt
Subject: Re: "Card-shuffling" algorithms
Message-ID: <9024@charon.cwi.nl>
Date: 1 Mar 93 02:34:40 GMT
References: <1993Feb25.201917.1717@ee.eng.ohio-state.edu> <1mmhpqINNhr5@uwm.edu> <9023@charon.cwi.nl>
Sender: news@cwi.nl
Organization: CWI, Amsterdam
Lines: 47

I have to correct myself (do you not hate that?).

In article <9023@charon.cwi.nl> dik@cwi.nl (That's me) writes:
 > In article <1mmhpqINNhr5@uwm.edu> markh@csd4.csd.uwm.edu (Mark) writes:
 >  > Impossible.  Shuffling is the inverse of sorting, which is an N log(N)
 >  > process.  Therefore you need log(N) passes at the very least.
 >  > 
 >  > Take any comparison-based sorting algorithm at all.  Replace the comparison
 >  > operation:
 >  > Compare(A, B) = 0 if A <= B
 >  >                 1 if A > B
 >  > with the randomizer
 >  > Random(A, B) = 0 or 1 with equal probability.
 >  > The result is a shuffling algorithm.
I said this was wrong for the wrong reasons.  I assumed that the number of
compares was fixed, which is not true.  The real reasons this is wrong are
the following:
1.  There is an hidden assumption that the order of the resulting shuffling
    process is the same as the order of the original sorting process.  This
    is not true.  Consider bubble sort:
        modified = true
        while modified
            modified = false
            for i in 1..n-1 do if a[i] > a[i+1] then
                interchange(i, i+1)
                modified = true
    The order of this process is n^2 and there is an upperbound on the number
    of operations which is also of order n^2.  Change the compare to the
    randomize operator.  The resulting process has no upperbound on the number
    of operators.  Also the order of the process now becomes ln(2).2^n
    (my math may have been wrong, but it is exponential).
    It would be interesting to find the class of algorithms where the
    randomizing version has the same order as the sorting version.  There
    are at least two requirements: no comparison must be repeated and the
    algorithm does not depend on transitivity of the comparison.
2.  The resulting algorithm can be strongly biased.  In a perfect shuffle
    the probability of the first element retaining its place is 1/n.
    When we modify quicksort-like algorithms it is easy to verify that
    for those algorithms the probability is 2^(1-n).  So the algorithm is
    biased.

However, if we assume that the random number generator is a random bit
generator (a degenerate case ;-)), I agree that the order of a shuffling
algorithm is n.ln(n) in the number of random generator calls.
-- 
dik t. winter, cwi, kruislaan 413, 1098 sj  amsterdam, nederland
home: bovenover 215, 1025 jn  amsterdam, nederland; e-mail: dik@cwi.nl
