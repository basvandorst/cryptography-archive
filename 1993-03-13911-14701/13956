Path: msuinfo!uwm.edu!wupost!darwin.sura.net!haven.umd.edu!news.umbc.edu!elang01.acslab.umbc.edu!olson
From: olson@elang01.acslab.umbc.edu (Bryan G. Olson; CMSC)
Newsgroups: sci.crypt
Subject: Re: New encryption problem?
Date: 3 Mar 1993 02:28:14 GMT
Organization: University of Maryland, Baltimore County
Lines: 78
Sender: olson@elang01.acslab.umbc.edu (Mr. Bryan G. Olson; CMSC (G))
Distribution: world
Message-ID: <1n153uINNert@news.umbc.edu>
References: <1993Mar1.210532.15134@oracle.us.oracle.com> <C398wr.KD4@rahul.net>
NNTP-Posting-Host: elang01.acslab.umbc.edu

You will need to read the article cited in the annotation below to follow this.

In article <C398wr.KD4@rahul.net>, dhesi@rahul.net (Rahul Dhesi) writes:
|> In <1993Mar1.210532.15134@oracle.us.oracle.com> mfriedma@us.oracle.com
|> (Michael Friedman) writes:
|> 
|> >I have plain text P1, P2, ... Pn
|> 
|> >I want to deliver to customer A the encrypted text Ca1, Ca2, ... Can,
|> >to customer B, Cb1, Cb2, ... Cbn, etc.
|> 
|> >I want to have a key for each document, K1 ... Kn, and a key for each
|> >customer, Ka ... Kz.
|> 
|> Assign each document and each customer a large prime number.  Generate
|> an encryption key by multiplying a document prime with a customer
|> prime, modulo 2^N where N bits are needed in the key.  Use some
|> standard encryption algorithm (e.g., IDEA or DES).
|> 

I don't think so.  First the notation:

Ka is the key used for customer A, although A does not know this value.
Same for Kb and customer B.
Ki and Kj are the master keys for plaintext Pi and Pj respectively.

f(X,Y) is the function that computes a key specific to both a customer and
a plaintext.  Above f(X,Y)=X*Y mod 2^N is suggested.


A and B want to beat the system.  They can aquire fa=(Ka,Ki) and 
fb=(Kb,Ki) by both buying the text Pi.  Under the f function above:

        f(Ka,Ki)= Ka*Ki  mod 2^N
        f(Kb,Ki)= Kb*Ki  mod 2^N

So:  Ki= (Ka^-1)*f(Ka,Ki)     mod 2^N
     Ki= (Kb^-1)*f(Kb,Ki)     mod 2^N

     (Ka^-1)*f(Ka,Ki) = (Kb^-1)*f(Kb,Ki)    mod 2^N

     Kb*(Ka^-1) = f(Ka,Ki)*(f(Kb,Ki)^-1)    mod 2^N

Thus they have calculated    Kb*(Ka^-1)   (mod 2^N)

Now consider the plaintext-for-sale item Pj.

                   f(Ka,Kj)= Ka*Kj    mod 2^N
solving for Kj:
                   Kj= Ka^-1 * f(Ka,Kj)   mod 2^N
substituting into  
                   f(Kb,Kj)= Kb*Kj            mod 2^N
we get    
         f(Kb,Kj)= Kb*Ka^-1 * f(Ka,Kj)       mod 2^N

Now a buys f(Ka,Kj) by buying Pj.  They know Kb*(Ka^-1), so
B can get f(Kb,Kj) without buying Pj.

This defeats the purpose of encrypting all the messages separately for
each customer.  Actually, in many applications seperate encryption would not 
be needed, since if one customer buys Pj, he can just send Pj to others.  But 
since the problem assumed encryption for each customer, the above demonstrates
a defect in the solution.  If several customers all buy one plaintext, then they
can get together and all get their keys to later plaintexts even if only one 
buys it.


The origional problem is not hard to solve.  We just need
f(X,Y) to have the properties:
	f(X,Y) is easy to compute from X and Y
	Neither X not Y can be computed from the other and f(X,Y).
This is easy to build from a conventional block cipher, say:
    f(X,Y)= DES(key=X, input=DES(key=Y, input=0))
although DES is itself questionable.


Bryan Olson
olson@umbc.edu
