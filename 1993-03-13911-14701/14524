Newsgroups: sci.crypt
Path: msuinfo!uwm.edu!cs.utexas.edu!zaphod.mps.ohio-state.edu!howland.reston.ans.net!news.ans.net!newsgate.watson.ibm.com!yktnews.watson.ibm.com!wo0z!lwloen
From: lwloen@rchland.vnet.ibm.com (Larry Loen)
Subject: Re: Vigenere Ciphers
Sender: news@rchland.ibm.com
Message-ID: <1993Mar26.181830.33080@rchland.ibm.com>
Date: Fri, 26 Mar 1993 18:18:30 GMT
Reply-To: lwloen@rchland.vnet.ibm.com
Disclaimer: This posting represents the poster's views, not necessarily those of IBM
References:  <1993Mar26.140603.25459@crc.ac.uk>
Nntp-Posting-Host: wo0z.rchland.ibm.com
Organization: IBM Rochester
Keywords: C code
Lines: 80

In article <1993Mar26.140603.25459@crc.ac.uk>, k-hatric@nimr.mrc.ac.uk (Kerr Hatrick) writes:
|> I'm interested in Vigenere ciphers and the classical 
|> 
|> methods by which any particular Vigenere Key might be 
|> 
|> found given a reasonably long piece of ciphertext.
|> 
|> Can anybody direct me to an FTP site where I might 
|> 
|> find  C code (a) allowing Vigenere encryption of text 
|> 
|> using a user-defined key and (b) allowing  analysis
|> 
|> of Vigenere ciphertext ( perhaps even allowing digram/
|> 
|> trigram frequencies to be explored )? 
|> 
|> 	Thanks for your time,
|> 				Kerr Hatrick
|> 				(k-hatric@nimr.mrc.ac.uk)
|>  
|> 
|> 

I don't know what's available, but writing your own little deciphering 
subroutine is not a large effort.  We're talking maybe 50 lines of source 
code.  (And, as will become obvious, "legitimate" enciphering is a trival
subset of the attack code).

In my hobby work on Vigenere (assumes messages limited to upper case
alphabetics), I've found the following works:

1)  Try out all short keys (say, 4 through 12).  If you need something
  spiffier, the Kasiski method or the Index of Coincidence seem to work
  well for spotting the key.  Neither of these are a big job to code up,
  either.

2)  For each key tried (however #1 is done), simply try out all 26 possible
  keys for each trial column for each trial key.  Find out which has the
  best match against the standard (English) frequency count.  Almost any
  form of statistical matching seems to work fine.

Using the above methods, I have solved puzzle cryptograms in Vigenere (and
all the related systems, such as Porta).  It gets about 80% of the columns
correct, on average.  This is enough to enable the incorrect columns to be
easily hand-repaired.

Incredibly, the program works almost as well on foreign language cryptograms,
even using the English frequency count list!  I've solved ciphers whose content
was in a language I'd need a dictionary to understand.

On a 386 or 486, even under interpretive BASIC, the solution time is darn
near instantaneous per trial.

Generally, you don't need fancy analysis with Viggys anymore unless there is
something under 10 samples of each Viggy alphabet.

If you wish to do anything more, have fun and go at it, but this has been
plenty effective for me; I first published this method back in about 1976
and I'm not sure it was original, even then; it's the obvious way to go
with a computer.

For a real live computer encryption example, it would be a little harder.

1)  There probably aren't a lot of repetitions that one can expect in a
  puzzle example.

2)  Getting the correct frequency distribution may be a little problematic.
  Still, it seems one only has to be within spittin' distance and maybe
  doing the formally correct statistical matching would help too.

As you can see, the conditions for a solution are not very rigorous.  The
main thing is to get the key right and with anything like enough text,
the classical statistical methods work.  Longish (4 or more) repeat 
sequences also seem, as a practical matter, to give the key away, too.
	

-- 
   Larry W. Loen        |  My Opinions are decidedly my own, so please
                        |  do not attribute them to my employer
