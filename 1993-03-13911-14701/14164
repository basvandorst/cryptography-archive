Newsgroups: sci.crypt
Path: msuinfo!uwm.edu!rpi!gatech!udel!rochester!cantaloupe.srv.cs.cmu.edu!crabapple.srv.cs.cmu.edu!mnr
From: Marc.Ringuette@GS80.SP.CS.CMU.EDU
Subject: Re: Permanent signatures for pictures
Message-ID: <C3x1AB.89s.1@cs.cmu.edu>
Originator: mnr@GS80.SP.CS.CMU.EDU
Sender: news@cs.cmu.edu (Usenet News System)
Nntp-Posting-Host: gs80.sp.cs.cmu.edu
Organization: School of Computer Science, Carnegie Mellon
Date: Mon, 15 Mar 1993 04:43:00 GMT
Lines: 186

I wrote,
> It just occurred to me that I could use a simulation where my analysis
> fails me.

Well, here it is.  I apologize if this is all incomprehensible to you.

Summary:  tagging wins against <10 thieves out of a large subscriber
base, and has a chance against 20 thieves.  This is assuming very
smart thieves; your mileage may be considerably better.

---

>  Dow Jones strategy:  twiddle some bits with probability a little less
>     than 0.5, and some other bits with a fairly small probability.
>     Say, 0.4 and 0.1.  The former must be chosen so that there's a
>     non-negligible probability of a vote among the thieves agreeing
>     with the minority position; the latter must be chosen so there's
>     a non-negligible probability that _all_ the thieves will vote with
>     the majority.
>
>  Thief strategy:  choose a threshold t.  Vote on the value of each
>     bit; if either side gets a fraction of votes bigger than (1-t),
>     go with the majority, otherwise flip a fair coin.  Say, t=0.25.

I haven't played with the simulator all I could, but to sum it up, the
ballpark figures for the success of my hybrid tagging strategy vs. the
thieves' hybrid strategy are that with 5000 tag bits and 5-10 thieves
out of 1000 subscribers, the tagger can detect all of the thieves with
accuracy in the high 90's if he knows where to put the threshold.  For
20 thieves out of 1000 subscribers, I believe that the tagger can
detect half the thieves with >90% accuracy using 5000 tag bits, but
more than 20 thieves are probably too many.

You may have noticed the caveat "if [the tagger] knows where to put the
threshold" in the previous paragraph.  I haven't dealt with threshold-setting
in my simulator.  For the purposes of the simulator I assume that the tagger
can guess how many thieves there are and use his ranked list of candidates to
kick them out.  I don't think threshold-setting will be a major obstacle; I
just couldn't think of a good way to do it a priori.

---

Net result:  even though the exponent is on the thieves' side, tagging
is a fairly practical way of detecting groups of thieves of size <20.
It's also true that unless the thieves have a really good strategy,
they stick out like a sore thumb when exposed to this kind of statistical
analysis.

Please note that this tagging strategy was optimized for large numbers of
thieves; special-case schemes for <5 thieves could do much better in those
cases.

I'll attach the code to the end of this message.  It's written in vanilla C.


-- Marc Ringuette (mnr@cs.cmu.edu)




/* Text-tagging simulator -- Marc Ringuette, mnr@cs.cmu.edu, 3/14/93.

Usage:    tagsim p_lo p_hi lo_frac N n thief_thresh rounds iters
Example:  tagsim 0.1 0.4 0.5 1000 10 0.25 10 1000 5

Explanation:

   N subscribers, n thieves.  Tagger must kick out 'kickout' subscribers
   after 'tagbits' bits have been twiddled.  How well does he do?  The
   program outputs the fraction of correct kickouts based on the two 
   measures available.  This is similar to but NOT equal to the success
   rate expected by an actual tagger.  It may be an overestimate.

   Tagger strategy:  twiddle bits using two different probabilities, p_lo
   and p_hi, with the choice being random, with probability lo_frac of
   using p_lo and (1-lo_frac) of using p_hi.  If p_lo is used, tagger
   detects thieves by looking at the cases where the stolen output is with
   the minority, and adding up how often each subscriber's value was
   minority in those cases.  If p_hi is used, tagger adds up how often
   each subscriber agrees with the stolen output.

   Thief strategy:  majority vote if fewer than thief_thresh*n votes
   for either side; flip a fair coin otherwise.

   Output:  the fraction of the top 'kickout' candidates which were 
   actually thieves, for each of the two data-collection modes.  No
   attempt was made to combine the information of the two modes, or
   to automatically set kickout thresholds.
*/

#define MAX 10000

float p_lo,p_hi,lo_frac,thief_thresh;
int N,n,kickout,rounds,iters,bias[MAX],unbias[MAX],stats2[MAX],thief[MAX];

randbit(frac)
	float frac;
{
	return (  (unsigned long)random() % 1000000 ) / 1000000.0 < frac;
}

intcmp(a,b)
	int *a,*b;
{
	if (*a<*b) return -1;
	else if (*a>*b) return 1;
	else return 0;
}

float 
frac_correct(stats)
	int *stats;

{
	int i,numgreater,numequal,thresh;
	float matches;

	for (i=0;i<N;++i) stats2[i]=stats[i];
	qsort(stats2,N,sizeof(int),intcmp);
	thresh=stats2[N-kickout];
	for (numgreater=0,numequal=0,i=0;i<N;++i) {
		if (stats[i]>thresh) ++numgreater;
		else if (stats[i]==thresh) ++numequal;
	}
	matches=0.0;
	for (i=0;i<n;++i) {
		if (stats[i]>thresh) matches = matches + 1.0;
		else if (stats[i]==thresh) matches = matches + (1.0/numequal)*(kickout-numgreater);
	}
	return matches/kickout;
}

main(argc,argv)
	int argc;
	char **argv;
{
	int i,j,it,vote,which;
	float bias_correct,unbias_correct;

	sscanf(argv[1],"%f",&p_lo);
	sscanf(argv[2],"%f",&p_hi);
	sscanf(argv[3],"%f",&lo_frac);
	sscanf(argv[4],"%d",&N);
	sscanf(argv[5],"%d",&n);
	sscanf(argv[6],"%f",&thief_thresh);
	sscanf(argv[7],"%d",&kickout);
	sscanf(argv[8],"%d",&rounds);
	sscanf(argv[9],"%d",&iters);

	srandom(time(0)); 


    bias_correct=unbias_correct=0.00;
    for (it=0;it<iters;++it) {
	for (i=0;i<N;++i) bias[i]=unbias[i]=0;
	for (i=0;i<rounds;++i) {
		if (randbit(lo_frac)) {
			for (vote=0,j=0;j<n;++j)
				vote += thief[j] = randbit(p_lo);
			if (vote>n-thief_thresh*n || 
			    (vote>=thief_thresh*n && randbit(0.5))) {
				for (j=0;j<n;++j)
					if (thief[j]) ++bias[j];
				for (j=n;j<N;++j)
					if (randbit(p_lo)) ++bias[j];
			}
		} else {
			for (vote=0,j=0;j<n;++j) {
				vote+= thief[j] = randbit(p_hi);
			}
			if (vote>=thief_thresh*n && vote<=n-thief_thresh*n)
				which=randbit(0.5);
			else if (vote<thief_thresh*n) which=0;
			else which=1;
			for (j=0;j<n;++j)
				if (which==thief[j]) ++unbias[j];
			for (j=n;j<N;++j)
				if (which==randbit(p_hi)) ++unbias[j];
		}
	}
	bias_correct = bias_correct + frac_correct(bias);
        unbias_correct = unbias_correct + frac_correct(unbias);
    }
    printf("Detection rates: %.4f biased, %.4f unbiased.\n",
		bias_correct/iters,unbias_correct/iters);
}
