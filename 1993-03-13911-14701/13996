Newsgroups: sci.crypt
Path: msuinfo!uwm.edu!wupost!usc!elroy.jpl.nasa.gov!ames!sgi!wdl1!wdl39!mab
From: mab@wdl39.wdl.loral.com (Mark A Biggar)
Subject: Re: "Card-shuffling" algorithms
Message-ID: <1993Mar5.230404.25380@wdl.loral.com>
Sender: news@wdl.loral.com
Organization: Loral Western Development Labs
References: <1993Feb25.201917.1717@ee.eng.ohio-state.edu> <1mmhpqINNhr5@uwm.edu> <1993Mar4.184800.1@zodiac.rutgers.edu>
Date: Fri, 5 Mar 1993 23:04:04 GMT
Lines: 87

In article <1993Mar4.184800.1@zodiac.rutgers.edu> leichter@zodiac.rutgers.edu writes:
>In article <1mmhpqINNhr5@uwm.edu>, markh@csd4.csd.uwm.edu (Mark) writes:
>| In article <1993Feb25.201917.1717@ee.eng.ohio-state.edu> butzerd@columbia.eng.ohio-state.edu (Dane C. Butzer) writes:
>||Does anybody know of an algorithm that will randomly shuffle a deck in one
>||pass, with one random number chosen per card, given a "good" random number
>||generator?  Is such an algorithm even believed to be possible?
>| Impossible.  Shuffling is the inverse of sorting, which is an N log(N) process.
>| Therefore you need log(N) passes at the very least.
> (bogus analysis deleted)

What? The following algorithm does exactly what he wants with exactly 1 pass
through the deck, picks one random number per card and does exactly n-1 swaps
for an O(n) algorithm.  In C. assume card[1] through card[n] is the deck.

for (i = n; i > 2; i--) 
    swap(card[i],card[rand(i)]);

where rand(n) return a uniformly distributed random int between 1 and n 
inclusive.  In english, this picks the nth card randomly from cards 1-n,
the n-1th card from the remaining n-1 cards, the n-2th card from the remaining
n-2 cards etc.  This generates exactly one of the permutations of the
original deck with equal uniform probability.

--
Mark Biggar
mab@wdl1.wdl.loral.com


assume card[i] is the ith card with n cards in the deck.
>| 
>| Take any comparison-based sorting algorithm at all.  Replace the comparison
>| operation:
>| 
>| Compare(A, B) = 0 if A <= B
>|                 1 if A | B
>| 
>| with the randomizer
>| 
>| Random(A, B) = 0 or 1 with equal probability.
>| 
>| The result is a shuffling algorithm.
>| 
>| The converse is true too.  Take any transposition-based random shuffling
>| algorithm.  Replace the random transposition function
>| 
>| Transpose(A, B) = (A, B) or (B, A) with equal probability
>| 
>| with a comparison-based transposition function:
>| 
>| Permute(A, B) = (A, B) if A <= B, or (B, A) if A | B.
>| 
>| The result is a sorting algorithm.
>
>Nice argument, but you made a BIG assumption along the way, one which was not
>in the original problem statement:  That the random shuffle was "transposition
>based".  Whatever exactly that means.
>
>It is in fact trivial to provide an algorithm that does exactly what the
>original problem requires:
>
>	Shuffling one card is easy.
>	To shuffle n cards, first shuffle the first n-1.  Then choose
>		with uniform probability an integer r between 0 and n-1.
>		Count off r cards from the already-shuffled deck, insert the
>		remaining card, and append the remaining cards.
>
>It is easy to see - using your connection between sorting and shuffling, for
>example - that the random number generator makes "as few choices as possible".
>
>It is also easy to see that one BIT per card is not nearly enough (since
>2^n < n! for n > 3).
>
>(This algorithm is the equivalent of the following "optimal" sorting
>	algorithm:
>
>	Sorting one element is easy.
>	To sort n elements, sort the first n-1, then insert the nth after
>		a binary search.
>
>I say "optimal" since it uses log n! COMPARISONS - the theoretical optimum -
>but O(n^2) MOVES to insert an element into the array needed to do a binary
>search.  One can use a binary tree to make the whole thing O(n log n); the
>same limitation, and fixup technique, works for the shuffler.)
>
>							-- Jerry


