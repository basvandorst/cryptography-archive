Path: msuinfo!uwm.edu!wupost!micro-heart-of-gold.mit.edu!rutgers!igor.rutgers.edu!zodiac.rutgers.edu!leichter
From: leichter@zodiac.rutgers.edu
Newsgroups: sci.crypt
Subject: Re: an idea
Message-ID: <1993Mar2.183648.1@zodiac.rutgers.edu>
Date: 2 Mar 93 23:36:48 GMT
References: <9302232203.AA18079@pizzabox.demon.co.uk> <1993Feb25.103557.11350@mnemosyne.cs.du.edu> <1993Feb25.144511.17815@magnus.acs.ohio-state.edu> <1mk4u7INNota@senator-bedfellow.MIT.EDU>
Sender: news@igor.rutgers.edu
Organization: Rutgers University Department of Computer Science
Lines: 71
Nntp-Posting-Host: pisces.rutgers.edu

In article <1mk4u7INNota@senator-bedfellow.MIT.EDU>, ninassup@athena.mit.edu
(Nikos I Nassuphis) writes:
| A lattice gas is a digital approximation of a real, thermodynamic gas.
| It works by representing particles with a single bit, which can travel
| in any of eight directions (N,S,E,W,NE,SW etc) with unit speed....
| 
| The evolution of the gas is computed by continously going through
| a move step, which moves all particles in thei respective directions
| and a collide step which uses a look-up table to collide particles that
| are on the same lattice site. The collision rules are chosen in such
| a way that mass, momentum and energy is conserved.
| 
| Such a "digital gas" behaves a little bit like a real one in that 
| is will rapidly "thermalized" from any initial configuration, and it
| will stay thermalized thereafter.
| 
| I have been toying with the idea of using a lattice gas algorithm for
| encryption purposes... as follows:
|
| 1.
| Take your message and use it as an intitial state for a gas state. Run it
| through the lattice gas algorithm until it reaches equilibrium.
| 
| 2.
| Flip some bits in the resulting (thermalised gas)
| 
| The key is the location and number of bits that were flipped, along with
| the number of steps the gas was evolved....
| 
| To decode just flip the same bits, reverse all speeds and run the simulation
| for the same number of steps as it was run during the encoding.
| The message will "spontaneously" appear....
| 
| even a single wrong bit is enough to prevent the message from decoding 
| correctly....

An algorithm of this general flavor was proposed years ago for use in a
particular situation, which lead to the title of the paper - something like
"The Wiretapper's Channel".  The idea was as follows:  Suppose you know that
someone is listening in to your communications, but his tap is noiser than
your direct connection.  To keep your message secure, use a carefully
selected error-correcting-code which will correct up to k one-bit errors,
where you can expect that you can send the message with no more than m bit
errors, while the wiretapper can expect n bit errors (where m < k and m < n).
Now deliberate flip (k-m) bits, at random, in the message.  Your intended
receiver can use the ECC to correct the resulting expected k errors, while
the wiretapper will receive the message with at least k+1 errors and won't
be able to use the ECC.

A "properly chosen" ECC has the property that it can recover from k bit
errors, but for k+1 or more bit errors, it gives essentially random results.
Such codes are known; if I remember right, the paper used Goppa codes.

There are many chaotic algorithms one might hope to use in this kind of
scheme.  The lattice gas is a clever one.  I know of no work on the security
of such systems, though there is certainly work on all kinds of cellular
automata that should be applicable.  Just the fact that the output is
"apparently random", and even that it passes many statistical tests, is not
nearly enough.  You certainly have to run the simulation of the gas through
enough steps to be sure that most (probably all) of the output bits depend
on many (again, probably all) the input bits.  It's not obvious how to
calculate that number, though one can certainly give a lower bound - the
information can only move one lattice step a cycle.  Beyond that, the scheme
would probably be vulnerable to attack by a technique related to differential
cryptography.  This would likely require using yet more cycles to avoid -
and knowing how MANY cycles would be even harder to compute.

Nifty idea, and it MIGHT work well - but there's plenty of work to be done
before we should believe in it.  (Or it might turn out that it just plain
doesn't work after all.)
							-- Jerry
