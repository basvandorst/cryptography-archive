Path: msuinfo!uwm.edu!cs.utexas.edu!zaphod.mps.ohio-state.edu!usc!rand.org!jim
From: jim@rand.org (Jim Gillogly)
Newsgroups: sci.crypt
Subject: Running key ciphers [was; Challenging Message]
Message-ID: <16570@rand.org>
Date: 17 Mar 93 18:09:54 GMT
References: <1993Mar14.000511.14875@csi.uottawa.ca> <1993Mar14.043418.2037@altair.selu.edu> <1993Mar17.085030.1@zodiac.rutgers.edu>
Sender: news@rand.org
Organization: Banzai Institute
Lines: 52
Nntp-Posting-Host: mycroft.rand.org

In article <1993Mar17.085030.1@zodiac.rutgers.edu> leichter@zodiac.rutgers.edu writes:
>... What you are approaching is what is known as a "book code":  Rather
>than using one or a few key words, use the text of a book starting at some
>pre-agreed point.  Book codes can be, and have been, broken.  Think about how

I think of a "book cipher" as something more like Larry Loen describes in
the "Temporary independent sci.crypt FAQ" posted a few days ago -- like the
Beale Cipher B2, for example.  This kind of cipher is usually called
"Running Key", at least in my experience.

Jerry Leichter's comments about attacking it with statistics are
interesting, but with English-like key and plaintext there's an easier
way... crib-dragging.  For the sake of argument, let's re-cast it away
from Vigenere and go back to XORing the keytext against the plaintext to
get the ciphertext -- saves one step in the following observation without
changing the security aspects.  If you have a reasonable amount of text,
simply <guess> words, and drag them through the ciphertext XORing them and
looking for English-like results -- which could be either part of the key
stream or the plaintext stream.  These islands of plaintext can be
expanded on each end to break the whole thing by guesswork, working
plaintext and keytext against each other... and if the keytext is
recognized ("Emma Woodhouse, handsome, clever and rich...") you're done.
As someone pointed out on another thread, it's often easy to guess useful
text.  Depending on the application, some of my favorites are " the "
(good for five letters), " from the ", and "\n#include <stdio.h>\n".

>If you combine the three books up front to compute a series of key letters,
>the "bits of fuzz" argument tells you that the result is a RANDOM series of
>letters.  This is the famous "one-time pad", and the resulting system is
>usually called a Vernam cipher.  It is absolutely secure, as long as you
>never re-use any key material.

Nope.  You don't get random keytext with any deterministic process like
this.  The only way to get Vernam encryption is to use absolutely
physically random keys.  For example, there are now quite a few on-line
books in the Gutenberg Project's collection on the net... a lucky attacker
could discover by trial and error that the three books are "Pride and
Prejudice", one of the Sherlock Holmes stories, and "Moby-Dick", and the
encryptor started at the beginning, just by testing the available books.
That's how the author of the Beale Cipher pamphlet claimed to have solved
B2.  Or, almost as lucky, that the three were "Alice in Wonderland", "The
Marvelous Land of Oz", and "Ethel the Aardvark Goes Quantity Surveying"...
only the first two are in Gutenberg, but stripping those two off leaves
you with the plaintext and "Ethel" XORed with each other, and you're back
to the single-book case that you can solve with crib-dragging.  I'm not
saying it's <easy>, but just that whenever you're not using absolutely
random keys you're not in a state of (cryptological) grace.  No system
that can be solved by a lucky cryptanalyst can be considered "absolutely
secure" under the meaning of the Act.
-- 
	Jim Gillogly
	25 Rethe S.R. 1993, 18:09
