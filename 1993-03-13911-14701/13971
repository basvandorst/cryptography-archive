Newsgroups: sci.crypt
Path: msuinfo!uwm.edu!rpi!batcomputer!munnari.oz.au!cs.mu.OZ.AU!nareen.acci.COM.AU!ggr
From: ggr@nareen.acci.COM.AU (Greg Rose)
Subject: Re: an idea
Message-ID: <9306312.15051@mulga.cs.mu.OZ.AU>
Sender: news@cs.mu.OZ.AU
Organization: Australian Computing and Communications Institute
References: <9302232203.AA18079@pizzabox.demon.co.uk> <1993Feb25.103557.11350@mnemosyne.cs.du.edu> <1993Feb25.144511.17815@magnus.acs.ohio-state.edu> <1mk4u7INNota@senator-bedfellow.MIT.EDU> <1993Mar2.183648.1@zodiac.rutgers.edu>
Date: Thu, 4 Mar 1993 01:50:59 GMT
Lines: 62

>In article <1mk4u7INNota@senator-bedfellow.MIT.EDU>, ninassup@athena.mit.edu
>(Nikos I Nassuphis) writes:
>| A lattice gas is a digital approximation of a real, thermodynamic gas.
>| It works by representing particles with a single bit, which can travel
>| in any of eight directions (N,S,E,W,NE,SW etc) with unit speed....
>| 
>| The evolution of the gas is computed by continously going through
>| a move step, which moves all particles in thei respective directions
>| and a collide step which uses a look-up table to collide particles that
>| are on the same lattice site. The collision rules are chosen in such
>| a way that mass, momentum and energy is conserved.
>| 
>| Such a "digital gas" behaves a little bit like a real one in that 
>| is will rapidly "thermalized" from any initial configuration, and it
>| will stay thermalized thereafter.
>| 
>| I have been toying with the idea of using a lattice gas algorithm for
>| encryption purposes... as follows:
>|
>| 1.
>| Take your message and use it as an intitial state for a gas state. Run it
>| through the lattice gas algorithm until it reaches equilibrium.
>| 
>| 2.
>| Flip some bits in the resulting (thermalised gas)
>| 
>| The key is the location and number of bits that were flipped, along with
>| the number of steps the gas was evolved....
>| 
>| To decode just flip the same bits, reverse all speeds and run the simulation
>| for the same number of steps as it was run during the encoding.
>| The message will "spontaneously" appear....
>| 
>| even a single wrong bit is enough to prevent the message from decoding 
>| correctly....

So far all of the criticisms have been that the key can be derived
from a chosen plaintext, by running it forward until there is a near
correspondence. However this behaviour depends on the fact that the
bits are only flipped at the end. Similarly, flipping bits at the
beginning is just as useless, as you would simply take the ciphertext
and run the simulation backwards until the result looked sufficiently
like the plaintext (or had the statistical properties of the input
language).

My first reaction (and the partial quote I'm replying to doesn't say
it but I think that the original posting did) is to flip random bits
at random stages of the simulation. This means that running either
forward or backward would quickly diverge from the input.

But what if you simply flip bits at both ends of the process? This
ensures that the divergence when running the algorithm in either
direction is maximised. You can either somehow divide the set of bits
to be flipped between the beginning and and of the simulation, or even
flip the same bits (my mental picture of the process seems to indicate that
this wouldn't hurt).

Any comment on this revised algorithm?
--
Greg Rose                 Australian Computing and Communications Institute
ggr@acci.com.au                                              +61 18 174 842
`Use of the standard phrase "HIJACKED" may be inadvisable' -- CAA
