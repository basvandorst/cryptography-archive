Newsgroups: alt.security.pgp,sci.crypt
Path: msuinfo!caen!spool.mu.edu!enterpoop.mit.edu!ira.uka.de!rz.uni-karlsruhe.de!stepsun.uni-kl.de!uklirb!posthorn!vier!neuhaus
From: neuhaus@vier.informatik.uni-kl.de (Stephan Neuhaus (HiWi Mattern))
Subject: Statistical properties of PGP's session keys.
Message-ID: <neuhaus.733422094@vier>
Sender: news@posthorn.informatik.uni-kl.de (News system account)
Nntp-Posting-Host: vier.informatik.uni-kl.de
Organization: University of Kaiserslautern, Germany
Date: Mon, 29 Mar 1993 16:21:34 GMT
Lines: 316
Xref: msuinfo alt.security.pgp:2267 sci.crypt:14633

In the past, some postings have appeared on sci.crypt and
alt.security.pgp that stated that PGP was insecure, or was probably
cracked.  One posting specifically mentioned ``random numbers''.  I
took this to mean the IDEA session keys.  It was stated that there was
``strong prevalence on bytes'' and ``high serial correlation on
contiguous bytes in material of 10000 bytes''.  In other words, the
random numbers aren't random enough.

I have written a nice test suite so that you can test some of these
claims on your own computer.  My own results follow at the end of this
article.

Since I do not have an effective method of putting up archives for
ftp, you'll have to send me email, and I'll mail you the archive in
compressed tar format.

The code will probably run only under Unix.  The full test suite will
work only if your computer has an ANSI C compiler, is big-endian,
supports the IEEE double-precision format, and has the mmap(2) system
call.  None of these requirements is essential for the basic tests.
You will need several .o files from the PGP distribution.  See the
installation document at the end of this posting.  The package should
be free of patented stuff and should not be subject to export/import
restrictions.  However, I'm no lawyer (thank the gods), and I could be
wrong---it wouldn't be the first time.

This thing took a long time to complete.  Personally, I think it was
worth the time, but then I was always ``on the front line''.  I wish
to apologize for the long delay.



The Tests
---------

I have made equidistribution tests, serial correlation tests, and some
contingency table analysis.  (If you don't know what these mean, then
the test suite is obviously not for you.)  Testing was done on a Sun 3
with SunOS 4.1.1, gcc 2.3.3 and PGP 2.2.  The test suite permits you
to make equidistribution tests or serial correlation tests on
contiguous key bytes, byte pairs, byte quadruples, and entire keys,
after they have been converted to double-precision.  (This results in
loss of precision, and is not an entirely accurate test.)

Two programs have been tested only rudimentarily.  The `pop' program
destructively modifies your data file to find duplicates; it will
eventually be made into a full population test.  The `equitot' program
was actually never run.  It makes an equidistribution test on the
whole file, assuming that it is sorted.  This is a side effect of the
`pop' program.

Equidistribution tests on bytes and the contingency table analysis are
made with a chi-square test.  All other tests are Kolmogorov-Smirnov
tests.  In general, I did m > 1000 tests, taking n > 1000 observations
on each test.  (This was to make sure that the asymptotic formulas for
the significance values could be applied.  In fact, the software will
not allow you to make a chi-square test with 5 or less elements
expected in each category, so that an equidistribution test on bytes
must have n > 1280.)  Each test yields a statistic s_k (1 <= k <= m);
these statistics should have a certain distribution (for example, a
chi-square distribution with so many degrees of freedom).  This
hypothesis was tested with a final KS test.  This is the ``total
significance'' you get when you apply a test program.

The values of the s_k can be written to a file unmodified (although
with identifying information prepended in a header), so that they can
be subjected to various treatements.  For example, the distribution
contains a program `showres' that plots the actual statistics against
the theoretical distribution on an X terminal, and the `bin2gnuplot'
program writes a file that can be plotted with `gnuplot'.  (For best
results, use the --compress and --points switches and plot the
resulting file "with dots".)

The initial contents of the random seed file and the MD5 hash that PGP
uses internally were generated by throwing pennies and counting heads
as `1' and tails as `0' (or the other way around).  The initial
timestamp was deliberately (but arbitrarily) fixed at some date (see
the full report for the exact values).


The Results
-----------

From the table below, I conclude that the bytes and shorts *are*
equidistributed in this particular configuration.  In fact, with the
exception of the one 9.9% entry in line 1, all other significances are
above 10%.  This is not small enough to reject equidistribution.

Note that I'm getting *horrible* results when the key generation
method of PGP 2.1 is used, even with the improved PRNG of 2.2. When I
used the new make_random_ideakey(), the bad results disappeared.  I'm
still wondering, however, if all this complication is really
necessary.  (I looked at the code, and I don't fully understand it.)

The serial correlation tests do not have meaningful significances,
because noone knows the distribution of the serial correlation
coefficient when the numbers are uniformly distributed and
independent.  I'm listing here only the maximum and minimum
coefficient.  Graphical displays indicate that the coefficients are
normally distributed with a mean < -1/n and a standard deviation of
about 1/sqrt(n).  If anybody is interested, I'd like to see a
nonlinear least-squares (or other) fit of the actual data to that
model.

The ``B'' equidistribution tests are chi-square tests followed by a KS
test to see if the chi-square values have the chi-square distribution
with 255 degrees of freedom; the ``S'' tests are KS tests followed by
two KS tests to see if the KS results have the KS distribution.
(Naturally, since each KS test yields two numbers, K_n^+ and K_n^-, I
was able to make two KS tests, one on the K_n^+ values, and one on the
K_n^- values.  In the table, the first line is for the K_n^+ values,
and the second one for the K_n^- values.)

As you can calculate from the numbers below, my tests were done on 7
Meg keys (i.e., 7*1024*1024 keys, not bytes).

[B = Bytes; S = Shorts (= byte pairs);
K_n^+ = KS statistic from above; K_n^- = KS statistic from below;
S^+ = Pr {K_n^+ > observed}; S^- = Pr {K_n^- > observed};
S = Pr { max {K_n^+, K_n^-} > observed};
min. r = minimum serial correlation coefficient;
max. r = maximum serial correlation coefficient.]

Equidistribution

What | tests | samples |   K_n^-  |    S^-   |   K_n^+  |    S^+   |     S
-----+-------+---------+----------+----------+----------+----------+---------
B    |  1024 |  114688 | 1.074619 | 0.099300 | 0.169267 | 0.944308 | 0.198405
B    |  2048 |   57344 | 0.850137 | 0.235637 | 0.343101 | 0.790226 | 0.465112
B    |  4096 |   28672 | 0.771757 | 0.303851 | 0.196441 | 0.925725 | 0.590698
B    |  8192 |   14336 | 0.638809 | 0.442129 | 0.462255 | 0.652230 | 0.809121
B    | 16384 |    7168 | 0.275590 | 0.859074 | 0.571782 | 0.520029 | 0.899299
B    | 32768 |    3584 | 0.406776 | 0.718253 | 1.021368 | 0.124135 | 0.247795
S    |  1024 |   57344 | 0.460718 | 0.654083 | 0.844382 | 0.240277 | 0.473893
     |       |         | 0.667006 | 0.410740 | 0.673984 | 0.403125 | 0.753993
S    |  2048 |   28672 | 0.541677 | 0.556088 | 0.818893 | 0.261539 | 0.513732
     |       |         | 0.350706 | 0.781930 | 0.846104 | 0.238882 | 0.471257
S    |  4096 |   14336 | 0.853865 | 0.232661 | 0.665504 | 0.412388 | 0.459466
     |       |         | 0.537335 | 0.561323 | 0.686253 | 0.389891 | 0.733981
S    |  8192 |    7168 | 0.372619 | 0.757532 | 0.838701 | 0.244916 | 0.482643
     |       |         | 0.484600 | 0.625206 | 1.025464 | 0.122071 | 0.243697


Serial correlation

What | tests | samples |    min. r   |    max. r
-----+-------+---------+-------------+-----------
B    |  1024 |  114688 | -0.00935271 | 0.00998983
B    |  2048 |   57344 | -0.0153073  | 0.0134544
B    |  4096 |   28672 | -0.0229335  | 0.019786
B    |  8192 |   14336 | -0.0336005  | 0.0315547
B    | 16384 |    7168 | -0.0479129  | 0.0450025
B    | 32768 |    3584 | -0.0621297  | 0.082112
S    |  1024 |   57344 | -0.0127302  | 0.0113458
S    |  2048 |   28672 | -0.0207855  | 0.0212214
S    |  4096 |   14336 | -0.034762   | 0.0334531
S    |  8192 |    7168 | -0.0448601  | 0.0438881
S    | 16384 |    3584 | -0.069847   | 0.0685689
S    | 32768 |    1792 | -0.0966103  | 0.0960926


[Note that Sidelnikov's serial correlation of "0.05..0.1 in material
of 10000 byte" does not appear.]

On the whole, PGP 2.2's random keys are *much* better than 2.1's.  We
shoud never, never switch back to that scheme!

When I have the time, I will look at the contingency table analysis to
find dependencies between bits in a key.  The code is already there.



Remarks
-------

Due to the rather small amount of generated keys (only 2.057e-38 of
the size of the complete key space), the validity of the results can
of course be doubted.

A full report on this is in progress, but I can only work on this on
weekends, so it may take a while before it is done.  I will announce
its availability in this forum.

Mailing out the sources may take some time, since I plan to do some
cosmetical patch-ups before sending.  This should delay delivery by
one day at most.

Nearly all the code is under the GPL.  Some of the mathematical
routines were written by William J. Cody of Argonne National Labs and
converted to C with the f2c compiler, available from netlib.  Without
the excellent service from netlib, and without the excellent routines
by Cody, I could not have completed that project.  Thank you!  (I'm
not sure about the copyright status of Cody's code, but I left all
references to him or to Argonne in the C file, and since the code is
available from netlib, I assume that there are no problems.  This code
is of course not GPL'd.)

Some of the routines are based on code in Numerical Recipes.  It is
still under my copyright and comes under the GPL.  The Recipes are
clearly credited.  If anyone either a) knows where to get better
source code for the routines, or b) has any problems with my copyright
on the sources, please contact me.  (The code was rewritten from
scratch in *all* cases, and I still have the scratch paper to prove
it, so I'm not stealing anybody's code.  The problem is that some of
the NR routines are difficult to code in a different manner.)

Please send me bug reports of any kind.  However, I do *not* want to
maintain this suite for non-Unix machines, or even Unix machines that
lack certain essential features.  If you want to patch the code so
that it works on little-endian, non-IEEE-754 machines (if you insist
on --doubles), or without the mmap(2) call (if you insist on `pop'),
or even with MS-DOG (if you are insane), go ahead.  But don't expect
me to port and maintain the code to machines that I do not have access
to.  Also don't expect me to turn out a non-ANSI version.  The basic
tests should all work on all Unix boxes anyway.  Only the `pop'
program and the `--doubles' option should be affected.


Installation document
---------------------

The general outline of what you have to do to run the tests yourself
is:

1. Unpack the distribution in an empty directory.  This consists of
uudecoding, uncompressing, and untarring.

2. Modify the Makefile and set the PGPDIR variable to the directory
where you keep your PGP object (.o) files.  If you don't have X
running, remove `showres' from the target `all' in the Makefile.

If you do not have an ANSI C compiler, you'll probably have to fiddle
around with unproto yourself (I don't know how to do that), in order
to remove the function prototypes.

3. If your floating-point format is IEEE 754, but if you have a
little-endian system (such as a 80x86-based Unix box), and if you want
to conduct tests with the --doubles option (see the manpages in the
distribution for the meaning of that option), get in touch with me,
and we'll work out a source patch.  If your format is not IEEE 754,
forget about using the --doubles option.  It's not essential.

4. Say `make all' or `gmake all'.  After this has been completed, you
should have the following executables in your directory:

	bigtest
	conting
	equi
	equitot
	mkdata
	prepare
	sercor
	[showres]
	pop


The showres program will only be created if you have X running.  If
you forgot to take it out of your makefile, the compilation will
abort.  The files `bigtest' and `mkdata' are actually shell scripts.

5. Check how much space is left on your hard disk.  For a minimal
test, you should have at least 13107200 bytes (10MB) free.  The more
the better.  Let x be the number of bytes that you want to spare.
Leave some space for the results of the tests.  Compute y =
floor(x/20).  This is the number of keys that will be generated.  (You
might think that this is a mistake, since each key has 16 bytes, but
since each key gets a four-byte serial number prepended as it is
written out, the size of one key on the disk is 20 bytes, not 16.)

Look in the file `mkdata'.  This file contains an invocations of
`prepare'.  Modify the value of the --nkeys=... option and insert your
value of y there.  (The reason for the `mkdata' script is so that you
don't have to type in all these random initial values on the command
line.)  Run the mkdata script.  Take a long coffee break.

6. I *told* you to take a *long* coffe break, didn't I?  Since the
`prepare' program hasn't yet finished, why don't you go inhale some
more caffeine? :-)  (Generating 7*1024*1024 keys took about 10 hours
on a Sun 3 with a fast disk.)

7. Now you are ready to make your tests.  If you have X, be sure to
add the --binary (-B) option to the test programs.  You will then be
able to view the results graphically.  Read the manpages for equi,
sercor, pop, prepare, possibly showres, and conting.  Don't forget
that you might have trouble with the --doubles option if your computer
doesn't have IEEE 754, or is not big-endian.  If your operating system
is SysV-based, with a 14-character limit on file names, and if you
still want to use --binary, you should patch the sources.  Get in
touch with me, and we'll work something out.


Okay, now that you have compiled everything, I'd like to ask you to
make the following test:

	./equi --runs=128 --observations=4096 --bytes --binary

Then look at the output file with the `showres' program if you have an
X terminal, or use `bin2gnuplot' and gnuplot.  The ``total
significance'' that the program reports should not be smaller than
0.1.  If it is, please contact me.

Now you can start on the real thing.  Type

	nohup nice -20 ./bigtest > results &

log out, and come back three days later.  The `results' file will
contain the results of the equidistribution and serial correlation
tests.


Have fun.

-- 
Stephan <neuhaus@informatik.uni-kl.de>
sig closed for inventory.  Please leave your pickaxe outside.
PGP 2.2 public key available on request.  Note the expiration date.
