Newsgroups: sci.crypt
Path: msuinfo!uwm.edu!wupost!darwin.sura.net!paladin.american.edu!europa.eng.gtefsd.com!fs7.ece.cmu.edu!crabapple.srv.cs.cmu.edu!mnr
From: Marc.Ringuette@GS80.SP.CS.CMU.EDU
Subject: Re: Identifying / Securing Files
Message-ID: <C4MI2p.57u.1@cs.cmu.edu>
Originator: mnr@GS80.SP.CS.CMU.EDU
Sender: news@cs.cmu.edu (Usenet News System)
Nntp-Posting-Host: gs80.sp.cs.cmu.edu
Organization: School of Computer Science, Carnegie Mellon
Date: Sun, 28 Mar 1993 23:06:00 GMT
Lines: 58

gec> Agreement. sigh. There is _no_ unbreakable software protection :_)
gec> At least not until the program is constantly able to communicate with
gec> the vendor of it *grin*

Germano says these things lightheartedly, but I'm very interested in
understanding both of these possibilities from a cryptographic perspective.
How about a cryptographic means of making sure that the user of a program
cannot dissasemble it, and cannot find out any more about the program than
it's strict i/o mappings?  Or, if communications are available, how about 
a means of offloading a few computations to the software owner's machine in
order to prevent dissasembly and/or implement pay-per-use?

I have often heard the claim that there's no such thing as "cryptographically
strong copy protection", and in fact that the whole idea is silly.  But all
the evidence I ever get is anecdotes.

Part of the difficulty is that it's a hard problem to formalize.  Here's
a crack at it.  Can you prove anything about the following two problems?

 1. A program P computes a function f(i) over the integers.
    The program is expressed in terms of a simple machine language.
    Does there exist an obfuscating process Obf(P) which produces a
    new program P' which computes f(i) but guarantees to give away no
    more information on any single run than the value of f(i)?

 2. A program P computes a function f(i) over the integers.
    The user's machine is in constant communications with the
    software author's machine.  Is it possible to rewrite P
    so that (a) it requires at least one communication with the
    author's machine per run, and (b) the amount of communications
    per run is small, even if i and/or f(i) are large?

For case 1, we're looking for some kind of "cryptographically strong
code shuffler."  I'm imagining some code which munges the input
unrecognizably, does incomprehensible things to it, and through some
kind of magic, finally XOR's the answer out of thin air on the last
instruction of the program...

For case 2, we can obviously succeed in requiring communications
with the author's machine on each run if the entire computation of
f(i) is offloaded.  But in order to limit the bandwidth of communications 
between the author and the user, can we concoct a means of offloading
only a few public-key decryptions (or some such) instead of the entire
computation?

Two final requests:  

   1. No anecdotes, please, about practical copy-protection.  I'm not
      being practical here.  I want _theory_.  References to something in
      the literature would be great.

   2. If you have nit-picks about my question, please suggest fixes
      rather than just flaming me about it.  These are hard problems
      to write down in an airtight way.

Thanks.

-- Marc Ringuette (mnr@cs.cmu.edu)
