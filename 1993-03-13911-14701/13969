Newsgroups: sci.crypt,sci.math
Path: msuinfo!caen!batcomputer!munnari.oz.au!cs.mu.OZ.AU!nareen.acci.COM.AU!ggr
From: ggr@nareen.acci.COM.AU (Greg Rose)
Subject: Re: "Card-shuffling" algorithms
Message-ID: <9306312.14290@mulga.cs.mu.OZ.AU>
Summary: You have a bug.
Sender: news@cs.mu.OZ.AU
Organization: Australian Computing and Communications Institute
References: <C2xAxr.9Ln@mentor.cc.purdue.edu> <C2xpHF.1v7@cup.hp.com>
Date: Thu, 4 Mar 1993 01:25:02 GMT
Lines: 93
Xref: msuinfo sci.crypt:13969 sci.math:40446

In article <C2xpHF.1v7@cup.hp.com> dhepner@cup.hp.com (Dan Hepner) writes:
>
>Thanks for the critical analysis of the card shuffling algorithm.  I'm
>sure you guys are right, that there's some difference, and this is not
>in any way a dispute over which is correct.  But can you tell me how
>much difference it makes?  Could we predict the "winner" or the "loser"?
>I mean, it's not obvious.  I used the three card deck, as advised by both 
>people who made essentially the same recommendation to perfect "my" 
>algorithm (which was pointed out as being suggested in its correct form 
>long ago by Knuth).

The problem with your program is simple -- you only initialise the
deck once -- so the ABSOLUTE order of the cards quickly becomes truly
random. However, in a casino, someone could watch the order of the
cards in the previous hand, and would have a distinct chance of
improving their odds on the next deal. To demonstrate this, I modified
your program by moving the initialisation into the loop.
>
>If you really care, here's the program which generates those results.
>---------------------------------------------------------
>#include <stdio.h>
>
>int cards[3];
>
>int count [222];
>
>main ()
>{
>    int i,r,n, temp, loop, a,b,c;
>    srand48(time(0));
>    for (i=0; i<3; i++)
>	cards[i] = i;
>    for (loop=0; loop < 10000000; loop++)
>    {
>	for (n=0; n<3; n++)
>	{
>	    r = lrand48() % 3; 
>	    temp = cards[r];
>	    cards[r] = cards[n];
>	    cards[n] = temp;
>	}
>	i = (cards[0] * 100 + (cards[1] * 10) + cards[2]);
>	count[i] ++;
>     }
>     for (a=0; a< 3; a++)
>	for (b=0; b<3; b++)
>	   for (c=0; c<3; c++)
>	   {
>	      if ((a != b) && (a != c) && (b != c)) 
>	      {
>	         i = (100 * a) + (10 * b) + c;
>	         printf ("result %d = %d\n", i, count[i]);
>              }
>           }
>}

My change:
$ diff t.c t1.c
11,13c11
<     for (i=0; i<3; i++)
<       cards[i] = i;
<     for (loop=0; loop < 10000000; loop++)
---
>     for (loop=0; loop < 100000; loop++)
14a13,14
>       for (i=0; i<3; i++)
>           cards[i] = i;

(I reduced the loopcount as the difference is somewhat obvious.)
$ time a.out
result 12 = 15098
result 21 = 18513
result 102 = 18267
result 120 = 18542
result 201 = 14688
result 210 = 14892

real    0m2.27s
user    0m1.88s
sys     0m0.02s

Note that there are two distinct groups, with a 25% difference between
them. For example, the second card has a 10/27 probability of being a
'2', but only an 8/27 probability of being a '1'. The first card is
similarly more likely to be a '1'.

Trying to exploit this bug in a deck of 52 cards would be pretty hard,
I admit, but it is nevertheless the case that there are predictable
non-uniformities in the outcome of the shuffle.
--
Greg Rose                 Australian Computing and Communications Institute
ggr@acci.com.au                                              +61 18 174 842
`Use of the standard phrase "HIJACKED" may be inadvisable' -- CAA
