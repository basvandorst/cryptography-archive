Path: msuinfo!caen!zaphod.mps.ohio-state.edu!wupost!darwin.sura.net!europa.asd.contel.com!emory!athena.cs.uga.edu!groucho.dev.uga.edu!is
From: is@groucho.dev.uga.edu (Bob Stearns)
Newsgroups: sci.crypt
Subject: Re: Missing subject header
Message-ID: <1992Jun16.185041.11635@athena.cs.uga.edu>
Date: 16 Jun 92 18:50:41 GMT
References: <1992Jun16.150920.19026@rchland.ibm.com>
Sender: news@athena.cs.uga.edu
Organization: University of Georgia
Lines: 62

In article <1992Jun16.150920.19026@rchland.ibm.com> lwloen@rchland.vnet.ibm.com (Larry Loen) writes:
>In sci.crypt <m04430o@fido.asd.sgi.com> DES Keysearch machines, explain ,
>Nelson Boyard writes:
>
>> (in) li@oracorp.com (Li Gong) writes:
>>>One must realize that *if* the compression algorithm is known to the
>>>attacker (which is often the case), then he can also recognize things
>>>in compressed form.  
>
>>But only IF the compression algorithm is known to the attacker before the
>>attacker builds his massively parallel key search engine.  It's easy for
>>the attacker to change his mind, less easy for him to change thousands of
>>chips.
>
>Classically, it is assumed that all details about a cryptography system are
>known to the attacker except the particular key used.  In a commercial
>environment, this would certainly be a sound assumption as most companies
>would have to standardize just about everything but the key.  Thus, any
>algorithm used to "precompress" the data must be assumed to be known.
>
>It is often quite possible to find data with lots of zeroes or space
>characters and these will often themselves have large, repeatable outputs
>in a typical compression algorithm.  Note that the compression
>algorithm will not and need not repeat bytes.  The problem is one of 
>predictability (or, being predictable around a small number of values or
>being somehow deducable even post-encryption).  For a DES attack, one must
>merely be able to predict what any eight bytes of plaintext were.  This may
>render any compression whatever moot, because the compression obviously
>happens before the encryption step; the compression output is the "plaintext"
>that the massive parallel machine works upon.  This may sound hard to do; it
>probably is, but it is the sort of thing that has been done before.
>
An approach which eliminates this problem, enhances security, and other
motherhood phrases is to use a changing, trimmable prefix. Since most
modern compression algorithms are one pass decodable, any string X will
compress to the same Xc no matter what follows it, so long as X is the
first part of the object to be compressed. 

Given this handy property, take some passage Pk and compress it, giving 
Pkc. Then prepend Pk to M, the actual message, and compress the result, 
giving C. Remove Pkc from the front of C, encrypt the remaining C' using
a shared secret key (DES??) and transmit it. 

Reconstruction is achieved at the receiving site by: decrypting C', 
using the shared secret key; compressing the same Pk giving the same 
Pkc; prepending Pkc to C' giving C; uncompressing C; removing Pk.

Since C' contains dictionary references to Pkc which is not included, 
it is seriously more difficult to interpret even if the key is 
compromised. If Pk is changed regularly and has character, word and 
non-textual statistics similar to C then almost all of C' will consist 
of references to the compression of Pk which is not present in the 
message, making the interpretation after decryption very difficult. A 
good source for Pk is a travesty of some fraction of the preceding 
traffic on the channel. Choose the order of the travesty to optimize 
between the cost and the precision of the match of the statistics of
Pk with M.
-- 
Bob Stearns
University of Georgia
is@groucho.dev.uga.edu
(404)542-5110
