Path: msuinfo!caen!zaphod.mps.ohio-state.edu!ncar!noao!arizona!rcs
From: rcs@cs.arizona.edu (Richard Schroeppel)
Newsgroups: sci.crypt
Subject: Hugenum hardware board
Keywords: bignum
Message-ID: <17601@optima.cs.arizona.edu>
Date: 8 Jun 92 19:10:52 GMT
Sender: news@cs.arizona.edu
Reply-To: rcs@cs.arizona.edu (Richard Schroeppel)
Organization: U of Arizona, CS Dept, Tucson
Lines: 582

I am posting this message for Harvey Dubner <70372.1170@compuserve.com>.
He doesn't get sci.crypt, so replies should go to him by email.
I have never met or worked with Mr. Dubner, or used his equipment;
but I know that some computational number theory people have worked
with him, and that some of his hardware was used in verifying the
repunit prime R1031.

-- Rich Schroeppel  rcs@cs.arizona.edu

-------------------------------------------------------

From: Harvey Dubner 
 
For the past 10 years I have been using special purpose hardware designed
and built by my son, Robert Dubner, to do number theory work.  We have now
built a printed circuit board, called the Cruncher, which plugs into a PC
and improves performance by orders of magnitude for operations with large
numbers.  PC performance can approach supercomputers and far surpasses work
stations.
 
As a business venture, selling the Cruncher makes no sense.  We cannot
afford money for engineering design, software, marketing, sales,
management, and almost everthing else.  We are prepared, as a labor of
love, to supply all this at no cost.  However we do need money for
prototype parts, test equipment, printed circuit board design and
fabrication, test bed PC computer, etc.  And of course the parts and labor
to build and test each Cruncher.
 
Considering the small number of units we can hope to sell, we have decided
to sell the Cruncher for US $2500.  Delivery is three months.
 
I have attached two documents which give more details:
 
            PROPOSAL                   dated April 12, 1992
            TECHNICAL SPECIFICATIONS   dated May 31, 1992
 
I will be happy to answer any questions.
 
Harvey Dubner
 
ps: Want to buy one?  Do your friends want any?  Your enemies?
 
 
 
                           PROPOSAL
 
A Proposal For Making High-Speed Numerical Calculation
Economically Available to a Wide Range of Researchers
 
Robert Dubner
Harvey Dubner
 
April 12, 1992
 
 
Synopsis
 
Theoretical advances in modern number theory often involve vast amounts of
computation -- so much so that it becomes frustrating to work on any but
the most advanced supercomputers.  Processing time on those machines
comes, of course, at a tremendous premium.  Researchers must beg or steal
small snippets of time on the big machines, or emphasize investigations
that can be tailored to the capabilities of less-powerful computers.
 
For the last eight years, we have been making significant contributions to
number theory using a computer in our living room.  The machine is a home-
built personal computer augmented with special-purpose hardware optimizing
it for numerical computations on numbers ranging in size from several
hundred digits to about ten thousand digits.
 
The time is now ripe for a new generation of special-purpose hardware,
which will run about ten times faster than our current circuitry.  We
propose to design that hardware so that it will plug into any IBM-PC/AT
compatible computer.  The result will be that any researcher who wants
supercomputer capability for manipulating large numbers will be able to
have it -- at roughly one one-thousandth the cost.
 
 
Background
 
The branch of Mathematics called Number Theory has the distinction of
dealing with problems that amateurs can understand but professionals
cannot solve.  Often the source of new ideas and theories is massive
arithmetic calculations.  At first these calculations were done by hand,
then by mechanical calculating machines, and in modern times by electronic
computers.  In fact, modern number theory and computer technology are
intimately entwined.
 
Number theory problems have played a prominent role in the testing of the
largest computers, where complex calculations are used both to verify the
designs and test the computers in production.  As a byproduct, the
availability of such massive free computer time has contributed to the
solution of many number theory problems.  In general, the accelerating
improvements in the cost effectiveness of computers have led to
corresponding improvements in basic theory which in turn lead to computers
being used more effectively.  This is particularly illustrated by the
continuing massive improvements in factoring, prime finding, primality
proving, and calculating the digits of pi. A new phenomenon is the
development of applications of number theory which are actually useful to
non-mathematicians, such as cryptography and random number generators.
 
In 1984 we developed a special-purpose number theory computer oriented
toward doing calculations on numbers ranging in size up to several
thousand digits.  The computer was similar in cost and configuration to a
PC but its performance for number theory was within a factor of ten of a
Cray supercomputer.  Of great significance was the availability of the
computer 100% of the time for number theory work in the home.  As a result
of using this computer and its successor we discovered 48% of the 1,000
largest known primes, helped prove the primality of the repunit R1031
(1,031 1's), showed that there are no repunit primes larger than this up
to R16500, developed a new theory for producing Carmichael numbers, derived
a new approach for counting partitions based on cosine series, and made
significant contributions to the Cunningham project for factorization.
About twenty papers have been published.
 
Consider the potential contributions from a veritable army of
professionals and amateurs armed with plug-in boards which convert low-
cost PCs into supercomputers for number theory.
 
 
Historical Review of Our Efforts
 
We first started writing software for the arithmetic manipulation of large
numbers in 1980.  Our first effort was done totally in software on a home-
built computer based on a two megaHertz Intel 8080 processor.
 
That machine's basic register-to-register operation time was on the order
of two microseconds.  The first algorithm was based on maintaining a
single decimal digit in each byte of memory.  Multiplication was done by
a schoolboy algorithm -- the digit-by-digit multiply was implemented by
doing a table lookup.  The inner-loop time of the multiply was on the
order of 300 microseconds.  The time for multiplying two 1,000-digit
numbers was thus on the order of 300 seconds.  Division was implemented by
using Knuth's Algorithm D.
 
That first implementation had some interesting characteristics, largely as
a result of the table lookup.  It was quite simple, for example, to start
investigating the properties of very large numbers in radixes other than
base ten.  But it was very slow.
 
Within a few months we made the software run faster by going to a binary
representation and moving to sixteen-bit arithmetic.  This version had an
inner-loop time of about one millisecond, and the time to square a 1,000-
digit number dropped to about forty-three seconds.  This was just about as
fast as the 8080 computer could possibly go, so within a year or so we
began to look into augmenting the hardware.
 
Our first attempt at speeding up the 8080 hardware involved adding a pair
of RCA CDP1855 unsigned-magnitude eight-bit multiply-divide-unit chips to
the computer.  These components could multiply two sixteen-bit numbers in
about sixteen microseconds.  A new program was written to take advantage
of the part.  The internal representation was now straight binary, and the
inner-loop time was on the order of 100 microseconds.  The benchmark time
for multiplying two 1,000-digit numbers on this machine was on the order
of four seconds.
 
In late 1982 we added a five megaHertz bit-slice processor to the
computer.  This processor was also equipped with a TRW MPY16 16-bit
multiplier chip and some logic for doing the additions.  This version of
the hardware also did the schoolboy algorithm in sixteen-bit chunks, and
the inner-loop time was reduced to 1.2 microseconds.  In this machine,
multiplying two 1,000-digit numbers took about sixty milliseconds.
 
Early in 1984 we designed and built what has basically been our workhorse
for the last eight years.  The Magic Multiplier has a complete hardware
implementation for doing the multiply-and-two-adds inner loop of the
schoolboy algorithm.  Memory is thirty-two bits wide and the period of the
inner loop is 150 nanoseconds.  Theoretically this hardware can be used to
multiply two 1,000-digit numbers in 1.6 milliseconds; in practice the
special hardware is so much faster than the general-purpose computer that
loads up its address pointers and counters at the beginning of each pass
of the outer loop that overhead slows things down, even at the 1,000-digit
level.  The observed time for the multiply is about 1.9 milliseconds.
 
In four years we had increased the speed of our benchmark 1,000-digit
multiply from 300 seconds to 1.9 milliseconds -- a factor of 160,000.
 
In 1988 we looked again at what we were doing with an eye toward
increasing the speed yet again.  We reluctantly came to the conclusion
that a significant speed increase just wasn't feasible given the amount of
money and effort we were willing to dedicate.  We compromised by building
four more units.  We replaced the archaic 8080-plus-bit-slice control
computer with a twenty megaHertz Motorola 68020, but the high-speed
multiplying hardware was left unchanged.  Reliability was enhanced by
building these four circuit boards using MultiWire technology (a form of
printed-wiring circuit board).
 
So, for several years we had five machines running.  In 1991 the original
wire-wrapped 8080-based machine started becoming unreliable (many of the
sockets and integrated-circuit leads had oxidized to the point where the
tin was jet black) and we decided to scrap it.
 
By the end of 1991 it was clear that advances in computer technology were
catching up with us.  Our machines are still respectably fast, but a
$3,000 thirty-three megaHertz Intel 486 computer can multiply two 1,000-
digit numbers in fifteen milliseconds.
 
Fifteen milliseconds is only about eight times slower than our current
special hardware.  Fifty megaHertz 486 computers are available now; the
word is that the Intel 586 is already running and is going to be about
four times faster than the 486.  (Although with a basic system clock speed
of sixty megaHertz, don't expect the 586-based machines to be especially
cheap.)
 
These advances indicate that shortly our hardware-based speed advantage is
going to evaporate.  Honor demands that we do something to radically speed
up our special hardware!  Happily, we believe that we know how to do it.
 
 
Summary of Our Efforts
 
Here is a tabular listing of our efforts compared to a thirty-three
megaHertz 486 (vintage 1991), which can multiply two 1,000-digit numbers
in fifteen milliseconds.
 
1980 -- 8080; pure software; BCD   300 seconds      20,000 times slower.
 
1981 -- 8080; pure software; binary 43 seconds       2,900 times slower.
 
1982 -- 8080 + RCA MDUs              4 seconds       2,700 times slower.
 
1983 -- 8080 + 2901 + MPY16          0.060 seconds        4 times slower.
 
1984 -- Magic Multiplier             0.0019 seconds      8 times faster.
 
In 1988 we built four improved-reliability Magic Multipliers, but each
still runs at the same speed as the original 1984 version.
 
The speed of personal computers has been doubling about every eighteen
months.  If we want to maintain our advantage for more than another few
years, it is time to go to the next generation of hardware.
 
Brief Overview of the Proposed New Hardware
 
The critical element in building a new high-speed multiplying circuit is
the LSI Logic L64240 Multi-Bit Filter.  This is a versatile device that
contains 64 eight-bit multipliers.  It can be configured in a number of
different ways.  We will be using it as a 64-tap Finite-Impulse-Response
filter with eight-bit coefficients.  The part internally carries partial
results with sufficient accuracy that no overflow can take place, no
matter what combination of data and coefficients are used.
 
The clock frequency of the chip can be as high as twenty megaHertz.  Since
there are 64 multipliers in there, the part can do 1.28 billion eight-bit
multiplications per second.  We are delighted to report that we can take
advantage of all that computational power and apply it to the problem of
multiplying large numbers.
 
Mathematically, a FIR filter performs a convolution of two data streams.
Likewise, it turns out that the schoolboy algorithm for multiplying two
numbers is also a convolution.  Consequently, we can use the LSI Logic
chip to multiply two numbers.  The wonderful thing is the size of the
numbers involved, and the speed with which the convolution takes place.
 
The 64 eight-bit coefficients of the FIR filter can be regarded as a
single 512-bit number.  A second binary number can be broken up into
eight-bit pieces and passed through the filter.  On each clock cycle, a
value will appear on the output lines of the filter.  This number can have
a magnitude as large as twenty-two bits, since it is the sum of 64
sixteen-bit numbers.
 
On each clock cycle we take the previous result, right-shift it eight
bits, and add it to the current result.  The bottom eight bits of the sum
is stored in memory.  When you finish passing the second number through
the filter, you'll find that the final result stored in memory is the
binary product of that number, and the 512-bit number that was loaded into
the filter's coefficients.
 
To implement an N-digit multiply, we need to change the loop slightly.
Instead of simply storing a result into memory, we need to accumulate the
eight-bit result into memory.
 
To calculate the time required to multiply two 1,000-digit numbers, we
observe that 1,000 decimal digits requires 416 bytes of storage.  We will
chop the multiplier into seven 64-byte pieces, each of which will be
loaded in turn into the coefficients of the FIR chip.  Each pass of the
1,000-digit multiplicand will need 416 + 64 clock cycles for all of the
data to get into the chip, and for all of the result to be clocked out of
the chip.  At twenty megaHertz, each pass will take twenty-four
microseconds.  Seven passes will take 168 microseconds.
 
That number is an unattainable best case.  On each of the seven passes the
driving computer will have to load some hardware registers, and the
coefficients will need to be loaded into the FIR chip.  We estimate that
the overhead for loading the coefficients and then starting the multiply
process will be about 13.2 microseconds on a 486/33, and about 30
microseconds on a 386/20.
 
Assuming those numbers, the total time for squaring a 1,000-digit number
becomes
 
      486/33:    260 microseconds
      386/20:    378 microseconds
 
The 486 with the new hardware will be seven times faster than our current
hardware, and seventy times faster than a 486/33 computer without the new
hardware.  That speed is only about a factor of two or three slower than
a modern supercomputer performing that same multiply.
 
 
General Description of the Hardware Architecture
 
A block diagram of the hardware of the PC Cruncher is very simple.  There
is a block of memory on the left, the convoluter/accumulator in the
middle, and another memory block on the right.  In addition to those
elements, there is dedicated control and address generation logic which
gives the hardware the ability to perform a variety of functions:
 
   .  Move data between the PC host and the two memories.  Because of the
      limitations of the industry-standard ISA bus, those moves will be
      limited to about three or four megabytes per second.
 
      (That limitation is why we are equipping the board with 256K of
      memory.  Operands and intermediate values will be kept on the board,
      and only transferred between the host and the board when absolutely
      necessary, typically for input/output purposes.)
 
   .  Move data in either direction between the two memories at twenty
      megabytes per second.
 
   .  Zero out locations in the right memory at twenty megabytes per
      second.
 
   .  Load coefficients from the left memory into the convoluter at twenty
      megabytes per second -- a coefficient load will take about 3.4
      microseconds.
 
   .  Pass data from the left memory through the convoluter and do one of
      three things with it:
 
      1)   do a straight store into the right memory;
 
      2)   accumulate the convoluted product into the right memory (for
           doing addition and multiplication);
 
      3)   subtract the convoluted product from the right memory (for
           doing subtraction and division).
 
 
Some Additional Computation Time Estimates
 
Until we can actually test a finished circuit board with real software, it
is difficult to say with precision exactly what the processing time will
be.  As has been noted, there will also be system-based variables that
will vary from one computer to another.
 
We can, however, try to take everything we can think of into account, and
come up with some worst-case estimates.
 
The following tables are as conservative as we reasonably can be.
 
The multiply times are based on the times needed to clear the product
accumulation memory, do the actual multiplication, and to move the result
back from the right-side memory to the left-side memory.
 
The prime-test times are based on the execution times necessary to perform
the 3**N mod N Fermat test.  These times assume that an N-digit number is
squared once for every bit of an N-digit number; that a multiply by 3 gets
done half that many times, and that a 'mod N' division gets executed for
every bit; and that a divide takes twenty percent longer than a multiply.
 
Two sets of numbers are given: one using estimated overhead of a 486/33;
the other using a 386/20.
 
 Execution times for a 486/33        Execution times for a 386/20
 
 Digits   Multiply  PrimeTest        Digits   Multiply  PrimeTest
           (fSec)   (Sec)                      (fSec)   (Sec)
 
   100       36     0.027              100       66     0.049
   200       64     0.095              200      109     0.161
   300       75     0.167              300      120     0.266
   400      110     0.328              400      170     0.503
   500      150     0.556              500      225     0.830
   600      164     0.733              600      239     1.062
   700      210     1.093              700      300     1.553
   800      260     1.544              800      365     2.158
   900      279     1.863              900      384     2.554
 
  1000      335     2.484             1000      455     3.361
  2000      893    13.188             2000     1103    16.257
  3000     1779    39.307             3000     2094    46.213
  4000     2855    84.020             4000     3260    95.859
  5000     4302   158.051             5000     4812   176.686
  6000     5897   259.838             6000     6497   286.147
  7000     7904   406.058             7000     8609   442.124
  8000    10019   587.983             8000    10814   634.463
  9000    12587   830.670             9000    13487   889.866
 10000    15220  1115.797            10000    16210  1188.148
 
 
These time estimates are pessimistic worst-case values.  They assume that
a high-level language routine calls a low-level assembly language routine
every time the new hardware needs to do something.  In practice, this
won't occur -- the entire multiply function, for example, will be
implemented in low-level assembly language, making the multiply routine
somewhat faster.
 
The 'Prime Test' times in turn use the worst-case multiply times.  The
worst-case multiply assumes that the product needs to be moved from the
right-side back to the left-side -- in an (3**N mod N) test, that won't be
true.  In the 1,000-digit range, that move accounts for about 10 to 20
percent of the total execution time -- in a low-level, assembly-coded
(3**N mod N) test, we'll get all of that time back.
 
In short, we expect the actual performance of the board to be at least
several percent better than these worst-case estimates.
 
 
Cost Estimates
 
That's the good news.  Let's look at the damage.
 
Rough estimate for a circuit board and components:
 
      $100  --  The printed circuit board itself.
        50  --  64K of 35ns RAM for the multiplicand memory.
        90  --  64K of 15ns RAM for the product memory.
        60  --  Buffers, counters, drivers, decoders, adders, and what-
have-you.
       800  --  The 64-tap convoluter.
 
That adds up to $1,100 in parts for an add-in circuit board that will
boost an IBM PC/AT into supercomputer territory.
 
Can We Go Faster?
 
On an ordinary IBM PC/AT platform, we are very definitely battling the
limits of the CPU chips and especially the ISA bus.  If we start talking
about using the much higher speed EISA bus, particularly with a 486/33 or
486/50 processor, or perhaps even moving to a Sun workstation platform,
then it makes sense to talk about an even faster implementation.
 
The LSI Logic Multi-Bit FIR chips are designed for easy cascade expansion.
For example, the current design could be expanded by simply adding a
second FIR chip in series with the first.  There would be some minor
overhead associated with the second chip (128 coefficients would need to
be loaded, rather than 64, plus some other minor effects) but in general,
the circuit would run twice as fast.  Total parts cost would be around
$2,000.
 
The two-FIR chip solution would be a crowded IBM PC/AT circuit board, but
it probably could be done.
 
If somebody out there is really hungry for speed, well, we have not yet
exhausted the possibilities.
 
The chip can also be configured as a 32-tap FIR filter that has eight bits
of data and 16-bit coefficients.  Two FIR chips, operating in parallel on
a sixteen-bit data stream, can thus act as a 32-tap FIR filter with 16-bit
data and 16-bit coefficients.  Cascade a second pair of FIR chips in
parallel, and you have a 64-tap FIR filter with 16-bits of data and
coefficient.
 
Even with overhead, such a device could square a 1000-digit number in
about 120 microseconds.  Testing a 1000-digit number for primality would
take well under a second.  It would be somewhat faster than a four-
processor Cray XMP.  The parts cost would be about $4,500.
 
 
Summary
 
Advances in number theory tend to move hand-in-hand with advances in
computer technology.  Much worthwhile research has undoubtedly languished
because of lack of access to the most powerful (and therefore, most
expensive) computers.  We propose to design an add-in board for IBM PC/AT
compatible computers that will make it possible for researchers interested
in operating on large numbers to have the power of a modern supercomputer
-- twenty-four hours a day -- very inexpensively.
 
 
 
 
                        TECHNICAL SPECIFICATIONS
 
                        Dubner PC Cruncher Board
 
                              May 31, 1992
 
GENERAL DESCRIPTION
 
The PC Cruncher Board is a printed circuit board which plugs into a 16-bit
expansion slot of an IBM PC/AT or compatible computer.  The Cruncher
Board, in combination with supplied software, provides extremely rapid
computation capability on the kinds of large numbers often found in number
theory research.
 
For example, on a 486/33, multiplying two 1000-digit numbers in pure
software requires about 15 milliseconds.  The same computer with the PC
Cruncher board installed does the same calculation in about 360
microseconds -- a factor of 40 faster.  With larger numbers the PC
Cruncher Board becomes even more efficient:  The time to multiply two
10,000-digit numbers in software is about 1.5 seconds.  The PC Cruncher
board does the same calculation in about 15 milliseconds -- over 100 times
faster.
 
The Cruncher performance gain is even more dramatic when installed in a
386/20.  When multiplying 10,000-numbers the gain is over 350 times.  This
illustrates the fact that for large numbers, performance is primarily
dependent on the Cruncher characteristics and is almost independent of the
host computer.  The Cruncher is presently recommended for use in 386 and
486 computers.  Although the hardware will work on a 286, software
modifications are required which will not be available for some time.
 
 
PHYSICAL AND ELECTRONIC INTERFACE REQUIREMENTS
 
The PC Cruncher Board conforms with the physical and electronic
requirements of the Personal Computer Bus Standard P996.  In other words,
it will plug into a 16-bit slot in any ordinary IBM PC/AT or compatible.
It is a full-size board and occupies an entire 12.425-inch slot.  The
board dissipates about 5 Watts, and has no special cooling requirements.
 
Interface to the host is via a block of I/O strobes.  A DIP switch on the
board allows those I/O strobes to start at 0x280, 0x290, 0x2A0, 0x2B0,
0x2C0, 0x2D0, 0x2E0, or 0x2F0.
 
 
BASIC IMPLEMENTATION
 
The Cruncher Board is designed around a 64-tap Finite Impulse Response
(FIR) filter chip available from LSI Logic.  The board has 256K of operand
storage, and 64K of subproduct storage.  Eight-bit data can be taken out
of operand storage, passed through the FIR chip, and stored into the
subproduct storage at the rate of twenty megabytes per second.  Some
additional hardware allows the FIR output to be either stored directly to,
added to, or subtracted from, the subproduct storage.
 
Specifically, the hardware is capable of the following operations (all at
twenty megabytes per second.)
 
       *    Zero out subproduct memory.
       *    Move from subproduct memory to operand memory.
       *    Load coefficients from operand memory into the FIR chip.
       *    Pass data from operand memory through the FIR chip and store
              directly into the subproduct memory.
       *    Pass data through the FIR chip and accumulate into subproduct
              memory.
       *    Pass data through the FIR and subtract from subproduct memory.
 
 
SOFTWARE
 
The PC Cruncher Board will be supplied with complete source-level code,
written primarily in ANSI-compatible C and Microsoft MASM 5.1 assembly
language.  In general, we believe that the code will be most effective
when incorporated directly into the user's software.  The following basic
C-functions will be supplied, which include assembler code to attain
highly optimized performance.
 
Variables ending in v such as av, bv, are very large integers which are on
the Cruncher board.  The maximum length of each is defined by software,
with its actual size being dynamic.  The Cruncher can multiply any two
numbers whose product is less than 155,000 digits.  Similarly, it can
divide any number with less than 155,000 digits into any number with less
than 155,000 digits, giving an appropriate quotient and remainder.
 
hadd(av,bv,cv);    av = bv + cv.
hsub(av,bv,cv);    av = bv - cv.
hcomp(bv,cv);      compares bv and cv (bv-cv); returns -1, 0, or +1.
hmult(av,bv,cv);   av = bv * cv.
hdiv(av,bv,cv);    av = bv \ cv, the integer quotient.  Remainder in bv.
hmod(av,bv,cv);    av = bv * cv (mod av).
hmove(av,bv);      move bv into av.
hpower(av,bv,cv);  av = bv^cv.
hpowerm(av,bv,cv); av = bv^cv (mod av).
hdisp(av);         display av on the monitor (abbreviated to one line).
hdispa(av);        display all digits of av.
hsetval(xyz,av);   av = xyz , xyz a standard host integer.
hgetval(xyz,av);   xyz = av , xyz a standard host integer.
hsqrt(av,bv);      av = square root of bv.
 
There are many other functions that will be made available that are
essentially application programs written in C using the above functions.
 
We recommend a 32-bit C compiler, and that the host computer run in
protected mode.  The host can run in non-protect mode but this will
significantly affect performance for small numbers (i.e. less than 500
digits) and have some affect on larger numbers.
 


