Here is the output from diff -rc pgp23a pgp26ui...

Remember that PGP escapes lines beginning "-", so you should check and
strip the signature using PGP before feeding the file to patch.

-----BEGIN PGP SIGNED MESSAGE-----

Only in pgp26ui: README.1st
Common subdirectories: pgp23a/contrib and pgp26ui/contrib
Common subdirectories: pgp23a/doc and pgp26ui/doc
diff -rc pgp23a/keys.asc pgp26ui/keys.asc
*** pgp23a/keys.asc	Fri Jul  2 19:21:10 1993
- --- pgp26ui/keys.asc	Fri May 27 12:54:32 1994
***************
*** 93,95 ****
- --- 93,134 ----
  rvtJdzWLGIa3gzlUmiCTgyhJnZx3zkn7LggByUPE6YXWJ9Sd
  =Qzpg
  -----END PGP PUBLIC KEY BLOCK-----
+ 
+ -----BEGIN PGP PUBLIC KEY BLOCK-----
+ Version: 2.3a
+ 
+ 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
+ =CXlb
+ -----END PGP PUBLIC KEY BLOCK-----
Common subdirectories: pgp23a/src and pgp26ui/src
Common subdirectories: pgp23a/contrib/elm_nn and pgp26ui/contrib/elm_nn
Common subdirectories: pgp23a/contrib/emacs and pgp26ui/contrib/emacs
Common subdirectories: pgp23a/contrib/idea and pgp26ui/contrib/idea
Common subdirectories: pgp23a/contrib/mail_tin and pgp26ui/contrib/mail_tin
Common subdirectories: pgp23a/contrib/mailx and pgp26ui/contrib/mailx
Common subdirectories: pgp23a/contrib/md5sum and pgp26ui/contrib/md5sum
Common subdirectories: pgp23a/contrib/mh and pgp26ui/contrib/mh
Common subdirectories: pgp23a/contrib/mime and pgp26ui/contrib/mime
Common subdirectories: pgp23a/contrib/misc and pgp26ui/contrib/misc
Common subdirectories: pgp23a/contrib/vi and pgp26ui/contrib/vi
Only in pgp26ui/contrib/md5sum: pgp26ui.md5
diff -rc pgp23a/src/armor.c pgp26ui/src/armor.c
*** pgp23a/src/armor.c	Fri Jul  2 18:32:38 1993
- --- pgp26ui/src/armor.c	Thu May 26 12:17:52 1994
***************
*** 508,514 ****
  	else
  		fprintf (outFile, "-----BEGIN PGP MESSAGE, PART %02d/%02d-----\n",
  					1, noSections);
! 	fprintf (outFile, "Version: %s\n",rel_version);
  	fprintf (outFile, "\n");
  
  	init_crc();
- --- 508,514 ----
  	else
  		fprintf (outFile, "-----BEGIN PGP MESSAGE, PART %02d/%02d-----\n",
  					1, noSections);
! 	fprintf (outFile, "Version: %s\n", armor_version);
  	fprintf (outFile, "\n");
  
  	init_crc();
diff -rc pgp23a/src/config.c pgp26ui/src/config.c
*** pgp23a/src/config.c	Sun Jun 13 20:44:58 1993
- --- pgp26ui/src/config.c	Wed May 25 18:58:37 1994
***************
*** 84,90 ****
  	MYNAME, TEXTMODE, TMP, TZFIX, VERBOSE, BAKRING,
  	ARMORLINES, COMPLETES_NEEDED, MARGINALS_NEEDED, PAGER,
  	CERT_DEPTH, CHARSET, CLEAR, SELF_ENCRYPT,
! 	INTERACTIVE, PKCS_COMPAT,
  	/* options below this line can only be used as command line
  	 * "long" options */
  #define CONFIG_INTRINSICS	BATCHMODE
- --- 84,90 ----
  	MYNAME, TEXTMODE, TMP, TZFIX, VERBOSE, BAKRING,
  	ARMORLINES, COMPLETES_NEEDED, MARGINALS_NEEDED, PAGER,
  	CERT_DEPTH, CHARSET, CLEAR, SELF_ENCRYPT,
! 	INTERACTIVE, PKCS_COMPAT, ARMOR_VERSION, VERSION_BYTE,
  	/* options below this line can only be used as command line
  	 * "long" options */
  #define CONFIG_INTRINSICS	BATCHMODE
***************
*** 96,102 ****
  	"MYNAME", "TEXTMODE", "TMP", "TZFIX", "VERBOSE", "BAKRING",
  	"ARMORLINES", "COMPLETES_NEEDED", "MARGINALS_NEEDED", "PAGER",
  	"CERT_DEPTH", "CHARSET", "CLEARSIG", "ENCRYPTTOSELF", 
! 	"INTERACTIVE", "PKCS_COMPAT",
  	/* command line only */
  	"BATCHMODE", "FORCE",
  };
- --- 96,102 ----
  	"MYNAME", "TEXTMODE", "TMP", "TZFIX", "VERBOSE", "BAKRING",
  	"ARMORLINES", "COMPLETES_NEEDED", "MARGINALS_NEEDED", "PAGER",
  	"CERT_DEPTH", "CHARSET", "CLEARSIG", "ENCRYPTTOSELF", 
! 	"INTERACTIVE", "PKCS_COMPAT", "ARMOR_VERSION", "VERSION_BYTE",
  	/* command line only */
  	"BATCHMODE", "FORCE",
  };
***************
*** 106,112 ****
  	STRING, BOOL, STRING, NUMERIC, NUMERIC, STRING,
  	NUMERIC, NUMERIC, NUMERIC, STRING,
  	NUMERIC, STRING, BOOL, BOOL,
! 	BOOL, NUMERIC,
  	/* command line only */
  	BOOL, BOOL,
  };
- --- 106,112 ----
  	STRING, BOOL, STRING, NUMERIC, NUMERIC, STRING,
  	NUMERIC, NUMERIC, NUMERIC, STRING,
  	NUMERIC, STRING, BOOL, BOOL,
! 	BOOL, NUMERIC, STRING, NUMERIC,
  	/* command line only */
  	BOOL, BOOL,
  };
***************
*** 392,397 ****
- --- 392,411 ----
  				
  			case INTERACTIVE:
  				interactive_add = flag;
+ 				break;
+ 
+ 			case ARMOR_VERSION:
+ 				strncpy(armor_version, str,
+ 					MAX_VERSION_LENGTH);
+ 				armor_version[MAX_VERSION_LENGTH-1] = '\0';
+ 				break;
+ 
+ 			case VERSION_BYTE:
+ 				version_byte = value;
+ 				if (version_byte < VERSION_BYTE_MIN)
+ 					version_byte = VERSION_BYTE_MIN;
+ 				if (version_byte > VERSION_BYTE_MAX)
+ 					version_byte = VERSION_BYTE_MAX;
  				break;
  				
  			case BATCHMODE: batchmode = flag; break;
diff -rc pgp23a/src/crypto.c pgp26ui/src/crypto.c
*** pgp23a/src/crypto.c	Fri Jul  2 17:55:08 1993
- --- pgp26ui/src/crypto.c	Fri May 27 12:01:10 1994
***************
*** 30,35 ****
- --- 30,39 ----
  
  	Modified  6-May-93 Colin Plumb
  	Changed to use the entry points in rsaglue.c.
+ 
+ 	Modified 25-May-94 mathew
+ 	Accepts range of version bytes rather than single value, for
+ 	compatibility with MIT PGP 2.6 release..
  */
  
  #include <ctype.h>
***************
*** 59,64 ****
- --- 63,69 ----
  
  #define	USE_LITERAL2
  
+ int version_byte = VERSION_BYTE_DEFAULT;	/* PGP packet format version */
  
  /* This variable stores the md5 hash of the current file, if it is
     available.  It is used in open_strong_pseudorandom. */
***************
*** 313,319 ****
   */
  int
  version_error(int val, int checkval)
! {	if (val != checkval)
  	{	fprintf (pgpout, PSTR(
  "\n\007Unsupported packet format - you need a newer version of PGP for this file.\n"));
  		return(1);
- --- 318,332 ----
   */
  int
  version_error(int val, int checkval)
! {	return version_range_error(val, checkval, checkval);
! }
! 
! /* Return nonzero if val isn't in range from minval to maxval, after
!  * printing a warning.
!  */
! int
! version_range_error(int val, int minval, int maxval)
! {	if (val < minval || val > maxval)
  	{	fprintf (pgpout, PSTR(
  "\n\007Unsupported packet format - you need a newer version of PGP for this file.\n"));
  		return(1);
***************
*** 445,451 ****
  	return RANDSEED_SIZE;
  }
  
! static int make_random_ideakey(byte key[IDEAKEYSIZE+RAND_PREFIX_LENGTH])
  /*	Make a random IDEA key.  Returns its length (the constant 16).
  	It also generates a random IV, which is placed in the key array
  	after the key proper, but is not counted in the length.
- --- 458,464 ----
  	return RANDSEED_SIZE;
  }
  
! int make_random_ideakey(byte key[IDEAKEYSIZE+RAND_PREFIX_LENGTH])
  /*	Make a random IDEA key.  Returns its length (the constant 16).
  	It also generates a random IV, which is placed in the key array
  	after the key proper, but is not counted in the length.
***************
*** 786,792 ****
  	put_word16((word16) ske_length, certificate+certificate_length);
  	certificate_length+=2;	/* advance past word */
  
! 	certificate[certificate_length++] = VERSION_BYTE;
  
  	/* Begin fields that are included in MD calculation... */
  
- --- 799,805 ----
  	put_word16((word16) ske_length, certificate+certificate_length);
  	certificate_length+=2;	/* advance past word */
  
! 	certificate[certificate_length++] = version_byte;
  
  	/* Begin fields that are included in MD calculation... */
  
***************
*** 1367,1373 ****
  		goto badcert;	/* complain and return bad status */
  
  	version = *certificate++;
! 	if (version_error(version, VERSION_BYTE))
  		goto err1;
  
  	mdlensave = mdlen = *certificate++;	/* length of material to be added to MD */
- --- 1380,1386 ----
  		goto badcert;	/* complain and return bad status */
  
  	version = *certificate++;
! 	if (version_range_error(version, VERSION_BYTE_MIN, VERSION_BYTE_MAX))
  		goto err1;
  
  	mdlensave = mdlen = *certificate++;	/* length of material to be added to MD */
***************
*** 1807,1813 ****
  		goto badcert2;	/* complain and return bad status */
  
  	version = *certificate++;
! 	if (version_error(version, VERSION_BYTE))
  		goto err2;
  
  	mdlensave = mdlen = *certificate++;	/* length of material to be added to MD */
- --- 1820,1826 ----
  		goto badcert2;	/* complain and return bad status */
  
  	version = *certificate++;
! 	if (version_range_error(version, VERSION_BYTE_MIN, VERSION_BYTE_MAX))
  		goto err2;
  
  	mdlensave = mdlen = *certificate++;	/* length of material to be added to MD */
***************
*** 2361,2367 ****
  			       FALSE);
  		
  		/* Write version byte */
! 		ver = VERSION_BYTE;
  		fwrite (&ver, 1, 1, g);
  		
  		writekeyID( n, g );	
- --- 2374,2380 ----
  			       FALSE);
  		
  		/* Write version byte */
! 		ver = version_byte;
  		fwrite (&ver, 1, 1, g);
  		
  		writekeyID( n, g );	
***************
*** 2745,2751 ****
  
  		/* Read and check version */
  		fread (&ver, 1, 1, f);
! 		if (version_error(ver, VERSION_BYTE))
  			{	fclose (f);
  				return (-1);
  			}
- --- 2758,2765 ----
  
  		/* Read and check version */
  		fread (&ver, 1, 1, f);
! 		if (version_range_error(ver, VERSION_BYTE_MIN,
! 					VERSION_BYTE_MAX))
  			{	fclose (f);
  				return (-1);
  			}
diff -rc pgp23a/src/crypto.h pgp26ui/src/crypto.h
*** pgp23a/src/crypto.h	Sun May  9 19:38:28 1993
- --- pgp26ui/src/crypto.h	Fri May 27 11:59:07 1994
***************
*** 57,62 ****
- --- 57,65 ----
  /* Creates a randseed.bin file (call if above returns false) */
  void create_seedfile(void);
  
+ /* Make a random IDEA key.  Returns its length (the constant 16). */
+ int make_random_ideakey(byte *key);
+ 
  /*	Return date string, given pointer to 32-bit timestamp */
  char *cdate(word32 *tstamp);
  
***************
*** 74,79 ****
- --- 77,85 ----
  
  /* Print an error message and return nonzero if val != checkval */
  int version_error (int val, int checkval);
+ 
+ /* Print an error message and return nonzero if val not in [minval..maxval] */
+ int version_range_error (int val, int minval, int maxval);
  
  int check_key_sig(FILE *fkey, long fpkey, int keypktlen, char *keyuserid,
  	 FILE *fsig, long fpsig, char *keyfile, char *siguserid, byte *xtimestamp,
diff -rc pgp23a/src/fileio.c pgp26ui/src/fileio.c
*** pgp23a/src/fileio.c	Sun May  9 19:38:28 1993
- --- pgp26ui/src/fileio.c	Fri May 27 12:03:45 1994
***************
*** 22,27 ****
- --- 22,30 ----
  
  	Modified 17 Nov 92 - HAJK
  	Change to temp file stuff for VMS.
+ 
+ 	Modified 17 Nov 92 - apb
+ 	Wipe file with random data.
  */
  
  #include <ctype.h>
***************
*** 98,103 ****
- --- 101,146 ----
  #endif
  }
  
+ static void init_buffrand(void)
+ {	/*	Initialise for future calls to buffrand().
+ 		This random number generator is intended to be used
+ 		to provide data to overwrite a disk file.  It does
+ 		not have to be cryptographically strong, but should
+ 		generate data that is unlikely to be easily compressible.
+ 		If a file is overwritten with compressible data, a
+ 		compressing file system is likely to leave some of the
+ 		original data intact.  Overwriting a file with random
+ 		data does not guarantee that the original data will be
+ 		destroyed, but is better than overwriting the file
+ 		with zeros.
+ 	*/
+ 
+ 	byte ideakey[24]; /* must be big enough for make_random_ideakey */
+ 
+ 	/* We don't want the ideakey itself here, we just want the side
+ 	   effect of initialising lots of stuff so that buffrand()
+ 	   can later call idearand(). */
+ 	(void) make_random_ideakey(ideakey);
+ 	burn(ideakey);
+ }
+ 
+ static void buffrand(char *buf, int n)
+ {	/*	Fill a buffer with random data.  See open_buffrand()
+ 		and close_buffrand().
+ 	*/
+ 
+ 	while (n-- > 0) {
+ 		*buf++ = idearand();
+ 	}
+ }
+ 
+ static void close_buffrand(void)
+ {	/*	Finish using buffrand().
+ 	*/
+ 
+ 	close_idearand();
+ }
+ 
  static int wipeout(FILE *f)
  {	/*	Completely overwrite and erase file, so that no sensitive
  		information is left on the disk.
***************
*** 111,119 ****
  	flength = ftell(f);
  	rewind(f);
  
! 	fill0(textbuf, sizeof(textbuf));
  	while (flength > 0L)
! 	{	/* write zeros to the whole file... */
  		if (flength < (word32) DISKBUFSIZE)
  			count = (int)flength;
  		else
- --- 154,163 ----
  	flength = ftell(f);
  	rewind(f);
  
! 	init_buffrand();
  	while (flength > 0L)
! 	{	/* write random data to the whole file... */
! 		buffrand(textbuf, DISKBUFSIZE);
  		if (flength < (word32) DISKBUFSIZE)
  			count = (int)flength;
  		else
***************
*** 121,126 ****
- --- 165,172 ----
  		fwrite(textbuf,1,count,f);
  		flength -= count;
  	}
+ 	close_buffrand();
+ 	burn(textbuf);
  	rewind(f);	/* maybe this isn't necessary */
  	return(0);	/* normal return */
  }	/* wipeout */
Only in pgp23a/src: idea68k.s
diff -rc pgp23a/src/keyadd.c pgp26ui/src/keyadd.c
*** pgp23a/src/keyadd.c	Wed Jun 23 16:53:10 1993
- --- pgp26ui/src/keyadd.c	Fri May 27 11:54:20 1994
***************
*** 29,34 ****
- --- 29,35 ----
  #include "fileio.h"
  #include "keymgmt.h"
  #include "charset.h"
+ #include "mpiio.h"
  #include "language.h"
  #include "pgp.h"
  #include "exitpgp.h"
***************
*** 48,55 ****
  static int newkeys, newsigs, newids, newrvks;
  static byte mykeyID[KEYFRAGSIZE];
  
  static int mergesigs (FILE *fkey, char *keyfile, long keypos, FILE *fring,
! 		char *ringfile, long *pringpos, FILE *out)
  /* Merge signatures from userid in fkey (which is keyfile) at keypos with
   * userid from fring (which is ringfile) at ringpos, appending result to out.
   */
- --- 49,95 ----
  static int newkeys, newsigs, newids, newrvks;
  static byte mykeyID[KEYFRAGSIZE];
  
+ 
+ static struct sig_list {
+ 	struct sig_list *next;
+ 	long pos;
+ } *siglist;
+ 
+ static void
+ sig_list_add(long pos)
+ {
+ 	struct sig_list *p;
+ 	p = xmalloc(sizeof *p);
+ 	p->pos = pos;
+ 	p->next = siglist;
+ 	siglist = p;
+ }
+ 
+ static int
+ sig_list_find(long pos)
+ {
+ 	struct sig_list *p;
+ 	for (p = siglist; p; p = p->next)
+ 		if (p->pos == pos)
+ 			return 1;
+ 	return 0;
+ }
+ 
+ static void
+ sig_list_clear(void)
+ {
+ 	struct sig_list *p, *n;
+ 	for (p = siglist; p; p = n) {
+ 		n = p->next;
+ 		free(p);
+ 	}
+ 	siglist = NULL;
+ }
+ 
+ 
  static int mergesigs (FILE *fkey, char *keyfile, long keypos, FILE *fring,
! 		char *ringfile, long *pringpos, long ringkeypos,
! 		long ringkeypktlen, FILE *out)
  /* Merge signatures from userid in fkey (which is keyfile) at keypos with
   * userid from fring (which is ringfile) at ringpos, appending result to out.
   */
***************
*** 59,66 ****
- --- 99,108 ----
  	int status;
  	byte ctb;
  	int copying;
+ 	word32 rstamp, kstamp;
  	byte keyID[KEYFRAGSIZE];
  	char userid[256];
+ 	char sigid[256];
  
  	/* First, copy the userid packet itself, plus any comments or ctrls */
  	ringuseridpos = ringpos = *pringpos;
***************
*** 100,111 ****
  	copying = FALSE;
  	for ( ; ; )
  	{	/* Read next sig from keyfile; see if it is in ringfile;
! 		 * set copying true/false accordingly.  If copying is true
! 		 * and it is a signature, copy it.  Loop till hit
! 		 * a new key or userid in keyfile, or EOF.
  		 */
  		keypos = ftell(fkey);
! 		status = readkeypacket(fkey,FALSE,&ctb,NULL,NULL,NULL,NULL,
  				NULL,NULL,NULL,NULL,keyID,NULL);
  		if (status == -3)	/* unrecoverable error: bad packet length etc. */
  			return(status);
- --- 142,155 ----
  	copying = FALSE;
  	for ( ; ; )
  	{	/* Read next sig from keyfile; see if it is in ringfile;
! 		 * if it is not a signature, ignore it,
! 		 * if it is absent from ringfile, copy it,
! 		 * if it is present, and the timestamp is not newer, ignore it,
! 		 * if present and newer, replace old with new.
! 		 * Loop till hit a new key or userid in keyfile, or EOF.
  		 */
  		keypos = ftell(fkey);
! 		status = readkeypacket(fkey,FALSE,&ctb,(byte *)&kstamp,NULL,NULL,NULL,
  				NULL,NULL,NULL,NULL,keyID,NULL);
  		if (status == -3)	/* unrecoverable error: bad packet length etc. */
  			return(status);
***************
*** 118,126 ****
  		{	long sig_pos;
  			int sig_len;
  			/* Set copying true if signature is not in the ringfile */
! 			copying = (getpubusersig (ringfile, ringuseridpos, keyID, &sig_pos,
! 						&sig_len) < 0);
! 			if (copying)
  			{	char *signator;
  				if ((signator = user_from_keyID(keyID)) == NULL)
  					fprintf(pgpout, PSTR("New signature from keyID %s on userid \"%s\"\n"), 
- --- 162,225 ----
  		{	long sig_pos;
  			int sig_len;
  			/* Set copying true if signature is not in the ringfile */
! 			copying = (getpubusersig (ringfile, ringuseridpos, keyID,
! 					(byte *)&rstamp, &sig_pos, &sig_len) < 0);
! 			if (!copying) {
! 				long save_pos = ftell(fkey);
! 				fseek(fkey, keypos+6, SEEK_SET);
! 				fread(&kstamp,1,SIZEOF_TIMESTAMP,fkey);
! 				convert_byteorder((byte *)&kstamp,SIZEOF_TIMESTAMP);
! 				if (verbose)
! 					fprintf(pgpout, "ring: %lx  key: %lx\n", rstamp, kstamp);
! 				if (kstamp > rstamp) { /* Update */
! 					byte sig_class = 0xff;
! 					if (verbose)
! 						fprintf(pgpout, "checking new signature\n");
! 					CToPascal(userid);
! 					status = check_key_sig(fring, ringkeypos, ringkeypktlen,
! 							userid, fkey, keypos, ringfile, sigid,
! 							(byte *)&kstamp, &sig_class);
! 					PascalToC(userid);
! 					PascalToC(sigid);
! 					switch (status) {
! 					case 0:		/* signature OK */
! 						switch (sig_class) {
! 						case K0_SIGNATURE_BYTE:
! 						case K1_SIGNATURE_BYTE:
! 						case K2_SIGNATURE_BYTE:
! 						case K3_SIGNATURE_BYTE:
! 							copying = 1;
! 							fprintf(pgpout, PSTR("Replacing signature from %s\n"),
! 									LOCAL_CHARSET(sigid));
! 							break;
! #ifdef notyet
! 						case KR_SIGNATURE_BYTE:
! 							copying = 1;
! 							fprintf(pgpout, PSTR("Signature revocation from %s\n"),
! 									LOCAL_CHARSET(sigid));
! 							break;
! #endif
! 						default:
! 							fprintf(pgpout, PSTR("Unknown signature class %#x from %s\n"),
! 									sig_class, LOCAL_CHARSET(sigid));
! 						}
! 						if (copying)
! 							sig_list_add(sig_pos);
! 						break;
! 					case -2:
! 						fprintf(pgpout, PSTR("\007*** BAD NEW SIGNATURE, class %#x from %s\n"),
! 								sig_class, LOCAL_CHARSET(sigid));
! 						break;
! 					default:
! 						/* don't replace if we can't check the new signature */
! 						fprintf(pgpout, PSTR("Can't check new signature from keyID %s\n"),
! 								keyIDstring(keyID));
! 					}
! 					fprintf(pgpout, PSTR("on userid \"%s\"\n"), LOCAL_CHARSET(userid));
! 				}
! 				fseek(fkey, save_pos, SEEK_SET);
! 			}
! 			else
  			{	char *signator;
  				if ((signator = user_from_keyID(keyID)) == NULL)
  					fprintf(pgpout, PSTR("New signature from keyID %s on userid \"%s\"\n"), 
***************
*** 130,136 ****
  					fprintf(pgpout, PSTR("New signature from %s\n"), LOCAL_CHARSET(signator));
  					fprintf(pgpout, PSTR("on userid \"%s\"\n"), LOCAL_CHARSET(userid));
  				}
! 				++newsigs;
  				if (batchmode)
  					show_update(keyIDstring(mykeyID));
  			}
- --- 229,237 ----
  					fprintf(pgpout, PSTR("New signature from %s\n"), LOCAL_CHARSET(signator));
  					fprintf(pgpout, PSTR("on userid \"%s\"\n"), LOCAL_CHARSET(userid));
  				}
! 			}
! 			if (copying)
! 			{	++newsigs;
  				if (batchmode)
  					show_update(keyIDstring(mykeyID));
  			}
***************
*** 142,151 ****
  		}
  	}
  
! 	/* Third, for all ring sig's, copy to output */
  	fseek (fring, ringpos, SEEK_SET);
  	for ( ; ; )
  	{	ringpos = ftell(fring);
  		status = nextkeypacket (fring, &ctb);
  		ringpktlen = ftell(fring) - ringpos;
  		if (status < 0  ||  is_key_ctb (ctb)  ||  ctb==CTB_USERID)
- --- 243,261 ----
  		}
  	}
  
! 	/* Third, for all ring sig's which are not replaced, copy to output */
  	fseek (fring, ringpos, SEEK_SET);
  	for ( ; ; )
  	{	ringpos = ftell(fring);
+ 		if (sig_list_find(ringpos)) {
+ 			/* skip signature packet */
+ 			nextkeypacket (fring, &ctb);
+ 			ringpos = ftell(fring);
+ 			/* skip trust packet, if present */
+ 			if (nextkeypacket (fring, &ctb) < 0 || ctb != CTB_KEYCTRL)
+ 				fseek(fring, ringpos, SEEK_SET);
+ 			continue;
+ 		}
  		status = nextkeypacket (fring, &ctb);
  		ringpktlen = ftell(fring) - ringpos;
  		if (status < 0  ||  is_key_ctb (ctb)  ||  ctb==CTB_USERID)
***************
*** 152,157 ****
- --- 262,268 ----
  		 	break;
  		copyfilepos (fring, out, ringpktlen, ringpos);
  	}	/* End of loop for each sig in ringfile */
+ 	sig_list_clear();
  	fseek (fring, ringpos, SEEK_SET);
  	*pringpos = ringpos;
  	return(0);
***************
*** 165,171 ****
   */
  {
  	long ringkeypos, keykeypos, ringpos;
! 	int ringpktlen, keypktlen;
  	int status;
  	byte ctb;
  	int copying;
- --- 276,282 ----
   */
  {
  	long ringkeypos, keykeypos, ringpos;
! 	int ringpktlen, keypktlen, ringkeypktlen;
  	int status;
  	byte ctb;
  	int copying;
***************
*** 176,182 ****
  	ringkeypos = ringpos = *pringpos;
  	fseek (fring, ringpos, SEEK_SET);
  	(void) nextkeypacket(fring, &ctb);
! 	ringpktlen = ftell(fring) - ringpos;
  	copyfilepos (fring, out, ringpktlen, ringpos);
  	for ( ; ; )
  	{	ringpos = ftell(fring);
- --- 287,293 ----
  	ringkeypos = ringpos = *pringpos;
  	fseek (fring, ringpos, SEEK_SET);
  	(void) nextkeypacket(fring, &ctb);
! 	ringkeypktlen = ringpktlen = ftell(fring) - ringpos;
  	copyfilepos (fring, out, ringpktlen, ringpos);
  	for ( ; ; )
  	{	ringpos = ftell(fring);
***************
*** 312,318 ****
  			/* don't use substring match (exact_match = TRUE) */
  			if (getpubuserid (keyfile, keykeypos, userid, &userid_pos,
  						&userid_len, TRUE) >= 0)
! 			{	if ((status = mergesigs (fkey,keyfile,userid_pos,fring,ringfile,&ringpos,out)) < 0)
  					return(status);
  				copying = FALSE;
  			}
- --- 423,429 ----
  			/* don't use substring match (exact_match = TRUE) */
  			if (getpubuserid (keyfile, keykeypos, userid, &userid_pos,
  						&userid_len, TRUE) >= 0)
! 			{	if ((status = mergesigs (fkey,keyfile,userid_pos,fring,ringfile,&ringpos,ringkeypos,ringkeypktlen,out)) < 0)
  					return(status);
  				copying = FALSE;
  			}
diff -rc pgp23a/src/keymaint.c pgp26ui/src/keymaint.c
*** pgp23a/src/keymaint.c	Tue May 18 01:15:14 1993
- --- pgp26ui/src/keymaint.c	Thu May 26 12:09:58 1994
***************
*** 423,429 ****
  				break;
  			if (show_user) {
  				if (pk->pk_userids)		/* more than one user ID */
! 					fprintf(pgpout, "        ");
  				fprintf(pgpout, "  %s\n", LOCAL_CHARSET(userid));
  			}
  			if (id)
- --- 423,429 ----
  				break;
  			if (show_user) {
  				if (pk->pk_userids)		/* more than one user ID */
! 					fprintf(pgpout, "          ");
  				fprintf(pgpout, "  %s\n", LOCAL_CHARSET(userid));
  			}
  			if (id)
***************
*** 752,758 ****
  	setkrent(ringfile);
  	init_userhash();
  
! 	fprintf(pgpout, PSTR("  KeyID   Trust      Validity  User ID\n"));
  	while ((status = readkpacket(f, &ctb, userid, keyID, sigkeyID)) != -1) {
  		if (status == -3 || status == -2)
  			break;
- --- 752,758 ----
  	setkrent(ringfile);
  	init_userhash();
  
! 	fprintf(pgpout, PSTR("  KeyID     Trust      Validity  User ID\n"));
  	while ((status = readkpacket(f, &ctb, userid, keyID, sigkeyID)) != -1) {
  		if (status == -3 || status == -2)
  			break;
***************
*** 781,790 ****
  				fprintf(pgpout, "%c %s ", tchar, keyIDstring(keyID));
  				fprintf(pgpout, " %-*s", trustlst_len, trust_lst[owntrust]);
  			} else
! 				fprintf(pgpout, "         %*s ", trustlst_len, "");
  			fprintf(pgpout, " %-*s", legitlst_len, legit_lst[kc&KC_LEGIT_MASK]);
  			if (usercount)
! 				putc(' ', pgpout);
    			++usercount;
  			fprintf(pgpout, "%s\n", LOCAL_CHARSET(userid));
  			break;
- --- 781,790 ----
  				fprintf(pgpout, "%c %s ", tchar, keyIDstring(keyID));
  				fprintf(pgpout, " %-*s", trustlst_len, trust_lst[owntrust]);
  			} else
! 				fprintf(pgpout, "            %*s", trustlst_len, "");
  			fprintf(pgpout, " %-*s", legitlst_len, legit_lst[kc&KC_LEGIT_MASK]);
  			if (usercount)
! 				putc(' ', pgpout); /* XXX why is this here?  */
    			++usercount;
  			fprintf(pgpout, "%s\n", LOCAL_CHARSET(userid));
  			break;
***************
*** 793,799 ****
  				tchar = '#';
  				break;
  			}
! 			fprintf(pgpout, "%c        ", (kc & KC_CONTIG) ? 'c' : ' ');
  			fprintf(pgpout, " %-*s", trustlst_len, trust_lst[TRUST_LEV(kc)]);
  			fprintf(pgpout, "%*s   ", legitlst_len, "");
  			if ((signator = user_from_keyID(sigkeyID)) == NULL)
- --- 793,799 ----
  				tchar = '#';
  				break;
  			}
! 			fprintf(pgpout, "%c          ", (kc & KC_CONTIG) ? 'c' : ' ');
  			fprintf(pgpout, " %-*s", trustlst_len, trust_lst[TRUST_LEV(kc)]);
  			fprintf(pgpout, "%*s   ", legitlst_len, "");
  			if ((signator = user_from_keyID(sigkeyID)) == NULL)
diff -rc pgp23a/src/keymgmt.c pgp26ui/src/keymgmt.c
*** pgp23a/src/keymgmt.c	Wed Jun 23 16:53:54 1993
- --- pgp26ui/src/keymgmt.c	Fri May 27 11:54:21 1994
***************
*** 137,143 ****
  	char		*bufptr;	/* ptr to Key ID string */
  	static char	keyIDbuf[2*KEYFRAGSIZE+1];
  
! 	/*	only show bottom 3 bytes of keyID	*/
  
  	bufptr = keyIDbuf;
  	
- --- 137,143 ----
  	char		*bufptr;	/* ptr to Key ID string */
  	static char	keyIDbuf[2*KEYFRAGSIZE+1];
  
! 	/*	only show bottom 4 bytes of keyID	*/
  
  	bufptr = keyIDbuf;
  	
***************
*** 146,152 ****
  	**	LSB-first keyID format
  	*/
  
! 	for (i = 2; i >= 0; i--)
  		{
  		sprintf( bufptr, "%02X", keyID[i] );
  		bufptr += 2;
- --- 146,152 ----
  	**	LSB-first keyID format
  	*/
  
! 	for (i = 3; i >= 0; i--)
  		{
  		sprintf( bufptr, "%02X", keyID[i] );
  		bufptr += 2;
***************
*** 156,162 ****
  	**	MSB-first keyID format
  	*/
  
! 	for (i = KEYFRAGSIZE-3; i < KEYFRAGSIZE; i++)
  		{
  		sprintf( bufptr, "%02X", keyID[i] );
  		bufptr += 2;
- --- 156,162 ----
  	**	MSB-first keyID format
  	*/
  
! 	for (i = KEYFRAGSIZE-4; i < KEYFRAGSIZE; i++)
  		{
  		sprintf( bufptr, "%02X", keyID[i] );
  		bufptr += 2;
***************
*** 302,308 ****
  	fwrite(&ctb,1,1,f);		/* write key certificate header byte */
  	convert(cert_length);	/* convert to external byteorder */
  	fwrite(&cert_length,1,sizeof(cert_length),f);
! 	version = VERSION_BYTE;
  	fwrite(&version,1,1,f);		/* set version number */
  	convert_byteorder(timestamp,4);	/* convert to external form */
  	fwrite(timestamp,1,4,f); /* write certificate timestamp */
- --- 302,308 ----
  	fwrite(&ctb,1,1,f);		/* write key certificate header byte */
  	convert(cert_length);	/* convert to external byteorder */
  	fwrite(&cert_length,1,sizeof(cert_length),f);
! 	version = version_byte;
  	fwrite(&version,1,1,f);		/* set version number */
  	convert_byteorder(timestamp,4);	/* convert to external form */
  	fwrite(timestamp,1,4,f); /* write certificate timestamp */
***************
*** 467,473 ****
  	else if (is_ctb_type (ctb, CTB_SKE_TYPE))
  	{	if (sigkeyID)
  		{	fread(&version,1,1,f);		/* Read version of sig packet */
! 			if (version_error(version, VERSION_BYTE))
  				SKIP_RETURN(-6);			/* Need a later version */
  			/* Skip timestamp, validity period, and type byte */
  			fread(&mdlen, 1, 1, f);
- --- 467,474 ----
  	else if (is_ctb_type (ctb, CTB_SKE_TYPE))
  	{	if (sigkeyID)
  		{	fread(&version,1,1,f);		/* Read version of sig packet */
! 			if (version_range_error(version, VERSION_BYTE_MIN,
! 						VERSION_BYTE_MAX))
  				SKIP_RETURN(-6);			/* Need a later version */
  			/* Skip timestamp, validity period, and type byte */
  			fread(&mdlen, 1, 1, f);
***************
*** 493,499 ****
  	if (n != NULL)
  		set_precision(MAX_UNIT_PRECISION);	/* safest opening assumption */
  	fread(&version,1,1,f);	/* read and check version */
! 	if (version_error(version, VERSION_BYTE))
  		SKIP_RETURN(-6);			/* Need a later version */
  	if (timestamp)
  	{	fread(timestamp,1,SIZEOF_TIMESTAMP,f);	/* read certificate timestamp */
- --- 494,500 ----
  	if (n != NULL)
  		set_precision(MAX_UNIT_PRECISION);	/* safest opening assumption */
  	fread(&version,1,1,f);	/* read and check version */
! 	if (version_range_error(version, VERSION_BYTE_MIN, VERSION_BYTE_MAX))
  		SKIP_RETURN(-6);			/* Need a later version */
  	if (timestamp)
  	{	fread(timestamp,1,SIZEOF_TIMESTAMP,f);	/* read certificate timestamp */
***************
*** 824,830 ****
  
  
  int getpubusersig(char *keyfile, long user_position, byte *sigkeyID,
! 	long *sig_position, int *sig_len)
  /*  Start at user_position in keyfile, and scan for the signature packet
  	that matches sigkeyID.  Return sig_position and sig_len.
  	Return 0 if OK, -1 on error.
- --- 825,831 ----
  
  
  int getpubusersig(char *keyfile, long user_position, byte *sigkeyID,
! 	byte *timestamp, long *sig_position, int *sig_len)
  /*  Start at user_position in keyfile, and scan for the signature packet
  	that matches sigkeyID.  Return sig_position and sig_len.
  	Return 0 if OK, -1 on error.
***************
*** 857,862 ****
- --- 858,866 ----
  		{	if (equal_buffers(sigkeyID,keyID0,KEYFRAGSIZE))
  			{	*sig_position = fpos;
  				*sig_len = ( int ) ( ftell(f) - fpos );
+ 				fseek(f, fpos+6, SEEK_SET);
+ 				fread(timestamp,1,SIZEOF_TIMESTAMP,f);	/* read certificate timestamp */
+ 				convert_byteorder(timestamp,SIZEOF_TIMESTAMP); /* convert from external form */
  				fclose(f);
  				return(0);	/* normal return */
  			}
***************
*** 1151,1157 ****
  	int i;
  
  /*	Display the hash.  The format is:
! pub  1024/xxxxxx yyyy-mm-dd  aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
            Key fingerprint =  xx xx xx xx xx xx xx xx  xx xx xx xx xx xx xx xx 
  */
  	fprintf( pgpout, "%*s  ", indent ? 27 : 1, PSTR("Key fingerprint =" ) );
- --- 1155,1161 ----
  	int i;
  
  /*	Display the hash.  The format is:
! pub  1024/xxxxxxxx yyyy-mm-dd  aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
            Key fingerprint =  xx xx xx xx xx xx xx xx  xx xx xx xx xx xx xx xx 
  */
  	fprintf( pgpout, "%*s  ", indent ? 27 : 1, PSTR("Key fingerprint =" ) );
***************
*** 1214,1223 ****
  	}
  
  /*	Here's a good format for display of key or signature certificates:
! Type bits/keyID   Date       User ID
! pub  1024/xxxxxx yyyy-mm-dd  aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
! sec   512/xxxxxx yyyy-mm-dd  aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
! sig   384/xxxxxx yyyy-mm-dd  aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
  */
  
  	if (moreflag)
- --- 1218,1227 ----
  	}
  
  /*	Here's a good format for display of key or signature certificates:
! Type bits/keyID     Date       User ID
! pub  1024/xxxxxxxx yyyy-mm-dd  aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
! sec   512/xxxxxxxx yyyy-mm-dd  aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
! sig   384/xxxxxxxx yyyy-mm-dd  aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
  */
  
  	if (moreflag)
***************
*** 1228,1234 ****
  		if (mcguffin && strlen(mcguffin) > 0)
  			fprintf(pgpout,PSTR(", looking for user ID \"%s\"."),LOCAL_CHARSET(mcguffin));
  	}
! 	fprintf(pgpout,PSTR("\nType bits/keyID   Date       User ID\n"));
  	for ( ; ; )
  	{
  		status = readkeypacket(f,FALSE,&ctb,timestamp,(char *)userid,n,e,
- --- 1232,1238 ----
  		if (mcguffin && strlen(mcguffin) > 0)
  			fprintf(pgpout,PSTR(", looking for user ID \"%s\"."),LOCAL_CHARSET(mcguffin));
  	}
! 	fprintf(pgpout,PSTR("\nType bits/keyID     Date       User ID\n"));
  	for ( ; ; )
  	{
  		status = readkeypacket(f,FALSE,&ctb,timestamp,(char *)userid,n,e,
***************
*** 1298,1307 ****
  						countbits(n),keyIDstring(keyID),cdate(&tstamp));
  				}
  				else
! 					fprintf(pgpout,"                             ");
  				if (compromised && firstuser)
  				{	fprintf(pgpout, PSTR("*** KEY REVOKED ***\n"));
! 					fprintf(pgpout,"                             ");
  				}
  				firstuser = 0;
  				fprintf(pgpout,"%s\n",LOCAL_CHARSET((char *)userid));
- --- 1302,1311 ----
  						countbits(n),keyIDstring(keyID),cdate(&tstamp));
  				}
  				else
! 					fprintf(pgpout,"                               ");
  				if (compromised && firstuser)
  				{	fprintf(pgpout, PSTR("*** KEY REVOKED ***\n"));
! 					fprintf(pgpout,"                               ");
  				}
  				firstuser = 0;
  				fprintf(pgpout,"%s\n",LOCAL_CHARSET((char *)userid));
***************
*** 1388,1397 ****
  	}
  
  /*	Here's a good format for display of key or signature certificates:
! Type bits/keyID   Date       User ID
! pub  1024/xxxxxx yyyy-mm-dd  aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
! sec   512/xxxxxx yyyy-mm-dd  aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
! sig   384/xxxxxx yyyy-mm-dd  aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
  */
  
  	if (options & CHECK_NEW)
- --- 1392,1401 ----
  	}
  
  /*	Here's a good format for display of key or signature certificates:
! Type bits/keyID     Date       User ID
! pub  1024/xxxxxxxx yyyy-mm-dd  aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
! sec   512/xxxxxxxx yyyy-mm-dd  aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
! sig   384/xxxxxxxx yyyy-mm-dd  aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
  */
  
  	if (options & CHECK_NEW)
***************
*** 1406,1412 ****
  			if (mcguffin && strlen(mcguffin) > 0)
  				fprintf(pgpout,PSTR(", looking for user ID \"%s\"."),LOCAL_CHARSET(mcguffin));
  		}
! 		fprintf(pgpout,PSTR("\nType bits/keyID   Date       User ID\n"));
  	}
  	for ( ; ; )
  	{	long fpos = ftell(f);
- --- 1410,1416 ----
  			if (mcguffin && strlen(mcguffin) > 0)
  				fprintf(pgpout,PSTR(", looking for user ID \"%s\"."),LOCAL_CHARSET(mcguffin));
  		}
! 		fprintf(pgpout,PSTR("\nType bits/keyID     Date       User ID\n"));
  	}
  	for ( ; ; )
  	{	long fpos = ftell(f);
***************
*** 1495,1504 ****
  						countbits(n),keyIDstring(keyID),cdate(&tstamp));
  				}
  				else
! 					fprintf(pgpout,"                             ");
  				if (compromised && firstuser)
  				{	fprintf(pgpout, PSTR("*** KEY REVOKED ***\n"));
! 					fprintf(pgpout,"                             ");
  				}
  				firstuser = 0;
  				fprintf(pgpout,"%s\n",LOCAL_CHARSET((char *)keyuserid));
- --- 1499,1508 ----
  						countbits(n),keyIDstring(keyID),cdate(&tstamp));
  				}
  				else
! 					fprintf(pgpout,"                               ");
  				if (compromised && firstuser)
  				{	fprintf(pgpout, PSTR("*** KEY REVOKED ***\n"));
! 					fprintf(pgpout,"                               ");
  				}
  				firstuser = 0;
  				fprintf(pgpout,"%s\n",LOCAL_CHARSET((char *)keyuserid));
***************
*** 2495,2500 ****
- --- 2499,2505 ----
  \n	1)	 384 bits- Casual grade, fast but less secure\
  \n	2)	 512 bits- Commercial grade, medium speed, good security\
  \n	3)	1024 bits- Military grade, very slow, highest security\
+ \nNote that MIT PGP 2.6 only handles keys of 504 to 1024 bits.\
  \nChoose 1, 2, or 3, or enter desired number of bits: "));
  		numstr = (char *)userid;	/* use userid buffer as scratchpad */
  		getstring(numstr,5,TRUE);	/* echo keyboard */
diff -rc pgp23a/src/keymgmt.h pgp26ui/src/keymgmt.h
*** pgp23a/src/keymgmt.h	Fri Jun 11 09:57:56 1993
- --- pgp26ui/src/keymgmt.h	Fri May 27 11:54:21 1994
***************
*** 80,86 ****
  	long *userid_position, int *userid_len, boolean exact_match);
  
  int getpubusersig(char *keyfile, long user_position, byte *sigkeyID,
! 	long *sig_position, int *sig_len);
  
  void getKeyHash( byte *hash, unitptr n, unitptr e );
  void printKeyHash( byteptr hash, boolean indent );
- --- 80,86 ----
  	long *userid_position, int *userid_len, boolean exact_match);
  
  int getpubusersig(char *keyfile, long user_position, byte *sigkeyID,
! 	byte *timestamp, long *sig_position, int *sig_len);
  
  void getKeyHash( byte *hash, unitptr n, unitptr e );
  void printKeyHash( byteptr hash, boolean indent );
diff -rc pgp23a/src/makefile.unx pgp26ui/src/makefile.unx
*** pgp23a/src/makefile.unx	Fri Jul  2 19:11:18 1993
- --- pgp26ui/src/makefile.unx	Thu May 26 12:44:29 1994
***************
*** 55,61 ****
  	@echo "        sysv_386, sco-2.0, x286(*), hpux, linux, mips-ultrix, vax-ultrix,"
  	@echo "        xenix386, mach_386, 386bsd, isc, isc_asm, 3b1, 3b1_asm, rs6000,"
  	@echo "        bsd, bsdgcc, vax_bsd43, rt_aos4, osf, sgigcc_asm, sgigcc, irix"
! 	@echo "        newsgcc, newsasm, aux(*), aux-gcc, os2, djgpp"
  	@echo ""
  	@echo "for targets marked with (*) you must first get unproto, see"
  	@echo "setup.doc for further details"
- --- 55,61 ----
  	@echo "        sysv_386, sco-2.0, x286(*), hpux, linux, mips-ultrix, vax-ultrix,"
  	@echo "        xenix386, mach_386, 386bsd, isc, isc_asm, 3b1, 3b1_asm, rs6000,"
  	@echo "        bsd, bsdgcc, vax_bsd43, rt_aos4, osf, sgigcc_asm, sgigcc, irix"
! 	@echo "        newsgcc, newsasm, aux(*), aux-gcc, os2, djgpp, sunos5cc, sunos5gcc"
  	@echo ""
  	@echo "for targets marked with (*) you must first get unproto, see"
  	@echo "setup.doc for further details"
***************
*** 156,161 ****
- --- 156,169 ----
  	$(MAKE) all CC=cc LD=cc OBJS_EXT=sparc.o \
  	CFLAGS="-Qpath unproto -O -DUNIX -DHIGHFIRST -DIDEA32"
  
+ sunos5cc:
+ 	$(MAKE) all CC=cc LD=cc OBJS_EXT=sparc5.o \
+ 	CFLAGS="-fast -xO4 -Dsparc -Usun -DUNIX -DHIGHFIRST -DIDEA32"
+ 
+ sunos5gcc:
+ 	$(MAKE) all CC=gcc LD=gcc OBJS_EXT=sparc5.o \
+ 	CFLAGS="-O2 -Dsparc -Usun -DUNIX -DHIGHFIRST -DIDEA32"
+ 
  sun386i:
  	$(MAKE) all CC=gcc LD=gcc OBJS_EXT=_80386.o \
  	CFLAGS="-O -DUNIX -DIDEA32"
***************
*** 276,281 ****
- --- 284,293 ----
  next:
  	$(MAKE) all \
  	CFLAGS="-O -DNEXT -DUNIX -DHIGHFIRST -DMACH -DPORTABLE -DNOTERMIO"
+ 
+ next486:
+ 	$(MAKE) all \
+ 	CFLAGS="-O -DNEXT -DUNIX -DMACH -DPORTABLE -DNOTERMIO"
  
  bsdgcc:
  	$(MAKE) all CC=gcc LD=gcc \
diff -rc pgp23a/src/pgp.c pgp26ui/src/pgp.c
*** pgp23a/src/pgp.c	Fri Jul  2 19:22:36 1993
- --- pgp26ui/src/pgp.c	Fri May 27 12:15:07 1994
***************
*** 47,53 ****
- --- 47,58 ----
  		Version 2.2 - 6 Mar 93
  		Version 2.3 - 13 Jun 93
  		Version 2.3a - 1 Jul 93
+ 		Version 2.6ui - 25 May 93
  
+ 	Note: 2.6ui is an unofficial international release, based on 2.3a
+ 	and put together by mathew <mathew@mantis.co.uk> for compatibility 
+ 	with MIT PGP 2.6.
+ 
  	(c) Copyright 1990-1993 by Philip Zimmermann.  All rights reserved.
  	The author assumes no liability for damages resulting from the use
  	of this software, even if the damage results from defects in this
***************
*** 142,154 ****
  #define	STACK_WIPE	4096
  
  /* Global filenames and system-wide file extensions... */
! char rel_version[] = "2.3a";	/* release version */
  #ifdef RSAREF
  #define RSASTRING " (with RSAREF)"
  #else
  #define RSASTRING ""
  #endif
! static char rel_date[] = "1 Jul 93";	/* release date */
  char PGP_EXTENSION[] = ".pgp";
  char ASC_EXTENSION[] = ".asc";
  char SIG_EXTENSION[] = ".sig";
- --- 147,161 ----
  #define	STACK_WIPE	4096
  
  /* Global filenames and system-wide file extensions... */
! char rel_version[] = "2.6ui";	/* release version */
! /* Version reported in armor files */
! char armor_version[MAX_VERSION_LENGTH] = "2.6";
  #ifdef RSAREF
  #define RSASTRING " (with RSAREF)"
  #else
  #define RSASTRING ""
  #endif
! static char rel_date[] = "27 May 94";	/* release date */
  char PGP_EXTENSION[] = ".pgp";
  char ASC_EXTENSION[] = ".asc";
  char SIG_EXTENSION[] = ".sig";
diff -rc pgp23a/src/pgp.h pgp26ui/src/pgp.h
*** pgp23a/src/pgp.h	Fri Jun 11 03:44:12 1993
- --- pgp26ui/src/pgp.h	Wed May 25 18:43:46 1994
***************
*** 118,125 ****
  #define CK_ENCRYPTED_BYTE	2	/* Conventional key is encrypted */
  
  /* Version byte for data structures created by this version of PGP */
! #define	VERSION_BYTE		2	/* PGP2 */
  
  /* Values for trust bits in keycntrl packet after key packet */
  #define	KC_OWNERTRUST_MASK		0x07	/* Trust bits for key owner */
  #define	KC_OWNERTRUST_UNDEFINED	0x00
- --- 118,130 ----
  #define CK_ENCRYPTED_BYTE	2	/* Conventional key is encrypted */
  
  /* Version byte for data structures created by this version of PGP */
! #define	VERSION_BYTE_MIN	2	/* PGP2 to 2.5 */
! #define	VERSION_BYTE_MAX	3	/* PGP2.6 */
! #define	VERSION_BYTE_DEFAULT	2	/* PGP2 */
  
+ /* Max length of ASCII version string in armored output */
+ #define MAX_VERSION_LENGTH	20
+ 
  /* Values for trust bits in keycntrl packet after key packet */
  #define	KC_OWNERTRUST_MASK		0x07	/* Trust bits for key owner */
  #define	KC_OWNERTRUST_UNDEFINED	0x00
***************
*** 230,235 ****
- --- 235,242 ----
  extern int compl_min;	/* number of fully trusted signatures needed */
  extern int max_cert_depth;
  extern char pager[];	/* file lister command */
+ extern char armor_version[MAX_VERSION_LENGTH];	/* version text in armor output */
+ extern int version_byte;	/* PGP packet format version */
  
  /* These lists store hashed passwords for future use. */
  /* passwds are passwords of as-yet-unknown purpose; keypasswds
Only in pgp26ui/src: sparc5.s
diff -rc pgp23a/src/zdeflate.c pgp26ui/src/zdeflate.c
*** pgp23a/src/zdeflate.c	Sun May  9 19:39:18 1993
- --- pgp26ui/src/zdeflate.c	Fri May 27 12:30:32 1994
***************
*** 275,283 ****
  
      /* Use dynamic allocation if compiler does not like big static arrays: */
  #ifdef DYN_ALLOC
! 	__window = window = (uch far*) fcalloc(WSIZE*2*sizeof(uch)+16, 1);
! 	__prev = prev = (Pos far*) fcalloc(WSIZE*sizeof(Pos)+16, 1);
! 	head   = (Pos far*) fcalloc(HASH_SIZE, sizeof(Pos));
  
  	if (window == NULL || prev == NULL || head == NULL) {
  		err(ZE_MEM, "window allocation");
- --- 275,283 ----
  
      /* Use dynamic allocation if compiler does not like big static arrays: */
  #ifdef DYN_ALLOC
! 	__window = window = (uch far*) _fcalloc(WSIZE*2*sizeof(uch)+16, 1);
! 	__prev = prev = (Pos far*) _fcalloc(WSIZE*sizeof(Pos)+16, 1);
! 	head   = (Pos far*) _fcalloc(HASH_SIZE, sizeof(Pos));
  
  	if (window == NULL || prev == NULL || head == NULL) {
  		err(ZE_MEM, "window allocation");
***************
*** 327,335 ****
  void lm_free()
  {
  #ifdef DYN_ALLOC
! 	free(__window);
! 	free(__prev);
! 	free(head);
  	window = NULL;
  	prev = head = NULL;
  #endif
- --- 327,335 ----
  void lm_free()
  {
  #ifdef DYN_ALLOC
! 	_ffree(__window);
! 	_ffree(__prev);
! 	_ffree(head);
  	window = NULL;
  	prev = head = NULL;
  #endif
diff -rc pgp23a/src/zipup.c pgp26ui/src/zipup.c
*** pgp23a/src/zipup.c	Sun May  9 19:39:20 1993
- --- pgp26ui/src/zipup.c	Thu May 26 12:18:34 1994
***************
*** 37,43 ****
  #    define fhow (O_RDONLY|O_BINARY)
  #  else /* !MSDOS */
  #ifndef AMIGA
!      long lseek();
  #endif /* AMIGA */
  #    define fhow 0
  #  endif /* ?MSDOS */
- --- 37,43 ----
  #    define fhow (O_RDONLY|O_BINARY)
  #  else /* !MSDOS */
  #ifndef AMIGA
!      off_t lseek();
  #endif /* AMIGA */
  #    define fhow 0
  #  endif /* ?MSDOS */
***************
*** 64,70 ****
  /* ??? Does not yet handle non-seekable y */
  {
    int m;				/* method for this entry */
!   long q = -1L;			/* size returned by filetime */
    ush att;				/* internal file attributes (dummy only) */
    ush flg;				/* gp compresion flags (dummy only) */
  
- --- 64,70 ----
  /* ??? Does not yet handle non-seekable y */
  {
    int m;				/* method for this entry */
!   off_t q = -1L;			/* size returned by filetime */
    ush att;				/* internal file attributes (dummy only) */
    ush flg;				/* gp compresion flags (dummy only) */
  
diff -rc pgp23a/src/ztrees.c pgp26ui/src/ztrees.c
*** pgp23a/src/ztrees.c	Sun May  9 19:39:20 1993
- --- pgp26ui/src/ztrees.c	Fri May 27 12:29:58 1994
***************
*** 346,353 ****
      compressed_len = input_len = 0L;
          
  #ifdef DYN_ALLOC
!     d_buf = (ush far*) fcalloc(DIST_BUFSIZE, sizeof(ush));
!     l_buf = (uch far*) fcalloc(LIT_BUFSIZE/2, 2);
      /* Avoid using the value 64K on 16 bit machines */
      if (l_buf == NULL || d_buf == NULL) error("ct_init: out of memory");
  #endif
- --- 346,353 ----
      compressed_len = input_len = 0L;
          
  #ifdef DYN_ALLOC
!     d_buf = (ush far*) _fcalloc(DIST_BUFSIZE, sizeof(ush));
!     l_buf = (uch far*) _fcalloc(LIT_BUFSIZE/2, 2);
      /* Avoid using the value 64K on 16 bit machines */
      if (l_buf == NULL || d_buf == NULL) error("ct_init: out of memory");
  #endif
***************
*** 413,420 ****
  void ct_free()
  {
  #ifdef DYN_ALLOC
! 	free(d_buf);
! 	free(l_buf);
  	d_buf = NULL;
  	l_buf = NULL;
  #endif
- --- 413,420 ----
  void ct_free()
  {
  #ifdef DYN_ALLOC
! 	_ffree(d_buf);
! 	_ffree(l_buf);
  	d_buf = NULL;
  	l_buf = NULL;
  #endif

-----BEGIN PGP SIGNATURE-----
Version: 2.6

iQCVAgUBLeX6UHzXN+VrOblFAQH0eAP+KnOUVKXfe5b9hMceS8F8JglxvWP8foM3
f6v5r2Gyibf6v0YdSPAuItZaxYsVrxjGvL7hxvLPATn7LQFo0Uq9AAfAb5ys3TE7
hjbLPE/gA6jecDJmVqafGSKMBwEsPcUsNavw3m8UZvK1zN3MGVteqDxwgI8Sep9/
/z21ADAOAcs=
=Av81
-----END PGP SIGNATURE-----
