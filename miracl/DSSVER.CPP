/*
 *   Proposed Digital Signature Standard (DSS)
 *
 *   See Communications ACM July 1992, Vol. 35 No. 7
 *   This new standard for digital signatures has been proposed by 
 *   the American National Institute of Standards and Technology (NIST)
 *   under advisement from the National Security Agency (NSA). 
 *
 *   This program verifies a the signature given to a <file> in
 *   <file>.dss generated by program dssign.c
 * 
 *   This program must be linked to functions in shs.c
 *
 *   Copyright (c) 1988-1993 Shamus Software Ltd.
 */

#include <iostream.h>
#include <fstream.h>
#include <string.h>
#include <big.h>

extern "C"
{ /* Secure Hashing Standard (SHS) routines */
    extern void shs_init(void);
    extern void shs_process(int);
    extern void shs_hash(char *);
}

miracl precision(200,256);

void strip(char *name)
{ /* strip off filename extension */
    int i;
    for (i=0;name[i]!='\0';i++)
    {
        if (name[i]!='.') continue;
        name[i]='\0';
        break;
    }
}

static Big hash(ifstream &fp)
{ /* compute hash function */
    char ch,s[20];
    unsigned char uch;
    int i;
    Big h;
    shs_init();
    forever 
    { /* read in bytes from message file */
        fp.get(ch);
        if (fp.eof()) break;
        shs_process((unsigned char)ch);
    }
    shs_hash(s);
/* convert to big number */
    INPLEN=20;
    IOBASE=256;
    h=s;
    return h;
}

void main()
{
    ifstream common="common.dss";    /* construct file I/O streams */
    ifstream public_key="public.dss";
    ifstream message;
    ifstream signature;
    Big p,q,g,y,v,u1,u2,r,s,t,h;
    char ifname[13],ofname[13];
/* get public data */
    common >> q >> p >> g;
/* get public key of recipient */
    public_key >> y;
/* get message */
    cout << "signed file = " ;
    cin.sync();
    cin.getline(ifname,13);
    strcpy(ofname,ifname);
    strip(ofname);
    strcat(ofname,".dss");
    message.open(ifname,ios::binary); 
    if (!message)
    { /* no message */
        cout << "Unable to open file " << ifname << "\n";
        exit(0);
    }
    h=hash(message);

    IOBASE=10;
    signature.open(ofname);
    if (!signature)
    { /* no signature */
        cout << "signature file " << ofname << " does not exist\n";
        exit(0);
    }
    signature >> r >> s;
    if (r>=q || s>=q)
    {
        cout << "Signature is NOT verified\n";
        exit(0);
    }
    s=inverse(s,q);
    u1=(h*s)%q;
    u2=(r*s)%q;
    t=pow(g,u1,p);
    v=pow(y,u2,p);
    v=(t*v)%p;
    v%=q;
    if (v==r) cout << "Signature is verified\n";
    else      cout << "Signature is NOT verified\n";
}

