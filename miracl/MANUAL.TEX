\documentstyle[twoside]{report}    % Specifies the document style.
\raggedbottom
\parindent=0mm
\parskip=3mm
\textheight=182mm
\textwidth=113mm

\title{M.I.R.A.C.L. Users Manual \thanks{This manual documents Version 3.2 
of the MIRACL library}} 
\author{Shamus Software Ltd.\\
        94 Shangan Road\\
          Ballymun\\
          Dublin\\
          Ireland}

\date{October 1, 1992}

\begin{document}           % End of preamble and beginning of text.

\maketitle                 % Produces the title.

\pagenumbering{roman}

\tableofcontents

\begin{abstract}
The MIRACL library consists of over 100 routines that cover all aspects
of Multi-precision arithmetic. Two new data-types are defined -- {\em big} for 
large integers and {\em flash} (short for floating-slash) for large rational 
numbers. The large integer routines are based on Knuth's algorithms, 
described in Chapter 4 of his classic work `The Art of Computer Programming'. 
Floating-slash arithmetic, which works with rounded fractions, was originally 
proposed by D. Matula and P. Kornerup. All routines have been thoroughly 
optimised for speed and efficiency, while at the same time remaining standard, 
portable C. A C++ interface is also provided. Full source code is included.
\end{abstract}

\chapter{Introduction} 

\pagenumbering{arabic}

Remember when as a naive young computer user,  you received  delivery  of 
your brand new state-of-the-art micro;  remember your anticipation at the 
prospect of the computer power now available at your fingertips; remember 
recalling all those articles which promised that  ``todays  microcomputers 
are  as  powerful  as  yesterdays  mainframes''.  Remember then slowly and 
laboriously typing in your first program, to calculate, say,  $1000!$  (i.e. 
$1000\times999\times998\ldots\times3\times2\times1$) - a calculation unimaginable 
by hand.  


\begin{bf}
\begin{center}
\begin{tabular}{l}
                       10 LET X=1          \\
                       20 FOR I=1 TO 1000   \\
                       30 X=X*I            \\
                       40 NEXT I           \\
                       50 PRINT X          \\
                       60 END              \\

                       RUN                 \\
\end{tabular}
\end{center}
\end{bf}

After a few seconds the result appeared:-

\begin{bf}
\begin{center}
                       Too big at line 30
\end{center}
\end{bf}

Remember your disappointment.

Now try the MIRACL approach. MIRACL is a portable C library which  implements  
multiprecision integer and rational data-types, and provides the routines to 
perform  basic  arithmetic  on them.

Run the program `fact' on the distribution diskette, and type in 1000. There 
is your answer.  

Now  run the program `roots',  and ask it to calculate the square root of 
2. Virtually instantly your computer comes 
back with the value correct to 100+ decimal places. Now thats what I call 
computing!  

Next  run the Public Key Cryptography program `enciph'.  When it asks the 
name of a file to be enciphered press return.  When it asks for an output 
filename,  type  `FRED'  followed  by  return.  Now  type in any message, 
finishing with CONTROL-Z.  Your  message  has  been  thoroughly 
enciphered in the file FRED.BLG (type it out and see).  Now run `deciph', 
and type in FRED.  Press return for the requested output  filename.  Your 
original message appears on the screen.  

This type of encipherment,  based as it is on the difficulty of factoring 
large numbers,  offers much greater security and  flexibility  than  more 
traditional methods.  

A  useful  demonstration  of  the power of MIRACL is given by the program 
RATCALC, a powerful scientific calculator -- accurate to 36 decimal places 
and with the unusual ability to handle fractions directly.  

\vspace{5mm}
It is assumed in this manual that the reader is familiar with the C language, 
and with his/her own computer. On a first reading Chapters 4, 5 and 6 may be 
safely skipped. Examination of the example programs' source code will be very 
rewarding.



\cleardoublepage 
\chapter{Installation}

The MIRACL library has been successfully installed on a VAX11/780, 
using Digital's own C compiler, on a Sun SPARC workstation, on an IBM PC 
using (amongst  others) 
the Microsoft V6.0, Zortech C++ V3.0, 
and Borlands Turbo C V2.0 and Borland C++ V3.0 compilers, on an Acorn 
Archimedes using the 
Norcroft ARM  C V1.54A, and on an Apple Macintosh, using the Lightspeed C 
compiler. 

The complete source code for each module in the MIRACL library, and  for each  
of the example programs is provided on the distribution media.  Each (except 
{\em mrmuldv.any}) is written in Standard C, and should compile using any 
decent C compiler. (Note that some modules contain extensive amounts of 
in-line assembly language, used to optimise performance for certain 
compiler/processor combinations, but these are invoked transparently by 
conditional compilation commands and will not interfere with other compilers.) 
The batch files xxDOIT.xxx contain the commands used for the creation  of a 
library file and the example programs for several compilers.   Print  out  and  
examine  the  appropriate  file  for  your configuration. 

Pre-compiled libraries for immediate use with certain  popular  compilers
may be found on the distribution diskettes: ready-to-run versions of  only  some
of the example programs may be included, due to  lack  of  space.

\vspace{3mm}
{\bf IMPORTANT!}
\vspace{3mm}

To  create  a  library  you will need access to a compiler, a text editor,
a linker, a 
librarian utility,  and  an  assembler  (optional).  Read  your  compiler 
documentation  for further details.  The file {\em mrmuldv.any}, which contains
special assembly language versions of the time-critical routines {\bf muldiv}, 
{\bf muldvd} and {\bf muldvm}  
together with portable C versions, will need  to  be 
tailored for your configuration.  Copy it to a file named  {\em mrmuldv.c}  and 
edit this file. Read this manual carefully, and the comments in 
{\em mirdef.h} and {\em mrmuldv.any} for details.  


The main header file {\em miracl.h} may need to be edited if you use  an  older 
type of C compiler,  which does not support the new ANSI extensions.  See 
the comments at the beginning of {\em miracl.h} for details.  

The hardware specific file {\em mirdef.h} may also  need to be edited,  if you
want to implement  the  MIRACL  library  on  a  computer  other than that 
originally specified. To assist with this, four different versions of the 
header are supplied: {\em mirdef.h16} 
for use with a 16-bit processor, {\em mirdef.h32} for 32-bit 
processors, {\em mirdef.haf} if using a 32-bit processor in a 16-bit mode, and 
{\em mirdef.hpc} for pseudo 32-bit working in a 16-bit environment. Note that 
the full 32-bit version is fastest, but only possible if using a true 32-bit 
compiler with a 32-bit processor (e.g. Watcom C/386 on an 80386 PC).

This {\em mirdef.h} file contains three optional definitions: Define FULLWIDTH 
if you are 
able to supply versions of {\bf muldvd} and {\bf muldvm} in {\em mrmuldv.c}. 
Define MR\_FLASH if you wish to use {\em flash} variables in your programs. 
By omitting this definition {\em big} variables can be made much larger, and the 
library produced will be much smaller, leading to more compact executables. 
Define MR\_STRIPPED\_DOWN to omit most error checking, to save even more 
space in production code. Use with care! 

It is suggested that the library file {\em miracl.lib} be placed in that 
directory or folder where the compiler keeps its own object libraries. 
Similarly the header files {\em miracl.h} and {\em mirdef.h} can be placed 
in the same directory or folder used by the compiler to store its own standard 
header files, such as {\em stdio.h}. 

Remember that MIRACL is portable software. It may be ported to {\bf any} 
computer which supports a C compiler.

More installation advice, specific to your particular computer, may be found 
in the {\em read.me} files on the distribution media.

\cleardoublepage 
\chapter{The User Interface}
\vspace{3mm}
{\bf AN EXAMPLE}
\vspace{3mm}

\begin{verbatim}
/*
 *   Program to calculate factorials.
 */

#include <stdio.h>
#include <miracl.h>   /* include MIRACL system */

main()
{ /* calculate factorial of number */
    big nf;         /* declare "big" variable nf */
    int n;
    mirsys(5000,10);/* set base 10, 5000 digits per "big" */
    nf=mirvar(1);   /* initialise "big" variable nf=1     */
    printf("factorial program\n");
    printf("input number n= \n");
    scanf("%d",&n);
    getchar();
    while (n>1) 
        premult(nf,n--,nf); /* nf=n!=n*(n-1)*...2*1  */
    printf("n!= \n");
    otnum(nf,stdout); /* output result */ 
}

\end{verbatim}

      This program can be used to quickly calculate and print out 1000!  (a 
      2568 digit number) in less than 10 seconds on an Acorn Archimedes 32-bit 
      computer,  a task  first 
      performed  ``by  H.S.  Uhler using a desk calculator and much patience 
      over a period of several years''  \cite{Knuth73}. Many other example 
      programs are described in Chapter 8.  

\vspace{5mm}

      Any  program  that wishes to make use of the  MIRACL  system  must have 
an {\tt \#include <miracl.h>} statement. This tells the compiler to include 
the C 
      header  file  {\em miracl.h}  with  the  main  program source file before 
      proceeding with the compilation.  This file  contains 
      declarations  of  all  the  MIRACL routines available to the user and 
      permits  access  to  some global variables. The small sub-header file 
      {\em mirdef.h} contains hardware-specific details.
                                                     
      In the main program the MIRACL system must be initialized by  a  call 
      to  the  routine {\bf mirsys}, which sets the number base and the maximum 
      size of the {\em big} and {\em flash} variables.  It also initializes the 
      random number system,  and creates several workspace {\em big} variables 
      for its own internal use. Also initialized is the relatively 
      sophisticated 
      error tracing system which is integrated with the MIRACL package.  
      Whenever an  error  is  detected  the  sequence  of  routine calls 
      down to the routine which generated the error is reported, as well as 
      the  error itself. A typical error message might be 

      \begin{center}
      \begin{tabbing}

                    MIRACL error \=from routine powmod      \\
                                 \>called from isprime      \\
                                 \>called from your program \\
                    Raising integer to a negative power     
      \end{tabbing}
      \end{center}

      Such an error report facilitates debugging, and certainly assisted us 
      during  the  development  of  these routines.  An associated variable 
      TRACER,  initialised to OFF,  if set by the user to ON,  will cause a 
      trace  of  the  program's  progress through the MIRACL routines to be 
      output to the computer screen.  

      Every {\em big}  or  {\em flash}  variable  in  the  users  program  
      must be initialized by a call to the routine {\bf mirvar}, which also 
      allows the variable to be given an initial integer value.  

      The full set of arithmetic and number-theoretic routines declared  in 
      {\em miracl.h}  may  be  used  on  these  variables.  Full flexibility 
      is (almost always) allowed in parameter usage with these  routines.  For 
      example the call {\bf multiply($x,y,z$)},  multiplies the {\em big} 
      variable $x$  by the {\em big} variable $y$ to give the result as {\em 
      big} variable $z$.  Equally valid would be {\bf multiply($x,y,x$)}, {\bf 
      multiply($y,y,x$)}, or {\bf multiply($x,x,x$)}.  
      This last simply squares $x$.  Note that the first  parameters  are  by 
      convention  always (usually) the inputs to the routines.  Routines are provided 
      not only to allow arithmetic on {\em big} and {\em flash} numbers,  but  
      also to  allow  these  variables  to  perform arithmetic with the 
      built-in integer and double precision data-types.  

      Conversion routines are also provided to convert  from  one  type  to 
      another.  For  details of each routine see the relevant documentation 
      in Chapter 9 and the example programs of Chapter 8.  

      Input and output to a file or I/O device is handled by the routines {\bf 
      innum}, {\bf otnum},  {\bf cinnum} and {\bf cotnum}. The first two use 
      the fixed number base specified by the user in  the  initial call of 
      {\bf mirsys}. The latter pair work in conjunction with the global 
      variable IOBASE which can be assigned dynamically  by the  user.  A  
      simple  rule  is that if the program is CPU bound,  or involves changes 
      of base,  then set the base initially to MAXBASE  (or 0 if a full-width 
      base is possible -- see Chapter 4) and use {\bf cinnum} and 
      {\bf cotnum}. If on the other hand the program is I/O bound, 
      or needs access to individual digits of numbers (using {\bf getdig}, 
      {\bf putdig} and {\bf numdig}), use {\bf innum} and {\bf otnum}. 

      Input and output to/from a character string is also supported in a 
      similar fashion by the routines
      {\bf instr}, {\bf otstr}, {\bf cinstr} and {\bf cotstr}.
      The input routines can be used to set {\em big} or {\em flash} 
      numbers  to  large  constant values.  By outputting to a string, 
      formatting can take place prior to actual output to a file or I/O 
      device. 

      Numbers to bases up to 256 can be represented.  Numbers up to base 60 
      use as many of the symbols 0-9, A-Z, a-x as necessary. If the base is 
      greater than 60,  the symbols used are the Ascii codes 0-255.  A base 
      of 256 is useful when it is necessary to interpret a line of text as 
      a large integer,  as is the case  for  the  Public  Key  Cryptography 
      programs described in Chapter 8.  

      Rational numbers may be input using either a radix point (e.g 0.3333) 
      or  as  a fraction (e.g.  1/3).  Either form can be used on output by 
      setting the global variable POINT=ON or =OFF. 


\cleardoublepage
\chapter {Internal Representation}

      Conventional computer  arithmetic  facilities  as  provided  by  most 
      computer language compilers usually provide one or two floating-point 
      data  types  (e.g.  single and double precision) to represent all the 
      real numbers,  together with one or more integer types  to  represent 
      whole  numbers.  These built-in data-types are closely related to the 
      underlying computer architecture,  which is sensibly designed to work 
      quickly with large amounts of small numbers,  rather than slowly with 
      small amounts of large numbers (given  a  fixed  memory  allocation). 
      Floating-point allows a relatively small binary number (e.g. 32 bits) 
      to  represent  real numbers to an adequate precision (e.g.  7 decimal 
      places) over a large dynamic range.  Integer types allow small  whole 
      numbers to be represented directly by their binary equivalent,  or in 
      2's complement  form  if  negative.  Nevertheless  this  conventional 
      approach to computer arithmetic has several disadvantages.  

      \vspace{5mm}
      (1)   Floating-point  and  Integer  data-types  are   
      incompatible.  Note that the set of integers, although infinite, is a 
      subset of the rationals (i.e.  fractions),  which is in turn a subset 
      of the reals.  Thus every integer has  an  equivalent  floating-point 
      representation.  Unfortunately  these  two  representations  will  in 
      general be different.  For example a small positive whole number will 
      be  represented  by  its  binary  equivalent  as  an integer,  and as 
      separated mantissa and exponent as a floating-point. This implies the 
      need for conversion routines, to convert from one form to the other.  

      \vspace{5mm}
      (2) Most rational numbers cannot be expressed  exactly  (e.g.  $1/3$).  
      Indeed  the  floating-point  system  can  only  express exactly those 
      rationals whose denominators are multiples  of  the  factors  of  the 
      underlying  radix.  For  example our familiar decimal system can only 
      represent exactly  those  rational  numbers  whose  denominators  are 
      multiples of 2 and 5; $1/20$ is $0.05$ exactly, $1/21$ 
      is $.0476190476190\ldots$  

      \vspace{5mm}
      (3) Rounding in floating-point is  base-dependant  and  a  source  of 
      obscure errors.  

      \vspace{5mm}
      (4)  The  fact that the size of integer and floating-point data types 
      are dictated by the computer architecture,  defeats  the  efforts  of 
      language designers to keep their languages truly portable.  

      \vspace{5mm}
      (5)  Numbers  can  only  be  represented to a fixed machine-dependent 
      precision. In many applications this can be a crippling disadvantage, 
      for example in the new and growing field of Public-Key cryptography.  

      \vspace{5mm}
      (6) Base-dependent phenomena cannot easily be studied. For example it 
      would be difficult to access a particular digit of a decimal  number, 
      as  represented  by  a  traditional  integer  data-type.

      \vspace{5mm}
      Herein is described a set of standard  C  routines  which  manipulate 
      multiprecision  rational  numbers  directly,   with  multiprecision 
      integers as a compatible subset. Approximate real arithmetic can also 
      be performed.  

      The two new data-types are called {\em big} and {\em flash}.  The  former is 
      used  to  store  multiprecision  integers,   and  the  latter  stores 
      multiprecision fractions as numerator and denominator  in
     ``floating-slash'' form.  Both take the form of a fixed length array of
      integers, 
      with sign and length information encoded in the  first  element,  and 
      the  data  itself  in  subsequent  elements.  Both  new  types can be 
      introduced into the syntax of the C language by the C  statements 

      \begin{center}
      \begin{tabular}{l}
                            typedef int* big;     \\
                            typedef int* flash; 
      \end{tabular}
      \end{center}
      \pagebreak
      Now  {\em big} and {\em flash} variables can be declared just like any 
      built-in data type, e.g.  

      \begin{center}
                             big x,y[10],z[10][10];
      \end{center}

      Note that the user of these data-types is  not  concerned  with  this 
      internal representation; the library routines allow {\em big} and {\em flash} 
      numbers to be manipulated directly.  

      The structure of {\em big} and {\em flash} numbers is illustrated in figure (4.1).

\begin{figure}
\thicklines
\begin{picture}(330,160)
\put (3,150){x[0]}
\put (38,150){x[1]}
\put (73,150){x[2]}
\put (163,150){x[n]}
\put (298,150){x[max]}
\put (0,120){\framebox(25,20){s 0 n}}
\put (35,120){\framebox(25,20){LSW}}
\put (70,120){\framebox(25,20){}}
\put (105,130){.............}
\put (160,120){\framebox(25,20){MSW}}
\put (195,120){\framebox(25,20){0}}
\put (240,130){..................}
\put (300,120){\framebox(25,20){0}}

\put (3,90){x[0]}
\put (38,90){x[1]}
\put (73,90){x[2]}
\put (128,90){x[n]}
\put (158,90){x[n+1]}
\put (193,90){x[n+2]}
\put (248,90){x[n+d]}
\put (298,90){x[max]}
\put (0,60){\framebox(25,20){s d n}}
\put (35,60){\framebox(25,20){LSW}}
\put (70,60){\framebox(25,20){}}
\put (105,70){.....}
\put (125,60){\framebox(25,20){MSW}}
\put (160,60){\framebox(25,20){LSW}}
\put (195,60){\framebox(25,20){}}
\put (230,70){.....}
\put (250,60){\framebox(25,20){MSW}}
\put (280,70){...}
\put (300,60){\framebox(25,20){0}}
\put (60,42){\vector(-1,0){25}}
\put (65,40){numerator}
\put (115,42){\vector(1,0){25}}
\put (155,40){/}
\put (190,42){\vector(-1,0){20}}
\put (195,40){denominator}
\put (255,42){\vector(1,0){20}}
\end{picture}

\caption{Structure of {\em big} and {\em flash} data-types where $s$  is        
         the  sign of the number,  $n$ and $d$ are the lengths of the 
         numerator and denominator respectively,  and LSW and MSW     
         mean  `Least  significant  word'  and  `Most significant     
         word'}

\end{figure} 



      These   structures   combine   ease   of  use  with  representational 
      efficiency.  A denominator of length zero ($d=0$),  implies  an  actual 
      denominator  of one;  and similarily a numerator of length zero ($n=0$) 
      implies  a  numerator of one.  Zero itself is uniquely defined as the 
      number whose first element is zero (i.e. $n=d=0$).  

      Note that the slash in the  {\em flash}  data-type  is  not  in  a fixed 
      position,    and  may  `float'   depending  on the relative  size  of 
      numerator and denominator.  

      A {\em flash} number is manipulated by  splitting  it  up  into  separate 
     {\em big}  numerator  and  denominator  components.  A {\em big}  number  is 
      manipulated by extracting and operating  on  each  of  its  component 
      integer elements.  To avoid possible overflow,  the  numbers  in each 
      element are normally limited to a somewhat smaller range than that of
      the full word-length, e.g. 0 to 32767  ($= 2^{15} - 1$) on a 16-bit 
      micro-computer. However with careful programming a full-width base of  
      $2^{16}$
      can also be used, as the C language does not report a run-time  error
      on integer overflow \cite{Scott89b}.  

      When the system is initialised the user specifies the fixed number of 
      words (or bytes) to be assigned to all {\em big}  or  {\em flash}  variables, 
      and the number base to be used. Any base can be used, up to a maximum 
      which is dependant on the wordlength of the computer used. If 
      requested  to  use  a  small  base  $b$,  the system will,  for optimal   
      efficiency, actually use base $b^{n}$, where $n$ is the largest integer 
      such that $b^{n}$ fits in a single computer word. Programs will in 
general execute fastest if a full-width base is used (achieved by specifying a 
base of 0 in the initial call to {\bf mirsys}). Note that this mode may be 
supported by extensive in-line assembly language for certain popular 
compiler/processor combinations, in certain time-critical routines (for 
example if using Borland/Turbo C with an 8086 processor, in small or medium 
memory model). Examine, for example, the source code in module {\em mrarth1.c}.  

      The   encoding  of  the  sign  and  numerator  and  denominator  size 
      information into the first word is possible,  as the C  language  has 
      standard  constructs  for bit manipulation.  On a 16-bit computer the 
      maximum number of words in each {\em big} or {\em flash} variable is 
limited to  127, the  equivalent of about 500 decimal digits (unless the 
MR\_FLASH definition is omitted from {\em mirdef.h}, see above).  On a 
32-bit computer there is, effectively, no limit.  


\cleardoublepage
\chapter{The Implementation}

      
      No  great  originality  is claimed for the routines used to implement 
      arithmetic on the {\em big} data-type.  The algorithms used are  faithful 
      renditions  of  those described by Knuth \cite[\$4.3.1]{Knuth81}. However
      some 
      effort was made to optimise the  implementation  for  speed.  At  the 
      heart  of  the  time-consuming multiply and divide routines there is, 
      typically,  a need  to  multiply  together  a  digit  from  each 
      operand,  add  in  a  `carry'  from  a  previous operation,  and then 
      separate the total into a digit of the result,  and a `carry' for the 
      next   operation.   To   illustrate consider  this base  10 
      multiplication: 

      \begin{center}
      \begin{tabular}{r}
          8723536221   \\
          x        9   \\ \hline
         78511825989   \\
      \end{tabular}
      \end{center}
                                

      To correctly process the column with  the  5  in  it,  we  multiply 
      $5\times9=45$,  add  in  the `carry' from the previous column (a 3),  to 
      give 48,  keep the 8 as the result for this column,  and carry  the 
      4 to the next column.  

      This  basic primitive operation is essentially the calculation of the 
      quotient $(a.b+c)/m$ and its remainder. For the example above $a=5$, 
      $b=9$, 
      $c=3$ and $m=10$.  This operation has suprisingly universal  application, 
      and since it lies at the innermost loop of the arithmetic algorithms, 
      its efficient implementation is essential.  

      There  are three main difficulties with a high-level language general 
      base implementation of this MAD (Multiply, Add and Divide) operation.  

\vspace{5mm}
      (1)  It will be slow.

\vspace{5mm}
      (2)  Quotient  and  remainder  are  not available simultaneously as a 
           result of the divide operation.  Therefore the calculation  must 
           be  essentially done twice,  once to get the quotient,  and once 
           for the remainder.  

\vspace{5mm}
       (3) Although the operation results in two single  digit  quantities, 
           the  intermediate  product $(a.b+c)$ may be double-length.  Indeed 
           such a Multiply-Add and  Divide  routine  can  be  used  on  all 
           occasions when a double-length quantity would be required by the 
           basic  arithmetic  algorithms.  Note  that  the  C language is 
           blessed with a `long' integer data-type which  may  in  fact  be 
           capable of temporarily storing this product.  

\vspace{5mm}
      For  these reasons it is best to implement this critical operation in 
      the assembly language of the computer used,  although a portable  C 
      version is possible. At machine-code level a transitory double-length 
      result can often be dealt with, even if the C long data-type is not 
      itself double-length (as is the case for the C compiler used on the 
      VAX11/780, for which ints and longs are both 32-bit quantities).  For 
      further details see the documentation in the file {\em mrmuldv.any}.  

      A  criticism  of  the  MIRACL system might be its use of fixed length 
      arrays for its {\em big} and {\em flash} data types.  This was done to 
      avoid 
      the  difficult  and  time-consuming problems of memory allocation and 
      garbage  collection  which  would  be  needed  by  a  variable-length 
      representation. However it does mean that when doing a calculation on 
      {\em big}  integers  that  the  results of all intermediate calculations 
      must be less than or equal to the fixed size initially  specified  to
      {\bf mirsys}.  

      In practise most numbers in a stable integer calculation are of  more 
      or  less  the  same size,  except when two are multiplied together in 
      which case a double-length intermediate product is created.  This  is 
      usually  immediately  reduced again by a subsequent divide operation.  
      A classic example of this would be  in  the  Pollard-Brent  factoring 
      program (Chapter 8).  

      Note  that  this  is another manifestation, on a macro level,  of the 
      problem mentioned in point (3) above.  It would be a pity to have  to 
      specify each variable to be twice as large as necessary, just to cope 
      with  these  occasional  intermediate  products.  For  this  reason a 
      special Multiply, Add and Divide routine {\bf mad} has been included in 
      the MIRACL library. It has proved very useful when implementing large 
      programs  (like  the  Pomerance-Silverman-Montgomery factoring 
      program, Chapter 8) on computers with limited memory.  

\vspace{5mm}
      As well  as  the  basic  arithmetic  operations,  routines  are  also 
      provided: 

\newcounter{fred}

\begin{list}%
{\roman{fred}}{\usecounter{fred}}

\item to generate and test {\em big} prime numbers,  using a  probabilistic 
      primality test (Knuth \cite[\$4.5.4]{Knuth81}) 

\item to generate {\em big}  and  {\em flash}  random  numbers,  based  on the 
      recently discovered subtract-with-borrow generator \cite{Marsaglia} 

\item to calculate powers and roots

\item to implement both the normal and extended euclidean GCD algorithm 
      (Knuth \cite[\$4.5.2]{Knuth81}) 

\item to implement the `Chinese Remainder Thereom' \cite{Knuth81}, and to 
      calculate the Jacobi Symbol \cite{Reisel}.

\item to multiply very large numbers, using the Fast Fourier Transform method
      \cite{Pollard}.

\end{list}

\cleardoublepage
\chapter{Floating-Slash numbers}

      The  straightforward  way to represent rational numbers is as reduced 
      fractions,  as a numerator and denominator with  all  common  factors 
      cancelled  out.   These  numbers  can  then  be  added,   subtracted, 
      multiplied and divided in the obvious way,  and the result reduced by 
      dividing  both  numerator  and  denominator  by their Greatest Common 
      Divisor.  An efficient GCD subroutine,  using Lehmers modification of 
      the  classical euclidean algorithm for multiprecision numbers (Knuth 
      \cite{Knuth81}), is included in the MIRACL package.  

      An alternative way to  represent  rationals  would  be  as  a  finite 
      continued fraction (See Knuth \cite[\$4.5.2]{Knuth81}). Every rational number 
      $\frac{p}{q}$ can be written as 

$$ \frac{p}{q} = a_0 + \frac{1}{a_1 + \textstyle \frac{1}{a_2 + \textstyle \frac{1}{a_3 + \cdots}}}$$

      or more elegantly as $\frac{p}{q} = [a_0/a_1/a_2/..../a_n]$,  where the
      $a_i$  are positive integers, usually quite small.  

      For example

                      $$\frac{277}{642}  =  [0/2/3/6/1/3/3]$$

      Note  that  the  $a_i$ elements of the  above  continued  fraction 
      representation  are  easily found as the quotients generated as a 
      by-product when the euclidean GCD algorithm is applied to $p$ and $q$.  

      As we are committed to fixed length representation  of  rationals,  a 
      problem  arises  when the result of some operation exceeds this fixed 
      length.  There is a necessity  for  some  scheme  of  truncation,  or 
      rounding. While there is no obvious way to truncate a large fraction, 
      it   is   a   simple   matter  to  truncate  the  continued  fraction 
      representation.  The resulting,  smaller,  fraction is called a  best 
      rational approximation, or a convergent, to the original fraction.  

 Consider truncating $\frac{277}{642} = [0/2/3/6/1/3/3]$. Simply drop the last 
 element from the CF representation,  giving $[0/2/3/6/1/3] = 
 \frac{85}{197}$, 
 which is a very close approximation to $\frac{277}{642}$ (error = 0.0018\%). 
 Chopping  more  terms  from  the  CF  expansion  gives the successive 
 convergents  as  $\frac{22}{51}$,  $\frac{19}{44}$,  
 $\frac{3}{7}$,  $\frac{1}{2}$,  $\frac{0}{1}$.   As  the 
 fractions get smaller, the error increases.  Obviously the truncation 
 rule for a computer implemention  should  be  to  choose  the  biggest 
 convergent that fits the computer representation.  

      The  type  of  rounding  described  above  is  also  called  `Mediant 
      rounding'.  If $\frac{p}{q}$ and $\frac{r}{s}$  are  two  neighbouring  
      representable 
      slash   numbers   astride   a   gap,   then   their  mediant  is  the 
      unrepresentable $\frac{(p+r)}{(q+s)}$.  All larger  fractions  between 
      $\frac{p}{q}$ 
      and the mediant will round to $\frac{p}{q}$,  and those between 
      $\frac{r}{s}$ and the 
      mediant will round  to  $\frac{r}{s}$. The mediant itself rounds to the 
      `simpler' of $\frac{p}{q}$ and $\frac{r}{s}$.  

      This is theoretically a very good way to round,  much better than the 
      rather arbitrary and base-dependent methods  used  in  floating-point 
      arithmetic,  and is the method used here.  The full theoretical basis 
      of floating-slash arithmetic is  described  in  detail  by  Matula  \& 
      Kornerup  \cite{Matula85}.  It should be noted that our {\em flash} 
      representation 
      is in fact a cross between  the  fixed-  and  floating-slash  systems 
      analysed  by  Matula \& Kornerup,  as our slash can only float between 
      words,  and not between bits.  However  the  characteristics  of  the 
      {\em flash}  data-type  will  tend  to  those  of floating-slash,  as the 
      precision is increased.  

      The MIRACL routine {\bf round} implements mediant rounding. If the result 
      of an arithmetic operation is the fraction $\frac{p}{q}$,  then the euclidean 
      GCD algorithm is applied as before to $p$ and $q$.  However this time the 
      objective  is  not  to use the algorithm to calculate the GCD per se, 
      but to use its quotients to build successive  convergents  to  
      $\frac{p}{q}$.  
      This  process is stopped when the next convergent is too large to fit 
      the {\em flash} representation.  The complete algorithm  is  given  below 
      (Kornerup \& Matula \cite{Korn83}) 


      Given $p\geq0$ and $q\geq1$

      \begin{tabbing}
        gggggggggggg\=ggggggggggggg\=gggggggggggggg\= \kill           
                  \>$b(-2)=p$ \>  $p(-2)=0$ \> $q(-2)=1$  \\
                  \>$b(-1)=q$ \>  $p(-1)=1$ \> $q(-1)=0$
      \end{tabbing}

      Now  for  $i=0,1,\ldots$  and  for  $b(i-1)>0$ ,  find the quotient 
      $a(i)$ and remainder $b(i)$ when $b(i-2)$ is divided by $b(i-1)$, 
      such that 

                $$   b(i) = -a(i).b(i-1) + b(i-2)     $$

      Then calculate

                $$   p(i) = a(i).p(i-1) + p(i-2)   $$
                $$   q(i) = a(i).q(i-1) + q(i-2)   $$

      Stop when $\frac{p(i)}{q(i)}$ is to big to fit the  {\em flash}   representation, 
      and take $\frac{p(i-1)}{q(i-1)}$ as the rounded result.  
        
      If applied to $\frac{277}{642}$, this process will give the same sequence of 
      convergents as stated earlier.  

      Since  this  rounding procedure must be applied to the result of each 
      arithmetic operation, and since it is potentially rather slow,  a lot 
      of effort has been made to optimize its implementation. Lehmer's idea 
      of  operating only with the most significant piece of each number for 
      as long as possible (Knuth \cite{Knuth81}) is used,  so that for  most  of  the 
      iterations  only single-precision arithmetic is needed.  Special care 
      is taken to avoid the rounded result overshooting the limits  of  the 
      {\em flash}  representation  (Scott \cite{Scott89a}).  The application of the basic 
      arithmetic routines to the calculation of elementary  functions  such 
      as $\log x$, $\exp x$, $\sin x$, $\cos x$, $\tan x$ etc., uses the fast
      algorithms described by Brent \cite{Brent76}.

      In  many  cases the result given by a program can be guaranteed to be 
      exact.  This can be checked by testing  the  global  variable  EXACT, 
      which  is  initialised  to  TRUE and is only set to FALSE if any rounding 
      takes place.  

      A  disadvantage  of  using  a {\em flash} type of variable to approximate 
      real  arithmetic  is   the   non-uniformity   in   gap-size   between 
      representable  values  (Matula  \& Kornerup \cite{Matula85}).  

      To illustrate this 
      consider a floating-slash system which is  constrained  to  have  the 
      product of numerator and denominator less than 256. Observe that the 
      first representable fraction less than $\frac{1}{1}$ in such a system is 
      $\frac{15}{16}$, a gap of $\frac{1}{16}$. The next fraction larger 
      than $\frac{0}{1}$ is $\frac{1}{255}$,  a gap of $\frac{1}{255}$.  
      In general,  for a $k$-bit  floating-slash 
      system,  the gap size varies from smaller than $2^{-k}$ to a worst case 
      $2^{-k/2}$. In practise this means that a real value  that  falls  into 
      one of the larger gaps,  will be represented by a fraction which will 
      be accurate to only half its usual precision.  Fortunately such large 
      gaps  are rare,  and increasingly so for higher precision,  occurring 
      only near simple fractions.  However it does mean that  real  results 
      can  only  be completely trusted to half the given decimal places.  A 
      partial solution to this problem  would  be  to  represent  rationals 
      directly as continued fractions.  This gives a much better uniformity 
      of gap-size (Kornerup \& Matula \cite{Korn85}),  but would be very 
      difficult to implement using a high level language.  

      Arithmetic  on  {\em flash}  data-types  is undoubtedly slower than on an 
      equivalent  sized  multiprecision  floating-point  type  (e.g.  Brent 
      \cite{Brent78}).  The  advantages  of  the  {\em flash} approach are its ability to 
      exactly represent rational numbers,  and do exact arithmetic on them. 
      Even  when rounding is needed,  the result often works out correctly, 
      due to the tendency of mediant-rounding to prefer a  simple  fraction 
      over  a  complex  one.  For example the {\em roots} program (Chapter 8) 
      when asked to find the square root of 2 and then square  the  result, 
      comes back with the exact answer of 2, despite internal rounding.  So 
      the MIRACL approach should appeal to those who prefer  an  answer  of 
      10, to one of 9.9999997.  
\cleardoublepage
\chapter{The C++ Interface}

      Many users of the MIRACL package would be disappointed that they have 
      to calculate 
  
                          $$  t = x^{2}  + x + 1  $$

      for a flash variable $x$ by the sequence

      \begin{center}
      \begin{tabular}{l}
                            fmul(x,x,t);   \\
                            fadd(t,x,t);   \\
                            fincr(t,1,1,t);
      \end{tabular}
      \end{center}

      rather than by simply $t=x*x+x+1;$

      Someone  could  of  course  use the MIRACL library to write a special 
      purpose C compiler which could properly interpret such an instruction (see 
      Cherry and Morris \cite{Cherry} for an  example  of  this  approach).  However 
      such  a drastic step is not necessary.  A superset of C,  called C++, 
      has been developed by AT\&T (Stroustrup \cite{Strous}),  which may gain general 
      acceptance  as the natural successor to C.  The enhancements to C are 
      mainly aimed at making it an object-oriented  language.  By  defining 
      {\em big} and {\em flash} variables as `classes' (in C++ terminology), it 
      is possible to  `overload'  the usual mathematical operators, so 
      that the compiler will automatically substitute  calls  to  the  
      appropriate  MIRACL  routines  when these operators are used in 
      conjunction with {\em big}  or  {\em flash}  variables. Furthermore  C++  
      is able to look after the initialization (and ultimate 
      elimination) of these data-types  automatically,  using  its 
      constructor/destructor mechanism,  which is included with the class 
      definition. This relieves the programmer from the tedium of 
explicitly initialising each {\em big} and {\em flash} variable by repeated calls to 
{\bf mirvar}. 
      Indeed once the classes are properly defined and set up, 
      it  is as simple to work with the new data-types as with the 
      built-in {\em double} and {\em int} types. Using C++ also helps shield 
      the user from the internal workings of MIRACL.

      The MIRACL library is interfaced to C++ via the header files {\em 
      big.h, flash.h} and {\em number.h}. 

      \vspace{3mm}
      {\bf EXAMPLE}
      \vspace{3mm}
\begin{verbatim}
/*
 *   Program to calculate factorials.
 */

#include <iostream.h>
#include <stdiostream.h>
#include <big.h>   /* include MIRACL system */

miracl precision(500,10);

void main()
{ /* calculate factorial of number */
    Big nf=1;       /* declare "Big" variable nf */
    int n;
    cout << "factorial program\n";
    cout << "input number n= \n";
    cin >> n;
    while (n>1) 
        nf*=(n--);  /* nf=n!=n*(n-1)*(n-2)*....3*2*1  */
    cout << "n!= \n" << nf << "\n";
}

\end{verbatim} 

Compare this with the C version of Chapter 3. Note the neat use of a dummy 
class {\em miracl} used to set the precision of the {\em big} variables.

In many of the example programs, particularly the factoring programs, all the 
arithmetic is done {\em mod n}. To avoid the tedious reduction {\em mod n} 
required after each operation, a new C++ class {\em ZZn} has been used, and 
defined in the file {\em number.h}. This class {\em ZZn} (for 
{\em ZZ(n)} or the ring of integers {\em mod n} ) 
has its arithmetic operators defined to automatically perform the reduction. 
The statement {\bf modulo(n)} sets the modulus.

C++ versions of many of the example programs are included in the distribution 
media, with the file extensions {\em .cpp}

\cleardoublepage
\chapter{Example Programs}

      Note:  The programs described here are of an experimental nature, and 
      in  many  cases  are  not  completely  `finished  off'.  For  further 
      information read the comments associated with the appropriate  source 
      file.  

      \section{Simple Programs}

      \subsection{hail.c}

      This  program  allows you to investigate so-called hailstone numbers, 
      as  described  by Gruenberger \cite{Fred}. 
      The procedure is simple.  Starting 
      with any number apply the following rules: 

      (a) If it is odd, multiply it by 3 and add 1.

      (b) If it is even, divide it by 2.

      (c) Repeat the process,  until the number becomes equal to 1, in which
          case stop.  

      It would appear that for  any  initial  number  this  process  always 
      eventually terminates, although it has not been proved that this must 
      happen,  or  that  the process cannot get stuck in an infinite loop.  
      What goes up,  it seems,  must come down.  Try  the  program  for  an 
      initial value of 27. Then try it using much bigger numbers.  

      \subsection{palin.c}

      This  programs  allows one to investigate palindromic reversals 
      \cite{Fred}. A palindromic number is one which reads the same in both 
      directions.  Start with any number and apply the following rules.  

      (a)  Add  the number to the number obtained by reversing the order of 
          the digits. Make this the new number.  

      (b) Stop the process when the new number is palindromic.


      It appears  that  for  most  initial  numbers  this  process  quickly 
      terminates.  Try it for 89. Then try it for 196.  

      \subsection{mersenne.c}

      This program generates all prime  numbers  of  the  form  $2^{n}-1$. The 
      largest  known  primes  have  always been of this form because of the 
      efficiency of this Lucas-Lehmer test.

      \section{Factoring Programs}
 
      Six different Integer Factorisation programs are included, covering all 
      modern approaches to this classical problem. For more background and
      information on the algorithms used, see Scott \cite{Scott89c}.

      \subsection{brute.c}

      This  program attempts to factorise a number by brute force division, 
      using a table of small prime numbers. When  attempting a difficult
      factorisation it makes sense to try this approach first.
      Factorise 12345678901234567890 using  this  program.  Then try it on 
      bigger random numbers.  

      \subsection{brent.c}

      This program attempts to factorise a number using  the  Brent-Pollard 
      method.  This  method  is  faster  at finding larger factors than the 
      simple-minded brute  force  approach.  However  it  will  not  always 
      succeed,  even  for simple factorisations.  Use it to factorise 
      R17, that is 11111111111111111 (seventeen ones). Then try it on larger
      numbers that would not yield to the brute force approach.  


      \subsection{pollard.c}

      Another factoring program, which implements Pollard's $(p-1)$ method,  
      specialises in quickly finding a factor $p$ of  a number  $N$ for  which
      $(p-1)$ has itself only small factors. Phase 1 of this method will work
      if all these small factors are less  than  LIMIT1. If  Phase 1  fails 
      then Phase 2 searches for just one  final  larger factor less  than
      LIMIT2. The constants LIMIT1 and LIMIT2 are set inside the program. 


      \subsection{williams.c}

      This program is similar to Pollards method, but can find a factor $p$ 
      of N for which $(p+1)$ has only small factors. Again two phases are 
      used. In fact this method is sometimes a $(p+1)$ method, and sometimes 
      a $(p-1)$ method, so several attempts are made to hit on the $(p+1)$ 
      condition. The algorithm is rather more complex than that used in 
      Pollards method, and is somewhat slower. 


      \subsection{lenstra.c}

      Recently Lenstra \cite{Monty} has discovered a new method of factorisation, 
      generically similar to the Pollard and Williams methods, but 
      potentially much more powerful. It works by randomly generating an 
      Elliptic Curve, which can then be used to find a factor $p$ of $N$, for 
      which $p+1-\delta$ has only small factors, where $\delta$ depends on the particular 
      curve chosen. If one curve fails then another can be tried, an option 
      not possible with the Pollard/Williams methods. Again this is a two 
      phase method, and although it has very good asymptotic behaviour, it 
      is much slower than the Pollard/Williams methods for each iteration. 

      \subsection{qsieve.c}

      This is a  very  sophisticated Pomerance-Silverman-Montgomery 
      (See \cite{Pomerance}, \cite{Silverman})  factoring  program.  
      which factored F7 = $2^{128} +1 =$ 

               $$  340282366920938463463374607431768211457 $$

      in less than 15 minutes, running on a 25MHz IBM PC computer. When 
      this number was first factored, it took 90 minutes on an IBM 360 
      mainframe (Morrison \& Brillhart \cite{Morrison}), albeit using a 
      somewhat inferior algorithm. 

      Its  speciality  is factoring all numbers (up to 
      about sixty digits long), irrespective of the size of the factors. If 
      the number to be factored is $N$,  then the program actually works with 
      a  number  $k.N$,  where  $k$ is a small Knuth-Schroepel multiplier.  The 
      program itself works out the best value of $k$ to use. Internally,  the 
      program uses a `factor base' of small primes. The larger the number, 
      the bigger will be  this  factor  base.  The  program  works  by  
      accumulating information from a number of simpler factorisations. As 
      it progresses with these it prints out `working...n'.  When it thinks 
      it has enough information it prints out `trying',  but these tries 
      may be premature and  may  not  succeed.  The program will always 
      terminate before the number $n$ in `working...n' reaches the size of 
      the factor base.  


      This program uses much more memory than  any  of  the  other  example 
      programs,  particularly when factoring bigger numbers.  The amount of 
      memory that the program can take is limited by the values defined for 
      MEM and MLF  at  the  beginning  of  the  program.  These  should  be 
      increased  if possible,  or reduced if your computer has insufficient 
      memory.  

      Use {\bf qsieve} to factor 10000000000000000000000000000000009 
      (thirty-five digits).

      \subsection{factor.c}

      This program combines the above algorithms into a single general purpose
      program for factoring integers. Each method is used in turn in the 
      attempt 
      to extract factors. The number to be factored is given in the command 
      line, as in {\bf factor 11111111111}. The number can also be specified as 
      a formula, using the switch `-f', as in {\bf factor -f (10\#11-1)/9}. The 
      symbol \# here means `to the power of' (\# is used instead of \^\  as the 
      latter symbol has a special meaning for DOS on an IBM PC).  

      \section{Discrete Logarithm Programs}

      Two programs implement Pollards algorithms \cite{Pollard2} for 
extracting discrete logarithms. The discrete logarithm problem to find $x$ 
given $y$, $r$ and $n$ in

             $$ y = r^{x} \bmod n $$

The above is a good example of a one-way function. It is easy 
to calculate $y$ given $x$, but apparently extremely difficult to find $x$ 
given $y$. Pollard's algorithms however perform quite well under certain 
circumstances, if $x$ is known to be small or if $n$ is a prime $p$ for which 
$p-1$ has only small factors.

     \subsection{kangaroo.c}

      This program finds $x$ in the above, assuming that $x$ is quite 
      small. The value of $r$ is fixed (at 16), and the modulus $n$ is also 
fixed inside the program. Initially a `trap' is set. Subsequently the discrete
logarithm can be found (almost certainly) for any number, assuming its 
discrete logarithm is less than a certain upper limit. The number of steps 
required will be approximately the square root of this limit.  

      \subsection{genprime.c}

      A prime number $p$ with known factorisation of $p-1$ is generated by 
this program, for use by the {\em index.c} program described below. The 
factors of $p-1$ are output to a file {\em prime.dat}.

      \subsection{index.c}

      This program implements Pollard's rho algorithm for extracting discrete 
logarithms, when the modulus $n$ in the above equation is a prime $p$, and 
when $p-1$ has only relatively small factors. The number of steps required is a 
function of the square root of the largest of these factors. 


      \section{Public-Key Cryptography}

      Two Public-Key cryptography systems, whose strength appears to depend 
      on  the  difficulty  of  factorisation,  are given.  The first is the 
      classic RSA system (Rivest,  Shamir \& Adleman \cite{RSA}). This is fast to 
      encode a message, but painfully slow at decoding.  A much faster, and 
      better approach has recently been invented  by  Blum  and Goldwasser. 
      This probabilistic Public Key system is also somewhat stronger  than
      RSA in some senses.   For  more  details  see  Brassard \cite{Brassard},  who 
      describes it as  ``the best that academia has had to offer thus  far''. 
      For both methods  the  keys  are  constructed  from  `strong'  primes
      to improve security.  

      \subsection{genkey.c}

      Public  Key  Cryptography  is  a two key encipherment system with the 
      very desirable feature that the encoding key  can  be  made  publicly 
      available, without weakening the strength of the cipher. This program 
      generates the `public' encoding key and `private' decoding keys  that 
      are necessary for both the original Rivest-Shamir-Adleman PK  system 
      and the superior Blum-Goldwasser method (see \cite{Brassard}). These keys 
      can take a long
      time to generate, as they are formed from very large  prime  numbers,
      which must be generated carefully for maximum security.  
              
      The program prompts for `size of each prime in bits'. The 
      security of the system depends on the  difficulty  of  factoring  the 
      encoding  `public'  key,  which is formed from two such large primes. The 
      largest numbers which  can  be  routinely  factored  using  the  most 
      powerful computers are 400 bits long (1992). So a minimum size of 
      256 bits for each prime gives adequate security (for now!) 

      After  this  program  has  run,  the  two  keys  are created in files 
      PUBLIC.KEY and PRIVATE.KEY.  

      \subsection{encode.c}

      Messages or files may be encoded with this program,  which  uses  the 
      `public'  encoding  key  from  the file PUBLIC.KEY,  generated by the 
      program {\em genkey},  which must have  been  run  prior  to  using  this 
      program.  When run the user is  prompted  for  a  file  to  encipher.  
      Either  give  the  name  of  a text file,  or press return to enter a 
      message directly from the keyboard.  In the former case  the  encoded 
      output  is sent to a file with the same name,  but with the extension 
      .RSA.  In the latter case a prompt is issued for an  output  filename, 
      which  must  be  given.  Text  entered  from  the  keyboard  must  be 
      terminated by a CONTROL-Z (end-of-file character).  Type out the  encoded  file 
      and be impressed by how indecipherable it looks. 

      \subsection{decode.c}

      Messages or files encoded using the RSA system may be  decoded  using 
      this  program,  which  uses  the `private' decoding key from the file 
      PRIVATE.KEY generated by the program {\em genkey} which  must  have  been 
      run at some stage prior to using this program.  

      When  run,  the  user  is  prompted  for  the  name of the file to be 
      decoded.  Type in the filename (without an extension  -- the  program 
      will  assume  the extension .RSA) and press return.  Then the user is 
      asked for an output filename.  Either  supply  a  filename  or  press 
      return, in which case the decoded output will be sent straight to the 
      screen.  A problem with the RSA system becomes immediately apparent -- 
      decoding takes a very long time! This is particularly true for larger 
      key sizes and long messages.  

      \subsection{enciph.c}

      This program works in an identical fashion to the  program  `encode', 
      except that it prompts for a random seed before encrypting the data.
      This random seed is then used internally to generate a larger random 
      number. The encryption process depends on this random number, which
      means that the same data will not necessarily produce the same 
      cipher-text, which is one of the strengths of this approach. As well as 
      creating a file with a .BLG extension containing the encrypted data,
      a second small file (with the .KEY extension) is also produced.


      \subsection{deciph.c}

      This program works in an identical fashion to the  program  `decode'.  
      However it has the advantage that it runs much more quickly. There will
      be a significant initial delay while a rather complex calculation 
      is carried out. This uses the private key and the data in the .KEY file
      to recover the large random number used in the encryption process. 
      Thereafter deciphering is as fast as encipherment.

      \subsection{keyids.c}

      Okamoto's Identity based key exchange algorithm \cite{Okamoto} requires 
      a large RSA type modulus $n=p.q$, and a small `primitive root' of both 
      $p$ and $q$ (for which the full factorisations of $p-1$ and $q-1$ 
      are needed). This program uses McCurley's construction \cite{McCurley} 
      to generate such an $n$, using $16$ as the fixed root. This ensures that 
      the underlying key exchange is provably as difficult to break as it is to 
      factor $n$.  

      Next the program requests an identifying string for each user of the 
      system, and `signs' it (by extracting its cube root {\em mod n}) 
      to create an unforgeable identity. The values of $p$ and $q$ can 
      then optionally be discarded, to prevent any other valid identities 
      being created, or else retained for future use.
      Finally each user is equipped with a file containing $n$, their own 
      unique identifying string, and its unforgeable signature.

      \section{``flash'' Programs}

      Several programs demonstrate the use of {\em flash} variables.  One gives 
      an implementation of Gaussian elimination to solve a  set  of  linear 
      equations,  involving  notoriously  ill-conditioned Hilbert matrices.  
      Others show how rational arithmetic can be used to  approximate  real 
      arithmetic,  in,  for  example  the calculation of roots and $\pi$.  The 
      former program detected an error in the value for the square root  of 
      5 given in Knuth \cite[appendix A]{Knuth81}. The correct value is 

       $$ 2.23606\ 79774\ 99789\ 69640\ 91736\ 68731\ {\bf 2}7623\ 54406 $$ 
    
      The error is in the tenth last digit, which is a 2, and not a 1.

      The  {\em roots} program runs particularly fast when calculating the square 
      roots of single precision integers,  as a simple  form  of  continued 
      fraction generator can be used \cite{Scott87}. In one test  the  golden 
      ratio  $(1+\sqrt{5})/2$  was calculated to 100,000 decimal places in 
      3 hours of CPU time on a VAX11/780.  

      The `sample' program was used to calculate $\pi$ correct to 1000 decimal 
      places, taking less than a minute on a 25MHz 80386-based IBM PC to do so.

      \subsection{roots.c}

      This program calculates the square root of  an  input  number,  using 
      Newtons method. Try it to calculate the square root of two. The 
      accuracy  obtained  depends  on  the  size  of  the  flash variables, 
      specified in the initial call to {\bf mirsys}.  The tendency of flash arithmetic to 
      prefer  simple  numbers  can be illustrated by requesting,  say,  the 
      square root of 7.  The program calculates this value and then squares 
      it,  to give 7 again exactly.  On your  pocket  calculator  the  same 
      result  will only be obtained if clever use is made of extra (hidden) 
      guard digits.  


      \subsection{hilbert.c}

      Traditionally the inversion of `Hilbert' matrices is  regarded  as  a 
      tough test for any system of arithmetic. This programs solves the set 
      of linear equations $H.x = b$, where $H$ is a Hilbert matrix and $b$ is the 
      vector  [1,1,1,1,....1],  using  the  classical  Gaussian Elimination 
      method.  

      \subsection{sample.c}

      This program is the same as that used by Brent \cite{Brent78} to  demonstrate 
      some  of  the  capabilities  of his Fortran Multiprecision arithmetic 
      package. It calculates $\pi$, $\exp(\pi.\sqrt{163/9})$ and 
      $\exp(\pi.\sqrt{163})$.  


      \subsection{ratcalc.c}

      As a comprehensive and useful demonstration of flash arithmetic  this 
      program simulates a standard full-function scientific calculator. Its 
      unique feature (besides its 36-digit accuracy) is its ability to work
      directly with fractions, and to handle mixed  calculations  involving
      both fractions and decimals. By using  this  program  the  user  will
      quickly  get  a feel for flash arithmetic and its capabilities.  Note
      that this program contains some non-portable  code  (screen  handling
      routines) that must be tailored to each individual  computer/terminal
      combination.  


\cleardoublepage
\chapter{The MIRACL routines}


      Note: In these routines a big parameter can also be used wherever a 
            flash is specified, but not visa-versa. Further information may 
            be gleaned from the (lightly) commented source code.  

\section{Low level routines}

\subsection{absol}

\begin{tabbing}
ggggggggggggggggggggg\= \kill
      Function:      \>void {\bf absol}(x,y)    \\
                     \>flash x,y;               \\
      \ \\
      Module:        \>mrcore.c                 \\
      \ \\
      Description:   \>Gives absolute value of a big or flash number. \\
      \ \\
      Parameters:    \>Two big/flash variables $x$ and $y$. On exit $y=|x|$. \\  
      \ \\
      Return value:  \>None \\
      \ \\
      Restrictions:  \>None \\

\end{tabbing}

\subsection{add}

\begin{tabbing}
ggggggggggggggggggggg\= \kill

      Function:      \>void {\bf add}(x,y,z)   \\  
                     \>big x,y,z;\\
      \ \\
      Module:        \>mrarth0.c \\
      \ \\
      Description:   \>Adds two big numbers. \\
      \ \\
      Parameters:    \>Three big numbers $x$, $y$ and $z$. On exit $z=x+y$.\\
      \ \\
      Return value:  \>None \\
      \ \\
      Restrictions:  \>None \\
      \ \\
      Example:       \>add(x,x,x); /* This doubles the value of $x$. */ \\

\end{tabbing}

\subsection{brand}

\begin{tabbing}
ggggggggggggggggggggg\= \kill

      Function:      \>int {\bf brand}()  \\
      \ \\
      Module:        \>mrcore.c   \\
      \ \\
      Description:   \>Generates random integer number  \\
      \ \\
      Parameters:    \>None \\
      \ \\
      Return Value:  \>A random integer number  \\
      \ \\
      Restrictions:  \>First use must be preceded by an initial call to \\
                     \>irand().\\

\end{tabbing}


\pagebreak

\subsection{cinnum}

\begin{tabbing}
ggggggggggggggggggggg\= \kill

      Function:      \>int {\bf cinnum}(x,f)  \\
                     \>flash x;  \\
                     \>FILE *f;  \\
      \ \\
      Module:        \>mrio2.c \\
      \ \\
      Description:   \>
                     \parbox[t]{3in}
                     {Inputs a flash number from the keyboard or a file,  
                     using as number base the current value of the 
                     global variable IOBASE. Flash numbers can be entered 
                     using either a slash `/' to indicate numerator and 
                     denominator, or with a radix point.} \\ 
      \ \\ 
      Parameters:    \>
                     \parbox[t]{3in}
                     {A big/flash number $x$ and a file descriptor $f$. For 
                     input from the keyboard specify $f$ as {\em stdin}, otherwise 
                     as the descriptor of some other opened file. 
                     To force input of a fixed number of 
                     bytes, set global INPLEN to the required number,
                     just before calling {\bf cinnum}.}   \\
      \ \\
      Return value:  \>The number of input characters.   \\
      \ \\
      Restrictions:  \>None        \\
      \ \\
      Example:       \>    IOBASE=256;  \\
                     \>    INPLEN=25; /* This inputs 25 bytes from $fp$ and */ \\
                     \>    cinnum(x,fp);  /* converts them into big number $x$ */\\

\end{tabbing}
\pagebreak
\subsection{cinstr}

\begin{tabbing}
ggggggggggggggggggggg\= \kill

      Function:      \>int {\bf cinstr}(x,s) \\
                     \>flash x; \\
                     \>char *s; \\
      \ \\
      Module;        \>mrio2.c \\
      \ \\
      Description:   \>
                     \parbox[t]{3 in}
                     {Inputs a flash number from a character string, using as
                      number base the current value of the global variable 
                      IOBASE. Flash numbers can be input using a slash `/' to
                      indicate numerator and denominator, or with a radix 
                      point.} \\
      \ \\
      Parameters:     \>
                      \parbox[t]{3 in}
                      {A big/flash number $x$ and a string $s$. } \\
      \ \\
      Return value:   \>The number of input characters. \\
      \ \\
      Restrictions:   \>None \\
      \ \\
      Example:        \>/* input large hex number into big x */ \\
                      \>IOBASE=16; \\
                      \>cinstr(x,``AF12398065BFE4C96DB723A'');\\
\end{tabbing}
              
 
\subsection{compare}

\begin{tabbing}
ggggggggggggggggggggg\= \kill

      Function:      \>int {\bf compare}(x,y)  \\
                     \>big x,y;  \\
\ \\
      Module:        \>mrcore.c    \\
\ \\
      Description:   \>Compares two big numbers.    \\
      \ \\
      Parameters:    \>Two big numbers $x$ and $y$.  \\
      \ \\
      Return value:  \>Returns $+1$ if $x>y$, returns 0 if $x=y$, \\
                     \>returns $-1$ if $x<y$.\\
      \ \\
      Restrictions:  \>None        \\

\end{tabbing}
\pagebreak
\subsection{convert}

\begin{tabbing}
ggggggggggggggggggggg\= \kill


      Function:      \>void {\bf convert}(n,x)  \\
                     \>int n;                   \\
                     \>big x;                   \\
      \ \\
      Module:        \>mrcore.c \\
      \ \\
      Description:   \>Convert an integer number to big number format. \\
      \ \\
      Parameters:    \>An integer $n$ and a big number $x$.  \\
      \ \\
      Return value:  \>None \\
      \ \\
      Restrictions:  \>None \\

\end{tabbing}

\subsection{copy}

\begin{tabbing}
ggggggggggggggggggggg\= \kill

      Function:      \>void {\bf copy}(x,y)   \\
                     \>flash x,y;\\
      \ \\
      Module:        \>mrcore.c  \\
      \ \\
      Description:   \>Copies a big or flash number to another. \\
      \ \\
      Parameters:    \>
                     \parbox[t]{3in}
                     {Two big or flash numbers $x$ and $y$. On exit $y=x$. 
                     Note that if $x$ and $y$ are the same variable, no 
                     operation is performed.} \\
      \ \\
      Return value:  \>None  \\
      \ \\
      Restrictions:  \>None   \\

\end{tabbing}

\pagebreak

\subsection{cotnum}

\begin{tabbing}
ggggggggggggggggggggg\= \kill

      Function:      \>int {\bf cotnum}(x,f)\\
                     \>flash x;  \\
                     \>FILE *f;  \\
      \ \\
      Module:        \>mrio2.c   \\
      \ \\
      Description:   \>
                     \parbox[t]{3in}
                     {Output a big or flash number to the screen or to a file,
                     using as number base the value currently assigned to the
                     global variable IOBASE. A flash number will be converted
                     to radix-point representation if the global variable
                     POINT=ON. Otherwise it will be output as a fraction.}  \\
      \ \\
      Parameters:    \>
                     \parbox[t]{3in}
                     {A big/flash number $x$ and a file descriptor $f$. If $f$ is
                     {\em stdout} then output will be to the screen, otherwise to
                     the file opened with descriptor $f$.}\\
      \ \\                                                    
      Return value:  \>Number of output characters.\\
      \ \\
      Restrictions:  \>None\\
      \ \\
      Example:       \>IOBASE=16;  \\
                     \>cotnum(x,fp);\\
      \ \\
                     \>
                     \parbox[t]{3in}
                     {This outputs $x$ in hex, 
                     to the file associated with {\em fp}.} \\
\end{tabbing}

\pagebreak
\subsection{cotstr}
\begin{tabbing}
ggggggggggggggggggggg\= \kill
      Function:      \>int {\bf cotstr}(x,s) \\
                     \>flash x; \\
                     \>char *s; \\
      \ \\
      Module:        \>mrio2.c \\
      \ \\
      Description:   \>
                     \parbox[t]{3in}
                     {Output a big or flash number to the specified string,
                     using as number base the value currently assigned to the
                     global variable IOBASE. A flash number will be converted
                     to radix-point representation if the global variable
                     POINT=ON. Otherwise it will be output as a fraction.}  \\
      \ \\
      Parameters:    \>
                     \parbox[t]{3 in}
                     {A big/flash number $x$ and a string $s$. On exit $s$ 
                      will contain a representation of the number $x$.} \\
      \ \\
      Return value:  \>Number of output characters.\\
      \ \\
      Restrictions:  \>
                     \parbox[t]{3 in}
                     {Note that there is nothing to prevent this routine from
                      overflowing the limits of the user supplied character 
                      array $s$, causing obscure runtime problems. It is the 
                      programmers responsibility to
                      ensure that $s$ is big enough to contain the number 
                      output to it. Alternatively use the internally declared 
                      global string MR\_IOBUFF, which is of size MR\_IOBSIZ 
                      (specified in {\em mirdef.h}). If this array overflows 
                      an error message {\bf will} be generated and the program 
                      aborted.} \\
\end{tabbing}

\pagebreak
\subsection{decr}

\begin{tabbing}
ggggggggggggggggggggg\= \kill

      Function:      \>void {\bf decr}(x,n,z) \\
                     \>big x,z;   \\
                     \>int n;     \\
      \ \\
      Module:        \>mrarth0.c   \\
      \ \\
      Description:   \>Decrement a big number by an integer amount. \\
      \ \\
      Parameters:    \>Big numbers $x$ and $z$, and integer $n$.\\
                     \>On exit $z=x-n$. \\
      \ \\
      Return value:  \>None \\
      \ \\
      Restrictions:  \>None  \\
\end{tabbing}

\subsection{divide}

\begin{tabbing}
ggggggggggggggggggggg\= \kill

      Function:      \>void {\bf divide}(x,y,z)  \\
                     \>big x,y,z; \\
      \ \\
      Module:        \>mrarth2.c \\
      \ \\
      Description:   \>Divides one big number by another.   \\
      \ \\
      Parameters:    \>
                     \parbox[t]{3in}
                     {Three big numbers $x$, $y$ and $z$. On exit $z=x/y$; $x=x \bmod y$.
                     The quotient only is returned if $x$ and $z$ are the same, the
                     remainder only if $y$ and $z$ are the same.} \\
      \ \\
      Return value:  \>None     \\
      \ \\
      Restrictions:  \>
                     \parbox[t]{3 in}
                     {Parameters $x$ and $y$ must be different, and $y$ must 
                     be non-zero.} \\
      \ \\
      Example:       \>divide(x,y,y); \\
      \ \\
                     \>
                     \parbox[t]{3 in}
                     {This sets $x$ equal to the remainder when $x$ is
                     divided by $y$. The quotient is not returned.} 
\end{tabbing}
\pagebreak
\subsection{exsign}
\begin{tabbing}
ggggggggggggggggggggg\= \kill
      Function:      \>int {\bf exsign}(x)    \\
                     \>flash x; \\
      \ \\
      Module:        \>mrcore.c \\
      \ \\
      Description:   \>Extracts the sign of a big/flash number.    \\
      \ \\
      Parameters:    \>A big/flash number $x$. \\
      \ \\
      Return value:  \>The sign of $x$, i.e. $-1$ if $x$ is negative, $+1$ if $x$ is \\
                     \>zero or positive.  \\
      \ \\
      Restrictions:  \>None \\

\end{tabbing}


\subsection{getdig}

\begin{tabbing}
ggggggggggggggggggggg\= \kill

      Function:      \>int {\bf getdig}(x,i) \\
                     \>big x; \\
                     \>int i; \\
      \ \\
      Module:        \>mrcore.c \\
      \ \\
      Description:   \>Extracts a digit from a big number. \\
      \ \\
      Parameters:    \>A big number $x$, and the required digit $i$. \\
      \ \\
      Return value:  \>The value of the requested digit. \\
      \ \\
      Restrictions:  \>Returns rubbish if required digit does not exist. \\

\end{tabbing}
\pagebreak
\subsection{igcd}

\begin{tabbing}
ggggggggggggggggggggg\= \kill

      Function:      \>int {\bf igcd}(x,y) \\
                     \>int x,y; \\
      \ \\
      Module:        \>mrcore.c \\
      \ \\
      Description:   \>Calculates the Greatest Common Divisor of two  \\
                     \>integers using Euclids Method. \\
      \ \\
      Parameters:    \>Two integers $x$ and $y$   \\
      \ \\
      Return value:  \>The GCD of $x$ and $y$     \\

\end{tabbing}

\subsection{incr}
\begin{tabbing}
ggggggggggggggggggggg\= \kill
      Function:      \>void {\bf incr}(x,n,z) \\
                     \>big x,z; \\
                     \>int n; \\
      \ \\
      Module:        \>mrarth0.c \\
      \ \\
      Description:   \>Increment a big variable. \\
      \ \\
      Parameters:    \>Big numbers $x$ and $z$, and an integer $n$. \\
                     \>On exit $z=x+n$. \\
      \ \\
      Return value:  \>None \\
      \ \\
      Restrictions:  \>None  \\
      \ \\
      Example:       \>incr(x,2,x);  /* This increments x by 2. */ \\
\end{tabbing}
\pagebreak
\subsection{innum}
\begin{tabbing}
ggggggggggggggggggggg\= \kill
      Function:      \>int {\bf innum}(x,f) \\
                     \>flash x; \\
                     \>FILE *f; \\
      \ \\
      Module:        \>mrio1.c \\
      \ \\
      Description:   \>
                     \parbox[t]{3in}
                     {Inputs a big or flash number from a file or the keyboard,
                     using as number base the value specified in the initial
                     call to {\bf mirsys}.
                     Flash numbers can be entered using either
                     a slash `/' to indicate numerator and denominator, or
                     with a radix point.} \\ 
      \ \\
      Parameters:    \>
                     \parbox[t]{3in}
                     {A big/flash number $x$ and a file descriptor $f$. For input
                     from the keyboard specify $f$ as {\em stdin}, otherwise as the
                     descriptor of some other opened file.} \\
      \ \\
      Return value:  \>The number of characters input. \\
      \ \\
      Restrictions:  \>
                     \parbox[t]{3in}
                     {The number base specified in {\bf mirsys} must be less
                     than or equal to 256. If not use {\bf cinnum} instead.} \\
       \ \\
       Hint:         \>
                     \parbox[t]{3in}
                     {For fastest inputting of Ascii text to a big number \'a la
                      Public Key programs, and if a full-width base is 
                      possible, use {\em mirsys(...,256);} initially. This has 
                      the same effect as specifying {\em mirsys(...,0);},
                      except that now Ascii bytes may be input directly via 
                      {\em innum(x,fp);}
                      without the time-consuming change of base implicit in
                      the use of {\bf cinnum}.} \\


\end{tabbing}

\pagebreak

\subsection{insign}

\begin{tabbing}
ggggggggggggggggggggg\= \kill


      Function:      \>void {\bf insign}(s,x) \\
                     \>int s; \\
                     \>flash x; \\
      \ \\
      Module:        \>mrcore.c \\
      \ \\
      Description:   \>Forces a big/flash number to a particular sign. \\
      \ \\
      Parameters:    \>A big/flash number $x$, and the sign $s$ that it is \\
                     \>to take. On exit $x=s.|x|$. \\
      \ \\
      Return value:  \>None \\
      \ \\
      Restrictions:  \>None \\
      \ \\
      Example:       \>insign(PLUS,x);   /* force $x$ to be positive */  \\

\end{tabbing}

\subsection {instr}
\begin{tabbing}
ggggggggggggggggggggg\= \kill
      Function:      \>int {\bf instr}(x,s) \\
                     \>flash x; \\
                     \>char *s; \\
      \ \\
      Module:        \>mrio1.c \\
      \ \\
      Description:   \>
                     \parbox[t]{3 in}
                     {Inputs a big or flash number from a character string,
                     using as number base the value specified in the initial
                     call to {\bf mirsys}.
                     Flash numbers can be entered using either
                     a slash `/' to indicate numerator and denominator, or
                     with a radix point.} \\
      \ \\
      Parameters:    \>
                     \parbox[t]{3 in}
                     {A big/flash number $x$ and a character string $s$.} \\
      \ \\
      Return value:  \>The number of characters input. \\
      \ \\
      Restrictions:  \>
                     \parbox[t]{3in}
                     {The number base specified in {\bf mirsys} must be less
                     than or equal to 256. If not use {\bf cinstr} instead.} \\
\end{tabbing}
       

\subsection{irand}

\begin{tabbing}
ggggggggggggggggggggg\= \kill


      Function:      \>void {\bf irand}(seed) \\
                     \>long seed; \\
      \ \\
      Module:        \>mrcore.c \\
      \ \\
      Description:   \>
                     \parbox[t]{3in}
                     {Initializes random number system. 
                     Long integer types are used internally to yield a
                     generator with maximum period.} \\
      \ \\
      Parameters:    \>A long integer seed, which is used to start off the \\
                     \>random number generator. \\
      \ \\
      Return value:  \>None \\
      \ \\
      Restrictions:  \>None \\

\end{tabbing}

\subsection{lgconv}

\begin{tabbing}
ggggggggggggggggggggg\= \kill

      Function:      \>void {\bf lgconv}(ln,x) \\
                     \>long n; \\
                     \>big x; \\
      \ \\
      Module:        \>mrcore.c \\
      \ \\
      Description:   \>Converts a long integer to big number format \\
      \ \\
      Parameters:    \>A long integer $ln$ and a big number $x$  \\
      \ \\
      Return value:  \>None \\
      \ \\
      Restrictions:  \>None \\

\end{tabbing}
\pagebreak
\subsection{mad}

\begin{tabbing}
ggggggggggggggggggggg\= \kill


      Function:      \>void {\bf mad}(x,y,z,w,q,r) \\
                     \>big x,y,z,w,q,r; \\
      \ \\
      Module:        \>mrarth2.c \\
      \ \\
      Description:   \>
                     \parbox[t]{3in}
                     {Multiply add and divide big numbers. The initial product
                     is stored in a double-length internal variable to avoid
                     the possibility of overflow at this stage.} \\
      \ \\
      Parameters:    \>
                     \parbox[t]{3in}
                     {Six big numbers $x,y,z,w,q$ and $r$. On exit $q=(x.y+z)/w$ and
                     $r$ contains the remainder. If $w$ and $q$ are not distinct
                     variables then only the remainder is returned; if $q$ and $r$
                     are not distinct then only the quotient is returned. The
                     addition of $z$ is not done if $x$ and $z$ (or $y$ and $z$) are the
                     same.} \\
      \ \\
      Return value:  \>None \\
      \ \\
      Restrictions:  \>Parameters $w$ and $r$ must be distinct. The value  \\
                     \>of $w$ must not be zero. \\
      \ \\
      Example:       \>mad(x,x,x,w,x,x); /* $x=x^2/w$ */
\end{tabbing}

\subsection{mirexit}

\begin{tabbing}
ggggggggggggggggggggg\= \kill

      Function:      \> void {\bf mirexit}() \\
      \ \\
      Module:        \>mrcore.c \\
      \ \\
      Description:   \>
                     \parbox[t]{3 in}
                     {Cleans up after MIRACL, freeing all internal variables. 
                     A subsequent call to {\bf mirsys} will re-initialise the
                     MIRACL system.} \\
      \ \\
      Parameters:    \>None \\
      \ \\
      Return value:  \>None \\
      \ \\
      Restrictions:  \>Must be called after {\bf mirsys}.

\end{tabbing}
\pagebreak

\subsection{mirsys}

\begin{tabbing}
ggggggggggggggggggggg\= \kill


      Function:      \>void {\bf mirsys}(nd,nb) \\
                     \>int nd,nb; \\
      \ \\
      Module:        \>mrcore.c \\
      \ \\
      Description:   \>
                     \parbox[t]{3in}
                     {Initialize the MIRACL system as described below. Must 
                     be called before attempting to use any other MIRACL 
                     routines.} \\  
      \ \\
                     \>(1) The error tracing mechanism is initialised. \\
                     \>(2) the number of computer words to use for each  \\
                     \>    big/flash number is calculated from $nd$ and $nb$. \\  
                     \>(3) Sixteen big work variables (four of them double \\
                     \>    length) are initialised. \\  
                     \>(4) Certain global variables are given default initial\\
                     \>    values. \\
                     \>(5) The random number generator is started by \\
                     \>    calling {\bf irand(0L)}. \\
      \ \\
      Parameters:    \>
                     \parbox[t]{3in}
                     {The number of digits $nd$ to use for each big/flash 
                     variable and the number base $nb$. If $nd$ is negative it 
                     is taken as indicating the size of big/flash numbers 
                     in 8-bit bytes.} \\  
      \ \\
      Return value:  \>None \\
      \ \\
      Restrictions:  \>
                     \parbox[t]{3in}
                     {The number base $nb$ should normally be greater than 1 
                     and less than or equal to MAXBASE. A base of 0 implies
                     that the `full-width' number base should be used.
                     The number of digits $nd$ must be less than a certain 
                     maximum, depending on the value of MR\_SBITS and on
                     whether or not MR\_FLASH is defined. 
                     (See {\em mirdef.h}).} \\  
      \ \\

      Example:       \>mirsys(500,10); \\
      \ \\
                     \>This initializes the MIRACL system to use 500  \\
                     \>decimal digits for each big or flash number. \\

\end{tabbing}

\subsection{mirvar}

\begin{tabbing}
ggggggggggggggggggggg\= \kill

      Function:      \>flash {\bf mirvar}(iv) \\
                     \>int iv; \\
      \ \\
      Module:        \>mrcore.c \\
      \ \\
      Description:   \>
                     \parbox [t]{3 in}
                     {Initialises a big/flash variable by reserving a
                     suitable number of memory locations for it. This memory
                     may be released by a subsequent call to the standard C
                     function {\em free()}.} \\
      \ \\
      Parameters:    \>An integer initial value for the big/flash number. \\
      \ \\
      Return value:  \>A pointer to the reserved locations. \\
      \ \\
      Restrictions:  \>None \\
      \ \\
      Example:       \>flash x; \\
                     \>x=mirvar(1); \\
      \ \\
                     \>Creates a flash variable $x=1$. \\

\end{tabbing}

\subsection{multiply}

\begin{tabbing}
ggggggggggggggggggggg\= \kill


      Function:      \>void {\bf multiply}(x,y,z) \\
                     \>big x,y,z; \\
      \ \\
      Module:        \>mrarth2.c \\
      \ \\
      Description:   \>Multiplies two big numbers  \\
      \ \\
      Parameters:    \>Three big numbers $x,y$ and $z$. On exit $z=x.y$ \\
      \ \\
      Return value:  \>None \\
      \ \\
      Restrictions:  \>None \\

\end{tabbing}

\subsection{negate}

\begin{tabbing}
ggggggggggggggggggggg\= \kill


      Function:      \>void {\bf negate}(x,y) \\
                     \>flash x,y; \\
      \ \\
      Module:        \>mrcore.c \\
      \ \\
      Description:   \>Negates a big/flash number. \\
      \ \\
      Parameters:    \>Two big/flash numbers $x$ and $y$. On exit $y=-x$. \\
      \ \\
      Return value:  \>None \\
      \ \\
      Restrictions:  \>None. Note that {\bf negate(x,x)} is valid and sets $x=-x$.\\
      
\end{tabbing}

\subsection{normalise}
\begin{tabbing}
ggggggggggggggggggggg\= \kill

      Function:      \>int {\bf normalise}(x,y) \\
                     \>big x,y; \\
      \ \\
      Module:        \>mrarth2.c \\
      \ \\
      Description:   \>
                     \parbox[t]{3 in}
                     {Multiplies a big number such that its Most Significant
                     Word is greater than half the number base. If such a
                     number is used as a divisor by {\bf divide}, the 
                     division will be carried out faster. If many divisons
                     by the same divisor are required, it makes sense to
                     normalise the divisor just once beforehand.}\\
      \ \\
      Parameters:    \>Two big numbers $x$ and $y$. On exit $y=n.x$. \\
      \ \\
      Return value:  \>Returns $n$, the normalising multiplier. \\
      \ \\
      Restrictions:  \>Use with care. Used internally.\\
      \ \\
      Example:       \>See example program {\em pollard.c}.  \\

\end{tabbing}

\subsection{numdig}

\begin{tabbing}
ggggggggggggggggggggg\= \kill

      Function:      \>int {\bf numdig}(x) \\
                     \>big x; \\
      \ \\
      Module:        \>mrcore.c \\
      \ \\
      Description:   \>Calculates the number of digits in a big number. \\
      \ \\
      Parameters:    \>A big number $x$. \\
      \ \\
      Return value:  \>The number of digits in $x$. \\
      \ \\
      Restrictions:  \>None \\


\end{tabbing}


\subsection{otnum}

\begin{tabbing}
ggggggggggggggggggggg\= \kill


      Function:      \>int {\bf otnum}(x,f) \\
                     \>flash x; \\
                     \>FILE *f; \\
      \ \\
      Module:        \>mrio1.c \\
      \ \\
      Description:   \>
                     \parbox[t]{3in}
                     {Output a big or flash number to the screen or to a 
                      file, using as number base the value specified in the
                      initial call to {\bf mirsys}.
                     A flash number will be converted to radix-point
                     representation if the global variable POINT=ON. Otherwise
                     it will be output as a fraction.} \\
      \ \\
      Parameters:    \>
                     \parbox[t]{3in}
                     {A big/flash number $x$ and a file descriptor $f$. If $f$ is
                     {\em stdout} then output will be to the screen, otherwise to
                     the file opened with descriptor $f$.} \\
      \ \\
      Return value:  \>Number of output characters. \\
      \ \\
      Restrictions:  \>
                     \parbox[t]{3 in}
                     {The number base specified in {\bf mirsys} must be less 
                     than or equal to 256. If not, use {\bf cotnum} 
                     instead.} \\


\end{tabbing}

\pagebreak
\subsection{otstr}
\begin{tabbing}
ggggggggggggggggggggg\= \kill



      Function:      \>int {\bf otstr}(x,s) \\
                     \>flash x; \\
                     \>char *s; \\
      \ \\
      Module:        \>mrio1.c \\
      \ \\
      Description:   \>
                     \parbox[t]{3in}
                     {Output a big or flash number to the specified string, 
                      using as number base the value specified in the
                      initial call to {\bf mirsys}.
                     A flash number will be converted to radix-point
                     representation if the global variable POINT=ON. Otherwise
                     it will be output as a fraction.} \\
      \ \\
      Parameters:    \>
                     \parbox[t]{3 in}
                     {A big/flash number $x$ and a character string $s$. On 
                      exit $s$ will contain a representation of $x$.} \\
      \ \\
      Return value:  \>Number of output characters. \\
      \ \\
      Restrictions:  \>
                     \parbox[t]{3 in}
                     {The number base specified in {\bf mirsys} must be less 
                     than or equal to 256. If not, use {\bf cotstr} 
                     instead.
 
                     Note that there is nothing to prevent this routine from
                      overflowing the limits of the user supplied character 
                      array $s$, causing obscure runtime problems. It is the 
                      programmers responsibility to
                      ensure that $s$ is big enough to contain the number 
                      output to it. Alternatively use the internally declared 
                      global string MR\_IOBUFF, which is of size MR\_IOBSIZ 
                      (specified in {\em mirdef.h}). If this array overflows 
                      an error message {\bf will} be generated and the program 
                      aborted} \\
 
\end{tabbing}             
\pagebreak
\subsection{premult}

\begin{tabbing}
ggggggggggggggggggggg\= \kill

      Function:      \>void {\bf premult}(x,n,z) \\
                     \>int n; \\
                     \>big x,z; \\
      \ \\
      Module:        \>mrarth1.c \\
      \ \\
      Description:   \>Multiplies a big number by an integer \\
      \ \\
      Parameters:    \>Two big numbers $x$ and $z$, and an integer $n$. \\
                     \>On exit $z=n.x$ \\
      \ \\
      Return value:  \>None \\
      \ \\
      Restrictions:  \>None \\


\end{tabbing}

\subsection{putdig}

\begin{tabbing}
ggggggggggggggggggggg\= \kill

      Function:      \>void {\bf putdig}(n,x,i) \\
                     \>big x; \\
                     \>int i,n; \\
      \ \\
      Module:        \>mrcore.c \\
      \ \\
      Description:   \>Set a digit of a big number to a given value  \\
      \ \\
      Parameters:    \>A big number $x$, a digit number $i$, and its new \\
                     \>value $n$. \\
      \ \\
      Return value:  \>None \\
      \ \\
      Restrictions:  \>The digit indicated must exist. \\
      
\end{tabbing}

\pagebreak
\subsection{size}

\begin{tabbing}
ggggggggggggggggggggg\= \kill

      Function:      \>int {\bf size}(x) \\
                     \>big x; \\
      \ \\
      Module:        \>mrcore.c \\
      \ \\
      Description:   \>
                     \parbox[t]{3 in}
                     {Tries to convert big number to a simple integer.
                     Also useful for testing the sign of big/flash variable
                     as in: {\tt if (size(x)<0) ...}} \\
      \ \\
      Parameters:    \>A big number $x$. \\
      \ \\
      Return value:  \>
                     \parbox[t]{3in}
                     {The value of $x$ as an integer. If this is not possible
                     (because $x$ is too big) it returns the value plus or 
                     minus TOOBIG.} \\
      \ \\
      Restrictions:  \>None \\
                                          
\end{tabbing}

\subsection{subdiv}

\begin{tabbing}
ggggggggggggggggggggg\= \kill

      Function:      \>int {\bf subdiv}(x,n,z) \\
                     \>int n; \\
                     \>big x,z; \\
      \ \\
      Module:        \>mrarth1.c \\
      \ \\
      Description:   \>Divide a big number by an integer. \\
      \ \\
      Parameters:    \>Two big numbers $x$ and $z$, and an integer $n$. \\
                     \>On exit $z=x/n$. \\
      \ \\
      Return value:  \>The integer remainder. \\
      \ \\
      Restrictions:  \>The value of $n$ must not be zero. \\

\end{tabbing}

\pagebreak

\subsection{subtract}

\begin{tabbing}
ggggggggggggggggggggg\= \kill

      Function:      \>void {\bf subtract}(x,y,z) \\
                     \>big x,y,z; \\
      \ \\
      Module:        \>mrarth0.c \\
      \ \\
      Description:   \>Subtracts two big numbers. \\
      \ \\
      Parameters:    \>Three big numbers $x$, $y$ and $z$. On exit $z=x-y$. \\
      \ \\
      Return value:  \>None \\
      \ \\
      Restrictions:  \>None
\end{tabbing}



\subsection{zero}

\begin{tabbing}
ggggggggggggggggggggg\= \kill

      Function:      \>void {\bf zero}(x) \\
                     \>flash x; \\
      \ \\
      Module:        \>mrcore.c \\
      \ \\
      Description:   \>Sets a big or flash number to zero    \\
      \ \\
      Parameters:    \>A big or flash number $x$. \\
      \ \\
      Return value:  \>None \\
      \ \\
      Restrictions:  \>None \\

\end{tabbing}
\pagebreak
\section{Advanced Arithmetic Routines}

\subsection{bigdig}

\begin{tabbing}
ggggggggggggggggggggg\= \kill

      Function:      \>void {\bf bigdig}(n,b,x)  \\
                     \>int n,b; \\
                     \>big x;   \\
      \  \\
      Module:        \>mrrand.c \\
      \ \\
      Description:   \>Generates a big random number of given length.\\
      \ \\
      Parameters:    \>
                     \parbox[t]{3in}
                     {A big number $x$ and two integers $n$ and $b$. On 
                     exit $x$ contains a big random number $n$ digits long 
                     to base $b$.} \\
      \ \\
      Return value:  \>None \\
      \ \\
      Restrictions:  \>None \\
      \ \\
      Example:       \>bigdig(100,10,x);   \ \\
                     \>This generates a 100 decimal digit random number \\
\end{tabbing}


\subsection{bigrand}

\begin{tabbing}
ggggggggggggggggggggg\= \kill

      Function:      \>void {\bf bigrand}(w,x)  \\
                     \>big w,x;  \\
      \ \\
      Module:        \>mrrand.c  \\
      \ \\
      Description:   \>Generates a big random number. \\
      \ \\
      Parameters:    \>Two big numbers $w$ and $x$. On exit $x$ is a big \\
                     \>random number in the range $1<x<w$. \\
      \ \\
      Return value:  \>None \\
      \ \\
      Restrictions:  \>None \\

\end{tabbing}
\pagebreak
\subsection{crt}
\begin{tabbing}
ggggggggggggggggggggg\= \kill
      Function:      \>void {\bf crt}(rem,x) \\
                     \>big *rem; \\
                     \>big x; \\
      \ \\
      Module:        \>mrcrt.c \\
      \ \\
      Description:   \>
                     \parbox[t]{3 in}
                     {Applies Chinese Remainder Thereom.} \\
      \ \\
      Parameters:    \>
                     \parbox[t]{3 in}
                     {On exit $x$ contains the big number which yields 
                     the given big remainders $rem$ when it is divided by the 
                     big moduli
                     specified in a prior call to {\bf crt\_init}.} \\
      \ \\
      Return value:  \>None \\
      \ \\
      Restrictions:  \>The routine {\bf crt\_init} must be called first. \\
\end{tabbing}

\subsection{crt\_end}
\begin{tabbing}
ggggggggggggggggggggg\= \kill
      Function:      \>void {\bf crt\_end}() \\
      \ \\
      Module:        \>mrcrt.c \\
      \ \\
      Description:   \>
                     \parbox[t]{3 in}
                     {Cleans up after an application of the Chinese Remainder
                      Thereom. Must be called before the CRT is applied again} \\
      \ \\
      Parameters:    \>None \\
      \ \\
      Return value:  \>None \\
      \ \\
      Restrictions:  \>None \\
\end{tabbing}
      
\pagebreak
\subsection{crt\_init}
\begin{tabbing}
ggggggggggggggggggggg\= \kill
      Function:      \>bool {\bf crt\_init}(np,m) \\
                     \>int np; \\
                     \>big *m; \\
      \ \\
      Module:        \>mrcrt.c \\
      \ \\
      Description:   \>
                     \parbox[t]{3 in}
                     {Initialises for an application of the Chinese Remainder
                      Thereom. Some internal workspace is allocated.} \\
      \ \\
      Parameters:    \>
                     \parbox[t]{3 in}
                     {The number of co-prime moduli $np$, and an array of
                      at least two big moduli $m[\ ]$} \\
      \ \\
      Return value:  \>TRUE if all went well, FALSE if there was a problem. \\
      \ \\
      Restrictions:  \>None \\
\end{tabbing}
\subsection{egcd}

\begin{tabbing}
ggggggggggggggggggggg\= \kill
  Function:      \>int {\bf egcd}(x,y,z) \\
                     \>big x,y,z; \\
      \ \\
      Module:        \>mrgcd.c \\
      \ \\
      Description:   \>Calculates the Greatest Common Divisor of two  \\
                     \>big numbers. \\
      \ \\
      Parameters:    \>Three big numbers $x, y$ and $z$. \\
                     \>On exit $z=\gcd(x,y)$ \\
      \ \\
      Return value:  \>GCD as integer, if possible, otherwise TOOBIG \\
      \ \\
      Restrictions:  \>None \\
\end{tabbing}
\pagebreak
\subsection{expb2}
\begin{tabbing}
ggggggggggggggggggggg\= \kill
      Function:      \>void {\bf expb2}(n,x) \\
                     \>big x;    \\
                     \>int n;    \\
      \ \\
      Module:        \>mrarth3.c    \\
      \ \\
      Description:   \>Calculates 2 to the power of an integer. \\
      \ \\
      Parameters:    \>A big number $x$ and an integer $n$. On exit $x=2^{n}$. \\     
      \ \\
      Return value:  \>None \\
      \ \\
      Restrictions:  \>None   \\
      \ \\
      Example:       \>expb2(756839,x); \\
                     \>decr(x,1,x); \\
                     \>IOBASE=10; \\
                     \>cotnum(x,stdout); \\
                     \>
                     \parbox[t]{3in}
                     {This calculates and prints out the largest known prime 
                     number (on a true 32-bit computer with lots of memory!
                     -- for example a VAX 11/780)}
\end{tabbing}
\pagebreak
\subsection{fastmult}
\begin{tabbing}
ggggggggggggggggggggg\= \kill
      Function:      \>void {\bf fastmult}(x,y,z) \\
                     \>big x,y,z;   \\

      \ \\
      Module:        \>mrfast.c       \\
      \ \\
      Description:   \>Multiplies two big numbers, using the Fast Fourier\\ 
                     \>Method. See \cite{Pollard}.   \\
      \ \\
      Parameters:    \>Three big numbers $x, y$ and $z$. On exit $z=x.y$\\
      \ \\
      Return value:  \>None \\
      \ \\
      Restrictions:  \>
                     \parbox[t]{3 in}
                     {Should only be used on a 32-bit computer when $x$
                      and $y$ are very large, at least 1000 decimal digits.} \\ 

         
\end{tabbing}
\subsection{gprime}

\begin{tabbing}
ggggggggggggggggggggg\= \kill


      Function:      \>void {\bf gprime}(n) \\
                     \>int n; \\
      \ \\
      Module:        \>mrprime.c \\
      \ \\
      Description:   \>
                     \parbox[t]{3in}
                     {Generates an array of all prime numbers up to a certain
                     limit into the global PRIMES, terminated by zero. This
                     array is used internally by the routines {\bf isprime} and 
                     {\bf nxprime}.} \\
      \ \\
      Parameters:    \>
                     \parbox[t]{3in}
                     {A positive integer $n$ indicating the maximum prime
                     number to be generated. If $n=0$ the PRIMES array is 
                     deleted.} \\
      \ \\
      Return value:  \>None \\
      \ \\
      Restrictions:  \>None \\

\end{tabbing}
\subsection{invers}

\begin{tabbing}
ggggggggggggggggggggg\= \kill

      Function:      \>int {\bf invers}(x,y) \\
                     \>int x,y; \\
      \ \\
      Module:        \>mrsmall.c \\
      \ \\
      Description:   \>
                     \parbox[t]{3 in}
                     {Calculates the inverse of an integer modulus a
                     co-prime integer}     \\
      \ \\
      Parameters:    \>An integer $x$ and a co-prime integer $y$  \\
      \ \\
      Return value:  \>$1/x \bmod y$  \\
      \ \\
      Restrictions:  \>
                     \parbox[t]{3 in}
                     {Result unpredictable if $x$ and $y$ not
                     co-prime}   \\

\end{tabbing}

\subsection{isprime}

\begin{tabbing}
ggggggggggggggggggggg\= \kill
      Function:      \>bool {\bf isprime}(x) \\
                     \>big x; \\
      \ \\
      Module:        \>mrprime.c \\
      \ \\
      Description:   \>
                     \parbox[t]{3in}
                     {Tests whether or not a big number is prime using a
                     probabilistic primality test. The number is assumed
                     to be prime if it passes this test MR\_NTRY times, where
                     MR\_NTRY is a global variable with a default initialisation
                     in routine {\bf mirsys.}} \\
                     \>
                     \parbox[t]{3in}
                     {NOTE: This routine first test divides $x$ by the list of
                     small primes stored in the global array PRIMES. The
                     testing of larger primes will be significantly faster
                     in many cases if this list is increased. See {\bf gprime()}. 
                     By default only the small primes less than 1000 are
                     used.} \\
      \ \\
      Parameters:    \>A big number $x$. \\
      \ \\
      Return value:  \>Returns the boolean value TRUE if $x$ is (almost \\
                     \>certainly) prime, otherwise FALSE. \\
      \ \\
      Restrictions:  \>None

\end{tabbing}


\subsection{jack}

\begin{tabbing}
ggggggggggggggggggggg\= \kill

      Function:      \>int {\bf jack}(x,n) \\
                     \>big x,n; \\
      \ \\
      Module:        \>mrjack.c \\
      \ \\
      Description:   \>
                     \parbox[t]{3in}
                     {Calculates the value of the Jacobi symbol. 
                      See \cite{Reisel}. }\\
      \ \\
      Parameters:    \>Two big numbers $x$ and $n$ \\
      \ \\
      Return value:  \>
                     \parbox[t]{3in}
                     {The value of $(x/n)$ as +1 or -1, or 0 if symbol 
                      undefined} \\
      \ \\
      Restrictions:  \>None \\

\end{tabbing}
\subsection{logb2}

\begin{tabbing}
ggggggggggggggggggggg\= \kill

      Function:      \>int {\bf logb2}(x) \\
                     \>big x; \\
      \ \\
      Module:        \>mrarth3.c \\
      \ \\
      Description:   \>Calculates the approximate integer log to the base \\
                     \>2 of a big number (in fact the number of bits in it.) \\
      \ \\
      Parameters:    \>A big number $x$. \\
      \ \\
      Return value:  \>Number of bits in $x$ \\
      \ \\
      Restrictions:  \>None \\

\end{tabbing}
\pagebreak
\subsection{nroot}

\begin{tabbing}
ggggggggggggggggggggg\= \kill

      Function:      \>bool {\bf nroot}(x,n,z) \\
                     \>big x,z; \\
                     \>int n; \\
      \ \\
      Module:        \>mrarth3.c \\
      \ \\
      Description:   \>
                     \parbox[t]{3 in}
                     {Extracts lower approximation to a root of a big number.}\\
      \ \\
      Parameters:    \>
                     \parbox[t]{3 in}
                     {Two big numbers $x$ and $z$, and an integer $n$.
                     On exit $z=\lfloor x^{1/n} \rfloor $.} \\
      \ \\
      Return value:  \>
                     \parbox[t]{3 in}
                     {Returns the boolean value TRUE if the root found is 
                     exact, otherwise returns FALSE.} \\
      \ \\
      Restrictions:  \>
                     \parbox[t]{3 in}
                     {The value of $n$ must be positive. If $x$ is negative, 
                      then $n$ must be odd.} \\

\end{tabbing}
\subsection{nxprime}

\begin{tabbing}
ggggggggggggggggggggg\= \kill

      Function:      \>void {\bf nxprime}(w,x) \\
                     \>big w,x; \\
      \ \\
      Module:        \>mrprime.c \\
      \ \\
      Description:   \>Find next prime number. \\
      \ \\
      Parameters:    \>Two big numbers $w$ and $x$. \\
                     \>On exit $x$ contains the next prime number greater \\
                     \>than $w$. \\
      \ \\
      Return value:  \>None \\
      \ \\
      Restrictions:  \>None \\

\end{tabbing}
\pagebreak

\subsection{power}

\begin{tabbing}
ggggggggggggggggggggg\= \kill
              
      Function:      \>void {\bf power}(x,n,z,w) \\
                     \>int n; \\
                     \>big x,z,w; \\
      \ \\
      Module:        \>mrarth3.c \\
      \ \\
      Description:   \>Raise a big number to an integer power. \\
      \ \\
      Parameters:    \>
                     \parbox[t]{3 in}
                     {Two big numbers $x$ and $z$, and an integer $n$. On exit
                     $w=x^n$. If $w$ and $z$ are distinct, then $w=x^n \bmod z$
                     }  \\
      \ \\
      Return value:  \>None \\
      \ \\
      Restrictions:  \>The value of $n$ must be positive \\
      
\end{tabbing}

\subsection{powltr}

\begin{tabbing}
ggggggggggggggggggggg\= \kill

      Function:      \>void {\bf powltr}(x,y,z,w) \\
                     \>int x; \\
                     \>big y,z,w; \\
      \ \\
      Module:        \>mrarth3.c \\
      \ \\
      Description:   \>
                     \parbox[t]{3in}
                     {Raise an int to the power of a big number modulus 
                      another big number. Uses
                      Left-to-Right binary method, which is 50\% faster than 
                      {\bf powmod} for small $x$.}  \\
      \ \\
      Parameters:    \>An integer $x$ and three bigs $y$, $z$ and $w$. \\
                     \>On exit $w=x^y \bmod z$  \\
      \ \\
      Return value:  \>None \\
      \ \\
      Restrictions:  \>
                     \parbox[t]{3 in}
                     {The value of $y$ must be positive. The parameters $w$
                      and $z$ must be distinct.} \\

\end{tabbing}

\subsection{powmod}

\begin{tabbing}
ggggggggggggggggggggg\= \kill


      Function:      \>void {\bf powmod}(x,y,z,w) \\
                     \>big x,y,z,w; \\
      \ \\
      Module:        \>mrarth3.c \\
      \ \\
      Description:   \>
                     \parbox[t]{3 in}
                     {Raise a big number to a big power modulus another 
                      big.} \\
      \ \\
      Parameters:    \>Four big numbers $x, y, z$ and $w$. \\
                     \>On exit $w=x^y \bmod z$. \\
      \ \\
      Return value:  \>None \\
      \ \\
      Restrictions:  \>
                     \parbox[t]{3in}
                     {The value of $y$ must be positive. The parameters $w$    
                      and $z$ must be distinct.} \\


\end{tabbing}

\subsection{scrt}
\begin{tabbing}
ggggggggggggggggggggg\= \kill
      Function:      \>void {\bf scrt}(rem,x) \\
                     \>int *rem; \\
                     \>big x; \\
      \ \\
      Module:        \>mrscrt.c \\
      \ \\
      Description:   \>
                     \parbox[t]{3 in}
                     {Applies Chinese Remainder Thereom (for small 
                      prime moduli).} \\
      \ \\
      Parameters:    \>
                     \parbox[t]{3 in}
                     {On exit $x$ contains the big number which yields 
                     the given integer remainders $rem$ when it is divided by 
                     the integer moduli
                     specified in a prior call to {\bf scrt\_init}.} \\
      \ \\
      Return value:  \>None \\
      \ \\
      Restrictions:  \>The routine {\bf scrt\_init} must be called first. \\
\end{tabbing}

\subsection{scrt\_end}
\begin{tabbing}
ggggggggggggggggggggg\= \kill
      Function:      \>void {\bf scrt\_end}() \\
      \ \\
      Module:        \>mrscrt.c \\
      \ \\
      Description:   \>
                     \parbox[t]{3 in}
                     {Cleans up after an application of the Chinese Remainder
                      Thereom. Must be called before the CRT is applied again} \\
      \ \\
      Parameters:    \>None \\
      \ \\
      Return value:  \>None \\
      \ \\
      Restrictions:  \>None \\
\end{tabbing}
      

\subsection{scrt\_init}
\begin{tabbing}
ggggggggggggggggggggg\= \kill
      Function:      \>bool {\bf scrt\_init}(np,m) \\
                     \>int np; \\
                     \>int *m; \\
      \ \\
      Module:        \>mrscrt.c \\
      \ \\
      Description:   \>
                     \parbox[t]{3 in}
                     {Initialises for an application of the Chinese Remainder
                      Thereom. Some internal workspace is allocated.} \\
      \ \\
      Parameters:    \>
                     \parbox[t]{3 in}
                     {The number of co-prime moduli $np$, and an array of
                      at least two integer moduli $m[\ ]$} \\
      \ \\
      Return value:  \>TRUE if all went well, FALSE if there was a problem. \\
      \ \\
      Restrictions:  \>None \\
\end{tabbing}

\pagebreak
\subsection{sftbit}

\begin{tabbing}
ggggggggggggggggggggg\= \kill

      Function:      \>void {\bf sftbit}(x,n,z) \\
                     \>big x,z; \\
                     \>int n; \\
      \ \\
      Module:        \>mrarth3.c \\
      \ \\
      Description:   \>Shifts a big integer left or right by a number of bits \\
      \ \\
      Parameters:    \>The big parameter $x$ is shifted by $n$ bits, to give $z$. \\
                     \>Positive $n$ shifts to the left, negative to the right. \\
      \ \\
      Return value:  \>None \\
      \ \\
      Restrictions:  \>None \\

\end{tabbing}
\pagebreak
\subsection{smul}

\begin{tabbing}
ggggggggggggggggggggg\= \kill

      Function:      \>int {\bf smul}(x,y,z) \\
                     \>int x,y,z; \\
      \ \\
      Module:        \>mrsmall.c \\
      \ \\
      Description:   \>Multiplies two integers mod a third \\
      \ \\
      Parameters:    \>Integers $x, y$ and $z$ \\
      \ \\
      Return value:  \>$x.y \bmod z$   \\
      \ \\
      Restrictions:  \>None \\

\end{tabbing}

\subsection{spmd}

\begin{tabbing}
ggggggggggggggggggggg\= \kill

      Function:      \>int {\bf spmd}(x,y,z) \\
                     \>int x,y,z; \\
      \ \\
      Module:        \>mrsmall.c \\
      \ \\
      Description:   \>Raises an integer to an integer power modulus a third  \\
      \ \\
      Parameters:    \>Integers $x$, $y$, and $z$  \\
      \ \\
      Return value:  \>$x^y \bmod z$ \\
      \ \\
      Restrictions:  \>None \\

\end{tabbing}

\pagebreak

\subsection{sqrmp}

\begin{tabbing}
ggggggggggggggggggggg\= \kill

      Function:      \>int {\bf sqrmp}(x,y) \\
                     \>int x,y; \\
      \ \\
      Module:        \>mrsmall.c \\
      \ \\
      Description:   \>Calculates the square root of an integer mod an \\
                     \>integer prime number  \\
      \ \\
      Parameters:    \>An integer $x$ and a prime number $y$   \\
      \ \\
      Return value:  \>$\sqrt{x} \bmod y$, or 0 if root does not exist \\
      \ \\
      Restrictions:  \>Return value unpredictable if $y$ is not prime \\

\end{tabbing}
\subsection{xgcd}

\begin{tabbing}
ggggggggggggggggggggg\= \kill

      Function:      \>int {\bf xgcd}(x,y,xd,yd,z) \\
                     \>big x,y,xd,yd,z; \\
      \ \\
      Module:        \>mrxgcd.c \\
      \ \\
      Description:   \>
                     \parbox[t]{3in}
                     {Calculates extended Greatest Common Divisor of two big
                     numbers. Can also be used to calculate modular inverses.
                     Note that this routine is about 8 times slower than a 
                     {\bf mad} operation on numbers of similar size.} \\
      \ \\
      Parameters:    \>Five big numbers $x,y,xd,yd$ and $z$. \\
                     \>On exit $z=\gcd(x,y)=x.xd+y.yd$  \\
      \ \\
      Return value:  \>GCD as integer, if possible, otherwise TOOBIG  \\
      \ \\
      Restrictions:  \>
                     \parbox[t]{3in}
                     {If $xd$ and $yd$ are not distinct, only $xd$ is 
                      returned. The GCD is only returned if $z$ distinct from 
                      both $xd$ and $yd$.} \\
      \ \\
      Example:       \>xgcd(x,p,x,x,x);  /* $x = 1/x \bmod p $ ($p$ is prime) */  
\end{tabbing}


\pagebreak
\section{Floating-Slash Routines}

\subsection{build}

\begin{tabbing}
ggggggggggggggggggggg\= \kill

      Function:      \>void {\bf build}(x,gener) \\
                     \>flash x;       \\
                     \>int (*gener)();\\
      \ \\
      Module:        \>mrbuild.c  \\
      \ \\
      Description:    \>
                      \parbox[t]{3in}
                      {Uses supplied generator of regular continued fraction
                       expansion to build up a flash number $x$, rounded if 
                       necessary.}\\
      \ \\
      Parameters:    \>The flash number created, and the generator function. \\
      \ \\
      Return value:  \>None  \\
      \ \\
      Restrictions:  \>None   \\
      \ \\
      Example:       \>int phi(w,n)   \\
                     \>flash w;       \\
                     \>int n;         \\
                     \>\{ /* rcf generator for golden ratio */       \\
                     \> \    return 1;  \\
                     \>\}               \\
                     \>.\\
                     \>.\\
                     \>build(x,phi); \\
                     \>.\\
                     \>This will calculate the golden ratio   \\
                     \>$(1+\sqrt{5})/2$ in $x$ -- very quickly! \\
\end{tabbing}
\pagebreak
\subsection{dconv}

\begin{tabbing}
ggggggggggggggggggggg\= \kill

      Function:      \>void {\bf dconv}(d,x)  \\
                     \>double d;   \\
                     \>flash x;    \\
      \ \\
      Module:        \>mrflash.c  \\
      \ \\
      Description:   \>Converts a double to flash format. \\
      \ \\
      Parameters:    \>
                     \parbox[t]{3 in}
                     {A double $d$ and a flash variable $x$. On exit $x$ will
                     contain the flash equivalent of $d$. } \\
      \ \\
      Return value:  \>None   \\
      \ \\                    
      Restrictions:  \>None   \\
\end{tabbing}

\subsection{denom}

\begin{tabbing}
ggggggggggggggggggggg\= \kill

      Function:      \>void {\bf denom}(x,y) \\
                     \>flash x;  \\
                     \>big y;    \\
      \ \\
      Module:        \>mrcore.c \\
      \ \\
      Description:   \>Extract the denominator of a flash number \\
      \ \\
      Parameters:    \>A flash number $x$ and a big number $y$. On exit $y$ \\
                     \>will contain the denominator of $x$.   \\
      \ \\
      Return value:  \>None \\
      \ \\
      Restrictions:  \>None    \\
\end{tabbing}
\pagebreak
\subsection{facos}

\begin{tabbing}
ggggggggggggggggggggg\= \kill


      Function:      \>void {\bf facos}(x,y) \\
                     \>flash x,y; \\
      \ \\
      Module:        \>mrflsh3.c \\
      \ \\
      Description:   \>Calculates arc-cosine of a flash number, using {\bf fasin}. \\
      \ \\
      Parameters:    \>Two flash numbers $x$ and $y$. On exit $y=\arccos x$. \\
      \ \\
      Return value:  \>None  \\
      \ \\
      Restrictions:  \>$|x|$ must be less than or equal to 1. \\

\end{tabbing}
\subsection{facosh}

\begin{tabbing}
ggggggggggggggggggggg\= \kill

      Function:      \>void {\bf facosh}(x,y) \\
                     \>flash x,y; \\
      \ \\
      Module:        \>mrflsh4.c \\
      \ \\
      Description:   \>Calculates hyperbolic arc-cosine of a flash number. \\
      \ \\
      Parameters:    \>Two flash numbers $x$ and $y$. On exit $y=$arccosh$\ x$. \\
      \ \\
      Return value:  \>None \\ 
      \ \\
      Restrictions:  \>$|x|$ must be greater than or equal to 1. \\
\end{tabbing}
\pagebreak
\subsection{fadd}

\begin{tabbing}
ggggggggggggggggggggg\= \kill

      Function:      \>void {\bf fadd}(x,y,z) \\
                     \>flash x,y,z; \\
      \ \\
      Module:        \>mrflash.c \\
      \ \\
      Description:   \>Add two flash numbers. \\
      \ \\
      Parameters:    \>Three flash numbers $x, y$ and $z$. On exit $z=x+y$. \\
      \ \\
      Return value:  \>None \\
      \ \\
      Restrictions:  \>None \\

\end{tabbing}

\subsection{fasin}

\begin{tabbing}
ggggggggggggggggggggg\= \kill


      Function:      \>void {\bf fasin}(x,y) \\
                     \>flash x,y; \\
      \ \\
      Module:        \>mrflsh3.c \\
      \ \\
      Description:   \>Calculates arc-sin of a flash number, using {\bf fatan}. \\
      \ \\
      Parameters:    \>Two flash numbers $x$ and $y$. On exit $y=\arcsin x$. \\
      \ \\
      Return value:  \>None \\
      \ \\
      Restrictions:  \>$|x|$ must be less than or equal to 1. \\

\end{tabbing}
\pagebreak
\subsection{fasinh}

\begin{tabbing}
ggggggggggggggggggggg\= \kill


      Function:      \>void {\bf fasinh}(x,y) \\
                     \>flash x,y; \\
      \ \\
      Module:        \>mrflsh4.c \\
      \ \\
      Description:   \>Calculates hyperbolic arc-sin of a flash number. \\
      \ \\
      Parameters:    \>Two flash numbers $x$ and $y$. On exit $y=$arcsinh$\ x$. \\
      \ \\
      Return value:  \>None \\
      \ \\
      Restrictions:  \>None \\

\end{tabbing}

\subsection{fatan}

\begin{tabbing}
ggggggggggggggggggggg\= \kill

      Function:      \>void {\bf fatan}(x,y) \\
                     \>flash x,y; \\
      \ \\
      Module:        \>mrflsh3.c \\
      \ \\
      Desciption:    \>Calculates the arc-tangent of a flash number, using \\
                     \>$O(n^{2.5})$ method based on Newton's iteration. \\
      \ \\
      Parameters:    \>Two flash numbers $x$ and $y$. On exit $y=\arctan x$. \\
      \ \\
      Return value:  \>None \\
      \ \\
      Restrictions:  \>None \\

\end{tabbing}
\pagebreak
\subsection{fatanh}

\begin{tabbing}
ggggggggggggggggggggg\= \kill

      Function:      \>void {\bf fatanh}(x,y) \\
                     \>flash x,y; \\
      \ \\
      Module:        \>mrflsh4.c \\
      \ \\
      Desciption:    \>Calculates the hyperbolic arc-tangent of a flash \\
                     \>number. \\
      \ \\
      Parameters:    \>Two flash numbers $x$ and $y$. On exit $y=$arctanh$\ x$. \\
      \ \\
      Return value:  \>None \\
      \ \\
      Restrictions:  \>$x^2$  must be less than 1   \\
      
\end{tabbing}

\subsection{fcomp}

\begin{tabbing}
ggggggggggggggggggggg\= \kill


      Function:      \>int {\bf fcomp}(x,y) \\
                     \>flash x,y; \\
      \ \\
      Module:        \>mrflash.c \\
      \ \\
      Description:   \>Compare two flash numbers. \\
      \ \\
      Parameters:    \>Two flash numbers $x$ and $y$. \\
      \ \\
      Return value:  \>Returns $-1$ if $y>x$, $+1$ if $x>y$ and 0 if $x=y$. \\
      \ \\
      Restrictions:  \>None \\
      
\end{tabbing}
\pagebreak
\subsection{fconv}

\begin{tabbing}
ggggggggggggggggggggg\= \kill

      Function:      \>void {\bf fconv}(n,d,x) \\
                     \>int n,d; \\
                     \>flash x; \\
      \ \\
      Module:        \>mrflash.c \\
      \ \\
      Description:   \>Convert a simple fraction to flash format. \\
      \ \\
      Parameters:    \>Integers $n$ and $d$, and a flash number $x$. \\
                     \>On exit $x=\frac{n}{d}$ \\
      \ \\
      Return value:  \>None \\
      \ \\
      Restrictions:  \>None \\
      
\end{tabbing}

\subsection{fcos}

\begin{tabbing}
ggggggggggggggggggggg\= \kill


      Function:      \>void {\bf fcos}(x,y) \\
                     \>flash x,y; \\
      \ \\
      Module:        \>mrflsh3.c \\
      \ \\
      Description:   \>Calculates cosine of a given flash angle, using {\bf ftan}. \\
      \ \\
      Parameters:    \>Two flash numbers $x$ and $y$. On exit $y=\cos x$. \\
      \ \\
      Return value:  \>None \\
      \ \\
      Restrictions:  \>None \\

\end{tabbing}
\pagebreak
\subsection{fcosh}

\begin{tabbing}
ggggggggggggggggggggg\= \kill

      Function:      \>void {\bf fcosh}(x,y) \\
                     \>flash x,y; \\
      \ \\
      Module:        \>mrflsh4.c \\
      \ \\
      Description:   \>Calculates hyperbolic cosine of a given flash angle. \\
      \ \\
      Parameters:    \>Two flash numbers $x$ and $y$. On exit $y=\cosh x$. \\
      \ \\
      Return value:  \>None \\
      \ \\
      Restrictions:  \>None \\

\end{tabbing}

\subsection{fdiv}

\begin{tabbing}
ggggggggggggggggggggg\= \kill


      Function:      \>void {\bf fdiv}(x,y,z) \\
                     \>flash x,y,z; \\
      \ \\
      Module:        \>mrflash.c \\
      \ \\
      Description:   \>Divides two flash numbers. \\
      \ \\
      Parameters:    \>Three big numbers $x, y$ and $z$. On exit $z=x/y$. \\
      \ \\
      Return value:  \>None \\
      \ \\
      Restrictions:  \>None \\

\end{tabbing}
\pagebreak
\subsection{fdsize}

\begin{tabbing}
ggggggggggggggggggggg\= \kill


      Function:      \>double {\bf fdsize}(x) \\
                     \>flash x; \\
      \ \\
      Module:        \>mrdouble.c \\
      \ \\
      Description:   \>Converts a flash number to double format. \\
      \ \\
      Parameters:    \>A flash number $x$. \\
      \ \\
      Return value:  \>The value of the parameter $x$ as a double. \\
      \ \\
      Restrictions:  \>The value of $x$ must be representable as a double.\\

\end{tabbing}

\subsection{fexp}

\begin{tabbing}
ggggggggggggggggggggg\= \kill

      Function:      \>void {\bf fexp}(x,y) \\
                     \>flash x,y; \\
      \ \\
      Module:        \>mrflsh2.c \\
      \ \\
      Description:   \>Calculates the exponential of a flash number using \\
                     \>$O(n^{2.5})$ method. \\
      \ \\
      Parameters:    \>Two flash numbers $x$ and $y$. On exit $y=\exp x$. \\
      \ \\
      Return value:  \>None \\
      \ \\
      Restrictions:  \>None \\

\end{tabbing}
\pagebreak
\subsection{fincr}

\begin{tabbing}
ggggggggggggggggggggg\= \kill

      Function:      \>void {\bf fincr}(x,n,d,y) \\
                     \>big x,y; \\
                     \>int n,d; \\
      \ \\
      Module:        \>mrflash.c \\
      \ \\
      Description:   \>Add a simple fraction to a flash number. \\
      \ \\
      Parameters:    \>Two flash numbers $x$ and $y$, and two integers $n$  \\
                     \>and $d$. On exit $y=x+\frac{n}{d}$. \\
      \ \\
      Return value:  \>None \\
      \ \\
      Restrictions:  \>None \\
      \ \\
      Example:       \>fincr(x,-2,3,x); \\
                     \>This subtracts two-thirds from the value of $x$. \\

\end{tabbing}

\subsection{flog}

\begin{tabbing}
ggggggggggggggggggggg\= \kill

      Function:      \>void {\bf flog}(x,y) \\
                     \>flash x,y; \\
      \ \\
      Module:        \>mrflsh2.c \\
      \ \\
      Description:   \>Calculates the natural log of a flash number using \\
                     \>$O(n^{2.5})$ method. \\
      \ \\
      Parameters:    \>Two flash numbers $x$ and $y$. On exit $y=\log x$. \\
      \ \\
      Return value:  \>None \\
      \ \\
      Restrictions:  \>None \\

\end{tabbing}
\pagebreak
\subsection{flop}

\begin{tabbing}
ggggggggggggggggggggg\= \kill

      Function:      \>void {\bf flop}(x,y,op,z) \\
                     \>flash x,y,z; \\
                     \>int *op; \\
      \ \\
      Module:        \>mrflash.c \\
      \ \\
      Description:   \>Perform primitive flash operation. Used internally. \\
      \ \\
      Parameters:    \>
                     \parbox[t]{3in}
                     {Three flash numbers $x, y$ and $z$. On exit $z=Fn(x,y)$,
                     where the function performed depends on the
                     parameter {\em op}. See source listing comments for more
                     details.} \\
      \ \\
      Restrictions:  \>None \\
      \ \\
      Return value:  \>None \\

\end{tabbing}

\subsection{fmul}

\begin{tabbing}
ggggggggggggggggggggg\= \kill


      Function:      \>void {\bf fmul}(x,y,z) \\
                     \>flash x,y,z; \\
      \ \\
      Module:        \>mrflash.c \\
      \ \\
      Description:   \>Multiply two flash numbers. \\
      \ \\
      Parameters:    \>Three flash numbers $x, y$ and $z$. On exit $z=x.y$ \\
      \ \\
      Return value:  \>None \\
      \ \\
      Restrictions:  \>None \\

\end{tabbing}
\pagebreak
\subsection{fpack}

\begin{tabbing}
ggggggggggggggggggggg\= \kill

      Function:      \>void {\bf fpack}(n,d,x) \\
                     \>flash x; \\
                     \>big n,d; \\
      \ \\
      Module:        \>mrcore.c \\
      \ \\
      Description:   \>Forms a flash number from big numerator and \\
                     \>denominator. \\
      \ \\
      Parameters:    \>A flash number $x$ and two big numbers $n$ and $d$. \\
                     \>On exit $x=\frac{n}{d}$. \\
      \ \\
      Return value:  \>None \\
      \ \\
      Restrictions:  \>
                     \parbox[t]{3in}
                     {The denominator must be non-zero. Flash variable $x$ and big
                     variable $d$ must be distinct. The resulting flash variable
                     must not be too big for the representation.} \\
      
\end{tabbing}

\subsection{fpi}

\begin{tabbing}
ggggggggggggggggggggg\= \kill

      Function:      \>void {\bf fpi}(x) \\
                     \>flash x; \\
      \ \\
      Module:        \>mrpi.c \\
      \ \\
      Description:   \>
                     \parbox[t]{3in}
                     {Calculates $\pi$ using Guass-Legendre $O(n^2.\log n)$ method.
                     Note that on subsequent calls to this routine, $\pi$ is
                     immediately available, as it is stored internally.
                     (This routine is disappointingly slow. There appears to 
                     be no simple way to calculate a rational approximation 
                     to $\pi$ quickly)} \\
      \ \\
      Parameters:    \>A flash number $x$. On exit $x=\pi$. \\
      \ \\
      Return value:  \>None \\
      \ \\
      Restrictions:  \>None 
\end{tabbing}
\subsection{fpmul}
\begin{tabbing}
ggggggggggggggggggggg\= \kill

      Function:      \>void {\bf fpmul}(x,n,d,y) \\
                     \>flash x,y; \\
                     \>int n,d; \\
      \ \\
      Module:        \>mrflash.c \\
      \ \\
      Description:   \>Multiplies a flash number by a simple fraction. \\
      \ \\
      Parameters:    \>Two flash numbers $x$ and $y$, and two integers $n$  \\
                     \>and $d$. On exit $y=x.\frac{n}{d}$ \\
      \ \\
      Return value:  \>None \\
      \ \\
      Restrictions:  \>None \\
      
\end{tabbing}

\subsection{fpower}

\begin{tabbing}
ggggggggggggggggggggg\= \kill

      Function:      \>void {\bf fpower}(x,n,y) \\
                     \>flash x,y; \\
                     \>int n; \\
      \ \\
      Module:        \>mrflsh1.c \\
      \ \\
      Description:   \>Raises a flash number to an integer power. \\
      \ \\
      Parameters:    \>Flash variables $x$ and $y$, and an integer $n$. \\
                     \>On exit $y=x^n$. \\
      \ \\
      Return value:  \>None \\
      \ \\
      Restrictions:  \>None \\
      
\end{tabbing}

\pagebreak
\subsection{fpowf}

\begin{tabbing}
ggggggggggggggggggggg\= \kill

      Function:      \>void {\bf fpowf}(x,y,z) \\
                     \>flash x,y,z; \\
      \ \\
      Module:        \>mrflsh2.c \\
      \ \\
      Description:   \>Raises a flash number to a flash power. \\
      \ \\
      Parameters:    \>Three flash numbers $x$, $y$ and $z$. On exit $z=x^y$ \\
      \ \\
      Return value:  \>None \\
      \ \\
      Restrictions:  \>None \\

\end{tabbing}

\subsection{frand}

\begin{tabbing}
ggggggggggggggggggggg\= \kill


      Function:      \>void {\bf frand}(x) \\
                     \>flash x; \\
      \ \\
      Module:        \>mrfrnd.c \\
      \ \\
      Description:   \>Generates a random flash number. \\
      \ \\
      Parameters:    \>A big number $x$. On exit $x$ contains a flash \\
                     \>random number in the range $0<x<1$. \\
      \ \\
      Return value:  \>None \\
      \ \\
      Restrictions:  \>None \\

\end{tabbing}
\pagebreak
\subsection{frecip}

\begin{tabbing}
ggggggggggggggggggggg\= \kill


      Function:      \>void {\bf frecip}(x,y) \\
                     \>flash x,y; \\
      \ \\
      Module:        \>mrflash.c \\
      \ \\
      Description:   \>Calculates reciprocal of a flash number. \\
      \ \\
      Parameters:    \>Two flash numbers $x$ and $y$. On exit $y=1/x$. \\
      \ \\
      Return value:  \>None \\
      \ \\
      Restrictions:  \>None \\

\end{tabbing}

\subsection{froot}

\begin{tabbing}
ggggggggggggggggggggg\= \kill


      Function:      \>bool {\bf froot}(x,m,y) \\
                     \>flash x,y; \\
                     \>int m; \\
      \ \\
      Module:        \>mrflsh1.c \\
      \ \\
      Description:   \>Calculates $m$-th root of a flash number using Newton's \\
                     \>$O(n^2)$ method. \\
      \ \\
      Parameters:    \>Flash numbers $x$ and $y$, and an integer $m$. On exit $y$ is \\
                     \>the $m$-th root of $x$. \\
      \ \\
      Return value:  \>TRUE for exact root, otherwise FALSE \\
      \ \\
      Restrictions:  \>None \\

\end{tabbing}
\pagebreak
\subsection{fsin}

\begin{tabbing}
ggggggggggggggggggggg\= \kill

      Function:      \>void {\bf fsin}(x,y) \\
                     \>flash x,y; \\
      \ \\
      Module:        \>mrflsh3.c \\
      \ \\
      Description:   \>Calculates sine of a given flash angle. Uses {\bf ftan}. \\
      \ \\
      Parameters:    \>Two flash numbers $x$ and $y$. On exit $y=\sin x$. \\
      \ \\
      Return value:  \>None \\
      \ \\
      Restrictions:  \>None \\

\end{tabbing}

\subsection{fsinh}

\begin{tabbing}
ggggggggggggggggggggg\= \kill

      Function:      \>void {\bf fsinh}(x,y) \\
                     \>flash x,y; \\
      \ \\
      Module:        \>mrflsh4.c \\
      \ \\
      Description:   \>Calculates hyperbolic sine of a given flash angle. \\
      \ \\
      Parameters:    \>Two flash numbers $x$ and $y$. On exit $y=\sinh x $. \\
      \ \\
      Return value:  \>None \\
      \ \\
      Restrictions:  \>None \\

\end{tabbing}
\pagebreak
\subsection{fsub}

\begin{tabbing}
ggggggggggggggggggggg\= \kill

      Function:      \>void {\bf fsub}(x,y,z) \\
                     \>flash x,y,z; \\
      \ \\
      Module:        \>mrflash.c \\
      \ \\
      Description:   \>Subtract two flash numbers. \\
      \ \\
      Parameters:    \>Three flash numbers $x,y$ and $z$. \\
                     \>On exit $z=x-y$. \\
      \ \\
      Return value:  \>None \\
      \ \\
      Restrictions:  \>None \\
      
\end{tabbing}

\subsection{ftan}

\begin{tabbing}
ggggggggggggggggggggg\= \kill

      Function:      \>void {\bf ftan}(x,y) \\
                     \>flash x,y; \\
      \ \\
      Module:        \>mrflsh3.c \\
      \ \\
      Description:   \>Calculates the tan of a given flash angle, using an   \\
                     \>$O(n^{2.5})$ method. \\
      \ \\
      Parameters:    \>Two flash numbers $x$ and $y$. On exit $y=\tan x$. \\
      \ \\
      Return value:  \>None \\
      \ \\
      Restrictions:  \>None \\

\end{tabbing}
\pagebreak
\subsection{ftanh}

\begin{tabbing}
ggggggggggggggggggggg\= \kill

      Function:      \>void {\bf ftanh}(x,y) \\
                     \>flash x,y; \\
      \ \\
      Module:        \>mrflsh4.c \\
      \ \\
      Description:   \>Calculates the hyperbolic tan of a given flash angle. \\
      \ \\
      Parameters:    \>Two flash numbers $x$ and $y$. On exit $y=\tanh x$. \\
      \ \\
      Return value:  \>None \\
      \ \\
      Restrictions:  \>None \\

\end{tabbing}

\subsection{ftrunc}

\begin{tabbing}
ggggggggggggggggggggg\= \kill

      Function:      \>void {\bf ftrunc}(x,y,z) \\
                     \>flash x,z; \\
                     \>big y; \\
      \ \\
      Module:        \>mrflash.c \\
      \ \\
      Description:   \>Seperates a flash number to a big number and a  \\
                     \>flash remainder. \\
      \ \\
      Parameters:    \>
                     \parbox[t]{3in}
                     {Flash numbers $x$ and $z$, and a big number $y$. 
                     On exit $y=int(x)$ and $z$ is the fractional remainder.
                     If $y$ is the same as $z$, only $int(x)$ is returned.}\\ 
      \ \\
      Return value:  \>None \\
      \ \\
      Restrictions:  \>None \\
      
\end{tabbing}
\pagebreak
\subsection{numer}

\begin{tabbing}
ggggggggggggggggggggg\= \kill

      Function:      \>void {\bf numer}(x,y) \\
                     \>flash x; \\
                     \>big y; \\
      \ \\
      Module:        \>mrcore.c \\
      \ \\
      Description:   \>Extract the numerator of a flash number. \\
      \ \\
      Parameters:    \>A flash number $x$ and a big number $y$. \\
                     \>On exit $y$ will contain the numerator of $x$. \\
      \ \\
      Return value:  \>None \\
      \ \\
      Restrictions:  \>None \\

\end{tabbing}
\subsection{round}

\begin{tabbing}
ggggggggggggggggggggg\= \kill

      Function:      \>void {\bf round}(n,d,x) \\
                     \>flash x; \\
                     \>big n,d; \\
      \ \\
      Module:        \>mrround.c \\
      \ \\
      Description:   \>
                     \parbox[t]{3in}
                     {Forms a rounded flash number from big numerator and
                     denominator. If rounding takes place the global variable
                     EXACT is set to FALSE. EXACT is initialised to TRUE in
                     routine {\bf mirsys}. This routine is used internally} \\
      \ \\
      Parameters:    \>
                     \parbox[t]{3in}
                     {A flash number $x$ and two big numbers $n$ and $d$. On exit
                     x=R\{$n/d$\}, that is the flash number $\frac{n}{d}$ rounded if
                     necessary to fit the representation.} \\
      \ \\
      Return value:  \>None \\
      \ \\
      Restrictions:  \>The denominator must be non-zero. \\

\end{tabbing}

\appendix
\cleardoublepage
\chapter{Global variables}
\pagebreak
\begin{tabbing}
gggggggggggggggggggggggg\= \kill

bool EXACT;       \>
                  \parbox[t]{3in}
                  {Initialised to TRUE. Set to FALSE if any rounding
                  takes place}\\
\ \\
int INPLEN;       \>
                  \parbox[t]{3in}
                  {Length of input string. Must be used when inputting
                   binary data}\\
\ \\
int IOBASE;       \>
                  \parbox[t]{3in}
                  {The number base to be used for input and output. May be 
                   changed at will within a program.}\\
\ \\
bool MR\_ERCON;    \>
                  \parbox[t]{3in}
                  {Errors by default generate an error message and 
                   immediately abort the program. Alternatively by setting 
                   MR\_ERCON=TRUE error control
                   is left to the user.}\\
\ \\
int MR\_ERNUM;       \>Number of the last error that occurred. \\
\ \\
char MR\_IOBUFF[\ ]; \>Input/Output buffer. \\
\ \\
int MR\_NTRY;     \> 
                  \parbox[t]{3in}
                  {Number of iterations used in probabalistic primality
                   test by {\bf isprime()}. Initialised to 6.}\\
\ \\
bool POINT;       \>
                  \parbox[t]{3in}
                  {If set to TRUE numbers are output with a radix point.
                   Otherwise they are output as fractions (the default).}\\
\ \\
int *PRIMES;      \>
                  \parbox[t]{3in}
                  {Pointer to a table of small prime numbers.}\\
\ \\
int TOOBIG;       \>
                  \parbox[t]{3in}
                  {The value returned by {\bf size()}, when it cannot reduce a 
                   {\em big} variable to integer size. Read-only.}\\
\ \\
bool TRACER;      \>
                  \parbox[t]{3in}
                  {If set to ON causes debug information to be printed out,
                   tracing the progress of all subsequent calls to MIRACL 
                   routines. Initialised to OFF.}\\
\end{tabbing}

\chapter{The Hardware Interface}
\pagebreak

Hardware details are specified to MIRACL in this header file {\em mirdef.h}.

\begin{verbatim}
/* 
 *   MIRACL compiler/hardware definitions - mirdef.h
 *   This version suitable for use with most 16-bit 
 *   computers e.g. IBM PC.
 *
 *   Copyright (c) 1988-1992 Shamus Software Ltd.
 */

#define MIRACL_16
#define utype int    /* the underlying type is usually int *
                      * but see mrmuldv.any                */
#define small unsigned utype

#define MR_SBITS 16  /* Number of 'active'  bits per small */
#define MR_LBITS 32  /* Number of bits per long            */
#define MR_IBITS 16  /* Number of bits per int             */
#define MR_MBITS 52  /* Number of bits per double mantissa */
#define MR_EBITS 12  /* Number of bits per double exponent */
#define MR_IOBSIZ 1024  /* I/O buffer size                 */
#define FULLWIDTH    /* define if fullwidth base possible  *
                      * and supported. See mrmuldv.any     */
#define LITTLE_ENDIAN   /* see mrmuldv.any */
#define MR_FLASH     /* delete this definition if integer  *
                      * only version of MIRACL required    */
/* 
#define MR_STRIPPED_DOWN * define this to minimize size    *
                      * of library - all error messages    *
                      * lost! USE WITH CARE - see mrcore.c */
#define MAXBASE ((small)1<<(MR_SBITS-1))
                     /* maximum number base size */
/* 
#define MAXBASE ((small)1<<(MR_SBITS-2))

This definition may be necessary if 
(1) unsigned types not implemented properly, or
(2) CPU instruction set does not support unsigned multiply 
    and divide e.g. as in VAX
*/

\end{verbatim}

This file must be edited if porting to a new hardware environment. Assembly 
language versions of the time-critical routines in {\em mrmuldv.any} 
must also be written, if not already provided.




\begin{thebibliography}{99}

      \bibitem{Brassard}
      BRASSARD, G. Modern Cryptology. Lecture Notes  in  Computer  Science,
      Vol. 325. Springer-Verlag 1988.

      \bibitem{Brent76}
      BRENT, R.P. Fast Multiprecision Evaluation of Elementary Functions.
      J. ACM, 23, 2 (April 1976), 242-251. 

      \bibitem{Brent78}
      BRENT, R.P.  A Fortran Multiprecision Arithmetic Package. ACM Trans.  
      Math. Software 4,1 (March 1978), 57-81.  

      \bibitem{Cherry}
      CHERRY, L. and MORRIS, R. BC - An Arbitrary Precision Desk-Calculator 
      Language. in ULTRIX-32 Supplementary Documents Vol.  1 General Users.  
      Digital Equipment Corporation 1984.  

      \bibitem{Fred}
      GRUENBERGER, F. Computer Recreations. Scientific American, April 1984  

      \bibitem{Knuth73}
      KNUTH,  D.E.  The  Art  of Computer Programming,  Vol 1:  Fundamental 
      Algorithms. Addison-Wesley, Reading, Mass., 1973.  

      \bibitem{Knuth81}
      KNUTH,  D.E.  The Art of Computer Programming,  Vol 2:  Seminumerical 
      Algorithms. Addison-Wesley, Reading, Mass., 1981.  

      \bibitem{Korn83}
      KORNERUP, P.  and MATULA, D.W.  Finite Precision Rational Arithmetic: 
      An Arithmetic Unit.  IEEE Trans.  Comput., C-32, 4 (April 1983),  378-
      387.  
      
      \bibitem{Korn85}
      KORNERUP,  P.   and  MATULA,  D.W.   Finite  Precision  Lexicographic 
      Continued  Fraction  Number  Systems.   Proc.   7th  Sym.   on  Comp. 
      Arithmetic, IEEE Cat.  \#85CH2146-9, 1985, 207-214.  

      \bibitem{Marsaglia}
      MARSAGLIA, G.M. and ZAMAN, A. A New Class of Random Number Generators.
      The Annals of Applied Probability, Vol. 1, 3, 1991, 462-480

      \bibitem{Matula85}
      MATULA, D.W.  and KORNERUP, P.  Finite Precision Rational Arithmetic: 
      Slash Number Systems. IEEE Trans.  Comput., C-34, 1 (January 1985), 3-
      18.  

      \bibitem{Maurer}
      MAURER, U.M. and YACOBI, Y. Non-Interactive Public Key Cryptography.
      Advances in Cryptography, Eurocrypt '91, Springer Verlag, 1992

      \bibitem{McCurley}
      McCURLEY, K.S. A Key Distribution System Equivalent to Factoring. J.
      Cryptology, Vol. 1. No. 2, 1988

      \bibitem{Monty}  
      MONTGOMERY, P. Speeding the Pollard and Elliptic Curve Methods. 
      Math. Comput., 48, (January 1987), 243-264

      \bibitem{Morrison}
      MORRISON,  M.A.  and  BRILLHART,  J.  A  Method  of Factoring and the 
      Factorization of F7. Math. Comput., 29, 129 (January 1975), 183-205.  

      \bibitem{Okamoto}
      OKAMOTO, E. Proposal for Identity based Key Distribution Systems. 
      Electronics Letters, (20th November 1986), 1283-1284. 

      \bibitem{Pollard}
      POLLARD, J.M. Fast Fourier Transform in a Finite Field. Math. 
      Comput., 25, 114 (April 1971), 365-374

      \bibitem{Pollard2}
      POLLARD, J.M. Monte Carlo Methods for Index Computation (mod p). Math.
      Comp. Vol. 32, No. 143, pp 918-924, 1978

      \bibitem{Pomerance}
      POMERANCE,  C. The Quadratic Sieve Factoring Algorithm. In Advances
      in Cryptology, Lecture Notes in Computer Science, Vol. 209, Springer-
      Verlag, 1985, 169-182

      \bibitem{Reisel}
      REISEL, H. Prime Numbers and Computer methods for Factorisation. 
      Birkhauser. 1987
      
      \bibitem{RSA}
      RIVEST, R., SHAMIR, A. and ADLEMAN, L. A Method for obtaining Digital 
      Signatures and Public-Key Cryptosystems.  Comm.  ACM,  21,2 (February 
      1978), 120-126.  

      \bibitem{Scott87}
      SCOTT, M.P.J.  On the Efficient Generation of Multiprecision Rational 
      Approximations. NIHE Dublin Working Paper CA 0487, 1987.

      \bibitem{Scott89a}
      SCOTT, M.P.J.   Fast  rounding  in  multiprecision   floating-slash 
      arithmetic.  IEEE Transactions on Computers, July 1989, 1049-1052.

      \bibitem{Scott89b}
      SCOTT, M.P.J.  On Using Full Integer Precision in C. Dublin City 
      University Working Paper CA 0589, 1989.
      
      \bibitem{Scott89c}
      SCOTT, M.P.J. Factoring Large Integers on Small Computers. National
      Institute for Higher Education Working Paper CA 0189, 1989

      \bibitem{Silverman}
      SILVERMAN, R.D. The Multiple Polynomial Quadratic Sieve, Math. Comp.
      48, 177, (January 1987), 329-339

      \bibitem{Strous}
      STROUSTRUP, B. The C++ Programming Language. Addison-Wesley, Reading
      Mass., 1986

\end{thebibliography}

\end{document}

