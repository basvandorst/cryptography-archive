/*
 *   MIRACL flash number builder: uses generator of
 *   regular continued fraction expansion to create
 *   a flash number, rounded if necessary.
 *   mrbuild.c
 *
 *   Copyright (c) 1988-1993 Shamus Software Ltd.
 */

#include <stdio.h>
#include <miracl.h>

#ifdef MR_FLASH

#define abs(x)  ((x)<0? (-(x)) : (x))

/* Access global variables */

extern int  mr_depth;    /* error tracing .. */
extern int  mr_trace[];  /* .. mechanism     */
extern int  mr_check;    /* error checking   */
extern small MR_OBITS;   /* other bits       */
extern small mr_base;    /* number base      */
extern int  mr_nib;      /* no. ints in big  */
extern int  mr_workprec;

extern big mr_w0;
extern big mr_w1;       /* workspace variables  */
extern big mr_w2;
extern big mr_w3;
extern big mr_w4;
extern big mr_w7;

void build(x,gen)
flash x;
int (*gen)(big,int);
{ /* Build x from its regular c.f. *
   * generated by gen()            */
    small ex1,ex2,ex,st,sr;
    int a,b,c,d,rm,q,n,prc,lw2,lw4,lz;
    bool finoff,last;
    big t;
    if (MR_ERNUM) return;
    mr_depth++;
    mr_trace[mr_depth]=48;
    if (TRACER) track();
    zero(mr_w1);
    convert(1,mr_w2);
    convert(1,mr_w3);
    zero(mr_w4);
    finoff=FALSE;
    last=FALSE;
    n=0;
    q=(*gen)(x,n);   /* Note - first quotient may be zero */
    ex=mr_base-1;
    if (mr_nib==mr_workprec) prc=mr_nib;
    else prc=mr_workprec+1;
    while (!MR_ERNUM && q>=0)
    {
        if (q==TOOBIG || n==0 || finoff)
        {
            if (q!=TOOBIG) convert(q,x);
            else last=FALSE;
            mr_check=OFF;
            multiply(mr_w2,x,mr_w0);
            subtract(mr_w1,mr_w0,mr_w7);
            mr_check=ON;
            if ((int)(mr_w7[0]&MR_OBITS)>mr_nib) break;
            copy(mr_w7,mr_w1);
            t=mr_w1,mr_w1=mr_w2,mr_w2=t;   /* swap(mr_w1,mr_w2) */
            mr_check=OFF;
            multiply(mr_w4,x,mr_w0);
            subtract(mr_w3,mr_w0,mr_w7);
            mr_check=ON;
            if ((int)(mr_w7[0]&MR_OBITS)>mr_nib)
            { /* oops! */
                fpack(mr_w1,mr_w4,x);
                negate(x,x);
                EXACT=FALSE;
                mr_depth--;
                return;
            }
            copy(mr_w7,mr_w3);
            t=mr_w3,mr_w3=mr_w4,mr_w4=t;   /* swap(mr_w3,mr_w4) */
            n++;
        }
        lw2=(int)(mr_w2[0]&MR_OBITS);
        lw4=(int)(mr_w4[0]&MR_OBITS);
        lz=lw2+lw4;
        if (lz > prc) break;  /* too big - exit */
        if (last)
        {
            if (finoff) break;
            finoff=TRUE;
            q=(*gen)(x,n);
            continue;
        }
        if (lz>=prc-1)
        { /* nearly finished - so be careful not to overshoot */
            if (mr_base==0)
            {
                st=mr_w2[lw2]+1;
                if (st==0) ex1=1;
                else ex1=muldvm((small)1,(small)0,st,&sr);
                st=mr_w4[lw4]+1;
                if (st==0) ex2=1;
                else ex2=muldvm((small)1,(small)0,st,&sr);
            }
            else
            {
                ex1=mr_base/(mr_w2[lw2]+1);
                ex2=mr_base/(mr_w4[lw4]+1);
            }
            if (ex2>ex1) ex=ex1,ex1=ex2,ex2=ex;
            if (lz==prc) ex=ex2;
            else         ex=ex1;
            last=TRUE;
        }
        a=1;
        b=0;
        c=0;
        d=1;
        forever
        {
            q=(*gen)(x,n);          
            if (q<0 || q>=TOOBIG/abs(d))
            { /* there could be more.... *** V3.21 mod *** */
                last=FALSE;
                break;
            }
            rm=b-q*d;
            b=d;
            d=rm;
            rm=a-q*c;
            a=c;
            c=rm;
            n++;
            if ((small)(abs(c-d))>ex) break;
        }
        premult(mr_w1,c,mr_w7);
        premult(mr_w1,a,mr_w1);
        premult(mr_w2,b,mr_w0);
        premult(mr_w2,d,mr_w2);
        add(mr_w1,mr_w0,mr_w1);
        add(mr_w2,mr_w7,mr_w2);
        premult(mr_w3,c,mr_w7);
        premult(mr_w3,a,mr_w3);
        premult(mr_w4,b,mr_w0);
        premult(mr_w4,d,mr_w4);
        add(mr_w3,mr_w0,mr_w3);
        add(mr_w4,mr_w7,mr_w4);
    }
    if (fit(mr_w2,mr_w4,mr_nib)) fpack(mr_w2,mr_w4,x);
    else                         fpack(mr_w1,mr_w3,x);
    negate (x,x);
    if (q!=(-1)) EXACT=FALSE;
    mr_depth--;
}

#endif

