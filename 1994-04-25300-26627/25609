Path: msuinfo!netnews.upenn.edu!newsserver.jvnc.net!darwin.sura.net!howland.reston.ans.net!math.ohio-state.edu!magnus.acs.ohio-state.edu!csn!news.usafa.af.mil!cs27-75.usafa.af.mil!goemansd
From: goemansd@kirk.usafa.af.mil (Daniel Goemans)
Newsgroups: sci.crypt
Subject: Algorithm for Review
Date: Thu, 7 Apr 1994 00:36:51 GMT
Organization: United States Air Force Academy
Lines: 73
Message-ID: <goemansd.46@kirk.usafa.af.mil>
NNTP-Posting-Host: 128.236.127.75

To any and all! 
 
This is an algorithm I have been talking about for a short while.  It may 
not be the most secure you've seen, but I have included some ideas that I 
have definitely not seen before, and some that are very difficult to 
mathematically model (yet relatively easy to code, using finite arrays).
 
I'd like you to take a look at it, and focus specifically on things like 
(1) The 'polymorphic' key
(2) The use of plain & cipherbits as indices -- instead of in the 
traditional geometric form.
 
While this may be nothing more than a weekend project for you, it may 
represent an evolutionary change in the way encryption is considered.
 
---- ---- Starts Here ---- ----

POLYMORPHIC KEY, RECURRENT STREAM CIPHER

<TERMS>
Ct   = Cipherbit at time t 
At   = Plainbit at time t  
Kt   = 64 bit key (polymorphic) at time t
KBnt = Key bit in position n  (0 <= n < 64) at time t
KS   = 1 of 8 eight bit Kt sections, identified by a 3 bit num.
o    = The transmission order of a bit (i.e. Co is the oth bit
	  enciphered and transmitted)
INV  = The inverse function, used instead of 'NOT' to avoid confusion.

<ASSUME>
One (pseudo)clock pulse per bit transmission (i.e.  Ct is transmitted at time 
t, and Ct-1 was transmitted one clock pulse earlier).

<KEY MANIPULATION>
If At = 1 Then
		
			For KB1 To KB64 Do
	
			KBnt+1 = (A * KBnt + D) mod 64
	Where
			A = (The first eight KBn such that KBn-1 = 1) + 1
	And
			D = INV [KS #(At-2)(Ct-4)(At-7)]

<CIPHER>
Ct = At XOR {[Chksum (OrderNum XOR KeyPiece)] XOR [LFSR Output]}
Where 
	Chksum is the Checksum function, with an eight bit input.
And
	OrderNum = {o mod [(At-8)(KB(KS#(At-6)(Ct-5)(At-1) mod 64))(At-3)]}
And
	Keypiece = [(KBn..KBn+8) such that n = (Kt mod 64)]
And 
	LFSR = 64 bit Linear Function Shift Register, seeded with the
		 key at time t=0.

Due to ASCII restrictions, I couldn't show subscripts effectively, so please 
read bit references such as (At-2) as the plainbit A transmitted at time
(t-2).
For clarification, KS#(x)(y)(z) references an 8 bit sequence in the key. 
For example, given x=1 y=0 z=1, KeySection 5 would be referenced (which 
would be the 41st - 48th Key Bits).

Please feel free to mail me with any responses, recommendations, or 
questions you may have!
 
Dan
--
Daniel Goemans |  "You have to start knowing yourself so well
USAF Academy   |     that you begin to know other people.
Lines 1 & 2    |   A piece of us in every person we can ever meet."
may not agree. |                      -- John D. MacDonald    
         PGP 2.3 public key available on request.
