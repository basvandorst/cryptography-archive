Path: msuinfo!agate!howland.reston.ans.net!europa.eng.gtefsd.com!MathWorks.Com!blanket.mitre.org!linus.mitre.org!gauss.mitre.org!bs
From: bs@gauss.mitre.org (Robert D. Silverman)
Newsgroups: sci.crypt
Subject: Re: Searching for primes
Date: 6 Apr 1994 16:01:43 GMT
Organization: Research Computer Facility, MITRE Corporation, Bedford, MA
Lines: 118
Message-ID: <2numd7$qcd@linus.mitre.org>
References: <1994Apr3.224626.13805@mnemosyne.cs.du.edu> <2ns8l0$ikq@linus.mitre.org> <1994Apr6.092808.25303@mnemosyne.cs.du.edu>
NNTP-Posting-Host: gauss.mitre.org

In article <1994Apr6.092808.25303@mnemosyne.cs.du.edu> colin@nyx10.cs.du.edu (Colin Plumb) writes:
:In article <2ns8l0$ikq@linus.mitre.org>,
:Robert D. Silverman <bs@gauss.mitre.org> wrote:
:
:Oh, my, Bob Silverman!  I'm in distinguished company.
:
:>In article <1994Apr3.224626.13805@mnemosyne.cs.du.edu> colin@nyx10.cs.du.edu (Colin Plumb) writes:
:>:Fast sieving for prime numbers
:>: 
:>:I've been working on efficient generation of "strong" primes.  That is,
:>:primes where p-1 has a large prime factor.  You need to perform a similar
:> 
:>(1) Please define large.  Please tell us why you are concerned about whether
:>    p-1 has a large prime factor. I suspect I know the reason. If my
:>    suspicion is true, your concerns are not relevent.
:
:What you suspect is partially true, which is that the old literature
:all recommends it.  But the issue which brought it up for me was
:DSS, which requires that 160-bit q divide 512-to-1024-bit p-1.
 
No problem. But 160 bits is still way to big for Pollard P-1 to work,
so you need not worry. [i.e. if your prime p  has p-1 divisible by
a 160 bit prime, P-1 will NEVER find it].

stuff deleted...

:>:First of all, trial division by small primes is a very useful thing.
:>:Basically, each prime p will weed out 1/p of the candidates.  If this
:> 
:>Negative. Each prime does NOT weed out 1/p. For example, if you sieve
:>by 5, you must remember that 1/3 of the numbers you hit have already been
:>sieved out by 3. The fraction is really: (1-1/2)(1-1/3)(1-1/5).....(1-1/p)
:>By Mertens' theorem this is approximately exp(-gamma)/log p.
:
:Um... yes, each prime does weed out 1/p.  That's what you wrote in
:your equation and what I said, but maybe English is causing our
:problems.  Each prime p weeds out 1/p of the numbers *which get that far*.

This is correct.  2 weeds out half. 3 now weeds out
1/3 *of the remainder*, but only an additional 1/6 of the original set.
I took your "weed out 1/p" to mean that each prime p weeds out an
additional 1/p from the original set of candidates and NOT 1/p from
the candidates that still remain...  "Fuzzy English"......
I took "each weeds out 1/p" to mean that after sieving out 2,3,5,...P,
one had eliminated 1/2 + 1/3 + 1/5 +1/7 + ... 1/P  of the original
candidates. And that is not true.

 
 
:>:can be done at a cost of about one multiply, it's significantly
:>:thousand times faster than a Fermat test to the base 2, the cheapest
:> 
:>One is usually doing these divisions on multi-precise numbers. They
:>are significantly more expensive than one multiply.
:
:I was talking about doing one division first and then cacheing the
:remainder to use in searching a range.  Again, I apologize if I confused
:you with my discussion of trial division.  Trial division is the
:*effect* I'm getting, but the implementation is much more efficient.
 
Please say exactly what you are doing. If I take the candidate list
{n, n+1, n+2, n+3, n+4  .....  n+h}   and divide n by 2,3,5,7....
looking for a zero remainder, then divide n+1 by 2,3,5,7...  etc.
I am doing trial division.

If I compute  h1 = n mod 2 ,  h2 = n mod 3, h3 = n mod 5, etc.
then set up an array of locations x[0], x[1], x[2], ... x[h]  and
starting at x[2-h1] I put a '1' in x[2-h1], x[2-h1+2], x[2-h1+4]... and
a 1 in x[3-h2], x[3-h2+3], x[3-h2+6]...  etc.   I am SIEVING out those
n+i  in my list that are divisible by 2,3,5,...

This does not involve trial division.
 
The total cost for this is O(h loglog P) where P is the largest
candidate divisor. You can reduce this using Brent's "wheel" version
of the sieve to essentially O(h(1 + epsilon)).

:>:Obviously the smaller the prime, the more lucrative the trial division.
:> 
:>Secondly, even if one wants to do this, one should use a SIEVE, not
:>trial division.
:Um... I don't quite understand the distinction.  Obviously, the implementation
 
See above
 
:Again, I emphasize that "trial division" does not describe the
:implementation; after some precomputation (which essentially is a trial
:division), the cost to attempt one division is one machine-word
:multiplication.  I thought I described that technique.
 
When done with a sieve, the cost to test ALL the numbers in the
range [n, n+h] for divisibility by p  is h/p. That is why sieve
based factoring algorithms are so effective.  

One the other hand, your cost to test all the numbers for divisibility
by p [assuming 1 mult = 1 division attempt] is h multiplications.
Multiplication takes at least several cycles for just one of them.
The sieve procedure only takes ONE cycle to put x[i] = 1.
 
Compare  k*h (where k is #cycles/mult)  with  h/p.



:Anyway, now that you've torn this parat, maybe you can take a crack
:at my next piece on computing multiplicative inverses...
 
When I see it...

Basically to compute  1/a  mod p  takes O(log p) multiplications mod p
when using a variation of Euclid's algorithm. If p is a multi-precise
number (very big, say), there are FFT techniques to reduce the cost,
or Lehmer's binary method.  See Knuth Vol. 2

-- 
Bob Silverman
These are my opinions and not MITRE's.
Mitre Corporation, Bedford, MA 01730
"You can lead a horse's ass to knowledge, but you can't make him think"
