Newsgroups: sci.crypt
Path: msuinfo!agate!howland.reston.ans.net!cs.utexas.edu!uunet!mnemosyne.cs.du.edu!nyx10!colin
From: colin@nyx10.cs.du.edu (Colin Plumb)
Subject: Re: Q: Security of new encryption-devdriver
Message-ID: <1994Apr19.095229.19780@mnemosyne.cs.du.edu>
X-Disclaimer: Nyx is a public access Unix system run by the University
 	of Denver for the Denver community.  The University has neither
 	control over nor responsibility for the opinions of users.
Sender: usenet@mnemosyne.cs.du.edu (netnews admin account)
Organization: Nyx, Public Access Unix at U. of Denver Math/CS dept.
References: <2nq8d6$kkp@liberator.et.tudelft.nl> <2oels0$su0@freenet3.scri.fsu.edu> <1994Apr14.105133.742@mnemosyne.cs.du.edu> <2oqtrt$cfc@u.cc.utah.edu>
Date: Tue, 19 Apr 94 09:52:29 GMT
Lines: 44

In article <2oqtrt$cfc@u.cc.utah.edu>, R Bryner <rb7656@u.cc.utah.edu> wrote:
>Colin Plumb (colin@nyx10.cs.du.edu) wrote:
>: It is still the case that if you read a sector, modify a byte, and
>: write it back, an opponent can tell, to within one encryption block,
>: where the change was made.  This leaks information.
>
>I am jumping in on this, but I assume you are talking about the sector
>incryptors for disk-drives.
>
>I have thought about this a little, and It would seem to me that what you
>need is a program, much like compress that runs in the background and
>re-encrypts the whole drive periodicaly with a new iv based upon both the
>sector and an incrimenting value stored in the program.

Great, but if the incrementing value can differ for each sector,
where do you store the map indicating its value for each sector?
That's a pain.

SFS uses a hash of the entire sector as the IV.  The hash is not
particularly strong, but unless you carefully choose plaintext to
exploit its weaknesses, it will protect your data from disclosure.
(And the information disclosed is only the data itself; it does not
help you find the key or decrypt other data not specially chosen.)
This avoids all storage overhead and provides good security.  An
attacker with multiple snapshots of the ciphertext can figure out which
blocks have been modified, but that's an awfully vrude measure.
And if you run a disk optimizer, even that information is hidden.

A few notes for the perplexed: the hash also includes the sector number,
so two identical sectors in different locations will have completely
different cihpertexts.  And how to recover the hash?  Well, compute any
arbitrary hash on most of the sector except the last cipher block.  XOR
or add  the result into the last cipher block.  Use this as the IV and
encrypt using any of the standard chaining modes.  Those modes require
only the previous and current ciphertext blocks to compute the current
plaintext block, so without the IV, you can decrypt all but the first
cipher block in the sector.  This includes the last cipher block, which
is the IV you need to decrypt the first plaintext block.  So now you
have all the plaintext, you can compute the hash and XOR or subtract
it out of the last block to recover the original input.

There, now, wasn't that fun?
-- 
	-Colin
