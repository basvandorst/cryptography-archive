Path: msuinfo!agate!ames!elroy.jpl.nasa.gov!swrinde!gatech!howland.reston.ans.net!europa.eng.gtefsd.com!MathWorks.Com!zombie.ncsc.mil!golf!mizzou1.missouri.edu!C445585
From: C445585@mizzou1.missouri.edu
Newsgroups: sci.crypt
Subject: Re: Yet Another Secure? RNG
Date: Mon, 04 Apr 94 18:22:45 CDT
Organization: University of Missouri, Columbia
Lines: 58
Message-ID: <16F8E10277S86.C445585@mizzou1.missouri.edu>
References: <jktaberCnHAoC.3yM@netcom.com>
NNTP-Posting-Host: mizzou1.missouri.edu

In article <jktaberCnHAoC.3yM@netcom.com>
jktaber@netcom.com (John K. Taber) writes:
 
  Okay, now if I understood this scheme right, it works like this:
 
  There is a buffer of 17 bytes, v(17).  These 17 bytes are also
looked at as four "rotors," of 2 bytes, 3 bytes, 5 bytes, and 7 bytes.
The general idea is to add 4 values from the buffer of 17, and use that
value as output.  Rotate the output byte left 1 bit, and add it into
the next position in the buffer.
 
   Basically, this means that your output sequence looks like this:
 
   v0 + v2 + v5 + v10
   v1 + v3 + v6 + v11
   v0 + v4 + v7 + v12
   v1 + v2 + v8 + v13
   v0 + v3 + v9 + v14
   v1 + v4 + v5 + v15
   v0 + v2 + v6 + v16
   v1 + v3 + v7 + v10
         etc.
 
   Now, v0 is changed after the first output, v1 after the second, v2 after
the third, and so on until the 18 output byte, which changes v0 again.
 
   Suppose I knew the low-order bit of all 17 bytes.  (Let's ignore *how*
I might come to know those bits--I just know all 17 low-order bits.)  Now,
if I know them, and I know where we are in the output stream, I'll never
lose track of what those low-order bits are--the only way they're changed
is by being XORed with the high-order bit of one output byte, and since I
can see that byte, I have no problems tracking the results.
 
   Without specifying how, just yet, assume I know the low-order two bits
in each of the 17 bytes in the buffer.  I never lose any information about
those bits, either.  In fact, if I know all the low-order i bits, I can
just keep my knowledge of those bits for as long as I can see the output
stream of bytes.
 
   Now, what if I *think* I know the low-order bit of all 17 bytes?  If
I want to test my knowledge, it's fairly easy--each output gives me a
chance to test my knowledge of 4 of those bits at a time--the low-order
output bit is the XOR of those 4 bits.
 
   If I tried all 2**17 possible low-order bit patterns, I'd come up with
a certainly-right bit pattern, if I had enough output bytes--otherwise
I'd come up with a subset of possible bit-patterns.  Once I have a certain
(or a set of probable) pattern of low bits, I can try the same attack
again, using the same length of output sequence, to retrieve the next
bit.  (I need the low-bit first to account for carry-in.)  Repeat 8 times,
and I have the whole 17 bytes, for about 2**20 ops and about 2**17 memory.
>What I'm interested in is the kind of thinking needed to see the
>weaknesses of such a cipher.
>--
>John K. Taber                        jktaber@netcom.com
 
   --John Kelsey, c445585@mizzou1.missouri.edu
 
