Path: msuinfo!agate!howland.reston.ans.net!europa.eng.gtefsd.com!MathWorks.Com!blanket.mitre.org!linus.mitre.org!gauss.mitre.org!bs
From: bs@gauss.mitre.org (Robert D. Silverman)
Newsgroups: sci.crypt
Subject: Re: Searching for primes
Date: 5 Apr 1994 17:54:40 GMT
Organization: Research Computer Facility, MITRE Corporation, Bedford, MA
Lines: 80
Message-ID: <2ns8l0$ikq@linus.mitre.org>
References: <1994Apr3.224626.13805@mnemosyne.cs.du.edu>
NNTP-Posting-Host: gauss.mitre.org

In article <1994Apr3.224626.13805@mnemosyne.cs.du.edu> colin@nyx10.cs.du.edu (Colin Plumb) writes:
:Fast sieving for prime numbers
: 
:I've been working on efficient generation of "strong" primes.  That is,
:primes where p-1 has a large prime factor.  You need to perform a similar
 
(1) Please define large.  Please tell us why you are concerned about whether p-1
   has a large prime factor. I suspect I know the reason. If my suspicion is 
   true, your concerns are not relevent.
(2) The reason for "strong" prime generation does not exist anymore.
    When people were suggesting use of 256 bit keys for RSA there was
    a remote possibility that the Pollard P-1 algorithm might be used
    to attack a key.  Today it is impossible.

    To begin with, that in itself was a red herring. If the key is 256
    bits, the factors are around 120 bits. For P-1 to be effective,
    ALL the prime factors of p-1 must be less than about 10^8, with 
    perhaps a single additional factor less than 10^14. (assuming an
    FFT extension to the algorithm). The chances of this happening are
    vanishingly small. The largest factor EVER found with P-1 has 34 decimal
    digits. This is 109 bits; still 10 bits smaller than one gets with
    a 256-bit key.

    For larger keys, the chance that p-1 has no prime factor greater
    than 10^14 is virtually nonexistent.

:operation in DSS, when you need a 160-bit prime q, and a longer prime p,
:for which p-1 is a multiple of q.
: 
 
rest deleted....

(3) Finally, the rest of what you propose is unnecessary. 
 
ECM renders the P-1 algorithm obsolete. And finding a "strong" prime
by your definition does not protect from an ECM attack getting lucky.
It is about as likely that an ECM attack will succeed as the chance that
a random 100-digit prime can be found by P-1.

It is possible to generate large primes very fast in such a way that
you can prove they are prime very quickly. Take two moderate primes
p and q [moderate means p is (say) 20-30 digits and q is ~80 digits].
Now simply look at numbers of the form  rpq + 1  and rpq - 1 for small
to moderate r. Consider only those r such that rpq + 1 and rpq -1 
are not divisible by small primes. If you suspect one of these is prime,
then it is trivial to construct a primality proof since you have a 
complete factorization of p-1 or p+1.

If p ~ 20 digits and q ~80 digits isn't good enough, use slightly
larger. The potential values of r which should be tried can be
constructed as a wheel.

:So here are some useful techniques:
: 
:First of all, trial division by small primes is a very useful thing.
:Basically, each prime p will weed out 1/p of the candidates.  If this
 
Negative. Each prime does NOT weed out 1/p. For example, if you sieve
by 5, you must remember that 1/3 of the numbers you hit have already been
sieved out by 3. The fraction is really: (1-1/2)(1-1/3)(1-1/5).....(1-1/p)
By Mertens' theorem this is approximately exp(-gamma)/log p.
 
:can be done at a cost of about one multiply, it's significantly
:thousand times faster than a Fermat test to the base 2, the cheapest
 
One is usually doing these divisions on multi-precise numbers. They
are significantly more expensive than one multiply.

:pseudo-primality test.
: 
:Obviously the smaller the prime, the more lucrative the trial division.
 
Secondly, even if one wants to do this, one should use a SIEVE, not
trial division.

-- 
Bob Silverman
These are my opinions and not MITRE's.
Mitre Corporation, Bedford, MA 01730
"You can lead a horse's ass to knowledge, but you can't make him think"
