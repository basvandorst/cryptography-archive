Path: msuinfo!news.mtu.edu!sol.ctr.columbia.edu!howland.reston.ans.net!europa.eng.gtefsd.com!MathWorks.Com!yeshua.marcam.com!zip.eecs.umich.edu!newsxfer.itd.umich.edu!gumby!yale!yale.edu!nigel.msen.com!zib-berlin.de!news.th-darmstadt.de!fauern!rrze.uni-erlangen.de!not-for-mail
From: unrza3@cd4680fs.rrze.uni-erlangen.de (Markus Kuhn)
Newsgroups: sci.crypt
Subject: Is this hash function secure?
Date: Thu, 14 Apr 1994 20:10:30 +0200
Organization: Regionales Rechenzentrum Erlangen, Germany
Message-ID: <2ok0umEgbn@uni-erlangen.de>
Reply-To: mskuhn@cip.informatik.uni-erlangen.de
NNTP-Posting-Host: cd4680fs.rrze.uni-erlangen.de
Lines: 73

The following algorithm is used in a popular consumer electronics product.
The security of this product is based on the assumption, that it is not
possible to guess the key[] from sending test text messages (32 bytes long)
to decode() and looking at the 8-byte answers.

Is this algorithm similar to one described in the literature? What
cryptoanalysis steps would you suggest in order to get the key[] from
a known or choosen plain text (= msg) attack? Just curious ...

Markus


/*
 * an example for the secret key
 */
const unsigned char key[32] = {
  0x6c, 0xbc, 0xaf, 0xc3, 0x2b, 0xb5, 0xdc, 0x90,
  0xf9, 0x05, 0xea, 0x51, 0x46, 0x9d, 0xe2, 0x60,
  0x70, 0x52, 0x67, 0x26, 0x61, 0x49, 0x42, 0x09,
  0x50, 0x99, 0x90, 0xa2, 0x36, 0x0e, 0xfd, 0x39
};


/*
 * This is the core function of the decryption algorithm
 * which is iterated 99 times by decode(). This code assumes that
 * unsigned char is exactly 8-bit long.
 */
void kernel(unsigned char *out, int *oi, const unsigned char in)
{
  unsigned char b, c;

  out[*oi] ^= in;
  b = key[(out[*oi] >> 4)];
  c = key[(out[*oi] & 0x0f) + 16];
  c = ~(c + b);
  c = (c << 1) | (c >> 7);    /* rotate 1 left */
  c += in;
  c = (c << 1) | (c >> 7);    /* rotate 1 left */
  c = (c >> 4) | (c << 4);    /* swap nibbles */
  *oi = (*oi + 1) & 7;
  out[*oi] ^= c;

  return;
}


void decode(const unsigned char *msg, unsigned char *answ)
{
  int i;
  int oi = 0;           /* index in output array answ[] */

  for (i = 0; i < 8; i++) answ[i] = 0;
  for (i = 0; i < 27; i++)
    kernel(answ, &oi, msg[i]);
  kernel(answ, &oi, 0);
  kernel(answ, &oi, 0);
  oi = (oi + 1) & 7;
  for (i = 27; i < 30; i++) {
    kernel(answ, &oi, msg[i]);
    kernel(answ, &oi, msg[i]);
    oi = (oi + 1) & 7;
  }
  for (i = 0; i < 64; i++)
    kernel(answ, &oi, msg[31]);

  return;
}


-- 
Markus Kuhn, Computer Science student «°o°» University of Erlangen, Germany
Internet: mskuhn@cip.informatik.uni-erlangen.de   |   X.500 entry available
