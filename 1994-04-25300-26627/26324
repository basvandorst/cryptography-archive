Path: msuinfo!agate!howland.reston.ans.net!gatech!udel!MathWorks.Com!zombie.ncsc.mil!golf!mizzou1.missouri.edu!C445585
From: C445585@mizzou1.missouri.edu
Newsgroups: sci.crypt
Subject: crypto-strengh PRNGs
Date: Sun, 24 Apr 94 23:49:32 CDT
Organization: University of Missouri, Columbia
Lines: 91
Message-ID: <16FA214F0CS86.C445585@mizzou1.missouri.edu>
NNTP-Posting-Host: mizzou1.missouri.edu

>From: jktaber@netcom.com (John K. Taber)
>Subject: Re: Yet Another Secure? RNG
>Date: Sun, 24 Apr 1994 02:48:16 GMT
 
>So, with non-linear, and long period, I'm getting the idea we need
>massive diffusion of changes.  That is a pre-req for
>encryption.  The thinking is simple -- to solve even one bit,
>the analyst must also solve all bits.  The reason for this pre-req
>must be to prevent piecemeal attacks.
 
   Hmmm.  The need for long period is obvious.  I don't really agree,
though, that the massive internal diffusion of changes is necessary
for a crypto-strength PRNG.  I think the important thing is that an
analyst can't find a way to get at the linear pieces of the PRNG.
 
   Some stream ciphers are based on LFSRs, which internally change only
linearly.  Multiple LFSRs are combined nonlinearly, and the output
streams are often decimated by another LFSR.  There are a lot of ways
to do this.  The idea seems to be to divide up the design--LFSRs are
well-understood, and they can be guaranteed to give a nice long-period
stream of bits.  Unfortunately, since they're linear, any access to
the stream of bits of the driving LFSRs (or any equivalent set of
driving LFSRs) allows the analyst to get the internal state of the LFSRs.
 
   As a really complicated example:  Suppose I devised a crypto-strength
PRNG (to be used as a stream cipher) by using the output from a software
simulated LFSR to apply substitutions to the internal 512-bit input
buffer of MD5.  It looks like this could be quite secure--the LFSR is
linear, but MD5 combines previous and current LFSR information in a way
that will make it very hard for an attacker to retrieve the LFSR stream.
 
   This could be something like:
 
   S() is a 256-element list of 32-bit values.
   X(16) is the 16 32-bit word input buffer to MD5.
   LFSR_OUT() is the next 8-bit output from a software-simulated LFSR.
 
 
   For i = 0 to 15 do
     X(i) = LFSR_OUT()
 
   Output = MD5(IV, X())
 
   Now, there are advantages to making the internal state change
nonlinearly and quickly, of course.  However, I think the main thing
is never to give an analyst
 
1.  A direct shot at the outputs of weak PRNGs.
2.  Enough information to probabilistically test a guess about
    some manageable subset of the bits of state.  (Ie, my attack
    against the low order 17 bits of one of the earlier versions
    of the PRNG.)
 
>We don't seem to be eliciting much interest, so maybe this rng is
>hopelessly flawed or incomprehensible.
 
   I've been following the discussion, but I've been pretty busy with
work, and what time I've had, I've been mostly focusing on BLOWFISH and
such stuff lately.  However, it seems like most of this class of PRNG
is going to be vulnerable to attacks that guess some subset of the
rotors, and test the guess against some outputs in terms of differences.
This looks something like
 
   Rotor1(0) + Rotor2(0) + Rotor3(0) = X
   ...
   Rotor1(0) + Rotor2(0) + Rotor3(1) = Y
 
   This gives me Rotor3(1) - Rotor3(0) with some time offset.  This
can apparently be defeated by making Rotor3(1) get clobbered in some
unintuitive way based on hidden state between the appearance of X and
Y in the output.  However, this will simply mean that you leak that
hidden state information you're using to clobber Rotor3(1).
 
   I think a better approach might be to start with a PRNG that gives
good output stats, but needs to be shielded from an attacker's view,
and then come up with a way to use it to generate bits.  For example,
how about something like:
 
   Generate 16 AFSR outputs.
 
   Use another AFSR to select 3 of them, A,B, and C.
 
   Let X = (A AND B) OR (NOT A AND C).  (This is a bitwise select.)
 
   This is simple, fast, and probably not secure as it stands.  How would
you attack it?
 
 
>John K. Taber                                 jktaber@netcom.com
 
   --John Kelsey, c445585@mizzou1,missouri.edu
