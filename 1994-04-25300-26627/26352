Path: msuinfo!agate!dog.ee.lbl.gov!ihnp4.ucsd.edu!news.cerf.net!mvb.saic.com!MathWorks.Com!europa.eng.gtefsd.com!news.umbc.edu!olson
From: olson@umbc.edu (Bryan G. Olson; CMSC (G))
Newsgroups: sci.crypt
Subject: Re: DES Key question
Date: 25 Apr 1994 18:23:37 GMT
Organization: University of Maryland, Baltimore County
Lines: 33
Distribution: world
Message-ID: <2ph1r9$n9k@news.umbc.edu>
References: <2pga47$psb@godot.cc.duq.edu> <6018@tdbunews.teradata.COM>
NNTP-Posting-Host: umbc7.umbc.edu
X-Newsreader: TIN [version 1.2 PL2]

Gary Jones (gdj@ElSegundoCA.NCR.COM) wrote:
: In article psb@godot.cc.duq.edu, wynn@next.duq.edu (Joseph Wynn) writes:

: > I wrote a program to do DES.  I have a section of code that creates the 
: > 
: > I am having a problem understanding what to do for decryption.  For 
: > decryption, can you just use the same keys, 1 through 16, that you used 
: > for encryption, but in reverse order?
: > 

Yes.

: For encryption, the first step in key-selection is a series of left-rotates. 
: For decryption, this first step consists of a series of right-rotates in the 
: reverse order.

That's just a convenient way to produce the same keys in reverse
order in hardware implementations.  In software it's easiest to write
one bit-twiddling routine and then reverse the order of the keys.

Most software implementations have a load_key() procedure which takes
as parameters the 64 bit key and a flag to determine whether to
reverse the order of key vectors for decryption.  It produces a table
of the 16 key vectors, which gets passed to the block encryption
routine.  Thus the only difference between encryption and decryption is
whether the flag causes the execution of a small section of code that
reverses the key vectors.

Exhaustive password crackers work differently, since they need
fast key loading.

--Bryan Olson

