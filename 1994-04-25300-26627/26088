Path: msuinfo!agate!ihnp4.ucsd.edu!usc!rand.org!jim
From: jim@rand.org (Jim Gillogly)
Newsgroups: sci.crypt
Subject: Re: PUZZLE or exercise with phi-test
Date: 16 Apr 1994 15:12:33 GMT
Organization: Banzai Institute
Lines: 104
Message-ID: <2oov91$ovf@rand.org>
References: <straitsCo8Mxs.5qn@netcom.com>
NNTP-Posting-Host: mycroft.rand.org

In article <straitsCo8Mxs.5qn@netcom.com>, Stewart C. Strait wrote:

> Let the plaintext, ciphertext, and key be respectively
> p[0],p[1], ...;  c[0],c[1], ...; and k[0],k[1], ...  .
>
> Then c[i]=p[i]+k[0]+ (sum over all p such that (2**p) & i is nonzero)
> of k[p+1].
>
> Plaintext:   THIS ISQU ITEA WEAK SYST EM
> Keys used:   YYYY YYYY YYYY YYYY YYYY YY
>               P P  P P  P P  P P  P P  P
>                MM   MM   MM   MM   MM
>                   IIII      IIII      II
>                        WWWW WWWW
>                                  XXXX XX
>              ---------------------------
> Ciphertext:  RUSR ONIB CCKV YVON NIZP HE

and offered a challenge cipher starting

> straits.3.002; VIGROTOR; 1024 Ciphertext letters.
> ACGUR UMWKH HIARZ RWNTW SRNFG LLMVB LDNQG FCPYB ZICUR YUDKG MDDQJ XKSMN

Probably a number of different approaches would work with this.  As a
one-off, I tried quick-and-dirty attacks that took more time overall than
an elegant attack would have used.  Step 1 was observing that subtracting
the first 512 bytes from the last 512 gives a distribution of differences
that depends only on the 11th key byte, k[10]:

	c[512] - c[0] = p[512] - p[0] + k[10]
	c[513] - c[1] = p[513] - p[1] + k[10]
	c[514] - c[2] = p[514] - p[2] + k[10]
	c[515] - c[3] = p[515] - p[3] + k[10]
	c[516] - c[4] = p[516] - p[4] + k[10]

If a word from the first half happens to line up with a word in the second
half, a string of equal values will show up in the ciphertext differences,
and that value will be k[10].  The longer the string, the more confidence
we have that it wasn't due to chance.

Given the underlying roughness of English, an E in one half will wind up
adjacent to an E in the second half more often than average (as with the
other high frequency letters); so k[10] should be one of the most frequent
values for the ciphertext difference to take.  The same concept works for
other key-letters with decreasing confidence as the segments get shorter:

	k[10]=D (strong confidence)
	k[9] =P or A, maybe E;
	k[8] =F (matching string of 3) or VGSX
	k[7] =H (strong)
	k[6] =K (very strong)
	k[5] =M or X, maybe B or H
	k[4] =maybe HQSW
	k[3] =perhaps GW
	k[2] =BIL??
	k[1] =who knows
	k[0] =no information, since it's applied to all plaintext

For the first few bytes, exhaustive search is good enough.  With five
bytes of key we get 16 bytes of output; with six bytes of key we get 32.
To recognize when we're done, adding logarithms of English digraphs works
well enough, as would other standard techniques like looking for English
words using a hash table.  With an exhaustive search of 6 bytes, the
correct result gets the highest score.  With 5 bytes, it's close enough to
the top to spot, and a much shorter run:

wgskb easaliosnesnteam: 99      wyxta eindchamonorlenh: 91
hovgz theeeteaengtorsw: 94      wcssb eesedegonisrlasi: 91
pzzur loshimepecceasat: 93      ubigm gherrteneattoefw: 91
pfajk liratrotldiesere: 93      tbjgn hiersueneassoeev: 91
nmtcx ndacctecaletotua: 93      oazvr mothileofcdearas: 91
larss presorschenofwnf: 93      mdobu ongreelseynlthet: 91
gewxx useoonnthaifandr: 93      hovro theetitppyreorsw: 91
abcfs abermofosonndtar: 93      hovgb theeeteaclermpqu: 91
xebgc dbisoniolehevith: 92      herqs trisutyelerolyth: 91
worhj esttodsofolyorwa: 92      hergc trisediobuhelyth: 91
sgwob iesalikorisntewi: 92      eylfr warhinsepobeatoi: 91
pjpcr lechaughesmesacl: 92      eqpjg winlerkeahithirt: 91
pfnwn liengeotiasocoob: 92      zszkd blieitewingponoo: 90
jtpan raidisofosweecon: 92      wpgrn eredestobjseactw: 90
iafvg suthoreowtoprild: 92      wovgk espppeplengtorsw: 90
hovsb theeshsocleradei: 92 ---> vqxww fromanystatenopr: 90
ekonc woosathhernehosa: 92      uemtj geakednthasperrf: 90

With the first 5 key bytes in hand, I tried each of the other likely keys
from the first phase in turn, and ended up with VQXWWXKHFAD.  Each of the
higher key bytes was on the list of possibles, though not always first.

Simpler would have been to eliminate the first stage altogether, and given
the first few key bytes, get each subsequent byte in turn: with each
correct new choice, we double the length of exposed plaintext, so it's a
linear search for the correct one -- as in the movie War Games, where WOPR
found digits of the secret code one at a time.

Stewart said:
> If I end up posting a lot of these I'll probably use rec.puzzles
> instead of sci.crypt and just give a brief announcement in sci.crypt.
> (Unless there is a consensus that they belong here.)

IMHO sci.crypt is appropriate for the initial posting; probably rec.puzzles
is best for subsequent ones.
-- 
	Jim Gillogly
	Trewesday, 25 Astron S.R. 1994, 15:12
