Path: msuinfo!agate!howland.reston.ans.net!europa.eng.gtefsd.com!MathWorks.Com!blanket.mitre.org!linus.mitre.org!linus!mbunix!eachus
From: eachus@spectre.mitre.org (Robert I. Eachus)
Newsgroups: sci.crypt
Subject: Re: Encryption Using Huffman Coding
Date: 1 Apr 94 10:45:04
Organization: The Mitre Corp., Bedford, MA.
Lines: 42
Message-ID: <EACHUS.94Apr1104504@spectre.mitre.org>
References: <CnKDnt.3vr@chinet.chinet.com>
NNTP-Posting-Host: spectre.mitre.org
In-reply-to: schneier@chinet.chinet.com's message of Fri, 1 Apr 1994 04:55:04 GMT


In article <CnKDnt.3vr@chinet.chinet.com> schneier@chinet.chinet.com (Bruce Schneier) writes:

  > If you take a data file and compress it using Huffman coding techniques,
  > you get something that looks random.  Make the coding table the key, and
  > the compressed text is now ciphertext.  Although there is no reason to
  > believe that this is in any secure, I know of no one who has any idea how
  > to cryptanalyze it.

  > I have heard a lot of folklore on this topic; does anyone know of any
  > actual reserach results?

     It's not that hard, and I've done it.  (Lost the tables used to
compress a 20K file.  It took me a few hours to recover the file, and
this was when computers were a lot slower.)

     What did I do?  I had the algorithm used to build the tables
handy, so I compressed a similar file (this was a database of names
and addresses), and tried to read the original data with those tables.
Since the Huffman coding is self-correcting, all I had to do was find
the two or three cases where the tail of the tree was different, then
it was a simple substitution cipher.  If you really are curious, try
the experiment.  A novel and an address list will create very
different tables, but those for two different address lists (or two
different novels) will be almost identical.  And since the differences
are in the low frequency part of the tables, you will get recognizable
strings instantly.

     You could make it more difficult by arbitrarily permuting the
ones and zeros and choosing random digraphs to encode.  This version
of Huffman encoded several dozen common digraphs as single symbols,
prefixed digits with a number shift. and treated upper-case with a
preceding single character shift.  (Oh yes, it ran on a PDP-1.  That
is not a typo: one not eleven.)

--

					Robert I. Eachus

with Standard_Disclaimer;
use  Standard_Disclaimer;
function Message (Text: in Clever_Ideas) return Better_Ideas is...
