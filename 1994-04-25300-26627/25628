Newsgroups: sci.crypt
Path: msuinfo!agate!ihnp4.ucsd.edu!swrinde!cs.utexas.edu!uunet!mnemosyne.cs.du.edu!nyx10!colin
From: colin@nyx10.cs.du.edu (Colin Plumb)
Subject: Re: Computing multiplicative inverses
Message-ID: <1994Apr7.075115.2730@mnemosyne.cs.du.edu>
X-Disclaimer: Nyx is a public access Unix system run by the University
 	of Denver for the Denver community.  The University has neither
 	control over nor responsibility for the opinions of users.
Sender: usenet@mnemosyne.cs.du.edu (netnews admin account)
Organization: Nyx, Public Access Unix at U. of Denver Math/CS dept.
References: <199404061759.SAA16140@an-teallach.com>
Date: Thu, 7 Apr 94 07:51:15 GMT
Lines: 25

In article <199404061759.SAA16140@an-teallach.com>,
Graham Toal <gtoal@an-teallach.com> wrote:
>Anyway, why am I telling you this, when it's stuff everyone knows?
>Well, the same trick isn't quite so obvious for *division* by a
>constant!
>
>How we did it was like this:  first of all, assume 16 bit ints (you
>can scale this up yourself later; in fact we *were* using 16 bit ints
>in our space games.)  Let's say we want to divide by 10 instead of
>multiplying by it...  well, n / 10  is  n / 10  * 65536/65536  which is
>(n * 65536/10) / 65536 - so we'd code up a shift-and-add multiply
>routine for multiplying by 6553, then do the divide just by extracting
>the top two result bytes from the 4-byte product...

This general technique is analyzed in "P.D. Barrett, "Implementing the
Rivest Shamir and Adleman public key encryption algorithm on a standard
digital signal processor," Advances in Cryptology: Proc. Crypto '86,
Lecture Notes in Computer Science 263, Springer-Verlag 1987.  (This is
out of another bibliography I have, in the Crypto '93 proceedings,
so it may refer to other papers for the bulk of the work.)

Basically, yes, this works.  Apparently something similar is done in the
HP Precision compilers to do division by constants.
-- 
	-Colin
