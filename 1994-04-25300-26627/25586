Path: msuinfo!agate!dog.ee.lbl.gov!ihnp4.ucsd.edu!usc!howland.reston.ans.net!pipex!demon!an-teallach.com!gtoal
Newsgroups: sci.crypt
From: gtoal@an-teallach.com (Graham Toal)
Subject: Re: Computing multiplicative inverses
X-Phone: +44 31 662 0366
X-Fax: +44 31 662 4678
X-Organisation: An Teallach Limited
Date: Wed, 6 Apr 1994 18:06:21 +0000
Message-ID: <199404061759.SAA16140@an-teallach.com>
Sender: usenet@demon.co.uk
Lines: 44

::More on finding multiplicative inverses
::
::The general method for finding multiplicative inverses (the Extended
::Euclidean Algorithm) involves repeated division.  This is annoyingly
: 
:Negative. Use Lehmer's method. (see Knuth Vol. 2) it involves
:NO division at all; only shifts and add/subtract.

I don't know if this is relevant to the current discussion, but it's
a nice hack I thought more people would be interested in knowing if
they haven't come across it before.

Way back when, I used to do a little video-game programming on 8-bit
micros.  We used all sorts of tricks for getting speed up.  Lots of
stuff would be table driven, for instance, but every now and then
you had to do something like a multiply over a range that was too
big for a table.  So we'd use the old shift-and-add trick. (Obviously
I'm talking about multiplication by a constant here)

for instance, n * 10  was equivalent to n * 8 + n * 2  which was
n << 3 + n << 1  which was  ((n << 2) + n) << 1) which all worked out
very neatly on a processor that could shift by constants quickly, or
add, but not multiply.

Anyway, why am I telling you this, when it's stuff everyone knows?
Well, the same trick isn't quite so obvious for *division* by a
constant!

How we did it was like this:  first of all, assume 16 bit ints (you
can scale this up yourself later; in fact we *were* using 16 bit ints
in our space games.)  Let's say we want to divide by 10 instead of
multiplying by it...  well, n / 10  is  n / 10  * 65536/65536  which is
(n * 65536/10) / 65536 - so we'd code up a shift-and-add multiply
routine for multiplying by 6553, then do the divide just by extracting
the top two result bytes from the 4-byte product...

Now, the more astute of you will realise that this doesn't actually
give 100% accurate results near the boundaries, and the rounding error
doesn't always go the way you'd expect, but for what we used it for
it was a useful and very fast technique.  I just thought I'd mention
it on the offchance that it might be useful for someone else out there
in some application or other...

G
