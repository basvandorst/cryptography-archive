Path: msuinfo!news.mtu.edu!sol.ctr.columbia.edu!howland.reston.ans.net!news.ans.net!hp81.prod.aol.net!search01.news.aol.com!not-for-mail
From: elde@aol.com (Elde)
Newsgroups: sci.crypt
Subject: Re: Encryption Using Huffman Coding
Date: 1 Apr 1994 03:10:23 -0500
Organization: America Online, Inc. (1-800-827-6364)
Lines: 28
Sender: news@search01.news.aol.com
Message-ID: <2ngktf$1d7@search01.news.aol.com>
References: <CnKDnt.3vr@chinet.chinet.com>
NNTP-Posting-Host: search01.news.aol.com

In article <CnKDnt.3vr@chinet.chinet.com>, schneier@chinet.chinet.com (Bruce
Schneier) writes:

>If you take a data file and compress it using Huffman coding techniques,
>you get something that looks random.  Make the coding table the key, and
>the compressed text is now ciphertext.  Although there is no reason to
>believe that this is in any secure, I know of no one who has any idea how
>to cryptanalyze it.

>I have heard a lot of folklore on this topic; does anyone know of any
>actual reserach results?

The problem here is that the 'key' (code table) must be sent along with the
data, or else it cannot be decrypted or decompressed.  This requires a second
secure means of communication.

A better solution might be to use a LZW style compression.  Use a private key
to initialize a PRNG, and a standardized initial dictionary.  Updates to the
PRNG can be sent in the data stream in the same manner that updates to the
dictionary are sent.  (Or data (or cipher) blocks can also be fed into the
PRNG).

In practice, this gives you two keys, one the initialization vector for the
PRNG, and one the standard dictionary.  (this could also serve as a pseudo
Public Key system, or by using different standard dictionaries, as the boundary
definitions for differing communications nets)

Derek L.
