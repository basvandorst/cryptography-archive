Path: msuinfo!agate!howland.reston.ans.net!wupost!waikato!auckland.ac.nz!pgut01.cs.aukuni.ac.nz
From: pgut01@cs.aukuni.ac.nz (Peter Claus  Gutmann)
Newsgroups: sci.crypt
Subject: Re: Q: Security of new encryption-devdriver
Date: 13 Apr 1994 07:24:52 GMT
Organization: University of Auckland
Lines: 49
Message-ID: <2og6o4$mnq@ccu2.auckland.ac.nz>
References: <2nq8d6$kkp@liberator.et.tudelft.nl> <2nt40b$nk@ccu2.auckland.ac.nz> <2oels0$su0@freenet3.scri.fsu.edu>
NNTP-Posting-Host: cs13.cs.aukuni.ac.nz
X-Newsreader: NN version 6.5.0 #7 (NOV)

misha@freenet3.scri.fsu.edu (Michael Smith) writes:

>Peter Gutmann (pgut01@cs.aukuni.ac.nz) wrote:
>: There is a flaw in this reasoning which contributed to my decision to encrypt
>: raw partitions rather than use the drive-within-a-drive approach.  The
>: important point is that you don't want to use a different IV for each *sector*,
>: but for each *new encrypted data block*.  This means that if you read a sector,
>: change a byte, and write it back out again, you must change the IV.  This
>: necessitates keeping a unique IV somewhere for each sector, which is changed
>: each time the sector is updated.  
> 
>Is this still true when using CBC mode?  In CBC mode you have:
> 
>  c_0 = E(p_0 xor IV)
> 
>(where p_0 is the first plaintext block, c_0 is the first
>ciphertext block).
> 
>Therefore even if you re-encrypt a different plaintext block with
>the same IV, an attacker can't recover the new plaintext block,
>even if he knew the old one (which is not the case in CFB mode)

It's still a problem in CBC mode.  From the SFS docs:

When a block cipher is converted to handle units of data larger than its
intrinsic block size, a number of weaknesses can be introduced, depending on
the mode of operation which is chosen for the block cipher.  For example, if
two identical ciphertext blocks are present in different locations in a file,
this may be used to determine the plaintext.  If we can find two identical
blocks of ciphertext when cipher block chaining (CBC) is used, then we know
that:
 
    P[ i ] = d( C[ i ] ) ^ C[ i-1 ]
    P[ j ] = d( C[ j ] ) ^ C[ j-1 ]
 
where C is the ciphertext, P is the plaintext, and e() and d() are encryption
and decryption respectively.  Now if C[ i ] = C[ j ], then d( C[ i ] ) =
d( C[ j ] ), which cancel out when xor'd so that:
 
    P[ i ] ^ C[ i-1 ] = P[ j ] ^ C[ j-1 ]
 
or:
 
     P[ j ] = P[ i ] ^ C[ i-1 ] ^ C[ j-1 ]
 
Knowing C[ i ] and C[ j ] we can determine P[ i ] and P[ j ], and knowing
either P[ i ] or P[ j ] we can determine the other.

Peter.
