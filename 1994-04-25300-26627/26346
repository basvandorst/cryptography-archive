Path: msuinfo!agate!howland.reston.ans.net!usc!rutgers!igor.rutgers.edu!thorium.rutgers.edu!leichter
From: leichter@thorium.rutgers.edu
Newsgroups: comp.security.misc,alt.security,sci.crypt,alt.2600
Subject: Re: Jitec claim world's first virus-proof computer
Message-ID: <1994Apr25.122529.1@thorium.rutgers.edu>
Date: 25 Apr 94 17:25:29 GMT
References: <2o3q7s$319@bmerha64.bnr.ca> <FAIGIN.94Apr8092012@solarium.aero.org> <FAIGIN.94Apr14081828@soldan.aero.org> <2olsn6$jb5@rzsun02.rrz.uni-hamburg.de>
Sender: news@igor.rutgers.edu
Followup-To: comp.security.misc,alt.security,sci.crypt,alt.2600
Lines: 72
Nntp-Posting-Host: thorium.rutgers.edu
Xref: msuinfo comp.security.misc:9442 alt.security:15996 sci.crypt:26346 alt.2600:7738

In article <2olsn6$jb5@rzsun02.rrz.uni-hamburg.de>,
bontchev@fbihh.informatik.uni-hamburg.de (Vesselin Bontchev) writes:
| No, no, I wasn't clear again, sorry. "Writable by each other" is not
| the correct expression. What I mean is: if a user can create (or write
| to) a program which another user can execute, then a virus is able to
| spread from the first user to the second. Usually it is also the other
| way around - the second user can create a program which the first user
| can execute - that's why I said "by each other", but I admit that it
| is not precise.
| 
| BTW, this includes the situation you describe above. If all users are
| able to create only rwx--x--x files, then Alice can write a virus, let
| it infect a game she has written, and tell Bob: "look what a cool game
| I wrote". The permissions even will not permit Bob to examine the file
| and check it for viruses, but will let him execute it. From that
| point, the virus becomes able to infect all executable programs that
| belong to Bob, plus all those to which he has write access (hopefully
| none besides those in the first set), plus all those to which he as
| the right to chmod them to writable by him. Then the virus can spread
| to third user, Clark, when he executes any of Bob's programs, and so
| on, until the full POset of users between whom a transitive
| information flow exists.
|
Actually, one can do better than this with a slightly different file protec-
tion semantics.

Suppose that the rules were the following:  No executing program may either
(a) write to a file that has x permission for anyone; or (b) chmod any file to
add x permission for anyone unless the owner of the executing program is (1)
the same as the owner of the file being changed or (2) root.

Clause (a) means that you can't modify an executable program at all.  You can,
of course, turn off all the x permissions and *then* write it, but clause (b)
prevents you from then turning the x permissions back on.  The exception
clauses are (2) for trusted programs (particularly the linker); or (1) for
changing your own files any way you like.

Under this semantics, when Bob runs Alice's infected program, the program is
free to infect any of Alice's files - nothing new here, Alice could have
infected her own files herself.  But to infect one of Bob's files, it would
first have to turn off all x accesses - which Bob would surely notice the next
time he tried to run the affected file.

Of course, Bob may just turn x access back on, and thus let the virus in.  Or
it might even delete the old program an create a new one.  These and many
similar scenarios are easily dealt with by carefully defining the semantics.
What it comes down to is that very few programs really need to create executa-
ble files, almost none need to modify them - and one multi-user systems, the
exceptions that involve creating or modifying *another user's* executable
files are so rare that one can probably forbid them without causing undue
harm.

A similar but perhaps more natural (but slightly broader) set of rules is:
A program can only delete, rename, create, chmod, or write to a file that has
x permission for anyone if the program file itself is owned by root or by the
owner of the file; and the same applies to using chmod on any file to turn on
x permission for anyone.

The result would be a system in which viruses could certainly spread as much
as they liked within one person's files, but since the transitive closure of
*executable* files writable by that person would be just that person's files,
it could go no further.

Of course, no protection is absolute.  If Alice induced Bob to *copy* the
infected executable, there's no way any reasonable protection model could
distinguish between the new copy, owned by Bob, and Bob's legitimate programs.
(Ultimately, Alice might have hidden the virus in the source code and induced
Bob to re-compile it himself!)  If Bob then ran the copy, it could infect his
files.  And there are always the "executables" that aren't, like input files
for interpreters.  But one can still do a hell of a lot better than we are
doing today.
							-- Jerry
