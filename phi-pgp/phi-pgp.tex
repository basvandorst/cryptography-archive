% --------------- COPYRIGHT ------------------------
%| AIT - Computer Science Program - Thailand        |
%|   see COPYRIGHT notice                           |
%--------------------------------------------------

% --------------- PRODUCT IDENTIFICATION -----------
%| Product              : phi-pgp                   |
%| Date                 : November 1993             |
%| Last update          : 16 Aug 94                 |
%| Conceived by         : O. Nicole                 |
%| Purpose              : Documentation of Phi-pgp  |
%--------------------------------------------------

\documentstyle{article}
\begin{document}
\title{Phi-pgp\\A GNU Emacs interface to PGP\\\Large Version 1.0}
\author{Olivier {\sc Nicole}\\AIT - Computer Science Program - Thailand\\\tt <on@cs.ait.ac.th>}
\renewcommand{\today}{August 1994}
\maketitle

\tableofcontents

\section{Introduction}
Phi-pgp provides users of  Emacs  mail facilities with a   flexible,
robust and consistent access to PGP (Pretty Good Privacy). 

The interface is flexible  as it offers  all the features one user can
hope for, and those  features only. It is  robust to security and with
handling communication  between Emacs and PGP.   Last it is consistent
with both Emacs and PGP standard use.

\section{Why Phi-pgp?}

This is only a short pronunciation guide. 

Even if it is written  ``phi'', it has nothing  to  do with the  Greek
letter (\verb+$\phi$+, $\phi$)  but it is  the transcription into  the
Roman alphabet of the  Thai world\ldots phi.  In the Thai  alphabet it
should be  written {\it   paw   pahn}, {\it  sara   ee}  and  {\it  my
toh}. Guess what it looks like?

For a general idea, imagine the letter `M' upside down. Attach a small
circle to the left leg  of the letter at  the top on the outside. Then
above  the   letter, add a   horizontal half  circle  (upper half) and
finally a kind   of acute: '.  And  you finally  get a  ``phi''. Looks
beautiful doesn't it?

It  should never  be  pronounced  ``fi'',  but  rather  something  like
``p'hee''.

concerning the meaning, the first  one is ``older brother'' or ``older
sister''. It is  also used as  a mark of  respect while  addressing an
older person.  Common sense is also  to distinguish to person with the
same nickname, the oldest one becomes automatically phi-someone.

I needed a name to distinguish this interface  from the previous ones,
so why  not ``phi-ing'' the  name.  And I also hope   that, as the new
interface carries more features and brings more wisdom, it is worth the
respect of a phi.

\section{One more Emacs interface to PGP}

I do know other interfaces already exist!  If I wrote a  new one it is
mainly because all the previous interfaces I have  tested or looked at
did not provide the features I was expecting.

Here is the list of the features I was required wich Phi-pgp offers:

\begin{itemize}
 \item  possibility to re-enter  the pass phrase;  as it is allowed by
PGP, it should also be allowed by the interface;

 \item one  single command  needed  to decrypt  messages, whatever the
contents of the message (crypted or signed mail);

 \item the key entered by  the user when encrypting/signing a  message
is thorougly checked;

\item in addition  to that, an Emacs-like completion facility when entering a
key;

 \item same clever default choices as with PGP whenever possible;

 \item encrypting  open to a  free number of recipients, automatically
including every of email message recipient;

\item full filter use of PGP;

 \item user can select pass phrase persistancy during one single Emacs
session;

\item multiple secret keys;

\item flexible handling of Emacs abort C-g;

 \item no modification of  user's mail box while decrypting,  provided
that messages are kept in a separate buffer;

 \item a way to  handle "for your eyes only"  type of crypted messages
(further refered to as {\it view-only}).
\end{itemize}

Well, I managed all this.

\section{Phi-pgp user manual}

This part on the user manual tries to reflect  the GNU Emacs Manual as
much as possible. The notations are thoses used in the Emacs manual.

PGP (Pretty Good Privacy) is a  public-key encryption software written
by Philip Zimmerman and {\it al}.  It has proved useful for electronic
mail encryption. PGP   is available via anonymous  {\tt  FTP}. See PGP
documentation about legal issue regarding copying off PGP.

Phi-pgp provides an interface so  PGP  can be  used within Emacs  mail
facilities.  When installed, Phi-pgp  is automatically  available when
entering the sending or reading mail sub-systems with the {\tt
C-x~m} or {\tt M-x~rmail} commands.

Refer to GNU Emacs Manual for  more information about entering sending
mail or reading mail sub-system.

\subsection{Signing or crypting a mail message}

The commands provided to  sign or encrypt the mail  message to be sent
off are as follows.

{\leftmargini 2cm %to match GNU Emacs Manual style
\labelwidth 1.5cm
\labelsep 0.5cm
\begin{description}
\item[\hbox to 1.5cm{\tt C-c  s\hfill}] 
Signs the mail message using the current secret key ({\tt pgp-sign}).

\item[\hbox to 1.5cm{\tt C-c  S\hfill}] 
Clear-signs the mail message using  the current secret  key. If it  is
text  only, the body  of  the message will not   be modified; only the
appended signature will be in PGP format ({\tt pgp-clear-sign}).

\item[\hbox to 1.5cm{\tt  C-c  e\hfill}]
Encrypts  the mail  message  for one  or several recipients.  The mail
message can be encrypted for every recipient ({\tt pgp-encrypt}).

\item[\hbox to 1.5cm{\tt C-c R\hfill}]   
Encrypts current region of the mail ({\tt pgp-encrypt-region}).

\item[\hbox to 1.5cm{\tt  C-c V\hfill}]  
Encrypts  the mail specifying the  ``for your eyes only'' option, that
is  PGP will not  allow  file-saving of  the  decrypted message ({\tt
pgp\-encrypt-view}).

\item[\hbox to 1.5cm{\tt C-c t\hfill}] 
Signs the mail message using the  current secret key, then encrypts it
for a list of recipients ({\tt pgp-sign-encrypt}).

 
\item[\hbox to 1.5cm{\tt C-c x\hfill}] 
Extracts  the public key corresponding to  the current  secret key and
adds   it  to   the     mail    message at  cursor     position ({\tt
pgp-append\-pubkey}).
\end{description}}

A  mail message can  be encrypted or signed   only inside a Emacs mail
buffer.  The commands are not bound outside the  mail buffer.  Running
the commands  with {\tt M-x}  will  give unpredictable results. Whilst
these commands modify the  body of the  mail contained in the  buffer,
the mail headers remain unchanged.

Encrypting   a mail  message  transforms  contents so  only  the named
persons  will be  allowed to read  it. The  public  key  given to  the
encryption program is meant for those allowed persons.

If the mail has   several recipients,  the  user  of Phi-pgp  will  be
prompted  to enter a PGP  public key for every  recipient of the email
during any PGP phase  that involves encrypting a  message, {\tt C-c e}
({\tt pgp\-encrypt}), {\tt C-c R} ({\tt pgp-encrypt\-region}), {\tt C-c
V} ({\tt pgp-encrypt-view})  or {\tt C-c t} ({\tt  pgp-sign-encrypt}).
That no person ought to be the recipient of  an encrypted mail message
that has not been encrypted for that person.

Emacs mail headers include three possible fields where mail recipients
can be named: {\tt To:},  {\tt CC:} and {\tt BCC:}.   Any one of these
fields may recur several  times in the  mail header and be split  into
several lines.

 ThePhi-pgp user  is first prompted to PGP   public keys for  the {\tt
To:} recipients,  then  {\tt CC:} recipients  and  finally  {\tt BCC:}
recipients. He can also be prompted to additional  PGP public keys. To
terminate the list of additional keys, the user simply enters an empty
key by typing {\tt RET}. The additional list of keys shouldn't be used
to  add user self  public key when  it is needed  for every mail to be
sent. User should take   advantage  of the {\tt   pgp-auto-add-pubkey}
instead,  see section ``Customizing   user  environment'' of  {\it PGP
user's guide}.

Phi-pgp implements a name completing mechanism  when entering a public
key (or later a secret key) is required.  This completion mechanism is
consistent with both  PGP and Emacs.  In PGP,  if you are  used typing
{\tt   boi}      to  refer   to    user  ID:      {\tt   Jean  Bambois
<jb@pointue.tour.la>}, typing  in Phi-pgp  {\tt  boi~RET}  will select
{\tt  Jean  Bambois  <jb@pointue.tour.la>}.    Type {\tt  boi~SPC}  to
display the  selected choice, which allows  you to make modifications,
type {\tt RET} to validate the modifications.  This will check whether
if the  entered string still exists as  a valid public  key.  Typing a
{\tt ?} at any time will display a list of possible completions.  {\tt
RET}, {\tt  TAB}  and {\tt LFD}  bind  to the  commands that complete,
validate and exit, while {\tt SPC} only completes the typed line.

The standard command to   crypt a mail   message is {\tt C-c e}  ({\tt
pgp-encrypt}).  This encrypts all of the mail body.  It is possible to
encrypt   the current  region  only   using  the  {\tt   C-c R}  ({\tt
pgp-encrypt-region}) command.   {\tt C-c  V} ({\tt pgp-encrypt\-view})
tells PGP to set up a special  flag so the  recipient of the mail will
can decrypt and view the message but not save  it in a file. That {\tt
C-c V} applies to the entire mail body.

Signing a mail  message  transforms its contents:  authentification of
the originator can be made and then becomes unforgeable.

During any  PGP phase  that involves  signing  a message, {\tt C-s  s}
({\tt pgp-sign}), {\tt C-c S}  ({\tt pgp-clear-sign})  or {\tt C-c  t}
({\tt pgp-sign-encrypt}),  the secret key  used to sign the message is
the current secret  key;  for a discussion   on  the secret  key,  see
section under ``Managing the secret key'' of {\it PGP user's guide}.

It is always the entire  body of a mail  message that is signed.   The
standard command to  sign a message  is {\tt C-s s} ({\tt  pgp-sign}).
The  pass phrase will unlock  the secret key.  The pass  phrase can be
made permanent inside     Phi-pgp  memory, see  ``Customizing     user
environment''of {\it PGP user's guide} for a discussion on this topic.
To   clear-sign  a message,   use   the  command {\tt   C-c   S} ({\tt
pgp-clear-sign}): the message  will remain readable  for humans and the
signature block will be appended to it.

The last command, {\tt C-c t} ({\tt pgp-sign-encrypt}) signs the entire
message body with the current secret key before encrypting the end result
for the given list of recipient keys.

You    can  add  your   own  public   key  using   {\tt  C-c  x} ({\tt
pgp-append-pubkey}).  It will check in the public keyring for the key
matching  your current secret  ring and then insert  it at the current
point location. This comes useful if you  need to send your own public
key over mail. You can ask Phi-pgp to automatically insert your public
key in encrypted messages, see ``Customizing user environment''of {\it
PGP user's guide}.

The resulting output of Phi-pgp  encrypting or signing a mail  message
is displayed in a temporary buffer called {\tt *PGP output*} that will
pop-up in a  way similar to {\tt  *Help*} buffer. The output looks  as
follows:

\begin{verbatim}
Pretty Good Privacy 2.2 - Public-key encryption for the masses.
(c) 1990-1993 Philip Zimmermann, Phil's Pretty Good Software.
Date: 1993/11/24 05:08 GMT

* Crypted for following key(s):
Key for user ID: Jean Bambois <jb@pointue.tour.la>
22-bit key, for Key ID 911911, created 1993/11/07
\end{verbatim}

\subsection{Decrypting a mail message}

The commands provided  by Phi-pgp to decrypt  a  received mail are  as
follows.

{\leftmargini 2cm %to match GNU Emacs Manual style
\labelwidth 1.5cm
\labelsep 0.5cm
\begin{description}
\item[\hbox to 1.5cm{\tt C-c  d\hfill}]
Decrypts a PGP message or check the signature ({\tt pgp-decr-mess}).

\item[\hbox to 1.5cm{\tt C-c  a\hfill}]
Adds public keys contained in the message to the public keyring ({\tt
pgp-add-key}).
\end{description}}

The two commands are bound inside {\tt rmail-mode} only.

{\tt C-c d}  ({\tt pgp-decr-mess}) is  the only one  command needed to
decrypt  a  PGP  coded  incoming mail. The  command willprompt   PGP to analyse  the contents  of  the
message and either decrypt or check the signature.

If there are several  separated PGP coded packet  in the same message,
PGP will analyse each packet separately.

Here is an example of Phi-pgp output:

\begin{verbatim}
Pretty Good Privacy 2.2 - Public-key encryption for the masses.
(c) 1990-1993 Philip Zimmermann, Phil's Pretty Good Software.
Date: 1993/11/24 06:23 GMT

* Message encrypted for following key:
Key for user ID: Jean Bambois <jb@pointue.tour.la>
22-bit key, for Key ID 911911, created 1993/11/07

This is a sample text.
Without any blank line.
And only three lines.

-------------------- Next packet --------------------

* Signed with following key:
Good signature from user "Jean Bambois <jb@pointue.tour.la>".
Signature made 1993/11/24 06:25 GMT

This is a sample text.
Without any blank line.
And only three lines.
\end{verbatim}

For  ``for your eyes only'' crypted  messages, the resulting text will
be  kept in  a separate  buffer. The  buffer  is read-only,  i.e.: the
contents  of this buffer cannot    be saved. The view-only buffer   is
called {\tt *PGP temp*}. Here is an example of a view-only buffer:

\begin{verbatim}
WARNING:
Some Emacs functions in this buffer have been disabled so the 
buffer cannot be saved.Hey! This is a message marked "For your 
eyes only" after all!

This is a sample text.
Without any blank line.
And only three lines.
\end{verbatim}

To  select it, to view it  and move inside it  are the only authorized
functions  in this buffer. When  several  packets are encrypted  ``for
your  eyes only'' inside  a  single   mail message,  every  packet  is
displayed in the same view-only buffer.

\medskip
If  the  original message contains   public  key blocs, Phi-pgp output
reads as follows::

\begin{verbatim}
* Message containing the following public key(s)
Key for user ID: Jean Bambois <jb@pointue.tour.la>
22-bit key, for Key ID 911911, created 1993/11/07
- signed with key ID 17, for user ID: La Poigne <poigne@foire.la>

To add the key(s) to your public keyring, type "C-c a" 
in RMAIL buffer.
\end{verbatim}

Now you can add  the key just received  to your public keyring typing
{\tt C-c a} ({\tt pgp-add-key}).  Phi-pgp output will look like:

\begin{verbatim}
* Following new key(s) and signature(s) added:

Key for user ID: Jean Bambois <jb@pointue.tour.la>
22-bit key, for Key ID 911911, created 1993/11/07
- signed with key for user ID: La Poigne <poigne@foire.la>
  key ID 17, created 1993/11/19

 1 new key(s) and 1 new signature(s) added.
To sign the new key(s) yourself, run "pgp -ks"
To edit the trust information, run "pgp -ke"
\end{verbatim}

The output says it all.

As Phi-pgp output  can itself contain  PGP coded material, {\tt C-c d}
({\tt pgp-decr\-mess}) and {\tt C-c a} ({\tt pgp-add-key}) commands can
be run recursively on both   {\tt *PGP output*}   or {\tt *PGP  temp*}
buffers.

\subsection{Managing the secret key}

The commands provided  to manage the secret key are as follows.

{\leftmargini 2cm %to match GNU Emacs Manual style
\labelwidth 1.5cm
\labelsep 0.5cm
\begin{description}
\item[\hbox to 1.5cm{\tt C-c  k\hfill}]
Sets the secret key to a user given value ({\tt pgp-set-seckey}).

\item[\hbox to 1.5cm{\tt C-c  K\hfill}]
Displays the secret key's current value ({\tt pgp-view-seckey}).
\end{description}}

Phi-pgp  allows   you to  use  different  secret  keys.   If  no  {\tt
pgp-default-seckey} variable (see   next section) is set, the  default
key will be the last secret key added to the secret keyring.

To  change the  secret key,  use {\tt  C-c  k} ({\tt  pgp-set-seckey})
command. The  command runs the key  completion mechanism described for
mail encryption.

To display the current  secret key, use   {\tt C-c  K} ({\tt
pgp-view\-seckey}) command.  The   key's value will  be displayed  in the
Minibuffer.

The  two   commands are significant   inside send-mail  mode only.  In
read-mail mode, as the secret  key used to decrypt  a message has been
chosen by the message's originator, it cannot be selected by the user.

\subsection{Customizing user environment}

The variables the  user may  wish to  set to  change the behaviour  of
Phi-pgp are as follows:

{\leftmargini 2cm %to match GNU Emacs Manual style
\labelwidth 1.5cm
\labelsep 0.5cm
\begin{description}
\item[\rlap{\tt pgp-default-seckey}]\hfill\\
Is the default user secret key to be used.

\item[\rlap{\tt pgp-delete-pass}]\hfill\\
Set non-{\tt  nil} means Phi-pgp will  not  remember the pass phrase
after it has been used.

\item[\rlap{\tt pgp-self-crypt}]\hfill\\
Set non-{\tt  nil} means Phi-pgp will always  enrypt the message for
the mail originator when doing encryption.

\item[\rlap{\tt pgp-auto-add-pubkey}]\hfill\\
Set non-{\tt nil} automatically add the  originator of the mail public
key inside the encrypted mail message.
\end{description}}

When multiple  secret keys are  available in the secret keyring, the
user  can set the  default key to be used. If  no default key  is set, the
key most recentely added to the secret keyring will be used.

To set the     default secret   key,   add  the   following  to   your
\verb+~/.emacs+ file:

\begin{verbatim}
(setq pgp-default-seckey "my prefered secret key")
\end{verbatim}

If no secret key  exists, matching {\tt my  prefered secret key},  you
will be prompted for a valid secret key the first time Phi-pgp needs a
secret key.

Phi-pgp keeps a list of valid pass  phrases, one pass phrase per secret
key. These pass phrases are kept during one single Emacs session only.

Keeping the  pass phrase associated to a  secret key in an  Emacs Lisp
variable  constitutes a   security   hole.   If Emacs   crashes,   the
variable's value will be available in the {\tt core} dumped file.

Using PGP on a multi-user system also constitute a security hole.

For better  security,  the user can choose  to  delete the pass phrase
every time  it has been   used. To do so,  add  the following to  your
\verb+~/.emacs+ file:

\begin{verbatim}
(setq pgp-delete-pass t)
\end{verbatim}

For  better  facility  the pass phrase  can   be kept  along with  the
associated secret key  during the whole of an  Emacs session.  This is
definitively  a   wise  choice:  I  do    not  particularly  enjoy  to
blind-typing a 30  or 40 character long  string every time I receive a
mail message.

As  the value of the  pass phrase is kept  in Emacs memory only, it is
anyway safer  than when  for  example setting the {\tt  PGPPASS} shell
environment variable. Basically it  provides the same facilities  too,
the pass phrase needs to be entered, correctly, only once.

\medskip
To tell Phi-pgp any time it encrypts a mail message that it should add
your own key  to the list of  the persons messages  are encrypted for,
add the following to your \verb+~/.emacs+ file:

\begin{verbatim}
(setq pgp-self-crypt t)
\end{verbatim}

The commands concerned with {\tt  pgp-self-crypt} are {\tt C-c e}  ({\tt
pgp\-encrypt}), {\tt C-c~R}  ({\tt pgp-encrypt-region}),  {\tt C-c  V}
({\tt pgp-encrypt-view}) and {\tt C-c t} ({\tt pgp\-sign-encrypt}).

\medskip
The last variable  only affects the  {\tt C-c e} ({\tt  pgp\-encrypt})
command. It  tells Phi-pgp that you want  your public key to bes added
on the end of the body of the mail, before encrypting  it. if you wish
to do so, add the following to your \verb+~/.emacs+ file:

\begin{verbatim}
(setq pgp-auto-add-pubkey t)
\end{verbatim}

Ther is no point in adding your own public key at  the end of a signed
message as your public key will be used to check the signature. If the
message  is only  partially  encrypted, the  command {\tt C-c~x} ({\tt
pgp-append-pubkey}) only can be used.

\medskip
Making  clear signatures as often as  possible is another user setable
choice. Yet it has not been implemented  in Phi-pgp. As the option can
be selected by modifying the {\tt config.txt} file of PGP.

\section{More about the new features}

Here is a more complete discussion of the various features I wished to
see included in Phi-pgp and the solutions to implement them.

\subsection{Re-enter pass phrase}

PGP allows  the  user  to re-type  the pass  phrase   when it  was given
incorrectely the first time. A very usefull feature indeed.

As most computer  users, I suppose, I  have never been formally taught
how to type  on neither a  typewriter keyboard nor a computer keyboard
where mistakes   are not important and  can  be quickly corrected.  So
when I am  requested  to type  a  pass  phrase, i.e.  a   real phrase,
including several words, and no echo, I am most likely to make typos.

So I really need to be given a chance to type it again.

The PGP interfaces I  have tried use  two techniques to send  the pass
phrase  to PGP: either  they  create   a temporary shell   environment
variable  (the one  called {\tt PGPPASS},   I strongly recommend  that
users don't do that), or they use an un  documented feature of PGP (in
version 2.2 manual): the   shell environment variable  {\tt PGPPASSFD}
that specifies, when set to 0, that PGP should read the pass phrase as
the first line of the standard input.

Neither allows PGP to ask for a new pass phrase.

If the interface can  receive and interpret message  output by PGP and
send   a new pass  phrase, a    second chance  will   be given  to the
user. This   can be done by  running  PGP as an   asynchronous process
within Emacs.

An asynchronous process can be set to send all its  output to a filter
function. The  function will then insert  the output in an  Emacs text
buffer, which is the standard  behaviour.  But it  can also search for
specific character strings: for example   the PGP prompt asking for  a
repeat of the pass phrase.

Communication with the   asynchronous PGP process should be  done
through {\sc pty}'s.  Pipes smply do not works.

In     Phi-pgp, the filter   function  recognizes  three categories of
messages: messages dealing with the pass phrase, messages dealing with
text marked view-only, and a special  treatment has been added in case
Emacs  is trying to   build the  list  of secret    keys from the   secret
keyring. The last two will be  discussed further.  The filter function
also stores every output to an Emacs buffer.

In the case of the pass phrase, the filter will  do the following:

\begin{itemize}
\item recognize the prompt for a pass phrase, 

\item check which pass phrase is needed for that PGP key user ID,

 \item clear the pass phrase  in Emacs memory  after the pass phrase has
been given twice incorrectly.
\end{itemize}

The character strings for the filter function to recognize ought to be
specific enough so they will rarely match in a user message.

\subsection{Single decrypt command}

PGP uses  a single command to decrypt  any kind of text regardless of
the contents of the text, signed  message, crypted text or even public
key bloc.

PGP is also able to work on various PGP'ed blocs in a file in a single
run, for example a public key bloc following a crypted text.

The user will find the  cognitive load that  much lighter when only  a
single Emacs command is needed to work on incoming mail messages.

\subsection{Checking  the keys and completion}

This feature is  an enhancement  of  the standard PGP interface.  With
standard shell level use  of PGP, the user can  either enter the  full
key or  only part of it. In  the later case  PGP will complete it with
the first matching key.

An Emacs  interface  will implement such  a  completion mechanism, but
with Phi-pgp  the  user  can  actually  see   both the result    after
completion and  what key  will be  selected.  The completion mechanism
proposes as  a default  completing  key what  PGP secretly   uses when
runned from shell level; that is, the first  key containing the string
given by the user.  The key  last added to  the keyring being checked
first.

Standard Emacs defaults are   used  to make the  completion  mechanism
transparent to the user.

Implementing  that  mechanism  has revealed  quite  a  few interesting
problems.  Standard Emacs completion  tools are internal functions. As
suc, they are  not written in Lisp.   {\tt completing-read},  the main
function knows  by  default how  to  do  completing from  a prefix  (a
substring located at the beginning only) of a character string.

To have {\tt completing-read} completes from a substring, a programmed
completion had to be written. But the completion function, called {\tt
pgp-collection} will always return a valid complete string rather than
a prefix only.

The GNU Emacs {\tt mouse-choose-completion}  had to be modified too to
reprint the minibuffer   when  completion is selected   from  the {\tt
*Completions*} buffer with the mouse.

Two lists of keys are memorised  by Emacs.  The  list of keys in the public
keyring and the list  of keys in the secret keyring.   The list  of public
keys is  extracted with a {\tt  pgp~-kv}  command, but extracting the list of scret keys was slightly more tricky. It can  be done with a {\tt
pgp~secring.pgp} command, as set  in  PGP documentation.   Then PGP
will prompt the user to add the keys to the secret keyring. This means
a special string has to be filtered from PGP output  to answer {\tt n}
to the prompt.

\begin{sloppypar}
The two lists  are read only once  during a single  Emacs session.  To
force  Emacs  to read them again,  the  {\tt pgp-list-pubring-set} and
{\tt pgp-list-secring\-set} variables can be set to {\tt nil}.
\end{sloppypar}

When new public keys are  added to the  public keyring, the Emacs list
of public keys is upgraded.

PGP  allows  several distinct  secret  keys to  be kept  in the secret
keyring. Phi-pgp  can handle it by  associating a pass phrase to each
different secret key.

\subsection{Free number of encryption keys}

Emacs mail can have three fields to describe  the recipients of a mail
message: {\tt To:},  {\tt CC:} and {\tt  BCC:}. It seems reasonable to
say that  if  a mail message  need  encryption  for one recipient,  it
should be encrypted  with a different  key for each recipient, so that
anyone could read the message at the other end.

This is not only  good in theory. Several times  a month I do  send an
encrypted mail message to multiple recipients.

A user variable  adding the message sender  to  the list of  those for
whom the  message was encrypted, together with  a free number of other
recipients sound like a good idea.

So what? We have the list of mail addresses to send the mail to on the
one hand and a list of PGP public keys on the other hand.  Matching up
should be  automated in some way;  see further, section on ``automated
matching''.

\subsection{Full filter use of PGP}

Every   command of   PGP   dealing  with encrypting/signing/decrypting
supports an {\tt  -f} option  stating  that PGP should read  the input
text from standard input and write it into standard output.

This  feature of PGP should   be used everywhere as  it means no file
remains on disk if problems occur.

In  fact every PGP  command  I have  tested  can  handle the {\tt  -f}
option.  Only on  some occasions, it can limit  the ability of PGP  to
prompt certain facilities. For example, {\tt  pgp~-ka} will prompt the
user  to certify a newly  added key, while  {\tt pgp~-kaf} will not.
Certifying the key will be done by using the {\tt pgp~-ks} command.

There is also a different behaviour of PGP when it  is used to decrypt
a text that does  not containt any PGP  material.  While the  standard
form returns  an error,  the filter form  will return  the input  text
without any error.  If an error  code has been  returned it could have
been  used to implement recursive decrypt,  re-run of PGP  on the text
just decrypted in the event of several levels of encryption.

Anyway,    recursive   decrypting can  be  handled   by manually
re-running PGP on the buffer from a previous decrypt.

The  last difference I  found  concerns adding  a   key to  the public
keyring.   Applied to  a  file   containing  a   key  bloc PGP    will
automatically add the key to the keyring,  while the filter run of PGP
will only give a description of the key bloc, without adding it to the
keyring.

\subsection{No modification of incoming mail}

With  every PGP interfaces  I  have  checked,  when incoming  mail  is
decrypted, the  decryped text is  saved in the user mailbox, replacing
the received mail.

I  claim this is  a  misbehaviour. There is no  reason  why the user's
incoming mail should  be modified in any other  way than  by receiving
mail  messages from the outside  or deleting read   mail messages.  No
other action involving  any modification of  the  mail body should  be
authorized. But mails  can be copied to another  file  to be modified,
this file is no more the incoming mailbox.

Security is involved too.  There ought to have been a very good reason
for  encrypting a mail message before   sending it, therefore purpose,
the mailbox should not save a decrypted version of the mail message.

Finally  for implementation  purpose,  the user  may want  to  run PGP
recursively  on an incoming  mail. For example  to add a public key to
his public keyring, this key  bloc being embeded  into a crypted mail.
If the original mail body  is destroyed with every  run of PGP,  there
will be no easy way to return to the  original received mail.  And, if
only part of the  text was encrypted,  should we indicate that the now
decrypted part  was formally encrypted?  How  can  we keep a signature
attached to a message.  As  soon as the  signature is decrypted, it is
not signing any thing, it should be kept in  its cryptic PGP format to
be checked as a signature.

Each output is sent to  a separate buffer; the user  can then save the
buffer if he wishes to.

\subsection{Controlling abort {\tt C-g}}

There  are some   critical sections  where  handling of   {\tt C-g} is
important.   The best  solution    was   then to  inhibit     the quit
command.

The critical segments are the following:

\begin{itemize}
 \item Reading the pass phrase:   {\tt C-g} is totally disabled and
the input of  {\tt C-g} is  handled by the  program Return {\tt  nil}
value instead of a phrase.

 \item While modifying the view-only buffer.

 \item  While PGP  process is  running.  Using {\tt  C-g}  allows neat
termination of PGP  process by  removing  temporary files created   by
PGP. {\tt  C-g}  is disabled  just  before PGP process is  started and
enabled when  the process ends. The function  in charge  of waiting for
PGP termination will  check the  keyboard entries  for  {\tt C-g}  and
abort PGP process if {\tt C-g} is typed.
\end{itemize}

\subsection{ View-only messages}

When receiving a crypted mail, one can never predict the nature of its
contents. It  can be signed mail,  standard  encrypted mail, mail that
was encrypted with the option ``for your eyes  only'' (option {\tt -m}
in PGP).

Phi-pgp handles  view-only messages in two  different sections  of the
interface.

First,  when the filter  function  that receives PGP  output detects a
view-only  message, it  accepts  to view it  and  sends the appropiate
continuation commands until it gets to the end of the message.

Second, the text of the message is output  to a separate Emacs buffer,
which is set to a view-only mode.  The view only mode is basically set
by disabling some of the key  maping. No command  to save or write the
buffer is allowed,  neither are the commands to  save some of the text
in the  kill-ring or in a  register. The {\tt  Edit} menu  is disabled
too.

This view-only buffer is declared {\it read-only}, which is a good way
to help the user remember it is a special buffer.

The security of this view-only mode is not total but it is safe enough
for most users.   Anyone who really wants  to save  the contents of  a
decrypted  view-only message will easily find  out a way  to do it, if
only by  modifiing the  PGP source files.  But  there are simpler ways
that work   fine without hacking  PGP.   The level  of security of the
view-only buffer will  help the user to  remember his message requires
special car. It is up to the user to act securely then.

My first idea, after decrypting a view-only message, was to select the
resulting buffer and kill it as soon as the user leaves it. This meant
rebinding any  command that tells Emacs  to change buffer to something
like: change buffer and  kill the buffer  I just left. Everything  was
fine  until  I tried  to   write an equivalent   command for  the {\tt
mouse-set-point} command (activated with mouse first button).

My idea was to check  if the newly  selected buffer, after changing to
one designated by the mouse, was the same as previously;  and if
not, kill  the previous buffer,  then bind  all to {\tt  [mouse-1]} for
the view-only buffer.

The result was not appropriate. When  I left the view-only buffer with
a mouse click, the buffer remained.  When I went back to the view-only
buffer with a mouse click, I deleted  the buffer I  had just left. Any
idea what may have caused such an odd behiavour?

This is a {\it come from} problem. As far as  I can remember, the {\it
come  from} notion   was   defined in  the   early 80's  in  {\it  ACM
communication}. The purpose was  to add a  new feature to  the Fortran
language,  allowing  the   user    to   write statements   like   {\tt
20~comefrom~10} instead of  the  standrad {\tt 10~goto~20}.  It became
funnier with the programmed come from {\tt on~i~comefrom~10,~20,~30}.

The new {\tt mouse-set-point} function was bound and activated only in
the view-only  buffer. Because it  was  coming from  outside, the  old
buffer was   the  outside   one    and the  new  one   the   view-only
buffer. Deleting the old buffer meant deleting the buffer I was coming
from, which is exactely what I did. In fact I should have changed {\tt
mouse-set-point}  for every buffer  except the  view-only buffer. This
was too much work.

A future version(?)  could try to implement  a kind of {\it more mode}
to view the view-only message and then delete the buffer. As this {\it
more mode} can handle any event, it  can disable any exit from viewing
without deleting the buffer.

\section{Other inside considerations}

A few more details on the guts of Phi-pgp.

When  Phi-pgp starts  an asynchronous PGP  process   within Emacs, the
output of the PGP  process is sent to a  filter function, as discussed
previously. Phi-pgp   will then wait  for  the termination  of the PGP
process and then display PGP output.

\subsection{Waiting for process termination}

This is an active wait. Every half second, Phi-pgp checks the status of
PGP process and detects any change from running to exited. 

During the   half second  pause, if  a  character is   entered  at the
keyboard, the waiting loop will check {\tt C-g} to know if an abort of
the command has  been  requested.  Any  other event,  including  mouse
actions, is discarded.

\subsection{Displaying output}

This function is   Phi-pgp's  {\tt ugly little duck}.

It is far too  long! It could have  been split into three functions as
it handles three totally  different behaviours when displaying results
of encrypting/signing, decrypting or  adding a new  key to the  public
keyring.

In every case, that function removes certain  prompt messages from PGP
output (prompt asking   for pass phrase  for example),  to keep useful
information only. It could also add a few comments on Phi-pgp itself.

It uses a consistent format of public keys display:
\begin{verbatim}
Key for user ID: Jean Bambois <jb@pointue.tour.la>
22-bit key, for Key ID 911911, created 1993/11/07
\end{verbatim} 

Finally it uses the same  technique as Emacs help  to display the result
on the screen.

There is only one  case when when  the function  really bcomes  a {\it
very} ugly little duck: it is when Phi-pgp is used to add a new key to
the public  keyring,   i.e.  the display  function   is in charge  of
updating the list of public keys  Phi-pgp tries to memorize! That mean
that using {\tt C-g} at  that very moment would leave  the list in an
un-predictable state.

One more remark   about adding a new   key to the  public keyring. The
order used to display  the added keys may  not  reflect the  order PGP
added them to the public keyring.  Nevertheless the order of Phi-pgp's
internal list is compatible with public  keyring order, and the added
new  keys and/or  signatures are mixed  in  a single display.  It  was
easier that  way! Anyway, a  bottom message states   how many keys and
signatures were added.

\section{Automated matching}

The idea is to automatically  propose a convenient default public  key
for a person whose email address is known.

When Phi-pgp builds the list of keys to encrypt a  mail with, it knows
the list of  recipients of the mail and  the list of available  public
keys.

Given one email address recipient, how to find a matching public key.

A simple case is when the public key contains an email address.  It is
then possible to propose  the public key  which embedded mail  address
matches with good predictability.

When the mail recipient is a local person, the matching should be done
only  on the user-id   component of the   mail address. When  the mail
address includes a machine name the public key's embedded mail address
does      not    include,   for   example,       mailing    to    {\tt
jb@jeux.pointue.tour.la}    while  the  public    key   contains  {\tt
jb@pointue.tour.la}.

The problem  becomes much more difficult  when the public key does not
include email address.  How  email addresses  {\tt jb@pointue.tour.la}
or  \\{\tt jbambois@pointue.tour.la}   can be  matched  with  {\tt  Jean
Bambois} or {\tt Joe I. Barnes} public key.

And  when the public key is  only a nickname with  no link to the real
user name, no matching can be done.

A criterium of  acceptability should also be  set to avoid meaningless
matching. No matching is better when it cannot be predicted accurately
enough.

This remains an open problem.

If a  large  enough number of  public  keys (more  than 1,000) and the
corresponding email  adresses (though not necessarily  embedded inside
the public key)  can be collected, then something  may be tried  using
neural networks.

The  entry point for such  a facility already exists  in Phi-pgp.  The
function is called {\tt  pgp-set-initial}; it always returns an  empty
string as the most conveniently found value.

\section{Known limitations}

\begin{itemize}
 \item  PGP version 2.3a has not been intensively tested. 

As Phi-pgp was  developed with PGP version 2.2,  it has been tested
in a lot of ways.

 \item  As the list of   public keys is  never  extracted twice from  the
public keyring, the user should never modify the public keyring during a
Phi-pgp session but wait until the next run of Emacs.

\begin{sloppypar}
In Phi-pgp's next  version, {\tt pgp-list-pubring-set} should keep the
date and time the  public keyring was   read (the instant just  before
reading  starts). Every call to {\tt  pgp-list-pubring} will check the
{\tt pgp-list-pubring-set} value  and compare  it to the  modification
date  and time  of the {\tt  pubring.pgp}  public keyring file. If the
file is more recent it will be read  again. This will permit to remove
the upgrade  of the Phi-pgp's internal list  of  public keys from {\tt
pgp-show-status}.  This would definitely be an improvment.
\end{sloppypar}

 \item   Multiple  secret keys  facilities  have  not been intensively
tested.

But  why should you need several  secret keys? Do  you  ever send mail
your mother would be ashamed of?

 \item  Only the {\tt pubring.pgp} default   public   keyring and   the
{\tt secring.pgp} default secret keyring are considered.

I did not  have the time or  the desire nor  I could find any  use for
several keyrings.

 \item the display of output from PGP, referrin to the addition of new
keys to the public keyring does not preserve the actual order in which
the keys were added and mixes added keys and signatures.

 \item Sending  the contents of a buffer  to a PGP  process  for en or
decryption can take long time,  about one second  per kilo-byte. As it
is   implemented with a  single Emacs  function, I  do  not know where
action can be taken to speed up the transfer.

Finally it is not possible to insert  a waiting message while Emacs is
already busy on the sending command.
\end{itemize}

\section{New releases}

I do not plan  to make too  frequent releases of Phi-pgp beyond
correcting the bugs.

Phi-pgp  was first writen for  PGP version 2.2,   then modified to fit
version 2.3a. By the time that  documentation was ready, version 2.6ui
of PGP was  available, so Phi-pgp is  adapted to that  last release of
PGP.

I tried  to use only very  standard Emacs features and functions, none
documented as newly added or about to be removed. So  I hope that from
an Emacs point of view, Phi-pgp will remain valid for some time.

On the PGP  side, as long  as the user  interface does not change,  or
undergoes only slight variations, adapting Phi-pgp will be simple.  If
changes  in user interface are too  important, it could mean the death
of Phi-pgp as it is totally based on PGP user interface. It would make
me very sad since I beleive Phi-pgp is  not too bad  as it is. Anyway,
what will never die is the fun I had writing all this.

Now, if you like it, let me know.  Thanks for any bug, etc. etc. etc.
\end{document}
