<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<!--NewPage-->
<html>
<head>
<!-- Generated by javadoc on Tue Jan 13 07:38:24 PST 1998 -->
<title>
  Class cryptix.provider.rsa.RSAAlgorithm
</title>
</head>
<body>
<a name="_top_"></a>
<pre>
<a href="packages.html">All Packages</a>  <a href="tree.html">Class Hierarchy</a>  <a href="Package-cryptix.provider.rsa.html">This Package</a>  <a href="cryptix.provider.rsa.RIPEMD160_RSA_PKCS1Signature.html#_top_">Previous</a>  <a href="cryptix.provider.rsa.RawRSACipher.html#_top_">Next</a>  <a href="AllNames.html">Index</a></pre>
<hr>
<h1>
  Class cryptix.provider.rsa.RSAAlgorithm
</h1>
<pre>
java.lang.Object
   |
   +----cryptix.provider.rsa.RSAAlgorithm
</pre>
<hr>
<dl>
  <dt> public final class <b>RSAAlgorithm</b>
  <dt> extends Object
</dl>
A class that calculates the RSA algorithm. A single method is
 used for encryption, decryption, signing and verification:
 <ul>
   <li> for encryption and verification, the public exponent, <i>e</i>,
        should be given.
   <li> for decryption and signing, the private exponent, <i>d</i>,
        should be given.
 </ul>
 <p>
 The purpose of having this as a separate class is to avoid duplication
 between the RSA Cipher and Signature implementations.
 <p>
 <b>References:</b>
 <ol>
   <li> Donald E. Knuth,
        <cite>The Art of Computer Programming</cite>,
        ISBN 0-201-03822-6 (v.2) pages 270-274.
        <p>
   <li> <cite>ANS X9.31, Appendix B</cite>.
 </ol>
 <p>
 <b>Copyright</b> &copy; 1997
 <a href="http://www.systemics.com/">Systemics Ltd</a> on behalf of the
 <a href="http://www.systemics.com/docs/cryptix/">Cryptix Development Team</a>.
 <br>All rights reserved.
 <p>
 <b>$Revision: 1.7 $</b>
<p>
<dl>
  <dt> <b>Author:</b>
  <dd> Raif S. Naffah, David Hopwood
</dl>
<hr>
<a name="index"></a>
<h2>
  <img src="images/method-index.gif" width=207 height=38 alt="Method Index">
</h2>
<dl>
  <dt> <img src="images/green-ball-small.gif" width=6 height=6 alt=" o ">
	<a href="#rsa(java.math.BigInteger, java.math.BigInteger, java.math.BigInteger)"><b>rsa</b></a>(BigInteger, BigInteger, BigInteger)
  <dd>  Computes the RSA algorithm, without using the Chinese Remainder
 Theorem.
  <dt> <img src="images/green-ball-small.gif" width=6 height=6 alt=" o ">
	<a href="#rsa(java.math.BigInteger, java.math.BigInteger, java.math.BigInteger, java.math.BigInteger, java.math.BigInteger, java.math.BigInteger)"><b>rsa</b></a>(BigInteger, BigInteger, BigInteger, BigInteger, BigInteger, BigInteger)
  <dd>  Computes the RSA algorithm.
</dl>
<a name="methods"></a>
<h2>
  <img src="images/methods.gif" width=151 height=38 alt="Methods">
</h2>
<a name="rsa(java.math.BigInteger, java.math.BigInteger, java.math.BigInteger, java.math.BigInteger, java.math.BigInteger, java.math.BigInteger)"><img src="images/green-ball.gif" width=12 height=12 alt=" o "></a>
<a name="rsa"><b>rsa</b></a>
<pre>
 public static BigInteger rsa(BigInteger X,
                              BigInteger n,
                              BigInteger exp,
                              BigInteger p,
                              BigInteger q,
                              BigInteger u)
</pre>
<dl>
  <dd> Computes the RSA algorithm. If <i>p</i> is null, straightforward
 modular exponentiation is used.
 <p>
 Otherwise, this method uses the Chinese Remainder Theorem (CRT) to
 compute the result given the known factorisation of the public
 modulus <i>n</i> into two relatively prime factors <i>p</i> and <i>q</i>.
 The arithmetic behind this method is detailed in [1] and [2].
 <p>
 The comments that follow, which are edited from the PGP
 <samp>mpilib.c</samp> file <em>with p and q reversed</em>, make
 the practical algorithmic implementation clearer:
 <p>
 <blockquote>
     Y = X**d (mod n) = X**d (mod pq)
 </blockquote>
 <p>
 We form this by evaluating:
 <blockquote>
     p2 = plain**d (mod p) and <br>
     q2 = plain**d (mod q)
 </blockquote>
 and then combining the two by the CRT.
 <p>
 Two optimisations of this are possible. First, we reduce X modulo p
 and q before starting, since:
 <blockquote>
    x**a (mod b) = (x (mod b))**a (mod b)
 </blockquote>
 <p>
 Second, since we know the factorisation of p and q (trivially derived
 from the factorisation of n = pq), and input is relatively prime to
 both p and q, we can use Euler's theorem:
 <blockquote>
     X**phi(m) = 1 (mod m),
 </blockquote>
 to throw away multiples of phi(p) or phi(q) in d. Letting
 <blockquote>
     ep = d (mod phi(p)) and <br>
     eq = d (mod phi(q))
 </blockquote>
 then combining these two speedups, we only need to evaluate:
 <blockquote>
     p2 = (X mod p)**ep (mod p) and <br>
     q2 = (X mod q)**eq (mod q).
 </blockquote>
 <p>
 Now we need to apply the CRT. Starting with:
 <blockquote>
     Y = p2 (mod p) and <br>
     Y = q2 (mod q)
 </blockquote>
 we can say that:
 <blockquote>
     Y = q2 + kq
 </blockquote>
 and if we assume that:
 <blockquote>
     0 <= q2 < q, then <br>
     0 <= Y < pq for some 0 <= k < p
 </blockquote>
 <p>
 Since we want:
 <blockquote>
     Y = p2 (mod p),
 </blockquote>
 then
 <blockquote>
     kq = (p2 - q2) (mod q)
 <blockquote>
 <p>
 Since p and q are relatively prime, q has a multiplicative inverse
 u mod p. In other words, uq = 1 (mod p).
 <p>
 Multiplying by u on both sides gives:
 <blockquote>
     k = u * (p2 - q2) (mod p)
 </blockquote>
 <p>
 Once we have k, evaluating kq + q2 is trivial, and that gives
 us the result.
<p>
  <dd><dl>
    <dt> <b>Parameters:</b>
    <dd> X - the BigInteger to be used as input.
    <dd> n - the public modulus.
    <dd> exp - the exponent (e for encryption and verification,
              d for decryption and signing).
    <dd> p - the first factor of the public modulus.
    <dd> q - the second factor of the public modulus.
    <dd> u - the multiplicative inverse of q modulo p.
    <dt> <b>Returns:</b>
    <dd> the result of the computation.
  </dl></dd>
</dl>
<a name="rsa(java.math.BigInteger, java.math.BigInteger, java.math.BigInteger)"><img src="images/green-ball.gif" width=12 height=12 alt=" o "></a>
<a name="rsa"><b>rsa</b></a>
<pre>
 public static BigInteger rsa(BigInteger X,
                              BigInteger n,
                              BigInteger exp)
</pre>
<dl>
  <dd> Computes the RSA algorithm, without using the Chinese Remainder
 Theorem.
<p>
  <dd><dl>
    <dt> <b>Parameters:</b>
    <dd> X - the BigInteger to be used as input.
    <dd> n - the public modulus.
    <dd> exp - the exponent (e for encryption and verification,
              d for decryption and signing).
    <dt> <b>Returns:</b>
    <dd> the result of the computation.
  </dl></dd>
</dl>
<hr>
<pre>
<a href="packages.html">All Packages</a>  <a href="tree.html">Class Hierarchy</a>  <a href="Package-cryptix.provider.rsa.html">This Package</a>  <a href="cryptix.provider.rsa.RIPEMD160_RSA_PKCS1Signature.html#_top_">Previous</a>  <a href="cryptix.provider.rsa.RawRSACipher.html#_top_">Next</a>  <a href="AllNames.html">Index</a></pre>
</body>
</html>
