





                          Secure Remote Login

                            Lawrence Brown
                           lpb@cs.adfa.oz.au

                    Department of Computer Science
                 Centre for Computer Security Research
      University College, UNSW, Australian Defence Force Academy
                     Canberra ACT 2600. Australia.



    Abstract

    In this paper I discuss some alternative approaches to  provid-
    ing security in remote terminal sessions. Since remote terminal
    sessions mean that information is carried over a  network  that
    may  not  be trusted, there is a need for mechanisms to protect
    the security of information exchanged during the  session.  The
    protocols  implemented  will  need  to  address  the  issues of
    authentication of the parties, negotiation of a suitable cipher
    to use, and the exchange of keys for that cipher. In this paper
    I examine each of these issues. I  then  describe  a  prototype
    implementation incorporating some of these features in the sec-
    log program, and I finish with a description of  work  in  pro-
    gress  on  extending  the widely used telnet protocol to incor-
    porate some of these security features.

    1.  Introduction

    With the growth of wide area networks linking together existing
    local  area  networks,  there  are increasing security problems
    with the existing network utilities traditionally supplied  for
    such  LANs.  These  utilities  have  assumed that the LAN was a
    secure communications service (even though  it  was  recognised
    fairly  early  that  it was not necessarily so), and that hence
    additional security services for these utilities were not  sup-
    plied.  However,  a  wide-area  internet  certainly  cannot  be
    assumed to be secure[1].  Thus there is  a  desire  to  provide
    utilities with additional security. Some of the issues involved
    in providing such security are canvassed in [WoK85 pp  189-198]
    [HeR89] and [DaP84].

    In this paper, I  start  by  identifying  some  of  the  issues
    involved  with  security  when  using a remote terminal session
    over a network.  I then identify the areas of  protocol  exten-
    sion  needed  to  prevent violating the security of information
    exchanged during such a  session,  and  where  such  extensions
    might  be  incorporated  intot  he  existing  protocols.  These
    ____________________

       [1] For a fascinating account of the 1986 Internet  breakin,
    see  [Sto88],  and  for  details  on other breakins see [Rei87]
    [Spa88].








     AUUGC90                    STELNET              Lawrence Brown


    protocols extensions will need to address the issues of authen-
    tication  of  the  parties, negotiation of a suitable cipher to
    use, and the exchange of keys for that cipher. Then I  describe
    a  prototype  which  incorporated some of these extensions into
    the seclog program. This involved writing a  pair  of  programs
    external  to  the  existing  rlogin program, which provided the
    necessary security by utilising the  existing  rlogin  protocol
    unchanged.   This resulted in a number of problems in practical
    implementation, which indicated that  these  extensions  really
    need to be incorporated into the underlying protocols. I finish
    with a description of work in progress  on  extend  the  option
    mechanism  of  the  widely  used telnet protocol to incorporate
    some of these security extensions.

    2.  Login Over a Network - Some Issues

    2.1.  Identity of the User

    When a user logs in to a host computer, they provide a username
    and  password  to  identify  themselves  to  the computer. On a
    hardwired line this is assumed to be secure, as it is difficult
    for someone to tap such a line and intercept the username pass-
    word pair.  However when logging in over a network, anyone with
    access  to  a  workstation and packet monitoring software could
    intercept the pair, and then subsequently claim to be the  ori-
    ginal  user (see Fig 1).  In either case it is assumed that the
    password is well chosen, so that it cannot be  guessed  [MoT79]
    [Spa88 Appendix A].

    To provide for authentication of the user, the information sent
    over the network should be insufficient to allow an intruder to
    impersonate the user  without  additional  knowledge.  A  third
    party,  who may or may not be trusted could be involved in this
    negotiation. The parties would exchange information until  they
    were  convinced  of  each  others  identity,  without releasing
    unnecessary information to an eavesdropper.  There are a number
    of ways of doing this.

                                   _












                  Fig 1 - Identity of User Uncertain


    +  Challenge - Response
         This involves the host computer sending a random number, a
         challenge  vector,  to  the  user.  The user encrypts this

                                 - 2 -




     AUUGC90                    STELNET              Lawrence Brown


         using a private key known only to both  parties,  with  an
         agreed  cipher, and sends the encrypted response vector to
         the host. The host encrypts the challenge vector using the
         user's  private  key,  and  compares  it with the response
         returned. The user is accepted only if they are identical.

         Since any intruder monitoring the network will see a  dif-
         ferent  challenge and response each time, they will not be
         able to produce  a  correct  response,  unless  they  have
         obtained  the  user's  key by some other means (which is a
         separate problem). This technique assumes  that  the  user
         and  remote host have already arranged a private key prior
         to wanting to establish a remote login session. Since,  in
         this  application,  a  user  must have negotiated with the
         remote site to obtain a usercode  and  conventional  pass-
         word,  obtaining  a  network  private  key  simply becomes
         another piece of information exchanged during  this  nego-
         tiation.  An issue that needs to be addressed in a practi-
         cal implementation of this scheme is which cipher  to  use
         to  build  the  response.  Any of the modern block ciphers
         detailed later would suffice, so the choice may either  be
         fixed, or made part of the negotiation in the protocol.

    +  Kerberos
         This may be used if both of the parties who wish to engage
         in  a remote terminal session participate in a common Ker-
         beros authentication domain (by  each  sharing  keys  with
         trusted  key  servers,  which in turn are part of the same
         hierarchy of servers, and thus can exchange  information).
         In  this  case,  the Kerberos authentication system may be
         used to create a special signed message, called a  ticket,
         which  validates  the identity of each of the parties, and
         in addition may include a suitable  session  key  for  use
         later.  In essence this is deferring the security issue to
         another domain, and  indeed  the  Kerberos  system  incor-
         porates  some  of  the  ideas  discussed here. This method
         relies on the use of a trusted third party to  assist  the
         authentication  process.   For further details on the Ker-
         beros scheme see [SNS88] and [Koh90].  For a  critique  of
         the system see [BeM90].

         A similar mechanism is also provided in the Amoeba distri-
         buted  operating  system.  For details of this see [MRT90]
         [TMR86].

    +  Digital Signature
         This  method  uses  a  public-key  authentication   scheme
         [SeP89] to identify the user. To use it, the user signs an
         identity message with the private  half  of  the  key  and
         sends  this  to  the remote host.  There it is verified by
         using the public half of the key to confirm that the iden-
         tity  message  is unchanged. Since only the user knows the
         private half of the key, only they could have  signed  the
         identity  message.   However,  there is still a problem in
         obtaining the correct public half of the  key.  If  it  is
         obtained  from  some  remote  database,  an intruder could
         intercept the request, and return a fraudulant  public-key

                                 - 3 -




     AUUGC90                    STELNET              Lawrence Brown


         claiming  to  be the desired recipient. The intruder could
         then claim to be the recipient.  This problem is solved by
         providing the public key signed by a public key centre (or
         possibly a hierarchy of signed keys), whose public key  is
         well  known.  This  can be supplied by the user as part of
         the identity message which removes the need for a  network
         key server to be accessed on every remote terminal session
         request.  Whilst this method has a number of nice  proper-
         ties, including no need for prior key exchange, it is com-
         putationally slow. However if a public key scheme is to be
         used  for encryption, then this would be the obvious coun-
         terpart.  Candidates for practical implementation  include
         RSA [RSA78] or El Gamal [ElG85] [McC86].

    +  Zero Knowledge Proof of Identity
         This technique provides a way of authenticating a user, by
         using a series of challenges and responses to convince the
         remote site that the user is who they say they  are.  How-
         ever  it  does not require the prior arrangement of a key.
         In this method, the user  sends  a  certificate  (Ident,j)
         originally  obtained  from  a  public  key  centre, to the
         remote host.  The host then interacts with user  to  prove
         ownership of the certificate [FFS88] [SeP89].  This method
         is  much  faster  than  a  digital  signature,  though  it
         involves  a  dialog between the user and the host.  In the
         longer term, it will probably be the method of choice.

    2.2.  Privacy of Session

    Having authenticated the user, the next issue to address is the
    provision of privacy for the user (see Fig 2).

    This implies a need to encrypt the data transferred during  the
    session.   However, a choice has to be made as to which form of
    cipher is to be used to provide privacy. A  Public-Key   scheme
    has the nice property that the keys need not be exchanged prior
    to establishing a session, but current implementations are  too
    slow.   The  alternative is to use a private-key scheme.  These
    are considerably faster, but require  the  keys  to  have  been
    exchanged  in some secure fashion, either prior to the session,
    or via a public key exchange scheme.  It is anticipated that in
    the  near future private-key schemes will be used.  As computer
    power continues to increase  though,  public-key  schemes  will
    become more desirable and will need also to be included.














                                 - 4 -




     AUUGC90                    STELNET              Lawrence Brown















                      Fig 2 - Privacy of Session


    Having decided to use a private key scheme, there  is  still  a
    range of ciphers to chose from, trading off speed for security.
    The choices include:

    +  Simple Substitution Cipher
         This is very fast, very simple to implement, but  is  very
         insecure.  Guessing as many characters as there are in the
         key is sufficient to crack the  scheme.  However,  if  all
         that  is  required  is  to  defeat  casual scanning (or an
         automatic word scanner), then it may well suffice.

    +  Stream Cipher
         Stream Ciphers are usually based on a pseudo-random number
         generator.  They are reasonably fast, and given a suitable
         choice of generator (such as a non-linear  feedback  shift
         register, or multiplexed linear feedback shift registers),
         have a moderate to high level of  security.  They  can  be
         cracked by guessing a sufficiently large number of charac-
         ters, but the number needed could be very  large.  Another
         possible  precaution  is to change keys before this number
         of characters is sent (using for  example  the  challenge-
         response  key  again,  and encrypting the previous session
         key again every period).

    +  Block Cipher
         The cipher would be used in a  stream  mode.  Any  of  the
         modern  block  ciphers  may  be  used, eg DES [ASA85] LOKI
         [BPS90] FEAL8 [ShM88] [Miy90].  These schemes all  have  a
         very  high level of security, but are probably the slowest
         of the private-key alternatives.  Suitable  modes  include
         either  Cipher  Feedback  (CFB),  or Output Feedback (OFB)
         modes (see Fig 3).  If the CFB mode is chosen, it uses the
         message  contents  in  forming the new key (which can slow
         down parallel key stream generation), but which  leads  to
         different  key streams for different messages.  If the OFB
         mode is used, the key stream generated is  independent  of
         the  message  content  (and  thus  the  key  stream can be
         precomputed). However OFB should not be used to encrypt  a
         number  of  different messages with the same keystream, as
         this creates a security hole.  However, if different  keys
         are  used,  it  is equivalent in security to CFB, with the

                                 - 5 -




     AUUGC90                    STELNET              Lawrence Brown


         advantage of being able to  precompute  the  keystream  if
         desired.

                                     _













                   Fig 3 - Stream Modes for Block Ciphers


    2.3.  Exchange of Keys

    Before a cipher can be used to encrypt data, it is necessary to
    mutually  agree  on  a  suitable  key. Such a key may be simply
    agreed on outside of the protocol altogether (it may simply  be
    another password), may be exchanged during, or derived from the
    authentication stage, or may  be  negotiated  by  a  completely
    separate phase. In more detail these alternatives are:

    +  Keys Exchanged Outside the Protocol
         In this case the user is given a key by  means  completely
         independent  to  the  remote  login negotiation. Typically
         this would be an additional password supplied to the users
         by  some secure physical means. This key could be just for
         the encryption phase, but more  typically  would  also  be
         used  in  the authentication phase, and then a session key
         would be derived to  use  in  the  encryption.  This  then
         becomes the next alternative.

    +  Key Derived from Authentication Process
         In this approach, the key used to encrypt data is  derived
         from information exchanged during the authentication nego-
         tiation. For example, if a  challenge-response  scheme  is
         being used, then a suitable key may be derived by encrypt-
         ing the response vector to form the session key.  If  Ker-
         beros  or  a like scheme is used, then the session key may
         well be incorporated into the ticket exchanged, along with
         verification  of the users identity. Similarly, if a digi-
         tal signature is being used along with public-key  encryp-
         tion  of the data, then the signature may include a certi-
         ficate, signed by a public notary,  identifying  the  user
         and specifying the public key to be used.

    +  Public-Key Exchange
         The final alternative is to use a separate  phase  of  the
         negotiation  to exchange a key using a public-key exchange
         protocol. In this case the exact protocol to be used would

                                 - 6 -




     AUUGC90                    STELNET              Lawrence Brown


         need  to  be  negotiated, and then the exchange could take
         place. Possible schemes here include  using  RSA  [RSA78],
         appropriate  if  RSA is used to provide either authentica-
         tion  or  secrecy  or  both;  or  Diffie-Hellman  [DiH76],
         appropriate  if El Gamal is used in either the authentica-
         tion or secrecy stages.

    The choice of which of these  alternatives,  and  how  many  if
    there  is scope for negotiation, will depend on the actual pro-
    tocol being modified to incorporate these  additional  security
    features.

    3.  Possible Implementation Alternatives

    3.1.  Where to Add Security?

    Since there are a number of existing protocols for remote  ter-
    minal  sessions, eg rlogin or telnet, it would be preferable to
    adapt these to provide the security features detailed  earlier,
    rather  than  write  a new protocol.  The issue is how to adapt
    these existing tools. There are two major options, as shown  in
    Fig 4.

    (A) Integrated into the Utilities
         Here, the programs are modified to  include  the  required
         security features. This has the advantage of being able to
         properly merge the extensions with the existing protocols.
         However,  access is required to the source to achieve this
         on all systems where it is required. In the  longer  term,
         this is the option of choice, and this paper will conclude
         with the state of negotiations to add security  extensions
         to the Telnet protocol.

    (B) Using Additional Processes
         Here, some filters are added, in traditional Unix fashion,
         around  the existing utilities. This is much easier to do,
         since there are no changes  to  the  existing  tools,  but
         there  are  several  disadvantages. It adds more processes
         and thus context switches, it blocks user interaction with
         the  client program using escapes, and it requires a tran-
         sparent (8-bit) path. Nonetheless,  this  was  the  option
         chosen for the prototype implementation, since it could be
         used to verify the functionality of the  security  aspects
         of  the  protocol,  even  though there were other problems
         with the scheme.













                                 - 7 -
