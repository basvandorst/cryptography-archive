
4.2    A  three-layer  construction  for  strong  permutations

In Lemma 2, we constructed a one way permutation f O g such that any
k input bits cannot be distinguished from a random string. If there
existed another transformation (permutation) h, such that given any t
bit string of its input, x, where t < n - k, it would be difficult to guess
any k bits of its output, h(x), then we could apply this function before g
and get f O g O h(x) as a one way permutation such that, when its output
is given the overall probability of distinguishing any t < n - k bit string
of x from random strings would be less than __1_2k+, as it will be proved in
the next subsection. Since h would be able to hide any k bits of its
output, we call it a hiding permutation.
First, we introduce a definition for hiding permutations.

Definition  8    Assume  that  h : D ! D  is  a  permutation.   Also
assume  that  i1; : :;:it and  j1; : :;:jk  are  functions  from  N  to  N ,
where  1   il(n); jl(n)   n  for  each  1   l   n.   We  call  h  a
hiding__permutation_____ if  for  each  probabilistic  polynomial  time
algorithm  M ,  for  each  t < n - k  and  for  each  polynomial  Q
and  for  all  sufficiently  large  n,


   | P rob{M (xit; : :;:xi1 k yjn; : :;:yjk+ ) = yjk; : :;:yj1} - _1_2k|< __1__*
 *_Q(n)


where  x 2r  n  and  xi denotes  i-th  bit  of  x,  and  yj  denotes
j-th  bit  of  h(x)  and  k = O(log n).

The following theorem shows how to make a strong permutation from a
hiding permutation.

Theorem  2   If  h  is  a  hiding  permutation  and  g = px + q,  where
p; q 2r GF  (2n ),  and  f  is  any  one  way  permutation,  then
m = f O g O h  is  a  strong  one  way  permutation.



Proof  Sketch:  To prove that m is a strong one way permutation we
should show that any bit of x is hard to guess, and any n - k+  bits of x
are simultaneously hard, given only m(x).
Assume that, by contradiction, that a probabilistic polynomial time
algorithm M could guess xi, given m(x). Let x0 = h(x). Since any xi is a
function of some bits of x0, and according to Lemma 2 any input bit of
f O g is individually a hard bit, then any algorithm which can guess xi
could a guess hard bit of f O g. This is contradictory to the assumption
that f is a one way permutation, since computing any hard bit of f O g is
equivalent to reversing f . Hence, every xi is a hard bit of m.
Moreover, having t < n - k bits of x does not reveal any k bits of h(x),
since h is a hiding permutation. Then, having t < n - k bits of x would


not help in inverting m, given m(x) = f O g O h(x). So, for each
polynomial Q and for large enough n, any probabilistic polynomial time
algorithm M cannot distinguish any string of t < n - k bits of x from a
random string with a probability better than __1__Q(n), when m(x) is given.
2

A method for hiding x is based on the application of a one way
permutation which acts on all bits, and serves as a hiding permutation
due to the following lemma.


Lemma  3   Any  one  way  permutation  h  which  is  complete,  is  a
hiding  permutation.



Proof  :  By contradiction assume that a one way permutation which is
complete is not a hiding permutation. Then, there is a probabilistic
polynomial time algorithm M that can obtain yjk; : :;:yj1, given
xit; : :;:xi1, with the available computing resource. On the other hand,
since n - t > k bits of x are not given, then the obtained k bits of the
output do not depend on at least n - t - k bits of the input. This is
equivalent to say that h is formed of the two functions, namely h1; h2,
i.e. h(x) = h1(xit+k; : :;:xi1) k h2(:). Obviously h1 would not be a
function of x, which contradicts our assumption that h is a complete
permutation.                                                               2

Then, a concrete example for construction of a family of strong one way
permutation, based on using a complete one way permutation as the
hiding permutation, is m(x) = f O g O h(x), where f is any one way
permutation, g = px + q where p; q 2r GF  (2n ), and h is a complete one
way permutation which acts on all its bits.


5   Conclusions


There are many functions that is considered to be one way, so if someone
knows the value of f (x), he can find the value of x for less than a fraction
of __1__Q(n)of x's. This does not necessarily mean that any bit of x cannot
be guessed efficiently. On the other hand, it is shown that O(log n) bits
of RSA and Rabin encryption schemes are hard to guess [1 ]. Also, it was
shown that O(log n) bits of the exponentiation function is also hard to
guess [8 ]. This does not mean that the remaining bits are easy to guess
and it simply means that we do not have yet any proof about remaining
bits. As, recently it is shown that n_2bits of exponentiation function are
simultaneously hard to guess, when the operation is done modulo a Blum
integer [11 ]. In this paper, we showed how to make a family of strong
one way permutation, such that when a member is chosen uniformly at


random, we get a one way permutation such that all its input bits are
hard and any t < n - k bit of input bits is indistinguishable from a
random string, with a high probability. Two schemes for this purpose
was suggested. The second scheme relies on the existence of a hiding
permutation. An open problem is to show that a one way permutation is
complete, or cannot be splitted into two parts. We also took advantage
of the simplest family of polynomials in Galois field and showed that the
family is also a family of complete permutations, where it had already
been shown that it is also a family of strongly universal   2 functions.
The proposed schemes for the construction of a family of strong one way
permutations can be shown to work with families of polynomials of
higher degrees in Galois field as well, where such polynomials form a
family of strongly universal   n functions. As it is shown [10 ], a strong
one way permutation is an effective tool for the construction of efficient
pseudorandom bit generators and universal one way hash functions.
                           ACKNOWLEDGMENT


We  would  like  to  thank  Cathy  Newberry  and  other  members  of
CCSR  for  their  help  and  assistance  during  the  preparation  of
this  work.   The  first  author  would  also  like  to  thank  the
organising  committee  of  ASIACRYPT  '91  for  their  generous
support.


References


  [1]W. Alexi, B. Chor, O. Goldreich, and C. P. Schnorr. RSA and
     Rabin functions: Certain parts are as hard as the whole. SIAM
     Journal  on  Computing, 17(2):194-209, 1988.

  [2]M. Blum and S. Micali. How to generate cryptographically strong
     sequences of pseudo-random bits. SIAM  Journal  on  Computing,
     13(4):850-864, 1984.

  [3]Manuel Blum and Shafi Goldwasser. An efficient probabilistic
     public-key encryption scheme which hides all partial information. In
     Advances  in  Cryptology  -  CRYPTO  '84, volume 196 of Lecture
     Notes  in  Computer  Science, pages 289-299. Springer-Verlag,
     1985.

  [4]O. Goldreich, H. Krawczyk, and M. Luby. On the existence of
     pseudorandom generators. In Proceedings  of  the  29th  IEEE
     Symposium  on  the  Foundations  of  Computer  Science, pages
     12-24, 1988.


  [5]O. Goldreich and L. A. Levin. A hard-core predicate for all one-way
     functions. In the  21st  ACM  Symposium  on  Theory  of  Computing,
     pages 25-32, 1989.

  [6]Shafi Goldwasser and Silvio Micali. Probabilistic encryption.
     Journal  of  Computer  and  System  Sciences, 28:270-299, 1984.

  [7]R. Impagliazzo, L. A. Levin, and M. Luby. Pseudo-random
     generation from one-way functions. In the  21st  ACM  Symposium
     on  Theory  of  Computing, pages 12-24, 1989.

  [8]Douglas L. Long and Avi Wigderson. The Discrete Logarithm Hides
     O(log n) Bits. SIAM  Journal  on  Computing, 17(2):363-372, 1988.

  [9]J. Rompel. One-way functions are necessary and sufficient for secure
     signatures. In the  22nd  ACM  Symposium  on  Theory  of
     Computing, pages 387-394, 1990.

[10] B. Sadeghiyan and J. Pieprzyk. A construction for one way hash
     functions and pseudorandom bit generators. Technical Report CS
     91/2, University College, The University of New South Wales, 1991.
     Also in the Abstracts of EUROCRYPT '91.

[11] A. Scherift and A. Shamir. Discrete logarithm is very discreet. In
     Proceedings  of  the  ACM  Symposium  on  Theory  of  Computing,
     pages 405-415, 1990.

[12] U. V. Vazirani and V. V. Vazirani. Efficient and Secure
     Pseudo-random Number Generation. In Proceedings  of  the  IEEE
     Symposium  on  Foundations  of  Computer  Science, pages
     458-463, 1984.

[13] M. N. Wegman and J. L. Carter. New hash functions and their use
     in authentication and set equality. Journal  of  Computer  and
     System  Sciences, 22:265-279, 1981.

[14] Y. Zheng, T. Matsumoto, and H. Imai. Duality between Two
     Cryptographic Primitives. In the  8-th  International
     Conference  on  Applied  Algebra,  Algebraic  Algorithms  and
     Error  Correcting  Codes, page 15, 1990.

