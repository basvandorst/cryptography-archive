diff -u -r --new-file ../oldelm/Configure ./Configure
--- ../oldelm/Configure	Mon May 30 18:55:55 1994
+++ ./Configure	Wed Aug 30 00:54:13 1995
@@ -38,6 +38,10 @@
 -d) shift; fastread='yes';;
 esac
 
+mail_domain=''
+d_mail_domain=''
+pgp_path=''
+dont_check_passwd=''
 Log=''
 Header=''
 bin=''
@@ -269,7 +273,7 @@
 d_bsd=''
 CONFIG=''
 : set package name
-package=elm2
+package=elm2-pgp
 
 echo " "
 echo "Beginning of configuration questions for $package kit."
@@ -1000,6 +1004,106 @@
 chmod +x filexp
 $eunicefix filexp
 
+: find where pgp is on this system.
+$cat <<EOM
+ 
+This version of Elm is set up to use PGP for encrypting messages. It is not
+assumed that users have PGP keys and if they don't then they will not notice
+any difference to the program. People with PGP keys and a user level of 1 or
+greater ("Intermediate" and "Expert") have the option of invoking Elm to use 
+their keys for encrypting, decrypting and checking signatures. 
+
+EOM
+dflt="$pgp_path"
+case "$dflt" in
+ '') dflt="/usr/local/bin/pgp"
+esac
+cont=true
+while $test "$cont" ; do
+    rp="Where is pgp stored on this system? [$dflt]"
+    $echo $n "$rp $c"
+    . myread
+    pgp_path="$ans"
+    case "$ans" in
+    /*)
+        if $test -f "$ans"; then
+            cont=''
+        else
+            if $test "$fastread" = yes; then
+                 dflt=y
+            else
+                dflt=n
+            fi
+            rp="File $ans doesn't exist. Use that name anyway? [$dflt]"
+            $echo $n "$rp $c"
+            . myread
+            case "$ans" in
+            y*) cont='';;
+            esac
+        fi
+        ;;
+    *)
+        echo "Please give the full pathname."
+        ;;
+    esac
+done
+: determine whether to check the pgp pass phrase
+$cat <<EOM
+
+Elm can be configured to check the PGP pass phrase.  However this
+takes a while to run. If the pass phrase is not checked and the user
+enters a bad pass phrase, de- and encrypting mails is not possible.
+EOM
+dflt="n"
+echo " "
+cont=true
+while $test "$cont" ; do
+    rp="Disable Elm from checking the pass phrase? [$dflt]"
+    $echo $n "$rp $c"
+    . myread
+    case "$ans" in
+    *)
+        if $test $ans = y; then
+            dont_check_passwd="$define"
+            cont=''
+        elif $test $ans = n; then
+            dont_check_passwd="$undef"
+            cont=''
+        fi
+        ;;
+    esac
+done
+$cat <<EOM 
+
+When encrypting messages, Elm needs to now the user's mail address. While
+the user name is easily figured out, the domain name might differ from the 
+domain of the current host.
+
+If the mail domain is misconfigured, Elm cannot encrypt messages to local
+recipients (only sign them). 
+
+Example: If the current host is unplugged.elm.net, but mail addresses are
+user@elm.net, you need to configure the mail domain to elm.net
+
+If you enter the word 'none', the domain of the current host is used.
+
+EOM
+dflt="$mail_domain"
+case "$dflt" in
+ '') dflt='none'
+esac
+rp="Set mail domain manually: [$dflt]"
+$echo $n "$rp $c"
+. myread
+case "$ans" in
+'none') mail_domain=''
+	d_mail_domain="$undef"
+        ;;
+*)	mail_domain="$ans"
+	d_mail_domain="$define"
+	;;
+esac
+
 # determine text processor to use, default to troff if found.
 case "$roff" in
 '')
@@ -1941,7 +2045,7 @@
 set `echo $libc $libnames | tr ' ' '\012' | sort | uniq`
 $echo $n "Extracting names from $* for later perusal...$c"
 nm $nm_opts $* 2>/dev/null >libc.tmp
-$sed -n -e 's/^.* [ATDS]  *[_.]*//p' -e 's/^.* [ATDS] //p' <libc.tmp >libc.list
+$sed -n -e 's/^.* [ATDSU]  *[_.]*//p' -e 's/^.* [ATDSU] //p' <libc.tmp >libc.list
 if $contains '^printf$' libc.list >/dev/null 2>&1; then
     echo done
 elif $sed -n -e 's/^__*//' -e 's/^\([a-zA-Z_0-9$]*\).*xtern.*/\1/p' \
@@ -4706,6 +4810,10 @@
 # config.sh
 # This file was produced by running the Configure script.
 
+mail_domain='$mail_domain'
+d_mail_domain='$d_mail_domain'
+pgp_path='$pgp_path'
+dont_check_passwd='$dont_check_passwd'
 Log='$Log'
 Header='$Header'
 bin='$bin'
diff -u -r --new-file ../oldelm/DISCLAIMER.PGP-Support ./DISCLAIMER.PGP-Support
--- ../oldelm/DISCLAIMER.PGP-Support	Thu Jan  1 01:00:00 1970
+++ ./DISCLAIMER.PGP-Support	Wed Aug 30 21:08:54 1995
@@ -0,0 +1,21 @@
+
+                               NO WARRANTY
+
+      BECAUSE THIS PATCH TO ELM IS PROVIDED FREE OF CHARGE, THERE IS NO 
+    WARRANTY FOR THIS PACKAGE.
+    EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR
+    OTHER PARTIES PROVIDE THE PACKAGE "AS IS" WITHOUT WARRANTY OF ANY
+    KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE
+    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+    PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE
+    PACKAGE IS WITH YOU.  SHOULD THE PACKAGE PROVE DEFECTIVE, YOU ASSUME
+    THE COST OF ALL NECESSARY SERVICING, REPAIR OR CORRECTION.
+     
+      IN NO EVENT WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY 
+    MODIFY AND/OR REDISTRIBUTE THE PACKAGE, BE LIABLE TO YOU FOR DAMAGES,
+    INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES 
+    ARISING OUT OF THE USE OR INABILITY TO USE THE PACKAGE (INCLUDING BUT 
+    NOT LIMITED TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES 
+    SUSTAINED BY YOU OR THIRD PARTIES OR A FAILURE OF THE PACKAGE TO OPERATE 
+    WITH ANY OTHER SOFTWARE), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN 
+    ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.
diff -u -r --new-file ../oldelm/HISTORY.PGP-Support ./HISTORY.PGP-Support
--- ../oldelm/HISTORY.PGP-Support	Thu Jan  1 01:00:00 1970
+++ ./HISTORY.PGP-Support	Wed Aug 30 20:17:35 1995
@@ -0,0 +1,176 @@
+CHANGES up to 30.8.95 -- RELEASE OF PGP6
+
+Changes from ELM PGP5a to PGP6 (by R. Muchsel)
+------------------------------
+- Fixed numerous typos, glitches, errors in the help files and
+  fixed some screen update problems and other loose ends.
+- Added a fix to Configure to work properly with GNU "nr"
+- Fixed the Makefile so that elm-help.4 will be installed on make install.
+- Changed hot keys: 
+    si(g)n instead of C)learsign (the message didn't fit into 1 line)
+    ke(y) management instead of ^K
+- Signing and encrypting a key is now allowed.
+- Added support for PGP keys to mail address links. You can use this
+  function to alias keys, add keys for multiple recipients (when
+  using a mailing list), etc.
+- Key management sub-menu:
+  * Display proper error message when trying to remove signature from
+    a disabled key.
+  * Keys are now sent from the key management sub-menu. Multiple keys
+    can be tagged.
+  * Keys can be tagged and added to a key/address link
+  * The key/address link file can be edited
+  * Changed a few hot keys
+  * Made menu and help more consistent with the alias sub-menu.
+  * All functions now use the key ID instead of the user name.
+- Use the current key ring (i.e. the one selected in the key management 
+  sub-menu) when adding keys from an e-mail and when sending keys,
+  when sending mails and decrypting mails.
+- Deleting keys is now interactive and will therefore work if a user
+  has multiple user IDs.
+- Messages can now be interlocked (i.e. the software will detect PGP
+  messages and keys within encrypted messages), ad infinitum.
+- Added S)ave option, which saves a message in decrypted format.
+
+COMMENTS, REQUESTS and CHANGES up to 5.8.95 -- RELEASE OF PGP5a
+
+From ralf@waldorf-gmbh.de Mon Jun 12 00:32:05 1995
+...one is not able to configure pgp-elm without having installed pgp before.
+the configure script blocks after the question
+'where is pgp stored on this system'.
+--> Configure script should actually catch such cases, but does not seem to
+--> work. /gec
+==> FIXED /gec
+
+From roessler@sobolev.rhein.de Wed, 14 Jun 1995 03:25:37
+> mir ist gerade ein Segfault mit Elm gelungen: Versehentlich beim
+> Mausbedienen mit dem Aermel auf eine Funktionstaste gekommen, mehrere
+> Zeilen wurden zugemuellt (`Set current message to:'), Elm produziert
+> daraufhin einen Segfault [reproduzierbar]. Da ich im Moment absolut keine
+> Zeit habe (und ausserdem mein elm nicht mit -g compiliert ist), die Bitte,
+> ob sich vielleicht einer von Euch das mal naeher ansehen kann.
+From chris@phil.uni-sb.de Wed Jun 14 03:43 MET 1995
+Ja, wenn man 20 Sekunden in den Code reinguckt (in_utils.c), sieht
+man, dass das zwangslaeufig knallen muss.  Die eine Routine
+(read_number()) legt einen Puffer der Groesse NLEN (48) an und gibt
+ihn der Funktion optionally_enter(), die davon ausgeht, dass er SLEN
+(256) Zeichen gross ist.
+--> read_number should create buffer of size SLEN, not NLEN /gec
+==> FIXED /gec
+
+From bontchev@fbihh.informatik.uni-hamburg.de Thu Jun 15 12:43 MET 1995
+> a. PGP support is only active and visible if the following conditions are met
+>    - Environment variable PGPPATH points to the key ring AND
+Aha, so *this* is why Elm-PGP suddenly stopped working on my system!
+You see, my PGPPATH variable points to where the PGP directory is; not
+to the keyring. The keyring is elsewhere (I am using the public
+keyring of our keyserver which runs from a different account) and is
+pointed to by a variable in the file config.txt.
+--> elm-pgp should parse config.txt and (for searching purposes behave just
+--> as pgp does). Easiest way might be to grap out the pgp-sources
+--> how it hunts the default pubring. /gec
+--> Even easier would be to place a symbolic link in the PGPPATH directory,
+--> which points to the acutal keyring /bontchev
+--> a third solution would be to disable elm-pgp's check about wether the
+--> keyring is accessible or not. /gec
+==> extended to check in ~/.pgp if no PGPPATH, and accept config.txt too /gec
+==> before checking for config.txt .pgprc is checked.
+
+From Ralf Baechle <ralf@waldorf-gmbh.de> Sun, 11 Jun 1995 02:21:07
+> heiten. Ich habe Elm bei mir so konfiguriert, dass er die abgeschickten
+> Emails in den entsprechenden Mailfoldern abspeichert. Da steht das Zeug
+> zwar auch beim PGP Elm drin - aber mit Deinem Schluessel verschluesselt...
+--> use PGP's ENCRYPTTOSELF, add this to the readme, together with other
+--> options that should be placed in the config-txt of PGP /gec
+==> Added section 2.h to README /gec
+
+From Ralf Baechle <ralf@waldorf-gmbh.de> Sun, 11 Jun 1995 02:21:07
+> Ich finde es gar nicht gut, dass PGP Elm nur entweder an alle oder an
+> gar niemanden die Emails verschluesselt verschickt. Das ist z.B. nicht
+> besonders praktisch, wenn nur ein Teil der Adressaten einen Schluessel
+> in meinem Publickeyring hat. Da sollte doch wenigstens gefragt werden,
+> ob man
+>  - nichts
+>  - so weit als moeglich verschluesselt 
+>  - alles unverschluesselt
+> verschicken will. Oder falls das Problem auftritt hat man einfach nur
+> falsche Adressen angegeben?
+--> In my opinion it is a *bad* idea to only partially encrypt. The rest 
+--> of the effects should be catched by the send-menu. /gec
+==> comments, please!
+
+From Ralf Baechle <ralf@waldorf-gmbh.de> Sun, 11 Jun 1995 02:21:07
+> Weiterhin muss wohl auch noch etwas daran gearbeitet werden, welche
+> Schluessel fuer CC, BCC und einer/mehrere To-adressen verwendet werden.
+> Waere doch z.B. ungeschickt, wenn die BCCs nicht "blind" sind, weil der
+> Nachricht dann mit PGP noch rausfinden kann, dass sie auch noch mit
+> anderen Schluesseln zu lesen ist... Na, das aktuelle Problem mit BCC
+> ist auf jeden Fall, dass der BCC Adressat die Email gar nicht lesen kann,
+> weil sie mit dem/den To- Keys verschluesselt wird...
+--> do a check for using PGP on the bcc part to, eventually re-encrypt with
+--> new keys. /gec
+==> BCC-Keys are now checked too, and the message is encrypted by using them.
+==> This compormises the semantics of bcc: as any receiver could check for
+==> who the message has been encrypted. /gec
+==> Comments ?
+
+From rmuchsel@iiic.ethz.ch Tue Jun 20 11:25 MET 1995
+> From gec
+> I just checked rm's sources, and I see no reason why he actually controls if
+> the public keyring exists. Perhaps you may (for a first go) just remove the
+> function access_keys() and any call to it ? 
+Der public key ring wird checkt, damit der pgp elm generell installiert werden
+kann (fuer alle User), die user ohne pgp es aber nicht merken. Vielleicht keine
+so gute Idee.. 
+--> might remove call to access_check() /gec
+==> IGNORED, see extensions to access_keys above  /gec
+
+From kssingvo@immd4.informatik.uni-erlangen.de Wed Jun 21 14:54 MET 1995
+it would be a great help, if you would add a note, where the actual
+version of PGP ELM can be found into the file README.PGP-Support.
+So please, can you tell me, where I can find it what the actual
+patchlevel is?
+--> add to readme /gec
+==> DONE /gec
+
+From kester@unix-ag.uni-kl.de Wed Jul 12 22:38 MET 1995
+One bug, I want to report: On our system ELM-PGP dumps a core if
+forced  into PGP-mode when PGPPATH unset and ~/.pgp not existant.
+[with patch]
+BTW Another approach to combine ELM  with  PGP  is  ELM  2.4  PL24  ME5a.
+Info  can  be found at http://www.cs.hmc.edu/people/me/elm/me.html).
+--> remove access_check, more smart hunting of keyring for ^K function /gec
+==> patch modified and applied /gec
+
+From almesber@lrc.epfl.ch Mon Jul 24 11:46 MET 1995
+Uebrigens, zu PGP: wann kommt das naechste Update von elm-pgp ? Es waere
+z.B. auch nett, wenn die PGP-Features auch in den Help-Texten waeren.
+(Und auch in den nicht-Expert-Menues.)
+--> who types them in ? /gec
+==> TO DO
+
+From caronni@tik.ee.ethz.ch 3.8.95
+--> Change 'E' flag to P, E is used for Expired
+==> DONE /gec
+
+From caronni@tik.ee.ethz.ch 3.8.95
+The keyring that was selected in the key-menu should be used for future
+pgp invocations.
+--> ?
+==> Comments, please!
+
+From caronni@tik.ee.ethz.ch 5.8.95
+--> Add +textmode=off for check of passphrase, to remove warning
+==> DONE /gec
+
+From caronni@tik.ee.ethz.ch 5.8.95
+Multiple keyrings should be possible. So you can have a small keyring with
+the keys you usually use, and a large one, which takes substantially more
+time to process.
+--> ?
+==> Comments ?
+
+From caronni@tik.ee.ethz.ch 5.8.95
+--> Send-Menu for sending of keyring too! (perhaps one wants to encrypt the
+--> keyring, or abort the operation!
+==> DONE /gec
diff -u -r --new-file ../oldelm/MANIFESTO.PGP-Support ./MANIFESTO.PGP-Support
--- ../oldelm/MANIFESTO.PGP-Support	Thu Jan  1 01:00:00 1970
+++ ./MANIFESTO.PGP-Support	Wed Aug 30 21:07:42 1995
@@ -0,0 +1,66 @@
+
+   Manifesto
+   ---------
+
+   This is about privacy and 
+   why encrypting messages
+   is not for criminals only.
+
+   There has been great resentment at governmental scanning of the network
+   traffic. However, we feel that espionage by local administrators, by
+   employers or benign colleagues is far worse a threat. Remember how easy
+   it is to install and use a packet sniffer?
+
+   We feel nobody has the right to read your private mail, your love letters
+   or that promising new job offering.
+
+   You might also have heard of the legal troubles of Phil Zimmermann, the 
+   creator of the free PGP encryption program. 
+   Check http://www.ifi.uio.no/~staalesc/PGP/home.html for the latest news 
+   and how to support his legal defense team.
+
+   Many of you use the popular Elm program to send and read electronic 
+   mail.  The Elm-PGP patch is aimed at making the use of encryption and 
+   authentication in electronic mail easier. With the patch, using PGP and 
+   encryption is as easy as typing the correct pass phrase while retaining 
+   all the power of Elm.
+  
+   Please use this patch and share it with your friends. This time, it's 
+   easy to keep your privacy. 
+
+
+
+   Disclaimer
+
+   We are in Switzerland, Europe. We are not affiliated with Phil Zimmermann,
+   nor with the creators of Elm. Please check the file README.PGP-Support for
+   closer information.
+
+   Since the patch was written in Switzerland, distributing the patch is legal
+   (the location is important, because some US governmental institutions feel
+   that even the export of code containing HOOKS for encryption programs is
+   illegal).
+
+
+
+
+                               NO WARRANTY
+
+      BECAUSE THIS PATCH IS PROVIDED FREE OF CHARGE, THERE IS NO WARRANTY 
+    FOR THIS PACKAGE.
+    EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR
+    OTHER PARTIES PROVIDE THE PACKAGE "AS IS" WITHOUT WARRANTY OF ANY
+    KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE
+    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+    PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE
+    PACKAGE IS WITH YOU.  SHOULD THE PACKAGE PROVE DEFECTIVE, YOU ASSUME
+    THE COST OF ALL NECESSARY SERVICING, REPAIR OR CORRECTION.
+     
+      IN NO EVENT WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY 
+    MODIFY AND/OR REDISTRIBUTE THE PACKAGE, BE LIABLE TO YOU FOR DAMAGES,
+    INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES 
+    ARISING OUT OF THE USE OR INABILITY TO USE THE PACKAGE (INCLUDING BUT 
+    NOT LIMITED TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES 
+    SUSTAINED BY YOU OR THIRD PARTIES OR A FAILURE OF THE PACKAGE TO OPERATE 
+    WITH ANY OTHER SOFTWARE), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN 
+    ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.
diff -u -r --new-file ../oldelm/README.PGP-Support ./README.PGP-Support
--- ../oldelm/README.PGP-Support	Thu Jan  1 01:00:00 1970
+++ ./README.PGP-Support	Wed Aug 30 20:58:16 1995
@@ -0,0 +1,520 @@
+This is the README for the PGP6 patch to ELM 2.4 PL24
+
+Changes from version 5a to 6 may be found in the file HISTORY and in the
+section '4) Changes' below.
+
+
+Blurb
+-----
+
+Elm-PGP offers tightly coupled usage of PGP in Elm. You are able to
+send PGP encrypted mails, check signatures and read encrypted mails
+with minimal overhead. There is also a user interface (similar to
+the aliases part of ELM) to comfortably manage the PGP keyrings.
+
+
+Authors and contact addresses
+-----------------------------
+
+The PGP6 patch contains changes and extensions to ELM which come from 
+muchsel@acm.org (Robert Muchsel - Main PGP integration),
+chris@phil.uni-sb.de (Chris Blum - Keyring management interface) and 
+caronni@tik.ee.ethz.ch (Germano Caronni - Extensions and bugfixes).
+
+Primary contact address for the PGP6 patch is caronni@tik.ee.ethz.ch
+Send bugreports (better: patches), comments and suggestions to me,
+I will forward them to the appropriate person.
+
+Elm-PGP is originally based on a hack by Mic Shaw <egd017@cent1.lancs.ac.uk>;
+we triedto reach him, but this address doesn't seem to exist anymore.
+This patch has been tested on Linux and Solaris, but it should work on
+any reasonably Unix compatible platform.
+
+
+FTP
+---
+You may get the newest version of Elm-PGP at
+ftp://ktik0.ethz.ch/~ftp/pub/packages/elm-pgp
+
+
+1. Features of Elm-PGP
+----------------------
+
+Our version of Elm-PGP has the following features:
+
+a. PGP support is only active and visible if the following conditions are met:
+   - Environment variable PGPPATH points to the folder in which the key ring
+     or the pgp config-file reside (pubring.pgp OR config.txt OR .pgprc) OR
+     (if PGPPATH is not set) .pgp exists and contains one of above files AND
+   - User level is greater 0 AND
+   - Command line option -P is supplied OR ELMPGP environment variable is set
+     OR user presses '&' AND
+   - The PGP pass phrase is entered correctly OR the PGPPASS environment
+     variable is set.
+   This makes it possible to install Elm-PGP as the default Elm for all users.
+
+b. Sending PGP messages is done automatically:
+   - If you have the public key of the recipient, the message will be signed
+     and encrypted.
+   - If you don't have the key, it will be signed.
+   - You can exclude recipients from encryption using the ~/.elm/pgpexclude
+     file (see below).
+   - If you want to send it plain (unsigned, un-encrypted), use the p)lain send
+     menu option.
+   - To send it just clearsigned use the si(g)n send menu option.
+
+c. The pass phrase is not kept in the environment and not passed as a command
+   line parameter. The pipe mechanism of PGP is used.
+
+d. Printing, piping, batch mode, etc. are supported.
+
+
+2. Installation
+---------------
+
+a. Make sure PGP and Elm 2.4 PL24 (standard) work and you know how to use
+   them. If you haven't compiled any version of Elm yet, it's probably
+   safer to try the unpatched version first.
+
+b. Apply the patches ('patch -p < elm.pl24-pgp6.diff') in the elm directory
+   itself. Some versions of patch need the '-p' argument to create new
+   files in the correct location, and not in the toplevel directory.
+   Apply later patches (e.g. elm.pgp6-pgp6a.diff) in chronological order.
+
+c. Run Configure. There are three new questions regarding PGP support:
+   - Location of your pgp program (easy, eh?).
+   - Decide whether you want Elm-PGP to check the pass phrase once it is
+     entered (checking the pass phrase is recommended).
+   - The domain part of your users' mail addresses if it differs from the
+     host name. Example: john.doe@magic.net needs to enter magic.net, because
+     the host name is something like 'ripoff122.magic.net'.
+     It is important to answer this question correctly, since Elm-PGP will
+     not be able to encrypt any mails to local recipients if this setting 
+     is misconfigured (the domain name is needed to find the correct public
+     keys).
+   - If possible, don't install Elm-PGP setgid.
+   - Use an ANSI compliant C compiler. gcc works fine. Ensure the symbol
+     ANSI_C is defined (add -DANSI_C to the compiler flags, this removes
+     the -traditional default setting). If you don't, you are asking for
+     trouble (i.e. Elm works without -DANSI_C, but -DANSI_C is recommended).
+   - Look at the end of this section for some hints to compile Elm-PGP under
+     Linux and Solaris.
+
+d. Make Elm-PGP ('make elm' or 'pmake elm') and run 'strip bin/*'.
+
+e. Make a backup copy of standard Elm.
+
+f. Move Elm-PGP to its proper place and set the permissions. This can
+   be done automatically by 'make install' or 'pmake install'.
+
+g. Set PGPPATH and ELMPGP environment variables (preferably in .login or
+   .profile) if you want to use the PGP features.
+   setenv PGPPATH ~/.pgp
+   setenv ELMPGP YES     <--- only if PGP support should be on by default
+
+h. It is useful to add the following line to the .pgprc or config.txt
+   file:
+   MyName = "<Your user id>"
+   Elm-PGP tries to set all other options automatically. Section 5 lists
+   all styles of PGP invocations Elm-PGP does.  For further information, 
+   please check pgpdoc2.txt
+
+i. Check whether you configured the mail domain correctly:
+   Run elm -P  and enter the pass phrase. Now m)ail to your own user id.
+   If PGP-Elm can encrypt the mail ('Encrypting...') and it shows up
+   in the incoming folder with a 'P' status indicator and you can display
+   it properly, everything is OK. As a last check, press '%' and verify
+   that the address is correct.
+
+j. Some Hints for Linux:
+   - If stdarg.h can not be found then make a symbolic link in /usr/include
+     to wherever this file is on your system. (use find).
+   - Does your /etc/passwd file keep full names in Berkeley/V7 format -> Y
+   - Compiler -> gcc
+   - Any additional cc flags? -> -DANSI_C   (__NOT___ --traditional etc.)
+   - Use pmake -> Y
+   - To make: pmake, pmake install (make does not work if you have pmake)
+   - Some systems don't set the domain name correctly. Add a file called
+     'domain' to the Elm lib directory and put the domain name into this file.
+
+k. Hints for Solaris:
+   - Do _NOT_ use the flock() locking style. (dot locking and fcntl is ok)
+   - Under some systems, -DANSI_C might help avoid troubles.
+   - Some systems don't set the domain name correctly. Add a file called
+     'domain' to the Elm lib directory and put the domain name into this file.
+
+
+3. Using Elm-PGP
+----------------
+
+a. Start 
+
+If you have the ELMPGP environment variable set (or you use the -P command 
+line option), you will be asked for the PGP pass phrase. Pressing 'Enter'
+without giving a pass phrase disables PGP support immediately. You can clear
+and re-enter the pass phrase with the '&' key anytime.
+
+
+b. Main menu
+
+The second character in the message status column shows if there is PGP
+information attached to a mail (if there are several PGP related parts
+in the message, K takes precedence over P, P over S):
+
+  K -- Message contains public keys
+  P -- Message is encrypted ('PGP' or 'Private')
+  S -- Message is signed
+
+If you press enter to display the message, it will be decrypted. If it
+contains new keys, you will be asked whether you want to add them to your
+key ring and whether you want to sign the new keys. Messages may be signed,
+encrypted, etc. ad nauseam - Elm-PGP will recurse and should untangle 
+nested messages.
+
+There are five new key assignments:
+
+   P -- Decrypt tagged messages and print them through the PGP filter (like
+        p, but with decryption)
+   S -- Decrypt tagged messages and save them (like s, but with decryption)
+   \ -- Decrypt tagged messages through the PGP filter and pipe them to a
+        command (like |, but with decryption)
+   & -- Disable/Enable PGP support and clear the pass phrase in memory.
+   y -- Enter the key management menu. In this menu you are able to examine
+        your keyrings and to change trust parameters and pass phrases, add 
+	and remove signatures, keys and user IDs, and so forth.
+
+c. Sending messages
+
+When sending a message, it will be signed automatically. If the public keys
+of all recipients are available, it will be encrypted. Otherwise you will be
+asked if you want to send the message signed only. To send a plain unsigned
+message, press p) for plain. To send a signed message only use si(g)n.
+
+If you have the public keys of recipients who cannot handle encrypted mail
+or who don't like encrypted mail, you can exclude them from encryption using
+the pgpexclude file in the .elm directory. 'pgpexclude' is interpreted line
+by line. Each line should contain one user id and nothing else. E.g.
+
+    # This is a comment
+    hl@slow.ibmxt
+    doe@ihatepgp.encrypted.mail 
+
+If Elm-PGP is unable to find the public key (e.g. because the mail address
+and the address encoded within the key don't match), you can add a link
+from the key to the mail address (cf. key management).
+
+It is important to know that Elm-PGP selects the first matching user id in
+your key ring. For example, if you have to different keys from the same person
+(old and new key), Elm-PGP selects the first matching key based on the user
+id.
+
+You are able to enter PGP mode from the send menu by typing '&'. This is
+useful if you have composed a message without first enabling the PGP mode.
+If you are in send-only mode, the passphrase will not be checked. In this
+case it might happen that after hitting s)end or si(g)n you are returned
+to the send menu. In this case PGP failed to run successfully. Just toggle
+'&' off and on, and try entring the passphrase again.
+
+
+d. Key Menu
+
+The key menu allows you to select among your keyrings, and to perform key
+management operations on them. From here you can also send selected keys to
+other users. The currently selected keyring is used for encryption etc. in 
+the other menus. 
+
+An important feature is the ability to link PGP keys to mail addresses. This
+serves multiple goals:
+- When sending mails to a mailing list of which you have the keys of all
+  recipients: Just tag the keys, press 'n' and enter the address of the
+  mailing list. All future mails to the list will then be encrypted with 
+  all indicated keys (if PGP mode is enabled, of course).
+- You send mails to caronni@tik.ee.ethz.ch, but only have the key of 
+  gec@acm.org. Select the key of 'gec', press 'n' and enter the address
+  caronni@tik.ee.ethz.ch. The same is helpful if reply addresses do not
+  match user IDs, as provided in the keyring.
+- If 'rmuchsel@iiic.ethz.ch' has lent his account to Bill Clinton, you 
+  select the key of Bill Clinton and enter muchsels address. Thus mail to 
+  this account will be encrypted with a completely independent key.
+The Option e) of the key menu allows the manual modification of the key 
+link file (needed when deleting links or single key IDs from a link).
+
+
+e. Security
+ 
+Although Elm-PGP tries hard not to leave traces of your pass phrase
+in memory and to delete all temporary decrypted files, it is important to
+know that this is by no means a high security implementation. Elm itself,
+the Elm-PGP modifications and PGP all use temporary files. If you are
+running Elm-PGP on a personal account as the sole user, you could set the
+temp directory to a private directory (Configure asks for the temp 
+directory). 
+
+Don't use this program if you have to keep vital secrets. Elm-PGP might
+crash and core dump everything. Also remember that the Subject: line is sent
+in the clear (together with all the other headers). Thus, take care to
+choose a non-sensitive subject. If you run Elm-PGP from a remote work-
+station, remember this: Each time you type in your PASSPHRASE you give
+it away to the persons who might be snooping on the network. Be careful, 
+and use an encrypting telnet (or a secure IP layer like SKIP) for such
+occasions!
+
+Please don't mail your secret keyring. (Not that Elm-PGP would allow you to
+do so directly). It is a) not very clever to send long-term secrets in an 
+open mail, and b) does slightly confuse the receiving Elm-PGP ;-)
+
+Since the Elm-PGP patches have not been tested widely, it might also be
+wise not to install it setuid or setgid. It might be possible to deliberately
+crash Elm-PGP end end up in a root shell.
+
+
+That's all there is to know about Elm-PGP.
+
+
+4. Changes:
+-----------
+
+For version 6:
+
+- Fixed numerous typos, glitches, errors in the help files and
+  fixed some screen update problems and other loose ends.
+- Added a fix to Configure to work properly with GNU "nr"
+- Fixed the Makefile so that elm-help.4 will be installed on make install.
+- Changed hot keys: 
+    si(g)n instead of C)learsign (the message didn't fit into 1 line)
+    ke(y) management instead of ^K
+- Signing and encrypting a key is now allowed.
+- Added support for PGP keys to mail address links. You can use this
+  function to alias keys, add keys for multiple recipients (when
+  using a mailing list), etc.
+- Key management sub-menu:
+  * Display proper error message when trying to remove signature from
+    a disabled key.
+  * Keys are now sent from the key management sub-menu. Multiple keys
+    can be tagged.
+  * Keys can be tagged and added to a key/address link
+  * The key/address link file can be edited
+  * Changed a few hot keys
+  * Made menu and help more consistent with the alias sub-menu.
+  * All functions now use the key ID instead of the user name.
+- Use the current key ring (i.e. the one selected in the key management 
+  sub-menu) when adding keys from an e-mail and when sending keys.
+- Deleting keys is now interactive and will therefore work if a user
+  has multiple user IDs.
+- Messages can now be interlocked (i.e. the software will detect PGP
+  messages and keys within encrypted messages), ad infinitum.
+
+
+For version 5a:
+
+- Fixed check for keyring to look for config-file too, should now correctly
+  handle default path of pgp.
+- Added hints about ENCRYPTTOSELF to README
+- Changed 'E' to 'P'
+- Before sending keyring the user is asked if ok
+- Messages are encrypted for bcc-keys too
+- Created HISTORY.PGP file, contains comments and changes
+- Fixed configure-script to handle non-existence of pgp
+- Internal fixes...
+- Fixed some typos
+
+
+For version 5:
+I have changed the following from Mic's PGPELM implementation:
+
+PGP pass phrase:
+- will not be stored in the environment
+- will be copied from the PGPPASS variable if it is set
+- will be cleared when <&><Enter> is pressed
+- will be cleared when program exit()s
+- will be queried in 'Send only mode', too.
+PGP support will be disabled after three bad passwords instead of halting
+the program.
+
+Key assignments:
+- Changed not to conflict with the ELM standard keys
+
+Environment variables:
+- ELMPGP=YES is equivalent to the -P option
+- PGPPASS variable is supported (see above)
+
+Send mail menu:
+- check for public keys automatically and encrypt if possible
+- support for pgpexclude file
+- removed extra p)gp menu
+- p)lain send option available to send unsigned and un-encrypted text
+- C)learsign available to send signed mail only
+- '&' is able to toggle pgp mode in send menu too
+- expand alias and carbon copy names properly
+
+Main display:
+- second char in row shows type of message
+- added PGP keyring manager, reachable via ^K
+
+MIME support:
+- removed x-application dependency, PGP messages will be recognized
+  regardless of the MIME information (the whole message is scanned)
+- only encrypted messages and public key messages will get the MIME
+  header so all people can read signed messages
+- replaced MIME application types with "application/pgp" as suggested
+  in the PGP documentation
+
+Message display:
+- display bounced messages properly (not only the PGP part)
+- display messages consisting of more than one PGP part properly
+- recognize pgp encrypted mails not sent by another Elm-PGP
+
+Misc.:
+- find PGP keys independent of the PGP_SLASH configuration option
+- display "Please wait..." message where appropriate
+- pipe pgp output to /dev/null in some cases to preserve the screen
+  layout
+- don't call PGP via the shell
+- use pipes to communicate with PGP in some places (pass phrase)
+- renamed default mail folder to Mail instead of mail
+- print and pipe work with more than 1 message
+- Batch and Send only mode work
+- upgraded to PL24 and created a clean diff
+- removed a bunch of bugs (and introduced a few new ones :)
+
+And many many other changes...
+
+
+
+5. PGP Invocations:
+-------------------
+
+PGP is invoked for different purposes by Elm-PGP. This is an (as of PGP6)
+exhaustive list of invocation methods:
+
+encrypt:
+  pgp -sweat +force +batchmode +encrypttoself +verbose=0
+      [+pubring=/selected/pubring.pgp] tmpfile key-IDs
+sign:
+  pgp -staw +force +batchmode +verbose=0 +clearsign=on tmpfile
+passphrase-check:
+  pgp -sbf +batchmode +force +vebose=0 +textmode=off (on -1 fd)
+sending pgp keys:
+  pgp -kxaf +verbose=0 +batchmode (on fd pointing to tmpfile)
+decryption/signature checking:
+  pgp -t +batchmode _verbose=0 +force [+pubring=/sected/pubring.pgp tmpfile
+key extraction:
+  pgp -ka +verbose=0 +interactive=on tmpfile [keyring]
+key management (generating list):
+  pgp -kvvc +batchmode [keyring]
+key management (key deletion):
+  pgp -kr +verbose=0 key-ID [keyring]
+key management (key modification):
+  pgp -ke +verbose=0 key-ID [keyring]
+key management (key signing):
+  pgp -ks +verbose=0 key-ID [keyring]
+key management (key signature removal):
+  pgp -krs +verbose=0 key-ID [keyring]
+key management (key signature dis/enabling):
+  pgp -kd +verbose=0 key-ID [keyring]
+
+
+========== And now some PGP keys ==========
+
+-----BEGIN PGP PUBLIC KEY BLOCK-----
+Version: 2.6.2
+
+mQCNAi1CDBsAAAEEALPQMXYAKg7CU/ZSfjGWxDrsxUyiXwQ49AgGnojhoSIAt9A4
+OLO7yccAm144i49hbguXnuxf4/RIZvWmkqgN8VSROG9DoMcus4/PlCSZaU5K0bCt
+mUSlPEAL1c4gP9d54J/024MlwM50zsgmdgaXGaSpjqD4r5iFjkW/rgoB+dHxAAUR
+tCFDaHJpcyBCbHVtIDxjaHJpc0BwaGlsLnVuaS1zYi5kZT60KENocmlzIEJsdW0g
+PGNocmlzQGNocmlzLnRlbGlwLnVuaS1zYi5kZT60I0NocmlzIEJsdW0gPGNocmlz
+QHBoaWwxNS51bmktc2IuZGU+iQCVAgUQLoCoCpTnQ0kvoxr1AQHusgP9Fhhkbudc
+DSYzScF3A8mjPcQeY1h4UzEIuFSV0HpqRZKU5tljAetyMkEfyX3vyxZOQVjk2xKS
+PnwUdbp/1V8kPz94GVXCh3/kohjp5uTcCFdGfKBxgkHV9N/5chhvV90ZtHPwH5Z7
+REIbp/P8wcrAarOmBZjCIaW2yZiw41lAkSGJAJUCBRAthRDaRb+uCgH50fEBAY+P
+A/9O04XnmUCUJkibXs+oYd8sXNdU62SKsAvmdWZnCSk3j0nHFRLF7uOgq7hliNVu
++yQQ9WvG1cHiyrHIGToBHpDHILF/5P8oB03NMMnsdis8uwbxkjsat9v9Hbt2lPGT
+zXemwvgfOA6xbYukBbqmzP0CCyY+ipyQL6ag5sPsugWa5LQkQ2hyaXN0aWFuIEJs
+dW0gPGNoYmxAc3R1ZC51bmktc2IuZGU+iQCVAgUQLYUR8kW/rgoB+dHxAQFReAP+
+LsoOop3527MLg5ByFaAmGtP1iZuoob8SjeQKWUVoBbu32es0H3ZM9jhq6Vx4kFD8
+mMbSxo6AfmlRcI3L6FZBTjNSwYTqIi5cvTwMmeygDIxYyPn0zo4GKxMOyhansDMk
+cTDFv6uniaF1aaMgRcF92veBeiCmMCfpUN7RhfRZunCJAJUCBRAtQzHO1bVsA1te
+xzEBAZJoA/4zIvXku4ZOcmFYkyB5LktlDnKjMAbbsWLOt6PkDewn23ZOBozOs1p9
+NnhnmWXV48MD3y2Y3FJ5zzzvW7g0uOmPdUHKkHKq1eDYRDz2f5YGyhxEWzA0kBa5
+xJfauNdFxGa3/IXm6xpOkxv8QlXE+fOYl4pKQ0eOow27nQdpIrMCRJkAjQMvPVjE
+AAABBADLdM5gjjgNC7qkka+euahsQp+++rJ3xQUgal+uZsaWYRM66f4yslqkeXUC
+ZLrH42nvDZcfiTVSYiQ5+vqxH+W9XEwGwFWdUAH5FfR0y4D6cUMr/YL6spnr/1kX
+SGsZboZZQPPNm7RkyqbKZ2iugsY8TxkIH5ayEdC4YhK0dP+17QAFEbQgUm9iZXJ0
+IE11Y2hzZWwgPG11Y2hzZWxAYWNtLm9yZz6JAJUDBRAwL0nlAChtpI9aymkBASP8
+A/0R3Jz7xbBnafsG7kQ2k0Aejtwd6JE0nvJv/qJ7wMv76rrDaldWCPAe1ZN3lhsH
+zjXJLMnkTHOoDGs/nq8ykWokxzwCG6jdeDxL50hdZwmKJUZkyddKcTSRz/r1yeIW
+T/Kdfbmx9yj1vpcGrTnnW+hrzIjCI0YsoCVTxewwQwCpjokAlQMFEDA4umSx/IyH
+e3rl4QEBBucD/R+1Dy76WdnsMgRLiOuqWUHe9FDe8nJ+mOx03UXOqWukr6nTWszR
+ol8aSN6uCXn0YgoT/6ZA0HSA7WWS1GnJpeonxl+yN9sPtdqoP+UG79yv2VUs0wpT
+7G9qDn/dHxzQdaB2hPuxgNogxI10xQFKqQOv5kH2NeI2WFf4SraOh9tNiQCVAwUQ
+MCKTwLhiErR0/7XtAQGU1wP+NmqARPTGNtOv3ZGQ9UCwcPBGDXKY+QESHBsfsKc4
+vzkurdREGNMt59Mtg0jj6v7UZvMGf9829RT/Yx2r0aC+oyP+WPM1boFmdgGiiebd
+AraPz21EjMrqjhjNfvC13zyxxRqkcnCD3M8ONmDa29Qa++uqHhHQqxqZ/OAjKNwM
++RC0JlJvYmVydCBNdWNoc2VsIDxybXVjaHNlbEBpaWljLmV0aHouY2g+iQCVAwUQ
+L9GjfbH8jId7euXhAQGWggQAgVEeF8diB56yXcWyTScr9BWebp8b/V+QscibZ4Bp
+lhfGfXNgz4zc/ISE68iyU6e5jESFp6VheQfaSRf697guPPwB7r3tn1Y+Z13tCMrw
+H4CkHLTE/3R3QgDrFegKBFv56ElffOOSH/h3AuCCNz+kE2ygvYuXa3BwicoPsLZ+
+VlCJAJUDBRAvPzcBF2VJgjtGFlEBAQeEA/9rlAOdtoxJG+cVSiBK241HkUFhIy37
+6k4VaPYaVTiKVQarzYrr+rpJROCgmqCj2eUtgq2jCvU3KYGn34kOBs8yhdc9XEDj
++9IpUQdCqEAyJQQMbpME/QX8SCv2Dp3fTcsx7uaQwkTEGxy0F4TdLpPHESVPwEVm
+oB5TZModjRC8BokAlQMFEC89WNa4YhK0dP+17QEBByYD/AuOXSu+WtCP9YYHL0Nc
+SyBJc72f2SXoVa278cd7BTJp6TP03VUUnykzg3m+9gG+Kvxg7GV3nxJL9LO5/OSx
+GQlk8dwkdleJlC51EXjXg/fz9FVq7aQOyUp+pTq1YXwTpm9RqZRKofrk0/zX1qRe
+xscOi1Nm8SWBRsYnRo/ilHqAtCZSb2JlcnQgTXVjaHNlbCA8MjoyNDYvODEwMC4x
+MUBGaWRvTmV0PpkAjQMuyOVsAAABBADDaj4C7J7iFL12xNuVysjHttnozINOfRew
+sCfQA839kcSw4QETIVSgNHRIpin0wOam52d9AebFIirkf1XekhlUx4c16BD1mcur
+LJcEC1j8KBLEolhjBVdLAKjxtxCQ3A0ygQjzzlzsKwS4DIh03AxOXeT4m99ny82x
+/IyHe3rl4QAFEbQoR2VybWFubyBDYXJvbm5pIDxjYXJvbm5pQHRpay5lZS5ldGh6
+LmNoPokAlQMFEDBCMCO4YhK0dP+17QEBfVYEALwkWAZfv65UEpJGSfH3w90bhej+
+ILowiB0Ug/pfjzLWTMHuQcC1qQC0eqrZQIQUmdczWi1CIk5gYenjMuePwol41WNj
+5LGe2lbzJt4khE5ZC2sEI/LWimbPVGo3GL1AlPqWovEIJ7333Fz2yVUHlt8juN9G
+8SmarVwfLOyCS9MTtB1HZXJtYW5vIENhcm9ubmkgPGdlY0BhY20ub3JnPokAlQMF
+EDA4ixi4YhK0dP+17QEBB8sD/iuawW3zQ/l72GAl/xuic+IWZbfZwkIWZ+fxAbUF
+YbGqhOGE9fc4mwuGJvAxR2+JoubxVMmxpZGthZyV3rMUVb72fD+2A/RkBd/aETY2
+a3ZBH1ixCb6/tw+P1DJEd1HfAnrGWM3US9qBcb7JYwcEXYVQ9RP1W/f24Aboh3K3
+R/BaiQCVAwUQMDXzWLH8jId7euXhAQHt2AP/ReTlMdhBuw/zJ1qjEv6FocN0DIPM
+VUBNfuZ6N9vg97z78fpFY/COdRJRnaPRDLtq+GOVsk7sFSINIHgjq+Xh3DS25IWe
+aK6+3k8AHWpx8K5L8JSvjdS42cVZQmkJ9AljezHWURMtf/uUHcviKO5M269zPc5s
+0NnRU37HiWcyGa+0LEdlcm1hbm8gQ2Fyb25uaSA8Y2Fyb25uaUB0aWsuZXRoei5j
+aD4gJWdlYy0ziQCVAwUQMBkkcCdGuTtG77LVAQEvuAQA4110jqlikOWIBr9Wg6zi
+RaBuzXjiUorM3b6ig4ESAnFnCNJE9b8HIwUcolvQP/NAh97nT23fGAylWzuUxmqP
+7xfckzbJ1WBfqAaOI19wazawZm6OaLgWkPARfc/nuRhSqPXNtW4Si2QTdVx7nbl2
+ys3PT0j4yI69WAL7hcf8IaWJAJUDBRAwFE3LmuZlUFuB8XkBAfgxA/0VCkIMgOsg
+uZfs7AZdzLoeCVuxJ+ffUJaROQGohfi89K/usAZE/l+vL1PTUCCWH89M7sbHnqts
+eXyY2hmw8UGD13Y5ZRnvnFAuOXKHrDithTVVsMkEKbwQRiTcrPMwZbQUeD8Ulj12
+HjwBC9cI0ayfnSr/u4KG9ZETO1dq8TJwi4kAlQMFEDAO3dPFLUdtDb+QbQEBQ2ED
+/1T9UMiOM12LZ+hZlnaBussyiW2ChUcnOoFRSf6UQQjH8zBY2k1m32uy4XlBXYAf
+06OGnDPCs8SI/Q4DKS3QX6gWejzmbVEVeDRXtmoHhI3G4XOHY5Dc76yE/5apzU5g
+tZCarSJcIOWyLZSZInZe97emTy7ydhTeW8I6771ZuqqjiQCVAwUQMBhNVvvCP42x
+MxQ5AQH6XwP7BPyNyzGc1WSXM9hwVKDeUcC0TjsBQkFX2ijfF7uOhzx/8iRKS7ii
+RKzMK2fjSa3PNbuQnB+0t49FO582uTnibQUfbQC2wc0dJVdV+XFv1hNepuZafIFn
+y8IoMFtIQ5RGkyPUgJMbInYpzIll1iAODPWkEvmg4dhk6b4H8QgIYlWJAJUCBRAw
+D00z4uW74fteFRkBAcldA/0cBwozm8dl9Tun5CiBKU0WOwEcVqSv0h/WoVl2vj7B
+tQUC3owYuwvRxMR4Nt6+fLcQZYnwDoBC0bd1CMRVt701wl8CcKka6/yXN379MOVi
+pNnjv5QrmZR3XKXdO4k3BksQ34OXVZK2gt1IMUHxQI8LUqwWkbLTd+6HwHYRapRr
+C4kAlQMFEDAOUbun4y1TSjMnFQEBNuYD/R2jkZwJm71yEf6ieK0RYMyDzblwj2rq
+RmrqGKtTw2iHY+i+rVGIIb82EQC5uPRO725PpBkd7wEA+ow64Zkf7eomVstoqkZ1
+CMd+YxJi8r9IU+TnN29zA8+VeU2e5LF2TKgnSfbZWiwc8ECwq755HctqNvYknVlJ
+333s6LYIzyFyiQCVAwUQL+GXqrH8jId7euXhAQHYWQQAvR4pBAx3HMBdVkIibdVL
+9D3Zx9bRG+XMduYHHF5bjPW1o/wn80zTbywfu/5zEhFTvPB1u6pz2K5TFMXuDMoW
+ND/lYw6ZiYDvq92BFIMqAInR6hzztZRld+Cmv+h2apVxre1cwibuWkTASXLzRIOr
+YqwBzmcyiaUQqD37WSZKi9+JAJUDBRAv3xk7BBmAwkFmqS0BAUfHBACxLVVyLNUE
+HRnhxJuxMlg62UN+trugKprCfPwGrIMPq0XoDMQV5ZLTw7KyHkIfDRqf69QyugyG
+hWLTdNZ7GUDktPE84V6U1HG8ZsLFG7hjgCbSK2oGQL5dBZEYo1e/pOnHDFGd2MRJ
+Wc4uB7y/czH6pERFAPFDLSBRWFlZBfmsNYkAlQMFEC8/MO8XZUmCO0YWUQEBi0QE
+AJ0Qi7A7kOk1qN9OWyZ6Ma+vmGEW/dhSCETEVDPwjb/89xjpr70NHcUcHJN3wQOH
+Oc+EYpSp8UEYxtj/y0sL9DsGRK3phdZ2cuW5wQWTyAoQdzg+y6AbsRHfOmM3eyOw
+39tV+mkShK5dWAjwpfk8X6vy5oAejILeRDt3kvdcivEiiQCVAwUQLz81FbhiErR0
+/7XtAQEBBwP/VmQcul2BRUgyzroiIDOzCanVHqvM8t1zfVWLkxMwzCdJw4b6lK5b
+zHTZWigse1gMuJIgwlc8N/sMdMiUJa97geT9AS/TFvdI1SgWTalszQTRaxXhd2WC
+FPH0Zv72CIqkRaofjngGUjgvu2xUhwJiBcIy40MS54Kn9e5F9OuFdGqJAJUDBRAv
+FZ0xRb+uCgH50fEBAUOoA/0efu52FLjjGWShCa29wXCogMG0Y3gteRtrgm51n/3a
+uslgZheNtagdYSZWHi8uPH0eLVOw/FEd9BHFyFGR6nsJn+HWFW3y0YesuHe4zBVM
+Q1fypIIcQ2qIgTF/1CifLRg0er14ZzEiJAn1LPEFK1FXmQmrpitDYZv6DfF7X3YL
+1YkAlQMFEC7I5omU50NJL6Ma9QEBULYD/i1ZXD0cXG1UcnuZjK3BaIvGEX9z3itu
+NZlfLxQrnIlPoT4dOodZNxsrVD7np5KxfOvuURYuV9/7jDZ02/LSdsQuYxkQup0K
+O+qdQj8wR1Ah+WI7sN5sbJOtMu8lDCmVqRs9C18N7DNm9G3MToRHm4kN6H63drTh
+R/KX9BH16kiJ
+=vuPT
+-----END PGP PUBLIC KEY BLOCK-----
diff -u -r --new-file ../oldelm/config.h.SH ./config.h.SH
--- ../oldelm/config.h.SH	Mon May 30 18:55:57 1994
+++ ./config.h.SH	Wed Aug 30 00:54:14 1995
@@ -602,4 +602,18 @@
 #$d_xenix	XENIX	/**/
 #$d_bsd	BSD	/**/
 
+/* PGP_PATH:
+ *      This symbol points to the PGP program.
+ */
+/* DONT_CHECK_PASSWD:
+ *      This symbol, if defined, disables checking of the PGP pass phrase.
+ */
+/* MAIL_DOMAIN:
+ *      This symbol sets the domain name of the user's mail address.
+ *      The mail domain defaults to the host name, if it is undefined.
+ */ 
+#define PGP_PATH "$pgp_path"
+#$dont_check_passwd DONT_CHECK_PASSWD	/**/
+#$d_mail_domain MAIL_DOMAIN "$mail_domain"	/**/
+
 !GROK!THIS!
diff -u -r --new-file ../oldelm/doc/Makefile.SH ./doc/Makefile.SH
--- ../oldelm/doc/Makefile.SH	Thu Mar 10 18:20:29 1994
+++ ./doc/Makefile.SH	Wed Aug 30 00:54:15 1995
@@ -174,6 +174,7 @@
 			$(LIB)/elm-help.1	\
 			$(LIB)/elm-help.2	\
 			$(LIB)/elm-help.3	\
+			$(LIB)/elm-help.4	\
 			$(LIB)/elmrc-info
 
 # List of files installed in remote LIB directory
@@ -181,6 +182,7 @@
 			$(REMOTE)$(LIB)/elm-help.1	\
 			$(REMOTE)$(LIB)/elm-help.2	\
 			$(REMOTE)$(LIB)/elm-help.3	\
+			$(REMOTE)$(LIB)/elm-help.4	\
 			$(REMOTE)$(LIB)/elmrc-info
 
 # List of formatted guides
@@ -319,6 +321,10 @@
 				$(CHMOD) u=rw,go=r $@
 
 $(LIB)/elm-help.3:		elm-help.3
+				$(CP) $? $@
+				$(CHMOD) u=rw,go=r $@
+
+$(LIB)/elm-help.4:		elm-help.4
 				$(CP) $? $@
 				$(CHMOD) u=rw,go=r $@
 
diff -u -r --new-file ../oldelm/doc/elm-help.4 ./doc/elm-help.4
--- ../oldelm/doc/elm-help.4	Thu Jan  1 01:00:00 1970
+++ ./doc/elm-help.4	Wed Aug 30 00:54:15 1995
@@ -0,0 +1,43 @@
+
+        Command                      Elm 2.4 Action
+
+
+           <RETURN>, <SPACE>    Display the current key
+           ?                    This screen of information
+           $                    Synchronize keyring
+           =                    Go to the first key in keyring
+           *                    Go to last key in keyring
+           -, <LEFT>            Go to the previous page of keys
+           +, <RIGHT>           Go to the next page of keys
+           /                    Search for pattern
+           c                    Change to a different keyring
+           d                    Delete current key
+           ^D                   Delete all keys with the specified pattern
+           D                    Disable/enable someone else's or PERMANENTLY
+                                      revoke your own public key
+           e                    Edit the key/address links file
+           J                    Increment current key by one
+           j, <DOWN>            Advance to next undeleted key
+           K                    Decrement current key by one
+           k, <UP>              Advance to previous undeleted key
+           l                    Limit key display by some criteria
+           m                    Modify user id of your own key, or the
+                                      trust parameter of someone else's
+           M                    Mail current or tagged keys
+           n                    Add new key/address link (alias)
+           q                    Quit key menue, asking about deletion
+           Q                    Quit key menue, deleting all marked keys
+           r                    Remove a signature from the current key
+           s                    Sign the current key
+           t                    Tag current key for further operations
+           T                    Tag current key and go to next message
+           u                    Undelete current key
+           U                    Undelete current key and advance to
+                                      next deleted key
+           x                    Exit leaving keyring untouched, ask permission
+                                        if keyring changed
+           X                    Exit leaving keyring untouched, unconditionally
+
+
+
+
diff -u -r --new-file ../oldelm/hdrs/defs.h ./hdrs/defs.h
--- ../oldelm/hdrs/defs.h	Thu Sep  1 21:42:39 1994
+++ ./hdrs/defs.h	Wed Aug 30 21:33:42 1995
@@ -1,8 +1,8 @@
 
-/* $Id: defs.h,v 5.35 1994/09/01 19:42:39 syd Exp $ */
+/* $Id: defs.h,v 5.35.2 1995/02/22 16:00:00 rm Exp $ */
 
 /*******************************************************************************
- *  The Elm Mail System  -  $Revision: 5.35 $   $State: Exp $
+ *  The Elm Mail System  -  $Revision: 5.35.2 $   $State: Exp $
  *
  * 			Copyright (c) 1988-1992 USENET Community Trust
  * 			Copyright (c) 1986,1987 Dave Taylor
@@ -14,6 +14,20 @@
  *
  *******************************************************************************
  * $Log: defs.h,v $
+ * Added defines for xxx_FILENO, as used by pgp-elm
+ * From: caronni@tik.ethz.ch
+ *
+ * Revision 5.35.2  1995/02/22  16:00:00  rm
+ * Moved PGP variable declarations to headers.h and elm.h, added definitions
+ * for PGP end-block signatures
+ * From: rmuchsel@iiic.ethz.ch
+ *
+ * Revision 5.35.1  1995/02/20  23:00:00  rm 
+ * Added constants for PGP messages, renamed default mail folder to Mail
+ * Removed MIME dependant PGP constants, added extern definitions for
+ * passphrase and pgp_enabled 
+ * From: rmuchsel@iiic.ethz.ch
+ *
  * Revision 5.35  1994/09/01  19:42:39  syd
  * Moved #defines for SETJMP & LONGJMP from src/editmsg.c to hdrs/defs.h and
  * used them instead of (set|long)jmp directly. This makes the usage consistent
@@ -271,6 +285,8 @@
 #define CM_MMDF_HEAD		(1<<3)	/* strip mmdf message seperator */
 #define CM_REMAIL		(1<<4)	/* Add Sender: and Orig-To: headers */
 #define CM_DECODE		(1<<5)	/* prompt for key if message is encrypted */
+#define CM_ONLY_HEADER		(1<<6)  /* only copy header accross */
+#define CM_PGP_SCAN_KEYS	(1<<7)	/* add keys to key ring if possible */
 
 #define EXECUTE_ACCESS	1		/* These five are 	   */
 #define WRITE_ACCESS	2		/*    for the calls	   */
@@ -284,6 +300,13 @@
 #define START_ENCODE	"[encode]"
 #define END_ENCODE	"[clear]"
 
+#define BEGIN_PGP_MESSAGE	"-----BEGIN PGP MESSAGE-----"
+#define BEGIN_PGP_SIGNATURE	"-----BEGIN PGP SIGNED MESSAGE-----"
+#define BEGIN_PGP_KEY		"-----BEGIN PGP PUBLIC KEY BLOCK-----"
+#define END_PGP_MESSAGE		"-----END PGP MESSAGE-----"
+#define END_PGP_SIGNATURE	"-----END PGP SIGNATURE-----"
+#define END_PGP_KEY             "-----END PGP PUBLIC KEY BLOCK-----"
+
 #define DONT_SAVE	"[no save]"
 #define DONT_SAVE2	"[nosave]"
 
@@ -326,6 +349,11 @@
 #define	MIME_NOTPLAIN	16384	/* indicates that we have a content-type,
 				   for which we need metamail anyway. */
 
+#define PGP_MESSAGE	32768   /* message is PGP encrypted */
+#define PGP_KEY       	65536   /* message contains PGP key */
+#define PGP_SIGNATURE 	131072  /* message has PGP signature */
+
+
 /** some defines for the "type" field of the alias record **/
 
 #define SYSTEM		1		/* bit masks, of course */
@@ -339,6 +367,15 @@
 #define BY_NAME		64
 #define BY_ALIAS	128
 
+/** some defines for limiting of PGP key displays **/
+
+#define BY_USERID	0
+#define BY_KEYID	1
+
+#define PUBLIC		0
+#define SECRET		1
+
+
 #define UNDELETE	0		/* purely for ^U function... */
 
 /** values for headers exit_disposition field */
@@ -375,7 +412,7 @@
 
 #define plural(n)	n == 1 ? "" : "s"
 #define lastch(s)	s[strlen(s)-1]
-#define ifmain(a,b)	(inalias ? b : a)
+#define ifmain(a,b,c)   (inpgpkey ? c : (inalias ? b : a))
 
 #ifdef MEMCPY
 
@@ -469,11 +506,13 @@
 #define YESNO	2
 #define CHANGE  3
 #define READ	4
+#define PGPKEY	5
 
 #define MAIN_HELP    0
 #define OPTIONS_HELP 1
 #define ALIAS_HELP   2
 #define PAGER_HELP   3
+#define PGPKEY_HELP  4
 
 /** types of folders **/
 #define NO_NAME		0		/* variable contains no file name */
@@ -712,6 +751,15 @@
 #define	SEEK_END	2	/* Set file pointer to EOF plus "offset" */
 #endif
 
+/*
+ * these constants are sometimes found in unistd.h - but unistd.h is not 
+ * always included /gec
+ */
+#ifndef STDIN_FILENO
+#define STDIN_FILENO 0
+#define STDOUT_FILENO 1
+#define STDERR_FILENO 2
+#endif
 
 /*
  * The "safe_malloc_fail_handler" vector points to a routine that is invoked
@@ -752,3 +800,24 @@
 
 long times();
 long ulimit();
+
+/* structures for pgpkey */
+#ifndef IDLEN
+# define IDLEN 128
+#endif
+struct _pgpkey_sigaliasS {
+  int type;   /* 0 = alias, 1 = sig */
+  char name[IDLEN];
+  char id[9];  /* only if type == 1 */
+  struct _pgpkey_sigaliasS *next;
+};
+struct _pgpkeyS {
+  char user_id[IDLEN];
+  char key_id[9];
+  char fingerprint[50];
+  short bits;
+  int type;
+  char date[11];
+  struct _pgpkey_sigaliasS *sigalias;
+  int status;
+};
diff -u -r --new-file ../oldelm/hdrs/elm.h ./hdrs/elm.h
--- ../oldelm/hdrs/elm.h	Thu Sep  1 21:42:40 1994
+++ ./hdrs/elm.h	Wed Aug 30 21:35:22 1995
@@ -1,8 +1,8 @@
 
-/* $Id: elm.h,v 5.12 1994/09/01 19:42:39 syd Exp $ */
+/* $Id: elm.h,v 5.12.1 1995/02/22 16:00:00 rm Exp $ */
 
 /*******************************************************************************
- *  The Elm Mail System  -  $Revision: 5.12 $   $State: Exp $
+ *  The Elm Mail System  -  $Revision: 5.12.1 $   $State: Exp $
  *
  * 			Copyright (c) 1988-1992 USENET Community Trust
  * 			Copyright (c) 1986,1987 Dave Taylor
@@ -14,6 +14,10 @@
  *
  *******************************************************************************
  * $Log: elm.h,v $
+ * Revision 5.12.1  1995/02/22  16:00:00  rm
+ * Added PGP specific variables.
+ * From: rmuchsel@iiic.ethz.ch
+ *
  * Revision 5.12  1994/09/01  19:42:39  syd
  * Moved #defines for SETJMP & LONGJMP from src/editmsg.c to hdrs/defs.h and
  * used them instead of (set|long)jmp directly. This makes the usage consistent
@@ -108,6 +112,7 @@
 int current = 0;		/* current message number  */
 int header_page = 0;     	/* current header page     */
 int inalias = 0;		/* TRUE if in the alias menu */
+int inpgpkey = 0;               /* TRUE if in the pgpkey menu */
 int last_current = -1;		/* previous current message */
 int last_header_page = -1;     	/* last header page        */
 int message_count = 0;		/* max message number      */
@@ -172,6 +177,7 @@
 char v_editor[SLEN] = {0};	/* "~v" editor...   */
 char config_options[SLEN] = {0};	/* which options are in o)ptions */
 char allowed_precedences[SLEN] = {0};	/* list of precedences user may specify */
+char passphrase[SLEN] = {0};	/* pgp pass phrase */
  
 char *def_ans_yes;		/* default yes answer - single char, lc	*/
 char *def_ans_no;		/* default no answer - single char, lc	*/
@@ -279,6 +285,8 @@
 struct alias_rec **aliases;     /* for the alias menu */
 int   max_aliases = 0;		/* number of aliases allocated */
 
+struct _pgpkeyS **pgpkey;	/* for the pgpkey menu */
+
 struct addr_rec *alternative_addresses;	/* how else do we get mail? */
 
 int system_data = -1;		/* fileno of system data file */
@@ -292,3 +300,5 @@
 
 JMP_BUF GetPromptBuf;		/* setjmp buffer */
 int InGetPrompt;		/* set if in GetPrompt() in read() */
+
+int pgp_enabled;		/* set if pgp support is active */
diff -u -r --new-file ../oldelm/hdrs/headers.h ./hdrs/headers.h
--- ../oldelm/hdrs/headers.h	Thu Sep  1 21:42:40 1994
+++ ./hdrs/headers.h	Wed Aug 30 21:33:44 1995
@@ -1,8 +1,8 @@
 
-/* $Id: headers.h,v 5.13 1994/09/01 19:42:39 syd Exp $ */
+/* $Id: headers.h,v 5.13.1 1995/02/22 16:00:00 rm Exp $ */
 
 /*******************************************************************************
- *  The Elm Mail System  -  $Revision: 5.13 $   $State: Exp $
+ *  The Elm Mail System  -  $Revision: 5.13.1 $   $State: Exp $
  *
  * 			Copyright (c) 1988-1992 USENET Community Trust
  * 			Copyright (c) 1986,1987 Dave Taylor
@@ -14,6 +14,10 @@
  *
  *******************************************************************************
  * $Log: headers.h,v $
+ * Revision 5.13.1  1995/02/22  16:00:00  rm
+ * Added declarations for PGP support
+ * From: rmuchsel@iiic.ethz.ch
+ *
  * Revision 5.13  1994/09/01  19:42:39  syd
  * Moved #defines for SETJMP & LONGJMP from src/editmsg.c to hdrs/defs.h and
  * used them instead of (set|long)jmp directly. This makes the usage consistent
@@ -103,6 +107,7 @@
 extern int current;		/* current message number  */
 extern int header_page;         /* current header page     */
 extern int inalias;		/* TRUE if in the alias menu */
+extern int inpgpkey;		/* TRUE if in the pgp key menu */
 extern int last_current;	/* previous current message */
 extern int last_header_page;    /* last header page        */
 extern int message_count;	/* max message number      */
@@ -167,6 +172,7 @@
 extern char v_editor[SLEN];	/* "~v" editor...   */
 extern char config_options[SLEN];	/* which options are in o)ptions */
 extern char allowed_precedences[SLEN];	/* list of precedences user may specify */
+extern char passphrase[SLEN];	/* pgp pass phrase */
 extern char *def_ans_yes;	/* default yes answer - single char, lc	*/
 extern char *def_ans_no;	/* default no answer - single char, lc	*/
 extern char *nls_deleted;	/* [deleted] */
@@ -282,4 +288,10 @@
 #endif
 
 extern JMP_BUF GetPromptBuf;	/* setjmp buffer */
+
+
+extern int pgp_enabled;		/* set if pgp support is active */
+extern struct _pgpkeyS **pgpkey;/* PGP keys */
+extern char *keyring;		/* name of keyring currently shown */
+extern char *pubkeyring;	/* same, but with +pubring= in front */
 extern int InGetPrompt;		/* set if in GetPrompt() in read() */
diff -u -r --new-file ../oldelm/hdrs/mime.h ./hdrs/mime.h
--- ../oldelm/hdrs/mime.h	Sat Nov  7 21:50:23 1992
+++ ./hdrs/mime.h	Wed Aug 30 00:54:16 1995
@@ -1,5 +1,5 @@
 /*******************************************************************************
- *  The Elm Mail System  -  $Revision: 5.3 $   $State: Exp $
+ *  The Elm Mail System  -  $Revision: 5.3.2 $   $State: Exp $
  *
  * 			Copyright (c) 1988-1992 USENET Community Trust
  * 			Copyright (c) 1986,1987 Dave Taylor
@@ -11,6 +11,16 @@
  *
  ******************************************************************************
  * $Log: mime.h,v $
+ * Revision 5.3.2  1995/02/20  23:00:00  rm
+ * Renamed MIME PGP message type to "application/pgp" as per suggestion of
+ * PGP 2.6.2 documentation. PGP key messages will have the same message type 
+ * From: rmuchsel@iiic.ethz.ch
+ *
+ * Revision 5.3.1  1994/01/08  00:34:54  Mic
+ * Added defines for MIME pgp headers.  (uses X- since they are not official
+ * yet)
+ * From: egd017@cent1.lancs.ac.uk
+ *
  * Revision 5.3  1992/11/07  20:50:08  syd
  * add some new names to make header_cmp use easier
  * From: Syd
@@ -38,6 +48,7 @@
 #define	MIME_HEADER_CONTENTTYPE	"Content-Type"
 #define	MIME_CONTENTENCOD	"Content-Transfer-Encoding:"
 #define	MIME_HEADER_CONTENTENCOD	"Content-Transfer-Encoding"
+#define	MIME_HEADER_PGP		"application/pgp"
 
 /* Encoding types */
 
diff -u -r --new-file ../oldelm/hdrs/patchlevel.h ./hdrs/patchlevel.h
--- ../oldelm/hdrs/patchlevel.h	Sat Sep 24 03:37:45 1994
+++ ./hdrs/patchlevel.h	Wed Aug 30 00:54:17 1995
@@ -1 +1 @@
-#define PATCHLEVEL "24"
+#define PATCHLEVEL "24 PGP6"
diff -u -r --new-file ../oldelm/hdrs/pgpkey.h ./hdrs/pgpkey.h
--- ../oldelm/hdrs/pgpkey.h	Thu Jan  1 01:00:00 1970
+++ ./hdrs/pgpkey.h	Wed Aug 30 00:54:17 1995
@@ -0,0 +1,11 @@
+#ifndef _PGPKEY_H_
+#define _PGPKEY_H_
+
+#define KEY_TYPE_PUBLIC   0
+#define KEY_TYPE_DISABLED 1
+#define KEY_TYPE_SECRET   2
+
+#define TYPE_ALIAS 0
+#define TYPE_SIGNATURE 1
+
+#endif
diff -u -r --new-file ../oldelm/hdrs/s_elm.h ./hdrs/s_elm.h
--- ../oldelm/hdrs/s_elm.h	Tue Aug  3 20:58:35 1993
+++ ./hdrs/s_elm.h	Wed Aug 30 00:54:17 1995
@@ -1,4 +1,5 @@
 /* s_elm.h created from s_elm.us by gencat on Tue Aug  3 14:58:35 EDT 1993 */
+/* added PGP specific help keys, 1995/02/20 rmuchsel@iiic.ethz.ch          */
 
 #define ElmSet	0x3
 #define ElmYes	0x1
@@ -759,3 +760,9 @@
 #define ElmVfyMenuSndFgt	0x34e
 #define ElmVfyMessageKept	0x34f
 #define ElmVfyNoFieldsInForm	0x350
+/** Added for PGP **/
+#define ElmHelpPipePGP		0x351
+#define ElmHelpPrintPGP	0x352
+#define ElmHelpDisablePGP	0x353
+#define ElmHelpMailPGPKey	0x354
+#define ElmMissingPGPKey       0x355
diff -u -r --new-file ../oldelm/hdrs/s_pgpkey.h ./hdrs/s_pgpkey.h
--- ../oldelm/hdrs/s_pgpkey.h	Thu Jan  1 01:00:00 1970
+++ ./hdrs/s_pgpkey.h	Wed Aug 30 00:54:18 1995
@@ -0,0 +1,4 @@
+
+#define PgpkeySet	0x2a
+#define PgpkeyReturn	0x1
+#define PgpkeyDummy	0x2
diff -u -r --new-file ../oldelm/hdrs/sysdefs.SH ./hdrs/sysdefs.SH
--- ../oldelm/hdrs/sysdefs.SH	Thu Dec 24 20:24:11 1992
+++ ./hdrs/sysdefs.SH	Wed Aug 30 00:54:18 1995
@@ -16,9 +16,9 @@
 
 echo "Extracting hdrs/sysdefs.h (with variable substitutions)"
 sed <<!GROK!THIS! >sysdefs.h -e 's!^#undef!/\*#undef!'
-/* $Id: sysdefs.SH,v 5.4 1992/12/24 19:24:10 syd Exp $ */
+/* $Id: sysdefs.SH,v 5.4.1 1995/02/25 17:19:21 rm Exp $ */
 /*******************************************************************************
- *  The Elm Mail System  -  $Revision: 5.4 $   $State: Exp $
+ *  The Elm Mail System  -  $Revision: 5.4.1 $   $State: Exp $
  *
  * 			Copyright (c) 1988-1992 USENET Community Trust
  * 			Copyright (c) 1986,1987 Dave Taylor
@@ -30,6 +30,10 @@
  *
  *******************************************************************************
  * $Log: sysdefs.SH,v $
+ * Revision 5.4.1  1995/02/25  17:19:21  rm
+ * Added pgpexclude filename definition.
+ * From: Robert Muchsel <rmuchsel@iiic.ethz.ch>
+ *
  * Revision 5.4  1992/12/24  19:24:10  syd
  * EDITOROPTS and DEFEDITOR appear to be unused but here is
  * a patch to make use of $editoropts.
@@ -137,6 +141,8 @@
 #define elmrcfile	".elm/elmrc"
 #define old_elmrcfile	".elm/elmrc.old"
 #define mailheaders	".elm/elmheaders"
+#define pgpexclude	".elm/pgpexclude"
+#define pgplink		".elm/pgplink"
 #define dead_letter	"Canceled.mail"
 
 #define unedited_mail	"emergency.mbox"
diff -u -r --new-file ../oldelm/nls/C/C/C/s_elm.m ./nls/C/C/C/s_elm.m
--- ../oldelm/nls/C/C/C/s_elm.m	Tue Aug  3 20:58:06 1993
+++ ./nls/C/C/C/s_elm.m	Wed Aug 30 00:54:18 1995
@@ -1614,3 +1614,5 @@
 847	Message kept.  Can be restored at next f)orward, m)ail or r)eply.
 $ #VfyNoFieldsInForm
 848	No fields in form!\007
+$ #MissingPGPKey
+849	"Can't encrypt message, missing public key(s) - just clearsign? (%c/%c) "
diff -u -r --new-file ../oldelm/nls/C/C/C/s_pgpkey.m ./nls/C/C/C/s_pgpkey.m
--- ../oldelm/nls/C/C/C/s_pgpkey.m	Thu Jan  1 01:00:00 1970
+++ ./nls/C/C/C/s_pgpkey.m	Wed Aug 30 00:54:19 1995
@@ -0,0 +1,6 @@
+$set 42 #Pgpkey
+$quote "
+$ #Return
+1	"Return to main menu..."
+$ #Dummy
+2	"Dummy text"
diff -u -r --new-file ../oldelm/src/Makefile.SH ./src/Makefile.SH
--- ../oldelm/src/Makefile.SH	Thu Dec 24 22:42:05 1992
+++ ./src/Makefile.SH	Wed Aug 30 00:54:19 1995
@@ -123,7 +123,9 @@
 			newmbox.c	\
 			options.c	\
 			out_utils.c	\
+                        p_screen.c      \
 			pattern.c	\
+                        pgpkey.c        \
 			pmalloc.c	\
 			quit.c		\
 			read_rc.c	\
@@ -184,7 +186,9 @@
 			newmbox.o	\
 			options.o	\
 			out_utils.o	\
+			p_screen.o	\
 			pattern.o	\
+			pgpkey.o	\
 			pmalloc.o	\
 			quit.o		\
 			read_rc.o	\
@@ -290,7 +294,7 @@
 init.o:		$(INCLDIR)/headers.h $(INCLDIR)/patchlevel.h $(INCLDIR)/s_elm.h
 leavembox.o:	$(INCLDIR)/headers.h $(INCLDIR)/s_elm.h
 lock.o:		$(INCLDIR)/headers.h $(INCLDIR)/s_elm.h
-limit.o:	$(INCLDIR)/headers.h $(INCLDIR)/s_elm.h $(INCLDIR)/s_aliases.h
+limit.o:	$(INCLDIR)/headers.h $(INCLDIR)/s_elm.h $(INCLDIR)/s_aliases.h $(INCLDIR)/s_pgpkey.h
 mailmsg1.o:	$(INCLDIR)/headers.h $(INCLDIR)/s_elm.h
 mailmsg2.o:	$(INCLDIR)/headers.h $(INCLDIR)/s_elm.h
 mkhdrs.o:	$(INCLDIR)/headers.h $(INCLDIR)/s_elm.h
@@ -298,7 +302,9 @@
 newmbox.o:	$(INCLDIR)/headers.h $(INCLDIR)/s_elm.h
 options.o:	$(INCLDIR)/headers.h $(INCLDIR)/s_elm.h $(INCLDIR)/save_opts.h
 out_utils.o:	$(INCLDIR)/headers.h
+p_screen.o:	$(INCLDIR)/headers.h $(INCLDIR)/s_pgpkey.h
 pattern.o:	$(INCLDIR)/headers.h $(INCLDIR)/s_elm.h
+pgpkey.o:	$(INCLDIR)/headers.h $(INCLDIR)/s_pgpkey.h $(INCLDIR)/s_elm.h
 pmalloc.o:	$(INCLDIR)/defs.h $(INCLDIR)/s_elm.h
 quit.o:		$(INCLDIR)/headers.h $(INCLDIR)/s_elm.h
 read_rc.o:	$(INCLDIR)/headers.h $(INCLDIR)/s_elm.h $(INCLDIR)/save_opts.h
diff -u -r --new-file ../oldelm/src/args.c ./src/args.c
--- ../oldelm/src/args.c	Mon Apr 12 05:35:24 1993
+++ ./src/args.c	Wed Aug 30 00:54:19 1995
@@ -1,8 +1,8 @@
 
-static char rcsid[] = "@(#)$Id: args.c,v 5.9 1993/04/12 03:35:08 syd Exp $";
+static char rcsid[] = "@(#)$Id: args.c,v 5.9.3 1995/02/22 16:00:00 rm Exp $";
 
 /*******************************************************************************
- *  The Elm Mail System  -  $Revision: 5.9 $   $State: Exp $
+ *  The Elm Mail System  -  $Revision: 5.9.3 $   $State: Exp $
  *
  * 			Copyright (c) 1988-1992 USENET Community Trust
  * 			Copyright (c) 1986,1987 Dave Taylor
@@ -14,6 +14,20 @@
  *
  *******************************************************************************
  * $Log: args.c,v $
+ * Revision 5.9.3  1995/02/22  16:00:00  rm
+ * Renamed environment variable to ELMPGP for consistency reasons
+ * From: rmuchsel@iiic.ethz.ch
+ *
+ * Revision 5.9.2  1995/02/20  23:00:00  rm
+ * Moved storage of pgp_enabled variable from defs.h to this file
+ * PGP support defaults to "yes" if the "PGPELM" environment variable is set
+ * Added "PGP supported" to the compile options output
+ * From: rmuchsel@iiic.ethz.ch
+ *
+ * Revision 5.9.1  1994/01/08  00:07:18  Mic
+ * Adds -P option to enable the extra functions associated with PGP
+ * From: egd017@cent1.lancs.ac.uk
+ *
  * Revision 5.9  1993/04/12  03:35:08  syd
  * No tite for elm -z
  * From: Syd
@@ -79,8 +93,11 @@
 	to_whom[0] = '\0';
 	batch_subject[0] = '\0';
 	included_file[0] = '\0';
+	pgp_enabled = getenv("ELMPGP") != NULL; /* default PGP handling   */
+        if (getenv("PGPPASS") != NULL)
+          strcpy(passphrase, getenv("PGPPASS"));
 
-        while ((c = getopt(argc, argv, "?acd:f:hi:kKms:tVvz")) != EOF) {
+        while ((c = getopt(argc, argv, "?acd:f:hi:kKms:PtVvz")) != EOF) {
 	   switch (c) {
 	     case 'a' : arrow_cursor++;		break;
 	     case 'c' : check_only++; use_tite = 0;	break;
@@ -92,6 +109,7 @@
 	     case 'k' : hp_terminal++;	break;
 	     case 'K' : hp_terminal++; hp_softkeys++;	break;
 	     case 'm' : mini_menu = 0;	break;
+	     case 'P' : pgp_enabled = 1; break;    /* the flag for PGP enabling */
 	     case 's' : strcpy(batch_subject, optarg);	break;
 	     case 't' : use_tite = 0;	break;
              case 'V' : sendmail_verbose++;     break;
@@ -143,6 +161,12 @@
               "\n\rCan't specify an included file in batch mode!\n\r")));
         }
 
+	if (pgp_enabled && !access_keys())
+	  pgp_enabled = 0;
+       else
+	  if (getenv("PGPPASS") != NULL)
+           strcpy(passphrase, getenv("PGPPASS"));
+
 	return(req_mfile);
 
 
@@ -165,6 +189,7 @@
 	printf(catgets(elm_msg_cat, ElmSet, ElmArgsHelp2,
 	  "\t -K \t\tKeypad&softkeys - enable use of softkeys + \"-k\"\n\r\
 \t -m \t\tMenu - Turn off menu, using more of the screen\n\r\
+\t -P \t\tPGP encryption - enables the use of PGP functions\n\r\
 \t -sx\t\tSubject 'x' - for batch mailing\n\r\
 \t -t \t\tTiTe - don't use termcap/terminfo ti/te entries.\n\r\
 \t -V \t\tEnable sendmail voyeur mode.\n\r\
@@ -265,6 +290,8 @@
 #else /* ENABLE_CALENDAR */
 	printf("\tCalendar file feature disabled: not ENABLE_CALENDAR\n");
 #endif /* ENABLE_CALENDAR */
+
+        printf("\tPGP support enabled\n");
 
 	printf("\n\n");
 	exit(1);
diff -u -r --new-file ../oldelm/src/delete.c ./src/delete.c
--- ../oldelm/src/delete.c	Sat Oct  3 23:58:49 1992
+++ ./src/delete.c	Wed Aug 30 00:54:19 1995
@@ -45,6 +45,11 @@
 	    else
 	      setit(aliases[current-1]->status, DELETED);
 	  }
+	  /* CHRIS BEGIN */
+	  else if (inpgpkey) {
+	    setit(pgpkey[current-1]->status, DELETED);
+	  }
+	  /* CHRIS END */
 	  else
 	    setit(headers[current-1]->status, DELETED);
 	}
@@ -58,6 +63,14 @@
 	    else
 	      setit(aliases[current-1]->status, DELETED);
 	  }
+	  /* CHRIS BEGIN */
+	  else if (inpgpkey) {
+	    if (ison(pgpkey[current-1]->status, DELETED))
+	      clearit(pgpkey[current-1]->status, DELETED);
+	    else
+	      setit(pgpkey[current-1]->status, DELETED);
+	  }
+	  /* CHRIS END */
 	  else if (ison(headers[current-1]->status, DELETED))
 	    clearit(headers[current-1]->status, DELETED);
 	  else
@@ -75,6 +88,10 @@
 
 	if (inalias)
 	  clearit(aliases[current-1]->status, DELETED);
+	/* CHRIS BEGIN */
+	else if (inpgpkey)
+	  clearit(pgpkey[current-1]->status, DELETED);
+	/* CHRIS END */
 	else
 	  clearit(headers[current-1]->status, DELETED);
 
@@ -90,7 +107,8 @@
 	char tempbuf[3];
 
 	strcpy(tempbuf, show_status(ifmain(headers[msg]->status,
-	                                   aliases[msg]->status)));
+	                                   aliases[msg]->status,
+					   pgpkey[msg]->status)));
 
 	if (on_page(msg)) {
 	  MoveCursor(((compute_visible(msg+1)-1) % headers_per_page) + 4, 2);
@@ -114,15 +132,24 @@
 	int istagged;
 
 	if (ison(ifmain(headers[current-1]->status,
-	                aliases[current-1]->status), TAGGED)) {
+	                aliases[current-1]->status,
+			pgpkey[current-1]->status), TAGGED)) {
 	  if (inalias)
 	    clearit(aliases[current-1]->status, TAGGED);
+	  /* CHRIS BEGIN */
+	  else if (inpgpkey)
+	    clearit(pgpkey[current-1]->status, TAGGED);
+	  /* CHRIS END */
 	  else
 	    clearit(headers[current-1]->status, TAGGED);
 	  istagged = FALSE;
 	} else {
 	  if (inalias)
 	    setit(aliases[current-1]->status, TAGGED);
+	  /* CHRIS BEGIN */
+	  else if (inpgpkey)
+	    setit(pgpkey[current-1]->status, TAGGED);
+	  /* CHRIS END */
 	  else
 	    setit(headers[current-1]->status, TAGGED);
 	  istagged = TRUE;
@@ -143,12 +170,14 @@
 	  if (msg+1 == current && !arrow_cursor) {
 	    StartBold();
 	    Writechar( ison(ifmain(headers[msg]->status,
-	                           aliases[msg]->status), TAGGED)? '+' : ' ');
+	                           aliases[msg]->status,
+				   pgpkey[msg]->status), TAGGED)? '+' : ' ');
 	    EndBold();
 	  }
 	  else
 	    Writechar( ison(ifmain(headers[msg]->status,
-	                           aliases[msg]->status), TAGGED)? '+' : ' ');
+	                           aliases[msg]->status,
+				   pgpkey[msg]->status), TAGGED)? '+' : ' ');
 	}	
 }
 
@@ -165,15 +194,19 @@
 	    StartBold();
 	    PutLine2(((compute_visible(msg+1)-1) % headers_per_page) + 4,
 		   2, "%s%c", show_status(ifmain(headers[msg]->status,
-		                                 aliases[msg]->status)),
+		                                 aliases[msg]->status,
+						 pgpkey[msg]->status)),
 		   ison(ifmain(headers[msg]->status,
-		               aliases[msg]->status), TAGGED )? '+' : ' ');
+		               aliases[msg]->status,
+			       pgpkey[msg]->status), TAGGED )? '+' : ' ');
 	    EndBold();
 	  }
 	  else
 	    PutLine2(((compute_visible(msg+1)-1) % headers_per_page) + 4,
 		   2, "%s%c", show_status(ifmain(headers[msg]->status,
-		                                 aliases[msg]->status)),
+		                                 aliases[msg]->status,
+						 pgpkey[msg]->status)),
 		   ison(ifmain(headers[msg]->status,
-		               aliases[msg]->status), TAGGED )? '+' : ' ');
+		               aliases[msg]->status,
+			       pgpkey[msg]->status), TAGGED )? '+' : ' ');
 }
diff -u -r --new-file ../oldelm/src/elm.c ./src/elm.c
--- ../oldelm/src/elm.c	Mon May 30 18:26:14 1994
+++ ./src/elm.c	Wed Aug 30 20:17:38 1995
@@ -1,8 +1,8 @@
 
-static char rcsid[] = "@(#)$Id: elm.c,v 5.21 1994/05/30 16:26:03 syd Exp $";
+static char rcsid[] = "@(#)$Id: elm.c,v 5.21.4 1995/02/25 21:49:45 rm Exp $";
 
 /*******************************************************************************
- *  The Elm Mail System  -  $Revision: 5.21 $   $State: Exp $
+ *  The Elm Mail System  -  $Revision: 5.21.4 $   $State: Exp $
  *
  * This file and all associated files and documentation:
  *			Copyright (c) 1988-1992 USENET Community Trust
@@ -15,6 +15,26 @@
  *
  *******************************************************************************
  * $Log: elm.c,v $
+ * Revision 5.21.4  1995/02/25  21:49:45  rm
+ * Fixed send mode pass phrase checking to be enabled only if pgp support
+ * is enabled
+ * From: Robert Muchsel <rmuchsel@iiic.ethz.ch>
+ * 
+ * Revision 5.21.3  1995/02/22  16:00:00  rm
+ * Fixed PGP batch and send-only support, streamlined PGP menu key checking
+ * From: rmuchsel@iiic.ethz.ch
+ *
+ * Revision 5.21.2  1995/02/20  23:00:00  rm
+ * Cleaned up PGP pipe support, renamed PGP specific keys to remove conflicts
+ * with the standard ELM keys: '\\' to pipe through PGP, 'P' to print through
+ * PGP, 'M' to mail a key and '&' to disable/enable PGP support
+ * From: rmuchsel@iiic.ethz.ch
+ *
+ * Revision 5.21.1  1994/01/08  00:09:11  Mic
+ * Adds extra commands to main menu, 'P' to pipe the message though pgp
+ * before printing, and '\' to pipe through PGP before doing normal pipe
+ * From: egd017@cent1.lancs.ac.uk
+ *
  * Revision 5.21  1994/05/30  16:26:03  syd
  * Add protection to fflush on mailfile
  * From: Syd
@@ -158,6 +178,10 @@
 	long num;		/** another variable for fun..               **/
 	extern int errno;
 
+	char fname[SLEN]; /*pgp*/
+	char command[VERY_LONG_STRING];/*pgp*/
+
+
 #ifdef I_LOCALE
 	setlocale(LC_ALL, "");
 #endif
@@ -175,6 +199,8 @@
 	     sprintf(address, catgets(elm_msg_cat, ElmSet, ElmSendOnlyMode,
 	       "Send only mode [ELM %s]"), version_buff);
 	     Centerline(1, address);
+	     if (pgp_enabled)
+	       setpasswd();
 	   }
 	   (void) send_msg(to_whom, "", batch_subject, TRUE,
 	     (batch_only ? NO : allow_forms), FALSE); 
@@ -306,14 +332,18 @@
 			   nucurr = get_page(current);
 			   break;
 
-	    case '|'    :  Writechar('|'); 
+	    case '\\'	:  if (!pgp_enabled)
+			   	break;
+			   /* else fall through */
+
+	    case '|'    :  Writechar(ch); 
 			   if (message_count < 1) {
 			     error(catgets(elm_msg_cat, ElmSet, ElmNoMailToPipe,
 			       "No mail to pipe!"));
 			     fflush(stdin);
 			   } else {
 	    		     softkeys_off();
-                             redraw += do_pipe();		
+			     redraw += do_pipe(ch != '|');
 			     softkeys_on();
 			   }
 			   break;
@@ -464,6 +494,12 @@
 			       "No mail to read!"));
 			   break;
 
+	    case 'y'    :  if (!pgp_enabled)
+			       break;
+			    pgpkey_management();
+			    redraw++;
+			    break;
+
 	    case 'm'    :  PutLine0(LINES-3, strlen(Prompt),
 			     catgets(elm_msg_cat, ElmSet, ElmMail,
 			     "Mail"));
@@ -520,6 +556,10 @@
 			   redraw++;	/* always fix da screen... */
 			   break;
 
+	    case 'P'	:  if (!pgp_enabled)
+			       break;
+			   /* else fall through */
+
 	    case 'p'    :  PutLine0(LINES-3, strlen(Prompt),
 			     catgets(elm_msg_cat, ElmSet, ElmPrintMail,
 			     "Print mail"));
@@ -528,7 +568,7 @@
 			     error(catgets(elm_msg_cat, ElmSet, ElmNoMailToPrint,
 			       "No mail to print!"));
 			     fflush(stdin);
-			   } else if (print_msg(TRUE) != 0)
+			   } else if (print_msg(TRUE,(ch == 'P')) != 0)
 			     redraw++;
 			   break;
 
@@ -581,6 +621,9 @@
 			   softkeys_on();
 			   break;
 
+	    case 'S'	: if (!pgp_enabled)
+			    break;
+
 	    case '>'    : /** backwards compatibility **/
 
 	    case 'C'	:
@@ -605,7 +648,7 @@
 			     PutLine0(LINES-3,COLUMNS-40,
 			        catgets(elm_msg_cat, ElmSet, ElmUseForHelp,
 				"(Use '?' for help)"));
-			     if (save(&redraw, FALSE, (ch != 'C'))
+			     if (save(&redraw, FALSE, (ch != 'C'), (ch == 'S'))
 				 && resolve_mode && ch != 'C') {
 			       if((i=next_message(current-1, TRUE)) != -1) {
 				 current = i+1;
@@ -614,6 +657,7 @@
 			     }
 			   }
 			   ClearLine(LINES-2);		
+			   if (ch == 'S') redraw++;
 			   break;
 
 	    case 'X'    :  PutLine0(LINES-3, strlen(Prompt),
@@ -647,6 +691,11 @@
 			  }
 			  break;
 
+	    case '&' 	: pgp_enabled = !pgp_enabled;
+			  memset(passphrase,0,sizeof(passphrase));
+			  redraw++;
+			  break;
+
 	    /* None of the menu specific commands were chosen, therefore
 	     * it must be a "motion" command (or an error).               */
 	    default	: motion(ch);
@@ -847,6 +896,9 @@
 
 static char *no_mail = NULL;
 static char *no_aliases = NULL;
+/* CHRIS BEGIN */
+static char *no_keys = NULL;
+/* CHRIS END */
 
 motion(ch)
 char ch;
@@ -862,6 +914,8 @@
 		  "No mail in folder!");
 		no_aliases = catgets(elm_msg_cat, ElmSet, ElmNoAliases,
 		  "No aliases!");
+		no_keys = catgets(elm_msg_cat, ElmSet, ElmNoAliases /* CHRIS this ought to be changed!! */,
+		  "No keys!");
 	}
 
 	switch (ch) {
@@ -974,7 +1028,7 @@
 			     } else
 			       error1(catgets(elm_msg_cat, ElmSet, ElmNoMoreItemBelow,
 				 "No more %s below."), items);
-			   } else error(ifmain(no_mail, no_aliases));
+			   } else error(ifmain(no_mail, no_aliases, no_keys));
 			   break;
 
 next_undel_msg:
@@ -985,7 +1039,7 @@
 			     } else
 			       error1(catgets(elm_msg_cat, ElmSet, ElmNoItemUndeletedBelow,
 				 "No more undeleted %s below."), items);
-			   } else error(ifmain(no_mail, no_aliases));
+			   } else error(ifmain(no_mail, no_aliases, no_keys));
 			   break;
 
 	    case 'K'    :  if(current > 0) {
@@ -995,7 +1049,7 @@
 			     } else
 			       error1(catgets(elm_msg_cat, ElmSet, ElmNoMoreItemAbove,
 				 "No more %s above."), items);
-			   } else error(ifmain(no_mail, no_aliases));
+			   } else error(ifmain(no_mail, no_aliases, no_keys));
 			   break;
 
 prev_undel_msg:
@@ -1006,7 +1060,7 @@
 			     } else
 			       error1(catgets(elm_msg_cat, ElmSet, ElmNoMoreUndeletedAbove,
 				 "No more undeleted %s above."), items);
-			   } else error(ifmain(no_mail, no_aliases));
+			   } else error(ifmain(no_mail, no_aliases, no_keys));
 			   break;
 
 	    case 'l'    :  PutLine1(LINES-3, strlen(Prompt),
@@ -1124,7 +1178,8 @@
 				"Not that many %s."), items);
 			    else if(selected
 				&& isoff(ifmain(headers[i-1]->status,
-			                        aliases[i-1]->status), VISIBLE))
+			                        aliases[i-1]->status,
+						pgpkey[i-1]->status), VISIBLE))
 			      error1(catgets(elm_msg_cat, ElmSet, ElmNotInLimitedDisplay,
 				"%s not in limited display."), Item);
 			    else {
diff -u -r --new-file ../oldelm/src/file.c ./src/file.c
--- ../oldelm/src/file.c	Tue Aug  3 21:29:06 1993
+++ ./src/file.c	Wed Aug 30 20:17:39 1995
@@ -228,8 +228,8 @@
 
 
 int
-save(redraw, silently, delete)
-int *redraw, silently, delete;
+save(redraw, silently, delete, pass_through_pgp)
+int *redraw, silently, delete, pass_through_pgp;
 {
 	/** Save all tagged messages + current in a folder.  If no messages
 	    are tagged, save the current message instead!  This routine
@@ -410,7 +410,7 @@
 	for (i=0; i < message_count; i++) 	/* save each tagged msg */
 	  if (headers[i]->status & TAGGED) {
 	    save_message(i, filename, save_file, (tagged > 1), appending++, 
-			 silently, delete);
+			 silently, delete, pass_through_pgp);
 	    scount++;
 	  }
 
@@ -431,8 +431,8 @@
 }
 
 void
-save_message(number, filename, fd, pause, appending, silently, delete)
-int number, pause, appending, silently, delete;
+save_message(number, filename, fd, pause, appending, silently, delete, pass_through_pgp)
+int number, pause, appending, silently, delete, pass_through_pgp;
 char *filename;
 FILE *fd;
 {
@@ -460,7 +460,10 @@
 	 */
 	if(is_new = ison(headers[number]->status, NEW))
 	  clearit(headers[number]->status, NEW);
-	copy_message("", fd, CM_UPDATE_STATUS);
+	if (pass_through_pgp && pgp_enabled)
+	  pgp_copy_message("", fd, CM_UPDATE_STATUS);
+	else
+	  copy_message("", fd, CM_UPDATE_STATUS);
 	if(is_new)
 	  setit(headers[number]->status, NEW);
 	current = save_current;
diff -u -r --new-file ../oldelm/src/fileio.c ./src/fileio.c
--- ../oldelm/src/fileio.c	Tue Aug 30 17:08:09 1994
+++ ./src/fileio.c	Thu Aug 31 16:21:59 1995
@@ -1,8 +1,8 @@
 
-static char rcsid[] = "@(#)$Id: fileio.c,v 5.16 1994/08/30 15:08:09 syd Exp $";
+static char rcsid[] = "@(#)$Id: fileio.c,v 5.16.8 1995/08/05 15:00:00 caronni Exp $";
 
 /*******************************************************************************
- *  The Elm Mail System  -  $Revision: 5.16 $   $State: Exp $
+ *  The Elm Mail System  -  $Revision: 5.16.8 $   $State: Exp $
  *
  *			Copyright (c) 1988-1992 USENET Community Trust
  *			Copyright (c) 1986,1987 Dave Taylor
@@ -14,6 +14,55 @@
  *
  *******************************************************************************
  * $Log: fileio.c,v $
+ * Revision 5.16.8  1995/08/05  15:00:00  caronni
+ * Extended access_keys to hunt for config.txt and .pgprc too
+ * Added +textmode=off for the validation of the passphrase
+ * Fixed bug in setpasswd, no reset of pgp_enable if no access.
+ * From: caronni@tik.ethz.ch
+ *
+ * Revision 5.16.7  1995/06/04  14:00:12  caronni
+ * Added include for xxx-FILENO - and moved it to hdrs/
+ * From: caronni@tik.ethz.ch
+ *
+ * Revision 5.16.6  1995/02/25  21:51:33  rm
+ * copy_message unpatched original. pgp_copy_message uses filter_through_pgp_fd
+ * to copy message properly. Pass phrase is not queried if not in PGP mode.
+ * Changed explicit file handle numbers to xxx_FILENO.
+ * From: Robert Muchsel <rmuchsel@iiic.ethz.ch>
+ *
+ * Revision 5.16.5  1995/02/23  15:00:00  rm
+ * Wipe PGP screen output if wrong password was entered, fix pgp_copy_message
+ * to not display header information on reply
+ * From: rmuchsel@iiic.ethz.ch
+ *
+ * Revision 5.16.4  1995/02/22  16:00:00  rm
+ * Fixed PGP batch/send only support. setpasswd() now uses new getpasswd() 
+ * function.
+ * From: rmuchsel@iiic.ethz.ch
+ *
+ * Revision 5.16.3  1995/02/20  23:00:00  rm
+ * Added function "invoke_pgp" to call PGP without the use of the shell and
+ * with the ability to redirect input, output and stderr and a pipe to send
+ * the pass phrase to pgp. Altered PGP check to ignore MIME headers. Use
+ * tempnam instead of own temp file name generation. Added "Please wait..."
+ * message. Copy beginning of message properly (text before the PGP message
+ * will no longer be discarded). Cleaned up the access_keys() function to
+ * ignore the PGP_SLASH configuration option. Keep pass phrase in memory
+ * instead of environment. Disable PGP functionality after three bad 
+ * passwords. Disable PGP if empty password is entered. passwd_is_correct
+ * now works without temporary files.
+ * From: rmuchsel@iiic.ethz.ch
+ *
+ * Revision 5.16.2  1994/01/08  00:14:08  Mic
+ * Alter check in copy_message to check for MIME headers to determine if
+ * the mail is pgp encoded
+ * From: egd017@cent1.lancs.ac.uk
+ *
+ * Revision 5.16.1  1993/11/27  05.18.33  Mic
+ * Add pgp functions access_keys(), pgp_copy_message(),
+ * setpasswd() for pgp message handling
+ * From: egd017@cent1.lancs.ac.uk (Mic Shaw)
+ *
  * Revision 5.16  1994/08/30  15:08:09  syd
  * Add an fflush to detect over quota on file saves.
  * From: Larry Schwimmer <rosebud@cyclone.Stanford.EDU>
@@ -105,6 +154,7 @@
 #include "s_elm.h"
 #include <sys/stat.h>
 #include <errno.h>
+#include <stdarg.h>
 
 extern int errno;
 
@@ -417,6 +467,46 @@
     }
 }
 
+pgp_copy_message(prefix,
+		 dest_file,
+		 cm_options)
+char *prefix;
+FILE *dest_file;
+int cm_options;
+{
+    FILE *tmp_file;
+    char tmpname[SLEN], *t;
+    register struct header_rec *current_header = headers[current-1];
+
+    /* Copy the message to a temp file. If it is not a pgp message, then
+     * copy it over to the destination file. If it is a pgp message, decrypt
+     * the pgp part(s) and copy the rest (use filter_through_pgp_fd). 
+     */
+
+    if (!pgp_enabled) {
+	copy_message(prefix,dest_file,(cm_options & ~CM_PGP_SCAN_KEYS));
+	return;
+    }
+
+    strcpy(tmpname, t=tempnam(temp_dir, "snd."));
+    free(t); /* This was a leak!! /gec */
+    if ((tmp_file=fopen(tmpname,"w")) == 0) 
+	emergency_exit();
+    copy_message("",tmp_file,(cm_options & ~CM_PGP_SCAN_KEYS));
+    fclose(tmp_file);
+
+    if (current_header->status & (PGP_MESSAGE | PGP_SIGNATURE)) {
+	printf("\nDecrypting - Please wait..."); fflush(stdout);
+    }
+    if ((tmp_file = fopen(tmpname, "r")) == NULL)
+	emergency_exit();
+ 
+    (void) filter_through_pgp_fd(tmp_file, dest_file, prefix, cm_options);
+    fclose(tmp_file);
+
+    unlink(tmpname);    
+}
+
 static struct stat saved_buf;
 
 /*
@@ -561,3 +651,254 @@
 }
 
 #endif
+
+/**
+   This function checks whether the pgp public keys can be accessed.
+   Returns 1=YES, 0=NO
+**/
+
+int
+access_keys()
+{
+  extern char *pgpkey_guesspath();
+
+  char temp[VERY_LONG_STRING], *p;
+
+  if (access("pubring.pgp", 0) == 0 || access(".pgprc", 0) == 0 ||
+				       access("config.txt", 0) == 0)
+    return 1;
+
+  if (!(p=pgpkey_guesspath())) return 0;
+  strcpy(temp,p);
+  strcat(temp,"pubring.pgp");
+
+  if (access(temp,0) == 0) return 1;
+
+  p=strrchr(temp,'/'); if (!p) abort();
+  *(p+1)=0;
+  strcat(temp,".pgprc");
+  if (access(temp,0) == 0) return 1;
+
+  p=strrchr(temp,'/'); if (!p) abort();
+  *(p+1)=0;
+  strcat(temp,"config.txt");
+  return (access(temp,0) == 0);
+
+  /* should really parse config.txt for 'PUBRING' and extract for later
+   * usage in keymenu! /gec
+   */
+}
+
+/**
+   This routine calls pgp with a variable number of parameters.
+   in, out and err file descriptors can be redirected; a -1 file descriptor
+   means no redirection. A -2 output file descriptor pipes the output to
+   /dev/null.
+   Function uses a pipe to send the password and "in" data (if any).
+   Returns: PGP exit code
+**/
+
+int
+invoke_pgp_argv(in, out, err, arg) 
+int in;
+int out;
+int err;
+char **arg;
+{
+  int filedes[2], pid, i;
+  int status = 0;
+  char buf[VERY_LONG_STRING];
+
+  /* create input pipe */
+  if (pipe(filedes) < 0)
+    emergency_exit();
+
+  pid = fork();
+
+  if (pid < 0)  { /* fork error */
+    close(filedes[0]);
+    close(filedes[1]);
+    emergency_exit(); 
+  }
+ 
+  if (pid == 0) { /* child */
+    setgid(groupid);
+    setuid(userid);
+
+    /* redirection */
+    close(STDIN_FILENO); dup(filedes[0]); close(filedes[0]); close(filedes[1]);
+    if (out == -2) { out = open("/dev/null", O_WRONLY); }
+    if (in  != -1) close(in);
+    if (out != -1) { close(STDOUT_FILENO); dup(out); close(out); } 
+    if (err != -1) { close(STDERR_FILENO); dup(err); close(err); }
+
+    putenv("PGPPASSFD=0"); 
+    execv(PGP_PATH, arg);
+
+    emergency_exit();
+  }
+                  /* parent */
+  close(filedes[0]); 
+
+  /* write pass phrase to pipe */
+  if (write(filedes[1], passphrase, strlen(passphrase)) < 0) 
+    emergency_exit();
+
+  /* copy input to pipe */
+  if (in != -1) {
+    do {
+      i = read(in, buf, sizeof(buf));
+      if (i < 0) {
+        emergency_exit();
+      }
+      write(filedes[1], buf, i);
+    } while (i > 0);
+  }
+  close(filedes[1]);
+
+  /* wait for termination of child */
+  waitpid(pid, &status, 0);
+
+  return status;
+}
+
+/** Same as above, use variable number of arguments instead of vector **/
+
+int
+invoke_pgp(int in, int out, int err, char *command, ...)
+{
+  int i;
+  char *arg[30];
+  char *carg;
+  va_list ap;
+
+  /* set up argument vector */
+  arg[0] = "pgp"; arg[1] = command;
+  i = 2;
+  va_start(ap, command); 
+  carg = va_arg(ap, char*); 
+  while (carg && (i<29)) {
+    arg[i] = carg; i++; carg = va_arg(ap, char*);
+  }
+  arg[i] = NULL;
+  va_end(ap);
+
+  return invoke_pgp_argv(in, out, err, arg);
+}
+
+/** 
+   This function optionally prompts for and returns a password.
+   It works like the getpass() library call, except that it
+   is not limited to 8 characters and takes a pointer where to
+   store the data
+**/
+
+getpasswd(prompt, store)
+char *prompt;
+char *store;
+{
+  int i;
+  char ch;
+
+  if (prompt && *prompt) {
+    fputs(prompt, stdout);
+    fflush(stdout);
+  }
+
+  for (i=0 ; ; ) {
+    ch = getchar();
+    if ((i > SLEN)  && (ch != '\r') && (ch != '\n') && (ch != 127 )) {
+      putchar('\007');
+      continue;
+    }
+    if (((ch == '\b') || (ch == 127)) && i > 0) {
+      i--;
+      continue;
+    }
+    store[i] = ch;
+    if (ch == '\n' || ch == '\r') {
+      store[i] = 0;
+      break;
+    }
+    i++;
+  }
+}
+
+
+/**
+   This function asks for the PGP pass phrase if there is none.
+   If the user presses Enter, PGP support will be disabled.
+   Three wrong tries will also disable PGP support.
+   Returns: nothing
+**/
+
+setpasswd() 
+{
+  int i, pass = 0;
+
+  if (*passphrase)  /* return if pass phrase is set */
+    return;
+
+  if (!access_keys()) {
+    pgp_enabled = 0;
+    return;
+  }
+
+  if (!mail_only) {
+
+    do {
+      ClearLine(4);
+
+      if (pass > 0) 
+	for (i=5; i<13; i++) { ClearLine(i); }
+
+
+      if (pass > 2) {
+         Centerline(4,"PGP functions disabled!\n");
+        pgp_enabled = 0;
+        sleep(3);
+        return;
+      }
+
+      Centerline(4,"Enter PGP pass phrase: ");
+      getpasswd("",passphrase);
+
+      if (! *passphrase) { /* empty pass phrase */
+        pgp_enabled = 0;
+        memset(passphrase, 0, sizeof(passphrase));
+        return;
+      }
+      strcat(passphrase, "\n");
+      pass++;
+
+#ifndef DONT_CHECK_PASSWD
+      ClearLine(4);
+      Centerline(4,"Checking - Please wait...\n");
+#endif
+    } while (!passwd_is_correct());
+  }
+  else {
+    getpasswd("\nPGP pass phrase: ", passphrase);
+    if (! *passphrase) {
+      pgp_enabled = 0;
+      memset(passphrase, 0, sizeof(passphrase));
+    }
+  }
+}
+
+/**
+   This function checks the PGP pass phrase. The easiest way to do this is  
+   to sign an empty file (PGP input file descriptor returns EOF).
+   Returns: 1=OK, 0=NOT OK
+**/
+
+int
+passwd_is_correct()
+{
+#ifdef DONT_CHECK_PASSWD
+  return 1;
+#else
+  return (invoke_pgp(-1, -2, -1, "-sbf", "+batchmode", "+force", "+verbose=0",
+          "+textmode=off", NULL) == 0);
+#endif
+}
diff -u -r --new-file ../oldelm/src/help.c ./src/help.c
--- ../oldelm/src/help.c	Mon May 30 18:42:49 1994
+++ ./src/help.c	Wed Aug 30 20:17:40 1995
@@ -1,8 +1,8 @@
 
-static char rcsid[] = "@(#)$Id: help.c,v 5.6 1994/05/30 16:42:48 syd Exp $";
+static char rcsid[] = "@(#)$Id: help.c,v 5.6.1 1994/05/30 23:00:00 syd Exp $";
 
 /*******************************************************************************
- *  The Elm Mail System  -  $Revision: 5.6 $   $State: Exp $
+ *  The Elm Mail System  -  $Revision: 5.6.1 $   $State: Exp $
  *
  *			Copyright (c) 1988-1992 USENET Community Trust
  *			Copyright (c) 1986,1987 Dave Taylor
@@ -14,6 +14,10 @@
  *
  *******************************************************************************
  * $Log: help.c,v $
+ * Revision 5.6.1  1995/02/20  23:00:00  rm
+ * Added help for PGP specific keys ('M', '\\', 'P' and '&').
+ * From: rmuchsel@iiic.ethz.ch
+ *
  * Revision 5.6  1994/05/30  16:42:48  syd
  * Just a minor fix to an impossible character comparison.
  * From: Jukka Ukkonen <ukkonen@csc.fi>
@@ -57,6 +61,7 @@
 
 #include "headers.h"
 #include "s_elm.h"
+#include "s_pgpkey.h"
 
 help(pager_help)
 int pager_help;
@@ -128,10 +133,18 @@
    "| = Pipe the current message or tagged messages to the command specified.");
 		      break;
 
+	    case '\\': s = catgets(elm_msg_cat, ElmSet, ElmHelpPipePGP,
+   "\\ = Pipe the current/tagged messages through PGP to the command specified.");
+		      break;
+
 	    case '#': if(!pager_help) s = catgets(elm_msg_cat, ElmSet, ElmHelpDebugAll,
 	    "# = Debug - display all information known about current message.");
 		      break;
 
+	    case 'y': s = catgets(elm_msg_cat, PgpkeySet, PgpkeyDummy, /* THIS OUGHT TO BE CHANGED! */
+   "y = Go to the PGP key management sub-menu.");
+	              break;
+
 	    case '%': s = catgets(elm_msg_cat, ElmSet, ElmHelpDebugReturnAdd,
      "% = Debug - display the computed return address of the current message.");
 		      break;
@@ -181,6 +194,10 @@
 	       "^ = Toggle the Delete/Undelete status of the current message.");
 		      break;
 
+	    case '&': s = catgets(elm_msg_cat, ElmSet, ElmHelpDisablePGP,
+	       "& = Disable/Enable PGP support.");
+		      break;
+
 	    case 'a': if(!pager_help) s = catgets(elm_msg_cat, ElmSet, ElmHelpAliasSubmenu,
 	   "a = Enter the alias sub-menu section.  Create and display aliases.");
 		      break;
@@ -271,6 +288,10 @@
 		      "p = Print the current message or the tagged messages.");
 	              break;
 
+	    case 'P': s = catgets(elm_msg_cat, ElmSet, ElmHelpPrintPGP,
+"P = Print the current message or the tagged messages through the PGP filter.");
+		      break;
+
 	    case 'q': if(pager_help)
 			s = catgets(elm_msg_cat, ElmSet, ElmHelpQuitPager,
 			  "q = Quit the pager and return to the index.");
@@ -284,6 +305,10 @@
 
 	    case 's': s = catgets(elm_msg_cat, ElmSet, ElmHelpSaveMessage,
                "s = Save current message or tagged messages to specified file.");
+		      break;
+
+	    case 'S': s = catgets(elm_msg_cat, ElmSet, ElmHelpSaveMessage,
+	       "S = PGP decrypt and save current or tagged messages to specified file.");
 		      break;
 
 	    case 't': s = catgets(elm_msg_cat, ElmSet, ElmHelpTagMessage,
diff -u -r --new-file ../oldelm/src/in_utils.c ./src/in_utils.c
--- ../oldelm/src/in_utils.c	Thu Sep  1 21:42:41 1994
+++ ./src/in_utils.c	Wed Aug 30 00:54:22 1995
@@ -1,8 +1,8 @@
 
-static char rcsid[] = "@(#)$Id: in_utils.c,v 5.16 1994/09/01 19:42:39 syd Exp $";
+static char rcsid[] = "@(#)$Id: in_utils.c,v 5.16.1 1995/08/03 13:39:04 caronni Exp caronni $";
 
 /*******************************************************************************
- *  The Elm Mail System  -  $Revision: 5.16 $   $State: Exp $
+ *  The Elm Mail System  -  $Revision: 5.16.1 $   $State: Exp $
  *
  *			Copyright (c) 1988-1992 USENET Community Trust
  *			Copyright (c) 1986,1987 Dave Taylor
@@ -14,6 +14,11 @@
  *
  *******************************************************************************
  * $Log: in_utils.c,v $
+ * Revision 5.16.1  1995/08/03  13:39:04  caronni
+ * Fixed buffersize-mismatch between read_number() and optionally_enter()
+ * which could otherwise crash elm, when too much is typed in.
+ * From: caronni@tik.ee.ethz.ch (Germano Caronni)
+ *
  * Revision 5.16  1994/09/01  19:42:39  syd
  * Moved #defines for SETJMP & LONGJMP from src/editmsg.c to hdrs/defs.h and
  * used them instead of (set|long)jmp directly. This makes the usage consistent
@@ -188,7 +193,7 @@
 {
 	/** Read a number, where 'ch' is the leading digit! **/
 	
-	char buff[NLEN];
+	char buff[SLEN];
 	int  num;
 
 	buff[0] = ch;
diff -u -r --new-file ../oldelm/src/init.c.orig ./src/init.c.orig
--- ../oldelm/src/init.c.orig	Thu Jan  1 01:00:00 1970
+++ ./src/init.c.orig	Wed Aug 30 21:27:25 1995
@@ -0,0 +1,598 @@
+
+static char rcsid[] = "@(#)$Id: init.c,v 5.20 1994/05/30 16:31:40 syd Exp $";
+
+/*******************************************************************************
+ *  The Elm Mail System  -  $Revision: 5.20 $   $State: Exp $
+ *
+ *			Copyright (c) 1988-1992 USENET Community Trust
+ *			Copyright (c) 1986,1987 Dave Taylor
+ *******************************************************************************
+ * Bug reports, patches, comments, suggestions should be sent to:
+ *
+ *	Syd Weinstein, Elm Coordinator
+ *	elm@DSI.COM			dsinc!elm
+ *
+ *******************************************************************************
+ * $Log: init.c,v $
+ * Revision 5.20  1994/05/30  16:31:40  syd
+ * make getpwuid dependent on ANSI_C not posix flag
+ * From: Syd
+ *
+ * Revision 5.19  1993/09/27  01:51:38  syd
+ * Add elm_chown to consolidate for Xenix not allowing -1
+ * From: Syd
+ *
+ * Revision 5.18  1993/08/23  03:26:24  syd
+ * Try setting group id separate from user id in chown to
+ * allow restricted systems to change group id of file
+ * From: Syd
+ *
+ * Revision 5.17  1993/08/03  19:28:39  syd
+ * Elm tries to replace the system toupper() and tolower() on current
+ * BSD systems, which is unnecessary.  Even worse, the replacements
+ * collide during linking with routines in isctype.o.  This patch adds
+ * a Configure test to determine whether replacements are really needed
+ * (BROKE_CTYPE definition).  The <ctype.h> header file is now included
+ * globally through hdrs/defs.h and the BROKE_CTYPE patchup is handled
+ * there.  Inclusion of <ctype.h> was removed from *all* the individual
+ * files, and the toupper() and tolower() routines in lib/opt_utils.c
+ * were dropped.
+ * From: chip@chinacat.unicom.com (Chip Rosenthal)
+ *
+ * Revision 5.16  1993/04/12  03:30:23  syd
+ * On AIX, __STDC__ is not defined but it does use unistd.h, etc.  In
+ * hdrs/def.h, ANS_C already gets defined if __STDC__ or _AIX.  But this
+ * variable then needs to be used in src/init.c and hdrs/filter.h in place
+ * of the current test for __STDC__.
+ * From:	rstory@elegant.com (Robert Story)
+ *
+ * Revision 5.15  1993/04/12  03:07:57  syd
+ * The "window is too small..." message gets printed on the wrong screen. The
+ * message also needs \r\n at the end.
+ * From: Jan Djarv <Jan.Djarv@sa.erisoft.se>
+ *
+ * Revision 5.14  1993/04/12  01:52:31  syd
+ * Initialize safe_malloc() failure trap just to play it safe.  Although
+ * Elm doesn't currently use these routines, do this just in case somebody
+ * someday adds a call to a library routine that does use them.
+ * From: chip@chinacat.unicom.com (Chip Rosenthal)
+ *
+ * Revision 5.13  1993/02/03  19:08:03  syd
+ * fix extra declares
+ * From: syd
+ *
+ * Revision 5.12  1993/01/20  03:43:37  syd
+ * Some systems dont have SIGBUS, make it optional
+ *
+ * Revision 5.11  1993/01/20  03:02:19  syd
+ * Move string declarations to defs.h
+ * From: Syd
+ *
+ * Revision 5.10  1993/01/19  05:07:05  syd
+ * Trim erroreous extra log entry
+ * From: Syd
+ *
+ * Revision 5.9  1993/01/19  04:47:12  syd
+ * Significant changes to provide consistent Date and From_ header
+ * cracking.  Overhauled date utilities and moved into library.  Moved
+ * real_from() into library.  Modified frm, newmail, and readmsg utilities
+ * to use library version of real_from().  Moved get_word() from Elm
+ * source into library.  Added new library routines atonum() and strfcpy().
+ * Fixed trailing backslash bug in len_next().
+ * From: chip@chinacat.unicom.com (Chip Rosenthal)
+ *
+ * Revision 5.8  1992/12/07  02:41:21  syd
+ * This implements the use of SIGUSR1 and SIGUSR2 as discussed on the
+ * mailing list recently, and adds them to the documentation.
+ * From: scs@lokkur.dexter.mi.us (Steve Simmons)
+ *
+ * Revision 5.7  1992/11/26  01:26:04  syd
+ * only enter raw mode if not batch and not elm -c, to avoid
+ * screen swap and cursor control output
+ *
+ * Revision 5.6  1992/11/26  00:46:13  syd
+ * changes to first change screen back (Raw off) and then issue final
+ * error message.
+ * From: Syd
+ *
+ * Revision 5.5  1992/10/30  21:12:40  syd
+ * Make patchlevel a text string to allow local additions to the variable
+ * From: syd via a request from Dave Wolfe
+ *
+ * Revision 5.4  1992/10/27  01:34:12  syd
+ * It fixes the problem where ti/te was being used (by Raw()),
+ * AFTER the command line args had been read but BEFORE the rc files had.
+ * From: Graham Hudspith <gwh@inmos.co.uk>
+ *
+ * Revision 5.3  1992/10/25  02:01:58  syd
+ * Here are the patches to support POSIX sigaction().
+ * From: tom@osf.org
+ *
+ * Revision 5.2  1992/10/24  13:35:39  syd
+ * changes found by using codecenter on Elm 2.4.3
+ * From: Graham Hudspith <gwh@inmos.co.uk>
+ *
+ * Revision 5.1  1992/10/03  22:58:40  syd
+ * Initial checkin as of 2.4 Release at PL0
+ *
+ *
+ ******************************************************************************/
+
+/***** Initialize - read in all the defaults etc etc 
+*****/
+
+#include "headers.h"
+#include "patchlevel.h"
+#include "s_elm.h"
+
+#ifdef TERMIOS
+#  include <termios.h>
+   typedef struct termios term_buff;
+#else
+# ifdef TERMIO
+#  include <termio.h>
+#  define tcgetattr(fd,buf)	ioctl((fd),TCGETA,(buf))
+   typedef struct termio term_buff;
+# else
+#  include <sgtty.h>
+#  define tcgetattr(fd,buf)	ioctl((fd),TIOCGETP,(buf))
+   typedef struct sgttyb term_buff;
+# endif
+#endif
+
+#ifdef PWDINSYS
+#  include <sys/pwd.h>
+#else
+#  include <pwd.h>
+#endif
+
+#ifdef I_TIME
+#  include <time.h>
+#endif
+#ifdef I_SYSTIME
+#  include <sys/time.h>
+#endif
+
+#include <errno.h>
+
+extern int errno;		/* system error number on failure */
+extern char version_buff[];
+
+char *error_description();
+
+#ifndef ANSI_C /* items are in unistd.h which is included if __STDC__ */
+char *getlogin();
+unsigned short getgid(), getuid(); 
+struct passwd *getpwuid();
+#endif
+
+char *get_full_name();
+
+SIGHAND_TYPE
+#ifdef SIGTSTP
+	sig_user_stop(), sig_return_from_user_stop(),
+#endif
+#ifdef SIGWINCH
+	winch_signal(),
+#endif
+	quit_signal(), term_signal(), ill_signal(),
+	fpe_signal(), segv_signal(),
+#ifdef SIGBUS
+	bus_signal(),
+#endif
+	alarm_signal(), pipe_signal(), hup_signal(),
+	usr1_signal(), usr2_signal() ;
+
+extern void init_opts_menu();
+extern void malloc_failed_exit();
+
+initialize(requestedmfile)
+char *requestedmfile;	/* first mail file to open, empty if the default */
+{
+	/** initialize the whole ball of wax.
+	**/
+	struct passwd *pass, *getpwnam();
+	register int init_scr_return, hostlen, domlen; 
+
+#if defined(SIGVEC) & defined(SV_INTERRUPT)
+	struct sigvec alarm_vec;
+#endif /* defined(SIGVEC) & defined(SV_INTERRUPT) */
+	char     buffer[SLEN], *cp;
+
+	sprintf(version_buff, "%s PL%s", VERSION, PATCHLEVEL);
+	def_ans_yes = catgets(elm_msg_cat, ElmSet, ElmYes, "y");
+	def_ans_no = catgets(elm_msg_cat, ElmSet, ElmNo, "n");
+	nls_deleted = catgets(elm_msg_cat, ElmSet, ElmTitleDeleted, "[deleted]");
+	nls_form = catgets(elm_msg_cat, ElmSet, ElmTitleForm, "Form");
+	nls_message = catgets(elm_msg_cat, ElmSet, ElmTitleMessage, "Message");
+	nls_to = catgets(elm_msg_cat, ElmSet, ElmTitleTo, "To");
+	nls_from = catgets(elm_msg_cat, ElmSet, ElmTitleFrom, "From");
+	nls_page = catgets(elm_msg_cat, ElmSet, ElmTitlePage, "  Page %d");
+	change_word = catgets(elm_msg_cat, ElmSet, ElmChange, "change");
+	save_word = catgets(elm_msg_cat, ElmSet, ElmSave, "save");
+	copy_word = catgets(elm_msg_cat, ElmSet, ElmCopy, "copy");
+	cap_save_word = catgets(elm_msg_cat, ElmSet, ElmCapSave, "Save");
+	cap_copy_word = catgets(elm_msg_cat, ElmSet, ElmCapCopy, "Copy");
+	saved_word = catgets(elm_msg_cat, ElmSet, ElmSaved, "saved");
+	copied_word = catgets(elm_msg_cat, ElmSet, ElmCopied, "copied");
+	strcpy(item, catgets(elm_msg_cat, ElmSet, Elmitem, "message"));
+	strcpy(items, catgets(elm_msg_cat, ElmSet, Elmitems, "messages"));
+	strcpy(Item, catgets(elm_msg_cat, ElmSet, ElmItem, "Message"));
+	strcpy(Items, catgets(elm_msg_cat, ElmSet, ElmItems, "Messages"));
+	strcpy(Prompt, catgets(elm_msg_cat, ElmSet, ElmPrompt, "Command: "));
+
+	/*
+	 * Install the error trap to take if xmalloc() or friends fail.
+	 */
+	safe_malloc_fail_handler = malloc_failed_exit;
+
+	init_opts_menu();
+	init_scr_return = InitScreen();
+
+	/* save original user and group ids */
+	userid  = getuid();
+	groupid = getgid();	
+#ifdef SAVE_GROUP_MAILBOX_ID
+	mailgroupid = getegid();
+	setgid(groupid);
+#endif
+
+	/* make all newly created files private */
+	original_umask = umask(077);
+
+	/* Get username (logname), home (login directory), and full_username
+	 * (part of GCOS) field from the password entry for this user id.
+	 * Full_username will get overridden by fullname in elmrc, if defined.
+	 *
+	 * For those sites that have various user names with the same user
+	 * ID, use the passwd entry corresponding to the user name as long 
+	 * as it matches the user ID.  Otherwise fall back on the entry 
+	 * associated with the user ID alone.
+	 */
+
+	if((cp = getenv("LOGNAME")) == NULL)
+		cp = getenv("USER");
+	if(cp != NULL && (pass = getpwnam(cp)) != NULL &&
+	    pass->pw_uid == userid) {
+	  ;  /* Null body */
+	} else if((pass = getpwuid(userid)) == NULL) {
+	  error(catgets(elm_msg_cat, ElmSet, ElmYouHaveNoPasswordEntry,
+		"You have no password entry!\r\n"));
+	  exit(1);
+	}
+	strcpy(username, pass->pw_name);
+	strcpy(home, pass->pw_dir);
+
+	if((cp = get_full_name(username)) != NULL)
+	  strcpy(full_username, cp);
+	else
+	  strcpy(full_username, username);	/* fall back on logname */
+
+#ifdef DEBUG
+	if (debug) {		/* setup for dprint() statements! */
+	  char newfname[SLEN], filename[SLEN];
+
+	  sprintf(filename, "%s/%s", home, DEBUGFILE);
+	  if (access(filename, ACCESS_EXISTS) == 0) {	/* already one! */
+	    sprintf(newfname,"%s/%s", home, OLDEBUG);
+	    (void) rename(filename, newfname);
+	  }
+
+	  /* Note what we just did up there: we always save the old
+	     version of the debug file as OLDEBUG, so users can mail
+	     copies of bug files without trashing 'em by starting up
+	     the mailer.  Dumb, subtle, but easy enough to do!
+ 	  */
+
+	  if ((debugfile = fopen(filename, "w")) == NULL) {
+	    debug = 0;	/* otherwise 'leave' will try to log! */
+	    leave(fprintf(stderr, catgets(elm_msg_cat, ElmSet, ElmCouldNotOpenDebugFile,
+			"Could not open file %s for debug output!\n"),
+		  filename));
+	  }
+	  (void) elm_chown(filename, userid, groupid); /* file owned by user */
+
+	  fprintf(debugfile, 
+     "Debug output of the ELM program (at debug level %d).  Version %s\n\n",
+		  debug, version_buff);
+	}
+#endif
+
+	/*
+	 * If debug level is fairly low, ignore keyboard signals
+	 * until the screen is set up.
+	 */
+	if (debug < 5) {
+	  signal(SIGINT,  SIG_IGN);
+	  signal(SIGQUIT, SIG_IGN);
+	}
+
+	if(!check_only && !batch_only) {
+	  if (init_scr_return < 0) {
+	    if (init_scr_return == -1) {
+	      printf(catgets(elm_msg_cat, ElmSet, ElmNoTerm,
+"Sorry, but you must specify what type of terminal you're on if you want to\n\
+run the \"elm\" program. (You need your environment variable \"TERM\" set.)\n"));
+	      dprint(1,(debugfile,"No $TERM variable in environment!\n"));
+	    }
+	    else if (init_scr_return == -2) {
+	      printf(catgets(elm_msg_cat, ElmSet, ElmBadTerm,
+"You need a cursor-addressable terminal to run \"elm\" and I can't find any\n\
+kind of termcap entry for \"%s\" - check your \"TERM\" setting...\n"),
+		   getenv("TERM"));
+	      dprint(1,
+		(debugfile,"$TERM variable is an unknown terminal type!\n"));
+	    } else {
+	      printf(catgets(elm_msg_cat, ElmSet, ElmTermInitFailed,
+		"Failed trying to initialize your terminal entry: unknown return code %d\n"), init_scr_return);
+	      dprint(1, (debugfile, "Initscreen returned unknown code: %d\n",
+		  init_scr_return));
+	    }
+	    exit(1);	/* all the errors share this exit statement */
+	  }
+	}
+
+	if (debug < 5) {	/* otherwise let the system trap 'em! */
+	  signal(SIGQUIT, quit_signal);		/* Quit signal 	            */
+	  signal(SIGTERM, term_signal); 	/* Terminate signal         */
+	  signal(SIGILL,  ill_signal);		/* Illegal instruction      */
+	  signal(SIGFPE,  fpe_signal);		/* Floating point exception */
+#ifdef SIGBUS
+	  signal(SIGBUS,  bus_signal);		/* Bus error  		    */
+#endif
+	  signal(SIGSEGV, segv_signal);		/* Segmentation Violation   */
+	  signal(SIGHUP,  hup_signal);		/* HangUp (line dropped)    */
+	  signal(SIGUSR1, usr1_signal);		/* User request 1	    */
+	  signal(SIGUSR2, usr2_signal);		/* User request 2	    */
+	}
+	else {
+	  dprint(3,(debugfile,
+  "\n*** Elm-Internal Signal Handlers Disabled due to debug level %d ***\n\n",
+		    debug));
+	}
+#if !defined(POSIX_SIGNALS) & defined(SIGVEC) & defined(SV_INTERRUPT)
+	bzero((char *) &alarm_vec, sizeof(alarm_vec));
+	alarm_vec.sv_handler = alarm_signal;
+	alarm_vec.sv_flags = SV_INTERRUPT;
+	sigvec (SIGALRM, &alarm_vec, (struct sigvec *)0);	/* Process Timer Alarm	    */
+#else /* defined(SIGVEC) & defined(SV_INTERRUPT) */
+	signal(SIGALRM, alarm_signal);		/* Process Timer Alarm      */
+#endif /* defined(SIGVEC) & defined(SV_INTERRUPT) */
+	signal(SIGPIPE, pipe_signal);		/* Illegal Pipe Operation   */
+#ifdef SIGTSTP
+	signal(SIGTSTP, sig_user_stop);		/* Suspend signal from tty  */
+	signal(SIGCONT, sig_return_from_user_stop);	/* Continue Process */
+#endif
+#ifdef SIGWINCH
+	signal(SIGWINCH, winch_signal);		/* change screen size */
+#endif
+
+	get_term_chars();
+
+	/*
+	 * Get the host name as per configured behavior.
+	 */
+#ifdef HOSTCOMPILED
+	strfcpy(hostname, HOSTNAME, sizeof(hostname));
+#else
+	gethostname(hostname, sizeof(hostname));
+#endif
+
+	/*
+	 * now get the domain name, used to build the full name
+	 */
+	gethostdomain(hostdomain, sizeof(hostdomain));
+
+	/*
+	 * now the tough part:
+	 *	we need to make three variables out of this stuff:
+	 *	hostname = just the hostname, as in bangpaths,
+	 *		this is whatever the user gave us so far,
+	 *		we wont change this one
+	 *	hostdomain = this is the domain considered local to this
+	 *		machine, and should be what we got above.
+	 *	hostfullname = this is the full FQDN of this machine,
+	 *		and is a strange combination of the first two.
+	 *	if tail(hostname) == hostdomain
+	 *		then hostfullname = hostname
+	 *			ie: node.ld.domain.type, ld.domain.type -> node.ld.domain.type
+	 *	else if hostname == hostdomain + 1
+	 *		then hostfullname = hostname
+	 *			ie: domain.type, .domain.type -> domain.type
+	 *	
+	 *	else hostfullname = hostname + hostdomain
+	 *			ie: host, .domain.type -> host.domain.type
+	 * lost yet?
+	 */
+	hostlen = strlen(hostname);
+	domlen = strlen(hostdomain);
+	if (hostlen >= domlen) {
+	  if (istrcmp(&hostname[hostlen - domlen], hostdomain) == 0)
+	    strcpy(hostfullname, hostname);
+	  else {
+	    strcpy(hostfullname, hostname);
+	    strcat(hostfullname, hostdomain);
+	  }
+	} else {
+	  if (istrcmp(hostname, hostdomain + 1) == 0)
+	    strcpy(hostfullname, hostname);
+	  else {
+	    strcpy(hostfullname, hostname);
+	    strcat(hostfullname, hostdomain);
+	  }
+	}
+
+ /* gec 1.8.95  THIS IS A VERY LOCAL QUIRK
+  * used because the normal mapping just seems not to work out...
+  */
+ strcpy(hostfullname,"tik.ee.ethz.ch");
+
+
+	/* Determine the default mail file name.
+	 * 
+	 * First look for an environment variable MAIL, then
+	 * use then mailhome if it is not found
+	 */
+	if ((cp = getenv("MAIL")) == NULL)
+		sprintf(defaultfile, "%s%s", mailhome, username);
+	else
+		strcpy(defaultfile, cp);
+
+	/* Determine options that might be set in the .elm/elmrc */
+	read_rc_file();
+
+	/* Now that we've read the rc file we can enter RAW mode */
+	if (!batch_only && !check_only)
+	    Raw(ON);
+
+	/* Determine the mail file to read */
+	if (*requestedmfile == '\0')
+	  strcpy(requestedmfile, defaultfile);
+	else if(!expand_filename(requestedmfile, FALSE)) {
+	    Raw(OFF);
+	    exit(0);
+        }
+	if (check_size)
+	  if(check_mailfile_size(requestedmfile) != 0) {
+	      Raw(OFF);
+	      exit(0);
+	  }
+
+	/* check for permissions only if not send only mode file */
+	if (! mail_only) {
+	  if ((errno = can_access(requestedmfile, READ_ACCESS)) != 0) {
+	    if (strcmp(requestedmfile, defaultfile) != 0 || errno != ENOENT) {
+	      dprint(1, (debugfile,
+		    "Error: given file %s as folder - unreadable (%s)!\n", 
+		    requestedmfile, error_description(errno)));
+	      fprintf(stderr, catgets(elm_msg_cat, ElmSet, ElmCantOpenFolderRead,
+			"Can't open folder '%s' for reading!\n"),
+		    requestedmfile);
+	      Raw(OFF);
+	      exit(1);
+	    }
+	  }
+	}
+
+	/** check to see if the user has defined a LINES or COLUMNS
+	    value different to that in the termcap entry (for
+	    windowing systems, of course!) **/
+
+	ScreenSize(&LINES, &COLUMNS);
+
+	if ((cp = getenv("LINES")) != NULL && isdigit(*cp)) {
+	  sscanf(cp, "%d", &LINES);
+	  LINES -= 1;	/* kludge for HP Window system? ... */
+	}
+
+	if ((cp = getenv("COLUMNS")) != NULL && isdigit(*cp))
+	  sscanf(cp, "%d", &COLUMNS);
+
+	/** fix the shell if needed **/
+
+	if (shell[0] != '/') {
+	   sprintf(buffer, "/bin/%s", shell);
+	   strcpy(shell, buffer);
+	}
+
+	if (! mail_only && ! check_only) {
+
+	  /* get the cursor control keys... */
+
+	  cursor_control = FALSE;
+
+	  if ((cp = return_value_of("ku")) != NULL) {
+	    strcpy(up, cp);
+	    if ((cp = return_value_of("kd")) != NULL) {
+	      strcpy(down, cp);
+	      if ((cp = return_value_of("kl")) != NULL) {
+		strcpy(left, cp);
+		if ((cp = return_value_of("kr")) != NULL) {
+		  strcpy(right, cp);
+		  cursor_control = TRUE;
+		  transmit_functions(ON);
+		}
+	      }
+	    }
+	  }
+	  if (!arrow_cursor) 	/* try to use inverse bar instead */
+	    if (return_value_of("so") != NULL && return_value_of("se") != NULL)
+	        has_highlighting = TRUE;
+	}
+
+	/** clear the screen **/
+	if(!check_only && !batch_only)
+	  ClearScreen();
+
+	if (! mail_only && ! check_only) {
+	  if (mini_menu)
+	    headers_per_page = LINES - 13;
+	  else
+	    headers_per_page = LINES -  8;	/* 5 more headers! */
+
+	  if (headers_per_page <= 0) {
+	    Raw(OFF);
+	    error1(catgets(elm_msg_cat, ElmSet, ElmWindowSizeTooSmall,
+		 "The window is too small to run Elm.  It must have at least %d rows"),
+		 1 + LINES - headers_per_page);
+	    exit(1);
+	  }
+	  newmbox(requestedmfile, FALSE);	/* read in the folder! */
+	}
+
+#ifdef DEBUG
+	if (debug >= 2 && debug < 10) {
+	  fprintf(debugfile,
+"hostname = %-20s \tusername = %-20s \tfullname = %-20s\n",
+	         hostname, username, full_username);
+
+	  fprintf(debugfile,
+"home     = %-20s \teditor   = %-20s \trecvd_mail  = %-20s\n",
+		 home, editor, recvd_mail);
+
+	  fprintf(debugfile,
+"cur_folder   = %-20s \tfolders  = %-20s \tprintout = %-20s\n",
+		 cur_folder, folders, printout);
+	
+	  fprintf(debugfile,
+"sent_mail = %-20s \tprefix   = %-20s \tshell    = %-20s\n\n",
+		sent_mail, prefixchars, shell);
+	
+	  if (local_signature[0])
+	    fprintf(debugfile, "local_signature = \"%s\"\n",
+			local_signature);
+	  if (remote_signature[0])
+	    fprintf(debugfile, "remote_signature = \"%s\"\n",
+			remote_signature);
+	  if (local_signature[0] || remote_signature[0])
+	    fprintf(debugfile, "\n");
+	}
+#endif
+}
+
+get_term_chars()
+{
+	/** This routine sucks out the special terminal characters
+	    ERASE and KILL for use in the input routine.  The meaning 
+            of the characters are (dare I say it?) fairly obvious... **/
+
+	term_buff term_buffer;
+
+	if (tcgetattr(STANDARD_INPUT,&term_buffer) == -1) {
+	  dprint(1, (debugfile,
+		   "Error: %s encountered on ioctl call (get_term_chars)\n", 
+		   error_description(errno)));
+	  /* set to defaults for terminal driver */
+	  backspace = BACKSPACE;
+	  kill_line = ctrl('U');
+	}
+	else {
+#if defined(TERMIO) || defined(TERMIOS)
+	  backspace = term_buffer.c_cc[VERASE];
+	  kill_line = term_buffer.c_cc[VKILL];
+#else
+	  backspace = term_buffer.sg_erase;
+	  kill_line = term_buffer.sg_kill;
+#endif
+	}
+}
diff -u -r --new-file ../oldelm/src/limit.c ./src/limit.c
--- ../oldelm/src/limit.c	Mon May 16 01:10:11 1994
+++ ./src/limit.c	Wed Aug 30 00:54:22 1995
@@ -49,6 +49,7 @@
 #include "headers.h"
 #include "s_elm.h"
 #include "s_aliases.h"
+#include "s_pgpkey.h"
 
 #define TO		1
 #define FROM		2
@@ -138,6 +139,35 @@
 	    }
 	    break;
 	  }
+	  else if (inpgpkey) {
+	    if (equal(first, "?")) {
+	      if (last_selected)
+	        error(catgets(elm_msg_cat, PgpkeySet, PgpkeyDummy,
+	          "Enter: {\"userid\",\"keyid\"} OR {\"public\",\"secret\"} OR \"all\""));
+	      else
+	        error(catgets(elm_msg_cat, PgpkeySet, PgpkeyDummy,
+	          "Enter: {\"userid\",\"keyid\"} [pattern] OR {\"public\",\"secret\"}"));
+	      continue;
+	    }
+	    else if (equal(first, "all")) {
+	      all++;
+	      selected = 0;
+	    }
+	    else if (equal(first, "userid"))
+	      selected = limit_pgpkey_selection(BY_USERID, rest, selected);
+	    else if (equal(first, "keyid"))
+	      selected = limit_pgpkey_selection(BY_KEYID, rest, selected);
+	    else if (equal(first, "public"))
+	      selected = limit_pgpkey_selection(PUBLIC, rest, selected);
+	    else if (equal(first, "secret"))
+	      selected = limit_pgpkey_selection(SECRET, rest, selected);
+	    else {
+	      error1(catgets(elm_msg_cat, ElmSet, ElmLimitNotValidCriterion,
+		"\"%s\" not a valid criterion."), first);
+	      continue;
+	    }
+	    break;
+	  }
 	  else {
 	    if (equal(first, "?")) {
 	      if (last_selected)
@@ -183,6 +213,17 @@
 	      strcpy(msg, catgets(elm_msg_cat, AliasesSet,
 		AliasesLimitNoMessagesSelected, "No aliases selected."));
 	  }
+	  else if (inpgpkey) {
+	    if (selected > 1)
+	      sprintf(msg, catgets(elm_msg_cat, PgpkeySet, PgpkeyDummy,
+				   "%d keys selected."), selected);
+	    else if (selected == 1)
+	      strcpy(msg, catgets(elm_msg_cat, PgpkeySet, PgpkeyDummy,
+				  "1 key selected."));
+	    else
+	      strcpy(msg, catgets(elm_msg_cat, PgpkeySet, PgpkeyDummy,
+				  "No keys selected."));
+	  }
 	  else {
 	    if (selected > 1)
 	      sprintf(msg, catgets(elm_msg_cat, ElmSet,
@@ -201,7 +242,8 @@
 	if (last_selected || selected) {
 	  /* if current message won't be on new display, go to first message */
 	  if (selected && !(ifmain(headers[current-1]->status,
-	                           aliases[current-1]->status) & VISIBLE))
+	                           aliases[current-1]->status,
+				   pgpkey[current-1]->status) & VISIBLE))
 	    current = visible_to_index(1)+1;
 	  return(TRUE);
 	} else {
@@ -329,6 +371,75 @@
 }
 
 int
+limit_pgpkey_selection(based_on, pattern, additional_criteria)
+int based_on, additional_criteria;
+char *pattern;
+{
+	/** Given the type of criteria, and the pattern, mark all
+	    non-matching keys as ! VISIBLE.  If additional_criteria,
+	    don't mark as visible something that isn't currently!
+	**/
+
+	register int iindex, count = 0;
+
+	dprint(2, (debugfile, "\n\n\n**limit on %d - '%s' - (%s) **\n\n",
+		   based_on, pattern, additional_criteria?"add'tl":"base"));
+
+	if (based_on == BY_USERID) {
+	  for (iindex = 0; iindex < message_count; iindex++)
+	    if (! in_string(shift_lower(pgpkey[iindex]->user_id), pattern))
+	      clearit(pgpkey[iindex]->status, VISIBLE);
+	    else if (additional_criteria && 	
+		     !(pgpkey[iindex]->status & VISIBLE))
+	      clearit(pgpkey[iindex]->status, VISIBLE);	/* shut down! */
+	    else { /* mark it as readable */
+	      setit(pgpkey[iindex]->status, VISIBLE);
+	      count++;
+	      dprint(5, (debugfile,
+		     "  PGP-Key %d (%s, %s) marked as visible\n",
+			iindex, pgpkey[iindex]->user_id,
+			pgpkey[iindex]->key_id));
+	    }
+	}
+	else if (based_on == BY_KEYID) {
+	  for (iindex = 0; iindex < message_count; iindex++)
+	    if (! in_string(shift_lower(pgpkey[iindex]->key_id), pattern))
+	      clearit(pgpkey[iindex]->status, VISIBLE);
+	    else if (additional_criteria && 	
+		     !(pgpkey[iindex]->status & VISIBLE))
+	      clearit(pgpkey[iindex]->status, VISIBLE);	/* shut down! */
+	    else { /* mark it as readable */
+	      setit(pgpkey[iindex]->status, VISIBLE);
+	      count++;
+	      dprint(5, (debugfile, 
+			"  PGP-Key %d (%s, %s) marked as visible\n",
+			iindex, pgpkey[iindex]->user_id,
+			pgpkey[iindex]->key_id));
+	    }
+	}
+	else {
+	  for (iindex = 0; iindex < message_count; iindex++)
+	    if (! (based_on == pgpkey[iindex]->type))
+	      clearit(pgpkey[iindex]->status, VISIBLE);
+	    else if (additional_criteria && 	
+		     !(pgpkey[iindex]->status & VISIBLE))
+	      clearit(pgpkey[iindex]->status, VISIBLE);	/* shut down! */
+	    else { /* mark it as readable */
+	      setit(pgpkey[iindex]->status, VISIBLE);
+	      count++;
+	      dprint(5, (debugfile,
+			"  PGP-key %d (%s, %s) marked as visible\n",
+			iindex, pgpkey[iindex]->user_id,
+			pgpkey[iindex]->key_id));
+	    }
+	}
+
+	dprint(4, (debugfile, "\n** returning %d selected **\n\n\n", count));
+
+	return(count);
+}
+
+int
 next_message(iindex, skipdel)
 register int iindex, skipdel;
 {
@@ -345,7 +456,8 @@
 	remember_for_debug = iindex;
 
 	for(iindex++;iindex < message_count; iindex++) {
-	  stat = ifmain(headers[iindex]->status, aliases[iindex]->status);
+	  stat = ifmain(headers[iindex]->status, aliases[iindex]->status,
+			pgpkey[iindex]->status);
 	  if (((stat & VISIBLE) || (!selected))
 	    && (!(stat & DELETED) || (!skipdel))) {
 	      dprint(9, (debugfile, "[Next%s%s: given %d returning %d]\n", 
@@ -370,7 +482,8 @@
 
 	remember_for_debug = iindex;
 	for(iindex--; iindex >= 0; iindex--) {
-	  stat = ifmain(headers[iindex]->status, aliases[iindex]->status);
+	  stat = ifmain(headers[iindex]->status, aliases[iindex]->status,
+			pgpkey[iindex]->status);
 	  if (((stat & VISIBLE) || (!selected))
 	    && (!(stat & DELETED) || (!skipdel))) {
 	      dprint(9, (debugfile, "[Previous%s%s: given %d returning %d]\n", 
@@ -402,7 +515,8 @@
 
 	for (iindex = 0; iindex < message; iindex++)
 	   if (ifmain(headers[iindex]->status,
-	              aliases[iindex]->status) & VISIBLE)
+	              aliases[iindex]->status,
+		      pgpkey[iindex]->status) & VISIBLE)
 	     count++;
 
 	dprint(4, (debugfile,
@@ -425,7 +539,8 @@
 
 	for (iindex = 0; iindex < message_count; iindex++) {
 	   if (ifmain(headers[iindex]->status,
-	              aliases[iindex]->status) & VISIBLE)
+	              aliases[iindex]->status,
+		      pgpkey[iindex]->status) & VISIBLE)
 	     count++;
 	   if (count == message) {
 	     dprint(4, (debugfile,
diff -u -r --new-file ../oldelm/src/mailmsg1.c ./src/mailmsg1.c
--- ../oldelm/src/mailmsg1.c	Tue Jul 20 04:46:14 1993
+++ ./src/mailmsg1.c	Wed Aug 30 00:54:22 1995
@@ -1,8 +1,7 @@
-
-static char rcsid[] = "@(#)$Id: mailmsg1.c,v 5.7 1993/07/20 02:46:14 syd Exp $";
+static char rcsid[] = "@(#)$Id: mailmsg1.c,v 5.7.3 1995/02/22 16:00:00 rm Exp $";
 
 /*******************************************************************************
- *  The Elm Mail System  -  $Revision: 5.7 $   $State: Exp $
+ *  The Elm Mail System  -  $Revision: 5.7.3 $   $State: Exp $
  *
  *			Copyright (c) 1988-1992 USENET Community Trust
  *			Copyright (c) 1986,1987 Dave Taylor
@@ -14,6 +13,19 @@
  *
  *******************************************************************************
  * $Log: mailmsg1.c,v $
+ * Revision 5.7.3  1995/02/22  16:00:00  rm
+ * When sending public keys, there is now a default subject.
+ * From: rmuchsel@iiic.ethz.ch
+ *
+ * Revision 5.7.2  1995/02/20  23:00:00  rm
+ * When sending the whole key ring, use "*" as keyid.  
+ * From: rmuchsel@iiic.ethz.ch
+ *
+ * Revision 5.7.1  1994/01/08  00:16:37  Mic
+ * Handles mailing pgp-key and prompts for key to be sent.
+ * form_letter can now also have a value -1 (to indicate mailing a pgp key)
+ * From: egd017@cent1.lancs.ac.uk
+ *
  * Revision 5.7  1993/07/20  02:46:14  syd
  * Handle reply-to in batch mode.
  * From: decwrl!uunet.UU.NET!fin!chip (Chip Salzenberg)
@@ -59,7 +71,7 @@
 
 char subject[SLEN], in_reply_to[SLEN], expires[SLEN],
      action[SLEN], priority[SLEN], reply_to[SLEN], to[VERY_LONG_STRING], 
-     cc[VERY_LONG_STRING], expanded_to[VERY_LONG_STRING], 
+     cc[VERY_LONG_STRING], expanded_to[VERY_LONG_STRING], keyid[VERY_LONG_STRING],
      expanded_reply_to[LONG_STRING],
      expanded_cc[VERY_LONG_STRING], user_defined_header[SLEN],
      bcc[VERY_LONG_STRING], expanded_bcc[VERY_LONG_STRING],
@@ -195,6 +207,12 @@
 	return(1);		/* everything is okay... */
 }
 
+/* The following is getting a bit messy: 
+ * form_letter == -1 means we want to send a PGP key.
+ * It also indicates the subject is not the subject, but contains the PGP
+ * key IDs. We should really add the extra parameters to the function...
+ */
+
 int
 send_msg(given_to, given_cc, given_subject, edit_message, form_letter, replying)
 char *given_to, *given_cc, *given_subject;
@@ -222,7 +240,13 @@
 
 	/* Then: fill in default values for some fields */
 
-	strcpy(subject, given_subject);
+        if (form_letter == -1) { /* This is a ha-ha-ck */
+          strcpy(keyid, given_subject);
+          strcpy(subject, "PGP public key(s)");
+        }
+        else
+	  strcpy(subject, given_subject);
+
 	strcpy(to, given_to);
 	strcpy(cc, given_cc);
 
@@ -501,3 +525,4 @@
 
 	return(ret);
 }
+
diff -u -r --new-file ../oldelm/src/mailmsg2.c ./src/mailmsg2.c
--- ../oldelm/src/mailmsg2.c	Mon May 30 19:24:48 1994
+++ ./src/mailmsg2.c	Thu Aug 31 15:55:12 1995
@@ -1,8 +1,8 @@
 
-static char rcsid[] = "@(#)$Id: mailmsg2.c,v 5.39 1994/05/30 17:24:38 syd Exp $";
+static char rcsid[] = "@(#)$Id: mailmsg2.c,v 5.39.7 1995/08/05 15:30:00 caronni Exp $";
 
 /*******************************************************************************
- *  The Elm Mail System  -  $Revision: 5.39 $   $State: Exp $
+ *  The Elm Mail System  -  $Revision: 5.39.7 $   $State: Exp $
  *
  * 			Copyright (c) 1988-1992 USENET Community Trust
  * 			Copyright (c) 1986,1987 Dave Taylor
@@ -14,6 +14,44 @@
  *
  *******************************************************************************
  * $Log: mailmsg2.c,v $
+ * Revision 5.39.7  1995/08/05  15:30:00  caronni
+ * Sending pgp keyring now passes through send-menu too
+ * bcc's are included into the list of recipients for pgp-encrypted
+ * mails. This causes them to be detectable to normal recipients, if those
+ * check who may be able to decrypt the mail they receive.
+ * From: caronni@tik.ee.ethz.ch
+ *
+ * Revision 5.39.6  1995/06/14  14:02:42  caronni
+ * Added include for xxx_FILENO. - and moved it to hdrs/
+ * From: caronni@tik.ethz.ch
+ *
+ * Revision 5.39.5  1995/02/25  17:23:20  rm
+ * Use "+encrypttoself" instead of username. Case independent destination
+ * address lookup. Added pgpexclude configuration file support.
+ * From: Robert Muchsel <rmuchsel@iiic.ethz.ch>
+ *
+ * Revision 5.39.4  1995/02/22  16:00:00  rm
+ * Fixed PGP batch/send-only support.
+ * From: rmuchsel@iiic.ethz.ch
+ *
+ * Revision 5.39.3  1995/02/20  23:00:00  rm
+ * Replaced all PGP system_call()s with invoke_pgp(). Removed special p)gp
+ * menu. Added p)lain send menu entry. Sign all messages by default and
+ * encrypt if the public keys of all recipients are in the key ring, function
+ * pgp_key_check(). Removed stripbrackets() since there is already a strip_parens.
+ * Add MIME header only if sending a public key or an encrypted message so
+ * all people can read a signed message. Added status message "Encrypting..."
+ * From: rmuchsel@iiic.ethz.ch
+ *
+ * Revision 5.39.2  1994/01/08  00:19:35  Mic
+ * Can now mail a key file, and uses MIME headers in all pgp mailing
+ * From egd017@cent1.lancs.ac.uk
+ *
+ * Revision 5.39.1  1993/11/27  05.22.25  Mic 
+ * Add function pgpmenu for prompts for pgp encoding etc. . .
+ * alterd code on conventional message for the extention.
+ * From: egd017@cent1.lancs.ac.uk
+ *
  * Revision 5.39  1994/05/30  17:24:38  syd
  * use Elm routine instead of strcasecmp for portability
  * From: Syd
@@ -251,6 +289,7 @@
 char *format_long(), *strip_commas(), *tail_of_string(); 
 long ftell();
 
+int pgp_encoded;
 #ifdef SITE_HIDING 
  char *get_ctime_date();
 #endif
@@ -263,7 +302,7 @@
 	    cc[VERY_LONG_STRING], expanded_to[VERY_LONG_STRING], 
 	    expanded_reply_to[LONG_STRING],
 	    expanded_cc[VERY_LONG_STRING], user_defined_header[SLEN],
-	    bcc[VERY_LONG_STRING], expanded_bcc[VERY_LONG_STRING],
+	    bcc[VERY_LONG_STRING], expanded_bcc[VERY_LONG_STRING], keyid[LONG_STRING],
 	    precedence[SLEN], expires_days[SLEN];
 
 
@@ -331,6 +370,10 @@
 	    (useful for knowing whether a redraw is needed.
 	**/
 
+	/**
+            remember: if form = -1 then send our public keyring
+	**/
+	 
 	FILE *reply, *real_reply; /* second is post-input buffer */
 	char *whole_msg_file, *tempnam();
 	char filename[SLEN], fname[SLEN], copy_file[SLEN],
@@ -355,13 +398,46 @@
 
 	/** if possible, let's try to recall the last message? **/
 
-	if (! batch_only && copy_msg != FORM && user_level != 0)
+	if (! batch_only && copy_msg != FORM && user_level != 0 && (form != -1))
 	  retransmit = recall_last_msg(filename, copy_msg, &cancelled_msg, 
 		       &already_has_text);
 
 	/** if we're not retransmitting, create the file.. **/
 
 	if (! retransmit)
+	  if (form == -1) { /* send pgp key */
+ 		int keyhandle;
+		char delim[] = " ";
+		char *strp;
+
+		if ((keyhandle = creat(filename, 0600)) < 0) {
+		  error1(catgets(elm_msg_cat, ElmSet, ElmCouldNotCreateFile,
+		         "Could not create file %s."), filename);
+		  return(need_redraw);
+                }
+
+ 		strp = strtok(keyid, delim);
+		while (strp != NULL) {
+  		  if (*strp) {
+ 		    if (invoke_pgp(-1, keyhandle, -2, "-kxaf", "+verbose=0",
+		        "+batchmode", strp, keyring, NULL) != 0) { 
+                      error1(catgets(elm_msg_cat, ElmSet, ElmCouldNotCreateFile,
+                             "Could not create PGP public key file %s."), filename);
+	  	      return(need_redraw);
+		    }
+		  }
+		  strp = strtok(NULL, delim);
+		}
+		close(keyhandle);
+
+                if ((reply = fopen(filename, "a")) == NULL) {
+                  error1(catgets(elm_msg_cat, ElmSet, ElmCouldNotOpenFile,
+                         "Could not open file %s."), filename);
+                  return(need_redraw);
+                }
+
+		mail_only = 1;
+	  } else 
 	  if ((reply = fopen(filename,"w")) == NULL) {
 	    err = errno;
 	    dprint(1, (debugfile, 
@@ -378,7 +454,7 @@
 		filename, error_description(errno));
 	    return(need_redraw);
 	  }
-
+	if (form != -1)
 	(void) elm_chown(filename, userid, groupid);
 
 	/* copy the message from standard input */
@@ -388,7 +464,7 @@
 	}
 
 	/** if there is an included file, copy it into the temp file **/
-	if (*included_file) {
+	if (*included_file && (form != -1)) {
 	  FILE *input;
 	  if ((input = fopen(included_file,"r")) == NULL) {
 	    dprint(1, (debugfile, 
@@ -438,6 +514,9 @@
 	  precedence[0] = '\0';
 	}
 	else if (copy_msg && ! retransmit) {  /* if retransmit we have it! */
+	  if (form == -1) 
+	    already_has_text = TRUE;
+	  else {
 	  if (attribution[0]) {
 	    fprintf(reply, attribution, headers[current-1]->from);
 	    fputc('\n', reply);
@@ -446,13 +525,14 @@
 	    fputs("Forwarded message:\n", reply);
 	  }
 	  if (edit_message) {
-	    copy_message(prefixchars, reply,
+	    pgp_copy_message(prefixchars, reply,
 		( noheader ? CM_REMOVE_HEADER : 0 ) | CM_MMDF_HEAD | CM_DECODE);
 	    already_has_text = TRUE;	/* we just added it, right? */
 	  }
 	  else
-	    copy_message("", reply,
+	    pgp_copy_message("", reply,
 		( noheader ? CM_REMOVE_HEADER : 0 ) | CM_MMDF_HEAD);
+	  }
 	}
 
         /* append signature now if we are going to use an external editor */
@@ -485,13 +565,15 @@
 	} else *copy_file = '\0';	/* signals to not save a copy */
 
 	/* ask the user to confirm transmission of the message */
-	if (!batch_only) {
+	if (!batch_only /*&& (form != -1)gec*/) {
 	    ch = (edit_message? 'e' : '\0');
 	    if (verify_transmission(filename, &form, &need_redraw,
 		    already_has_text, copy_file, ch) != 0) {
 		cancelled_msg = (bytes(filename) > 0);
+		if (form == -1) mail_only = 0;
 		return need_redraw;
 	    }
+	    else if (form == -1) mail_only = 0;
 	    if (form == YES && format_form(filename) < 1) {
 		cancelled_msg = (bytes(filename) > 0);
 		return need_redraw;
@@ -570,7 +652,7 @@
 
 	if ((real_reply = 
 	   write_header_info(whole_msg_file, expanded_to,
-	     expanded_cc, expanded_bcc, form == YES, FALSE)) == NULL) {
+	     expanded_cc, expanded_bcc, form, FALSE)) == NULL) {
 
 	  /** IT FAILED!!  MEIN GOTT!  Use a dumb mailer instead! **/
 
@@ -799,6 +881,7 @@
     prev_form = *form_p + 1;	/* force build of prompt strings	*/
     bad_cmd = FALSE;		/* nothing to complain about yet	*/
 
+    pgp_encoded = 0;
     for (;;) {
 
 	/* build up prompt and menu strings */
@@ -826,9 +909,13 @@
 		break;
 	    default:
 		strcpy(prompt_menu, catgets(elm_msg_cat, ElmSet,
-		    ElmVfyMenuEditMsg, "e)dit message, "));
+		    ElmVfyMenuEditMsg, "e)dit msg, "));
 		break;
 	    }
+		if (pgp_enabled)
+		    strcat(prompt_menu, catgets(elm_msg_cat, ElmSet, ElmVfyMenuVfyCpy,
+			"h)eaders, c)opy, p)lain, si(g)n, "));
+		else
 	    strcat(prompt_menu, catgets(elm_msg_cat, ElmSet, ElmVfyMenuVfyCpy,
 		"h)eaders, c)opy, "));
 #ifdef ISPELL
@@ -854,7 +941,7 @@
 
 	/* if we don't have a cmd, display prompt and get response from user */
 	if (force_cmd != '\0') {
-	    cmd = tolower(force_cmd);
+	    cmd = force_cmd;
 	    force_cmd = '\0';
 	    did_prompt = FALSE;
 	} else {
@@ -871,18 +958,31 @@
 	    cmd = ReadCh();
 	    if (cmd == EOF)
 	      leave(0);
-	    cmd = tolower(cmd);
 	    did_prompt = TRUE;
 	}
 
 	/* handle command */
 	switch (cmd) {
 
+	case 'p': 
+	case 'g':
+	    if (!pgp_enabled) {
+		bad_cmd = TRUE;
+		break;
+	    }
+	    /* fall through */	
+
 	case '\n':
 	case '\r':
 	case 's':
 	    if (did_prompt)
 		Write_to_screen("Send", 0);
+
+	    if (pgp_enabled && (cmd == 'g')) {
+		if (pgp_key_check(filename,1)== -1) break; /*gec*/
+            } else if (pgp_enabled && (cmd != 'p')) {
+		if (pgp_key_check(filename,0)== -1) break; /*gec*/
+	    }
 	    return 0;
 	    /*NOTREACHED*/
 
@@ -982,6 +1082,16 @@
 	    break;
 #endif
 
+	case '&': /*gec*/
+	    ClearScreen();
+	    pgp_enabled = !pgp_enabled;
+	    memset(passphrase,0,sizeof(passphrase));
+	    *need_redraw_p = TRUE;
+	    prev_form=*form_p+1;
+	    if (pgp_enabled) 
+	      setpasswd();
+	    break;
+
 	default:
 	    bad_cmd = TRUE;
 	    break;
@@ -1184,7 +1294,7 @@
 	fprintf(filedesc, "X-Mailer: ELM [version %s]\n", version_buff);
 #endif /* !NO_XHEADER */
 
-	if (form)
+	if (form == YES)
 	  fprintf(filedesc, "Content-Type: mailform\n");
 #ifdef MIME
 	else if (msg_is_multipart) {
@@ -1196,8 +1306,13 @@
 	else {
 #ifdef	MIME
 	  fprintf(filedesc, "%s\n", MIME_HEADER);
-	  fprintf(filedesc, "%s text/plain; charset=%s\n",
-		  MIME_CONTENTTYPE, charset);
+
+	  if ((pgp_encoded) || (form == -1))
+              fprintf(filedesc, "%s %s\n",MIME_CONTENTTYPE, MIME_HEADER_PGP);
+          else
+	      fprintf(filedesc, "%s text/plain; charset=%s\n",
+		      MIME_CONTENTTYPE, charset);
+
 	  fprintf(filedesc, "Content-Transfer-Encoding: %s\n",
 		  (!strincmp ("us-ascii", charset)
 		   && strincmp ("7bit", text_encoding))
@@ -1444,4 +1559,286 @@
 return FALSE;
 
 }
+
+/**
+   This function checks if we have the public key of the recipient. If yes,
+   the message is signed and encrypted. If no, it is signed. The user can
+   request a "plain send" via the p)lain send menu command.
+   If any "CC:" addresses are specified, then we must check all the public
+   keys. If a key is missing, then we cannot encrypt the message. 
+**/
+
+int pgp_key_check(filename, clearsign)
+char *filename; 
+int clearsign;
+{
+  FILE *fp;
+  int filedes[2], pid, i;
+  int status = 0;
+  char destination[VERY_LONG_STRING];
+  char addresses[VERY_LONG_STRING];
+  char pgplinks[VERY_LONG_STRING];
+  char line[VERY_LONG_STRING];
+  char tmp[VERY_LONG_STRING];
+  char *strp, *strp2;
+  char delim[] = " ";
+  char *arg[255];
+  char ch, msgbuf[SLEN];
+  int prompt_line;
+ 
+  prompt_line = mail_only ? 4 : LINES-2;
+  strp=NULL;
+  if (!clearsign) {
+    /** Get all destination addresses and remove junk **/
+    strcpy(destination, expanded_to);
+    if (*expanded_cc) {
+      strcat(destination, " ");
+      strcat(destination, expanded_cc);
+    }
+    if (*expanded_bcc) {
+      strcat(destination, " ");
+      strcat(destination, expanded_bcc);
+    }
+    strcpy(addresses, strip_parens(strip_commas(destination)));
+
+    /** copy destination addresses and expand if necessary **/
+    *destination = 0;
+    strp = strtok(addresses, delim);
+    while (strp != NULL) {
+      if (strchr(strp, '@') != NULL) {
+	strcat(destination, strp);
+	strcat(destination, " ");
+      }
+      else {
+#ifdef MAIL_DOMAIN
+	sprintf(tmp, "%s@%s ", strp, MAIL_DOMAIN);
+#else
+	sprintf(tmp, "%s@%s ", strp, hostfullname); 
+#endif
+	strcat(destination, tmp);
+      }
+      strp = strtok(NULL, delim);
+    }
+    strp = destination; while (*strp) { *strp = tolower(*strp); strp++; }
+    strcpy(addresses, destination);
+
+    /* check whether destination address is manually excluded from 
+     * encryption in the .elm/pgpexclude file 
+     */
+    sprintf(tmp, "%s/%s", home, pgpexclude);
+
+    if ((fp = fopen(tmp, "r")) != NULL) {
+      while (fgets(line, VERY_LONG_STRING, fp) != NULL) {
+	strp = line; while (*strp) { *strp = tolower(*strp); strp++; }
+	strp--; while (*line && isspace(*strp)) { *strp = 0; strp--; }
+	strp = strstr(addresses, line);
+	if (strp != NULL) {
+	  strp += strlen(line);
+	  if (isspace(*strp) || (*strp == '>') || (*strp == 0)) {
+	    fclose(fp);
+	    goto dont_encrypt;  /** do not encrypt **/
+          }
+	}
+      }
+      fclose(fp);
+    }
+
+    *pgplinks = 0;
+    /* check whether destination address is manually linked to
+     * certain PGP keys in the .elm/pgplink file
+     */
+    sprintf(tmp, "%s/%s", home, pgplink);
+
+    if ((fp = fopen(tmp, "r")) != NULL) {
+      *line = 0; 
+      while (fgets(line, VERY_LONG_STRING, fp) != NULL) {
+        char *idp, *splitp, *tp;
+        idp = line;
+	while (isspace(*idp)) idp++;
+	splitp = idp;
+	while ((*splitp) && (!isspace(*splitp))) splitp++;
+        if (*splitp) {
+          *splitp = 0;
+          *splitp++;
+          tp = splitp;
+          tp += strlen(tp)-1;
+          while ((tp > splitp) && (isspace(*tp))) { *tp = 0; tp--; }
+        }
+	
+        strp = strstr(addresses, idp);
+        if (strp != NULL) {
+          strp += strlen(idp);
+          if (isspace(*strp) || (*strp == '>') || (*strp == 0)) {
+
+            /** Yes, remove address from destination string **/
+            strp2 = strstr(destination, idp);
+            while (strp2 && *strp2 && (*strp2 != ' ')) {
+              *strp2 = ' '; strp2++;
+            }
+	    /** and from the addresses string **/
+	    strp2 = strstr(addresses, idp);
+	    while (strp2 && *strp2 && (*strp2 != ' ')) {
+	      *strp2 = ' '; strp2++;
+	    }
+	    /** and add it to the pgplinks string **/
+	    strcat(pgplinks, " ");
+	    strcat(pgplinks, splitp);
+          }
+        }
+        *line = 0;
+      }
+      fclose(fp);
+    }
+
+
+    /** create output pipe **/
+    if (pipe(filedes) < 0)
+      emergency_exit();
+
+    pid = fork();
+
+    if (pid < 0)  { /** fork error **/
+      close(filedes[0]);
+      close(filedes[1]);
+      emergency_exit();
+    }
+
+    if (pid == 0) { /** child **/
+      setgid(groupid);
+      setuid(userid);
+
+      /** redirection **/
+      close(STDOUT_FILENO); dup(filedes[1]); close(filedes[1]); close(filedes[0]);
+      /** Call PGP **/
+      execl(PGP_PATH, "pgp", "+verbose=0", "+force", "-kv", keyring, NULL);
+
+      emergency_exit(); /** exec failed **/
+    }
+		    /** parent **/
+    close(filedes[1]);
+
+    /** create FILE from descriptor **/
+    if ((fp = fdopen (filedes[0], "r")) == NULL) 
+      emergency_exit();
+
+    /** read output **/
+    while (fgets(line, VERY_LONG_STRING - 1, fp) != NULL) {
+      /** Check for line starting with "pub " or an alias address **/
+      if ((strncmp(line, "pub ", 4) == 0) ||
+	  (strncmp(line, "                              ", 30) == 0)) {
+	strp = line; while (*strp) { *strp = tolower(*strp); strp++; }
+	/** one of the destination addresses? **/
+	strcpy(tmp, addresses); strp = strtok(tmp, delim); 
+	while (strp != NULL) {
+	  strp2 = strstr(line, strp);
+	  if (strp2 != NULL) {
+	    strp2 += strlen(strp);
+	    if (isspace(*strp2) || (*strp2 == '>') || (*strp2 == 0)) {
+
+	      /** Yes, remove address from destination string **/
+	      strp2 = strstr(destination, strp);
+	      while (strp2 && *strp2 && (*strp2 != ' ')) {
+		*strp2 = ' '; strp2++;
+	      }
+
+	    }
+	  }
+       
+	  strp = strtok(NULL, delim);
+	}
+	
+      }
+      
+    }
+    fclose(fp);
+
+    /** wait for termination of child **/
+    waitpid(pid, &status, 0);
+    if (status != 0) {
+      if (sleepmsg > 0) sleep((sleepmsg + 1) / 2);
+      ClearLine(prompt_line);
+      error(catgets(elm_msg_cat, ElmSet, ElmMailNotSend, "PGP lookup failed - Mail not sent."));
+      return (-1);
+    }
+
+    strp = destination;
+    while (*strp == ' ')
+      strp++;
+  } /*!clearsign*/
+
+  if ((strp&&*strp) && !clearsign) {
+    MCsprintf(msgbuf, catgets(elm_msg_cat, ElmSet, ElmMissingPGPKey,
+    "Can't encrypt, missing public key(s) - sign and send anyway? (%c/%c) "),
+						  *def_ans_yes, *def_ans_no);
+    MoveCursor(LINES,0);
+    CleartoEOLN();
+    ch = want_to(msgbuf, *def_ans_no, LINES, 0);
+    if (ch != *def_ans_yes) {     /* user says no! */
+      return(-1);
+    }
+  }
+
+  if ((strp && ! *strp) && (!clearsign)) {
+    /** 
+       Found public keys for all destination addresses, so sign 
+       and encrypt the message 
+    **/
+    if (!batch_only) {
+      PutLine0(LINES,0,catgets(elm_msg_cat, ElmSet, ElmSendingMail,
+               "Encrypting mail..."));
+      CleartoEOLN();
+    }
+
+    arg[0] = "pgp"; arg[1] = "-sweat"; arg[2] = "+verbose=0";
+    arg[3] = "+force"; arg[4] = "+batchmode"; arg[5]="+encrypttoself";
+    i = 6;
+    if (pubkeyring != NULL) {
+      arg[i] = pubkeyring; i++;
+    }
+    arg[i] = filename; i++;
+
+    strcat(addresses, pgplinks); /* add manual links */
+    strp = strtok(addresses, delim);
+    while ((strp != NULL) && (i< 254)) {
+      if (*strp) {
+        arg[i] = strp; i++; 
+      }
+      strp = strtok(NULL, delim);
+    }
+    arg[i] = NULL;
+    if (invoke_pgp_argv(-1, -2, -1, arg) == 0) {
+      strcat(filename,".asc");
+      pgp_encoded++;
+      return 0;
+    } else {
+      if (sleepmsg > 0)
+        sleep((sleepmsg + 1) / 2);
+      ClearLine(prompt_line);
+      error(catgets(elm_msg_cat, ElmSet, ElmMailNotSend, "Encryption failed."));
+      return(-1);
+    }
+  }
+
+dont_encrypt:
+  /** Not all public keys found, so just sign the message **/
+  if (!batch_only) {
+    PutLine0(LINES,0,catgets(elm_msg_cat, ElmSet, ElmSendingMail,
+             "Signing mail..."));
+    CleartoEOLN();
+  }
+
+  if (invoke_pgp(-1, -2, -1, "-staw", "+verbose=0", "+clearsig=on", "+force",
+      "+batchmode", filename, NULL) == 0) {
+    strcat(filename,".asc");
+    return 0;
+  } else {
+    if (sleepmsg > 0)
+      sleep((sleepmsg + 1) / 2);
+    ClearLine(prompt_line);
+    error(catgets(elm_msg_cat, ElmSet, ElmMailNotSend, "Signing failed."));
+    return(-1);
+  }
+
+  return 0;
+}  
 
diff -u -r --new-file ../oldelm/src/mailmsg2.c.orig ./src/mailmsg2.c.orig
--- ../oldelm/src/mailmsg2.c.orig	Thu Jan  1 01:00:00 1970
+++ ./src/mailmsg2.c.orig	Wed Aug 30 20:17:41 1995
@@ -0,0 +1,1840 @@
+
+static char rcsid[] = "@(#)$Id: mailmsg2.c,v 5.39.7 1995/08/05 15:30:00 caronni Exp $";
+
+/*******************************************************************************
+ *  The Elm Mail System  -  $Revision: 5.39.7 $   $State: Exp $
+ *
+ * 			Copyright (c) 1988-1992 USENET Community Trust
+ * 			Copyright (c) 1986,1987 Dave Taylor
+ *******************************************************************************
+ * Bug reports, patches, comments, suggestions should be sent to:
+ *
+ *	Syd Weinstein, Elm Coordinator
+ *	elm@DSI.COM			dsinc!elm
+ *
+ *******************************************************************************
+ * $Log: mailmsg2.c,v $
+ * Revision 5.39.7  1995/08/05  15:30:00  caronni
+ * Sending pgp keyring now passes through send-menu too
+ * bcc's are included into the list of recipients for pgp-encrypted
+ * mails. This causes them to be detectable to normal recipients, if those
+ * check who may be able to decrypt the mail they receive.
+ * From: caronni@tik.ee.ethz.ch
+ *
+ * Revision 5.39.6  1995/06/14  14:02:42  caronni
+ * Added include for xxx_FILENO. - and moved it to hdrs/
+ * From: caronni@tik.ethz.ch
+ *
+ * Revision 5.39.5  1995/02/25  17:23:20  rm
+ * Use "+encrypttoself" instead of username. Case independent destination
+ * address lookup. Added pgpexclude configuration file support.
+ * From: Robert Muchsel <rmuchsel@iiic.ethz.ch>
+ *
+ * Revision 5.39.4  1995/02/22  16:00:00  rm
+ * Fixed PGP batch/send-only support.
+ * From: rmuchsel@iiic.ethz.ch
+ *
+ * Revision 5.39.3  1995/02/20  23:00:00  rm
+ * Replaced all PGP system_call()s with invoke_pgp(). Removed special p)gp
+ * menu. Added p)lain send menu entry. Sign all messages by default and
+ * encrypt if the public keys of all recipients are in the key ring, function
+ * pgp_key_check(). Removed stripbrackets() since there is already a strip_parens.
+ * Add MIME header only if sending a public key or an encrypted message so
+ * all people can read a signed message. Added status message "Encrypting..."
+ * From: rmuchsel@iiic.ethz.ch
+ *
+ * Revision 5.39.2  1994/01/08  00:19:35  Mic
+ * Can now mail a key file, and uses MIME headers in all pgp mailing
+ * From egd017@cent1.lancs.ac.uk
+ *
+ * Revision 5.39.1  1993/11/27  05.22.25  Mic 
+ * Add function pgpmenu for prompts for pgp encoding etc. . .
+ * alterd code on conventional message for the extention.
+ * From: egd017@cent1.lancs.ac.uk
+ *
+ * Revision 5.39  1994/05/30  17:24:38  syd
+ * use Elm routine instead of strcasecmp for portability
+ * From: Syd
+ *
+ * Revision 5.38  1994/05/30  16:43:14  syd
+ * I found a few months old patch I have not sent you before (I guess).
+ * It avoids unknowingly confusing some too rigidly and simple mindedly
+ * coded mailers with weird settings like
+ *
+ * 	charset=us-ascii and textencoding=8bit
+ *
+ * This patch will force 7bit encoding with charset=us-ascii.
+ * E.g. older versions of pine will dump core on 8bit & us-ascii.
+ * From: Jukka Ukkonen <ukkonen@csc.fi>
+ *
+ * Revision 5.37  1994/05/15  23:10:08  syd
+ * Below are the changes required to compile/link elm 2.4 pl23 under
+ * QNX 4.2 with the Watcom 9.5 compiler (very picky).
+ * From: "Brian Campbell" <brianc@quantum>
+ *
+ * Revision 5.36  1994/03/11  21:25:24  syd
+ * Fix Elm looping if an EOF is received.
+ * From: Gregory Neil Shapiro <gshapiro@WPI.EDU>
+ *
+ * Revision 5.35  1993/09/27  01:51:38  syd
+ * Add elm_chown to consolidate for Xenix not allowing -1
+ * From: Syd
+ *
+ * Revision 5.34  1993/08/23  03:26:24  syd
+ * Try setting group id separate from user id in chown to
+ * allow restricted systems to change group id of file
+ * From: Syd
+ *
+ * Revision 5.33  1993/08/10  18:53:31  syd
+ * I compiled elm 2.4.22 with Purify 2 and fixed some memory leaks and
+ * some reads of unitialized memory.
+ * From: vogt@isa.de
+ *
+ * Revision 5.32  1993/08/03  19:28:39  syd
+ * Elm tries to replace the system toupper() and tolower() on current
+ * BSD systems, which is unnecessary.  Even worse, the replacements
+ * collide during linking with routines in isctype.o.  This patch adds
+ * a Configure test to determine whether replacements are really needed
+ * (BROKE_CTYPE definition).  The <ctype.h> header file is now included
+ * globally through hdrs/defs.h and the BROKE_CTYPE patchup is handled
+ * there.  Inclusion of <ctype.h> was removed from *all* the individual
+ * files, and the toupper() and tolower() routines in lib/opt_utils.c
+ * were dropped.
+ * From: chip@chinacat.unicom.com (Chip Rosenthal)
+ *
+ * Revision 5.31  1993/07/20  01:47:47  syd
+ * Fix time() declaration
+ * From: Syd via prompt from Dan Mosedale
+ *
+ * Revision 5.30  1993/06/06  17:53:06  syd
+ * Remove extranious clear
+ * From: Chip
+ *
+ * Revision 5.29  1993/05/31  19:31:31  syd
+ * Total rewrite of verify_transmission().  The existing code was a monsterous
+ * mess and rife with bugs (couldn't forget zero-length messages in send-only
+ * mode, prompts were being setup wrong, perms on Canceled.mail not done right,
+ * etc. etc. etc.)  Previously, the work had been split among two places,
+ * the main code in mail() and the menu in verify_transmission(), and Elm kept
+ * bouncing back and forth between the two.  Now, all work is performed in
+ * verify_transmission() and it simply returns a send-it/forget-it status.
+ * Modified "Canceled.mail" handling so that the files it creates are in
+ * an mbox format (i.e. now includes headers as well as message body).
+ * From: chip@chinacat.unicom.com (Chip Rosenthal)
+ *
+ * Revision 5.28  1993/05/14  03:56:19  syd
+ * A MIME body-part must end with a newline even when there was no newline
+ * at the end of the actual body or the body is null. Otherwise the next
+ * mime boundary may not be recognized.  The same goes with the closing
+ * boundary too.
+ * From: Jukka Ukkonen <ukkonen@csc.fi>
+ *
+ * Revision 5.27  1993/05/08  20:25:33  syd
+ * Add sleepmsg to control transient message delays
+ * From: Syd
+ *
+ * Revision 5.26  1993/05/08  19:54:17  syd
+ * fix nesting error
+ *
+ * Revision 5.25  1993/05/08  19:06:58  syd
+ * add not keeping empty cancelled messages
+ * From: Syd via request from Phil Richards
+ *
+ * Revision 5.24  1993/05/08  18:51:32  syd
+ * Make Elm quote full names it adds, its easier than checking
+ * for specials and only quoting for specials in the name
+ * From: Syd
+ *
+ * Revision 5.23  1993/04/21  01:25:45  syd
+ * I'm using Elm 2.4.21 under Linux.  Linux has no Bourne shell.  Each
+ * user installs her favorite shell as /bin/sh.  I use Bash 1.12.
+ *
+ * Elm invokes the mail transport (MTA) like so:
+ *
+ *    ( ( MTA destination; rm -f tempfile ) & ) < tempfile &
+ *
+ * This form of command doesn't work with my Bash, in which any command
+ * which is backgrounded ("&") gets its stdin attached to /dev/null.
+ *
+ * The below patch arranges for Elm to call the MTA thusly:
+ *
+ *    ( MTA destination <tempfile; rm -f tempfile ) &
+ * From: decwrl!uunet.UU.NET!fin!chip (Chip Salzenberg)
+ *
+ * Revision 5.22  1993/04/12  03:57:45  syd
+ * Give up and add an Ultrix specific patch. There is a bug in Ispell under
+ * ultrix.  The problem is that when ispell returns, the terminal is no
+ * longer in raw mode. (Ispell isn't restoring the terminal parameters)
+ * From: Scott Ames <scott@cwis.unomaha.edu>
+ *
+ * Revision 5.21  1993/04/12  02:34:36  syd
+ * I have now added a parameter which controls whether want_to clears the
+ * line and centers the question or behaves like it did before. I also
+ * added a 0 at the end of the parameter list to all the other calls to
+ * want_to where a centered question on a clean line is not desirable.
+ * From: Jukka Ukkonen <ukkonen@csc.fi>
+ *
+ * Revision 5.20  1993/02/12  21:35:07  syd
+ * fix edit form catting on to end, strcat->strcpy
+ * From: Syd
+ *
+ * Revision 5.19  1993/02/03  17:12:53  syd
+ * move more declarations to defs.h, including sleep
+ * From: Syd
+ *
+ * Revision 5.18  1993/02/03  16:45:26  syd
+ * A Raw(OFF) was missing so when in mail only mode and one
+ * does f)orget, the "Message saved" ends up on wrong screen.
+ * Also added \r\n to end of messages to make output look nicer.
+ *
+ * When composing mail in the builtin editor, it wrapped on /.
+ * From: Jan Djarv <Jan.Djarv@sa.erisoft.se>
+ *
+ * Revision 5.17  1993/02/03  16:36:56  syd
+ * Fix where we remove the extra hostbangs and on which fields we do
+ * it to include bcc and cc as well as to, and to do it in the file
+ * copies as well as the command line.
+ *
+ * Revision 5.16  1993/01/20  03:02:19  syd
+ * Move string declarations to defs.h
+ * From: Syd
+ *
+ * Revision 5.15  1992/12/28  14:24:25  syd
+ * Fix problem where it won't let no answer on recall last message
+ * From: Syd
+ *
+ * Revision 5.14  1992/12/24  21:42:01  syd
+ * Fix messages and nls messages to match.  Plus use want_to
+ * where appropriate.
+ * From: Syd, via prompting from Jan Djarv <Jan.Djarv@sa.erisoft.se>
+ *
+ * Revision 5.13  1992/12/20  05:04:51  syd
+ * restore unintnded prefix_chars that caused forwarding without editing
+ * to add prefix
+ * From: Syd
+ *
+ * Revision 5.12  1992/12/11  01:58:50  syd
+ * Allow for use from restricted shell by putting SHELL=/bin/sh in the
+ * environment of spawned mail transport program.
+ * From: chip@tct.com (Chip Salzenberg)
+ *
+ * Revision 5.11  1992/12/07  04:26:26  syd
+ * add missing err declare
+ * From: Syd
+ *
+ * Revision 5.10  1992/12/07  03:20:30  syd
+ * Change $HOME/Cancelled.mail in message to /fullpath/Cancelled.mail
+ * as AFS uses different meaning for $HOME than Elm does and it was
+ * confusing to some users.
+ * From: Syd
+ *
+ * Revision 5.9  1992/11/26  01:46:26  syd
+ * add Decode option to copy_message, convert copy_message to
+ * use bit or for options.
+ * From: Syd and bjoerns@stud.cs.uit.no (Bjoern Stabell)
+ *
+ * Revision 5.8  1992/11/26  00:46:13  syd
+ * changes to first change screen back (Raw off) and then issue final
+ * error message.
+ * From: Syd
+ *
+ * Revision 5.7  1992/11/22  01:14:20  syd
+ * Allow SCO MMDF to use the mmdf library for mailer via execmail.
+ * From: Larry Philps <larryp@sco.com>
+ *
+ * Revision 5.6  1992/11/07  20:29:28  syd
+ * These small typos stopped me from making forms, so here is a patch.
+ * From: andrew.mcparland@rd.eng.bbc.co.uk (Andrew McParland)
+ *
+ * Revision 5.5  1992/11/07  16:21:56  syd
+ * There is no need to write out the MIME-Version header in subparts
+ * From: Klaus Steinberger <Klaus.Steinberger@Physik.Uni-Muenchen.DE>
+ *
+ * Revision 5.4  1992/10/30  21:04:04  syd
+ * fix a bug in the forms reply caused by the Cc: buffer not being
+ * cleared.  If one has sent mail just prior to replying to the form and
+ * specified a Cc:  address, the form reply is also sent to those Cc:
+ * address(es).
+ * From: dwolfe@pffft.sps.mot.com (Dave Wolfe)
+ *
+ * Revision 5.3  1992/10/25  01:47:45  syd
+ * fixed a bug were elm didn't call metamail on messages with a characterset,
+ * which could be displayed by elm itself, but message is encoded with QP
+ * or BASE64
+ * From: Klaus Steinberger <Klaus.Steinberger@Physik.Uni-Muenchen.DE>
+ *
+ * Revision 5.2  1992/10/24  13:44:41  syd
+ * There is now an additional elmrc option "displaycharset", which
+ * sets the charset supported on your terminal. This is to prevent
+ * elm from calling out to metamail too often.
+ * Plus a slight documentation update for MIME composition (added examples)
+ * From: Klaus Steinberger <Klaus.Steinberger@Physik.Uni-Muenchen.DE>
+ *
+ * Revision 5.1  1992/10/03  22:58:40  syd
+ * Initial checkin as of 2.4 Release at PL0
+ *
+ *
+ ******************************************************************************/
+
+/** Interface to allow mail to be sent to users.  Part of ELM  **/
+
+#include "headers.h"
+#include "s_elm.h"
+#include <errno.h>
+
+extern int errno;
+extern char version_buff[];
+
+char *error_description(), *strip_parens();
+char *format_long(), *strip_commas(), *tail_of_string(); 
+long ftell();
+
+int pgp_encoded;
+#ifdef SITE_HIDING 
+ char *get_ctime_date();
+#endif
+FILE *write_header_info();
+
+/* these are all defined in the mailmsg1.c file! */
+
+extern char subject[SLEN], in_reply_to[SLEN], expires[SLEN],
+            action[SLEN], priority[SLEN], reply_to[SLEN], to[VERY_LONG_STRING], 
+	    cc[VERY_LONG_STRING], expanded_to[VERY_LONG_STRING], 
+	    expanded_reply_to[LONG_STRING],
+	    expanded_cc[VERY_LONG_STRING], user_defined_header[SLEN],
+	    bcc[VERY_LONG_STRING], expanded_bcc[VERY_LONG_STRING], keyid[LONG_STRING],
+	    precedence[SLEN], expires_days[SLEN];
+
+
+#ifdef	MIME
+int msg_is_multipart;
+#endif /* MIME */
+long C_L_Position[2];   /*To Remember position of the Content-Length*/
+long C_StartData[2];    /*To Remember length of Header Area */
+long C_EndData[2];	/* To Remember the end of the BodyPart */
+
+int  gotten_key;
+char *bounce_off_remote();
+
+/*
+ * remove_hostbang - Given an expanded list of addresses, remove all
+ * occurrences of "thishost!" at the beginning of addresses.
+ * This hack is useful in itself, but it is required now because of the
+ * kludge disallowing alias expansion on return addresses.
+ */
+
+void
+remove_hostbang(addrs)
+char *addrs;
+{
+	int i, j, hlen, flen;
+
+	if ((hlen = strlen(hostname)) < 1)
+	  return;
+
+	flen = strlen(hostfullname);
+	i = j = 0;
+
+	while (addrs[i]) {
+	  if (j == 0 || isspace(addrs[j - 1])) {
+	    if (strncmp(&addrs[i], hostname, hlen) == 0 &&
+	      addrs[i + hlen] == '!') {
+	        i += hlen + 1;
+	        continue;
+	    }
+	    if (strncmp(&addrs[i], hostfullname, flen) == 0 &&
+	      addrs[i + flen] == '!') {
+	        i += flen + 1;
+	        continue;
+	    }
+	  }
+	  addrs[j++] = addrs[i++];
+	}
+	addrs[j] = 0;
+}
+
+int
+mail(copy_msg, edit_message, form)
+int  copy_msg, edit_message, form;
+{
+	/** Given the addresses and various other miscellany (specifically, 
+	    'copy-msg' indicates whether a copy of the current message should 
+	    be included, 'edit_message' indicates whether the message should 
+	    be edited) this routine will invoke an editor for the user and 
+	    then actually mail off the message. 'form' can be YES, NO, or
+	    MAYBE.  YES=add "Content-Type: mailform" header, MAYBE=add the
+	    M)ake form option to last question, and NO=don't worry about it!
+	    Also, if 'copy_msg' = FORM, then grab the form temp file and use
+	    that...
+	    Return TRUE if the main part of the screen has been changed
+	    (useful for knowing whether a redraw is needed.
+	**/
+
+	/**
+            remember: if form = -1 then send our public keyring
+	**/
+	 
+	FILE *reply, *real_reply; /* second is post-input buffer */
+	char *whole_msg_file, *tempnam();
+	char filename[SLEN], fname[SLEN], copy_file[SLEN],
+             very_long_buffer[VERY_LONG_STRING], mailerflags[NLEN];
+	int ch, sys_status, line_len;
+	register int retransmit = FALSE; 
+	int      already_has_text = FALSE;		/* we need an ADDRESS */
+	int	 signature_done = FALSE;
+	int	 need_redraw = 0;
+	int	 err;
+
+	static int cancelled_msg = 0;
+
+	dprint(4, (debugfile, "\nMailing to \"%s\" (with%s editing)\n",
+		  expanded_to, edit_message? "" : "out"));
+	
+	gotten_key = 0;		/* ignore previously gotten encryption key */
+
+	/** first generate the temporary filename **/
+
+	sprintf(filename,"%s%s%d", temp_dir, temp_file, getpid());
+
+	/** if possible, let's try to recall the last message? **/
+
+	if (! batch_only && copy_msg != FORM && user_level != 0 && (form != -1))
+	  retransmit = recall_last_msg(filename, copy_msg, &cancelled_msg, 
+		       &already_has_text);
+
+	/** if we're not retransmitting, create the file.. **/
+
+	if (! retransmit)
+	  if (form == -1) { /* send pgp key */
+ 		int keyhandle;
+		char delim[] = " ";
+		char *strp;
+
+		if ((keyhandle = creat(filename, 0600)) < 0) {
+		  error1(catgets(elm_msg_cat, ElmSet, ElmCouldNotCreateFile,
+		         "Could not create file %s."), filename);
+		  return(need_redraw);
+                }
+
+ 		strp = strtok(keyid, delim);
+		while (strp != NULL) {
+  		  if (*strp) {
+ 		    if (invoke_pgp(-1, keyhandle, -2, "-kxaf", "+verbose=0",
+		        "+batchmode", strp, keyring, NULL) != 0) { 
+                      error1(catgets(elm_msg_cat, ElmSet, ElmCouldNotCreateFile,
+                             "Could not create PGP public key file %s."), filename);
+	  	      return(need_redraw);
+		    }
+		  }
+		  strp = strtok(NULL, delim);
+		}
+		close(keyhandle);
+
+                if ((reply = fopen(filename, "a")) == NULL) {
+                  error1(catgets(elm_msg_cat, ElmSet, ElmCouldNotOpenFile,
+                         "Could not open file %s."), filename);
+                  return(need_redraw);
+                }
+	  } else 
+	  if ((reply = fopen(filename,"w")) == NULL) {
+	    err = errno;
+	    dprint(1, (debugfile, 
+               "Attempt to write to temp file %s failed with error %s (mail)\n",
+		 filename, error_description(err)));
+	    if(batch_only) {
+	      MCprintf(catgets(elm_msg_cat, ElmSet, ElmCouldNotCreateFile,
+		"Could not create file %s (%s)."),
+		filename, error_description(err));
+	      printf("\n");
+	    } else
+	      error2(catgets(elm_msg_cat, ElmSet, ElmCouldNotCreateFile,
+		"Could not create file %s (%s)."),
+		filename, error_description(errno));
+	    return(need_redraw);
+	  }
+	if (form != -1)
+	(void) elm_chown(filename, userid, groupid);
+
+	/* copy the message from standard input */
+	if (batch_only) {
+	  while (line_len = fread(very_long_buffer, 1, sizeof(very_long_buffer), stdin))
+	    fwrite(very_long_buffer, 1, line_len, reply);
+	}
+
+	/** if there is an included file, copy it into the temp file **/
+	if (*included_file && (form != -1)) {
+	  FILE *input;
+	  if ((input = fopen(included_file,"r")) == NULL) {
+	    dprint(1, (debugfile, 
+              "Can't open included file %s.  Failed with error %s (mail)\n",
+	      included_file, error_description(errno)));
+	    error1(catgets(elm_msg_cat, ElmSet, ElmCouldNotOpenFile,
+	      "Could not open file %s."), included_file);
+	    return(need_redraw);
+	  }
+
+	  while (fgets(very_long_buffer, VERY_LONG_STRING, input) != NULL) 
+	    fputs(very_long_buffer, reply);
+
+	  fclose(input);
+	  already_has_text = TRUE;
+	}
+
+	if (copy_msg == FORM) {
+	  sprintf(fname, "%s%s%d", temp_dir, temp_form_file, getpid());
+	  fclose(reply);	/* we can't retransmit a form! */
+	  if (access(fname,ACCESS_EXISTS) != 0) {
+	    if(batch_only) {
+	      printf(catgets(elm_msg_cat, ElmSet, ElmCouldNotFindForm,
+		"Couldn't find forms file!"));
+	      printf("\n");
+	    } else
+	      error(catgets(elm_msg_cat, ElmSet, ElmCouldNotFindForm,
+		"Couldn't find forms file!"));
+	    return(need_redraw);
+	  }
+	  dprint(4, (debugfile, "-- renaming existing file %s to file %s --\n",
+		  fname, filename));
+	  rename(fname, filename);
+
+	  /* kill leftover headers since forms reply skips regular init */
+	  expires[0] = '\0';
+	  expires_days[0] = '\0';
+	  action[0] = '\0';
+	  priority[0] = '\0';
+	  reply_to[0] = '\0';
+	  expanded_reply_to[0] = '\0';
+	  cc[0] = '\0';
+	  expanded_cc[0] = '\0';
+	  user_defined_header[0] = '\0';
+	  bcc[0] = '\0';
+	  expanded_bcc[0] = '\0';
+	  precedence[0] = '\0';
+	}
+	else if (copy_msg && ! retransmit) {  /* if retransmit we have it! */
+	  if (form == -1) 
+	    already_has_text = TRUE;
+	  else {
+	  if (attribution[0]) {
+	    fprintf(reply, attribution, headers[current-1]->from);
+	    fputc('\n', reply);
+	  }
+	  else if (forwarding) {
+	    fputs("Forwarded message:\n", reply);
+	  }
+	  if (edit_message) {
+	    pgp_copy_message(prefixchars, reply,
+		( noheader ? CM_REMOVE_HEADER : 0 ) | CM_MMDF_HEAD | CM_DECODE);
+	    already_has_text = TRUE;	/* we just added it, right? */
+	  }
+	  else
+	    pgp_copy_message("", reply,
+		( noheader ? CM_REMOVE_HEADER : 0 ) | CM_MMDF_HEAD);
+	  }
+	}
+
+        /* append signature now if we are going to use an external editor */
+	/* Don't worry about the remote/local determination too much */
+
+        if (already_has_text || 
+           (strcmp(editor,"builtin") != 0 && strcmp(editor,"none") != 0)) {
+	     signature_done = TRUE;
+             if (!retransmit && copy_msg != FORM) 
+	       already_has_text |= append_sig(reply);
+	}
+
+	if (! retransmit && copy_msg != FORM)
+	  if (reply != NULL)
+	    (void) fclose(reply);	/* on replies, it won't be open! */
+
+	/** Edit the message **/
+
+	/* calculate default save_file name */
+	if(auto_cc) {
+	  if(save_by_name) {
+	    if(force_name) {
+	      strcpy(copy_file, "=");	/* signals save by 'to' logname */
+	    } else {
+	      strcpy(copy_file, "=?");	/* conditional save by 'to' logname */
+	    }
+	  } else {
+	    strcpy(copy_file, "<");	/* signals save to sentmail */
+	  }
+	} else *copy_file = '\0';	/* signals to not save a copy */
+
+	/* ask the user to confirm transmission of the message */
+	if (!batch_only /*&& (form != -1)gec*/) {
+	    ch = (edit_message? 'e' : '\0');
+	    if (verify_transmission(filename, &form, &need_redraw,
+		    already_has_text, copy_file, ch) != 0) {
+		cancelled_msg = (bytes(filename) > 0);
+		return need_redraw;
+	    }
+	    if (form == YES && format_form(filename) < 1) {
+		cancelled_msg = (bytes(filename) > 0);
+		return need_redraw;
+	    }
+	}
+
+	if ((reply = fopen(filename,"r")) == NULL) {
+	    err = errno;
+	    dprint(1, (debugfile,
+		"Attempt to open file %s for reading failed with error %s (mail)\n",
+		filename, error_description(err)));
+	    if (!batch_only) {
+		error1(catgets(elm_msg_cat, ElmSet, ElmCouldNotOpenReply,
+		    "Could not open reply file (%s)."), error_description(err));
+	    } else {
+		printf(catgets(elm_msg_cat, ElmSet, ElmCouldNotOpenReply,
+		    "Could not open reply file (%s)."), error_description(err));
+		putchar('\n');
+	    }
+	    return need_redraw;
+	}
+
+	cancelled_msg = FALSE;	/* it ain't cancelled, is it? */
+
+	/** ask about bounceback if the user wants us to.... **/
+
+	if (uucp_hops(to) > bounceback && bounceback > 0 && copy_msg != FORM) 
+	  if (verify_bounceback() == TRUE) {
+	    if (strlen(cc) > 0) strcat(expanded_cc, ", ");
+	    strcat(expanded_cc, bounce_off_remote(to));
+	  }
+
+#ifdef	MIME
+	/* Look if its a Multimedia/multipart Message */
+	msg_is_multipart = check_for_multipart(reply);
+
+	if (msg_is_multipart == -1) {
+		return(need_redraw);
+	}
+#endif /* MIME */
+
+	/** grab a copy if the user so desires... **/
+
+	remove_hostbang(expanded_to);
+	remove_hostbang(expanded_cc);
+	remove_hostbang(expanded_bcc);
+
+	if (*copy_file) /* i.e. if copy_file contains a name */
+	  save_copy(expanded_to, expanded_cc, expanded_bcc,
+	       filename, copy_file, form);
+
+	/** write all header information into whole_msg_file **/
+
+	if((whole_msg_file=tempnam(temp_dir, "snd.")) == NULL) {
+	  dprint(1, (debugfile, "couldn't make temp file nam! (mail)\n"));
+	  if(batch_only) {
+	    printf(catgets(elm_msg_cat, ElmSet, ElmCouldNotMakeTemp,
+		"Sorry - couldn't make temp file name!"));
+	    printf("\n");
+	  } else if(mail_only)
+	    error(catgets(elm_msg_cat, ElmSet, ElmCouldNotMakeTemp,
+		"Sorry - couldn't make temp file name."));
+	  else
+	    set_error(catgets(elm_msg_cat, ElmSet, ElmCouldNotMakeTemp,
+		"Sorry - couldn't make temp file name."));
+	  return(need_redraw);
+	}
+
+	/** try to write headers to new temp file **/
+
+	dprint(6, (debugfile, "Composition file='%s' and mail buffer='%s'\n", 
+		    filename, whole_msg_file));
+
+	dprint(2,(debugfile,"--\nTo: %s\nCc: %s\nBcc: %s\nSubject: %s\n---\n", 
+		  expanded_to, expanded_cc, expanded_bcc, subject));
+
+	if ((real_reply = 
+	   write_header_info(whole_msg_file, expanded_to,
+	     expanded_cc, expanded_bcc, form, FALSE)) == NULL) {
+
+	  /** IT FAILED!!  MEIN GOTT!  Use a dumb mailer instead! **/
+
+	  dprint(3, (debugfile, "** write_header failed: %s\n", 
+		 error_description(errno)));
+
+	  if (cc[0] != '\0')  		/* copies! */
+	    sprintf(expanded_to,"%s %s", expanded_to, expanded_cc);
+
+	  quote_args(very_long_buffer, strip_parens(strip_commas(expanded_to)));
+	  strcpy(expanded_to, very_long_buffer);
+
+	  sprintf(very_long_buffer, "(%s -s \"%s\" %s < %s ; %s %s) &",
+		  mailx, subject, expanded_to, filename, remove_cmd, filename);
+
+	  if(batch_only) {
+	    printf(catgets(elm_msg_cat, ElmSet, ElmUsedDumpMailer,
+		"Message sent using dumb mailer %s."), mailx);
+	    printf("\n");
+	  } else
+	    error1(catgets(elm_msg_cat, ElmSet, ElmUsedDumpMailer,
+		"Message sent using dumb mailer %s."), mailx);
+	    if (sleepmsg > 0)
+		sleep(sleepmsg);
+
+	}
+	else {
+
+	  C_StartData[0] = ftell(real_reply);
+
+	  copy_message_across(reply, real_reply, FALSE);
+
+          /* Append signature if not done earlier */
+
+          if (!signature_done && !retransmit && copy_msg != FORM)
+               append_sig(real_reply);
+	  
+#ifdef MIME
+	  if (!copy_msg != FORM && msg_is_multipart) {
+	    fprintf(real_reply, "\n--%s--\n", MIME_BOUNDARY);
+	    if (C_L_Position[1] != 0L) {
+	      C_EndData[1] = ftell(real_reply);
+	      C_L_Position[1] = fseek(real_reply, C_L_Position[1], 0);
+	      fprintf(real_reply, "%d", C_EndData[1] - C_StartData[1]);
+	      fseek(real_reply, C_EndData[1], 0);
+	    }
+	  }
+#endif
+
+	  C_EndData[0] = ftell(real_reply);
+	    
+	  fseek(real_reply, C_L_Position[0], 0);
+	  fprintf(real_reply, "%d", C_EndData[0] - C_StartData[0]);
+	  fclose(real_reply);
+
+	  if (cc[0] != '\0')  				         /* copies! */
+	    sprintf(expanded_to,"%s %s", expanded_to, expanded_cc);
+
+	  if (bcc[0] != '\0') {
+	    strcat(expanded_to, " ");
+	    strcat(expanded_to, expanded_bcc);
+	  }
+
+	  if (strcmp(sendmail, mailer) == 0
+#ifdef SITE_HIDING
+	      && ! is_a_hidden_user(username)
+#endif
+	  ) {
+	    strcpy(mailerflags, (sendmail_verbose ? smflagsv : smflags));
+	    if (metoo) strcat(mailerflags, smflagmt);
+	  } else if (strcmp(submitmail, mailer) == 0)
+	    strcpy(mailerflags, submitflags_s);
+	  else if (strcmp(execmail, mailer) == 0) {
+	    strcpy(mailerflags, (sendmail_verbose ? emflagsv : emflags));
+	    if (metoo) strcat(mailerflags, emflagmt);
+	  } else
+	    mailerflags[0] ='\0';
+
+	  if (strcmp(submitmail, mailer) == 0)
+	    strcpy(expanded_to, " ");
+	  else {
+	    quote_args(very_long_buffer, strip_parens(strip_commas(expanded_to)));
+	    strcpy(expanded_to, very_long_buffer);
+	  }
+
+	  sprintf(very_long_buffer,"(%s %s %s < %s ; %s %s) &", 
+		mailer, mailerflags, expanded_to, whole_msg_file,
+		remove_cmd, whole_msg_file);
+	}
+
+	free(whole_msg_file);
+
+	fclose(reply);
+
+	if(batch_only) {
+	  printf(catgets(elm_msg_cat, ElmSet, ElmSendingMail,
+		"Sending mail..."));
+	  printf("\n");
+	} else {
+	  PutLine0(LINES,0,catgets(elm_msg_cat, ElmSet, ElmSendingMail,
+		"Sending mail..."));
+	  CleartoEOLN();
+	}
+
+	/* Take note of mailer return value */
+
+	if ( sys_status = system_call(very_long_buffer, SY_ENV_SHELL) ) {
+		/* problem case: */
+		if (mail_only || batch_only) {
+		   printf("\r\n");
+		   printf(catgets(elm_msg_cat, ElmSet, ElmMailerReturnedError,
+			"mailer returned error status %d"), sys_status);
+		   printf("\r\n");
+		} else {
+		   sprintf(very_long_buffer, catgets(elm_msg_cat, ElmSet, ElmMailerReturnedError,
+			"mailer returned error status %d"), sys_status);
+		   set_error(very_long_buffer);
+		}
+	} else {
+		/* Success case: */
+		if(batch_only) {
+		  printf(catgets(elm_msg_cat, ElmSet, ElmMailSent, "Mail sent!"));
+	          printf("\n");
+		} else if(mail_only)
+		  error(catgets(elm_msg_cat, ElmSet, ElmMailSent, "Mail sent!"));
+		else
+		  set_error(catgets(elm_msg_cat, ElmSet, ElmMailSent, "Mail sent!"));
+	}
+
+	/* Unlink temp file now.
+	 * This is a precaution in case the message was encrypted.
+	 * I.e. even though this file is readable by the owner only,
+	 * encryption is supposed to hide things even from someone
+	 * with root privelges. The best we can do is not let this
+	 * file just hang after we're finished with it.
+	 */
+	(void)unlink(filename);
+
+	return(need_redraw);
+}
+
+mail_form(address, subj)
+char *address, *subj;
+{
+	/** copy the appropriate variables to the shared space... */
+
+	strcpy(subject, subj);
+	strcpy(to, address);
+	strcpy(expanded_to, address);
+
+	return(mail(FORM, NO, NO));
+}
+
+int
+recall_last_msg(filename, copy_msg, cancelled_msg, already_has_text)
+char *filename;
+int  copy_msg, *cancelled_msg, *already_has_text;
+{
+	char ch;
+	char msg[SLEN];
+
+	/** If filename exists and we've recently cancelled a message,
+	    the ask if the user wants to use that message instead!  This
+	    routine returns TRUE if the user wants to retransmit the last
+	    message, FALSE otherwise...
+	**/
+
+	register int retransmit = FALSE;
+
+	if (access(filename, EDIT_ACCESS) == 0 && *cancelled_msg) {
+	  Raw(ON);
+	  CleartoEOLN();
+	  if (copy_msg)
+	    MCsprintf(msg, catgets(elm_msg_cat, ElmSet, ElmRecallLastInstead,
+		     "Recall last kept message instead? (%c/%c) "),
+		     *def_ans_yes, *def_ans_no);
+	  else
+	    MCsprintf(msg, catgets(elm_msg_cat, ElmSet, ElmRecallLastKept,
+		     "Recall last kept message? (%c/%c) "),
+		     *def_ans_yes, *def_ans_no);
+	  do {
+	    ch = want_to(msg, '\0', LINES-1, 0);
+	    if (ch == *def_ans_yes) {
+              retransmit++;
+	      *already_has_text = TRUE;
+	    } else if (ch != *def_ans_no) {
+	      Write_to_screen("%c??", 1, 07);	/* BEEP */
+	      if (sleepmsg > 0)
+		    sleep((sleepmsg + 1) / 2);
+	      ch = 0;
+	    }
+	  } while (ch == 0);
+
+	  fflush(stdout);
+
+	  *cancelled_msg = 0;
+	}
+
+	return(retransmit);
+}
+
+
+/*
+ * verify_transmission() - Ask the user to confirm transmission of the
+ * message.  Returns 0 to send it, -1 to forget it.
+ */
+int
+verify_transmission(filename, form_p, need_redraw_p,
+	already_has_text, copy_file, force_cmd)
+char *filename;		/* pathname to mail mssg composition file	*/
+int  *form_p;		/* pointer to form message state		*/
+int *need_redraw_p;	/* pointer to flag indicating screen stepped on	*/
+int already_has_text;	/* indicates there is already text in the mssg	*/
+char *copy_file;	/* pointer to buffer holding copy file name	*/
+int force_cmd;		/* command to do, '\0' to prompt user for cmd	*/
+{
+    char *prompt_mssg;		/* message to display prompting for cmd	*/
+    char prompt_menu[SLEN];	/* menu of available commands		*/
+    int bad_cmd;		/* set TRUE to bitch about user's entry	*/
+    int did_prompt;		/* TRUE if cmd prompted for and entered	*/
+    int prev_form;		/* "*form_p" value last time thru loop	*/
+    int cmd;			/* command to perform			*/
+    char lbuf[VERY_LONG_STRING];
+    int x_coord, y_coord;
+
+    prev_form = *form_p + 1;	/* force build of prompt strings	*/
+    bad_cmd = FALSE;		/* nothing to complain about yet	*/
+
+    pgp_encoded = 0;
+    for (;;) {
+
+	/* build up prompt and menu strings */
+	if (prev_form == *form_p) {
+	    ; /* not changed - no need to rebuild the strings */
+	} else if (user_level == 0) {
+	    prompt_mssg = catgets(elm_msg_cat, ElmSet, ElmVfyPromptPleaseChoose,
+		"Please choose one of the following options by parenthesized letter: s");
+	    strcpy(prompt_menu, catgets(elm_msg_cat, ElmSet, ElmVfyMenuUser0,
+		"e)dit message, edit h)eaders, s)end it, or f)orget it."));
+	} else {
+	    prompt_mssg = catgets(elm_msg_cat, ElmSet, ElmVfyPromptAndNow,
+		"And now: s");
+	    switch (*form_p) {
+	    case PREFORMATTED:
+		strcpy(prompt_menu, "");
+		break;
+	    case YES:
+		strcpy(prompt_menu, catgets(elm_msg_cat, ElmSet,
+		    ElmVfyMenuEditForm, "e)dit form, "));
+		break;
+	    case MAYBE:
+		strcpy(prompt_menu, catgets(elm_msg_cat, ElmSet,
+		    ElmVfyMenuEditMake, "e)dit msg, m)ake form, "));
+		break;
+	    default:
+		strcpy(prompt_menu, catgets(elm_msg_cat, ElmSet,
+		    ElmVfyMenuEditMsg, "e)dit msg, "));
+		break;
+	    }
+		if (pgp_enabled)
+		    strcat(prompt_menu, catgets(elm_msg_cat, ElmSet, ElmVfyMenuVfyCpy,
+			"h)eaders, c)opy, p)lain, si(g)n, "));
+		else
+	    strcat(prompt_menu, catgets(elm_msg_cat, ElmSet, ElmVfyMenuVfyCpy,
+		"h)eaders, c)opy, "));
+#ifdef ISPELL
+	    strcat(prompt_menu, catgets(elm_msg_cat, ElmSet, ElmVfyMenuIspell,
+		"i)spell, "));
+#endif
+#ifdef ALLOW_SUBSHELL
+	    strcat(prompt_menu, catgets(elm_msg_cat, ElmSet, ElmVfyMenuShell,
+		"!)shell, "));
+#endif
+	    strcat(prompt_menu, catgets(elm_msg_cat, ElmSet, ElmVfyMenuSndFgt,
+		"s)end, or f)orget"));
+	}
+	prev_form = *form_p;
+
+	/* complain if last entry was bad */
+	if (bad_cmd) {
+	    Write_to_screen("%c??", 1, 07);
+	    if (sleepmsg > 0)
+		sleep((sleepmsg + 1) / 2);
+	    bad_cmd = FALSE;
+	}
+
+	/* if we don't have a cmd, display prompt and get response from user */
+	if (force_cmd != '\0') {
+	    cmd = force_cmd;
+	    force_cmd = '\0';
+	    did_prompt = FALSE;
+	} else {
+	    MoveCursor(LINES-2, 0);
+	    CleartoEOS();
+	    PutLine0(LINES-2, 0, prompt_mssg);
+	    GetXYLocation(&x_coord, &y_coord);
+	    y_coord--; /* backspace over default answer */
+	    Centerline(LINES-1, prompt_menu);
+	    fflush(stdin);
+	    fflush(stdout);
+	    Raw(ON); /* double check... testing only... */
+	    MoveCursor(x_coord, y_coord);
+	    cmd = ReadCh();
+	    if (cmd == EOF)
+	      leave(0);
+	    did_prompt = TRUE;
+	}
+
+	/* handle command */
+	switch (cmd) {
+
+	case 'p': 
+	case 'g':
+	    if (!pgp_enabled) {
+		bad_cmd = TRUE;
+		break;
+	    }
+	    /* fall through */	
+
+	case '\n':
+	case '\r':
+	case 's':
+	    if (did_prompt)
+		Write_to_screen("Send", 0);
+
+	    if (pgp_enabled && (cmd == 'g')) {
+		if (pgp_key_check(filename,1)== -1) break; /*gec*/
+            } else if (pgp_enabled && (cmd != 'p')) {
+		if (pgp_key_check(filename,0)== -1) break; /*gec*/
+	    }
+	    return 0;
+	    /*NOTREACHED*/
+
+	case 'f': 
+	    if (did_prompt)
+		Write_to_screen("Forget", 0);
+	    if (bytes(filename) <= 0) {
+		; /* forget about empty files */
+	    } else if (mail_only) {
+		sprintf(lbuf, "%s/%s", home, dead_letter);
+		(void) append_copy_to_file(to, cc, bcc, lbuf, filename,
+		    *form_p);
+	    } else if (user_level > 0) {
+		set_error(catgets(elm_msg_cat, ElmSet, ElmVfyMessageKept,
+		    "Message kept.  Can be restored at next f)orward, m)ail or r)eply."));
+	    }
+	    return -1;
+	    /*NOTREACHED*/
+
+	case 'c':
+	    if (did_prompt)
+		Write_to_screen("Copy file", 0);
+	    if (name_copy_file(copy_file) != 0)
+		*need_redraw_p = TRUE;
+	    break;
+
+	case 'e':
+	    if (did_prompt)
+		Write_to_screen("Edit", 0);
+	    if (*form_p == PREFORMATTED) {
+		bad_cmd = TRUE;
+	    } else {
+		if (*form_p == YES)
+		    *form_p = MAYBE;
+		*need_redraw_p = TRUE;
+		if (edit_the_message(filename, already_has_text) != 0)
+		    return -1;
+	    }
+	    break;
+
+	case 'h':
+	    if (did_prompt)
+		Write_to_screen("Headers", 0);
+	    (void) edit_headers();
+	    *need_redraw_p = TRUE;
+	    break;
+
+	case 'm':
+	    if (*form_p != MAYBE) {
+		bad_cmd = TRUE;
+	    } else {
+		switch (check_form_file(filename)) {
+		case -1:
+		    /* couldn't open file??? */
+		    return -1;
+		case 0:
+		    Write_to_screen(catgets(elm_msg_cat, ElmSet,
+			ElmVfyNoFieldsInForm, "No fields in form!\007"), 0);
+		    if (sleepmsg > 0)
+			sleep(sleepmsg);
+		    break;
+		default:
+		    /* looks like a good form */
+		    *form_p = YES;
+		    break;
+		}
+	    }
+	    break;
+
+#ifdef ISPELL
+	case 'i':
+	    if (did_prompt)
+		Write_to_screen("Ispell", 0);
+	    if (*form_p == PREFORMATTED) {
+		bad_cmd = TRUE;
+	    } else {
+		if (*form_p == YES)
+		    *form_p = MAYBE;
+		sprintf(lbuf, "%s %s %s",
+		    ISPELL_PATH, ISPELL_OPTIONS, filename);
+		system_call(lbuf, SY_ENAB_SIGHUP);
+		*need_redraw_p = TRUE;
+#ifdef ultrix
+		/* I'm told this is required to work around some sort of bug */
+		force_raw();
+#endif
+	    }
+	    break;
+#endif
+
+#ifdef ALLOW_SUBSHELL
+	case '!':
+	    if (subshell() != 0) {
+		ClearScreen();
+		*need_redraw_p = TRUE;
+	    }
+	    break;
+#endif
+
+	case '&': /*gec*/
+	    ClearScreen();
+	    pgp_enabled = !pgp_enabled;
+	    memset(passphrase,0,sizeof(passphrase));
+	    *need_redraw_p = TRUE;
+	    prev_form=*form_p+1;
+	    if (pgp_enabled) 
+	      setpasswd();
+	    break;
+
+	default:
+	    bad_cmd = TRUE;
+	    break;
+
+	}
+
+    }
+
+}
+
+
+FILE *
+write_header_info(filename, long_to, long_cc, long_bcc, form, copy)
+char *filename, *long_to, *long_cc, *long_bcc;
+int   form, copy;
+{
+	/** Try to open filedesc as the specified filename.  If we can,
+	    then write all the headers into the file.  The routine returns
+	    'filedesc' if it succeeded, NULL otherwise.  Added the ability
+	    to have backquoted stuff in the users .elmheaders file!
+	    If copy is TRUE, then treat this as the saved copy of outbound
+	    mail.
+	**/
+
+	char opentype[3];
+	time_t time(), thetime;
+	char *ctime();
+	static FILE *filedesc;		/* our friendly file descriptor  */
+        char to_buf[VERY_LONG_STRING];
+	int err;
+
+#ifdef SITE_HIDING
+	char  buffer[SLEN];
+	int   is_hidden_user;		/* someone we should know about?  */
+#endif
+#ifdef MMDF
+	int   is_submit_mailer;		/* using submit means change From: */
+#endif /* MMDF */
+
+	char  *get_arpa_date();
+
+	if(copy) 
+	    strcpy(opentype, "r+");
+	else
+	    strcpy(opentype, "w+");
+
+	save_file_stats(filename);
+
+	filedesc = fopen(filename, opentype);
+	if (copy && filedesc == NULL)
+	  filedesc = fopen(filename, "w+");
+
+	if (filedesc == NULL) {
+	  err = errno;
+	  dprint(1, (debugfile,
+	    "Attempt to open file %s for writing failed! (write_header_info)\n",
+	     filename));
+	  dprint(1, (debugfile, "** %s **\n\n", error_description(err)));
+	  error2(catgets(elm_msg_cat, ElmSet, ElmErrorTryingToWrite,
+		"Error %s encountered trying to write to %s."), 
+		error_description(err), filename);
+	  if (sleepmsg > 0)
+		sleep(sleepmsg);
+	  return(NULL);		/* couldn't open it!! */
+	}
+
+	if (copy) {
+		/* Position to the end of the file */
+		fseek(filedesc, 0L, 2);
+	}
+
+	restore_file_stats(filename);
+
+	if(copy) {	/* Add top line that mailer would add */
+#ifdef MMDF
+	  fprintf(filedesc, MSG_SEPARATOR);
+#endif /* MMDF */
+	  thetime = time((long *) 0);
+	  fprintf(filedesc,"From %s %s", username, ctime(&thetime));
+#ifdef MMDF
+	} else if (strcmp(submitmail,mailer) == 0) {
+	  sprintf(to_buf, "%s %s %s", long_to, long_cc, long_bcc);
+	  do_mmdf_addresses(filedesc, strip_parens(strip_commas(to_buf)));
+#endif /* MMDF */
+	}
+
+#ifdef SITE_HIDING
+	if ( !copy && (is_hidden_user = is_a_hidden_user(username))) {
+	  /** this is the interesting part of this trick... **/
+	  sprintf(buffer, "From %s!%s %s\n",  HIDDEN_SITE_NAME,
+		  username, get_ctime_date());
+	  fprintf(filedesc, "%s", buffer);
+	  dprint(1,(debugfile, "\nadded: %s", buffer));
+	  /** so is this perverted or what? **/
+	}
+#endif
+
+
+	/** Subject moved to top of headers for mail because the
+	    pure System V.3 mailer, in its infinite wisdom, now
+	    assumes that anything the user sends is part of the 
+	    message body unless either:
+		1. the "-s" flag is used (although it doesn't seem
+		   to be supported on all implementations?? )
+		2. the first line is "Subject:".  If so, then it'll
+		   read until a blank line and assume all are meant
+		   to be headers.
+	    So the gory solution here is to move the Subject: line
+	    up to the top.  I assume it won't break anyone elses program
+	    or anything anyway (besides, RFC-822 specifies that the *order*
+	    of headers is irrelevant).  Gahhhhh....
+	**/
+
+	fprintf(filedesc, "Subject: %s\n", subject);
+
+	  fprintf(filedesc, "To: %s\n", format_long(long_to, strlen("To:")));
+
+	fprintf(filedesc,"Date: %s\n", get_arpa_date());
+
+#ifndef DONT_ADD_FROM
+#ifdef MMDF
+	is_submit_mailer = (strcmp(submitmail,mailer) == 0);
+#endif /* MMDF */
+/*
+ *	quote full user name in case it contains specials
+ */
+# ifdef SITE_HIDING
+#    ifdef MMDF
+	if (is_submit_mailer)
+	  fprintf(filedesc,"From: \"%s\" <%s>\n", full_username, username);
+	else
+#    endif /* MMDF */
+	if (is_hidden_user)
+	  fprintf(filedesc,"From: \"%s\" <%s!%s!%s>\n", full_username,
+		  hostname, HIDDEN_SITE_NAME, username);
+	else
+	  fprintf(filedesc,"From: \"%s\" <%s!%s>\n", full_username,
+		  hostname, username);
+# else
+#  ifdef  INTERNET
+#   ifdef  USE_DOMAIN
+#    ifdef MMDF
+	if (is_submit_mailer)
+	  fprintf(filedesc,"From: \"%s\" <%s>\n", full_username, username);
+	else
+#    endif /* MMDF */
+	  fprintf(filedesc,"From: \"%s\" <%s@%s>\n", full_username, 
+		username, hostfullname);
+#   else
+#    ifdef MMDF
+	if (is_submit_mailer)
+	  fprintf(filedesc,"From: \"%s\" <%s>\n", full_username, username);
+	else
+#    endif /* MMDF */
+	fprintf(filedesc,"From: \"%s\" <%s@%s>\n", full_username,
+		username, hostname);
+#   endif
+#  else
+#    ifdef MMDF
+	if (is_submit_mailer)
+	  fprintf(filedesc,"From: \"%s\" <%s>\n", full_username, username);
+	else
+#    endif /* MMDF */
+	fprintf(filedesc,"From: \"%s\" <%s!%s>\n", full_username,
+		hostname, username);
+#  endif
+# endif
+#endif
+
+	if (cc[0] != '\0')
+	    fprintf(filedesc, "Cc: %s\n", format_long(long_cc, strlen("Cc: ")));
+
+	if (copy && (bcc[0] != '\0'))
+	    fprintf(filedesc, "Bcc: %s\n", format_long(long_bcc, strlen("Bcc: ")));
+
+	if (strlen(action) > 0)
+	    fprintf(filedesc, "Action: %s\n", action);
+	
+	if (strlen(priority) > 0)
+	    fprintf(filedesc, "Priority: %s\n", priority);
+
+	if (strlen(precedence) > 0)
+	    fprintf(filedesc, "Precedence: %s\n", precedence);
+	
+	if (strlen(expires) > 0)
+	    fprintf(filedesc, "Expires: %s\n", expires);
+	
+	if (strlen(expanded_reply_to) > 0)
+	    fprintf(filedesc, "Reply-To: %s\n", expanded_reply_to);
+
+	if (strlen(in_reply_to) > 0)
+	    fprintf(filedesc, "In-Reply-To: %s\n", in_reply_to);
+
+	if (strlen(user_defined_header) > 0)
+	    fprintf(filedesc, "%s\n", user_defined_header);
+
+	add_mailheaders(filedesc);
+
+#ifndef NO_XHEADER
+	fprintf(filedesc, "X-Mailer: ELM [version %s]\n", version_buff);
+#endif /* !NO_XHEADER */
+
+	if (form == YES)
+	  fprintf(filedesc, "Content-Type: mailform\n");
+#ifdef MIME
+	else if (msg_is_multipart) {
+	  fprintf(filedesc, "%s\n", MIME_HEADER);
+	  fprintf(filedesc,
+		"%s multipart/mixed; boundary=%s\n", MIME_CONTENTTYPE, MIME_BOUNDARY);
+	}
+#endif /* MIME */
+	else {
+#ifdef	MIME
+	  fprintf(filedesc, "%s\n", MIME_HEADER);
+
+	  if ((pgp_encoded) || (form == -1))
+              fprintf(filedesc, "%s %s\n",MIME_CONTENTTYPE, MIME_HEADER_PGP);
+          else
+	      fprintf(filedesc, "%s text/plain; charset=%s\n",
+		      MIME_CONTENTTYPE, charset);
+
+	  fprintf(filedesc, "Content-Transfer-Encoding: %s\n",
+		  (!strincmp ("us-ascii", charset)
+		   && strincmp ("7bit", text_encoding))
+		  ? "7bit" : text_encoding);
+#else
+	  fprintf(filedesc, "Content-Type: text\n");
+#endif /* MIME */
+	}
+	fprintf(filedesc, "Content-Length: ");
+	C_L_Position[0] = ftell(filedesc);
+	fprintf(filedesc, "          \n"); /* Print Blanks as Placeholders */
+
+	putc('\n', filedesc);
+
+	return((FILE *) filedesc);
+}
+
+copy_message_across(source, dest, copy)
+FILE *source, *dest;
+int copy;
+{
+	/** Copy the message in the file pointed to by source to the
+	    file pointed to by dest.
+	    If copy is TRUE, treat as a saved copy of outbound mail. **/
+
+	int  crypted = FALSE;			/* are we encrypting?  */
+	int  encoded_lines = 0;			/* # lines encoded     */
+	int  line_len;
+	char buffer[SLEN];			/* file reading buffer */
+#ifdef MIME
+	int	text_lines = 0;
+	int	at_boundary = FALSE;
+
+	C_L_Position[1] = 0L;
+	C_StartData[1] = 0L;
+	C_EndData[1] = 0L;
+
+#endif /* MIME */
+
+	while (line_len = mail_gets(buffer, SLEN, source)) {
+	  if (buffer[0] == '[') {
+	    if (strncmp(buffer, START_ENCODE, strlen(START_ENCODE))==0)
+	      crypted = TRUE;
+	    else if (strncmp(buffer, END_ENCODE, strlen(END_ENCODE))==0)
+	      crypted = FALSE;
+	    else if ((strncmp(buffer, DONT_SAVE, strlen(DONT_SAVE)) == 0)
+	          || (strncmp(buffer, DONT_SAVE2, strlen(DONT_SAVE2)) == 0)) {
+	      if(copy) break;  /* saved copy doesn't want anything after this */
+	      else continue;   /* next line? */
+#ifdef MIME
+	    } else if (strncmp(buffer, MIME_INCLUDE, strlen(MIME_INCLUDE))==0) {
+	      text_lines = 0;
+	      if (!at_boundary) {
+		if (C_L_Position[1] != 0L) {
+		  C_EndData[1] = ftell(dest);
+		  C_L_Position[1] = fseek(dest, C_L_Position[1], 0);
+		  fprintf(dest, "%d", C_EndData[1] - C_StartData[1]);
+		  fseek(dest, C_EndData[1], 0);
+		}
+		fprintf(dest, "\n--%s\n", MIME_BOUNDARY);
+	      }
+	      Include_Part(dest, buffer, FALSE);
+	      fprintf(dest, "--%s\n", MIME_BOUNDARY);
+	      at_boundary = TRUE;
+	      continue;
+#endif /* MIME */
+	    }
+
+	    if (crypted) {
+	      if (! gotten_key++)
+	        getkey(ON);
+	      else if (! encoded_lines)
+	        get_key_no_prompt();		/* reinitialize.. */
+	      if (strncmp(buffer, START_ENCODE, strlen(START_ENCODE))) {
+	        encode(buffer);
+	        encoded_lines++;
+	      }
+	    }
+	  }
+	  else if (crypted) {
+	    if (batch_only) {
+	      printf(catgets(elm_msg_cat, ElmSet, ElmNoEncryptInBatch,
+		"Sorry. Cannot send encrypted mail in \"batch mode\".\n"));
+	      leave(0);
+	    } else if (! gotten_key++)
+	      getkey(ON);
+	    else if (! encoded_lines)
+	      get_key_no_prompt();		/* reinitialize.. */
+	    if (strncmp(buffer, START_ENCODE, strlen(START_ENCODE))) {
+	      encode(buffer);
+	      encoded_lines++;
+	    }
+#ifdef MIME
+	  } else {
+	    if (text_lines == 0) {
+	      if (msg_is_multipart) {
+		if (!at_boundary) {
+	 	  fprintf(dest,"--%s\n",MIME_BOUNDARY);
+		}
+	        fprintf(dest, "%s text/plain; charset=%s\n",
+			MIME_CONTENTTYPE, charset);
+		fprintf(dest, "Content-Transfer-Encoding: %s\n",
+			(!strincmp ("us-ascii", charset)
+			 && strincmp ("7bit", text_encoding))
+			? "7bit" : text_encoding);
+		fprintf(dest, "Content-Length: ");
+		C_L_Position[1] = ftell(dest);
+		fprintf(dest, "          \n"); /* Print Placeholders */
+	        fprintf(dest, "\n");
+		C_StartData[1] = ftell(dest);
+		at_boundary = FALSE;
+	      }
+	    }	
+	    text_lines++;
+#endif /* MIME */
+          }
+
+#ifndef DONT_ESCAPE_MESSAGES
+	  if (copy && (strncmp(buffer, "From ", 5) == 0)) {
+	    /* Add in the > to a From on our copy */
+	    fprintf(dest, ">");
+	    if (fwrite(buffer, 1, line_len, dest) != line_len) {
+		MoveCursor(LINES, 0);
+		Raw(OFF);
+		Write_to_screen(catgets(elm_msg_cat, ElmSet, ElmWriteFailedCopyAcross,
+			"\nWrite failed in copy_message_across\n"), 0);
+		emergency_exit();
+	    }
+	  }
+#ifdef NEED_LONE_PERIOD_ESCAPE
+	  else if (!copy && strcmp(buffer, ".\n") == 0)
+	    /* Because some mail transport agents take a lone period to
+	     * mean EOF, we add a blank space on outbound message.
+	     */
+	    fputs(". \n", dest);
+#endif /* NEED_LONE_PERIOD_ESCAPE */
+  	  else
+#endif /* DONT_ESCAPE_MESSAGES */
+  	    if (fwrite(buffer, 1, line_len, dest) != line_len) {
+		MoveCursor(LINES, 0);
+		Raw(OFF);
+		Write_to_screen(catgets(elm_msg_cat, ElmSet, ElmWriteFailedCopyAcross,
+			"\nWrite failed in copy_message_across\n"), 0);
+		emergency_exit();
+	    }
+	} 
+#ifdef MMDF
+	if (copy) fputs(MSG_SEPARATOR, dest);
+#else
+	if (copy) fputs("\n", dest);	/* ensure a blank line at the end */
+#endif /* MMDF */
+}
+
+int
+verify_bounceback()
+{
+	char	ch;
+	char	msg[SLEN];
+
+	/** Ensure the user wants to have a bounceback copy too.  (This is
+	    only called on messages that are greater than the specified 
+	    threshold hops and NEVER for non-uucp addresses.... Returns
+	    TRUE iff the user wants to bounce a copy back.... 
+	 **/
+
+	MoveCursor(LINES,0);
+	CleartoEOLN();
+	MCsprintf(msg, catgets(elm_msg_cat, ElmSet, ElmBounceOffRemote,
+	      "\"Bounce\" a copy off the remote machine? (%c/%c) "),
+	      *def_ans_yes, *def_ans_no);
+	ch = want_to(msg, *def_ans_no, LINES, 0);
+	return (ch == *def_ans_yes);
+}
+
+
+int
+append_sig(file)
+FILE *file;
+{
+	/* Append the correct signature file to file.  Return TRUE if
+           we append anything.  */
+
+        /* Look at the to and cc list to determine which one to use */
+
+	/* We could check the bcc list too, but we don't want people to
+           know about bcc, even indirectly */
+
+	/* Some people claim that  user@anything.same_domain should be 
+	   considered local.  Since it's not the same machine, better be 
+           safe and use the remote sig (presumably it has more complete
+           information).  You can't necessarily finger someone in the
+           same domain. */
+
+	  if (!batch_only && (local_signature[0] || remote_signature[0])) {
+
+            char filename2[SLEN];
+	    char *sig;
+
+  	    if (index(expanded_to, '!') || index(expanded_cc,'!'))
+              sig = remote_signature;		/* ! always means remote */
+            else {
+	      /* check each @ for @thissite.domain */
+	      /* if any one is different than this, then use remote sig */
+	      int len;
+	      char *ptr;
+	      char sitename[SLEN];
+	      sprintf(sitename,"@%s",hostfullname);
+	      len = strlen(sitename);
+              sig = local_signature;
+              for (ptr = index(expanded_to,'@'); ptr;  /* check To: list */
+	          ptr = index(ptr+1,'@')) {
+		if (strincmp(ptr,sitename,len) != 0
+		    || (*(ptr+len) != ',' && *(ptr+len) != 0
+		    && *(ptr+len) != ' ')) {
+	          sig = remote_signature;
+                  break;
+                }
+              }
+              if (sig == local_signature)		   /* still local? */ 
+                for (ptr = index(expanded_cc,'@'); ptr;   /* check Cc: */
+		    ptr = index(ptr+1,'@')) {
+		  if (strincmp(ptr,sitename,len) != 0
+		      || (*(ptr+len) != ',' && *(ptr+len) != 0 
+		      && *(ptr+len) != ' ')) {
+	            sig = remote_signature;
+                    break;
+                  }
+                }
+            }
+
+            if (sig[0]) {  /* if there is a signature file */
+	      if (sig[0] != '/')
+	        sprintf(filename2, "%s/%s", home, sig);
+	      else
+	        strcpy(filename2, sig);
+	      /* append the file - with a news 2.11 compatible */
+	      /* seperator if "sig_dashes" is enabled */
+	      (void) append(file, filename2, (sig_dashes ? "\n-- \n" : NULL));
+
+              return TRUE;
+            }
+          }
+
+return FALSE;
+
+}
+
+/**
+   This function checks if we have the public key of the recipient. If yes,
+   the message is signed and encrypted. If no, it is signed. The user can
+   request a "plain send" via the p)lain send menu command.
+   If any "CC:" addresses are specified, then we must check all the public
+   keys. If a key is missing, then we cannot encrypt the message. 
+**/
+
+int pgp_key_check(filename, clearsign)
+char *filename; 
+int clearsign;
+{
+  FILE *fp;
+  int filedes[2], pid, i;
+  int status = 0;
+  char destination[VERY_LONG_STRING];
+  char addresses[VERY_LONG_STRING];
+  char pgplinks[VERY_LONG_STRING];
+  char line[VERY_LONG_STRING];
+  char tmp[VERY_LONG_STRING];
+  char *strp, *strp2;
+  char delim[] = " ";
+  char *arg[255];
+  char ch, msgbuf[SLEN];
+  int prompt_line;
+ 
+  prompt_line = mail_only ? 4 : LINES-2;
+  strp=NULL;
+  if (!clearsign) {
+    /** Get all destination addresses and remove junk **/
+    strcpy(destination, expanded_to);
+    if (*expanded_cc) {
+      strcat(destination, " ");
+      strcat(destination, expanded_cc);
+    }
+    if (*expanded_bcc) {
+      strcat(destination, " ");
+      strcat(destination, expanded_bcc);
+    }
+    strcpy(addresses, strip_parens(strip_commas(destination)));
+
+    /** copy destination addresses and expand if necessary **/
+    *destination = 0;
+    strp = strtok(addresses, delim);
+    while (strp != NULL) {
+      if (strchr(strp, '@') != NULL) {
+	strcat(destination, strp);
+	strcat(destination, " ");
+      }
+      else {
+#ifdef MAIL_DOMAIN
+	sprintf(tmp, "%s@%s ", strp, MAIL_DOMAIN);
+#else
+	sprintf(tmp, "%s@%s ", strp, hostfullname); 
+#endif
+	strcat(destination, tmp);
+      }
+      strp = strtok(NULL, delim);
+    }
+    strp = destination; while (*strp) { *strp = tolower(*strp); strp++; }
+    strcpy(addresses, destination);
+
+    /* check whether destination address is manually excluded from 
+     * encryption in the .elm/pgpexclude file 
+     */
+    sprintf(tmp, "%s/%s", home, pgpexclude);
+
+    if ((fp = fopen(tmp, "r")) != NULL) {
+      while (fgets(line, VERY_LONG_STRING, fp) != NULL) {
+	strp = line; while (*strp) { *strp = tolower(*strp); strp++; }
+	strp--; while (*line && isspace(*strp)) { *strp = 0; strp--; }
+	strp = strstr(addresses, line);
+	if (strp != NULL) {
+	  strp += strlen(line);
+	  if (isspace(*strp) || (*strp == '>') || (*strp == 0)) {
+	    fclose(fp);
+	    goto dont_encrypt;  /** do not encrypt **/
+          }
+	}
+      }
+      fclose(fp);
+    }
+
+    *pgplinks = 0;
+    /* check whether destination address is manually linked to
+     * certain PGP keys in the .elm/pgplink file
+     */
+    sprintf(tmp, "%s/%s", home, pgplink);
+
+    if ((fp = fopen(tmp, "r")) != NULL) {
+      *line = 0; 
+      while (fgets(line, VERY_LONG_STRING, fp) != NULL) {
+        char *idp, *splitp, *tp;
+        idp = line;
+	while (isspace(*idp)) idp++;
+	splitp = idp;
+	while ((*splitp) && (!isspace(*splitp))) splitp++;
+        if (*splitp) {
+          *splitp = 0;
+          *splitp++;
+          tp = splitp;
+          tp += strlen(tp)-1;
+          while ((tp > splitp) && (isspace(*tp))) { *tp = 0; tp--; }
+        }
+	
+        strp = strstr(addresses, idp);
+        if (strp != NULL) {
+          strp += strlen(idp);
+          if (isspace(*strp) || (*strp == '>') || (*strp == 0)) {
+
+            /** Yes, remove address from destination string **/
+            strp2 = strstr(destination, idp);
+            while (strp2 && *strp2 && (*strp2 != ' ')) {
+              *strp2 = ' '; strp2++;
+            }
+	    /** and from the addresses string **/
+	    strp2 = strstr(addresses, idp);
+	    while (strp2 && *strp2 && (*strp2 != ' ')) {
+	      *strp2 = ' '; strp2++;
+	    }
+	    /** and add it to the pgplinks string **/
+	    strcat(pgplinks, " ");
+	    strcat(pgplinks, splitp);
+          }
+        }
+        *line = 0;
+      }
+      fclose(fp);
+    }
+
+
+    /** create output pipe **/
+    if (pipe(filedes) < 0)
+      emergency_exit();
+
+    pid = fork();
+
+    if (pid < 0)  { /** fork error **/
+      close(filedes[0]);
+      close(filedes[1]);
+      emergency_exit();
+    }
+
+    if (pid == 0) { /** child **/
+      setgid(groupid);
+      setuid(userid);
+
+      /** redirection **/
+      close(STDOUT_FILENO); dup(filedes[1]); close(filedes[1]); close(filedes[0]);
+      /** Call PGP **/
+      execl(PGP_PATH, "pgp", "+verbose=0", "+force", "-kv", keyring, NULL);
+
+      emergency_exit(); /** exec failed **/
+    }
+		    /** parent **/
+    close(filedes[1]);
+
+    /** create FILE from descriptor **/
+    if ((fp = fdopen (filedes[0], "r")) == NULL) 
+      emergency_exit();
+
+    /** read output **/
+    while (fgets(line, VERY_LONG_STRING - 1, fp) != NULL) {
+      /** Check for line starting with "pub " or an alias address **/
+      if ((strncmp(line, "pub ", 4) == 0) ||
+	  (strncmp(line, "                              ", 30) == 0)) {
+	strp = line; while (*strp) { *strp = tolower(*strp); strp++; }
+	/** one of the destination addresses? **/
+	strcpy(tmp, addresses); strp = strtok(tmp, delim); 
+	while (strp != NULL) {
+	  strp2 = strstr(line, strp);
+	  if (strp2 != NULL) {
+	    strp2 += strlen(strp);
+	    if (isspace(*strp2) || (*strp2 == '>') || (*strp2 == 0)) {
+
+	      /** Yes, remove address from destination string **/
+	      strp2 = strstr(destination, strp);
+	      while (strp2 && *strp2 && (*strp2 != ' ')) {
+		*strp2 = ' '; strp2++;
+	      }
+
+	    }
+	  }
+       
+	  strp = strtok(NULL, delim);
+	}
+	
+      }
+      
+    }
+    fclose(fp);
+
+    /** wait for termination of child **/
+    waitpid(pid, &status, 0);
+    if (status != 0) {
+      if (sleepmsg > 0) sleep((sleepmsg + 1) / 2);
+      ClearLine(prompt_line);
+      error(catgets(elm_msg_cat, ElmSet, ElmMailNotSend, "PGP lookup failed - Mail not sent."));
+      return (-1);
+    }
+
+    strp = destination;
+    while (*strp == ' ')
+      strp++;
+  } /*!clearsign*/
+
+  if ((strp&&*strp) && !clearsign) {
+    MCsprintf(msgbuf, catgets(elm_msg_cat, ElmSet, ElmMissingPGPKey,
+    "Can't encrypt, missing public key(s) - sign and send anyway? (%c/%c) "),
+						  *def_ans_yes, *def_ans_no);
+    MoveCursor(LINES,0);
+    CleartoEOLN();
+    ch = want_to(msgbuf, *def_ans_no, LINES, 0);
+    if (ch != *def_ans_yes) {     /* user says no! */
+      return(-1);
+    }
+  }
+
+  if ((strp && ! *strp) && (!clearsign)) {
+    /** 
+       Found public keys for all destination addresses, so sign 
+       and encrypt the message 
+    **/
+    if (!batch_only) {
+      PutLine0(LINES,0,catgets(elm_msg_cat, ElmSet, ElmSendingMail,
+               "Encrypting mail..."));
+      CleartoEOLN();
+    }
+
+    arg[0] = "pgp"; arg[1] = "-sweat"; arg[2] = "+verbose=0";
+    arg[3] = "+force"; arg[4] = "+batchmode"; arg[5]="+encrypttoself";
+    i = 6;
+    if (pubkeyring != NULL) {
+      arg[i] = pubkeyring; i++;
+    }
+    arg[i] = filename; i++;
+
+    strcat(addresses, pgplinks); /* add manual links */
+    strp = strtok(addresses, delim);
+    while ((strp != NULL) && (i< 254)) {
+      if (*strp) {
+        arg[i] = strp; i++; 
+      }
+      strp = strtok(NULL, delim);
+    }
+    arg[i] = NULL;
+    if (invoke_pgp_argv(-1, -2, -1, arg) == 0) {
+      strcat(filename,".asc");
+      pgp_encoded++;
+      return 0;
+    } else {
+      if (sleepmsg > 0)
+        sleep((sleepmsg + 1) / 2);
+      ClearLine(prompt_line);
+      error(catgets(elm_msg_cat, ElmSet, ElmMailNotSend, "Encryption failed."));
+      return(-1);
+    }
+  }
+
+dont_encrypt:
+  /** Not all public keys found, so just sign the message **/
+  if (!batch_only) {
+    PutLine0(LINES,0,catgets(elm_msg_cat, ElmSet, ElmSendingMail,
+             "Signing mail..."));
+    CleartoEOLN();
+  }
+
+  if (invoke_pgp(-1, -2, -1, "-staw", "+verbose=0", "+clearsig=on", "+force",
+      "+batchmode", filename, NULL) == 0) {
+    strcat(filename,".asc");
+    return 0;
+  } else {
+    if (sleepmsg > 0)
+      sleep((sleepmsg + 1) / 2);
+    ClearLine(prompt_line);
+    error(catgets(elm_msg_cat, ElmSet, ElmMailNotSend, "Signing failed."));
+    return(-1);
+  }
+
+  return 0;
+}  
+
diff -u -r --new-file ../oldelm/src/newmbox.c ./src/newmbox.c
--- ../oldelm/src/newmbox.c	Sat May 14 20:42:59 1994
+++ ./src/newmbox.c	Wed Aug 30 00:54:24 1995
@@ -1,8 +1,8 @@
 
-static char rcsid[] = "@(#)$Id: newmbox.c,v 5.36 1994/05/14 18:42:57 syd Exp $";
+static char rcsid[] = "@(#)$Id: newmbox.c,v 5.36.2 1995/02/20 23:00:00 rm Exp $";
 
 /*******************************************************************************
- *  The Elm Mail System  -  $Revision: 5.36 $   $State: Exp $
+ *  The Elm Mail System  -  $Revision: 5.36.2 $   $State: Exp $
  *
  *			Copyright (c) 1988-1992 USENET Community Trust
  *			Copyright (c) 1986,1987 Dave Taylor
@@ -14,6 +14,15 @@
  *
  *******************************************************************************
  * $Log: newmbox.c,v $
+ * Revision 5.36.2  1995/02/20  23:00:00  rm
+ * Don't check for PGP headers. Check all messages for PGP contents.
+ * From: rmuchsel@iiic.ethz.ch
+ *
+ * Revision 5.36.1  1994/01/08  00:21:13  Mic
+ * Checks mail specificaly for pgp headers, since it can handle these messages
+ * without metamail
+ * From: egd017@cent1.lancs.ac.uk
+ *
  * Revision 5.36  1994/05/14  18:42:57  syd
  * Here are some more of fixes to correctly call fflush() and unlock() in sequence.
  * From: Jukka Ukkonen <ukkonen@csc.fi>
@@ -997,8 +1006,17 @@
 	      else in_to_list = FALSE;
 	    }
 	  }
-	  if (in_header == FALSE && first_word(buffer, START_ENCODE))
+	  if (in_header == FALSE) {
+	    if (first_word(buffer, START_ENCODE))
 	    current_header->encrypted = 1;
+	    else if (first_word(buffer, BEGIN_PGP_MESSAGE))
+	      current_header->status |= PGP_MESSAGE;
+	    else if (first_word(buffer, BEGIN_PGP_SIGNATURE))
+              current_header->status |= PGP_SIGNATURE;
+	    else if (first_word(buffer, BEGIN_PGP_KEY))
+              current_header->status |= PGP_KEY;
+	  } 
+
 	  fbytes += (long) line_bytes;
 	  content_remaining -= (long) line_bytes;
 	}
diff -u -r --new-file ../oldelm/src/p_screen.c ./src/p_screen.c
--- ../oldelm/src/p_screen.c	Thu Jan  1 01:00:00 1970
+++ ./src/p_screen.c	Wed Aug 30 20:17:42 1995
@@ -0,0 +1,153 @@
+/**  pgpkey screen display routines for ELM program
+     most stuff herein stolen from a_screen.c
+**/
+
+#include "headers.h"
+#include "s_pgpkey.h"
+#include "pgpkey.h"
+
+char *show_status();
+/*char *alias_type();*/
+
+pgpkey_screen(modified)
+int modified;
+{
+  /* Stolen from showscreen() */
+
+  ClearScreen();
+
+  pgpkey_title(modified);
+
+  last_header_page = -1;	 	/* force a redraw regardless */
+  show_headers();
+
+  if (mini_menu)
+    show_pgpkey_menu();
+
+  show_last_error();
+
+  if (hp_terminal)
+    define_softkeys(PGPKEY);   /* not much use in this yet... */
+}
+
+pgpkey_title(modified)
+int modified;
+{
+  /** display a new title line, due to re-sync'ing the keys **/
+  /* Stolen from update_title() */
+
+  char buffer[SLEN];
+  char modmsg[SLEN];
+  char keyringbuf[SLEN], *c;
+
+  if (modified) {
+    strcpy(modmsg, catgets(elm_msg_cat, PgpkeySet, PgpkeyDummy,
+		"(modified) "));
+  }
+  else {
+    modmsg[0] = '\0';
+  }
+ 
+  if (keyring != NULL) {
+    if (strlen(keyring)<COLUMNS-45)  /* make sure it fits */
+      strcpy(keyringbuf,keyring);
+    else {
+      strcpy(keyringbuf,"..");
+      c=keyring;
+      while (*c) c++;
+      c-=COLUMNS-47;
+      strcat(keyringbuf,c);
+    }
+  }
+  else
+    strcpy(keyringbuf,"<default>");
+
+  if (selected)
+    MCsprintf(buffer, catgets(elm_msg_cat, PgpkeySet, PgpkeyDummy,
+			      "Keyring '%s': %d shown out of %d %s[ELM %s]"),
+	      keyringbuf, selected, message_count, modmsg, version_buff);
+  else if (message_count == 1)
+    sprintf(buffer, catgets(elm_msg_cat, PgpkeySet, PgpkeyDummy,
+			    "Keyring '%s': 1 key %s[ELM %s]"), keyringbuf, modmsg,
+	    version_buff);
+  else
+    MCsprintf(buffer, catgets(elm_msg_cat, PgpkeySet, PgpkeyDummy,
+			      "Keyring '%s': %d keys %s[ELM %s]"),
+	      keyringbuf, message_count, modmsg, version_buff);
+
+  ClearLine(1);
+
+  Centerline(1, buffer);
+}
+
+show_pgpkey_menu()
+{
+  /** write pgpkey menu... **/
+
+  if (user_level == RANK_AMATEUR) {	/* Give less options  */
+    Centerline(LINES-7, catgets(elm_msg_cat, PgpkeySet, PgpkeyDummy,
+				"You can use any of the following commands by pressing the first character;"));
+    Centerline(LINES-6, catgets(elm_msg_cat, PgpkeySet, PgpkeyDummy,
+				"m)odify key (trust or id), d)elete key, r)emove signature, s)ign key"));
+    Centerline(LINES-5, catgets(elm_msg_cat, PgpkeySet, PgpkeyDummy,
+				"q)uit to main menu.  To view a key, press <return>."));
+    Centerline(LINES-4, catgets(elm_msg_cat, PgpkeySet, PgpkeyDummy,
+				"j = move down, k = move up, ? = help"));
+  }
+  else {
+    Centerline(LINES-7, catgets(elm_msg_cat, PgpkeySet, PgpkeyDummy,
+				"PGP-key commands:  ?=help, <n>=set current to n, /=search pattern"));
+    Centerline(LINES-6, catgets(elm_msg_cat, PgpkeySet, PgpkeyDummy,
+				"c)hange keyring, d)elete, D)isable/enable, e)dit key/address links,"));
+    Centerline(LINES-5, catgets(elm_msg_cat, PgpkeySet, PgpkeyDummy,
+				"l)imit display, m)odify trust or ID, M)ail key, n)ew key/address link,"));
+    Centerline(LINES-4, catgets(elm_msg_cat, PgpkeySet, PgpkeyDummy,
+                                "r)emove signature, s)ign, t)ag, u)ndelete, or e(x)it"));
+  }
+}
+
+
+build_pgpkey_line(buffer, entry, message_number, highlight)
+char *buffer;
+struct _pgpkeyS *entry;
+int message_number, highlight;
+{
+  /** Build in buffer the alias header ... entry is the current
+    message entry, 'highlight' is either TRUE or FALSE,
+    and 'message_number' is the number of the message.
+    (there's lots of mindboggling truth in this comment... :-)
+  **/
+
+  char mybuffer[SLEN];
+
+  /** Note: using 'strncpy' allows us to output as much of the
+    subject line as possible given the dimensions of the screen.
+    The key is that 'strncpy' returns a 'char *' to the string
+    that it is handing to the dummy variable!  Neat, eh? **/
+  /* Stolen from build_header_line() */
+
+  int name_width;
+
+  /* Note that one huge sprintf() is too hard for some compilers. */
+
+  sprintf(buffer, "%s%c%c%c%-5d",
+	  (highlight && arrow_cursor)? "->" : "  ",
+	  entry->status & DELETED ? 'D' : ' ',
+	  entry->type==KEY_TYPE_PUBLIC?'P':entry->type==KEY_TYPE_SECRET?'S':'p',
+	  (entry->status & TAGGED?  '+' : ' '),
+	  message_number);
+
+  /* Set the name display width. */
+  name_width = COLUMNS-10;
+
+  /* Put the key id and user id in local buffer */
+  sprintf(mybuffer, "%s %s", entry->key_id, entry->user_id);
+
+  /* complete line with name, type and alias. */
+  sprintf(buffer + strlen(buffer), "%-*.*s",
+	  /* give max and min width parameters for 'name' */
+	  name_width, name_width, mybuffer);
+}
+
+
+
diff -u -r --new-file ../oldelm/src/pattern.c ./src/pattern.c
--- ../oldelm/src/pattern.c	Mon May 16 01:05:20 1994
+++ ./src/pattern.c	Wed Aug 30 20:17:42 1995
@@ -135,7 +135,8 @@
 	if (function == TAGGED) {	/* are messages already tagged??? */
 	  for (i=0; i < message_count; i++)
 	    if (ison(ifmain(headers[i]->status,
-	                    aliases[i]->status),TAGGED))
+	                    aliases[i]->status,
+			    pgpkey[i]->status),TAGGED))
 	      tagged++;
 
 	  if (tagged) {
@@ -158,6 +159,10 @@
 	      for (i=0; i < message_count; i++) {
 	        if (inalias)
 	          clearit(aliases[i]->status,TAGGED);
+		/* CHRIS BEGIN */
+		else if (inpgpkey)
+		  clearit(pgpkey[i]->status,TAGGED);
+		/* CHRIS END */
 	        else
 	          clearit(headers[i]->status,TAGGED);
 		show_new_status(i);
@@ -200,6 +205,29 @@
 	    }
 	  }
 	}
+	/* CHRIS BEGIN */
+	else if (inpgpkey) {
+	  for (i = 0; i < message_count; i++) {
+	    if (userid_matches(i, meta_pattern) ||
+	        keyid_matches(i, meta_pattern)) {
+	      if (! selected || (selected && (pgpkey[i]->status & VISIBLE))) {
+	        if (function == UNDELETE)
+	          clearit(pgpkey[i]->status, DELETED);
+	        else
+	          if ((function == DELETED) && (pgpkey[i]->type & SYSTEM)) {
+	            if(i == current - 1) curtag--;
+	            count--;
+	          }
+	          else
+	            setit(pgpkey[i]->status, function);
+	        show_new_status(i);
+	        if(i == current - 1) curtag++;
+	        count++;
+	      }
+	    }
+	  }
+	}
+	/* CHRIS END */
 	else {
 	  for (i = 0; i < message_count; i++) {
 	    if (from_matches(i, meta_pattern) ||
@@ -299,6 +327,19 @@
 	    }
 	  }
 	}
+	/* CHRIS BEGIN */
+	else if (inpgpkey) {
+	  for (i = current; i < message_count; i++) {
+	    matched = userid_matches(i, pattern) || keyid_matches(i, pattern);
+	    if (matched) {
+	      if (!selected || (selected && pgpkey[i]->status & VISIBLE)) {
+	        current = ++i;
+	        return(1);
+	      }
+	    }
+	  }
+	}
+	/* CHRIS END */
 	else {
 	  if (anywhere) {
 	      return(match_in_message(pattern));
@@ -378,6 +419,32 @@
 		pat) );
 }
 
+/* CHRIS BEGIN */
+int
+userid_matches(message_number, pat)
+int message_number;
+char *pat;
+{
+	/** Returns true if the pattern occurs in it's entirety
+	    in the user id of the indicated key **/
+
+	return( in_string(shift_lower(pgpkey[message_number]->user_id),
+		pat) );
+}
+
+int
+keyid_matches(message_number, pat)
+int message_number;
+char *pat;
+{
+	/** Returns true if the pattern occurs in it's entirety
+	    in the key id of the indicated key **/
+
+	return( in_string(shift_lower(pgpkey[message_number]->key_id),
+		pat) );
+}
+/* CHRIS END */
+
 int
 address_matches(message_number, pat)
 int message_number;
@@ -394,7 +461,7 @@
 	result = get_alias_address(aliases[message_number]->alias,TRUE,&dummy);
 	if (result != NULL)
 		return(in_string(shift_lower(result), pat) );
-	return(NULL);
+	return(0);
 }
 
 match_in_message(pat)
diff -u -r --new-file ../oldelm/src/pgpkey.c ./src/pgpkey.c
--- ../oldelm/src/pgpkey.c	Thu Jan  1 01:00:00 1970
+++ ./src/pgpkey.c	Wed Aug 30 22:15:49 1995
@@ -0,0 +1,1466 @@
+/*
+ * PGP key management
+ *
+ * Initial version by Chris Blum <chris@phil.uni-sb.de>
+ *
+ */
+
+/*
+ * Known problems:
+ *
+ *   - tagging isn't any good yet
+ *   - NLS support is still bogus (guess that's not the only part of Elm
+ *     with messy NLS; heck, learn english, dummies :-)
+ *
+ *
+ * Changes:
+ *
+ * 06/04/95 caronni@tik.ethz.ch
+ *    Bugfix to allow change of keyrings / removed newkeyring
+ * 08/27/95 muchsel@acm.org
+ *    Added mail key & new link support, bugfixes
+ * 08/29/95 caronni@tik.ee.ethz.ch
+ *    allowed for smarter search of keyring-folder: introduced
+ *    pgpkey_guesspath
+ * 08/30/95 muchsel@acm.org
+ *    bug fixes
+ */
+
+
+#include "headers.h"
+#include "s_elm.h"
+#include "s_pgpkey.h"
+#include "pgpkey.h"
+#include <errno.h>
+#include <sys/stat.h>
+
+#include <string.h>
+#include <ctype.h>
+#include <pwd.h>
+#include <sys/types.h>
+
+
+#define pgpkeys message_count   /* current number of keys in pgpkey list */
+
+struct _pgpkeyS **pgpkey = NULL;
+
+char *keyring    = NULL;
+char *pubkeyring = NULL;
+
+
+char *pgpkey_guesspath(void) /*gec*/
+{
+  char temp[VERY_LONG_STRING], *p;
+  static char *pgppath = NULL;
+
+  if (pgppath) return pgppath;
+
+  if (!(p=getenv("PGPPATH"))) {
+      if (!(p=getenv("HOME"))) return NULL;
+      strcpy(temp,p);
+      if (strlen(temp) < 1) return NULL;
+      if (temp[strlen(temp)-1] != '/') strcat(temp,"/");
+      strcat(temp,".pgp/");
+      pgppath=strdup(temp);
+  } else {
+      strcpy(temp,p);
+      if (strlen(temp) < 1) return NULL;
+      if (temp[strlen(temp)-1] != '/') strcat(temp,"/");
+      pgppath=strdup(temp);
+  }
+  return pgppath;
+}
+
+void pgpkey_clear_pgpkeys()
+{
+  if (pgpkey) {
+    int i,n;
+    struct _pgpkey_sigaliasS *a,*aa;
+
+    for (i=0; i<pgpkeys; i++) {
+      a=pgpkey[i]->sigalias;
+      while (a) {
+	aa=a->next;
+	free(a);
+	a=aa;
+      }
+      free(pgpkey[i]);
+    }
+    free(pgpkey);
+    pgpkey=NULL;
+  }
+  pgpkeys=0;
+}
+
+
+void pgpkey_generate_keylist()
+{
+  int tf;
+  FILE *f;
+  char tempfilename[SLEN];
+  char line[SLEN];
+  char *c;
+  int found;
+
+  error(catgets(elm_msg_cat, PgpkeySet, PgpkeyDummy,
+                "Generating key list..."));
+  
+  pgpkey_clear_pgpkeys();
+  tmpnam(tempfilename);
+  tf=open(tempfilename,O_CREAT|O_WRONLY,0600 /* not very beautiful, I know */);
+  if (tf<0) {
+    error(catgets(elm_msg_cat, PgpkeySet, PgpkeyDummy,
+		  "Couldn't create temporary file"));
+    return;
+  }
+  if (invoke_pgp(-1,tf,-2,"-kvvc","+batchmode","",keyring,NULL)) {
+    error(catgets(elm_msg_cat, PgpkeySet, PgpkeyDummy,
+		  "Couldn't extract key list from keyring"));
+    close(tf);
+    unlink(tempfilename);
+    return;
+  }
+  close(tf);
+
+  f=fopen(tempfilename,"r");
+  if (!f) {
+    error(catgets(elm_msg_cat, PgpkeySet, PgpkeyDummy,
+		  "Couldn't read temporary file"));
+    return;
+  }
+  found=0;  /* look for key table start */
+  while (fgets(line,SLEN,f)) {
+    if (!strncmp(line,"Key ring:",9)) {  /* get full name of keyring used */
+      char *c, *d;
+      c=line;
+      while (*c&&*c!='\'') c++;
+      if (*c) c++;
+      if (keyring == NULL) {
+        keyring    = malloc(SLEN);
+        pubkeyring = malloc(SLEN);
+      }
+      d = keyring;
+      while (*c&&*c!='\''&&keyring-d<SLEN-1) *d++=*c++;
+      *d = 0;
+      strcpy(pubkeyring,"+pubring=");
+      strcat(pubkeyring,keyring);
+    }
+    else if (!strncmp(line,"Type ",5)) {   /* table start found? */
+      found=1;
+      break;
+    }
+  }
+  if (!found) {
+    fclose(f);
+    error(catgets(elm_msg_cat, PgpkeySet, PgpkeyDummy,
+		  "PGP produced unparseable output, can't generate key list"));
+    return;
+  }
+
+  while (fgets(line,SLEN,f)) {
+    if (isdigit(*line)) break;   /* we're done when the key count appears */
+    if (!strncmp(line,"pub",3)||!strncmp(line,"sec",3)) {
+      struct _pgpkeyS *n;
+      char *c,*d;
+
+      /* resize the array of pointers to key structures to hold one
+         more pointer */
+      pgpkey=realloc(pgpkey,(pgpkeys+1)*sizeof(struct _pgpkeyS *));
+      if (!pgpkey) {
+      notenoughcore:
+	error(catgets(elm_msg_cat, PgpkeySet, PgpkeyDummy,
+		      "Cannot allocate enough memory"));
+	pgpkeys=0;
+	break;
+      }
+      /* now allocate a key structure buffer */
+      n=malloc(sizeof(struct _pgpkeyS));
+      if (!n) goto notenoughcore;
+      /* put reference into table */
+      pgpkey[pgpkeys]=n;
+      /* and let the world know about the new key */
+      pgpkeys++;
+
+      /* OK, so we found a new key.  Memory for its table entry has
+	 been allocated.  Let's now initialize the beast and fill it
+	 with data from the line just read, then see if there are
+	 aliases and/or signatures by just reading on in the file :-) */
+      if (*line=='p') {
+	if (line[3]!='@') n->type=KEY_TYPE_PUBLIC;  /* public key */
+	else n->type=KEY_TYPE_DISABLED;  /* disabled public key */
+      }
+      else if (*line=='s') n->type=KEY_TYPE_SECRET;  /* secret key */
+      n->bits=atoi(line+4);
+      c=line+3;
+      while (*c&&*c!='/') c++;
+      if (*c) c++;
+      strncpy(n->key_id,c,8);
+      n->key_id[8]='\0';
+      while (*c&&!isspace(*c)) c++;
+      while (*c&&isspace(*c)) c++;
+      strncpy(n->date,c,10);
+      n->date[10]='\0';
+      while (*c&&!isspace(*c)) c++;
+      while (*c&&isspace(*c)) c++;
+      d=n->user_id;
+      while (*c&&*c!='\n'&&*c!='\r'&&d-n->user_id<IDLEN-1) *d++=*c++;
+      *d='\0';
+      n->sigalias=NULL;
+      n->status=0;
+    }
+    else if (!strncmp(line,"sig",3)) {
+      struct _pgpkey_sigaliasS *s,*ss;
+      char *c,*d;
+
+      /* A signature to the last key has been found */
+      s=malloc(sizeof(struct _pgpkey_sigaliasS));
+      if (!s) goto notenoughcore;
+      /* initialize signature block and read data from current line */
+      s->type=TYPE_SIGNATURE; /* type is 'signature' */
+      s->next=NULL;
+      c=line+3;
+      while (*c&&isspace(*c)) c++;
+      strncpy(s->id,c,8);
+      s->id[8]='\0';
+      while (*c&&!isspace(*c)) c++;
+      while (*c&&isspace(*c)) c++;
+      d=s->name;
+      while (*c&&*c!='\n'&&*c!='\r'&&d-s->name<IDLEN-1) *d++=*c++;
+      *d=0;
+      /* now add it to the signature and alias chain of the key it belongs to */
+      ss=pgpkey[pgpkeys-1]->sigalias;
+      if (!ss) pgpkey[pgpkeys-1]->sigalias=s;
+      else {
+	while (ss->next) ss=ss->next;
+	ss->next=s;
+      }
+    }
+    else if (isspace(*line)) {
+      if ((c=strchr(line,'='))&&c-line<30) {    /* key fingerprint */
+	char *d;
+
+	c++;
+	while (*c&&isspace(*c)) c++;
+	d=c;
+	while (*c&&*c!='\r'&&*c!='\n') c++;
+	*c=0;
+	strcpy(pgpkey[pgpkeys-1]->fingerprint,d);
+      }
+
+      else {  /* alias */
+	struct _pgpkey_sigaliasS *a,*aa;
+	char *c,*d;
+
+	/* An alias to the last key has been found */
+	a=malloc(sizeof(struct _pgpkey_sigaliasS));
+	if (!a) goto notenoughcore;
+	/* initialize signature block and read data from current line */
+	a->type=TYPE_ALIAS;  /* type is 'alias' */
+	a->id[0]='\0';
+	a->next=NULL;
+	c=line+3;
+	while (*c&&isspace(*c)) c++;
+	d=a->name;
+	while (*c&&*c!='\n'&&*c!='\r'&&d-a->name<IDLEN-1) *d++=*c++;
+	*d=0;
+	/* now add it to the signature and alias chain of the key it belongs to */
+	aa=pgpkey[pgpkeys-1]->sigalias;
+	if (!aa) pgpkey[pgpkeys-1]->sigalias=a;
+	else {
+	  while (aa->next) aa=aa->next;
+	  aa->next=a;
+	}
+      }
+    }
+    /* we ignore lines that we can't parse; not exactly proper, but
+       good enough I guess */
+  }
+  fclose(f);
+  unlink(tempfilename);
+  clear_error();
+}
+
+
+int pgpkey_update_keyring(int dontask)
+{
+  int update_needed = 0;
+  int i;
+  char ch;
+  char msgbuf[256];
+  int deleted, not_deleted;
+
+  for (i=0; i<pgpkeys; i++) update_needed += !!(pgpkey[i]->status & DELETED); /* maybe more in the future */
+  if (!update_needed) return 0;   /* no update needed, leave the keyring as it is */
+
+  if (!dontask) {
+    MCsprintf(msgbuf, catgets(elm_msg_cat, PgpkeySet, PgpkeyDummy,
+			      "Keyring modified - delete %d key%s? (%c/%c) "),
+	      update_needed, update_needed==1?"":"s", *def_ans_yes, *def_ans_no);
+    ch = want_to(msgbuf, *def_ans_no, LINES-2, 0);
+  }
+  if (!dontask && ch != *def_ans_yes) {     /* user says no! */
+    if (sleepmsg > 0)
+      sleep((sleepmsg + 1) / 2);
+    ClearLine(LINES-2);
+    error(catgets(elm_msg_cat, PgpkeySet, PgpkeyDummy, "No keys deleted."));
+    return 0;
+  }
+  /* we've got a licence to kill */
+  deleted=not_deleted=0;
+  for (i=0; i<pgpkeys; i++) {
+    char userbuf[20];
+
+    sprintf(userbuf, "0x%s", pgpkey[i]->key_id);
+
+    if (pgpkey[i]->status & DELETED) {
+      if (invoke_pgp(-1,-1,-1,"-kr","+verbose=0",userbuf,keyring,NULL)) {
+	error1(catgets(elm_msg_cat, PgpkeySet, PgpkeyDummy,
+		      "Couldn't delete key %s."),userbuf);
+	not_deleted++;
+      }
+      else {
+	error1(catgets(elm_msg_cat, PgpkeySet, PgpkeyDummy,
+		       "Key %s deleted."),userbuf);
+	deleted++;
+      }
+    if (sleepmsg > 0)
+      sleep((sleepmsg + 1) / 2);
+    }
+  }
+  sprintf(msgbuf, catgets(elm_msg_cat, PgpkeySet, PgpkeyDummy,
+			  "%d key%s deleted, %d left intact."),
+	  deleted, deleted==1?"":"s", not_deleted);
+  error(msgbuf);
+  return 1;
+ }
+
+
+
+
+list_keyrings(numlines, wildcard)
+unsigned numlines;
+char *wildcard;
+{
+	/** List the keyrings in the user's PGPPATH directory.  This is
+	    simply a call to "ls -C" unless there is a wildcard, in
+	    which case it's "ls -C wildcard".  Note that wildcards can
+	    refer either to the folder directory (in which case they
+	    start with an '=') or a general directory, in which case we
+	    take them at face value.
+	    Numlines is the number of lines to scroll afterwards. This is
+	    useful when a portion of the screen needs to be cleared for
+	    subsequent prompts, but you don't want to overwrite the
+	    list of folders.
+	**/
+
+	char buffer[SLEN], *p = pgpkey_guesspath();
+
+	Raw(OFF | NO_TITE);
+	ClearScreen();
+	MoveCursor(LINES, 0);
+	if ( NULL == wildcard )
+	{
+	  sprintf(buffer, "cd %s;ls -C", p ? p:"./");
+	  printf(catgets(elm_msg_cat, PgpkeySet, PgpkeyDummy,
+		"\n\rContents of your %s directory%s:\n\r\n\r"),
+		p ? "PGP" : "current", 
+		p ? "" : " (no PGPPATH or .pgp folder)");
+	  (void) system_call(buffer, 0); 
+	}
+	else
+	{
+	  if (( *wildcard == '=' ) || ( *wildcard == '+' ))
+	  {
+	    char *what;
+	    what=*wildcard=='+'?(p?p:"./"):folders;
+	    sprintf(buffer, "cd %s;ls -C %s", what, wildcard+1);
+	    printf(catgets(elm_msg_cat, PgpkeySet, PgpkeyDummy,
+		"\n\rKeyrings which match `%s':\n\r\n\r"), wildcard+1);
+	  }
+          else
+	  {
+	    sprintf(buffer, "ls -C %s", wildcard);
+	    printf(catgets(elm_msg_cat, PgpkeySet, PgpkeyDummy,
+		"\n\rKeyrings which match `%s':\n\r\n\r"), wildcard);
+	  }
+	  (void) system_call(buffer, 0); 
+	}
+	while(numlines--)
+	    printf("\n\r");
+	Raw(ON | NO_TITE);
+}
+
+/* sneaked from file.c, expand_filename() */
+int
+expand_keyringname(filename, use_cursor_control)
+char *filename;
+int use_cursor_control;
+{
+	/** Expands	~/	to the current user's home directory
+			~user/	to the home directory of "user"
+			=,+	to the user's Mail/PGP directory
+			!	to the default keyring
+			shell variables (begun with $)
+
+	    Side effect: strips off trailing blanks
+
+	    Returns 	1	upon proper expansions
+			0	upon failed expansions
+	 **/
+
+	char temp_filename[SLEN], varname[SLEN], env_value[SLEN],
+	     logname[SLEN], *ptr, *address, *get_alias_address(),
+	     buffer[LONG_STRING];
+	register int iindex;
+	int too_long = FALSE;
+	struct passwd *pass, *getpwnam();
+	char *getenv();
+	char *pgppath;
+
+	pgppath=pgpkey_guesspath();
+	if (!pgppath) pgppath="./";
+	ptr = filename;
+	while (*ptr == ' ') ptr++;	/* leading spaces GONE! */
+	strcpy(temp_filename, ptr);
+
+	/** New stuff - make sure no illegal char as last **/
+	/** Strip off any trailing backslashes or blanks **/
+
+	ptr = temp_filename + strlen(temp_filename) - 1;
+	while (*ptr == '\n' || *ptr == '\r'
+	       || *ptr == '\\' || *ptr == ' ' || *ptr == '\t') {
+	    *ptr-- = '\0';
+	}
+
+	if (temp_filename[0] == '~') {
+	  if(temp_filename[1] == '/')
+	    sprintf(filename, "%s%s%s",
+		  home, (lastch(home) != '/' ? "/" : ""), &temp_filename[2]);
+	  else {
+	    for(ptr = &temp_filename[1], iindex = 0; *ptr && *ptr != '/'; ptr++, iindex++)
+	      logname[iindex] = *ptr;
+	    logname[iindex] = '\0';
+	    if((pass = getpwnam(logname)) == NULL) {
+	      dprint(3,(debugfile, 
+		      "Error: Can't get home directory for %s (%s)\n",
+		      logname, "expand_filename"));
+	      if(use_cursor_control)
+		error1(catgets(elm_msg_cat, ElmSet, ElmDontKnowHomeCursor,
+			"Don't know what the home directory of \"%s\" is!"),
+			logname);
+	      else
+		printf(catgets(elm_msg_cat, ElmSet, ElmDontKnowHomePrintf,
+		    "\n\rDon't know what the home directory of \"%s\" is!\n\r"),
+		    logname);
+	      return(0);
+	    }
+	    sprintf(filename, "%s%s", pass->pw_dir, ptr);
+	  }
+
+	}
+	else if (temp_filename[0] == '=' || temp_filename[0] == '+' ) {
+	  char *what;
+	  what=temp_filename[0]=='+'?pgppath:folders;
+	  sprintf(filename, "%s%s%s", what, 
+		(temp_filename[1] != '/' && lastch(what) != '/')? "/" : "",
+	  	&temp_filename[1]);
+	}
+	else if (temp_filename[0] == '$') {	/* env variable! */
+	  for(ptr = &temp_filename[1], iindex = 0; isalnum(*ptr); ptr++, iindex++)
+	    varname[iindex] = *ptr;
+	  varname[iindex] = '\0';
+
+	  env_value[0] = '\0';			/* null string for strlen! */
+	  if (getenv(varname) != NULL)
+	    strcpy(env_value, getenv(varname));
+
+	  if (strlen(env_value) == 0) {
+	    dprint(3,(debugfile, 
+		    "Error: Can't expand environment variable $%s (%s)\n",
+		    varname, "expand_filename"));
+	    if(use_cursor_control)
+	      error1(catgets(elm_msg_cat, ElmSet, ElmDontKnowValueCursor,
+		    "Don't know what the value of $%s is!"), varname);
+	    else
+	      printf(catgets(elm_msg_cat, ElmSet, ElmDontKnowValuePrintf,
+		    "\n\rDon't know what the value of $%s is!\n\r"), varname);
+	    return(0);
+	  }
+
+	  sprintf(filename, "%s%s%s", env_value, 
+		(*ptr && *ptr != '/' && lastch(env_value) != '/')? "/" : "", ptr);
+
+	} else if (strcmp(temp_filename, "!") == 0) {
+	  strcpy(filename, "");
+	} else
+	  strcpy(filename, temp_filename);
+	  
+	return(1);
+}
+
+char *pgpkeyhelpmsg =
+  	  "You must specify a keyring to change to.  Several options are available:"
+	  "\n\r  '!'       will use your default pubring"
+	  "\n\r  '~/'      represents the current user's home directory"
+	  "\n\r  '~user/'  represents any user's home directory"
+	  "\n\r  '+'       represents the user's PGP directory"
+	  "\n\r  '='       represents the user's Mail directory"
+	  "\n\r  '$xxx'    represents the shell variable xxx\n\r"
+	  "\n\rYou may use wildcards in the name, exactly as you do in the shell."
+	  "\n\rIf you do this, a list of all matching files or folders will be"
+	  "\n\rprinted and you will be prompted for another name.  Thus typing"
+	  "\n\r'=a*' will print the names of all files in your PGP directory"
+	  "\n\rstarting with 'a'.  Typing 'b*.c' will print all files in your current"
+	  "\n\rdirectory starting with 'b' and ending in '.c'.  A star (*) will"
+	  "\n\rusually list everything.  See your local shell manual for more"
+	  "\n\rinformation on wildcards."
+	  "\n\rSometimes elm will help you out by suggesting a name.  If you want to"
+	  "\n\ruse the suggested name, simply hit return.  If you don't like it, hit"
+	  "\n\ryour erase or line erase keys.\n\r\n\r";
+
+int pgpkey_change_keyring()
+{
+  /* mostly sneaked from quit.c */
+	  /* Prompt user for name of keyring to change to.
+	   * If all okay with that keyring, leave the current keyring.
+	   * If leave goes okay
+	   * change to the keyring that the user specified.
+	   *
+	   * Return value indicates whether a redraw is needed.
+	   */
+
+	  int redraw = FALSE;
+	  char newfile[SLEN];
+
+	  char	*nameof();
+
+	  /* get new file name */
+
+	  MoveCursor(LINES-3, 30);
+	  CleartoEOS();
+	  PutLine0(LINES-3, 38, catgets(elm_msg_cat, ElmSet, ElmUseForHelp,
+		"(Use '?' for help)"));
+	  PutLine0(LINES-2,0, catgets(elm_msg_cat, PgpkeySet, PgpkeyDummy,
+		"Change to which keyring: "));
+	  while(1) {
+	    newfile[0] = '\0';
+	    (void) optionally_enter(newfile, LINES-2, 25, FALSE, FALSE);
+	    clear_error();
+
+	    if(*newfile == '\0') {	/* if user didn't enter a file name */
+	      MoveCursor(LINES-3, 30);	/* abort changing file process */
+	      CleartoEOS();
+	      return(redraw);
+
+	    }
+
+	    if (strcmp(newfile, "?") == 0) {
+	      /* user wants to list keyrings */
+	      ClearScreen();
+	      printf("%s", pgpkeyhelpmsg) ;
+	      PutLine0(LINES-2,0,catgets(elm_msg_cat, PgpkeySet, PgpkeyDummy,
+		"Change to which keyring: "));	/* reprompt */
+	      redraw = TRUE;		/* we'll need to clean the screen */
+	      continue ;
+	    }
+
+	    /* if user entered wildcard, list expansions and try again */
+	    if ( has_wildcards( newfile ) ) {
+	      list_keyrings( 4, newfile ) ;
+	      PutLine0(LINES-2,0,catgets(elm_msg_cat, PgpkeySet, PgpkeyDummy,
+		"Change to which keyring: "));	/* reprompt */
+	      redraw = TRUE ;
+	      continue ;  
+	    }
+
+	    /* user entered a file name - expand it */
+	    if (! expand_keyringname(newfile, TRUE))
+	      continue;	/* prompt again */
+
+	    /* Make sure this is a file the user can open, unless it's the
+	     * default keyring, which is openable even if empty */
+	    if (*newfile&&(errno = can_access(newfile, READ_ACCESS)) != 0 ) {
+	      if (strcmp(newfile, defaultfile) != 0 || errno != ENOENT) {
+		error1(catgets(elm_msg_cat, PgpkeySet, PgpkeyDummy,
+			"Can't open keyring '%s' for reading!"), newfile);
+		continue; 	/* prompt again */
+	      }
+	    }
+	    break;	/* exit loop - we got the name of a good file */
+	  }
+
+	  /* All's clear with the new file to go ahead and leave the current. */
+	  MoveCursor(LINES-3, 30);
+	  CleartoEOS();
+
+	  pgpkey_update_keyring(0);
+          if (*newfile) {
+            if (keyring == NULL) {
+              keyring    = malloc(SLEN);
+              pubkeyring = malloc(SLEN);
+            }
+	    strcpy(keyring,newfile);
+	    strcpy(pubkeyring,"+pubring=");
+	    strcat(pubkeyring, newfile);
+          }
+	  else 
+            if (keyring != NULL) {
+              free(keyring);
+              free(pubkeyring);
+              keyring    =
+	      pubkeyring = NULL;
+            }
+
+	  return 1;
+}
+
+
+int pgpkey_edit(int i)
+{
+  char userbuf[20];
+
+  sprintf(userbuf, "0x%s", pgpkey[i]->key_id);
+  ClearScreen();
+  if (invoke_pgp(-1,-1,-1,"-ke","+verbose=0",userbuf,keyring,NULL)) {
+    error1(catgets(elm_msg_cat, PgpkeySet, PgpkeyDummy,
+		   "Couldn't edit key %s."),userbuf);
+    sleep(3);
+  }
+  sleep(1);
+  return 2;  /* Always reload keyring */
+}
+
+
+int pgpkey_sign(int i)
+{
+  char userbuf[20];
+
+  sprintf(userbuf, "0x%s", pgpkey[i]->key_id);
+  
+  if (pgpkey[i]->type==KEY_TYPE_SECRET) {
+    error1(catgets(elm_msg_cat, PgpkeySet, PgpkeyDummy,
+		   "Can't sign a secret key."));
+    return 0;
+  }
+  ClearScreen();
+  invoke_pgp(-1,-1,-1,"-ks","+verbose=0",userbuf,keyring,NULL);
+  sleep(4);
+  return 2;  /* This mindboggingly stupid PGP doesn't provide return codes...
+		Reload keyring just in case */
+}
+
+
+int pgpkey_unsign(int i)
+{
+  char userbuf[20];
+
+  sprintf(userbuf, "0x%s", pgpkey[i]->key_id);
+  
+  if (pgpkey[i]->type!=KEY_TYPE_PUBLIC) {
+    if (pgpkey[i]->type == KEY_TYPE_SECRET)
+      error1(catgets(elm_msg_cat, PgpkeySet, PgpkeyDummy,
+  		   "Secret keys don't need signatures."));
+    else
+      error1(catgets(elm_msg_cat, PgpkeySet, PgpkeyDummy,
+             "Cannot remove signatures from disabled keys."));
+    return 0;
+  }
+  ClearScreen();
+  invoke_pgp(-1,-1,-1,"-krs","+verbose=0",userbuf,keyring,NULL);
+  sleep(4);
+  return 2;  /* PGP doesn't offer return codes; reload keyring just in case */
+}
+
+
+int pgpkey_disable(int i)
+{
+  char userbuf[20];
+
+  sprintf(userbuf, "0x%s", pgpkey[i]->key_id);
+
+  if (pgpkey[i]->type==KEY_TYPE_SECRET) {
+    error1(catgets(elm_msg_cat, PgpkeySet, PgpkeyDummy,
+		   "Secret keys can't be disabled/enabled"));
+    return 0;
+  }
+  ClearScreen();
+  invoke_pgp(-1,-1,-1,"-kd","+verbose=0",userbuf,keyring,NULL);
+  sleep(1);
+  return 2;  /* PGP doesn't offer proper return codes, so we can't decide
+		if it's really necessary to reload the keyring. :-( */
+}
+
+
+
+void pgpkey_management()
+{
+  int ch;
+  static int modified = 0;
+  int nutitle = 0;
+  char buf[256];
+#define this (current-1)
+  struct _pgpkey_sigaliasS *sa;
+  int currentline;
+  int reload = 0;
+  int i, leftoff, tagged;
+  char keynames1[VERY_LONG_STRING], buffer[SLEN], 
+       expanded_link[VERY_LONG_STRING], bufline[VERY_LONG_STRING];
+  char *strp;
+  char *delim = " ";
+
+  pgpkey_main_state();   /* save state for return to the main menu */
+  pgpkey_generate_keylist();
+  if (pgpkeys&&!current) current = 1;
+  pgpkey_screen(modified);
+
+  define_softkeys(PGPKEY);
+
+  while (1) {
+
+    /* sneaked from alias.c */
+#ifdef SIGWINCH
+          if (resize_screen) {
+            int newLINES, newCOLUMNS;
+
+            ScreenSize(&newLINES, &newCOLUMNS);
+            resize_screen = 0;
+            if (newLINES != LINES || newCOLUMNS != COLUMNS) {
+              LINES = newLINES, COLUMNS = newCOLUMNS;
+#undef max
+#define max(a,b)               ((a) < (b) ? (b) : (a))
+              if (mini_menu)
+                headers_per_page = max (LINES - 13, 1);
+              else
+                headers_per_page = max (LINES -  8, 1);   /* 5 more headers! */
+#undef max
+              redraw++;
+            }
+          }
+          else redraw = 0;
+#else
+          redraw = 0;
+#endif
+          nucurr = 0;
+          nufoot = 0;
+    
+          prompt(Prompt);
+          CleartoEOLN();
+          ch = ReadCh();
+          MoveCursor(LINES-3,strlen(Prompt)); CleartoEOS();
+          
+          dprint(3, (debugfile, "\n-- PGPKEY command: %c\n\n", ch));
+
+          switch (ch) {
+
+	  case '?':
+	    redraw += pgpkey_help();
+	    break;
+
+	  case '$':
+	    pgpkey_update_keyring(0);
+	    redraw++;
+	    reload++;
+	    break;
+
+	  case 'x':
+	  case 'X':
+	    if (modified && ch=='X') {
+	      MCsprintf(buf, catgets(elm_msg_cat, PgpkeySet, PgpkeyDummy,
+                              "Keyring modified - exit without changes being made permanent? (%c/%c) "),
+              *def_ans_yes, *def_ans_no);
+	      ch = want_to(buf, *def_ans_no, LINES-2, 0);
+	      if (ch != *def_ans_yes) break;
+	    }
+	    /* fall through */
+
+	  case 'i':
+	  case 'q':
+	  case 'Q':
+	    PutLine0(LINES-3, strlen(Prompt),
+		     catgets(elm_msg_cat, PgpkeySet, PgpkeyReturn,
+			     "Return to main menu..."));
+	    clear_error();
+	    if (ch=='i'||ch=='q'||ch=='Q') pgpkey_update_keyring(ch=='Q');
+	    pgpkey_clear_pgpkeys();
+	    pgpkey_main_state();             /* Done with keys menu */
+	    return;
+
+	  case RETURN:        /* view details on key */
+	  case LINE_FEED:
+	  case SPACE:
+          case 'v':
+	    if (current > 0) {
+	      clear_error();
+	      sa=pgpkey[this]->sigalias;
+	      while (1) {
+		ClearScreen();
+		pgpkey_title(modified);
+		sprintf(buf, catgets(elm_msg_cat, PgpkeySet, PgpkeyDummy,
+				     "Currently viewing PGP %d bit %s key ID %s created %s"),
+			pgpkey[this]->bits, pgpkey[this]->type!=KEY_TYPE_SECRET ?  "public":"secret",
+			pgpkey[this]->key_id, pgpkey[this]->date);
+		Centerline(3, buf);
+		sprintf(buf, catgets(elm_msg_cat, PgpkeySet, PgpkeyDummy,
+				     "Key belongs to: %s"),
+			pgpkey[this]->user_id);
+		Centerline(4, buf);
+		sprintf(buf, catgets(elm_msg_cat, PgpkeySet, PgpkeyDummy,
+				     "Key fingerprint: %s"),
+			pgpkey[this]->fingerprint);
+		Centerline(5, buf);
+		currentline=7;
+		if (pgpkey[this]->type==KEY_TYPE_DISABLED) {
+		  currentline++; /* make room for one more line */
+		  Centerline(6, "This public key is currently disabled in this keyring");
+		}
+
+		while (currentline<LINES-1 && sa) {
+		  if (sa->type==TYPE_ALIAS) {  /* alias */
+		    PutLine1(currentline,0, catgets(elm_msg_cat, PgpkeySet, PgpkeyDummy,
+						    "alias                  %s"), sa->name);
+		  }
+		  else {
+		    PutLine2(currentline,0, catgets(elm_msg_cat, PgpkeySet, PgpkeyDummy,
+						    "signed by ID %s  %s"),
+			     sa->id, sa->name);
+		  }
+		  sa=sa->next;
+		  currentline++;
+		}
+		Centerline(LINES, catgets(elm_msg_cat, PgpkeySet, PgpkeyDummy,
+					  "Hit <SPACE> to cycle, any other key to return."));
+		ch=getchar();
+		if (ch != SPACE) break;
+		if (sa == NULL) sa=pgpkey[this]->sigalias;
+	      }
+	      redraw++;
+	    }
+	    break;
+
+	  case 'c':  /* select other keyring */
+	    PutLine0(LINES-3, strlen(Prompt), catgets(elm_msg_cat,
+						      PgpkeySet, PgpkeyDummy,
+						      "Change keyring"));
+	    redraw+=pgpkey_change_keyring();
+	    if (redraw) pgpkey_generate_keylist();
+	    break;
+	    
+	  case 'm':  /* modify key */
+	    if (current>0) {
+	      switch (pgpkey_edit(this)) {
+	      case 2:
+		reload++;
+		/* fall through */
+	      case 1:
+		redraw++;
+	      }
+	    }
+	    else error1(catgets(elm_msg_cat, PgpkeySet, PgpkeyDummy,
+				"No key to edit"));
+	    break;
+	    
+	  case 's':  /* sign key */
+	    if (current<=0) {
+	      error1(catgets(elm_msg_cat, PgpkeySet, PgpkeyDummy,
+			     "No key to sign"));
+	    }
+	    else {
+	      switch (pgpkey_sign(this)) {
+	      case 2:
+		reload++;
+		/* fall through */
+	      case 1:
+		redraw++;
+	      }
+	    }
+	    break;
+
+	  case 'r':  /* remove signature */
+	    if (current<=0) {
+	      error1(catgets(elm_msg_cat, PgpkeySet, PgpkeyDummy,
+			     "No key to remove signature from"));
+	    }
+	    else {
+	      switch (pgpkey_unsign(this)) {
+	      case 2:
+		reload++;
+		/* fall through */
+	      case 1:
+		redraw++;
+	      }
+	    }
+	    break;
+	    
+	  case 'D':  /* disable key */
+	    if (current<=0) {
+	      error1(catgets(elm_msg_cat, PgpkeySet, PgpkeyDummy,
+			     "No key to disable"));
+	    }
+	    else {
+	      switch (pgpkey_disable(this)) {
+	      case 2:
+		reload++;
+		/* fall through */
+	      case 1:
+		redraw++;
+	      }
+	    }
+	    break;
+
+          case 'M':  /* mail key */
+            if (pgpkey[0]->type==KEY_TYPE_SECRET) {
+              error1(catgets(elm_msg_cat, PgpkeySet, PgpkeyDummy,
+                 "Will not mail secret keys!"));
+              break;
+            }
+
+            PutLine0(LINES-3, strlen(Prompt),
+              catgets(elm_msg_cat, PgpkeySet, PgpkeyDummy,
+              "Mail public key(s)..."));
+            clear_error();
+
+            tagged = 0;
+
+            /*
+             *      See if there are any tagged keys.
+             */
+            for (i=0; i < message_count; i++) {
+              if (ison(pgpkey[i]->status, TAGGED)) {
+                if (tagged == 0) leftoff = i;
+                tagged++;
+              }
+            }
+
+            if (tagged == 0) {
+            /* Mail whole key ring? */
+              PutLine0(LINES-2,0, catgets(elm_msg_cat,
+                PgpkeySet, PgpkeyDummy, "There are NO tagged keys."));
+              CleartoEOLN();
+              MCsprintf(buffer, catgets(elm_msg_cat, PgpkeySet, PgpkeyDummy,
+                "Mail whole keyring? (%c/%c) "), *def_ans_yes, *def_ans_no);
+              ch = want_to(buffer, *def_ans_yes, LINES-3, 0);
+
+              if (ch == *def_ans_yes) {
+                /* Mail whole keyring */
+                strcpy(keynames1, "*");
+              }
+              else if (current<=0) {
+                error1(catgets(elm_msg_cat, PgpkeySet, PgpkeyDummy,
+                 "No key to mail"));
+                *keynames1 = 0;
+              }
+              else {
+                /* Mail current key */
+		sprintf(keynames1, "0x%s", pgpkey[current-1]->key_id);
+              }
+            }
+            else {
+              /* Mail tagged keys */
+
+	      sprintf(keynames1, "0x%s", pgpkey[leftoff]->key_id);
+              for (i=leftoff+1; i < message_count; i++) {
+                if (ison(pgpkey[i]->status, TAGGED)) {
+                  strcat(keynames1, " 0x");
+                  strcat(keynames1, pgpkey[i]->key_id);
+                }
+              }
+            }
+
+            if (*keynames1 != 0) /* use subject for the key names */
+              send_msg("","",keynames1,FALSE,-1,FALSE);
+            redraw++;
+            
+            break;
+
+	  case 'n': /* Link keys to mail address */
+            if (pgpkey[0]->type==KEY_TYPE_SECRET) {
+              error1(catgets(elm_msg_cat, PgpkeySet, PgpkeyDummy,
+                     "This function works for public keys only!"));
+              break;
+            }
+
+	    PutLine0(LINES-3, strlen(Prompt),
+              catgets(elm_msg_cat, PgpkeySet, PgpkeyDummy,
+              "Link key(s) to mail address (alias)..."));
+            clear_error();
+
+	    redraw++;
+	    tagged = 0;
+
+	    /*
+	     *      See if there are any tagged keys.
+	     */
+	    for (i=0; i < message_count; i++) {
+	      if (ison(pgpkey[i]->status, TAGGED)) {
+	        if (tagged == 0) leftoff = i;
+	        tagged++;
+	      }
+	    }
+
+	    if (tagged == 0) {
+	      if (current<=0) {
+	        /* No key selected */
+	        error1(catgets(elm_msg_cat, PgpkeySet, PgpkeyDummy,
+	          "No key to link"));
+		*keynames1 = 0;
+	      }
+	      else {
+	        /* Use current key */
+	        sprintf(keynames1, "0x%s", pgpkey[current-1]->key_id);
+	      }
+	    }
+	    else {
+	      /* Use tagged keys? */
+	      PutLine1(LINES-2,0, catgets(elm_msg_cat, PgpkeySet, PgpkeyDummy,
+	        "There are %d keys tagged..."), tagged);
+	      CleartoEOLN();
+	      MCsprintf(buffer, catgets(elm_msg_cat, PgpkeySet, PgpkeyDummy,
+	        "Create group link? (%c/%c) "), *def_ans_yes, *def_ans_no);
+	      ch = want_to(buffer, *def_ans_yes, LINES-3, 0);
+
+	      if (ch != *def_ans_yes) {
+                if (current<=0) {
+                  /* No key selected */
+                  error1(catgets(elm_msg_cat, PgpkeySet, PgpkeyDummy,
+                    "No key to link"));
+                  *keynames1 = 0;
+                }
+                else {
+                  /* Use current key */
+                  sprintf(keynames1, "0x%s", pgpkey[current-1]->key_id);
+                }
+	      }
+	      else {
+	        /* all tagged keys */
+                sprintf(keynames1, "0x%s", pgpkey[leftoff]->key_id);
+                for (i=leftoff+1; i < message_count; i++) {
+                  if (ison(pgpkey[i]->status, TAGGED)) {
+                    strcat(keynames1, " 0x");
+                    strcat(keynames1, pgpkey[i]->key_id);
+                  }
+                }
+	      }
+	    }
+
+	    if (*keynames1 != 0) {
+	      FILE *f, *g;
+
+ 	      ClearLine(LINES-2);
+	      PutLine0(LINES-2, 0, catgets(elm_msg_cat, PgpkeySet, PgpkeyDummy,
+	        "Enter link address: "));
+	      *buffer = 0;
+	      (void) optionally_enter(buffer, LINES-2, 21, FALSE, FALSE);
+              if (strlen(buffer) == 0) {
+	        ClearLine(LINES-2);
+	        break;
+	      }
+	      (void) build_address(strip_commas(buffer), bufline);
+              strcpy(expanded_link, strip_commas(strip_parens(bufline)));
+	      if (strlen(expanded_link) == 0) {     /* bad address!  Removed!! */
+	        ClearLine(LINES-2);
+	        break;
+	      }
+
+	      /* expand links to include the full host name */
+	      *bufline  = 0;
+	      strp = strtok(expanded_link, delim);
+	      while (strp != NULL) {
+	        if (strchr(strp, '@') != NULL) {
+	          strcat(bufline, strp);
+		  strcat(bufline, " ");
+	        }
+	        else {
+#ifdef MAIL_DOMAIN
+	          sprintf(buf, "%s@%s ", strp, MAIL_DOMAIN);
+#else
+	          sprintf(buf, "%s@%s ", strp, hostfullname);
+#endif
+	          strcat(bufline, buf);
+	        }
+	        strp = strtok(NULL, delim);
+	      }
+	      strp = bufline; while (*strp) { *strp = tolower(*strp); strp++; }
+	      strcpy(expanded_link, bufline);
+
+	      sprintf(buffer, "%s/%s", home, pgplink);
+	      if ((f = fopen(buffer, "r")) != NULL) {
+	      
+	        strcat(buffer, ".new");
+	        if ((g = fopen(buffer, "w")) == NULL) {
+	          error1(catgets(elm_msg_cat, PgpkeySet, PgpkeyDummy,
+	            "Can't create file"));
+	          break;
+	        }
+
+	        /* replace old links */
+	        while (!feof(f)) {
+	          *bufline = 0;
+	          fgets(bufline, sizeof(bufline), f);
+	          if (*bufline != 0) {
+  		    sscanf(bufline, "%s", buffer);
+		    strp = buffer; 
+                    while ((*strp) && (!isspace(*strp))) strp++; *strp = 0;
+           	    strp = strstr(expanded_link, buffer);
+  		    if (strp != NULL) {
+ 		      strp += strlen(buffer);
+		      if ((*strp == 0) || (isspace(*strp)))
+	                continue;
+	            }
+		    /* copy link to new file */
+	            fputs(bufline, g);
+		  }
+	        }
+	        fclose(f);
+	        fclose(g);
+
+	        sprintf(buffer, "%s/%s", home, pgplink);
+	        unlink(buffer);
+	        strcpy(buf, buffer);
+	        strcat(buf, ".new");
+	        rename(buf, buffer);
+	      }
+
+	      if ((f = fopen(buffer, "a")) == NULL) {
+	          error1(catgets(elm_msg_cat, PgpkeySet, PgpkeyDummy,
+	            "Can't append file"));
+	          break;
+	      }
+		  
+	      strp = strtok(expanded_link, delim);
+	      while (strp != NULL) {
+	        if (*strp) {
+	          fprintf(f, "%s %s\n", strp, keynames1);
+	        }
+	        strp = strtok(NULL, delim);
+	      }
+	      fclose(f);
+
+	    }
+	    break;
+
+	  case 'e': /* edit pgplink file */
+            PutLine1(LINES-3, strlen(Prompt), 
+              catgets(elm_msg_cat, PgpkeySet, PgpkeyDummy,
+                  "Edit key/address links..."));
+
+	    sprintf(buf, "%s/%s", home, pgplink);
+            edit_a_file(buf);
+
+            if (cursor_control) {
+              transmit_functions(ON);       /* insurance */
+            }
+            redraw++;
+	    break;
+
+	  default:
+	    motion(ch);
+	  } /* case */
+
+	  if (reload) {                 /* Reload key ring if necessary */
+	    pgpkey_generate_keylist();
+	    reload=0;
+	  }
+	  if (redraw) {			/* Redraw screen if necessary */
+	    pgpkey_screen(modified);
+	    nutitle = 0;
+	  }
+	  
+	  if (nutitle) {		/* Redraw title if necessary */
+	    pgpkey_title(modified);
+	    nutitle = 0;
+	  }
+	  
+	  check_range();
+
+	  if (nucurr == NEW_PAGE)
+	    show_headers();
+	  else if (nucurr == SAME_PAGE)
+	    show_current();
+	  else if (nufoot) {
+	    if (mini_menu) {
+	      MoveCursor(LINES-7, 0);  
+              CleartoEOS();
+	      show_pgpkey_menu();
+	    }
+	    else {
+	      MoveCursor(LINES-4, 0);
+	      CleartoEOS();
+	    }
+	    show_last_error();	/* for those operations that have to
+				 * clear the footer except for a message.
+				 */
+	  }
+	} /* while(1) */
+  /* NOTREACHED */
+}
+
+
+/* sneaked from alias.c */
+pgpkey_main_state()
+{
+/*	Save the globals that are shared for both menus
+ *	so that we can return to the main menu without
+ *	"tragedy".
+ */
+
+  static int pgpkey_count = 0,    pgpkey_current = 0, pgpkey_last = -1,
+             pgpkey_selected = 0, pgpkey_page = 0;
+  static int main_count = 0,     main_current = 0, main_last = -1,
+	     main_selected = 0,  main_page = 0;
+
+  if (inpgpkey) {			/* Restore the settings */
+    pgpkey_count = message_count;
+    pgpkey_current = current;
+    pgpkey_last = last_current;
+    pgpkey_selected = selected;
+    pgpkey_page = header_page;
+
+    message_count = main_count;
+    current = main_current;
+    last_current = main_last;
+    selected = main_selected;
+    header_page = main_page;
+
+    strcpy(item, catgets(elm_msg_cat, ElmSet, Elmitem, "message"));
+    strcpy(items, catgets(elm_msg_cat, ElmSet, Elmitems, "messages"));
+    strcpy(Item, catgets(elm_msg_cat, ElmSet, ElmItem, "Message"));
+    strcpy(Items, catgets(elm_msg_cat, ElmSet, ElmItems, "Messages"));
+    strcpy(Prompt, catgets(elm_msg_cat, ElmSet, ElmPrompt, "Command: "));
+
+    dprint(3, (debugfile, "Leaving pgpkey mode\n"));
+    inpgpkey = FALSE;
+  }
+  else {
+    main_count = message_count;
+    main_current = current;
+    main_last = last_current;
+    main_selected = selected;
+    main_page = header_page;
+
+    message_count = pgpkey_count;
+    current = pgpkey_current;
+    last_current = pgpkey_last;
+    selected = pgpkey_selected;
+    header_page = pgpkey_page;
+
+    strcpy(item, catgets(elm_msg_cat, PgpkeySet, PgpkeyDummy, "key"));
+    strcpy(items, catgets(elm_msg_cat, PgpkeySet, PgpkeyDummy, "keys"));
+    strcpy(Item, catgets(elm_msg_cat, PgpkeySet, PgpkeyDummy, "Key"));
+    strcpy(Items, catgets(elm_msg_cat, PgpkeySet, PgpkeyDummy, "Keys"));
+    strcpy(Prompt, catgets(elm_msg_cat, PgpkeySet, PgpkeyDummy, "PGP-Key: "));
+
+    dprint(3, (debugfile, "Entered pgpkey mode\n"));
+    inpgpkey = TRUE;
+  }
+}
+
+
+/* partly sneaked from help.c */
+pgpkey_help(void)
+{
+  int  ch;		/* character buffer for input */
+  char *help_prompt, *s;
+
+  if (mini_menu)
+    help_prompt = catgets(elm_msg_cat, PgpkeySet, PgpkeyDummy, "Key: ");
+  else
+    help_prompt = catgets(elm_msg_cat, PgpkeySet, PgpkeyDummy, 
+                           "Key you want help for: ");
+
+  MoveCursor(LINES-3, 0); CleartoEOS();
+
+  if (mini_menu) {
+    Centerline(LINES-3, catgets(elm_msg_cat, PgpkeySet, PgpkeyDummy, 
+ "Press the key you want help for, '?' for a key list, or '.' to exit help"));
+  }
+
+  lower_prompt(help_prompt); 
+
+  while ((ch = ReadCh()) != '.') {
+    switch (ch) {
+    case '?':
+      display_helpfile(PGPKEY_HELP);
+      return(1);
+      
+    case '$':
+      s = catgets(elm_msg_cat, PgpkeySet, PgpkeyDummy,
+		  "$ = Force resynchronization of the current keyring. This will purge deleted keys.");
+      break;
+
+    case '*':
+      s = catgets(elm_msg_cat, PgpkeySet, PgpkeyDummy,
+		  "* = Go to the last key in the current keyring.");
+      break;
+
+    case '-':
+      s = catgets(elm_msg_cat, PgpkeySet, PgpkeyDummy,
+		  "- = Go to the previous page of keys.  This is the same as the LEFT arrow.");
+      break;
+
+    case '=':
+      s = catgets(elm_msg_cat, PgpkeySet, PgpkeyDummy,
+		  "'=' = Go to the first key in the current keyring.");
+      break;
+
+    case RETURN:
+    case LINE_FEED:
+    case SPACE:
+    case 'v': 
+      s = catgets(elm_msg_cat, PgpkeySet, PgpkeyDummy,
+		  "v = View the current key.");
+      break;
+
+    case '+':
+      s = catgets(elm_msg_cat, PgpkeySet, PgpkeyDummy,
+		  "+ = Go to the next page of keys.  This is the same as the RIGHT arrow.");
+      break;
+
+    case '/':
+      s = catgets(elm_msg_cat, PgpkeySet, PgpkeyDummy,
+		  "/ = Search for specified pattern in keyring.");
+      break;
+
+    case 'c':
+      s = catgets(elm_msg_cat, PgpkeySet, PgpkeyDummy,
+		  "c = Change to other keyring, quit the current keyring.");
+      break;
+
+    case 'd':
+      s = catgets(elm_msg_cat, PgpkeySet, PgpkeyDummy,
+		  "d = Mark the current key for future deletion.");
+      break;
+
+    case ctrl('D'):
+      s = catgets(elm_msg_cat, PgpkeySet, PgpkeyDummy,
+		  "^D = Mark all keys with the specified pattern for future deletion.");
+      break;
+
+    case 'D':
+      s = catgets(elm_msg_cat, PgpkeySet, PgpkeyDummy,
+		  "D = Disable/enable key if someone else's, or PERMANENTLY REVOKE your own key.");
+      break;
+
+    case 'm':
+      s = catgets(elm_msg_cat, PgpkeySet, PgpkeyDummy,
+		  "m = Modify user id (if your own key) or trust parameters (if someone else's).");
+      break;
+
+    case 'J':
+      s = catgets(elm_msg_cat, PgpkeySet, PgpkeyDummy,
+		  "J = Go to the next key.");
+      break;
+
+    case 'j':
+      s = catgets(elm_msg_cat, PgpkeySet, PgpkeyDummy,
+		  "j = Go to the next undeleted key.  This is the same as the DOWN arrow.");
+      break;
+
+    case 'K':
+      s = catgets(elm_msg_cat, PgpkeySet, PgpkeyDummy,
+		  "K = Go to the previous key.");
+      break;
+
+    case 'k':
+      s = catgets(elm_msg_cat, PgpkeySet, PgpkeyDummy,
+		  "k = Go to the previous undeleted key.  This is the same as the UP arrow.");
+      break;
+
+    case 'l':
+      s = catgets(elm_msg_cat, PgpkeySet, PgpkeyDummy,
+		  "l = Limit displayed keys based on the specified criteria.");
+      break;
+
+    case 'q':
+      s = catgets(elm_msg_cat, PgpkeySet, PgpkeyDummy,
+		  "q = Quit the key sub-menu, asking about deletion.");
+      break;
+
+    case 'r':
+      s = catgets(elm_msg_cat, PgpkeySet, PgpkeyDummy,
+		  "r = Remove a signature from the current key.");
+      break;
+
+    case 's':
+      s = catgets(elm_msg_cat, PgpkeySet, PgpkeyDummy,
+		  "s = Sign the current key, certifying all previous user ids and aliases.");
+      break;
+
+    case 't':
+      s = catgets(elm_msg_cat, PgpkeySet, PgpkeyDummy,
+		  "t = Tag a key for further operations (or untag if tagged).");
+      break;
+
+    case 'T': s = catgets(elm_msg_cat, PgpkeySet, PgpkeyDummy,
+			  "T = Tag a key (or untag if tagged) and go to next key.");
+      break;
+
+    case ctrl('T'):
+      s = catgets(elm_msg_cat, PgpkeySet, PgpkeyDummy,
+		  "^T = Tag all keys with the specified pattern.");
+      break;
+
+    case 'u': s = catgets(elm_msg_cat, PgpkeySet, PgpkeyDummy,
+			  "u = Undelete - remove the deletion mark on the key.");
+      break;
+
+    case ctrl('U'):
+      s = catgets(elm_msg_cat, PgpkeySet, PgpkeyDummy,
+		  "^U = Undelete all keys with the specified pattern.");
+      break;
+
+    case 'x':
+      s = catgets(elm_msg_cat, PgpkeySet, PgpkeyDummy,
+		  "x = Exit leaving the keyring untouched, ask permission if changed.");
+      break;
+
+    case 'X':
+      s = catgets(elm_msg_cat, PgpkeySet, PgpkeyDummy,
+		  "X = Exit leaving the keyring untouched, unconditionally.");
+      break;
+
+    case 'Q':
+      s = catgets(elm_msg_cat, PgpkeySet, PgpkeyDummy,
+		"Q = Quick quit the key sub-menu, deleting marked keys.");
+      break;
+
+    case ctrl('L'):
+      s = catgets(elm_msg_cat, ElmSet, ElmHelpRewriteScreen,
+		  "^L = Rewrite the screen.");	
+      break;
+
+    case 'M':
+      s = catgets(elm_msg_cat, PgpkeySet, PgpkeyDummy,
+                  "M = Mail the current or tagged keys.");
+      break;
+
+    case 'n':
+      s = catgets(elm_msg_cat, PgpkeySet, PgpkeyDummy,
+                  "n = Link the current or tagged keys to a mail address.");
+      break;
+
+    case 'e':
+      s = catgets(elm_msg_cat, PgpkeySet, PgpkeyDummy,
+                  "e = Edit the key/mail address data file.");
+      break;
+
+    default : 
+      if (isdigit(ch)) 
+        s = catgets(elm_msg_cat, PgpkeySet, PgpkeyDummy,
+		  "<number> = Make specified number the current key.");
+      else
+        s = catgets(elm_msg_cat, PgpkeySet, PgpkeyDummy,
+                  "That key isn't used in this section.");
+      break;
+    }
+
+    error(s);
+    
+  }
+ 
+  /* Remove help lines */
+  error("");
+  MoveCursor(LINES-3, 0); CleartoEOS();
+  
+  return(0);
+}
+
diff -u -r --new-file ../oldelm/src/screen.c ./src/screen.c
--- ../oldelm/src/screen.c	Wed Jan 20 04:02:41 1993
+++ ./src/screen.c	Wed Aug 30 20:17:44 1995
@@ -1,8 +1,8 @@
 
-static char rcsid[] = "@(#)$Id: screen.c,v 5.3 1993/01/20 03:02:19 syd Exp $";
+static char rcsid[] = "@(#)$Id: screen.c,v 5.3.5 1995/08/05 16:12:38 caronni Exp $";
 
 /*******************************************************************************
- *  The Elm Mail System  -  $Revision: 5.3 $   $State: Exp $
+ *  The Elm Mail System  -  $Revision: 5.3.5 $   $State: Exp $
  *
  *			Copyright (c) 1988-1992 USENET Community Trust
  *			Copyright (c) 1986,1987 Dave Taylor
@@ -14,6 +14,32 @@
  *
  *******************************************************************************
  * $Log: screen.c,v $
+ * Revision 5.3.5  1995/08/05  16:12:38  caronni
+ * Changed 'E' flag to 'P' because of collision with 'E'xpired
+ * This collides with 'P'rivate. Well...
+ * From: Germano Caronni <caronni@tik.ee.ethz.ch>
+ *
+ * Revision 5.3.4  1995/02/25  21:56:10  rm
+ * Changed ordering of 'E' and 'K' status indicators.
+ * From: Robert Muchsel <rmuchsel@iiic.ethz.ch>
+ *
+ * Revision 5.3.3  1995/02/20  23:00:00  rm
+ * Add letters E, K and S for encrypted PGP messages, keys and signed messages.
+ * Show all PGP specific keys. Removed PGP advertisement. Changed program 
+ * name from PGPELM to ELM ... PGP to indicate it is a patch.
+ * From: rmuchsel@iiic.ethz.ch
+ *
+ * Revision 5.3.2  1994/01/08  00:26:58  Mic
+ * Adds the letters E and K to message types to indicate that they are
+ * either a public key or a pgp encoded message
+ * From: egd017@cent1.lancs.ac.uk
+ *
+ * Revision 5.3.1  1993/11/27  05:25:54  Mic
+ * Added to update_title() to say if pgpencryption is available.
+ * and wrote setpasswd() to check to see if the pgp passwd has been set
+ * If not it prompts for it.
+ * From: egd017@cent1.lancs.ac.uk
+ *
  * Revision 5.3  1993/01/20  03:02:19  syd
  * Move string declarations to defs.h
  * From: Syd
@@ -102,6 +128,9 @@
 	ClearLine(1);
 
 	Centerline(1, buffer);
+
+	if (pgp_enabled) /* Check the pass phrase here, since this get called */
+	  setpasswd();   /* often enough */
 }
 
 show_menu()
@@ -123,6 +152,8 @@
 	Centerline(LINES-5, catgets(elm_msg_cat, ElmSet, ElmLevel1MenuLine3,
   "n)ext, o)ptions, p)rint, q)uit, r)eply, s)ave, t)ag, u)ndelete, or e(x)it"));
 	}
+	if (pgp_enabled)
+		Centerline(LINES-4,"PGP: \\=pipe, &=disable, P)rint, S)ave decrypted, ke(y) management");
 }
 
 int
@@ -179,6 +210,14 @@
 	      build_alias_line(buffer, aliases[this_msg], this_msg+1,
 			       FALSE);
 	  }
+	  /* CHRIS BEGIN */
+	  else if (inpgpkey) {
+	    if (this_msg == current-1)
+	      build_pgpkey_line(buffer, pgpkey[this_msg], this_msg+1, TRUE);
+	    else
+	      build_pgpkey_line(buffer, pgpkey[this_msg], this_msg+1, FALSE);
+	  }
+	  /* CHRIS END */
 	  else {
 	  using_to = tail_of(headers[this_msg]->from, newfrom,
 	    headers[this_msg]->to); 
@@ -276,6 +315,11 @@
 	  if (inalias)
 	    build_alias_line(new_buffer, aliases[current-1], current,
 			     TRUE);
+	  /* CHRIS BEGIN */
+	  else if (inpgpkey) {
+	    build_pgpkey_line(new_buffer, pgpkey[current-1], current, TRUE);
+	  }
+	  /* CHRIS END */
 	  else {
 	  using_to = tail_of(headers[current-1]->from, newfrom,
 	    headers[current-1]->to); 
@@ -297,6 +341,11 @@
 	    if (inalias)
 	      build_alias_line(old_buffer, aliases[last_current-1],
 	                       last_current, FALSE);
+	    /* CHRIS BEGIN */
+	    else if (inpgpkey)
+	      build_pgpkey_line(old_buffer, pgpkey[last_current-1],
+				last_current, FALSE);
+	    /* CHRIS END */
 	    else {
 	    using_to = tail_of(headers[last_current-1]->from, newfrom,
 	      headers[last_current-1]->to); 
@@ -470,6 +519,9 @@
 		P = Private message
 		A = Action associated with message
 		F = Form letter
+		P = PGP encrypted message
+		K = PGP public key
+		S = Message has PGP signature
 		M = MIME compliant Message
 		    (only displayed, when metamail is needed)
 		_ = (space) default
@@ -492,6 +544,9 @@
 	else if (status & PRIVATE)      mybuffer[1] = 'P';
 	else if (status & ACTION)       mybuffer[1] = 'A';
 	else if (status & FORM_LETTER)  mybuffer[1] = 'F';
+	else if (status & PGP_KEY)	mybuffer[1] = 'K';
+	else if (status & PGP_MESSAGE)	mybuffer[1] = 'P';
+	else if (status & PGP_SIGNATURE) mybuffer[1]= 'S';
 #ifdef MIME
 	else if ((status & MIME_MESSAGE) &&
 		 ((status & MIME_NOTPLAIN) ||
diff -u -r --new-file ../oldelm/src/showmsg.c ./src/showmsg.c
--- ../oldelm/src/showmsg.c	Tue Aug 30 17:09:44 1994
+++ ./src/showmsg.c	Thu Aug 31 16:20:43 1995
@@ -1,8 +1,8 @@
 
-static char rcsid[] = "@(#)$Id: showmsg.c,v 5.16 1994/08/30 15:09:43 syd Exp $";
+static char rcsid[] = "@(#)$Id: showmsg.c,v 5.16.5 1995/02/23 23:00:00 rm Exp $";
 
 /*******************************************************************************
- *  The Elm Mail System  -  $Revision: 5.16 $   $State: Exp $
+ *  The Elm Mail System  -  $Revision: 5.16.5 $   $State: Exp $
  *
  * 			Copyright (c) 1988-1992 USENET Community Trust
  * 			Copyright (c) 1986,1987 Dave Taylor
@@ -14,6 +14,32 @@
  *
  *******************************************************************************
  * $Log: showmsg.c,v $
+ * Revision 5.16.5  1995/02/23  23:00:00  rm
+ * Messages containing public keys will be displayed after the 
+ * "new keys" check; messages containing more than one PGP part will be
+ * displayed properly
+ * From: rmuchsel@iiic.ethz.ch
+ *
+ * Revision 5.16.4  1995/02/21  16:00:00  rm
+ * Fixed a bug in the Metamail-specific showmsg code: Routine no longer uses
+ * an uninitialized string for the temp file name
+ * From: rmuchsel@iiic.ethz.ch
+ *
+ * Revision 5.16.3  1995/02/20  23:00:00  rm
+ * Cleaned up PGP support. Use tempnam(). Don't use MIME headers to check for
+ * PGP messages. Some screen output improvements.
+ * From: rmuchsel@iiic.ethz.ch
+ *
+ * Revision 5.16.2  1994/01/08  00:28:53  Mic
+ * Uses MIME headers to check for pgp messages.
+ * From: egd017@cent1.lancs.ac.uk
+ *
+ * Revision 5.16.1  1993/11/27  05:27:59  Mic
+ * Add a check to see if the message is ascii pgp message, or a key file.
+ * If keyfile add keys to keyring.  If its a pgp message, decode it and display
+ * it using pgp_show_message().  the same code hacked a little to work with
+ * a file rather than the mail folder.
+ *
  * Revision 5.16  1994/08/30  15:09:43  syd
  * Block sigwinch when in the external pager.
  * From: jwa@yog-sothoth.dcrt.nih.gov (James W. Adams)
@@ -162,6 +188,8 @@
 	    builtin = FALSE,			/* our pager? */
 	    val = 0,				/* return val */
 	    buf_len,				/* line length */
+	    i,					/* used as a flag */
+ 	    pgp_message = 0,			/* is it a pgp encoded message? */
 	    err;				/* place holder for errno */
 	struct header_rec *current_header = headers[number-1];
 #ifdef	SIGTSTP
@@ -170,6 +198,10 @@
 #ifdef	SIGWINCH
 	SIGHAND_TYPE	(*oldwinch)();
 #endif
+	char fname[STRING], Cmd[SLEN], line[VERY_LONG_STRING];
+	int code;
+	FILE *fpout;
+	char junk[VERY_LONG_STRING];
 
 	lines = current_header->lines; 
 
@@ -202,11 +234,9 @@
 	if ((current_header->status & MIME_MESSAGE) &&
 	    ((current_header->status & MIME_NEEDDECOD) ||
 	     (current_header->status & MIME_NOTPLAIN)) &&
-	    !getenv("NOMETAMAIL") ) {
-	    char fname[STRING], Cmd[SLEN], line[VERY_LONG_STRING];
-	    int code, err;
-	    long lines = current_header->lines;
-	    FILE *fpout;
+	     !getenv("NOMETAMAIL") &&
+	     !(current_header->status & 
+               (PGP_MESSAGE | PGP_SIGNATURE | PGP_KEY))) {
 
 	    if (fseek(mailfile, current_header->offset, 0) != -1) {
 		sprintf(fname, "%semm.%d.%d", temp_dir, getpid(), getuid());
@@ -226,6 +256,8 @@
 		    Raw(OFF | NO_TITE); /* Raw off so raw on takes effect */
 		    Raw(ON); /* Finally raw on and switch screen */
 		    return(0);
+		} else {
+		    (void) unlink (fname);
 		}
 	    }
 	}
@@ -241,6 +273,39 @@
 		  current_header->offset, error_description(err));	
 	  return(val);
 	}
+
+	if (pgp_enabled && (current_header->status & (PGP_MESSAGE|PGP_SIGNATURE|PGP_KEY))) {
+	    char *t=tempnam(temp_dir, "pgp."); /* this was a leak!! /gec */
+	    strcpy(fname, t);
+	    free(t);
+	    pgp_message = 1;
+
+	    ClearScreen();
+
+	    if ((fpout = fopen(fname, "w")) == NULL) 
+		emergency_exit();
+	    pgp_copy_message("", fpout, CM_PGP_SCAN_KEYS);
+ 	    fclose(fpout);
+
+	    PutLine0(LINES,0, catgets(elm_msg_cat, ElmSet, ElmPressAnyKeyIndex,
+		    "Press any key to see message."));
+	    (void) ReadCh();
+	    
+	    if ((fpout = fopen(fname, "r")) == NULL) {
+		fputs("\nError opening pgp file for reading\n", stderr);
+		unlink(fname);
+		emergency_exit();
+	    }
+
+	    /* since we can't use the headers to calculate the number of lines
+	     * we might as well count them 
+	     */
+
+	    for(lines = 0; fgets(junk, VERY_LONG_STRING, fpout) != NULL; lines++);
+	    rewind(fpout);
+	    clearerr(fpout);
+	}
+		                              
 	if(current_header->encrypted)
 	  getkey(OFF);
 
@@ -266,6 +331,8 @@
 	      "Could not prepare for external pager(pipe()-%s)."),
 	      error_description(err));	
 	    Raw(ON);
+	    if (pgp_message)     /* remove the temp file shall we? */
+	    	unlink(fname);  
 	    return(val);
 	  }
 
@@ -278,6 +345,8 @@
 	      "Could not prepare for external pager(fork()-%s)."),
 	      error_description(err));	
 	    Raw(ON);
+	    if (pgp_message)         /* kill the temp file */
+	    	unlink(fname);
 	    return(val);
 
 	  } else if (fork_ret == 0) {
@@ -341,6 +410,8 @@
 	      ;
 
 	    Raw(OFF);
+	    if (pgp_message)
+	      unlink(fname);
 	    return(val);	/* pager may have already touched the screen */
 	  }
 
@@ -493,7 +564,7 @@
 
 	while (lines > 0 && pipe_abort == FALSE) {
 
-	    if ((buf_len = mail_gets(buffer, VERY_LONG_STRING, mailfile)) == 0) {
+	    if ((buf_len = mail_gets(buffer, VERY_LONG_STRING, (pgp_message ? fpout : mailfile))) == 0) {
 
 	      dprint(1, (debugfile,
 		"Premature end of file! Lines left = %d msg = %s (show_msg)\n",
@@ -579,6 +650,11 @@
 #ifdef	SIGWINCH
 	  (void)signal(SIGWINCH,oldwinch);
 #endif
+	}
+
+	if(pgp_message) {
+	  fclose(fpout);
+	  unlink(fname);
 	}
 
 	/* If we are to prompt for a user input command and we don't
diff -u -r --new-file ../oldelm/src/showmsg_c.c ./src/showmsg_c.c
--- ../oldelm/src/showmsg_c.c	Fri Mar 11 22:25:27 1994
+++ ./src/showmsg_c.c	Wed Aug 30 20:17:45 1995
@@ -1,8 +1,8 @@
 
-static char rcsid[] = "@(#)$Id: showmsg_c.c,v 5.4 1994/03/11 21:25:24 syd Exp $";
+static char rcsid[] = "@(#)$Id: showmsg_c.c,v 5.4.2 1995/02/22 16:00:00 rm Exp $";
 
 /*******************************************************************************
- *  The Elm Mail System  -  $Revision: 5.4 $   $State: Exp $
+ *  The Elm Mail System  -  $Revision: 5.4.2 $   $State: Exp $
  *
  *			Copyright (c) 1988-1992 USENET Community Trust
  *			Copyright (c) 1986,1987 Dave Taylor
@@ -14,6 +14,14 @@
  *
  *******************************************************************************
  * $Log: showmsg_c.c,v $
+ * Revision 5.4.2  1995/02/22  16:00:00  rm
+ * Streamlined PGP key checking.
+ * From: rmuchsel@iiic.ethz.ch
+ *
+ * Revision 5.4.1  1995/02/20  23:00:00  rm
+ * Added PGP specific keys ('\\' and 'P').
+ * From: rmuchsel@iiic.ethz.ch
+ *
  * Revision 5.4  1994/03/11  21:25:24  syd
  * Fix Elm looping if an EOF is received.
  * From: Gregory Neil Shapiro <gshapiro@WPI.EDU>
@@ -104,8 +112,12 @@
 		       } else screen_mangled = TRUE;
 		       break;
 
+	    case '\\': if (! pgp_enabled)
+			 break;
+		       /* fall through */
+
 	    case '|' : put_cmd_name(catgets(elm_msg_cat, ElmSet, ElmPipe, "Pipe"), TRUE);
-		       (void) do_pipe();     /* do pipe - ignore return val */
+		       (void) do_pipe(command != '|'); /* do pipe - ignore return val */
 		       ClearScreen();
 		       build_bottom();
 		       break; 
@@ -207,9 +219,13 @@
 			 put_border();
 		       break;
 
+	    case 'P' : if (! pgp_enabled)
+			 break;
+		       /* fall through */
+
 	    case 'p' : put_cmd_name(catgets(elm_msg_cat, ElmSet, ElmPrintMessage,
 				"Print message"), FALSE);
-		       (void) print_msg(FALSE);
+		       (void) print_msg(FALSE,command != 'p');
 		       break;
 
 	    case 'r' : put_cmd_name(catgets(elm_msg_cat, ElmSet, ElmReplyToMessage,
@@ -217,10 +233,13 @@
 		       if(reply()) put_border();
 		       break;
 
+	    case 'S' : if (!pgp_enabled)
+			 break;
+
 	    case '>' :
 	    case 'C' :
 	    case 's' : put_cmd_name((command != 'C' ? cap_save_word : cap_copy_word), TRUE);
-		       (void) save(&intbuf, TRUE, (command != 'C'));
+		       (void) save(&intbuf, TRUE, (command != 'C'), (command == 'S'));
 		       if (resolve_mode && command != 'C')
 			 goto next_undel_msg;
 		       break;
diff -u -r --new-file ../oldelm/src/string2.c ./src/string2.c
--- ../oldelm/src/string2.c	Tue Aug  3 21:29:21 1993
+++ ./src/string2.c	Thu Aug 31 16:02:24 1995
@@ -1,8 +1,8 @@
 
-static char rcsid[] = "@(#)$Id: string2.c,v 5.2 1993/08/03 19:28:39 syd Exp $";
+static char rcsid[] = "@(#)$Id: string2.c,v 5.2.1 1995/08/31 19:58:39 caronni Exp $";
 
 /*******************************************************************************
- *  The Elm Mail System  -  $Revision: 5.2 $   $State: Exp $
+ *  The Elm Mail System  -  $Revision: 5.2.1 $   $State: Exp $
  *
  * 			Copyright (c) 1988-1992 USENET Community Trust
  * 			Copyright (c) 1986,1987 Dave Taylor
@@ -14,6 +14,12 @@
  *
  *******************************************************************************
  * $Log: string2.c,v $
+ * Revision 5.2.1  1995/08/31  15:58:39  caronni
+ * remove_possible_trailing_spaces sometimes referenced a byte before
+ * the string, and might be induced to write a byte after the end of the
+ * string.
+ * From Germano Caronni <caronni@.tik.ee.ethz.ch>
+ *
  * Revision 5.2  1993/08/03  19:28:39  syd
  * Elm tries to replace the system toupper() and tolower() on current
  * BSD systems, which is unnecessary.  Even worse, the replacements
@@ -83,7 +89,14 @@
 	for ( j = i = strlen(string); --i >= 0 && whitespace(string[i]); )
 		/** spin backwards, semicolon intented **/ ;
 
-	if (string[i-1] == '\\') /* allow for line to end with \blank  */
+				 /* This looks like a bug. If the string was
+				    empty (or == whitespaces), and the 
+				    character before the beginning happens
+				    to be a '\' strange things might happen.
+				    (writting out of string area) /gec 31.8.95
+				  */
+	if (i > 0 && string[i-1] == '\\') 
+				 /* allow for line to end with \blank */
 		i++;
 
 	if (i < j)
diff -u -r --new-file ../oldelm/src/syscall.c ./src/syscall.c
--- ../oldelm/src/syscall.c	Tue Aug 30 17:09:43 1994
+++ ./src/syscall.c	Thu Aug 31 16:25:05 1995
@@ -1,8 +1,8 @@
 
-static char rcsid[] = "@(#)$Id: syscall.c,v 5.9 1994/08/30 15:09:43 syd Exp $";
+static char rcsid[] = "@(#)$Id: syscall.c,v 5.9.5 1995/02/25 21:57:28 rm Exp $";
 
 /*******************************************************************************
- *  The Elm Mail System  -  $Revision: 5.9 $   $State: Exp $
+ *  The Elm Mail System  -  $Revision: 5.9.5 $   $State: Exp $
  *
  *			Copyright (c) 1988-1992 USENET Community Trust
  *			Copyright (c) 1986,1987 Dave Taylor
@@ -14,6 +14,31 @@
  *
  *******************************************************************************
  * $Log: syscall.c,v $
+ * Revision 5.9.5  1995/02/25  21:57:28  rm
+ * Added filter_through_pgp_fd (uses FILE * as arguments), added optional
+ * prefix string
+ * From: Robert Muchsel <rmuchsel@iiic.ethz.ch>
+ *
+ * Revision 5.9.4  1995/02/22  16:00:00  rm
+ * do_pgp_pipe() removed, code added to do_pipe(). filter_through_pgp() added
+ * to support piping and printing of multiple PGP messages (tagged messages).
+ * From: rmuchsel@iiic.ethz.ch
+ *
+ * Revision 5.9.3  1995/02/20  23:00:00  rm
+ * Changed PGP support to use invoke_pgp() instead of system_call()s. Fixed
+ * screen redraw problems.
+ * From: rmuchsel@iiic.ethz.ch
+ *
+ * Revision 5.9.2  1994/01/08  00:30:19  Mic
+ * Added the origional do_pipe, and renamed the newone do_pgp_pipe, also
+ * added a check in print_message for piping the message through pgp first.
+ * From: egd017@cent1.lancs.ac.uk
+ *
+ * Revision 5.9.1  1993/11/27  05:30:36  Mic
+ * Altered do_pipe() and print_msg() to pipe the message via pgp to decode
+ * the message first if needed!
+ * From: egd017@cent1.lancs.ac.uk
+ *
  * Revision 5.9  1994/08/30  15:09:43  syd
  * Block sigwinch when in the external pager.
  * From: jwa@yog-sothoth.dcrt.nih.gov (James W. Adams)
@@ -346,12 +371,13 @@
 }
 
 int
-do_pipe()
+do_pipe(pass_through_pgp)
+int pass_through_pgp;
 {
 	/** pipe the current message or tagged messages to
 	    the specified sequence.. **/
 
-	char command[SLEN], buffer[SLEN], *prompt;
+	char command[SLEN], buffer[SLEN], *prompt, *t;
 	register int  ret;
 	int	old_raw;
 
@@ -372,9 +398,28 @@
 
 	if (cursor_control)
 	  transmit_functions(OFF);
-	
-	sprintf(buffer, "%s -Ih|%s", readmsg, command);
-	ret = system_call(buffer, SY_USER_SHELL|SY_ENAB_SIGINT|SY_DUMPSTATE);
+
+	if (! pass_through_pgp) {	
+	  sprintf(buffer, "%s -Ih|%s", readmsg, command);
+	  ret = system_call(buffer, SY_USER_SHELL|SY_ENAB_SIGINT|SY_DUMPSTATE);
+	} 
+	else {
+	  char fname[SLEN], fname2[SLEN]; 
+
+	  strcpy(fname, t=tempnam(temp_dir, "pgp."));
+	  free(t); /* leak again... /gec */
+	  strcpy(fname2, t=tempnam(temp_dir, "pgp."));
+	  free(t); /* again... /gec */
+
+          sprintf(buffer, "%s -Ih> %s", readmsg, fname);
+          if (! (ret = system_call(buffer, SY_USER_SHELL|SY_ENAB_SIGINT|SY_DUMPSTATE)))
+	    if (filter_through_pgp(fname, fname2, "", 0)) {
+              sprintf(buffer, "%s< %s", command, fname2);
+              ret = system_call(buffer, SY_USER_SHELL|SY_ENAB_SIGINT|SY_DUMPSTATE);
+            }
+          unlink(fname);
+	  unlink(fname2);
+	}
 
 	SetXYLocation(0, 40);	/* a location not near the next request, so an absolute is used */
 	PutLine0(LINES, 0, catgets(elm_msg_cat, ElmSet, ElmPressAnyKeyToReturn,
@@ -395,8 +440,9 @@
 	return(1);
 }
 
-int print_msg(pause_on_scroll)
+int print_msg(pause_on_scroll,pass_through_pgp)
 int pause_on_scroll;
+int pass_through_pgp;
 {
 	/*
 	 * Print the tagged messages, or the current message if none are
@@ -446,9 +492,15 @@
 	 */
 	if (in_string(printout, "%s")) {
 	    sprintf(printbuffer, printout, filename);
+            if (pass_through_pgp) 
+		sprintf(buffer,"(%s 2>&1) > /dev/null", printbuffer);
+            else
 	    sprintf(buffer,"(%s -Ip > %s; %s 2>&1) > /dev/null",
 		readmsg, filename, printbuffer);
 	} else {
+	    if (pass_through_pgp)
+		sprintf(buffer,"(%s) < %s", printout, filename);
+	    else
 	    sprintf(buffer,"%s -Ip | %s", readmsg, printout);
 	}
 
@@ -458,6 +510,26 @@
 	if (create_folder_state_file() != 0)
 	    return 0;
 
+	/* 
+	 * Put file through PGP filter if requested.
+	 */
+        if (pass_through_pgp) {
+	  char ftemp[SLEN], command[SLEN], *t;
+
+          strcpy(ftemp, t=tempnam(temp_dir, "dump."));
+          free(t); /* and again /gec */
+
+	  /* dump tagged messages */
+          sprintf(command,"%s -Ip > %s", readmsg, ftemp);
+          if (system_call(command, SY_USER_SHELL|SY_ENAB_SIGINT) != 0) {
+            unlink(ftemp);
+            return 0;
+          }
+	
+	  filter_through_pgp(ftemp, filename, "", 0);
+	  unlink(ftemp);
+        }
+
 	/*
 	 * Put keyboard into normal state.
 	 */
@@ -523,7 +595,7 @@
 	    transmit_functions(ON);
 	(void) unlink(filename);
 	(void) remove_folder_state_file();
-	return (nlines > 1);
+	return (nlines > 1) + pass_through_pgp; /* always repaint if pgp called */
 }
 
 
@@ -685,3 +757,113 @@
     return unlink(folder_state_fname);
 }
 
+/**
+   This function takes an input file and filters it through PGP. Public
+   keys are removed, non-pgp information is preserved and pgp specific
+   information is decrypted (this function is works ok with tagged
+   messages). Optionally prefix each line with 'prefix'.
+   Returns: 0=Error, 1=Success 
+**/
+
+int filter_through_pgp_fd(fsource, ftarget, prefix, options)
+FILE *fsource;
+FILE *ftarget;
+char *prefix;
+int options;
+{
+  char temp[SLEN], temp2[SLEN], line[VERY_LONG_STRING];
+  char text_has_key[] = "[Text contains a PGP public key here]\n", *t;
+  int state = 0; /* 0 = normal text, 1 = pgp message, 2 = signature, 3 = key */
+  FILE *ftemp; 
+
+  strcpy(temp, t=tempnam(temp_dir, "pgp."));
+  free(t); /*gec*/
+
+  /* scan source for pgp specific information */
+  if ((ftemp = fopen(temp, "w")) == NULL)
+    return 0;
+
+  *line = 0;
+  while ((fgets(line, VERY_LONG_STRING, fsource) != NULL) && (*line)) {
+    if (first_word(line, BEGIN_PGP_MESSAGE)) {
+      state = 1; fputs(line, ftemp);
+    }
+    else if (first_word(line, BEGIN_PGP_SIGNATURE)) {
+      state = 2; fputs(line, ftemp);
+    }
+    else if (first_word(line, BEGIN_PGP_KEY)) {
+      state = 3; fputs(line, ftemp);
+    }
+    else if ((first_word(line, END_PGP_MESSAGE)) ||
+             (first_word(line, END_PGP_SIGNATURE))) {
+      state = 0;
+      fputs(line, ftemp);
+
+      /* decrypt PGP part */
+      fclose(ftemp); 
+      if (pubkeyring != NULL)
+        invoke_pgp(-1, -1, -1, "-t", "+batchmode", "+verbose=0", "+force", 
+	           pubkeyring, temp, NULL);
+      else
+	invoke_pgp(-1, -1, -1, "-t", "+batchmode", "+verbose=0", "+force",
+		   temp, NULL);
+
+      /* filter output recursively */
+      ftemp = fopen(temp, "r");
+      filter_through_pgp_fd(ftemp, ftarget, prefix, options);
+      fclose(ftemp);
+      ftemp = fopen(temp, "w");
+    }
+    else if (first_word(line, END_PGP_KEY)) {
+      state = 0;
+      fputs(line, ftemp);
+
+      fclose(ftemp);
+
+      if ((options & CM_PGP_SCAN_KEYS) == CM_PGP_SCAN_KEYS) {
+        invoke_pgp(-1, -1, -1, "-ka", "+verbose=0", "+interactive=on",
+           temp, keyring, NULL);
+      }
+      ftemp = fopen(temp, "w");
+
+      fputs(prefix, ftarget); fputs(text_has_key, ftarget);
+      fputs(prefix, ftarget); fputs("\n", ftarget);
+    }                                                      
+    else {
+      if (state == 0) { 
+	fputs(prefix, ftarget); fputs(line, ftarget);
+      }
+      else 
+        fputs(line, ftemp);
+    }
+   
+    *line = 0;
+  }
+
+  fclose(ftemp); unlink(temp);
+
+  return 1;
+}
+
+/**
+   Same as above, but accept path names as arguments and open the files
+**/
+
+int filter_through_pgp(source, target, prefix, options) 
+char *source;
+char *target;
+char *prefix;
+int options;
+{
+  FILE *fsource, *ftarget;
+  int ret;
+
+  if (((fsource = fopen(source, "r")) == NULL) ||
+      ((ftarget = fopen(target, "w")) == NULL))
+    return 0; 
+
+  ret = filter_through_pgp_fd(fsource, ftarget, prefix, options);
+
+  fclose(fsource); fclose(ftarget);
+  return ret;
+}
diff -u -r --new-file ../oldelm/src/utils.c ./src/utils.c
--- ../oldelm/src/utils.c	Fri Jun  3 19:05:33 1994
+++ ./src/utils.c	Wed Aug 30 00:54:27 1995
@@ -1,8 +1,8 @@
 
-static char rcsid[] = "@(#)$Id: utils.c,v 5.17 1994/06/03 17:05:17 syd Exp $";
+static char rcsid[] = "@(#)$Id: utils.c,v 5.17.1 1995/02/20 23:00:00 rm Exp $";
 
 /*******************************************************************************
- *  The Elm Mail System  -  $Revision: 5.17 $   $State: Exp $
+ *  The Elm Mail System  -  $Revision: 5.17.1 $   $State: Exp $
  *
  *			Copyright (c) 1988-1992 USENET Community Trust
  *			Copyright (c) 1986,1987 Dave Taylor
@@ -14,6 +14,10 @@
  *
  *******************************************************************************
  * $Log: utils.c,v $
+ * Revision 5.17.1  1995/02/20  23:00:00  rm
+ * clear pgp passhphrase before exiting
+ * From: rmuchsel@iiic.ethz.ch
+ *
  * Revision 5.17  1994/06/03  17:05:17  syd
  * try and prevent copy from calling elm_chown unless needed
  * From: Syd
@@ -264,6 +268,9 @@
 	printf(catgets(elm_msg_cat, ElmSet, ElmEmergencyExitTaken,
 		"\nEmergency exit taken! All temp files intact!\n\n"));
 
+        /** Clear PGP pass phrase **/
+        memset(passphrase,0,sizeof(passphrase));
+
 	exit(1);
 }
 rm_temps_exit()
@@ -309,6 +316,9 @@
 	    Raw(OFF);
 	}
 
+        /** Clear PGP pass phrase **/
+        memset(passphrase,0,sizeof(passphrase));
+
 	exit(1);
 }
 
@@ -358,6 +368,9 @@
 	  Raw(OFF);
 	}
 
+        /** Clear PGP pass phrase **/
+        memset(passphrase,0,sizeof(passphrase));
+
 	exit(0);
 }
 
@@ -402,6 +415,9 @@
 	    fflush (mailfile);
 	unlock ();
 
+        /** Clear PGP pass phrase **/
+        memset(passphrase,0,sizeof(passphrase));
+
 	exit(0);
 }
 
@@ -449,6 +465,9 @@
 	  NewLine();
 	  Raw(OFF);
 	}
+
+        /** Clear PGP pass phrase **/
+        memset(passphrase,0,sizeof(passphrase));
 
 	exit(0);
 }
diff -u -r --new-file ../oldelm/src/wildcards.c ./src/wildcards.c
--- ../oldelm/src/wildcards.c	Fri Dec 11 02:45:40 1992
+++ ./src/wildcards.c	Thu Aug 31 16:12:32 1995
@@ -1,8 +1,8 @@
 
-static char rcsid[] = "@(#)$Id: wildcards.c,v 5.5 1992/12/11 01:45:04 syd Exp $";
+static char rcsid[] = "@(#)$Id: wildcards.c,v 5.5.1 1995/08/31 16:05:05 caronni Exp $";
 
 /*******************************************************************************
- *  The Elm Mail System  -  $Revision: 5.5 $   $State: Exp $
+ *  The Elm Mail System  -  $Revision: 5.5.1 $   $State: Exp $
  *
  *			Copyright (c) 1988-1992 USENET Community Trust
  *			Copyright (c) 1986,1987 Dave Taylor
@@ -14,6 +14,10 @@
  *
  *******************************************************************************
  * $Log: wildcards.c,v $
+ * Revision 5.5.1  1995/08/31  16:05:05  caronni
+ * has_wildcards referenced data below start of string. Fixed.
+ * From: Germano Caronni <caronni@tik.ee.ethz.ch>
+ *
  * Revision 5.5  1992/12/11  01:45:04  syd
  * remove sys/types.h include, it is now included by defs.h
  * and this routine includes defs.h or indirectly includes defs.h
@@ -116,6 +120,11 @@
 
 	for ( wildchar = name ; NULL != ( wildchar = strpbrk( wildchar, user_wildcards ) ) ; wildchar++ )
 	{
+		if (wildchar == name) /* wildcard at the beginning 
+					 can't be escaped /gec 31.8.95
+				       */
+			return TRUE;
+
 		if ( *( wildchar - 1 ) != '\\' ) {
 			if (wildchar - name < 3)
 				return TRUE;
