

                    On Necessary and Sufficient Conditions for

             the Construction of Super Pseudorandom Permutations



                                 Babak Sadeghiyan

                                   Josef Pieprzyk *



                         Department of Computer Science,

                                 University College,

                          University of New South Wales,

                        Australian Defence Force Academy,

                         Canberra, A.C.T. 2600, Australia.



                                      Abstract

          In this paper, we present the necessary and sufficient conditions

       for super pseudorandomness of DES-like permutations. We show

       that four rounds of such permutations with a single random function

       is not super psuedorandom and we present a distinguishing circuit

       for _(f 2; f; f; f ) and another circuit for _(f l; f k; f j; f i). Then*
 *, we

       investigate the necessary and sufficient conditions for super

       pseudorandomness of type-1 Feistel type transformations, and we

       show that k2 rounds of this transformation is super pseudorandom.



1    Introduction


Pseudorandom bit generators have many cryptographic applications. Classical

pseudorandom bit generators are deterministic algorithms which generate

binary strings that have statistical properties similar to a truly random one.
   *______________________________________
     Support for this project was provided in part by TELECOM Australia un-

der the contract number 7027 and by ARC Grant under the reference number

A48830241.
                                          1


However, even if a generator passes all known statistical tests, it is sometimes

possible to predict the next bit knowing some previous ones. The notion of

unpredictability of the next bit was first introduced by Yao [5]. He showed that

a generated string is indistinguishable from a random one, if and only if,

knowing the first s bits of the string, predicting the s + 1 bit is difficult, *
 *in

other words the next bit is unpredictable. Goldreich, Goldwasser and Micali

introduced the notion of pseudorandom function generators [1] and showed how

to construct a pseudorandom function generator from a pseudorandom bit

generator adopting Yao's unpredictability criteria for the next bit.

Luby and Rackoff showed how to construct a pseudorandom invertible

permutation generator with three pseudorandom function generators and

application of three rounds of DES-like permutations [2] (this structure is

notated as _(h; g; f )). A practical implication of their work is that a private

key block cipher which can be proven to be secure against chosen plaintext

attack can be constructed. Their result is quite astonishing since it is not ba*
 *sed

on any unproven hypothesis. Later Pieprzyk [4] showed that four rounds of

DES-like permutations with a single pseudorandom function generator

_(f 2; f; f; f ) is also pseudorandom and it is secure against a chosen plainte*
 *xt

attack. Luby and Rackoff also introduced the notion of super

pseudorandomness, where the block cryptosystem is secure against a chosen

plaintext/ciphertext attack. They suggested that _(h; g; f; e) is super

pseudorandom. It is a question of how to construct super pseudorandom

permutations and whether _(f 2; f; f; f ) is super pseudorandom.

In this paper, we present the necessary and sufficient conditions for super

pseudorandomness of DES-like permutations. Then we show that four rounds

of such permutations with a single random function is not super

psuedorandom. We present a distinguishing circuit for _(f 2; f; f; f ) and

another one for some cases of _(f l; f k; f j; f i).

Then, we investigate the necessary and sufficient conditions for super

pseudorandomness of type-1 Feistel type transformations, and we show that k2

rounds of this transformation is super pseudorandom. We also show that

k2 - k + 1 rounds of the inverse of this type of transformations are

pseudorandom.


2    Notations


The notation we use, is similar to [4]. The set of all integers is denoted by N.

Let   = {0; 1} be the alphabet we consider. For n 2 N ,  n is the set of all 2n

binary strings of length n. The concatenation of two binary strings x; y is

denoted by x k y. The bit by bit exclusive-OR of x and y is denoted by x   y.

By x 2r S we mean that x is chosen from a set S uniformly at random. By f a

function we mean a trasformation from  n to  n . The set of all functions on

 n is denoted by Hn , i.e., Hn = {f | f :  n !  n } and it consists of 2n2n

elements. The composition of two functions f and g is defined as

f O g(x) = f (g(x)). The i-fold composition of f is denoted by f i. A function f

is a permutation if it is a 1 to 1 and onto function. The set of all permutatio*
 *ns

on  n is defined by Pn and it consists of 2n ! elements.



3    Preliminaries


This section provides the preliminary definitions and notions which are used

throughout the paper.


Definition  1    We  associate  with  a  function  f 2 Hn  the  DES-like

permutation  D2n;f 2 P2n  as,


                          D2n;f(L k R) = (R   f (L) k L)


where  R  and  L  are  n-bit  strings,  i.e.,  R; L 2  n .


Definition  2    Having  a  sequence  of  functions  f1; f2; : :;:fi 2 Hn ,  we

define  the  composition  of  their  DES-like  permutations  as  _ 2 P2n ,

where

                 _(fi; : :;:f2; f1) = D2n;fiO D2n;fi-1O : :O:D2n;f1


Definition  3    Let  l(n)  be  a  polynomial  in  n,  a  function  generator

F = {Fn : n 2 N }  is  a  collection  of  functions  with  the  following

properties:


    o  Indexing:   Each  Fn  specifies  for  each  k  of  length  l(n)  a

       function  fn;k 2 Hn .


    o  Poly-time  evaluation:   Given  a  key  k 2  l(n),  and  a  string

       x 2  n ,  fn;k(x)  can  be  computed  in  polynomial  time  in  n.


Definition  4    An  oracle  circuit  Cn  is  an  acyclic  circuit  which

contains  Boolean  gates  of  type  AND,  OR  and  NOT,  and  constant  gates

of  type  zero  and  one,  and  a  particular  kind  of  gates  named  oracle

gates.   Each  oracle  gate  has  an  n-bit  input  and  an  n-bit  output

and  it  is  evaluated  using  some  function  from  Hn .   The  oracle

circuit  Cn  has  a  single  bit  output.


Definition  5    The  size  of  an  oracle  circuit  Cn  is  the  total  number

of  connections  between  gates,  Boolean  gates,  constant  gates  and

oracle  gates.


Definition  6    A  distinguishing  circuit  family  for  a  function

generator  F  is  an  infinite  family  of  circuits  {Cn1; Cn2; : :}:,  where

n1 < n2 < : :,: such  that  for  some  pair  of  constants  c1  and  c2  and

for  each  n  there  exist  a  circuit  Cn  such  that:


    o  The  size  of  Cn  is  less  than  or  equal  to  nc1.


    o  Let  Prob {Cn [Hn ] = 1}  be  the  probability  that  the  output  bit  *
 *of

       Cn  is  one  when  a  function  is  randomly  selected  from  Hn  and

       used  to  evaluate  oracle  gates.   Let  Prob {Cn [Fn ] = 1}  be  the

       probability  that  the  output  bit  of  Cn  is  one  when  a  key  k  of

       length  l(n)  is  randomly  chosen  and  fn;k is  used  to  evaluate  the

       oracle  gates.


The  distinguishing  probability  for  Cn  is  greater  than  or  equal  to
  1 _______
 nc2,  that  is,


                 | Prob {Cn [Hn ] = 1} - Prob {Cn [Fn ] = 1} |  _1__nc2


Definition  7    A  function  generator  F  is  pseudorandom  if  there  is

no  distinguishing  circuit  family  for  F .



4    Pseudorandom  and  Super  Pseudorandom  Permutations


How to construct pseudorandom permutation from pseudorandom functions

was first presented by Luby and Rackoff applying a DES-like structure. The

following lemma is due to Luby and Rackoff and has been stated in [2] as the

main lemma.


Lemma  1   Let  f1; f2; f3 2r Hn   be  indepedent  random  functions  and  C2n

be  an  oracle  circuit  with  m < 2n  oracle  gates,  then

                                                                        2
           | Prob {C2n [P2n ] = 1} - Prob {C2n [_(f3; f2; f1)] = 1} |  m___2n


In other words, a block cryptosystem with three rounds of DES-like

permutation and three different random functions is secure against chosen

plaintext attack, when a cryptanalyst can ask for only a polynomial number of

plaintexts. This result is quite astonishing since it does not depend on any

unproved hypothesis and can be used as a justification for the design rule of

DES. Luby and Rackoff also showed that the above Lemma remains valid even

when functions are selected from three pseudorandom function generators.

When the block cryptosystem is secure against chosen plaintext/ciphertext

attack, it is called super pseudorandom. This notion only applies for invertible

permutations and is stated formally in three following definitions.


Definition  8    A  permutation  generator  F  is  a  function  generator

such__that__each  function  fn;k_is__1  to  1  and  onto.   Let_

F  = {Fn  : n 2 N },  where  Fn = {f n;k: k 2  l(n)},  where  fn;k_is  the

inverse  function  of  fn;k.   F  is  called  invertible  if  F  is  also  a

permutation  generator.


Definition  9    A  super  distinguishing  family  of  circuits  for  an

invertible  permutation  generator  F  is  an  infinite  family  of

circuits  {SCn1; SCn2; : :}:,  where  n1 < n2 < : :,: where  each  circuit  is

an  oracle  circuit  containing  two  types  of  oracle  gates,  normal  and

inverse,  such  that  for  some  pair  of  constants  c1  and  c2  and  for

each  n  there  exist  a  circuit  SCn  such  that:


    o  The  size  of  SCn  is  less  than  or  equal  to  nc1.


    o  Let  Prob {SCn [Pn ] = 1}  be  the  probability  that  the  output  bit

       of  SCn  is  one  when  a  permutation  p  is  randomly  selected  from

       Pn  and  p  and  __pare  used  to  evaluate  normal  and  inverse  oracle

       gates.   Let  Prob {SCn [Fn ] = 1}  be  the  probability  that  the

       output  bit  of  SCn  is  one  when_ a  key  k  of  length  l(n)  is

       randomly  chosen  and  fn;k and  fn;k is  used  to  evaluate  the

       normal  and  inverse  oracle  gates  respectively.


The  distinguishing  probability  for  SCn  is  greater  than  or  equal

to  _1__nc2,  that  is,


                | Prob {SCn [Pn ] = 1} - Prob {SCn [Fn ] = 1} |  _1__nc2


Definition  10    A  permutation  generator  F  is  super  pseudorandom  if

there  is  no  super  distinguishing  circuit  family  for  F .


If F is a super pseudorandom permutation generator, it is secure against a

chosen plaintext/ciphertext attack where a cryptanalyst can interactively

choose plain blocks and see their encryptions and choose encryptions and see

their corresponding plaintext blocks.



5    Necessary  and  Sufficient  Conditions  for  Super  Pseudorandomness


Luby and Rackoff [2] also suggested that, it is possible to make a super

pseudorandom permutation with four independent random functions, i.e. if

f1; f2; f3; f4 2 Hn are independent random functions then _(f4; f3; f2; f1) is a

super pseudorandom permutation. It is a matter of question whether it is

possible to build a super pseudorandom permutation with less number of

random functions. In this section, we present necessary and sufficient

conditions for construction of super pseudorandom permutations in Theorem 1.

Later, these conditions are applied to construct a super pseudorandom

permutation with a less number of random functions. Then, they are also

applied to show that with a single random function and four rounds of DES-like

permutations, a super pseudorandom permutation cannot be constructed.

First a definition for independent permutations is given, which would be used

in the proof of Theorem 1.

Let ss1, ss2 be two pseudorandom permutation generators, and Cn be an oracle

circuit with two types of oracles. Let Prob {Cn [ss1; ss2] = 1} be the probabil*
 *ity

that the output bit of the oracle circuit Cn is 1, when a key k of length l(n) *
 *is

randomly chosen and p1;k 2 ss1, p2;k 2 ss2 are used to evaluate each type of the

oracle gates respectively. Let Prob {Cn [Pn ; Pn ] = 1} be the probability that*
 * the

output bit of the oracle circuit Cn is 1, when two permutations p1; p2 are chos*
 *en

independently and randomly from Pn and are used to evaluate the oracle gates

of Cn . If ss2 is the inverse of ss1, then let Prob {Cn [Pn ; Pn ] = 1} be the

probability that the output bit of the oracle circuit Cn is 1, when a permutati*
 *on

p is chosen randomly from Pn and p and __pare used to evaluate the oracle gates


of Cn . We say ss1 and ss2 are two dependent permutation generators if there is

a distinguishing circuit with two types of oracles Cn such that


              | Prob {Cn [ss1; ss2] = 1} - Prob {Cn [Pn ; Pn ] = 1} |  _1__nc2


for some constant c2.


Definition  11    We  say  ss1  and  ss2  are  two  independent  permutation

generators,  if  there  is  no  distinguishing  oracle  circuit  family

with  two  types  of  oracle  gates  for  (ss1; ss2).


The following lemma suggests how to construct two independent permutations,

applying DES-like structures.


Lemma  2   Let  f1; f2; : :;:fi 2r Fn ,  and  G2 = _(fi; : :;:f2)  and

G3 = _(f1; : :;:fi-1)  are  two  independent  permutations,  if  and  only  if

they  are  pseudorandom.



Proof  Sketch:  We first show if G2 = _(fi; : :;:f2) and G3 = _(f1; : :;:fi-1),

are pseudorandom, they are independent permutations, where f1; : :;:fi 2r Fn .

For simplicity of the proof, consider that f1; : :;:fi 2r Hn , but it is allowe*
 *d to

examine only a polynomial m number of oracle gates. In other words, it is

assumed that the probability of distinguishing G2 or G3 from a random

permutation is less than Q(m)_2n, for any polynomial Q. Since, both G2 and G3

would not be distinguishable from a random permutation when polynomial

number of oracles are examined, any distinguisher circuit for dependency of G2

and G3 would virtually be a distinguisher for dependency of at least a branch

of of G2 from a branch of G3, for both G2 and G3 have two branches. Two

situations may arise:


    o  i is even:

       When i is even, each branch of G2 and G3 is fed with a different set of

       random functions. So each of the four branches is statistically

       independent from other branches. Hence, there would be no

       distinguishing circuit for dependency of G2 and G3.


    o  i is odd:

       In this structure, one branch of G2 is fed with the same set of random

       functions which feeds a branch of G3, but the other branches are


       independent from the others. Since the former branches are fed with a

       reverse order of the same set of random functions, they are also

       independent from each other.


When random functions are substituted with pseudorandom ones, the

probability of dependency between G2 and G3 would still remain less than 1

over any polynomial (see [2]).

Although, in the above proof, we considered that pseudorandom functions

f1; : :;:fi are chosen independently from Fn , but in the general case, it is

sufficient that only fi-1 and f2 be chosen independently to make G2 and G3

two indepedent permutations, if G2 and G3 are pseudorandom, (no matter

whether the other pseudorandom functions are chosen independently).

In addition, it can be shown if G2 and G3 are independent, they would be

pseudorandom. Since using one type of oracles reduces the possibility of

distinguishing, then
                  | Prob {C2n [G2] = 1} - Prob {C2n [P2n ] = 1} |  <

          | Prob {C2n [G2; G3] = 1} - Prob {C2n [P2n ; P2n ] = 1} |<    _1__nc2


and also,


                  | Prob {C2n [G3] = 1} - Prob {C2n [P2n ] = 1} |  <

          | Prob {C2n [G2; G3] = 1} - Prob {C2n [P2n ; P2n ] = 1} |<    _1__nc2


the above inequalities shows that both G2 and G3 are pseudorandom if they

are independent. This completes the proof of lemma 2.                       2



Theorem  1   Let  f1; f2; : :;:fi 2 Fn  such  that  G1 = _(fi; : :;:f1)  be  a

pseudorandom  permutation.   G1  is  super  pseudorandom  if  and  only  if

G2 = _(fi; : :;:f2)  and  G3 = _(f1; : :;:fi-1)  are  two  independent

permutations.



Proof  :

To prove the validity of Theorem 1, we first should show if  G2  and  G3  are

independent,  then  G1  is  super  pseudorandom._First, it is necessary to

show that G3 = _(f1; : :;:fi-1) and G 1 = _(f1; : :;:fi-1; fi) are independent *
 *of


each other. In order to prove this claim, by contradiction assume that they are

not independent, so

                             __                                          1
            | Prob {C2n [G3; G 1] = 1} - Prob {C2n [P2n ; P2n ] = 1} |  ____nc2


Without changing the inequality relation, we have,



                                __
               | Prob {C2n [G3; G 1] = 1} - Prob {C2n [G3; G3] = 1} +

          Prob {C2n [G3; G3] = 1} - Prob {C2n [P2n ; P2n ] = 1} |  _1__nc2


then,

                            __
           | Prob {C2n [G3; G 1] = 1} - Prob {C2n [G3; G3] = 1} |  +

          | Prob {C2n [G3; G3] = 1} - Prob {C2n [P2n ; P2n ] = 1} |     _1__nc2


If | Prob {C2n [G3; G3] = 1} - Prob {C2n [P2n ; P2n ] = 1} |  _1__nc2, then G3 *
 *is not

pseudorandom, which_contradicts our assumption. If

| Prob {C2n [G3; G 1] = 1} - Prob {C2n [G3; G3] = 1} |  _1__nc2, then the oracle

circuit virtually distinguishes fi from a randomly chosen function. This also

contradicts our assumption that fi is a pseudorandom function. Since both

cases_conclude to contradictions to our assumptions, it can be concluded G3

and G 1 should be independent_of each other.

Note that, in order that G 1 and G3 to be two independent permutations, there

is no need that the pseudorandom function fi be chosen independently from

f1; : :;:fi-1.

Considering the claim, when it is given that G2 and G3 are independent, then


            | Prob {C2n [G2; G3] = 1} - Prob {C2n [P2n ; P2n ] = 1} |< _1__nc2


Without changing the sign of inequality, we may expand the above relation as,



                             __                         __
            | Prob {C2n [G1; G 1] = 1} - Prob {C2n [G1; G 1] = 1}  +
                            __                         __
             Prob {C2n [G3; G 1] = 1} - Prob {C2n [G3; G 1] = 1}   +

          Prob {C2n [G2; G3] = 1} - Prob {C2n [P2n ; P2n ] = 1} |  <   _1__nc2


With reordering and separation of absolute values, we can get:

                                                       __
           || Prob {C2n [G2; G3] = 1} - Prob {C2n [G3; G 1] = 1} |  -
                             __                         __
            | Prob {C2n [G3; G 1] = 1} - Prob {C2n [G1; G 1] = 1} | -
                          __                                             1
         | Prob {C2n [G1; G 1] = 1} - Prob {C2n [P2n ; P2n ] = 1} ||<   ____nc2


Since, it was assumed_that G2 and G3 are two independent permutations,_and

so are G3 and G 1, then | Prob {C2n [G2; G3] = 1} - Prob {C2n [G3; G 1] = 1} |

would be less than _1__nc2, since

                                                      __
           | Prob {C2n [G2; G3] = 1} - Prob {C2n [G3; G 1] = 1} |  <

          | Prob {C2n [G2; G3] = 1} - Prob {C2n [P2n ; P2n ] = 1} |+
                           __                                            1
          | Prob {C2n [G3; G 1] = 1} - Prob {C2n [P2n ; P2n ] = 1} |<   ____nc2


Hence

                           __
          | Prob {C2n [G1; G 1] = 1} - Prob {C2n [P2n ; P2n ] = 1} |+
                            __                         __                1
           | Prob {C2n [G3; G 1] = 1} - Prob {C2n [G1; G 1] = 1} | <    ____nc2


So, each of the above absolute values would be less than _1__nc2. In other words

                             __                                          1
            | Prob {C2n [G1; G 1] = 1} - Prob {C2n [P2n ; P2n ] = 1} |< ____nc2

             __
Hence G1 and G 1 are independent of each other, and G1 is a super

pseudorandom permutation, as it is pseudorandom.

To conclude Theorem 1, we should also show that if  G1  is  a  super

pseudorandom  permutation,  then  G2  and  G3  are  two  independent

permutations. Hence, it is given that

                             __                                          1
            | Prob {C2n [G1; G 1] = 1} - Prob {C2n [P2n ; P2n ] = 1} |< ____nc2


Without changing the sign of inequality,

                             __                         __
            | Prob {C2n [G1; G 1] = 1} - Prob {C2n [G3; G 1] = 1}  +
                            __
             Prob {C2n [G3; G 1] = 1} - Prob {C2n [G3; G2] = 1}    +

          Prob {C2n [G3; G2] = 1} - Prob {C2n [P2n ; P2n ] = 1} |  <   _1__nc2


With reordering and separation of absolute values, we get:
