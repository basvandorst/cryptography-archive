--9a44 0014b4364e180040001 Page 1 of MANIFEST

7bf681 1 MANIFEST
63b635 2 README
476ecc 3 blaze.scr
8a49aa 4 cbc1.scr
581046 5 cbc2.scr
1feade 6 cbc3.scr
868e30 7 des.c
f3db2a 8 des.h
bbf31a 9 ecb.scr
039f0d 10 mini.scr
02ce39 11 misc.c
60fc96 12 misc.h
b51b5d 13 random.scr
cfb60c 14 ref.c
aa84bd 15 sim.c
0beac5 16 sim.h
4b2104 17 testvec.c

--926a 0011c402f8d80040002 Page 1 of README
e0af5a
3f1c37 testvec.c (compile with sim.c and des.c): ·Generates and runs test
9a0001 vectors. ·This program will both run existing input vectors, or·
08239f generate new ones (either randomly or from a script). ·When compiled
c43481 under DOS, it can either produce Unix (LF only) or DOS (CR/LF)
37d2c3 output files (select with the RAW parameter)
a1af5a
26a7b8 To run the ecb.scr sample script and:
473eef ··Store test vectors which go to the chip in TOCHIP.EXT
5b66ea ··Store test vectors received from the chip in FROMCHIP.EXT,

0763b5 ··Produce Unix-style output (LF only)
9e1741 ··Store debugging output in debug.out.
10af5a
f46e57 ····rm *.EXT
a1f54e ····testvec TOCHIP.EXT FROMCHIP.EXT RAW < ecb.scr > debug.out
c7ed9a ·································
1ff74b If TOCHIP.EXE already exists when the program is run, it will
917018 read it (instead of expecting a script from stdin).
60af5a
b4a916 Use the script random.scr to produce a random test vector, e.g.:
b7bdcd ····testvec TOCHIP.EXT FROMCHIP.EXT RAW < random.scr > debug.out
52af5a
d7ecf1 ----------------------------------------------------------------------------
b3af5a
4eaf5a
b0a8a2 ref.c (compile with des.c misc.c): ·Runs test scripts (.scr files)
0b7e68 and prints any keys that match. ·This is basically a stripped-down
abd9fb test vector generator for debugging purposes. ·(It doesn't make any
9749f1 attempt to match timings.)
2caf5a
1caf5a

--a854 001ab3b125780040003 Page 1 of blaze.scr
95a107 00 01 02 03 04 05 06 07 10 11 12 13 14 15 16 1720 21 22 23 24 25 26 2730 31 32 ¶
2e79b3 33 34 35 36 3740 41 42 43 44 45 46 4750 51 52 53 54 55 56 57
159ec4 0000000000000000 ···' XOR MASK
7e10d0 123456789ABCDEF0 ···' Ciphertext 0
690908 123456789ABCDEF0 ···' Ciphertext 1
9cb374 0F ·················' Plaintext byte mask
ebed5e 0 ··················' use CBC
72af2d 1 ··················' extra XOR
a25b0d 1 ··················' don't seed PRNG (use this input file)
fa2fcc 01020304050607 ·····' starting key
2b6f6b 8000 ···············' number of clocks
f8af5a
49af5a
29c4d8 d6 e9 89 fa ·'DES_DECRYPT(k=0D020304050612, c=123456789ABCDEF0)=B8 C0 1B 3E 35 ¶
84c98d DB 2F DE ·······00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F 10 11 12 13 14 ¶
b1422d 15 16 17 18 19 1A 1B 1C 1D 1E 1F 20 21 22 23 24 25 26 27 28 29 2A 2B 2C 2D 2E 2¶
89c4e2 F30 31 32 33 34 35 36 37 38 39 3A 3B 3C 3D 3E 3F 40 41 42 43 44 45 46 47 48 49 ¶
f7e1db 4A 4B 4C 4D 4E 4F50 51 52 53 54 55 56 57 58 59 5A 5B 5C 5D 5E 5F 60 61 62 63 64¶
58e46f ·65 66 67 68 69 6A 6B 6C 6D 6E 6F70 71 72 73 74 75 76 77 78 79 7A 7B 7C 7D 7E 7¶
ff0795 F 80 81 82 83 84 85 86 87 88 89 8A 8B 8C 8D 8E 8F90 91 92 93 94 95 96 97 98 99 ¶
505b42 9A 9B 9C 9D 9E 9F ·A0 A1 A2 A3 A4 A5 A6 A7 A8 A9 AA AB AC AD AE AFB0 B1 B2 B3 B¶
7fa3b9 4 B5 B6 B7 B8 B9 BA BB BC BD BE BF C0 C1 C2 C3 C4 C5 C6 C7 C8 C9 CA CB CC CD CE¶
f6f44d ·CFD0 D1 D2 D3 D4 D5 D6 D7 D8 D9 DA DB DC DD DE DF E0 E1 E2 E3 E4 E5 E6 E7 E8 E¶
ea8b9b 9 EA EB EC ED EE EFF0 F1 F2 F3 F4 F5 F6 F7 F8 F9 FA FB FC FD FE·
abaf5a


--a728 0015c860f9980040004 Page 1 of cbc1.scr
f64ce1 00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F 10 11 12 13 14 15 16 17 18 19 1¶
b53734 A 1B 1C 1D 1E 1F 20 21 22 23 24 25 26 27 28 29 2A 2B 2C 2D 2E 2F 30 31 32 33 34¶
5f0653 ·35 36 37 38 39 3A 3B 3C 3D 3E 3F 40 41 42 43 44 45 46 47 48 49 4A 4B 4C 4D 4E ¶
bc6d97 4F 50 51 52 53 54 55 56 57 58 59 5A 5B 5C 5D 5E 5F 60 61 62 63 64 65 66 67 68 6¶
a1cb67 9 6A 6B 6C 6D 6E 6F 70 71 72 73 74 75 76 77 78 79 7A 7B 7C 7D 7E 7F 80 81 82 83¶
b32164 ·84 85 86 87 88 89 8A 8B 8C 8D 8E 8F 90 91 92 93 94 95 96 97 98 99 9A 9B #9C 9D¶
d8a908 ·9E 9F A0 A1 A2 A3 A4 A5 A6 A7 A8 A9 AA AB AC AD AE AF B0 B1 B2 B3 B4 B5 B6 B7 ¶
babb7d B8 B9 BA BB BC BD BE BF C0 C1 C2 C3 C4 C5 C6 C7 C8 C9 CA CB CC CD CE CF D0 D1 D¶
54b467 2 D3 D4 D5 D6 D7 D8 D9 DA DB DC DD DE DF E0 E1 E2 E3 E4 E5 E6 E7 E8 E9 EA EB EC¶
c890fe ·ED EE EF F0 F1 F2 F3 F4 F5 F6 F7 F8 F9 FA FB FC FD FE FF
2f281f 37393b51def84190 ···' XOR MASK
1810d0 123456789ABCDEF0 ···' Ciphertext 0
596a3f 0102030405060708 ···' Ciphertext 1
b98c19 00 ·················' Plaintext byte mask
56cdad 1 ··················' use CBC
b0d84f 0 ··················' extra XOR
095b0d 1 ··················' don't seed PRNG (use this input file)
322fcc 01020304050607 ·····' starting key
359df9 10000 ··············' number of clocks
5caf5a


--a112 00101ebc6db80040005 Page 1 of cbc2.scr
f64ce1 00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F 10 11 12 13 14 15 16 17 18 19 1¶
b53734 A 1B 1C 1D 1E 1F 20 21 22 23 24 25 26 27 28 29 2A 2B 2C 2D 2E 2F 30 31 32 33 34¶
5f0653 ·35 36 37 38 39 3A 3B 3C 3D 3E 3F 40 41 42 43 44 45 46 47 48 49 4A 4B 4C 4D 4E ¶
bc6d97 4F 50 51 52 53 54 55 56 57 58 59 5A 5B 5C 5D 5E 5F 60 61 62 63 64 65 66 67 68 6¶
a1cb67 9 6A 6B 6C 6D 6E 6F 70 71 72 73 74 75 76 77 78 79 7A 7B 7C 7D 7E 7F 80 81 82 83¶
237dda ·84 85 86 87 88 89 8A 8B 8C 8D 8E 8F 90 91 92 93 94 95 96 97 98 99 9A 9B 9C 9D ¶
23435f 9E 9F A0 A1 A2 A3 A4 A5 A6 A7 A8 A9 AA AB AC AD AE AF B0 B1 B2 B3 B4 B5 B6 B7 B¶

1ce1f9 8 B9 BA # BB BC BD BE BF C0 C1 C2 C3 C4 C5 C6 C7 C8 C9 CA CB CC CD CE CF D0 D1 ¶
80796d D2 D3 D4 D5 D6 D7 D8 D9 DA DB DC DD DE DF E0 E1 E2 E3 E4 E5 E6 E7 E8 E9 EA EB E¶
0b8b2a C ED EE EF F0 F1 F2 F3 F4 F5 F6 F7 F8 F9 FA FB FC FD FE FF
56ac5f 423412341234123F ···' XOR MASK
0b327c 0000000000000000 ···' Ciphertext 0
ee53f1 1578345691832465 ···' Ciphertext 1
23e767 04 ·················' Plaintext byte mask
20cdad 1 ··················' use CBC
00d84f 0 ··················' extra XOR
795b0d 1 ··················' don't seed PRNG (use this input file)
12de95 FFFFFFFFFFFFF0 ·····' starting key
309df9 10000 ··············' number of clocks
01af5a






--3fb8 001348ab9e680040006 Page 1 of cbc3.scr
2c9f3b 00 01 02 03 04 05 07 08 09 0D 0E 0F 10 11 12 14 15 17 1A 1B 1C 1D 1F 20 21 24 2¶
bd57bd 5 28 29 2A 2B 2C 2E 30 31 32 35 36 37 39 3A 3C 3D 3E 40 42 43 44 45 48 49 4A 4B¶
1b6fb2 ·4C 4F 50 51 53 54 56 57 58 59 5C 5D 5F 61 62 63 64 66 67 69 6B 6C 6D 6F 70 71 ¶
6e57e8 72 73 77 78 7A 7B 7D 7E 7F 80 82 86 87 89 8A 8B 8C 8D 8E 90 92 93 94 95 97 98 9¶
753dfa 9 9A 9B 9E 9F A0 A2 A3 A4 A5 A6 A8 AA AC AD AE AF B0 B1 B3 B4 B7 B8 B9 F8 F9 FA¶
958c0a ·FB FC FD FF BB BC BD BE C0 C1 C3 C5 C6 C7 C8 C9 CA CB CC CD CE CF D0 D1 D2 D3 ¶
09fa11 D4 D5 D6 D7 D8 D9 DA DB DC DD DE DF E0 E1 E2 E3 E4 # E5 E6 E7 E8 E9 EA EB EC ED¶
473f52 ·EE EF F0 F1 F2 F3 F4 F5 F6 F7 F8 F9 FA FB FC FD FE FF
638b27 0124801248012480 ···' XOR MASK
3745a7 FFFFFFFFFFFFFFFF ···' Ciphertext 0
1d2ba4 0000000000000000 ···' Ciphertext 1
d6b12c 80 ·················' Plaintext byte mask
72cdad 1 ··················' use CBC
37d84f 0 ··················' extra XOR
e85b0d 1 ··················' don't seed PRNG (use this input file)
afa481 00000000000000 ·····' starting key
e49df9 10000 ··············' number of clocks
34af5a
--b787 000d22ad6f780040007 Page 1 of des.c
8d2d03 /*****************************************************************************
d729eb ·* ··········································································*
b2074d ·* ···············Software Model of ASIC DES Implementation. ················*
4a29eb ·* ··········································································*
9f9048 ·* ·Written by Paul Kocher, Tel: 415-397-0111, Email: paul@cryptography.com ·*
ce29eb ·* ··········································································*
e7489b ·*****************************************************************************
de29eb ·* ··········································································*
c515cb ·* ··IMPLEMENTATION NOTES: ··················································*
3429eb ·* ··········································································*
987602 ·* ··This DES implementation adheres to the FIPS PUB 46 spec and produces ···*
a90da9 ·* ··standard output. ·The internal operation of the algorithm is quite ·····*
9a876e ·* ··different from the FIPS. ·For example, bit orderings are reversed ······*
a41be6 ·* ··(the right-hand bit is now labelled as bit 0), the S tables have ·······*
06b9c7 ·* ··rearranged to simplify implementation, and several permutations have ···*
44966d ·* ··been inverted. ·No performance optimizations were attempted. ···········*
1829eb ·* ··········································································*
3e489b ·*****************************************************************************
aa29eb ·* ··········································································*
496eef ·* ··REVISION HISTORY: ······················································*
ba29eb ·* ··········································································*
0bc443 ·* ··Version 1.0: ·Initial release ·-- PCK. ·································*
d7b74c ·* ··Version 1.1: ·Altered DecryptDES exchanges to match EncryptDES. -- PCK ·*
fa5c27 ·* ··Version 1.2: ·Minor edits and beautifications. ·-- PCK ·················*
e0d8c3 ·*****************************************************************************/
9aaf5a
a8af5a
00feb2 #include <stdio.h>
a3bea3 #include <stdlib.h>
94324c #include <string.h>
e92bac #include "des.h"
fbaf5a
f77461 static void ComputeRoundKey(bool roundKey[56], bool key[56]);
6d84a3 static void RotateRoundKeyLeft(bool roundKey[56]);
57ccfa static void RotateRoundKeyRight(bool roundKey[56]);
741504 static void ComputeIP(bool L[32], bool R[32], bool inBlk[64]);
1c07da static void ComputeFP(bool outBlk[64], bool L[32], bool R[32]);
fe017b static void ComputeF(bool fout[32], bool R[32], bool roundKey[56]);
ef94fe static void ComputeP(bool output[32], bool input[32]);
7f7fae static void ComputeS_Lookup(int k, bool output[4], bool input[6]);
25abe7 static void ComputePC2(bool subkey[48], bool roundKey[56]);
fdfd9c static void ComputeExpansionE(bool expandedBlock[48], bool R[32]);
662f30 static void DumpBin(char *str, bool *b, int bits);
ad43bc static void Exchange_L_and_R(bool L[32], bool R[32]);
39af5a
efc223 int EnableDumpBin = 0;
f5af5a
7caf5a
84af5a
d84d6c /**********************************************************************/
a5c68f /* ···································································*/
033c1a /* ···························DES TABLES ·····························*/
14c68f /* ···································································*/
264d6c /**********************************************************************/
6faf5a
76af5a
8838e5 /*
aa556a ·* ·IP: Output bit table_DES_IP[i] equals input bit i.
30495d ·*/
09c166 static int table_DES_IP[64] = {
829d69 ····39, ·7, 47, 15, 55, 23, 63, 31,
10c827 ····38, ·6, 46, 14, 54, 22, 62, 30,
4b38ae ····37, ·5, 45, 13, 53, 21, 61, 29,
2b6de0 ····36, ·4, 44, 12, 52, 20, 60, 28,
f5b247 ····35, ·3, 43, 11, 51, 19, 59, 27,
c7e709 ····34, ·2, 42, 10, 50, 18, 58, 26,
28829e ····33, ·1, 41, ·9, 49, 17, 57, 25,
4811ff ····32, ·0, 40, ·8, 48, 16, 56, 24
2882f7 };
39af5a
95af5a
d238e5 /*
--43e9 000e122426b80040007 Page 2 of des.c
ac48ca ·* ·FP: Output bit table_DES_FP[i] equals input bit i.
c0495d ·*/
2ddd2a static int table_DES_FP[64] = {
675b71 ····57, 49, 41, 33, 25, 17, ·9, ·1,
768cd9 ····59, 51, 43, 35, 27, 19, 11, ·3,
b79996 ····61, 53, 45, 37, 29, 21, 13, ·5,
93b571 ····63, 55, 47, 39, 31, 23, 15, ·7,
040e3f ····56, 48, 40, 32, 24, 16, ·8, ·0,
62d997 ····58, 50, 42, 34, 26, 18, 10, ·2,
f5ccd8 ····60, 52, 44, 36, 28, 20, 12, ·4,
664da9 ····62, 54, 46, 38, 30, 22, 14, ·6
2d82f7 };
7baf5a
b0af5a
0f38e5 /*
85da05 ·* ·PC1: Permutation choice 1, used to pre-process the key
da495d ·*/
a40c38 static int table_DES_PC1[56] = {
0db89e ····27, 19, 11, 31, 39, 47, 55,
bb28e4 ····26, 18, 10, 30, 38, 46, 54,
cf8d2c ····25, 17, ·9, 29, 37, 45, 53,
ce1d56 ····24, 16, ·8, 28, 36, 44, 52,
62bf91 ····23, 15, ·7, ·3, 35, 43, 51,
d72feb ····22, 14, ·6, ·2, 34, 42, 50,
b491e6 ····21, 13, ·5, ·1, 33, 41, 49,
b0d02f ····20, 12, ·4, ·0, 32, 40, 48
1782f7 };
67af5a
16af5a
b638e5 /*
2af37a ·* ·PC2: Map 56-bit round key to a 48-bit subkey
89495d ·*/
097fcf static int table_DES_PC2[48] = {
e98889 ····24, 27, 20, ·6, 14, 10, ·3, 22,
1b30a5 ·····0, 17, ·7, 12, ·8, 23, 11, ·5,
893fa5 ····16, 26, ·1, ·9, 19, 25, ·4, 15,
dee272 ····54, 43, 36, 29, 49, 40, 48, 30,
566356 ····52, 44, 37, 33, 46, 35, 50, 41,
ab7786 ····28, 53, 51, 55, 32, 45, 39, 42
2a82f7 };

11af5a
c0af5a
2238e5 /*
9adb31 ·* ·E: Expand 32-bit R to 48 bits.
35495d ·*/
846a87 static int table_DES_E[48] = {
78e6fb ····31, ·0, ·1, ·2, ·3, ·4, ·3, ·4,
fa2634 ·····5, ·6, ·7, ·8, ·7, ·8, ·9, 10,
16d06b ····11, 12, 11, 12, 13, 14, 15, 16,
117fa0 ····15, 16, 17, 18, 19, 20, 19, 20,
184d0d ····21, 22, 23, 24, 23, 24, 25, 26,
139708 ····27, 28, 27, 28, 29, 30, 31, ·0
8a82f7 };
79af5a
cdaf5a
a738e5 /*
69c34a ·* ·P: Permutation of S table outputs
ea495d ·*/
745137 static int table_DES_P[32] = {
aaf612 ····11, 17, ·5, 27, 25, 10, 20, ·0,
3fb9f8 ····13, 21, ·3, 28, 29, ·7, 18, 24,
8fcde3 ····31, 22, 12, ·6, 26, ·2, 16, ·8,
d560a7 ····14, 30, ·4, 19, ·1, ·9, 15, 23
8482f7 };
79af5a
8eaf5a
d038e5 /*
2b6f34 ·* ·S Tables: Introduce nonlinearity and avalanche
d2495d ·*/
b71e19 static int table_DES_S[8][64] = {
8bd69a ····/* table S[0] */
e1846d ········{ ··13, ·1, ·2, 15, ·8, 13, ·4, ·8, ·6, 10, 15, ·3, 11, ·7, ·1, ·4,
--1f22 000be80f13a80040007 Page 3 of des.c
f065af ············10, 12, ·9, ·5, ·3, ·6, 14, 11, ·5, ·0, ·0, 14, 12, ·9, ·7, ·2,

12d5b0 ·············7, ·2, 11, ·1, ·4, 14, ·1, ·7, ·9, ·4, 12, 10, 14, ·8, ·2, 13,
5a3ee1 ·············0, 15, ·6, 12, 10, ·9, 13, ·0, 15, ·3, ·3, ·5, ·5, ·6, ·8, 11 ·},
d0d2b1 ····/* table S[1] */
8b4b6a ········{ ···4, 13, 11, ·0, ·2, 11, 14, ·7, 15, ·4, ·0, ·9, ·8, ·1, 13, 10,
0cdf4d ·············3, 14, 12, ·3, ·9, ·5, ·7, 12, ·5, ·2, 10, 15, ·6, ·8, ·1, ·6,
8bf575 ·············1, ·6, ·4, 11, 11, 13, 13, ·8, 12, ·1, ·3, ·4, ·7, 10, 14, ·7,
cf6234 ············10, ·9, 15, ·5, ·6, ·0, ·8, 15, ·0, 14, ·5, ·2, ·9, ·3, ·2, 12 ·},
38decc ····/* table S[2] */
7df108 ········{ ··12, 10, ·1, 15, 10, ·4, 15, ·2, ·9, ·7, ·2, 12, ·6, ·9, ·8, ·5,
a3d582 ·············0, ·6, 13, ·1, ·3, 13, ·4, 14, 14, ·0, ·7, 11, ·5, ·3, 11, ·8,
fd0bbf ·············9, ·4, 14, ·3, 15, ·2, ·5, 12, ·2, ·9, ·8, ·5, 12, 15, ·3, 10,
137505 ·············7, 11, ·0, 14, ·4, ·1, 10, ·7, ·1, ·6, 13, ·0, 11, ·8, ·6, 13 ·},
9fdae7 ····/* table S[3] */
f35c4d ········{ ···2, 14, 12, 11, ·4, ·2, ·1, 12, ·7, ·4, 10, ·7, 11, 13, ·6, ·1,
2c0156 ·············8, ·5, ·5, ·0, ·3, 15, 15, 10, 13, ·3, ·0, ·9, 14, ·8, ·9, ·6,
def5dc ·············4, 11, ·2, ·8, ·1, 12, 11, ·7, 10, ·1, 13, 14, ·7, ·2, ·8, 13,
62d332 ············15, ·6, ·9, 15, 12, ·0, ·5, ·9, ·6, 10, ·3, ·4, ·0, ·5, 14, ·3 ·},
97c636 ····/* table S[4] */
d74850 ········{ ···7, 13, 13, ·8, 14, 11, ·3, ·5, ·0, ·6, ·6, 15, ·9, ·0, 10, ·3,
aef1a6 ·············1, ·4, ·2, ·7, ·8, ·2, ·5, 12, 11, ·1, 12, 10, ·4, 14, 15, ·9,
5af43f ············10, ·3, ·6, 15, ·9, ·0, ·0, ·6, 12, 10, 11, ·1, ·7, 13, 13, ·8,
87d830 ············15, ·9, ·1, ·4, ·3, ·5, 14, 11, ·5, 12, ·2, ·7, ·8, ·2, ·4, 14 ·},
fbc21d ····/* table S[5] */
e2ea9b ········{ ··10, 13, ·0, ·7, ·9, ·0, 14, ·9, ·6, ·3, ·3, ·4, 15, ·6, ·5, 10,
35bd2c ·············1, ·2, 13, ·8, 12, ·5, ·7, 14, 11, 12, ·4, 11, ·2, 15, ·8, ·1,
55d567 ············13, ·1, ·6, 10, ·4, 13, ·9, ·0, ·8, ·6, 15, ·9, ·3, ·8, ·0, ·7,
9b8261 ············11, ·4, ·1, 15, ·2, 14, 12, ·3, ·5, 11, 10, ·5, 14, ·2, ·7, 12 ·},
09ce60 ····/* table S[6] */
fea636 ········{ ··15, ·3, ·1, 13, ·8, ·4, 14, ·7, ·6, 15, 11, ·2, ·3, ·8, ·4, 14,
baac1c ·············9, 12, ·7, ·0, ·2, ·1, 13, 10, 12, ·6, ·0, ·9, ·5, 11, 10, ·5,
677311 ·············0, 13, 14, ·8, ·7, 10, 11, ·1, 10, ·3, ·4, 15, 13, ·4, ·1, ·2,
f8b1aa ·············5, 11, ·8, ·6, 12, ·7, ·6, 12, ·9, ·0, ·3, ·5, ·2, 14, 15, ·9 ·},
c1ca4b ····/* table S[7] */
e8cf66 ········{ ··14, ·0, ·4, 15, 13, ·7, ·1, ·4, ·2, 14, 15, ·2, 11, 13, ·8, ·1,
e3aacb ·············3, 10, 10, ·6, ·6, 12, 12, 11, ·5, ·9, ·9, ·5, ·0, ·3, ·7, ·8,
fa2f45 ·············4, 15, ·1, 12, 14, ·8, ·8, ·2, 13, ·4, ·6, ·9, ·2, ·1, 11, ·7,
252777 ············15, ·5, 12, 11, ·9, ·3, ·7, 14, ·3, 10, 10, ·0, ·5, ·6, ·0, 13 ·}
0d82f7 };
44af5a
88af5a
1eaf5a
51af5a
be4d6c /**********************************************************************/
25c68f /* ···································································*/
4ecabf /* ····························DES CODE ······························*/
77c68f /* ···································································*/
494d6c /**********************************************************************/
e8af5a
8aaf5a
9138e5 /*
11b080 ·* ·EncryptDES: Encrypt a block using DES. Set verbose for debugging info.
65770b ·* ·(This loop does both loops on the "DES Encryption" page of the flowchart.)
1e495d ·*/
5a5620 void EncryptDES(bool key[56], bool outBlk[64], bool inBlk[64], int verbose) {
d72b1c ··int i,round;
3a9aa1 ··bool R[32], L[32], fout[32];
1cbfaf ··bool roundKey[56];
24af5a
eb94e2 ··EnableDumpBin = verbose; ···················/* set debugging on/off flag */
ebcb2a ··DumpBin("input(left)", inBlk+32, 32);
558fb2 ··DumpBin("input(right)", inBlk, 32);
bc0a8e ··DumpBin("raw key(left )", key+28, 28);
8a5585 ··DumpBin("raw key(right)", key, 28);
eeaf5a
f4c1be ··/* Compute the first roundkey by performing PC1 */
53b264 ··ComputeRoundKey(roundKey, key);
86af5a
6795d4 ··DumpBin("roundKey(L)", roundKey+28, 28);
070a5f ··DumpBin("roundKey(R)", roundKey, 28);
09af5a
be1340 ··/* Compute the initial permutation and divide the result into L and R */
--e2ca 0004f895fba80040007 Page 4 of des.c
d8d1a8 ··ComputeIP(L,R,inBlk);
c8af5a
b277ba ··DumpBin("after IP(L)", L, 32);
4b7699 ··DumpBin("after IP(R)", R, 32);
56af5a
44f437 ··for (round = 0; round < 16; round++) {
d221bf ····if (verbose)
5f91a0 ······printf("-------------- BEGIN ENCRYPT ROUND %d -------------\n", round);
aa8034 ····DumpBin("round start(L)", L, 32);
ec8117 ····DumpBin("round start(R)", R, 32);
d8af5a
f27fc3 ····/* Rotate roundKey halves left once or twice (depending on round) */
3ec8ba ····RotateRoundKeyLeft(roundKey);
031467 ····if (round != 0 && round != 1 && round != 8 && round != 15)
9650e7 ······RotateRoundKeyLeft(roundKey);
dd3cd7 ····DumpBin("roundKey(L)", roundKey+28, 28);
3f1bd4 ····DumpBin("roundKey(R)", roundKey, 28);
8baf5a
2a033b ····/* Compute f(R, roundKey) and exclusive-OR onto the value in L */
73d969 ····ComputeF(fout, R, roundKey);
1054e7 ····DumpBin("f(R,key)", fout, 32);

834739 ····for (i = 0; i < 32; i++)
eaa9e6 ······L[i] ^= fout[i];
aca5ab ····DumpBin("L^f(R,key)", L, 32);
92af5a
8f68b4 ····Exchange_L_and_R(L,R);
c2af5a
a5a140 ····DumpBin("round end(L)", L, 32);
9da063 ····DumpBin("round end(R)", R, 32);
0c21bf ····if (verbose)
ee4514 ······printf("--------------- END ROUND %d --------------\n", round);
bedf1c ··}
39af5a
f08e68 ··Exchange_L_and_R(L,R);
7baf5a
a7370b ··/* Combine L and R then compute the final permutation */
e3cf94 ··ComputeFP(outBlk,L,R);

668b91 ··DumpBin("FP out( left)", outBlk+32, 32);
a4f675 ··DumpBin("FP out(right)", outBlk, 32);
ffefe6 }
bbaf5a
64af5a
1faf5a
2638e5 /*
c19b68 ·* ·DecryptDES: Decrypt a block using DES. Set verbose for debugging info.
83a5c7 ·* ·(This loop does both loops on the "DES Decryption" page of the flowchart.)
7e495d ·*/
c36de8 void DecryptDES(bool key[56], bool outBlk[64], bool inBlk[64], int verbose) {
c02b1c ··int i,round;
a89aa1 ··bool R[32], L[32], fout[32];
52bfaf ··bool roundKey[56];
87af5a
6e94e2 ··EnableDumpBin = verbose; ···················/* set debugging on/off flag */
e2cb2a ··DumpBin("input(left)", inBlk+32, 32);

ef8fb2 ··DumpBin("input(right)", inBlk, 32);
340a8e ··DumpBin("raw key(left )", key+28, 28);
ed5585 ··DumpBin("raw key(right)", key, 28);
9faf5a
3ac1be ··/* Compute the first roundkey by performing PC1 */
20b264 ··ComputeRoundKey(roundKey, key);
afaf5a
c595d4 ··DumpBin("roundKey(L)", roundKey+28, 28);
c90a5f ··DumpBin("roundKey(R)", roundKey, 28);
f4af5a
311340 ··/* Compute the initial permutation and divide the result into L and R */
03d1a8 ··ComputeIP(L,R,inBlk);
a8af5a
c277ba ··DumpBin("after IP(L)", L, 32);
2f7699 ··DumpBin("after IP(R)", R, 32);
a6af5a
1bf437 ··for (round = 0; round < 16; round++) {
4f21bf ····if (verbose)
--4cd6 000642b0cd180040007 Page 5 of des.c
db2cb4 ······printf("-------------- BEGIN DECRYPT ROUND %d -------------\n", round);
908034 ····DumpBin("round start(L)", L, 32);
a48117 ····DumpBin("round start(R)", R, 32);
c5af5a
3d033b ····/* Compute f(R, roundKey) and exclusive-OR onto the value in L */
b5d969 ····ComputeF(fout, R, roundKey);
5d54e7 ····DumpBin("f(R,key)", fout, 32);
c84739 ····for (i = 0; i < 32; i++)


d5a9e6 ······L[i] ^= fout[i];
5ba5ab ····DumpBin("L^f(R,key)", L, 32);

b2af5a
fa68b4 ····Exchange_L_and_R(L,R);
18af5a
f3c90d ····/* Rotate roundKey halves right once or twice (depending on round) */
6e48f3 ····DumpBin("roundKey(L)", roundKey+28, 28); ·/* show keys before shift */
7f1bd4 ····DumpBin("roundKey(R)", roundKey, 28);
90f5db ····RotateRoundKeyRight(roundKey);
8711ff ····if (round != 0 && round != 7 && round != 14 && round != 15)
ba7c23 ······RotateRoundKeyRight(roundKey);
5baf5a
69a140 ····DumpBin("round end(L)", L, 32);
c6a063 ····DumpBin("round end(R)", R, 32);
f621bf ····if (verbose)

784514 ······printf("--------------- END ROUND %d --------------\n", round);
23df1c ··}
30af5a
ec8e68 ··Exchange_L_and_R(L,R);
f5af5a
f5370b ··/* Combine L and R then compute the final permutation */
f5cf94 ··ComputeFP(outBlk,L,R);
8d8b91 ··DumpBin("FP out( left)", outBlk+32, 32);
94f675 ··DumpBin("FP out(right)", outBlk, 32);
efefe6 }
3daf5a
deaf5a
41af5a
fc38e5 /*
4b8d8b ·* ·ComputeRoundKey: Compute PC1 on the key and store the result in roundKey
c1495d ·*/
3e988e static void ComputeRoundKey(bool roundKey[56], bool key[56]) {
9e17e0 ··int i;
60af5a
f9815b ··for (i = 0; i < 56; i++)
70d64b ····roundKey[table_DES_PC1[i]] = key[i];
54efe6 }
24af5a
8caf5a
daaf5a
1b38e5 /*
8155cb ·* ·RotateRoundKeyLeft: Rotate each of the halves of roundKey left one bit
44495d ·*/
737d60 static void RotateRoundKeyLeft(bool roundKey[56]) {
cf483e ··bool temp1, temp2;
7217e0 ··int i;
c7af5a
0ff689 ··temp1 = roundKey[27];
83fe1b ··temp2 = roundKey[55];

9c300b ··for (i = 27; i >= 1; i--) {
95575a ····roundKey[i] = roundKey[i-1];
0b3242 ····roundKey[i+28] = roundKey[i+28-1];
aadf1c ··}
bc7b9f ··roundKey[ 0] = temp1;
b3cf9d ··roundKey[28] = temp2;
51efe6 }
fbaf5a
5caf5a
51af5a
0c38e5 /*

3bc6ad ·* ·RotateRoundKeyRight: Rotate each of the halves of roundKey right one bit
87495d ·*/
57b26c static void RotateRoundKeyRight(bool roundKey[56]) {
64483e ··bool temp1, temp2;
--20a0 000e89a59d480040007 Page 6 of des.c
eb17e0 ··int i;
71af5a
085025 ··temp1 = roundKey[0];
754548 ··temp2 = roundKey[28];
78e568 ··for (i = 0; i < 27; i++) {
806cc2 ····roundKey[i] = roundKey[i+1];
fd09da ····roundKey[i+28] = roundKey[i+28+1];
c1df1c ··}
d5a88d ··roundKey[27] = temp1;
365d11 ··roundKey[55] = temp2;
29efe6 }
5daf5a
45af5a
d8af5a
2f38e5 /*
022903 ·* ·ComputeIP: Compute the initial permutation and split into L and R halves.
fb495d ·*/
fcac44 static void ComputeIP(bool L[32], bool R[32], bool inBlk[64]) {
826085 ··bool output[64];
f917e0 ··int i;
bdaf5a
81aeaf ··/* Permute
71f9a6 ···*/
466406 ··for (i = 63; i >= 0; i--)
a8c750 ····output[table_DES_IP[i]] = inBlk[i];
0aaf5a
af0318 ··/* Split into R and L. ·Bits 63..32 go in L, bits 31..0 go in R.
54f9a6 ···*/
b8ba85 ··for (i = 63; i >= 0; i--) {
5b0368 ····if (i >= 32)
67f2b8 ······L[i-32] = output[i];
50842c ····else
7970b5 ······R[i] = output[i];
22df1c ··}
04efe6 }
46af5a
c0af5a
96af5a
6a38e5 /*
d84ffe ·* ·ComputeFP: Combine the L and R halves and do the final permutation.
65495d ·*/
9893a5 static void ComputeFP(bool outBlk[64], bool L[32], bool R[32]) {
ee42e9 ··bool input[64];
0b17e0 ··int i;
0faf5a
056c41 ··/* Combine L and R into input[64]
30f9a6 ···*/
836406 ··for (i = 63; i >= 0; i--)
5a8397 ····input[i] = (i >= 32) ? L[i - 32] : R[i];
4caf5a
97aeaf ··/* Permute
1cf9a6 ···*/
e16406 ··for (i = 63; i >= 0; i--)
fbe116 ····outBlk[table_DES_FP[i]] = input[i];
c4efe6 }
3baf5a
13af5a
b9af5a
a438e5 /*
33810f ·* ·ComputeF: Compute the DES f function and store the result in fout.
14495d ·*/
af2720 static void ComputeF(bool fout[32], bool R[32], bool roundKey[56]) {
a9f6a2 ··bool expandedBlock[48], subkey[48], sout[32];
51bbe6 ··int i,k;
23af5a
291a04 ··/* Expand R into 48 bits using the E expansion */
a599d7 ··ComputeExpansionE(expandedBlock, R);
f1f0ba ··DumpBin("expanded E", expandedBlock, 48);
81af5a
7c93ff ··/* Convert the roundKey into the subkey using PC2 */
f17840 ··ComputePC2(subkey, roundKey);
e8d717 ··DumpBin("subkey", subkey, 48);
--4509 0001cf13c2680040007 Page 7 of des.c
e0af5a
c3154c ··/* XOR the subkey onto the expanded block */
adfcab ··for (i = 0; i < 48; i++)
4f6512 ····expandedBlock[i] ^= subkey[i];
c0af5a
870740 ··/* Divide expandedBlock into 6-bit chunks and do S table lookups */
1d25c6 ··for (k = 0; k < 8; k++)
6585c7 ····ComputeS_Lookup(k, sout+4*k, expandedBlock+6*k);
f8af5a
b3fd35 ··/* To complete the f() calculation, do permutation P on the S table output */
e92d52 ··ComputeP(fout, sout);
deefe6 }
3baf5a
25af5a
0faf5a
8438e5 /*
00913f ·* ·ComputeP: Compute the P permutation on the S table outputs.
25495d ·*/
0bf410 static void ComputeP(bool output[32], bool input[32]) {
5a17e0 ··int i;
b6af5a
95339a ··for (i = 0; i < 32; i++)
347688 ····output[table_DES_P[i]] = input[i];
57efe6 }
80af5a
67af5a
75af5a
e638e5 /*

2a859b ·* ·Look up a 6-bit input in S table k and store the result as a 4-bit output.
2e495d ·*/
59a67e static void ComputeS_Lookup(int k, bool output[4], bool input[6]) {
d0f3da ··int inputValue, outputValue;
3daf5a
261a9e ··/* Convert the input bits into an integer */
e2fccb ··inputValue = input[0] + 2*input[1] + 4*input[2] + 8*input[3] +
468c1a ··········16*input[4] + 32*input[5];
1caf5a
a64a3e ··/* Do the S table lookup */
a2b706 ··outputValue = table_DES_S[k][inputValue];
eeaf5a
df8aed ··/* Convert the result into binary form */
529a60 ··output[0] = (outputValue & 1) ? 1 : 0;
2c6aec ··output[1] = (outputValue & 2) ? 1 : 0;
a4f487 ··output[2] = (outputValue & 4) ? 1 : 0;
208c7f ··output[3] = (outputValue & 8) ? 1 : 0;
27efe6 }
dcaf5a
d8af5a
f4af5a
5938e5 /*
9781cc ·* ·ComputePC2: Map a 56-bit round key onto a 48-bit subkey
a8495d ·*/
07796f static void ComputePC2(bool subkey[48], bool roundKey[56]) {
ea17e0 ··int i;
2faf5a
64fcab ··for (i = 0; i < 48; i++)
c3c8bc ····subkey[i] = roundKey[table_DES_PC2[i]];
f8efe6 }
89af5a
4eaf5a
8eaf5a
3b38e5 /*
7a459d ·* ·ComputeExpansionE: Compute the E expansion to prepare to use S tables.
89495d ·*/
89b46d static void ComputeExpansionE(bool expandedBlock[48], bool R[32]) {
bf17e0 ··int i;
94af5a
79fcab ··for (i = 0; i < 48; i++)
d9b971 ····expandedBlock[i] = R[table_DES_E[i]];
8fefe6 }
9daf5a
1caf5a
--bb13 0016ae66eb080040007 Page 8 of des.c
e0af5a
d338e5 /*
4cf923 ·* ·Exchange_L_and_R: ·Swap L and R
ba495d ·*/
f195d1 static void Exchange_L_and_R(bool L[32], bool R[32]) {
3f17e0 ··int i;
c2af5a
74339a ··for (i = 0; i < 32; i++)
19fe8b ····L[i] ^= R[i] ^= L[i] ^= R[i]; ····/* exchanges L[i] and R[i] */
3cefe6 }
4faf5a
72af5a
feaf5a
a438e5 /*
439231 ·* ·DumpBin: Display intermediate values if emableDumpBin is set.
52495d ·*/
9cdbd9 static void DumpBin(char *str, bool *b, int bits) {
0217e0 ··int i;
80af5a
c98af7 ··if ((bits % 4)!=0 || bits>48) {
17b2e5 ····printf("Bad call to DumpBin (bits > 48 or bit len not a multiple of 4\n");
4b646c ····exit(1);
a6df1c ··}
adaf5a
783332 ··if (EnableDumpBin) {
35f079 ····for (i = strlen(str); i < 14; i++)
1ac8c3 ······printf(" ");
1c5fc3 ····printf("%s: ", str);
56eac8 ····for (i = bits-1; i >= 0; i--)
22de5b ······printf("%d", b[i]);
123177 ····printf(" ");
9c821f ····for (i = bits; i < 48; i++)
72c8c3 ······printf(" ");
d86b57 ····printf("(");
9105d7 ····for (i = bits-4; i >= 0; i-=4)
c6f78c ······printf("%X", b[i]+2*b[i+1]+4*b[i+2]+8*b[i+3]);
89fa6f ····printf(")\n");
e4df1c ··}
56efe6 }
6aaf5a
--e8aa 0017f449fe180040008 Page 1 of des.h
3008c5 typedef char bool;
d29629 void EncryptDES(bool key[56], bool outBlk[64], bool inBlk[64], int verbose);
2e8db3 void DecryptDES(bool key[56], bool outBlk[64], bool inBlk[64], int verbose);
7faf5a
--842b 001c97afa9d80040009 Page 1 of ecb.scr
f64ce1 00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F 10 11 12 13 14 15 16 17 18 19 1¶
fdb9bc A 1B 1C 1D 1E 1F 20 21 22 23 24 25 26 27 28 29 2A 2B 2C 2D 2E 2F30 31 32 33 34 ¶
b5f9a7 35 36 37 38 39 3A 3B 3C 3D 3E 3F 40 41 42 43 44 45 46 47 48 49 4A 4B 4C 4D 4E 4¶
4c9b42 F50 51 52 53 54 55 56 57 58 59 5A 5B 5C 5D 5E 5F 60 61 62 63 64 65 66 67 68 69 ¶
57b101 6A 6B 6C 6D 6E 6F70 71 72 73 74 75 76 77 78 79 7A 7B 7C 7D 7E 7F 80 81 82 83 84¶
5c2c39 ·85 86 87 88 89 8A 8B 8C 8D 8E 8F90 91 92 93 94 95 96 97 98 99 9A 9B 9C 9D 9E 9¶
4a1c73 F # A0 A1 A2 A3 A4 A5 A6 A7 A8 A9 AA AB AC AD AE AFB0 B1 B2 B3 B4 B5 B6 B7 B8 B¶
36fc0a 9 BA BB BC BD BE BF C0 C1 C2 C3 C4 C5 C6 C7 C8 C9 CA CB CC CD CE CFD0 D1 D2 D3 ¶
5b5b61 D4 D5 D6 D7 D8 D9 DA DB DC DD DE DF E0 E1 E2 E3 E4 E5 E6 E7 E8 E9 EA EB EC ED E¶
ea9439 E EFF0 F1 F2 F3 F4 F5 F6 F7 F8 F9 FA FB FC FD FE FF
829ec4 0000000000000000 ···' XOR MASK
b745a7 FFFFFFFFFFFFFFFF ···' Ciphertext 0
642ba4 0000000000000000 ···' Ciphertext 1
658c19 00 ·················' Plaintext byte mask
aacdad 1 ··················' use CBC
ffd84f 0 ··················' extra XOR
fb5b0d 1 ··················' don't seed PRNG (use this input file)
332fcc 01020304050607 ·····' starting key
769df9 10000 ··············' number of clocks
c9af5a
--cc30 001d5e0f0268004000a Page 1 of mini.scr
d6f4f1 5C416114B9D1D2D9B2550DF690FA75E798CC26203B1D79EB346229EDADE314B483321AA44BA4233¶
8ec7a2 8899568FDF85C1A9DEF1DE864EB2EAB4E52D7E075ADAA992D85DBAC85DD3A9A32
f39ec4 0000000000000000 ···' XOR MASK
fc10d0 123456789ABCDEF0 ···' Ciphertext 0
2e6a3f 0102030405060708 ···' Ciphertext 1
8b8c19 00 ·················' Plaintext byte mask
a1ed5e 0 ··················' use CBC
89d84f 0 ··················' extra XOR
ad5b0d 1 ··················' don't seed PRNG (use this input file)
6eabc7 010203040505D5 ·····' starting key
80d03f 2000 ················' number of clocks
d5af5a
--1b19 000748214c28004000b Page 1 of misc.c
56feb2 #include <stdio.h>
a1bea3 #include <stdlib.h>
a9c737 #include <memory.h>
79324c #include <string.h>
242bac #include "des.h"
3da50a #include "misc.h"
feaf5a
985854 #define VERBOSE
69af5a
1ac502 void GetUserInfo(unsigned char plaintextVector[32],·
d257e7 ········unsigned char plaintextXorMask[8],·
13910f ········unsigned char ciphertext0[8], unsigned char ciphertext[8],

5e446e ········unsigned char *plaintextByteMask, int *useCBC, int *extraXor,
0ee00d ········int *quickStart, unsigned char startKey[7], long *numClocks);
2b0986 void increment32(unsigned char *v);
5fb70b void decrement32(unsigned char *v);
61f314 void desDecrypt(unsigned char m[8], unsigned char c[8], unsigned char k[7]);
f5a5c5 void printHexString(char *tag, unsigned char *data, int len);
29708e static void EXIT_ERR(char *s) { fprintf(stderr, s); exit(1); }
f1560a int hex2bin(char *hex, unsigned char *bin);
87af5a
f3af5a
56c502 void GetUserInfo(unsigned char plaintextVector[32],·
6e57e7 ········unsigned char plaintextXorMask[8],·
d31fa8 ········unsigned char ciphertext0[8], unsigned char ciphertext1[8],
ad446e ········unsigned char *plaintextByteMask, int *useCBC, int *extraXor,
7c3170 ········int *quickStart, unsigned char startKey[7], long *numClocks) {
970e71 ··char buffer[1024];
8cc6d6 ··unsigned char tmp[512];
ea17e0 ··int i;
b8af5a
ff4264 #ifdef VERBOSE
18659f ··printf("Enter plaintextVector values: ");
657454 #endif
89766e ··gets(buffer);
30b72a ··i = hex2bin(buffer, tmp);
b053dd ··if (i <= 0 || i >= 256)
bc112c ····EXIT_ERR("Must have at least 1 plaintextVector entry and at most 255.\n");
141bcb ··memset(plaintextVector, 0, 32);
55f545 ··while (i--)
4a0422 ····plaintextVector[tmp[i]/8] |= (128 >> (tmp[i] % 8));
46af5a
f74264 #ifdef VERBOSE
92ee8b ··printf(" ···Enter plaintext xor mask: ");

267454 #endif
7d766e ··gets(buffer);
ecb72a ··i = hex2bin(buffer, tmp);
a11856 ··if (i != 8)
9ea670 ····EXIT_ERR("Must have 8 plaintext xor mask bytes.");
11b657 ··memcpy(plaintextXorMask, tmp, 8);
8caf5a
0d4264 #ifdef VERBOSE
3c3a0c ··printf(" ·········Enter ciphertext 0: ");
9c7454 #endif
91766e ··gets(buffer);
34b72a ··i = hex2bin(buffer, tmp);
211856 ··if (i != 8)
adcf62 ····EXIT_ERR("Must have 8 bytes in ciphertext 0.");
6398f3 ··memcpy(ciphertext0, tmp, 8);
2baf5a
cd4264 #ifdef VERBOSE
31a5d9 ··printf(" ·········Enter ciphertext 1: ");
797454 #endif
a6766e ··gets(buffer);
52b72a ··i = hex2bin(buffer, tmp);
a01856 ··if (i != 8)
eccb49 ····EXIT_ERR("Must have 8 bytes in ciphertext 1.");
b11da6 ··memcpy(ciphertext1, tmp, 8);
05af5a
184264 #ifdef VERBOSE
f5d221 ··printf(" ··Enter plaintext byte mask: ");
747454 #endif
--9cbe 0004b9f4b098004000b Page 2 of misc.c
74766e ··gets(buffer);
82b72a ··i = hex2bin(buffer, tmp);
8a8448 ··if (i != 1)

b7f706 ····EXIT_ERR("Plaintext byte mask is 1 byte long.");
6bc2b5 ··*plaintextByteMask = tmp[0];
7aaf5a
9d4264 #ifdef VERBOSE
7d1b21 ··printf(" ······Enter useCBC (0 or 1): ");
f57454 #endif
56766e ··gets(buffer);
eab72a ··i = hex2bin(buffer, tmp);
e515b9 ··if (i != 1 || tmp[0] > 1)
b819c6 ····EXIT_ERR("Must enter 0 or 1 for useCBC.");
68e2c1 ··*useCBC = tmp[0];
37af5a
264264 #ifdef VERBOSE
7bf965 ··printf(" ····Enter extraXor (0 or 1): ");
887454 #endif
4e766e ··gets(buffer);
61b72a ··i = hex2bin(buffer, tmp);
7e15b9 ··if (i != 1 || tmp[0] > 1)
776c75 ····EXIT_ERR("Must enter 0 or 1 for extraXor.");
522353 ··*extraXor = tmp[0];
29af5a
a04264 #ifdef VERBOSE
a7e0e1 ··printf(" ··Enter quickStart (0 or 1): ");
757454 #endif
ce766e ··gets(buffer);
19b72a ··i = hex2bin(buffer, tmp);
a015b9 ··if (i != 1 || tmp[0] > 1)
b12f69 ····EXIT_ERR("Must enter 0 or 1 for quickStart\n");
83bd7b ··*quickStart = tmp[0];
91af5a
0eaf5a
514264 #ifdef VERBOSE
02c8bf ··printf(" ·········Enter starting key: ");
187454 #endif
d3766e ··gets(buffer);
08e684 ··if (hex2bin(buffer, tmp) != 7)
f6a5e4 ····EXIT_ERR("Must enter 7 hex bytes as the key.\n");
130ed3 ··memcpy(startKey, tmp, 7);
86af5a
5f4264 #ifdef VERBOSE
43f4f6 ··printf(" ·····Enter number of clocks: ");
1c7454 #endif
6f766e ··gets(buffer);
c677e8 ··sscanf(buffer, "%ld", numClocks);
4b8b81 ··if (*numClocks < 1 || *numClocks > 1000000000L)
d6b093 ····EXIT_ERR("Must have between 1 and 1 billion clocks.\n");
6daf5a
134264 #ifdef VERBOSE
db186d ··printHexString("\n ·PtxtVector = ", plaintextVector, 32);
a4a738 ··printHexString(" PtxtXorMask = ", plaintextXorMask, 8);
5dffc6 ··printHexString("Ciphertext 0 = ", ciphertext0, 8);
b93b57 ··printHexString("Ciphertext 1 = ", ciphertext1, 8);
99dd31 ··printHexString("PtxtByteMask = ", plaintextByteMask, 1);
72e15b ··printf( ·······" ·····useCBC = %d\n", *useCBC);
2b2f30 ··printf( ·······" ···extraXor = %d\n", *extraXor);
6817dc ··printf( ·······" ·quickStart = %d\n", *quickStart);
5f1535 ··printHexString("Starting key = ", startKey, 7);
157214 ··printf( ·······"Total clocks = %ld\n\n", *numClocks);
517454 #endif
ebefe6 }
7caf5a
25af5a
020b42 void increment32(unsigned char *v) {
fae2f8 ··if ((++(v[3])) == 0)
c7ab75 ····if ((++(v[2])) == 0)
74b31a ······if ((++(v[1])) == 0)

584058 ········++v[0];
9befe6 }
4baf5a
--0a18 0005d5aab618004000b Page 3 of misc.c
e45411 void decrement32(unsigned char *v) {
0dc266 ··if (((v[3])--) == 0)
b2dbd7 ····if (((v[2])--) == 0)
f033fc ······if (((v[1])--) == 0)
2a3c05 ········v[0]--;
d8efe6 }
adaf5a



e6bc23 void desDecrypt(unsigned char m[8], unsigned char c[8], unsigned char k[7]) {
15f65b ··bool key[56], message[64];
fd17e0 ··int i;
68af5a
54ec0c // ·printf("DES_DECRYPT(k="); for (i=0; i<7;i++) printf("%02X",k[i]); ·//!!!
4cf514 // ·printf(", c="); for (i=0; i<8;i++) printf("%02X",c[i]); ···········//!!!
f8af5a
13815b ··for (i = 0; i < 56; i++)
ae9345 ····key[55-i] = ((k[i/8] << (i & 7)) & 128) ? 1 : 0;
f35c33 ··for (i = 0; i < 64; i++)
10e5ed ····message[63-i] = ((c[i/8] << (i & 7)) & 128) ? 1 : 0;
eac59d ··DecryptDES(key, message, message, 0);
5b1f76 ··for (i = 0; i < 8; i++)
6f452e ····m[i] = 0;
f55c33 ··for (i = 0; i < 64; i++)
fa7511 ····if (message[63-i])
59fe29 ······m[i/8] |= 128 >> (i%8);
f2af5a
04641f // ·printf(")="); for (i=0; i<8;i++) printf("%02X",m[i]); printf("\n"); //!!!
b8af5a
43efe6 }
17af5a
e5af5a
30c2bf int unhex(char c) {
bc53c4 ··if (c >= '0' && c <= '9')
1603d6 ····return (c - '0');
8d8db1 ··if (c >= 'a' && c <= 'f')
480ada ····return (c - 'a' + 10);
3449e3 ··if (c >= 'A' && c <= 'F')
28a66f ····return (c - 'A' + 10);
c712d4 ··return (-1);
2eefe6 }
85af5a
46af5a
ed4579 int hex2bin(char *hex, unsigned char *bin) {
53c22f ··int i = 0;
876a41 ··int j = 0;
efaf5a
598ef6 ··/* Trim string if comments present */
b08b28 ··if (strchr(hex, '#') != NULL)
c252e6 ····*strchr(hex, '#') = 0;
1ba3ed ··if (strchr(hex, '*') != NULL)
7760d1 ····*strchr(hex, '*') = 0;
e7a6e5 ··if (strchr(hex, '\'') != NULL)
7c2462 ····*strchr(hex, '\'') = 0;
abaf5a
5a1f4a ··for (i = 0; i < strlen(hex); i++) {
6a8e69 ····if (hex[i] >= '0' && unhex(hex[i]) < 0)
fed278 ······EXIT_ERR("Bad hex digit encountered.\n");

09df1c ··}
4baf5a
4f1f4a ··for (i = 0; i < strlen(hex); i++) {
c1f5b0 ····if (hex[i] < '0')
2f5f6a ······continue;
26643e ····if (hex[i] >= '0' && hex[i+1] >= '0') {
567935 ······bin[j++] = unhex(hex[i])*16+unhex(hex[i+1]);
dbc028 ······i++; ···// skip one

195f6a ······continue;
8b6fe7 ····}
3fe16f ····if (hex[i] >= '0') {
a78539 ······bin[j++] = unhex(hex[i]);
ea6fe7 ····}
efdf1c ··}
68c1d2 ··return (j);
5defe6 }
--3c7b 0014804ceb88004000b Page 4 of misc.c
e0af5a
1aaf5a
027b71 void printHexString(char *tag, unsigned char *data, int len) {
aa17e0 ··int i;
20af5a
469650 ··printf("%s", tag);
526c12 ··for (i = 0; i < len; i++)
21cd57 ····printf("%02X", data[i]);
bafee8 ··printf("\n");
b6efe6 }
48af5a
--77c4 001029468fd8004000c Page 1 of misc.h
e0af5a
32c502 void GetUserInfo(unsigned char plaintextVector[32],·
6657e7 ········unsigned char plaintextXorMask[8],·
e5910f ········unsigned char ciphertext0[8], unsigned char ciphertext[8],
4c446e ········unsigned char *plaintextByteMask, int *useCBC, int *extraXor,
25e00d ········int *quickStart, unsigned char startKey[7], long *numClocks);
560986 void increment32(unsigned char *v);
edb70b void decrement32(unsigned char *v);

4cf314 void desDecrypt(unsigned char m[8], unsigned char c[8], unsigned char k[7]);
fea5c5 void printHexString(char *tag, unsigned char *data, int len);
f9560a int hex2bin(char *hex, unsigned char *bin);
02af5a
--91c4 001d95d620a8004000d Page 1 of random.scr
1b9f56 00
4e9ec4 0000000000000000 ···' XOR MASK
c4327c 0000000000000000 ···' Ciphertext 0
892ba4 0000000000000000 ···' Ciphertext 1
918c19 00 ·················' Plaintext byte mask
05ed5e 0 ··················' use CBC
37d84f 0 ··················' extra XOR
260627 0 ··················' random vector (0=seed with timer, 1=use input, >1=seed)
63a481 00000000000000 ·····' starting key
8bd03f 2000 ················' number of clocks
d9af5a
--0289 000317f111e8004000e Page 1 of ref.c
56feb2 #include <stdio.h>
a1bea3 #include <stdlib.h>
a9c737 #include <memory.h>
79324c #include <string.h>

242bac #include "des.h"
3da50a #include "misc.h"
feaf5a
e7f8b5 #define CLOCKS_PER_DES 18
d8af5a
7a4525 int plaintextMatch(unsigned char plaintextVector[32], unsigned char m[8],
c46e85 ········unsigned char plaintextByteMask, int ciphertext, unsigned char key[7]);
8787d4 void checkKey(unsigned char key[7], unsigned char plaintextVector[32],·
4357e7 ········unsigned char plaintextXorMask[8],·
d31fa8 ········unsigned char ciphertext0[8], unsigned char ciphertext1[8],
7d5e1b ········unsigned char plaintextByteMask, int useCBC, int extraXor);
64af5a
57a2c4 void main(void) {
2b7ab8 ··unsigned char startKey[7], plaintextVector[32];
776f32 ··unsigned char plaintextXorMask[8];
01ed17 ··unsigned char ciphertext0[8];
52e93c ··unsigned char ciphertext1[8];
37b1b4 ··unsigned char plaintextByteMask;
36c9d8 ··int useCBC, extraXor, quickStart;
38e13a ··int i,j;
948520 ··long numClocks;
ac5ec8 ··unsigned char key[7];
d7af5a
8a50e3 ··GetUserInfo(plaintextVector, plaintextXorMask, ciphertext0, ciphertext1,·
8fd756 ··········&plaintextByteMask, &useCBC, &extraXor, &quickStart, startKey,
47ab3c ··········&numClocks);
2aaf5a

7fee44 ··for (i = 0; i < numClocks; i += CLOCKS_PER_DES) {
dea2d3 ····for (j = 0; j < 24; j++) {
22beb4 ······memcpy(key, startKey, 8);
08c578 ······key[0] += j;
ab91ec ······checkKey(key, plaintextVector, plaintextXorMask, ciphertext0,·
5320a7 ··········ciphertext1, plaintextByteMask, useCBC, extraXor);
3e6fe7 ····}
71ddad ····increment32(startKey+3);
96df1c ··}
aeefe6 }
8caf5a
00af5a
d287d4 void checkKey(unsigned char key[7], unsigned char plaintextVector[32],·
5c57e7 ········unsigned char plaintextXorMask[8],·
381fa8 ········unsigned char ciphertext0[8], unsigned char ciphertext1[8],
5f4479 ········unsigned char plaintextByteMask, int useCBC, int extraXor) {
3c0a0b ··unsigned char m[8];
1417e0 ··int i;
d4af5a
a4f09d ··desDecrypt(m, ciphertext0, key);
26835d ··printf("DES_decrypt(K="); for (i = 0; i < 7; i++) printf("%02X", key[i]);·
188cf0 ··printf(", C0="); for (i = 0; i < 8; i++) printf("%02X", ciphertext0[i]);
d849c7 ··printf(") -> "); for (i = 0; i < 8; i++) printf("%02X", m[i]); printf("\n");
24667c ··if (extraXor) {
0bd985 ····m[0] ^= m[4];
db406b ····m[1] ^= m[5];
f2e248 ····m[2] ^= m[6];
607ba6 ····m[3] ^= m[7];
7cdf1c ··}
bb1f76 ··for (i = 0; i < 8; i++)
45e88c ····m[i] ^= plaintextXorMask[i];
17af5a
c64534 ··if (plaintextMatch(plaintextVector, m, plaintextByteMask, 0, key)) {
b53498 ····desDecrypt(m, ciphertext1, key);
96553a ····printf("DES_decrypt(K="); for (i = 0; i < 7; i++) printf("%02X", key[i]);·
6dda88 ····printf(", C1="); for (i = 0; i < 8; i++) printf("%02X", ciphertext1[i]);
ead221 ····printf(") -> "); for (i = 0; i < 8; i++) printf("%02X", m[i]); printf("\n");
37952a ····if (extraXor) {
af2ad3 ······m[0] ^= m[4];
b6b33d ······m[1] ^= m[5];
31111e ······m[2] ^= m[6];
--62a0 0018ac4c1498004000e Page 2 of ref.c
4c88f0 ······m[3] ^= m[7];
5b6fe7 ····}
5b662a ····if (useCBC) {

429494 ······for (i = 0; i < 8; i++)
e1f3f9 ········m[i] ^= ciphertext0[i];
2b6fe7 ····}
10e5be ····if (plaintextMatch(plaintextVector, m, plaintextByteMask, 1, key)) {
5246ff ······printf("------- VALID MATCH--------\n");

059a8a ······fprintf(stderr, "Match found at key =");
c22526 ······for (i = 0; i < 7; i++)
3f44d0 ········fprintf(stderr, "%02X", key[i]);
0f5501 ······fprintf(stderr, "\n");
736fe7 ····}
6adf1c ··}
19efe6 }
81af5a
01af5a
004525 int plaintextMatch(unsigned char plaintextVector[32], unsigned char m[8],
8aa762 ·······unsigned char plaintextByteMask, int ciphertext, unsigned char key[7]) {
b817e0 ··int i;
f0af5a
068715 ··for (i = 0; i < 8; i++) {
c585ef ····if ((plaintextByteMask & (128>>i)) == 1)
388e03 ······continue; ··/* this byte is skipped */
b98ec8 ····if (plaintextVector[m[i]/8] & (128 >> (m[i]%8)))
d65f6a ······continue;
854210 ····return (0); ··········/* no match */
13df1c ··}
ceaf5a
957381 ··printf("Match of C%d with key ", ciphertext);
2daec4 ··for (i = 0; i < 7; i++)
80dac3 ····printf("%02X", key[i]);
b461e2 ··printf(" = ");
021f76 ··for (i = 0; i < 8; i++)

6511eb ····printf("%02X", m[i]);
b7fee8 ··printf("\n");
93af5a
35ec77 ··fprintf(stderr, "Match of C%d with key ", ciphertext);
bdaec4 ··for (i = 0; i < 7; i++)
5fedd0 ····fprintf(stderr, "%02X", key[i]);
d29064 ··fprintf(stderr, " = ");
371f76 ··for (i = 0; i < 8; i++)
d7651e ····fprintf(stderr, "%02X", m[i]);
96c77e ··fprintf(stderr, "\n");
10af5a
e0d4d1 ··return (1);
d9efe6 }
a1af5a
8aaf5a
--c93c 000f4b51cf08004000f Page 1 of sim.c
8d2d03 /*****************************************************************************
0833b1 ·* sim.c ····································································*
b33dcc ·* ·················Software Simulator for DES keysearch ASIC ···············*
6a29eb ·* ··········································································*
4509fc ·* ···Written 1998 by Cryptography Research (http://www.cryptography.com) ···*
5f8aaf ·* ······and Paul Kocher for the Electronic Frontier Foundation (EFF). ······*
38caeb ·* ······Placed in the public domain by Cryptography Research and EFF. ······*
f74992 ·* ·THIS IS UNSUPPORTED FREE SOFTWARE. USE AND DISTRIBUTE AT YOUR OWN RISK. ·*
c129eb ·* ··········································································*
66c755 ·* ·IMPORTANT: U.S. LAW MAY REGULATE THE USE AND/OR EXPORT OF THIS PROGRAM. ·*
8129eb ·* ··········································································*
fb489b ·*****************************************************************************
a729eb ·* ··········································································*
126eef ·* ··REVISION HISTORY: ······················································*
e329eb ·* ··········································································*
d97744 ·* ··Version 1.0: ·Initial version. ·········································*
4fbaf4 ·* ··Version 1.1: ·Initial release by Cryptography Research to EFF. ·········*
6ce429 ·* ················(Fixed byte/bit ordering notation to match VHDL.) ········*
3a29eb ·* ··········································································*
74d8c3 ·*****************************************************************************/
9daf5a
33feb2 #include <stdio.h>
b5bea3 #include <stdlib.h>
b8c737 #include <memory.h>
80324c #include <string.h>
e72bac #include "des.h"
2fbd71 #include "sim.h"
0aaf5a
b051c3 #define DEBUG
d6af5a
67a99d long getClockCounter(void);
54b42e int peekState(int addr);
1d7608 int RunChip(char *input, FILE *outfile, int useRaw);
2aaf5a
28708e static void EXIT_ERR(char *s) { fprintf(stderr, s); exit(1); }
62725e static void parseInput(char *input, int *reset, int *boardEn, int *ale,
7f8541 ········int *adrsel1, int *web, int *rdb, int *adrsel2, int *allactIn,
a060c4 ········int *addr, int *chipId, int *data);
bb79bd static int unhex(char c);
9bf453 static void RunClock(void);
f9d39e static void desDecrypt(unsigned char m[8], unsigned char c[8],
753286 ········unsigned char k[7]);
a2acca static void increment32(unsigned char *num);
91cc8b static void decrement32(unsigned char *num);

b8b1ae static void printKeyInfo(FILE *outDev, char *preamble, int searchUnit);
31af5a
34ec7c static unsigned char ALLACTIVE_IN = 1; ············/* not held between calls */
0dfec4 unsigned char ALLACTIVE_OUT ·····= 0;
40af5a
6ee4e3 unsigned char STATE[256];
41e3e4 unsigned char SELECTED_CHIP;
710ab3 ·········long CLOCK_COUNTER = 1;
cc8af3 ··········int DES_POSITION;
0c913b unsigned char WORKING_CTXT[24*8]; ·········/* last DES input ················*/
538181 unsigned char WORKING_PTXT[24*8]; ·········/* last DES out (for ptxt check) ·*/
c053df unsigned char RAW_DES_OUT[24*8]; ··········/* raw DES outputs ···············*/
daa765 int ··········WORKING_KDELTA[24]; ·········/* key delta (-1, 0, or +1) ······*/
533efd unsigned char WORKING_LAST_SELECTOR[24]; ··/* last ciphertext selector ······*/
4ce4be unsigned char WORKING_NEXT_SELECTOR[24]; ··/* next ciphertext selector ······*/
689e18 ··········int STARTUP_DELAY[24]; ··········/* startup delay ·················*/
24f67e unsigned char THIS_KEY[24*7]; ·············/* current DES key ···············*/
d35f18 unsigned char NEXT_KEY[24*7]; ·············/* next DES key ··················*/
1c11b6 ·········int ·PENDING_UPDATE_ADDR1 = -1, PENDING_UPDATE_DATA1 = -1;
cb8c2d ·········int ·PENDING_UPDATE_ADDR2 = -1, PENDING_UPDATE_DATA2 = -1;
3300ab ·········int ·PENDING_UPDATE_ADDR3 = -1, PENDING_UPDATE_DATA3 = -1;
17c6c2 unsigned char MATCH[24];
23af5a
11af5a
d1af5a
b1a885 static void resetChip(void) {
1aab8b ··memset(STATE, 0, sizeof(STATE)); ·································/* RESET */
f46530 ··SELECTED_CHIP = 0;
--ba12 0009cc27d6a8004000f Page 2 of sim.c
417126 ··DES_POSITION = 13;
9fa8d9 ··memset(WORKING_CTXT, 0, sizeof(WORKING_CTXT));
e2ae80 ··memset(WORKING_PTXT, 0, sizeof(WORKING_PTXT));
b5afb1 ··memset(RAW_DES_OUT, 0, sizeof(RAW_DES_OUT));
677ba0 ··memset(WORKING_KDELTA, 0, sizeof(WORKING_KDELTA));
c1e6c6 ··memset(WORKING_LAST_SELECTOR, 1, sizeof(WORKING_LAST_SELECTOR));
c48102 ··memset(WORKING_NEXT_SELECTOR, 1, sizeof(WORKING_NEXT_SELECTOR));
699bcb ··memset(STARTUP_DELAY, 0, sizeof(STARTUP_DELAY));
8f3fe2 ··memset(THIS_KEY, 0, sizeof(THIS_KEY));
849161 ··memset(NEXT_KEY, 0, sizeof(NEXT_KEY));
850ce5 ··PENDING_UPDATE_ADDR1 = -1;
c98635 ··PENDING_UPDATE_ADDR2 = -1;
28078a ··PENDING_UPDATE_ADDR3 = -1;
4f19ae ··memset(MATCH, 0, sizeof(MATCH));
49efe6 }
52af5a
04af5a
51a5b0 long getClockCounter(void) {
8eb11d ··return (CLOCK_COUNTER);
7eefe6 }
85af5a
98af5a
5f22bd int peekState(int addr) {
c69e96 ··return (STATE[addr]);
78efe6 }
c0af5a
7caf5a
66664b int RunChip(char *input, FILE *outfile, int useRaw) {
686c17 ··int reset,boardEn,ale,adrsel1,web,rdb,adrsel2,allactiveIn,addr,chipId,data;
ef86d5 ··int dataOut;
41e13a ··int i,j;
6eaf5a
75261a ··parseInput(input, &reset, &boardEn, &ale, &adrsel1, &web, &rdb, &adrsel2,

29b7df ··········&allactiveIn, &addr, &chipId, &data);
4e7493 ··ALLACTIVE_IN = (unsigned char)allactiveIn;
30af5a
183f21 ··dataOut = data; ················································/* default */
9d58d6 ··if (reset == 0) { ···············································/* reset? */
54b64f ····resetChip();
a281d3 ····RunClock();
129dff ··} else if (boardEn == 0) { ·····························/* board disabled? */
5581d3 ····RunClock();
3cbc66 ··} else if (ale == 1) { ·······························/* select chip/board */
0081d3 ····RunClock();
fa6af8 ····if (adrsel1 == 1)
bb80de ······SELECTED_CHIP = (unsigned char)addr;
90842c ····else
21294b ······{ /* board select done off-chip */ }
7302c3 ··} else if (chipId != SELECTED_CHIP) { ·················/* chipId not ours? */
8781d3 ····RunClock();
66d581 ··} else if (web == 0) { ·······························/* writing register? */
df81d3 ····RunClock();
ebb10b ····if (addr >= REG_SEARCH_KEY(0)) {
7b50c6 ······PENDING_UPDATE_ADDR2 = addr; ···································/* key */
3bda60 ······PENDING_UPDATE_DATA2 = data;
b64b08 ······if (((addr & 7) == 7) && (data & 1) && ((STATE[addr] & 1) == 0)) {
2b22fc ········if (CLOCK_COUNTER < 750)
33d675 ··········STARTUP_DELAY[(addr - 0x47) / 8] = 21; ·················/* adjust? */
f805d7 ········else {
c78561 ··········STARTUP_DELAY[(addr - 0x47) / 8] = 2*CLOCKS_PER_DES - DES_POSITION;
44c934 ··········if (DES_POSITION >= 15)
b2a6a3 ············STARTUP_DELAY[(addr - 0x47) / 8] += CLOCKS_PER_DES;
59e0f6 #if 0 ···························/* uncomment for debugging message on halts */
143237 ··········fprintf(stderr,"Startup with DES_POSITION=%d in unit %d, delay=%d\n",
545d8e ················DES_POSITION, (addr-0x47)/8, STARTUP_DELAY[(addr - 0x47) / 8]);
977454 #endif
be7fb0 ········}
7342cc ······}
056a79 ····} else {
a6b05a ······PENDING_UPDATE_ADDR2 = addr; ·····························/* other reg */
f5da60 ······PENDING_UPDATE_DATA2 = data;
9c6fe7 ····}
--eb12 000b9c238be8004000f Page 3 of sim.c
5be4b8 ··} else if (rdb == 0) { ·································/* read a register */
e34a99 ····dataOut = STATE[addr];
2e81d3 ····RunClock();
1249d8 ··} else {
8981d3 ····RunClock();
fadf1c ··}
eaaf5a
671c5c ··if (CLOCK_COUNTER >= 2) {
123cea ····if (useRaw) {
e1a3f4 ······fprintf(outfile, "%02X %d\n", dataOut, ALLACTIVE_OUT);
9c6a79 ····} else {
fe2044 ······fprintf(outfile, " (Addr: %02X) ·(Exp: 00) (Get: %02X) at Cycle:%ld\n",
e9f86f ··············addr, dataOut, CLOCK_COUNTER);

01457c ······for (i = 0; i < 24; i++) {
31e69a ········for (j = 6; j >= 0; j--)


ff590a ··········fprintf(outfile, "%02X", STATE[REG_SEARCH_KEY(i)+j]);
91798f ········fprintf(outfile, " ");
35555b ········if (CLOCK_COUNTER < 22)
78dc93 ··········fprintf(outfile, "0000000000000000");
fe00e6 ········else if (CLOCK_COUNTER <= 37)
3054ea ··········fprintf(outfile, "094CCE83D677160F");
8305d7 ········else {
a8dcd6 ··········for (j = 7; j >= 0; j--)

5cad27 ············fprintf(outfile, "%02X", RAW_DES_OUT[8*i+j]);
387fb0 ········}
9978b2 #if 0 ·····················/* uncomment to print information about the MATCH */
c42b60 ········{
451685 ··········static int latch[24]={0,0,0,0,0,0,0,0,0,0,0,0,0,0,
4515b3 ································0,0,0,0,0,0,0,0,0,0};
c2132c ··········if (DES_POSITION==10) latch[i] = MATCH[i];
a6ab83 ··········fprintf(outfile, " %d", latch[i]);
ad7fb0 ········}
b67454 #endif
2ca770 #if 0 ·················/* uncomment to print information about NEXT_SELECTOR */
a32b60 ········{
c51fc2 ··········static int latch[24]={1,1,1,1,1,1,1,1,1,1,1,1,1,1,
2c5bf8 ································1,1,1,1,1,1,1,1,1,1};
298e7e ··········if (DES_POSITION==15) latch[i] = WORKING_NEXT_SELECTOR[i];
1a4ad8 ··········fprintf(outfile, "%d", latch[i]);
8f7fb0 ········}
017454 #endif
3767a5 ········fprintf(outfile, " : Unit%d\n", i);
6a42cc ······}
22b96e ······fprintf(outfile, "\n");
e86fe7 ····}
23df1c ··}
a3755d ··CLOCK_COUNTER++;
f75593 ··return (dataOut);
0cefe6 }
d7af5a
e7af5a
d4725e static void parseInput(char *input, int *reset, int *boardEn, int *ale,
ce8541 ········int *adrsel1, int *web, int *rdb, int *adrsel2, int *allactIn,

746a3d ········int *addr, int *chipId, int *data) {
a117e0 ··int i;
47af5a
c69eb9 ··if (strlen(input) < 17 || input[8]!=' ' || input[11]!=' ' || input[14]!=' ')
ccda15 ·····EXIT_ERR("Bad input.\n");

558715 ··for (i = 0; i < 8; i++) {
c1c3f7 ····if (input[i] != '0' && input[i] != '1')
93b045 ······EXIT_ERR("Bad input (first 8 digits must be binary.)\n");
c1df1c ··}
38b959 ··if (unhex(input[9]) < 0 || unhex(input[10]) < 0 ||
70bbf9 ········unhex(input[12]) < 0 || unhex(input[13]) < 0 ||
6401b9 ········unhex(input[15]) < 0 || unhex(input[16]) < 0) {
78422f ····EXIT_ERR("Bad input (addr, chipId, data must be hex)");
fddf1c ··}
d4af5a
958f00 ··*reset ···= input[0]-'0';
4a25a2 ··*boardEn ·= input[1]-'0';
7c660a ··*ale ·····= input[2]-'0';
b92dfa ··*adrsel1 ·= input[3]-'0';
--9ad7 00064eb0a748004000f Page 4 of sim.c
48111b ··*web ·····= input[4]-'0';
71de77 ··*rdb ·····= input[5]-'0';
060751 ··*adrsel2 ·= input[6]-'0';
c1d2b3 ··*allactIn = input[7]-'0';
449a0b ··*addr ····= 16*unhex(input[9]) + unhex(input[10]);
3842c3 ··*chipId ··= 16*unhex(input[12]) + unhex(input[13]);
2d9e2a ··*data ····= 16*unhex(input[15]) + unhex(input[16]);
0fefe6 }
c0af5a
0caf5a
62d93f /* Decodes a hex char or returns -1 if bad. */
8d8462 static int unhex(char c) {
6b53c4 ··if (c >= '0' && c <= '9')
f203d6 ····return (c - '0');
2f8db1 ··if (c >= 'a' && c <= 'f')
3f0ada ····return (c - 'a' + 10);
a149e3 ··if (c >= 'A' && c <= 'F')
86a66f ····return (c - 'A' + 10);
0f12d4 ··return (-1);
95efe6 }
f4af5a
7baf5a
1baf5a
4f38e5 /*
dea850 ·* ··Run the system for one clock cycle and update the state.
89495d ·*/
4442ee void RunClock(void) {
5c6275 ··int i,j,k,b;
dd470b ··unsigned char key[7], m[8], c[8];
77af5a
9c9101 ··for (i = 0; i < 24; i++) {
84543c ····if (STARTUP_DELAY[i] > 0) {
604f54 ······STARTUP_DELAY[i]--;
3a4600 ······if (STARTUP_DELAY[i] == 0)
340ea6 ········STARTUP_DELAY[i] = -1; ··············/* prevent stop if 1st C0=match */
8e6fe7 ····}
76df1c ··}
14af5a
586df4 ··/* DES CLOCK 5: Plaintext vector result from last DES is ready. */
e94ae1 ··if (DES_POSITION == 5) {
8e23cf ····for (i = 0; i < 24; i++) { ··············/* i = search engine ···········*/
c6d1c1 ······k = 0; ································/* k = result of byte lookups ··*/
bd642b ······for (j = 0; j < 8; j++) { ·············/* j = byte idx ················*/
a0178a ········b = WORKING_PTXT[8*i+j]; ············/* b = byte value ··············*/
c9fb5d ········if (STATE[b/8] & (1 << (b%8))) ······/* check plaintext vector ······*/
ce346c ··········k = (k >> 1) | 128; ···············/* ··match = load 1 in k msb ···*/
1e359e ········else ································/* ·····························*/
f40eb7 ··········k = (k >> 1) | 0; ·················/* ··no match = load 0 into k ··*/
a042cc ······}
f83f33 ······k |= STATE[REG_PTXT_BYTE_MASK]; ·······/* set bits where bytemask=1 ···*/
b11a90 ······MATCH[i] = (unsigned char)((k == 255) ? 1 : 0);

f1af5a
dd663d ······if ((STATE[REG_SEARCH_STATUS(i)] & 1) == 0 || STARTUP_DELAY[i] > 0) {
b9b83a ········/* If search not active, key delta = 0 and do C0 next */
e3472c ········WORKING_KDELTA[i] = 0;
dfe9d7 ········WORKING_NEXT_SELECTOR[i] = 1;
0f373c ······} else if (k != 0xFF || (STATE[REG_SEARCH_STATUS(i)] & 2) ||
4b09fe ··············STARTUP_DELAY[i] < 0) {
28e722 ········/* If no match or CURRENTLY doing C1 or first DES result,
3da57c ·········* ····key delta = 1 and do C0 next.
a05af3 ·········*/

701df0 ········WORKING_KDELTA[i] = 1;
8bb30b ········WORKING_NEXT_SELECTOR[i] = 0;
cad29b ········if (k==0xFF)
de670b ··········printKeyInfo(stderr, "ALERT: Skip match while doing C1 ", i);
ee2e47 ········if (k == 0xFF && STARTUP_DELAY[i] < 0)
9b3369 ··········printKeyInfo(stderr, "ALERT: ···(C1 above is startup phantom.)", i);
2869ea ······} else if (WORKING_LAST_SELECTOR[i] == 0) {
d2b8e7 ········/* If doing C0 and got a match from C0, back up and do C1 */
ced05d ········WORKING_KDELTA[i] = -1;
4ae9d7 ········WORKING_NEXT_SELECTOR[i] = 1;

648f35 ········printKeyInfo(stderr, "ALERT: Match C0; will backup for C1 ", i);
--0c27 000479329b38004000f Page 5 of sim.c
6ccfc7 ······} else {
8a2ce9 ········/* If doing C0 and got a match from C1, halt */
b22aaa ········STATE[REG_SEARCH_STATUS(i)] &= (255-1);
62472c ········WORKING_KDELTA[i] = 0;
1be9d7 ········WORKING_NEXT_SELECTOR[i] = 1;
dd98d4 ········printKeyInfo(stderr, "ALERT: Matched C1; halting ", i);
ea42cc ······}
8eb3e1 ······if (STARTUP_DELAY[i] < 0)
5ece10 ········STARTUP_DELAY[i]++;
326fe7 ····}
cedf1c ··}
aeaf5a
c03071 ··if (DES_POSITION == 15) {
fa2135 ····for (i = 0; i < 24; i++) {
ccc53f ······memcpy(THIS_KEY+i*7, NEXT_KEY+i*7, 7);
ef7e92 ······memcpy(NEXT_KEY+i*7, STATE+REG_SEARCH_KEY(i), 7);
136fe7 ····}
8adf1c ··}
d0af5a
018fcd ··/* END OF DES CYCLE: Extract results */
77ea42 ··if (DES_POSITION == CLOCKS_PER_DES-1) {
6b2135 ····for (i = 0; i < 24; i++) {
7aaf5a
d9c284 ······/* Do the DES decryption */
8502ce ······for (j = 0; j < 7; j++)
9e22c0 ········key[j] = THIS_KEY[i*7+(6-j)];
77b37c ······for (j = 0; j < 8; j++)

a3ccfb ········c[j] = WORKING_CTXT[8*i+7-j];
0d481f ······desDecrypt(m, c, key);
481503 ······for (j = 0; j < 8; j++) {
7d3bd1 ········WORKING_PTXT[8*i+7-j] = m[j];
a60d03 ········RAW_DES_OUT[8*i+7-j] = m[j];
b042cc ······}
20af5a
84b9ef ······if (STATE[REG_SEARCHINFO] & 2) { ····················/* if extraXOR ···*/
025020 ········WORKING_PTXT[8*i+4] ^= WORKING_PTXT[8*i+0]; ·······/* ···L = L xor R */
fe6d21 ········WORKING_PTXT[8*i+5] ^= WORKING_PTXT[8*i+1]; ·······/* ·····" ········*/
ceada9 ········WORKING_PTXT[8*i+6] ^= WORKING_PTXT[8*i+2]; ·······/* ·····" ········*/
6615de ········WORKING_PTXT[8*i+7] ^= WORKING_PTXT[8*i+3]; ·······/* ·····" ········*/
1542cc ······}
ea89a7 ······if ((STATE[REG_SEARCH_STATUS(i)] & 2) == 0) { ········/* if c0, ·······*/
cd6b8a ········WORKING_PTXT[8*i+0] ^= STATE[REG_PTXT_XOR_MASK+0]; ·/* do ptxtXorMsk */
265511 ········WORKING_PTXT[8*i+1] ^= STATE[REG_PTXT_XOR_MASK+1]; ·/* ·····" ·······*/
6800b2 ········WORKING_PTXT[8*i+2] ^= STATE[REG_PTXT_XOR_MASK+2]; ·/* ·····" ·······*/
78cbdc ········WORKING_PTXT[8*i+3] ^= STATE[REG_PTXT_XOR_MASK+3]; ·/* ·····" ·······*/
3aabf4 ········WORKING_PTXT[8*i+4] ^= STATE[REG_PTXT_XOR_MASK+4]; ·/* ·····" ·······*/
36609a ········WORKING_PTXT[8*i+5] ^= STATE[REG_PTXT_XOR_MASK+5]; ·/* ·····" ·······*/
353539 ········WORKING_PTXT[8*i+6] ^= STATE[REG_PTXT_XOR_MASK+6]; ·/* ·····" ·······*/
5f3c97 ········WORKING_PTXT[8*i+7] ^= STATE[REG_PTXT_XOR_MASK+7];
4d5d4c ······} else { ·············································/* if c1 ········*/
9afc9c ········if (STATE[REG_SEARCHINFO] & 1) { ···················/* if useCBC ····*/
b784fd ··········WORKING_PTXT[8*i+0] ^= STATE[REG_CIPHERTEXT0+0]; ·/* xor with c0 ··*/
8c4de8 ··········WORKING_PTXT[8*i+1] ^= STATE[REG_CIPHERTEXT0+1]; ·/* ·····" ·······*/
3605d1 ··········WORKING_PTXT[8*i+2] ^= STATE[REG_CIPHERTEXT0+2]; ·/* ·····" ·······*/
dcc5c9 ··········WORKING_PTXT[8*i+3] ^= STATE[REG_CIPHERTEXT0+3]; ·/* ·····" ·······*/
8995a3 ··········WORKING_PTXT[8*i+4] ^= STATE[REG_CIPHERTEXT0+4]; ·/* ·····" ·······*/
6c55bb ··········WORKING_PTXT[8*i+5] ^= STATE[REG_CIPHERTEXT0+5]; ·/* ·····" ·······*/
811d82 ··········WORKING_PTXT[8*i+6] ^= STATE[REG_CIPHERTEXT0+6]; ·/* ·····" ·······*/
33dd9a ··········WORKING_PTXT[8*i+7] ^= STATE[REG_CIPHERTEXT0+7]; ·/* ·····" ·······*/
637fb0 ········}
e942cc ······}
1aaf5a
e370b8 ······/* Update ciphertext selector (state & last) */
569701 ······WORKING_LAST_SELECTOR[i] = (STATE[0x47+8*i] & 2) ? 1 : 0;
5ad73b ······STATE[0x47+8*i] &= 0xFD; ·····················/* select ciphertext 0 ··*/
25abd6 ······if (WORKING_NEXT_SELECTOR[i]) ················/* ... unless we want c1 */
8e98a9 ········STATE[0x47+8*i] |= 2; ······················/* ... then select c1 ···*/
206fe7 ····}
1ddf1c ··}
a1af5a
80cda8 ··/* LAST DES CLOCK: Load in the updated key */
473b35 ··if (DES_POSITION == 14) {
--4c9a 0007dd476568004000f Page 6 of sim.c
e02135 ····for (i = 0; i < 24; i++) {
b45d9d ······if (WORKING_KDELTA[i] == 1) { ···················/* ··if key delta = 1 */
635981 ········increment32(STATE+REG_SEARCH_KEY(i));
4242cc ······}
a6f8e9 ······if (WORKING_KDELTA[i] == -1) { ·················/* ··if key delta = -1 */
e80a03 ········decrement32(STATE+REG_SEARCH_KEY(i));

0a42cc ······}
406fe7 ····}
dedf1c ··}
d1af5a
a964de ··/* DES CLOCK 0: Latch in new working keys and working ciphertexts */
5c6cb5 ··if (DES_POSITION == 0) {
f70d66 ····for (i = 0; i < 24; i++) { ·························/* i = search engine */
34dbbd ······/* pick between ctxt 0 and ctxt 1? */
d38aeb ······if ((STATE[REG_SEARCH_STATUS(i)] & 2) == 0 && STARTUP_DELAY[i] == 0)
b7afe2 ········memcpy(WORKING_CTXT+8*i, STATE+REG_CIPHERTEXT0, 8); ······/* copy c0 */
f13dfa ······else
4ff6ee ········memcpy(WORKING_CTXT+8*i, STATE+REG_CIPHERTEXT1, 8); ······/* copy c1 */
1a6fe7 ····}
eedf1c ··}
0faf5a
c82d95 ··/* Update ChipAllActive, board all active */
57519a ··j = 1;
a763d6 ··for (i = 0; i < 24; i++)
bd9656 ····j &= STATE[0x47+i*8];
455974 ··j = (j & 1) ? 1 : 0;
fefe54 ··STATE[REG_SEARCHINFO] &= (255-4); ·······/* set ChipAllActive ·············*/

e632f7 ··STATE[REG_SEARCHINFO] |= (4*j); ·········/* ···" ··························*/
95fdfb ··if ((STATE[REG_SEARCHINFO] & 16) == 0) ··/* If board all active enable = 0 */
3b3c9d ····ALLACTIVE_OUT = ALLACTIVE_IN;
051bd0 ··else
b33a4d ····ALLACTIVE_OUT = ALLACTIVE_IN & j;

045e2a ··STATE[REG_SEARCHINFO] &= (255-8); ·················/* set board all active */
5c7b9a ··STATE[REG_SEARCHINFO] |= (8*ALLACTIVE_OUT); ·······/* set board all active */
71af5a
b34cd8 ··/* Do any pending updates and update DES cycle position */
52cfb8 ··if (PENDING_UPDATE_ADDR1 >= 0)
f286c6 ····STATE[PENDING_UPDATE_ADDR1] = PENDING_UPDATE_DATA1;
023f74 ··PENDING_UPDATE_ADDR1 = PENDING_UPDATE_ADDR2;
c854a4 ··PENDING_UPDATE_DATA1 = PENDING_UPDATE_DATA2;
9e3a49 ··PENDING_UPDATE_ADDR2 = PENDING_UPDATE_ADDR3;
6a5199 ··PENDING_UPDATE_DATA2 = PENDING_UPDATE_DATA3;
9f078a ··PENDING_UPDATE_ADDR3 = -1;
6cc7f8 ··DES_POSITION = (DES_POSITION + 1) % CLOCKS_PER_DES;
8eefe6 }
c9af5a
a4af5a
34d39e static void desDecrypt(unsigned char m[8], unsigned char c[8],
cc0b79 ········unsigned char k[7]) {
77f65b ··bool key[56], message[64];
5717e0 ··int i;
16af5a
2dd545 #ifdef DEBUG
e060e0 ··printf("DES_DECRYPT(k="); for (i=0; i<7;i++) printf("%02X",k[i]);
75e4d8 ··printf(", c="); for (i=0; i<8;i++) printf("%02X",c[i]);
ad7454 #endif
20af5a
9f815b ··for (i = 0; i < 56; i++)
6e9345 ····key[55-i] = ((k[i/8] << (i & 7)) & 128) ? 1 : 0;
8f5c33 ··for (i = 0; i < 64; i++)
0de5ed ····message[63-i] = ((c[i/8] << (i & 7)) & 128) ? 1 : 0;
c3c59d ··DecryptDES(key, message, message, 0);
be1f76 ··for (i = 0; i < 8; i++)
4d452e ····m[i] = 0;
c35c33 ··for (i = 0; i < 64; i++)
9d7511 ····if (message[63-i])
42fe29 ······m[i/8] |= 128 >> (i%8);
45af5a
72d545 #ifdef DEBUG
ea47c0 ··printf(")=");
3d17d3 ··for (i=0; i<8;i++)
7dcdbd ····printf("%02X",m[i]);
--a790 001522c46c68004000f Page 7 of sim.c
3bfeb7 ··printf(", clk=%ld\n",CLOCK_COUNTER);
b87454 #endif
1eaf5a
87efe6 }
97af5a
26af5a
e3af5a
2eaf5a
dba6b0 static void printKeyInfo(FILE *outDev, char *preamble, int searchUnit) {
eac359 ··fprintf(outDev, preamble);
b97d84 ··fprintf(outDev, "(K=%02X%02X%02X%02X%02X%02X%02X, clk=%ld, searchUnit=%d)\n",
d06867 ················STATE[0x40+8*searchUnit+6],STATE[0x40+8*searchUnit+5],

9fa184 ················STATE[0x40+8*searchUnit+4],STATE[0x40+8*searchUnit+3],
3b1668 ················STATE[0x40+8*searchUnit+2],STATE[0x40+8*searchUnit+1],
10ceed ················STATE[0x40+8*searchUnit+0], CLOCK_COUNTER, searchUnit);
b3af5a
607332 ··printf(preamble);
b7f622 ··printf("(K=%02X%02X%02X%02X%02X%02X%02X, clk=%ld, searchUnit=%d)\n",
e66867 ················STATE[0x40+8*searchUnit+6],STATE[0x40+8*searchUnit+5],
f6a184 ················STATE[0x40+8*searchUnit+4],STATE[0x40+8*searchUnit+3],
ba1668 ················STATE[0x40+8*searchUnit+2],STATE[0x40+8*searchUnit+1],
abceed ················STATE[0x40+8*searchUnit+0], CLOCK_COUNTER, searchUnit);
adaf5a
58efe6 }
c0af5a
e6af5a
67838f static void increment32(unsigned char *num) {
68708d ··if ((++(num[0])) == 0)
f2c3c0 ····if ((++(num[1])) == 0)
0949d0 ······if ((++(num[2])) == 0)
7754ed ········++(num[3]);
e7efe6 }
b8af5a
f5af5a
1fd062 static void decrement32(unsigned char *num) {
ded7cb ··if (((num[0])--) == 0)
8334ba ····if (((num[1])--) == 0)
654eee ······if (((num[2])--) == 0)
251e5b ········(num[3])--;
a0efe6 }
44af5a
52af5a

--6ca6 001193e4aa680040010 Page 1 of sim.h

8d2d03 /*****************************************************************************
516967 ·* sim.h ····································································*
8c93bc ·* ···························Header file for sim.c ·························*
d629eb ·* ··········································································*
dd09fc ·* ···Written 1998 by Cryptography Research (http://www.cryptography.com) ···*
708aaf ·* ······and Paul Kocher for the Electronic Frontier Foundation (EFF). ······*
20caeb ·* ······Placed in the public domain by Cryptography Research and EFF. ······*
784992 ·* ·THIS IS UNSUPPORTED FREE SOFTWARE. USE AND DISTRIBUTE AT YOUR OWN RISK. ·*
c329eb ·* ··········································································*
afc755 ·* ·IMPORTANT: U.S. LAW MAY REGULATE THE USE AND/OR EXPORT OF THIS PROGRAM. ·*
0629eb ·* ··········································································*
eb489b ·*****************************************************************************
4629eb ·* ··········································································*

726eef ·* ··REVISION HISTORY: ······················································*
6829eb ·* ··········································································*
8628d9 ·* ··Version 1.0: ·Initial release by Cryptography Research to EFF. ·········*
6129eb ·* ··········································································*
75d8c3 ·*****************************************************************************/
a1af5a
2aaf5a
1ac928 #define REG_PTXT_VECTOR ·····(0x00)
f821cd #define REG_PTXT_XOR_MASK ···(0x20)
75b3c1 #define REG_CIPHERTEXT0 ·····(0x28)
5a1752 #define REG_CIPHERTEXT1 ·····(0x30)
74db81 #define REG_PTXT_BYTE_MASK ··(0x38)
39107b #define REG_SEARCHINFO ······(0x3F)
b2b9aa #define REG_SEARCH_KEY(x) ···(0x40 + 8*(x))
86701d #define REG_SEARCH_STATUS(x) (0x47+8*(x))
1d60ef #define CLOCKS_PER_DES ······16
ebaf5a
bd7608 int RunChip(char *input, FILE *outfile, int useRaw);
7da99d long getClockCounter(void);
5273d4 int peekState(int reg); ···················/* runs chip & returns DATA value */
19af5a


--dfa5 000a2c967de80040011 Page 1 of testvec.c
8d2d03 /*****************************************************************************
a1132a ·* testvec.c ································································*
8bd58f ·* ············DES ASIC Simlator, Test Vector Generation Program ············*
9429eb ·* ··········································································*
5409fc ·* ···Written 1998 by Cryptography Research (http://www.cryptography.com) ···*
058aaf ·* ······and Paul Kocher for the Electronic Frontier Foundation (EFF). ······*
71caeb ·* ······Placed in the public domain by Cryptography Research and EFF. ······*
5e4992 ·* ·THIS IS UNSUPPORTED FREE SOFTWARE. USE AND DISTRIBUTE AT YOUR OWN RISK. ·*
9529eb ·* ··········································································*
15c755 ·* ·IMPORTANT: U.S. LAW MAY REGULATE THE USE AND/OR EXPORT OF THIS PROGRAM. ·*
5a29eb ·* ··········································································*
65489b ·*****************************************************************************
b629eb ·* ··········································································*
d815cb ·* ··IMPLEMENTATION NOTES: ··················································*
8829eb ·* ··········································································*
53a8b8 ·* ··This program automatically determines the configuration of a search ····*
521db9 ·* ··array. ·Additional diagnostic code should be added to detect common ····*
9a87f9 ·* ··chip failures (once these are known). ··································*
e029eb ·* ··········································································*
76489b ·*****************************************************************************
6329eb ·* ··········································································*
566eef ·* ··REVISION HISTORY: ······················································*
ba29eb ·* ··········································································*
a028d9 ·* ··Version 1.0: ·Initial release by Cryptography Research to EFF. ·········*
5b29eb ·* ··········································································*
aad8c3 ·*****************************************************************************/
a8af5a
d6feb2 #include <stdio.h>
63bea3 #include <stdlib.h>
9fc737 #include <memory.h>
93324c #include <string.h>
1a0a8b #include <time.h>
11bd71 #include "sim.h"
9aaf5a
31decb int USE_RAW_IO = 0;
b0a91d FILE *FILE_TOCHIP, *FILE_FROMCHIP; ·······/* TOCHIP can be input *or* output */
4fca8d int ·CREATING_VECTOR; ·····················/* reading vs writing TOCHIP file */
3e98dc unsigned char HARDWIRED_CHIP_ID ·= 0x3A;
e0af5a
7f583a int ALLACTIVE_IN = 1; ······························/* gets toggled randomly */
2ce03a int BOARD_EN_IN ·= 1; ······················/* input value for run_set/check */
13b9cd int ADRSEL1_IN ··= 1;
36af5a
60af5a
e17897 void GetUserInfo(unsigned char plaintextVector[32],
302461 ········unsigned char plaintextXorMask[8],
90910f ········unsigned char ciphertext0[8], unsigned char ciphertext[8],
b5446e ········unsigned char *plaintextByteMask, int *useCBC, int *extraXor,
7bc016 ········int *randomVector, unsigned char startKey[7], long *totalClocks);
cd1884 void LoadState(unsigned char plaintextVector[32],
fb2461 ········unsigned char plaintextXorMask[8],
481fa8 ········unsigned char ciphertext0[8], unsigned char ciphertext1[8],
d0a024 ········unsigned char plaintextByteMask, int useCBC, int extraXor,
c80ccc ········unsigned char startKey[7]);
511a5e void RunSimulator_SetRegister(int addr, int data);
8b5fd9 unsigned char RunSimulator_CheckRegister(int addr);
80703f void RunSimulator_DummyIO(void);
94708e static void EXIT_ERR(char *s) { fprintf(stderr, s); exit(1); }
ebaf5a
d6f314 void desDecrypt(unsigned char m[8], unsigned char c[8], unsigned char k[7]);
6eabe4 void increment32(unsigned char *num);
42cba5 void decrement32(unsigned char *num);
2d560a int hex2bin(char *hex, unsigned char *bin);
77a5c5 void printHexString(char *tag, unsigned char *data, int len);
33f163 void OpenFiles(char *toChipFilename, char *fromChipFilename, int useRaw);
b2bd55 void printKeyInfo(FILE *outDev, char *preamble, int searchUnit);
65a99d long getClockCounter(void);
8b3363 void proceedNormal(long totalClocks);
c7a6a5 void proceedRandom(void);
caaf5a
11af5a
a238e5 /*

--8051 0009399d7c480040011 Page 2 of testvec.c
4f775e ·*
ac775e ·*
0ff92c ·* ··THESE FUNCTIONS CREATE AND MANAGE THE TEST VECTORS.
5b775e ·*
9a775e ·*
81775e ·*
2d495d ·*/
b6af5a
6daf5a
b179bf void main(int argc, char **argv) {
5a7ab8 ··unsigned char startKey[7], plaintextVector[32];
736f32 ··unsigned char plaintextXorMask[8];
aded17 ··unsigned char ciphertext0[8];
fce93c ··unsigned char ciphertext1[8];
81b1b4 ··unsigned char plaintextByteMask;
5bcc34 ··int useCBC, extraXor, randomVector;
b9f974 ··long totalClocks;
ac92d0 ··char buffer[512];
1aaf5a
0796ed ··if (argc != 3 && argc != 4) {
c0795d ····fprintf(stderr,"Command line: TO_CHIP.OUT FROM_CHIP.OUT [RAW]\n");
5626d6 ····fprintf(stderr," ·TO_CHIP.OUT ·····File for data going to chip\n");
8134ad ····fprintf(stderr," ········(If this file exists, it will be simulated.\n");

114f39 ····fprintf(stderr," ········Otherwise, a new file will be created.)\n");
67803c ····fprintf(stderr," ·FROM_CHIP.OUT ···File for chip's output\n");
703172 ····fprintf(stderr," ·RAW ·············Gives unix CRLFs & no header.\n");
8b646c ····exit(1);

37df1c ··}
16af5a
026000 ··/*
802ba4 ···* Open files and set CREATING_VECTOR to:
3369bb ···* ····0=reading TOCHIP file,
cfdf37 ···* ····1=create TOCHIP from user input,
7fbbb4 ···* ····2=create random vector
def9a6 ···*/
18bbf9 ··OpenFiles(argv[1], argv[2], (argc == 4) ? 1 : 0);
a3af5a
97ee0b ··if (CREATING_VECTOR == 0) {
ac50a4 ····fprintf(stderr, "Using input vector from file.\n");
e6eb83 ····while (1) {

66b843 ······if (fgets(buffer, 500, FILE_TOCHIP) == NULL)
a52d5f ········break;
01563f ······if (strlen(buffer) < 10)
1a2d5f ········break;
97f0ee ······RunChip(buffer, FILE_FROMCHIP, USE_RAW_IO);
b86fe7 ····}
4a49d8 ··} else {
89ae2b ····GetUserInfo(plaintextVector, plaintextXorMask, ciphertext0, ciphertext1,

08828a ············&plaintextByteMask, &useCBC, &extraXor, &randomVector, startKey,
f497e4 ············&totalClocks);
ac3a38 ····if (randomVector == 0) {
f635be ······fprintf(stderr, "Seed=random (time-based)\n");
b694d0 ······srand((unsigned) time(NULL));
95c26c ······HARDWIRED_CHIP_ID = (unsigned char)(rand() & 255);
717a5a ····} else if (randomVector == 1) {
a1a0a2 ······fprintf(stderr, "Using user params.\n");
e16a79 ····} else {

5ac986 ······fprintf(stderr, "Seed=%d\n", randomVector);
cfccdd ······srand(randomVector);
91c26c ······HARDWIRED_CHIP_ID = (unsigned char)(rand() & 255);
456fe7 ····}
33af5a
21f70d ····/* Reset chip and set the chip ID */
a00659 ····sprintf(buffer, "01011111 00 %02X 00\n", HARDWIRED_CHIP_ID);
5c55a3 ····RunChip(buffer, FILE_FROMCHIP, USE_RAW_IO); fputs(buffer, FILE_TOCHIP);
3d55a3 ····RunChip(buffer, FILE_FROMCHIP, USE_RAW_IO); fputs(buffer, FILE_TOCHIP);
cd55a3 ····RunChip(buffer, FILE_FROMCHIP, USE_RAW_IO); fputs(buffer, FILE_TOCHIP);
7655a3 ····RunChip(buffer, FILE_FROMCHIP, USE_RAW_IO); fputs(buffer, FILE_TOCHIP);
62a71b ····sprintf(buffer, "11011111 %02X %02X 00\n", HARDWIRED_CHIP_ID,
9ff16b ············HARDWIRED_CHIP_ID);
1eb67c ····RunChip(buffer, FILE_FROMCHIP, USE_RAW_IO);
93084e ····fputs(buffer, FILE_TOCHIP);

--02cc 00029e33ba580040011 Page 3 of testvec.c
ba5b1f ····buffer[2] = '1';
34b67c ····RunChip(buffer, FILE_FROMCHIP, USE_RAW_IO);
7a084e ····fputs(buffer, FILE_TOCHIP);
ce47a4 ····buffer[2] = '0';
e3b67c ····RunChip(buffer, FILE_FROMCHIP, USE_RAW_IO);
80084e ····fputs(buffer, FILE_TOCHIP);
b0af5a
fd317c ····if (randomVector == 1) {
971b90 ······LoadState(plaintextVector, plaintextXorMask, ciphertext0, ciphertext1,
4b91ef ··············plaintextByteMask, useCBC, extraXor, startKey);
6d3cb4 ······proceedNormal(totalClocks);
916a79 ····} else {
92057c ······proceedRandom();
7f6fe7 ····}
4bdf1c ··}
a7af5a
a46b7f ··/* Clean up a bit (doesn't really matter -- this is test code :-) */
fd9918 ··fclose(FILE_FROMCHIP);
a9650b ··fclose(FILE_TOCHIP);
0defe6 }
b7af5a
b4af5a
b3bbdb void proceedNormal(long totalClocks) {
3be2b8 ··long numClocks = getClockCounter();
341614 ··unsigned char goodKey[8];
0b929f ··int i,j,r;
80af5a
27a415 ··while (++numClocks < totalClocks) {
a40a43 ····r = RunSimulator_CheckRegister(REG_SEARCHINFO);
021f4e ····if (r & 4) {
e8b4b9 ······fprintf(stderr, "------- Idle --------\n");
318957 ······RunSimulator_DummyIO();
325f6a ······continue;
9b6fe7 ····}
442135 ····for (i = 0; i < 24; i++) {
9ab4ea ······/* If we're going to see a stall, give some settling time */
d7bdac ······if ((peekState(REG_SEARCH_STATUS(i)) & 1) == 0) { ·········/* stalled? */
3ca6ab ········RunSimulator_DummyIO(); ·························/* wait before read */
b9fe40 ········RunSimulator_DummyIO();
d4fe40 ········RunSimulator_DummyIO();
ff42cc ······}
c7d86b ······r = RunSimulator_CheckRegister(REG_SEARCH_STATUS(i));

7e760d ······if ((r & 1) == 0) { ·······································/* stalled? */
598b76 ········goodKey[6] = RunSimulator_CheckRegister(REG_SEARCH_KEY(i)+0);
4c6426 ········goodKey[5] = RunSimulator_CheckRegister(REG_SEARCH_KEY(i)+1);
c910b2 ········goodKey[4] = RunSimulator_CheckRegister(REG_SEARCH_KEY(i)+2);
2cb297 ········goodKey[3] = RunSimulator_CheckRegister(REG_SEARCH_KEY(i)+3);
91b4ef ········goodKey[2] = RunSimulator_CheckRegister(REG_SEARCH_KEY(i)+4);
1b5bbf ········goodKey[1] = RunSimulator_CheckRegister(REG_SEARCH_KEY(i)+5);
1a2f2b ········goodKey[0] = RunSimulator_CheckRegister(REG_SEARCH_KEY(i)+6);
fbaf5a
abf636 ········fprintf(stderr, "ALERT: Full match in unit %d; extracted k = ", i);
b15425 ········printf("ALERT: Full match in unit %d; extracted k = ", i);
64677e ········for (j = 0; j < 7; j++) {
652f98 ··········fprintf(stderr, "%02X", goodKey[j]);
1d7e87 ··········printf("%02X", goodKey[j]);
9e7fb0 ········}
0de535 ········fprintf(stderr, "\n");
e10493 ········printf("\n");
db75ed ········RunSimulator_DummyIO(); ····························/* Settling time */
6afe40 ········RunSimulator_DummyIO();
e336ec ········RunSimulator_SetRegister(REG_SEARCH_STATUS(i), 1); ·······/* restart */
4242cc ······}
dd6fe7 ····}
06df1c ··}
f1efe6 }
adaf5a
0baf5a
d31874 void proceedRandom(void) {
840515 ··unsigned char readout[256];
74a4ed ··unsigned char goodKey[7];
29e13a ··int i,j;
--a796 0002667342680040011 Page 4 of testvec.c
4afe41 ··unsigned char plaintextVector[32];
14d1fd ··char buffer[256];
23af5a
6c852a ··/* chip has already been set and the chip ID has been loaded */
73af5a
42c34a ··/* Create plaintext vector with 181 bits set */
ae477e ··memset(plaintextVector, 0, sizeof(plaintextVector));
70a328 ··i = 0;
0d13b4 ··while (i < 181) {
926486 ····j = rand() & 255;
21e479 ····if ((plaintextVector[j/8] & (1 << (j % 8))) == 0) {
54e749 ······plaintextVector[j/8] |= (1 << (j % 8));
52079a ······i++;
2f6fe7 ····}
dcdf1c ··}
84af5a
68fd4c ··/* Load state */
03339a ··for (i = 0; i < 32; i++)
579479 ····RunSimulator_SetRegister(REG_PTXT_VECTOR + i, plaintextVector[i]);
c61f76 ··for (i = 0; i < 8; i++)
d332be ····RunSimulator_SetRegister(REG_PTXT_XOR_MASK + i, rand() & 255);
671f76 ··for (i = 0; i < 8; i++)
cce0be ····RunSimulator_SetRegister(REG_CIPHERTEXT0 + i, rand() & 255);
631f76 ··for (i = 0; i < 8; i++)
7849e3 ····RunSimulator_SetRegister(REG_CIPHERTEXT1 + i, rand() & 255);
e1c5ca ··RunSimulator_SetRegister(REG_PTXT_BYTE_MASK, 1 << (rand() & 7));
c99aac ··i = (rand() % 3) + (rand() & 16); ·/* 0/1/2 for CBC & extraXor. 16=activOn */
0bf2a6 ····fprintf(stderr, "Using mode %d with ActiveOn=%d.\n", (i&3), i/16);
02b125 ····RunSimulator_SetRegister(REG_SEARCHINFO, i);


040688 ··for (i = 0; i < 24; i++) { ·····························/* for each engine */
891cca ····for (j = 0; j < 7; j++) ·························/* set random start key */
0b98b9 ······RunSimulator_SetRegister(REG_SEARCH_KEY(i)+j, rand() & 255);
ecfdd9 ····RunSimulator_SetRegister(REG_SEARCH_STATUS(i), 1);
98df1c ··}
daaf5a
8ea083 ··/* Read out all registers (real and not) except for ptxt vector */
df1999 ··for (i = 255; i >= 32; i--)
6b1901 ····readout[i] = RunSimulator_CheckRegister(i);
d59097 ··/* Change the key in any stopped units */
219101 ··for (i = 0; i < 24; i++) {
385173 ····if ((readout[REG_SEARCH_STATUS(i)] & 1) == 0) ···············/* stalled? */
3d6ca2 ······RunSimulator_SetRegister(REG_SEARCH_KEY(i),
65571a ··············readout[REG_SEARCH_KEY(i)] ^ 0x08); ················/* fix key */
51df1c ··}
b31dc8 ··/* Read out ptxt vector */
632004 ··for (i = 31; i >= 0; i--)
151901 ····readout[i] = RunSimulator_CheckRegister(i);
8c809e ··/* scan stopped units */
539101 ··for (i = 0; i < 24; i++) {
f12abb ····if ((readout[REG_SEARCH_STATUS(i)] & 1) == 0) { ·············/* stalled? */
97e66a ······goodKey[6] = RunSimulator_CheckRegister(REG_SEARCH_KEY(i)+0);
b1093a ······goodKey[5] = RunSimulator_CheckRegister(REG_SEARCH_KEY(i)+1);
217dae ······goodKey[4] = RunSimulator_CheckRegister(REG_SEARCH_KEY(i)+2);
d2df8b ······goodKey[3] = RunSimulator_CheckRegister(REG_SEARCH_KEY(i)+3);
cfd9f3 ······goodKey[2] = RunSimulator_CheckRegister(REG_SEARCH_KEY(i)+4);
1536a3 ······goodKey[1] = RunSimulator_CheckRegister(REG_SEARCH_KEY(i)+5);
3b4237 ······goodKey[0] = RunSimulator_CheckRegister(REG_SEARCH_KEY(i)+6);
1d0767 ······if (rand() % 8)
8436ec ········RunSimulator_SetRegister(REG_SEARCH_STATUS(i), 1); ·······/* restart */
53ca8d ······fprintf(stderr, "****** Full match in unit %d; extracted k = ", i);
02b8df ······for (j = 0; j < 7; j++) {
8a3d3b ········fprintf(stderr, "%02X", goodKey[j]);
b905c9 ········printf("%02X", goodKey[j]);
8642cc ······}
c65501 ······fprintf(stderr, "\n");
de6fe7 ····}
cbdf1c ··}
fbaf5a
ab917c ··/* pick a different chip, read/write some registers, and reset chip id */
3fef47 ··do { i = rand() & 255; } while (i == HARDWIRED_CHIP_ID);
308260 ··sprintf(buffer, "11011111 %02X %02X 00\n", i, HARDWIRED_CHIP_ID);
2621ff ··RunChip(buffer, FILE_FROMCHIP, USE_RAW_IO);

--5543 0004f88973480040011 Page 5 of testvec.c
477f59 ··fputs(buffer, FILE_TOCHIP);
146c5f ··buffer[2] = '1';
8921ff ··RunChip(buffer, FILE_FROMCHIP, USE_RAW_IO);
527f59 ··fputs(buffer, FILE_TOCHIP);
0f70e4 ··buffer[2] = '0';
a421ff ··RunChip(buffer, FILE_FROMCHIP, USE_RAW_IO);
b07f59 ··fputs(buffer, FILE_TOCHIP);

6b1f76 ··for (i = 0; i < 8; i++)
feca76 ····RunSimulator_SetRegister(rand() & 255, rand() & 255);
161f76 ··for (i = 0; i < 8; i++)
46b8cf ····RunSimulator_CheckRegister(rand() & 255);
6615e8 ··sprintf(buffer, "11011111 %02X %02X 00\n", HARDWIRED_CHIP_ID,
04867c ··········HARDWIRED_CHIP_ID);
5b21ff ··RunChip(buffer, FILE_FROMCHIP, USE_RAW_IO);
a57f59 ··fputs(buffer, FILE_TOCHIP);
836c5f ··buffer[2] = '1';
ed21ff ··RunChip(buffer, FILE_FROMCHIP, USE_RAW_IO);
1f7f59 ··fputs(buffer, FILE_TOCHIP);
cc70e4 ··buffer[2] = '0';
7b21ff ··RunChip(buffer, FILE_FROMCHIP, USE_RAW_IO);
1c7f59 ··fputs(buffer, FILE_TOCHIP);
9daf5a
3074d9 ··/* Test board enable and ADRSEL1 */
234255 ··BOARD_EN_IN = 0;
71cb06 ··ADRSEL1_IN = 0;
732414 ··for (i = 0; i < 4; i++)
42ca76 ····RunSimulator_SetRegister(rand() & 255, rand() & 255);
0e2414 ··for (i = 0; i < 4; i++)
0fb8cf ····RunSimulator_CheckRegister(rand() & 255);
594255 ··BOARD_EN_IN = 0;
9891da ··ADRSEL1_IN = 1;
241f76 ··for (i = 0; i < 8; i++)
71ca76 ····RunSimulator_SetRegister(rand() & 255, rand() & 255);
7b1f76 ··for (i = 0; i < 8; i++)
54b8cf ····RunSimulator_CheckRegister(rand() & 255);
2c1889 ··BOARD_EN_IN = 1;
fbcb06 ··ADRSEL1_IN = 0;
da1f76 ··for (i = 0; i < 8; i++)
aeca76 ····RunSimulator_SetRegister(rand() & 255, rand() & 255);
e41f76 ··for (i = 0; i < 8; i++)
b8b8cf ····RunSimulator_CheckRegister(rand() & 255);
f81889 ··BOARD_EN_IN = 1;
1491da ··ADRSEL1_IN = 1;
4caf5a
8ce7e0 ··/* Make a final pass reading all the registers */
99741b ··for (i = 255; i >= 0; i--)
771901 ····readout[i] = RunSimulator_CheckRegister(i);
7e809e ··/* scan stopped units */
199101 ··for (i = 0; i < 24; i++) {

b02abb ····if ((readout[REG_SEARCH_STATUS(i)] & 1) == 0) { ·············/* stalled? */
76e66a ······goodKey[6] = RunSimulator_CheckRegister(REG_SEARCH_KEY(i)+0);
c2093a ······goodKey[5] = RunSimulator_CheckRegister(REG_SEARCH_KEY(i)+1);
287dae ······goodKey[4] = RunSimulator_CheckRegister(REG_SEARCH_KEY(i)+2);
96df8b ······goodKey[3] = RunSimulator_CheckRegister(REG_SEARCH_KEY(i)+3);
43d9f3 ······goodKey[2] = RunSimulator_CheckRegister(REG_SEARCH_KEY(i)+4);
eb36a3 ······goodKey[1] = RunSimulator_CheckRegister(REG_SEARCH_KEY(i)+5);
c34237 ······goodKey[0] = RunSimulator_CheckRegister(REG_SEARCH_KEY(i)+6);
9bc697 ······RunSimulator_SetRegister(REG_SEARCH_STATUS(i), 1); ·········/* restart */
5aca8d ······fprintf(stderr, "****** Full match in unit %d; extracted k = ", i);
34b8df ······for (j = 0; j < 7; j++) {
883d3b ········fprintf(stderr, "%02X", goodKey[j]);
fc05c9 ········printf("%02X", goodKey[j]);
f742cc ······}
d85501 ······fprintf(stderr, "\n");
a56fe7 ····}
04df1c ··}
81efe6 }
b2af5a
8baf5a
dbaf5a
be7897 void GetUserInfo(unsigned char plaintextVector[32],
4f2461 ········unsigned char plaintextXorMask[8],

--53eb 000af645a6880040011 Page 6 of testvec.c
261fa8 ········unsigned char ciphertext0[8], unsigned char ciphertext1[8],
49446e ········unsigned char *plaintextByteMask, int *useCBC, int *extraXor,
8b9f02 ········int *randomVector, unsigned char startKey[7], long *totalClocks) {
ef0e71 ··char buffer[1024];
98c6d6 ··unsigned char tmp[512];
fe17e0 ··int i;
b5af5a
77659f ··printf("Enter plaintextVector values: ");
10766e ··gets(buffer);
13b72a ··i = hex2bin(buffer, tmp);
4953dd ··if (i <= 0 || i >= 256)
b0112c ····EXIT_ERR("Must have at least 1 plaintextVector entry and at most 255.\n");
481bcb ··memset(plaintextVector, 0, 32);
83f545 ··while (i--)
24f3bf ····plaintextVector[tmp[i]/8] |= (1 << (tmp[i] % 8));
9aaf5a
51ee8b ··printf(" ···Enter plaintext xor mask: ");

14766e ··gets(buffer);
2db72a ··i = hex2bin(buffer, tmp);
aa1856 ··if (i != 8)
fba670 ····EXIT_ERR("Must have 8 plaintext xor mask bytes.");
91b657 ··memcpy(plaintextXorMask, tmp, 8);
b9af5a
b83a0c ··printf(" ·········Enter ciphertext 0: ");
b6766e ··gets(buffer);
67b72a ··i = hex2bin(buffer, tmp);

a21856 ··if (i != 8)
c0cf62 ····EXIT_ERR("Must have 8 bytes in ciphertext 0.");
2998f3 ··memcpy(ciphertext0, tmp, 8);
16af5a
e9a5d9 ··printf(" ·········Enter ciphertext 1: ");
eb766e ··gets(buffer);
26b72a ··i = hex2bin(buffer, tmp);
c41856 ··if (i != 8)
21cb49 ····EXIT_ERR("Must have 8 bytes in ciphertext 1.");
1e1da6 ··memcpy(ciphertext1, tmp, 8);
51af5a
fed221 ··printf(" ··Enter plaintext byte mask: ");
9f766e ··gets(buffer);
b5b72a ··i = hex2bin(buffer, tmp);
968448 ··if (i != 1)
69f706 ····EXIT_ERR("Plaintext byte mask is 1 byte long.");
1dc2b5 ··*plaintextByteMask = tmp[0];
93af5a
a51b21 ··printf(" ······Enter useCBC (0 or 1): ");
72766e ··gets(buffer);
1bb72a ··i = hex2bin(buffer, tmp);
a415b9 ··if (i != 1 || tmp[0] > 1)
1519c6 ····EXIT_ERR("Must enter 0 or 1 for useCBC.");
cde2c1 ··*useCBC = tmp[0];
7caf5a
bdf965 ··printf(" ····Enter extraXor (0 or 1): ");
28766e ··gets(buffer);
3ab72a ··i = hex2bin(buffer, tmp);
e915b9 ··if (i != 1 || tmp[0] > 1)
7a6c75 ····EXIT_ERR("Must enter 0 or 1 for extraXor.");
8e2353 ··*extraXor = tmp[0];
92af5a
2e04d5 ··printf(" Enter randomVector (0=randomize, 1=user input, >1=seed): ");
35766e ··gets(buffer);
3eb72a ··i = hex2bin(buffer, tmp);
a68448 ··if (i != 1)
6fbb66 ····EXIT_ERR("Must enter 0=randomize 1=use input, >1=value for prng seed).");
9db530 ··*randomVector = tmp[0];
d4af5a
40c8bf ··printf(" ·········Enter starting key: ");
a2766e ··gets(buffer);
07e684 ··if (hex2bin(buffer, tmp) != 7)
c3a5e4 ····EXIT_ERR("Must enter 7 hex bytes as the key.\n");
f30ed3 ··memcpy(startKey, tmp, 7);
6caf5a
aff4f6 ··printf(" ·····Enter number of clocks: ");

--5aef 000e933bd7d80040011 Page 7 of testvec.c
74766e ··gets(buffer);
775582 ··sscanf(buffer, "%ld", totalClocks);

0f9780 ··if (*totalClocks < 1 || *totalClocks > 1000000000L)

e4b093 ····EXIT_ERR("Must have between 1 and 1 billion clocks.\n");

33af5a
62186d ··printHexString("\n ·PtxtVector = ", plaintextVector, 32);
5aa738 ··printHexString(" PtxtXorMask = ", plaintextXorMask, 8);
44ffc6 ··printHexString("Ciphertext 0 = ", ciphertext0, 8);
913b57 ··printHexString("Ciphertext 1 = ", ciphertext1, 8);

83dd31 ··printHexString("PtxtByteMask = ", plaintextByteMask, 1);
37e15b ··printf( ·······" ·····useCBC = %d\n", *useCBC);
012f30 ··printf( ·······" ···extraXor = %d\n", *extraXor);
bbe751 ··printf( ·······"randomVector = %x\n", *randomVector);
b81535 ··printHexString("Starting key = ", startKey, 7);
bed787 ··printf( ·······"Total clocks = %ld\n\n", *totalClocks);
e2efe6 }
e0af5a
daaf5a
711884 void LoadState(unsigned char plaintextVector[32],
182461 ········unsigned char plaintextXorMask[8],
541fa8 ········unsigned char ciphertext0[8], unsigned char ciphertext1[8],
e3a024 ········unsigned char plaintextByteMask, int useCBC, int extraXor,
40e619 ········unsigned char startKey[7]) {
c917e0 ··int i;
0baf5a
af339a ··for (i = 0; i < 32; i++)
a19479 ····RunSimulator_SetRegister(REG_PTXT_VECTOR + i, plaintextVector[i]);
371f76 ··for (i = 0; i < 8; i++)
c0a554 ····RunSimulator_SetRegister(REG_PTXT_XOR_MASK + i, plaintextXorMask[7-i]);
131f76 ··for (i = 0; i < 8; i++)
6d2b06 ····RunSimulator_SetRegister(REG_CIPHERTEXT0 + i, ciphertext0[7-i]);
031f76 ··for (i = 0; i < 8; i++)
02abab ····RunSimulator_SetRegister(REG_CIPHERTEXT1 + i, ciphertext1[7-i]);
05ea2e ··RunSimulator_SetRegister(REG_PTXT_BYTE_MASK, plaintextByteMask);
5b35f1 ··RunSimulator_SetRegister(REG_SEARCHINFO, (useCBC?1:0) |

7e824a ··········(extraXor?2:0) | 16); ······················/* enable board active */
9d0688 ··for (i = 0; i < 24; i++) { ·····························/* for each engine */
c40441 ····RunSimulator_SetRegister(REG_SEARCH_KEY(i)+0, startKey[6]);
da0982 ····RunSimulator_SetRegister(REG_SEARCH_KEY(i)+1, startKey[5]);
d432d7 ····RunSimulator_SetRegister(REG_SEARCH_KEY(i)+2, startKey[4]);
751204 ····RunSimulator_SetRegister(REG_SEARCH_KEY(i)+3, startKey[3]);
a3696d ····RunSimulator_SetRegister(REG_SEARCH_KEY(i)+4, startKey[2]);
b864ae ····RunSimulator_SetRegister(REG_SEARCH_KEY(i)+5, startKey[1]);
4d13e5 ····RunSimulator_SetRegister(REG_SEARCH_KEY(i)+6, (startKey[0] + i) & 255);
e7fdd9 ····RunSimulator_SetRegister(REG_SEARCH_STATUS(i), 1);
8adf1c ··}
54efe6 }
15af5a
5daf5a
adaf5a
8b5194 void RunSimulator_SetRegister(int addr, int data) {
abd1fd ··char buffer[256];
f8af5a
3c9186 ··/* RESET,BOARD_EN,ALE,ADRSEL1,WRB,RDB,ADRSEL2,ALLACT_IN,ADDR,CHIP_ID,DATA */
d25f05 ··sprintf(buffer, "1%d0%d110%d %02x %02x %02x\n", BOARD_EN_IN, ADRSEL1_IN,
afa8dd ··········ALLACTIVE_IN, addr, HARDWIRED_CHIP_ID, data);
7721ff ··RunChip(buffer, FILE_FROMCHIP, USE_RAW_IO);
047f59 ··fputs(buffer, FILE_TOCHIP);
d1af5a
6ecb50 ··sprintf(buffer, "1%d0%d010%d %02x %02x %02x\n", BOARD_EN_IN, ADRSEL1_IN,
93a8dd ··········ALLACTIVE_IN, addr, HARDWIRED_CHIP_ID, data);
c621ff ··RunChip(buffer, FILE_FROMCHIP, USE_RAW_IO);
3d7f59 ··fputs(buffer, FILE_TOCHIP);
44af5a
bb5f05 ··sprintf(buffer, "1%d0%d110%d %02x %02x %02x\n", BOARD_EN_IN, ADRSEL1_IN,
cda8dd ··········ALLACTIVE_IN, addr, HARDWIRED_CHIP_ID, data);
8821ff ··RunChip(buffer, FILE_FROMCHIP, USE_RAW_IO);
b57f59 ··fputs(buffer, FILE_TOCHIP);
6faf5a
073db7 ··if ((rand() & 31) == 0)
1debd9 ····ALLACTIVE_IN = 1-ALLACTIVE_IN;
e9efe6 }



--0bd8 000b2bfff2680040011 Page 8 of testvec.c
e0af5a
1aaf5a
562371 void RunSimulator_DummyIO(void) {
5fd1fd ··char buffer[256];
dd5ffc ··int i,b,addr,chip;
f0af5a
bbb5a8 ··if ((rand() & 3) > 0) {
6df7c5 ····addr = rand() & 255;
7c7b22 ····chip = (rand() & 7) ? HARDWIRED_CHIP_ID : (rand() & 255);
b40f2c ····b = (rand() & 7) ? 1 : 0;
116e4c ····/*RESET,BOARD_EN,ALE,ADRSEL1,WRB,RDB,ADRSEL2,ALLACT_IN,ADDR,CHIP_ID,DATA*/
58d814 ····sprintf(buffer, "1%d01110%d %02x %02x 00\n", b, ALLACTIVE_IN, addr, chip);
34b67c ····RunChip(buffer, FILE_FROMCHIP, USE_RAW_IO);
e1084e ····fputs(buffer, FILE_TOCHIP);
b7b67c ····RunChip(buffer, FILE_FROMCHIP, USE_RAW_IO);
4a084e ····fputs(buffer, FILE_TOCHIP);
dea7f6 ····sprintf(buffer, "1%d01100%d %02x %02x 00\n", b, ALLACTIVE_IN, addr, chip);
26b67c ····RunChip(buffer, FILE_FROMCHIP, USE_RAW_IO);
7d084e ····fputs(buffer, FILE_TOCHIP);
e2b67c ····RunChip(buffer, FILE_FROMCHIP, USE_RAW_IO);
b2084e ····fputs(buffer, FILE_TOCHIP);
0cdda8 ····sprintf(buffer, "1%d01111%d %02x %02x 00\n", b, ALLACTIVE_IN, addr, chip);
d9b67c ····RunChip(buffer, FILE_FROMCHIP, USE_RAW_IO);
a3084e ····fputs(buffer, FILE_TOCHIP);
dbb67c ····RunChip(buffer, FILE_FROMCHIP, USE_RAW_IO);
d1084e ····fputs(buffer, FILE_TOCHIP);
64b67c ····RunChip(buffer, FILE_FROMCHIP, USE_RAW_IO);
53084e ····fputs(buffer, FILE_TOCHIP);
1149d8 ··} else {
1ad2a6 ····sprintf(buffer, "1101111%d FF %02x FF\n", ALLACTIVE_IN, HARDWIRED_CHIP_ID);
6cd137 ····for (i = rand() & 7; i > 0; i--) {
73f0ee ······RunChip(buffer, FILE_FROMCHIP, USE_RAW_IO);
3ad7ef ······fputs(buffer, FILE_TOCHIP);
0e6fe7 ····}
98df1c ··}
f8efe6 }
50af5a
55af5a
4caf5a
aba166 unsigned char RunSimulator_CheckRegister(int addr) {
9299d0 ··unsigned char rval;
d7d1fd ··char buffer[256];
72af5a
229186 ··/* RESET,BOARD_EN,ALE,ADRSEL1,WRB,RDB,ADRSEL2,ALLACT_IN,ADDR,CHIP_ID,DATA */
fbac2d ··sprintf(buffer, "1%d0%d110%d %02x %02x 00\n", BOARD_EN_IN, ADRSEL1_IN,
e0278e ··········ALLACTIVE_IN, addr, HARDWIRED_CHIP_ID /*no data*/);

4121ff ··RunChip(buffer, FILE_FROMCHIP, USE_RAW_IO);
317f59 ··fputs(buffer, FILE_TOCHIP);
09af5a
0faa92 ··sprintf(buffer, "1%d0%d100%d %02x %02x 00\n", BOARD_EN_IN, ADRSEL1_IN,
35278e ··········ALLACTIVE_IN, addr, HARDWIRED_CHIP_ID /*no data*/);
cf49fa ··rval=(unsigned char)RunChip(buffer, FILE_FROMCHIP, USE_RAW_IO);
dc7f59 ··fputs(buffer, FILE_TOCHIP);
deaf5a
a2234b ··sprintf(buffer, "1%d0%d111%d %02x %02x 00\n", BOARD_EN_IN, ADRSEL1_IN,
ac278e ··········ALLACTIVE_IN, addr, HARDWIRED_CHIP_ID /*no data*/);
0321ff ··RunChip(buffer, FILE_FROMCHIP, USE_RAW_IO);
b77f59 ··fputs(buffer, FILE_TOCHIP);
cbaf5a
2076c9 ··return (rval);
c6efe6 }
36af5a
adaf5a
4bc2bf int unhex(char c) {
af53c4 ··if (c >= '0' && c <= '9')
f203d6 ····return (c - '0');
618db1 ··if (c >= 'a' && c <= 'f')
180ada ····return (c - 'a' + 10);
e449e3 ··if (c >= 'A' && c <= 'F')
d7a66f ····return (c - 'A' + 10);
9912d4 ··return (-1);
b2efe6 }

--3d19 000c2e4763180040011 Page 9 of testvec.c
e0af5a
1aaf5a
4c4579 int hex2bin(char *hex, unsigned char *bin) {

dcc22f ··int i = 0;
a66a41 ··int j = 0;
66af5a
688ef6 ··/* Trim string if comments present */
078b28 ··if (strchr(hex, '#') != NULL)
a052e6 ····*strchr(hex, '#') = 0;
d8a3ed ··if (strchr(hex, '*') != NULL)
2560d1 ····*strchr(hex, '*') = 0;
d8a6e5 ··if (strchr(hex, '\'') != NULL)
762462 ····*strchr(hex, '\'') = 0;
6caf5a
9447de ··for (i = 0; i < (int)strlen(hex); i++) {
d28e69 ····if (hex[i] >= '0' && unhex(hex[i]) < 0)
d3d278 ······EXIT_ERR("Bad hex digit encountered.\n");
81df1c ··}
27af5a
1b47de ··for (i = 0; i < (int)strlen(hex); i++) {
34f5b0 ····if (hex[i] < '0')
875f6a ······continue;
51643e ····if (hex[i] >= '0' && hex[i+1] >= '0') {
57f2a4 ······bin[j++] = (unsigned char)(unhex(hex[i])*16+unhex(hex[i+1]));
0039d3 ······i++; ······················································/* skip one */
245f6a ······continue;
ab6fe7 ····}
a3e16f ····if (hex[i] >= '0') {
339eae ······bin[j++] = (unsigned char)(unhex(hex[i]));
3d6fe7 ····}
5fdf1c ··}
ebc1d2 ··return (j);
8cefe6 }
c2af5a
f2af5a
847b71 void printHexString(char *tag, unsigned char *data, int len) {
3d17e0 ··int i;
dbaf5a
449650 ··printf("%s", tag);
fc6c12 ··for (i = 0; i < len; i++)
20cd57 ····printf("%02X", data[i]);
8afee8 ··printf("\n");
eaefe6 }
8aaf5a
24af5a
18bb19 void OpenFiles(char *toChipFilename, char *fromChipFilename, int useRaw) {
e27959 ··FILE_TOCHIP = fopen(toChipFilename, useRaw ? "rb" : "r");
c0f096 ··if (FILE_TOCHIP != NULL) {
9d1260 ····CREATING_VECTOR = 0;
6449d8 ··} else {
335eff ····FILE_TOCHIP = fopen(toChipFilename, useRaw ? "wb" : "w");
c5d318 ····if (FILE_TOCHIP == NULL) {
445716 ······fprintf(stderr, "Can't open \"s\" for toChip file\n", toChipFilename);
e4c1d2 ······exit(1);
d56fe7 ····}
0c48bc ····CREATING_VECTOR = 1;
69df1c ··}
ebaf5a
7da670 ··FILE_FROMCHIP = fopen(fromChipFilename, useRaw ? "wb" : "w");
8d870f ··if (FILE_FROMCHIP == NULL) {

9842e1 ····fprintf(stderr, "Can't open \"s\" for fromChip file\n", fromChipFilename);
25646c ····exit(1);
fddf1c ··}
7baf5a
d359dc ··USE_RAW_IO = useRaw;
7dc563 #if 0 ··············/* Activate this to add column descriptors in the output */
4e14fa ··if (!useRaw){
e382e3 ····fprintf(FILE_TOCHIP, "RESET\n");
4d7cf5 ····fprintf(FILE_TOCHIP, "|BOARD_EN\n");
d6f02c ····fprintf(FILE_TOCHIP, "||ALE\n");
da1111 ····fprintf(FILE_TOCHIP, "|||ADRSEL1\n");
c287b0 ····fprintf(FILE_TOCHIP, "||||WRB\n");

--c2ba 001857ff29a80040011 Page 10 of testvec.c
93a32c ····fprintf(FILE_TOCHIP, "|||||RDB\n");
71b3bd ····fprintf(FILE_TOCHIP, "||||||ADRSEL2\n");
d017df ····fprintf(FILE_TOCHIP, "|||||||ALLACTIVE_IN\n");
6bed08 ····fprintf(FILE_TOCHIP, "|||||||| ADDR\n");
173c97 ····fprintf(FILE_TOCHIP, "|||||||| /\\ CHIP_ID\n");
f1102a ····fprintf(FILE_TOCHIP, "|||||||| || /\\ DATA\n");
4aea2f ····fprintf(FILE_TOCHIP, "|||||||| || || /\\ ALLACTIVE_OUT\n");
e1e4e9 ····fprintf(FILE_FROMCHIP, "DATA\n");
541499 ····fprintf(FILE_FROMCHIP, "/\\ ALLACTIVE_OUT\n");
4dc3ec ····fprintf(FILE_FROMCHIP, "|| | /-- IsActive [0..23] --\\\n");
a6df1c ··}
187454 #endif
217c65 ··fprintf(FILE_FROMCHIP, "KEY ···········DES_OUT ·········MATCH & SELECT1:\n");
1aefe6 }
85af5a

