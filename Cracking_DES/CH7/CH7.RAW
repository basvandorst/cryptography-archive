--9a44 0014b4364e180040001 Page 1 of MANIFEST

7bf681 1 MANIFEST
63b635 2 README
476ecc 3 blaze.scr
8a49aa 4 cbc1.scr
581046 5 cbc2.scr
1feade 6 cbc3.scr
868e30 7 des.c
f3db2a 8 des.h
bbf31a 9 ecb.scr
039f0d 10 mini.scr
02ce39 11 misc.c
60fc96 12 misc.h
b51b5d 13 random.scr
cfb60c 14 ref.c
aa84bd 15 sim.c
0beac5 16 sim.h
4b2104 17 testvec.c

--926a 0011c402f8d80040002 Page 1 of README
e0af5a
3f1c37 testvec.c (compile with sim.c and des.c): иGenerates and runs test
9a0001 vectors. иThis program will both run existing input vectors, orи
08239f generate new ones (either randomly or from a script). иWhen compiled
c43481 under DOS, it can either produce Unix (LF only) or DOS (CR/LF)
37d2c3 output files (select with the RAW parameter)
a1af5a
26a7b8 To run the ecb.scr sample script and:
473eef ииStore test vectors which go to the chip in TOCHIP.EXT
5b66ea ииStore test vectors received from the chip in FROMCHIP.EXT,

0763b5 ииProduce Unix-style output (LF only)
9e1741 ииStore debugging output in debug.out.
10af5a
f46e57 ииииrm *.EXT
a1f54e ииииtestvec TOCHIP.EXT FROMCHIP.EXT RAW < ecb.scr > debug.out
c7ed9a иииииииииииииииииииииииииииииииии
1ff74b If TOCHIP.EXE already exists when the program is run, it will
917018 read it (instead of expecting a script from stdin).
60af5a
b4a916 Use the script random.scr to produce a random test vector, e.g.:
b7bdcd ииииtestvec TOCHIP.EXT FROMCHIP.EXT RAW < random.scr > debug.out
52af5a
d7ecf1 ----------------------------------------------------------------------------
b3af5a
4eaf5a
b0a8a2 ref.c (compile with des.c misc.c): иRuns test scripts (.scr files)
0b7e68 and prints any keys that match. иThis is basically a stripped-down
abd9fb test vector generator for debugging purposes. и(It doesn't make any
9749f1 attempt to match timings.)
2caf5a
1caf5a

--a854 001ab3b125780040003 Page 1 of blaze.scr
95a107 00 01 02 03 04 05 06 07 10 11 12 13 14 15 16 1720 21 22 23 24 25 26 2730 31 32 Х
2e79b3 33 34 35 36 3740 41 42 43 44 45 46 4750 51 52 53 54 55 56 57
159ec4 0000000000000000 иии' XOR MASK
7e10d0 123456789ABCDEF0 иии' Ciphertext 0
690908 123456789ABCDEF0 иии' Ciphertext 1
9cb374 0F иииииииииииииииии' Plaintext byte mask
ebed5e 0 ииииииииииииииииии' use CBC
72af2d 1 ииииииииииииииииии' extra XOR
a25b0d 1 ииииииииииииииииии' don't seed PRNG (use this input file)
fa2fcc 01020304050607 иииии' starting key
2b6f6b 8000 иииииииииииииии' number of clocks
f8af5a
49af5a
29c4d8 d6 e9 89 fa и'DES_DECRYPT(k=0D020304050612, c=123456789ABCDEF0)=B8 C0 1B 3E 35 Х
84c98d DB 2F DE иииииии00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F 10 11 12 13 14 Х
b1422d 15 16 17 18 19 1A 1B 1C 1D 1E 1F 20 21 22 23 24 25 26 27 28 29 2A 2B 2C 2D 2E 2Х
89c4e2 F30 31 32 33 34 35 36 37 38 39 3A 3B 3C 3D 3E 3F 40 41 42 43 44 45 46 47 48 49 Х
f7e1db 4A 4B 4C 4D 4E 4F50 51 52 53 54 55 56 57 58 59 5A 5B 5C 5D 5E 5F 60 61 62 63 64Х
58e46f и65 66 67 68 69 6A 6B 6C 6D 6E 6F70 71 72 73 74 75 76 77 78 79 7A 7B 7C 7D 7E 7Х
ff0795 F 80 81 82 83 84 85 86 87 88 89 8A 8B 8C 8D 8E 8F90 91 92 93 94 95 96 97 98 99 Х
505b42 9A 9B 9C 9D 9E 9F иA0 A1 A2 A3 A4 A5 A6 A7 A8 A9 AA AB AC AD AE AFB0 B1 B2 B3 BХ
7fa3b9 4 B5 B6 B7 B8 B9 BA BB BC BD BE BF C0 C1 C2 C3 C4 C5 C6 C7 C8 C9 CA CB CC CD CEХ
f6f44d иCFD0 D1 D2 D3 D4 D5 D6 D7 D8 D9 DA DB DC DD DE DF E0 E1 E2 E3 E4 E5 E6 E7 E8 EХ
ea8b9b 9 EA EB EC ED EE EFF0 F1 F2 F3 F4 F5 F6 F7 F8 F9 FA FB FC FD FEи
abaf5a


--a728 0015c860f9980040004 Page 1 of cbc1.scr
f64ce1 00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F 10 11 12 13 14 15 16 17 18 19 1Х
b53734 A 1B 1C 1D 1E 1F 20 21 22 23 24 25 26 27 28 29 2A 2B 2C 2D 2E 2F 30 31 32 33 34Х
5f0653 и35 36 37 38 39 3A 3B 3C 3D 3E 3F 40 41 42 43 44 45 46 47 48 49 4A 4B 4C 4D 4E Х
bc6d97 4F 50 51 52 53 54 55 56 57 58 59 5A 5B 5C 5D 5E 5F 60 61 62 63 64 65 66 67 68 6Х
a1cb67 9 6A 6B 6C 6D 6E 6F 70 71 72 73 74 75 76 77 78 79 7A 7B 7C 7D 7E 7F 80 81 82 83Х
b32164 и84 85 86 87 88 89 8A 8B 8C 8D 8E 8F 90 91 92 93 94 95 96 97 98 99 9A 9B #9C 9DХ
d8a908 и9E 9F A0 A1 A2 A3 A4 A5 A6 A7 A8 A9 AA AB AC AD AE AF B0 B1 B2 B3 B4 B5 B6 B7 Х
babb7d B8 B9 BA BB BC BD BE BF C0 C1 C2 C3 C4 C5 C6 C7 C8 C9 CA CB CC CD CE CF D0 D1 DХ
54b467 2 D3 D4 D5 D6 D7 D8 D9 DA DB DC DD DE DF E0 E1 E2 E3 E4 E5 E6 E7 E8 E9 EA EB ECХ
c890fe иED EE EF F0 F1 F2 F3 F4 F5 F6 F7 F8 F9 FA FB FC FD FE FF
2f281f 37393b51def84190 иии' XOR MASK
1810d0 123456789ABCDEF0 иии' Ciphertext 0
596a3f 0102030405060708 иии' Ciphertext 1
b98c19 00 иииииииииииииииии' Plaintext byte mask
56cdad 1 ииииииииииииииииии' use CBC
b0d84f 0 ииииииииииииииииии' extra XOR
095b0d 1 ииииииииииииииииии' don't seed PRNG (use this input file)
322fcc 01020304050607 иииии' starting key
359df9 10000 ииииииииииииии' number of clocks
5caf5a


--a112 00101ebc6db80040005 Page 1 of cbc2.scr
f64ce1 00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F 10 11 12 13 14 15 16 17 18 19 1Х
b53734 A 1B 1C 1D 1E 1F 20 21 22 23 24 25 26 27 28 29 2A 2B 2C 2D 2E 2F 30 31 32 33 34Х
5f0653 и35 36 37 38 39 3A 3B 3C 3D 3E 3F 40 41 42 43 44 45 46 47 48 49 4A 4B 4C 4D 4E Х
bc6d97 4F 50 51 52 53 54 55 56 57 58 59 5A 5B 5C 5D 5E 5F 60 61 62 63 64 65 66 67 68 6Х
a1cb67 9 6A 6B 6C 6D 6E 6F 70 71 72 73 74 75 76 77 78 79 7A 7B 7C 7D 7E 7F 80 81 82 83Х
237dda и84 85 86 87 88 89 8A 8B 8C 8D 8E 8F 90 91 92 93 94 95 96 97 98 99 9A 9B 9C 9D Х
23435f 9E 9F A0 A1 A2 A3 A4 A5 A6 A7 A8 A9 AA AB AC AD AE AF B0 B1 B2 B3 B4 B5 B6 B7 BХ

1ce1f9 8 B9 BA # BB BC BD BE BF C0 C1 C2 C3 C4 C5 C6 C7 C8 C9 CA CB CC CD CE CF D0 D1 Х
80796d D2 D3 D4 D5 D6 D7 D8 D9 DA DB DC DD DE DF E0 E1 E2 E3 E4 E5 E6 E7 E8 E9 EA EB EХ
0b8b2a C ED EE EF F0 F1 F2 F3 F4 F5 F6 F7 F8 F9 FA FB FC FD FE FF
56ac5f 423412341234123F иии' XOR MASK
0b327c 0000000000000000 иии' Ciphertext 0
ee53f1 1578345691832465 иии' Ciphertext 1
23e767 04 иииииииииииииииии' Plaintext byte mask
20cdad 1 ииииииииииииииииии' use CBC
00d84f 0 ииииииииииииииииии' extra XOR
795b0d 1 ииииииииииииииииии' don't seed PRNG (use this input file)
12de95 FFFFFFFFFFFFF0 иииии' starting key
309df9 10000 ииииииииииииии' number of clocks
01af5a






--3fb8 001348ab9e680040006 Page 1 of cbc3.scr
2c9f3b 00 01 02 03 04 05 07 08 09 0D 0E 0F 10 11 12 14 15 17 1A 1B 1C 1D 1F 20 21 24 2Х
bd57bd 5 28 29 2A 2B 2C 2E 30 31 32 35 36 37 39 3A 3C 3D 3E 40 42 43 44 45 48 49 4A 4BХ
1b6fb2 и4C 4F 50 51 53 54 56 57 58 59 5C 5D 5F 61 62 63 64 66 67 69 6B 6C 6D 6F 70 71 Х
6e57e8 72 73 77 78 7A 7B 7D 7E 7F 80 82 86 87 89 8A 8B 8C 8D 8E 90 92 93 94 95 97 98 9Х
753dfa 9 9A 9B 9E 9F A0 A2 A3 A4 A5 A6 A8 AA AC AD AE AF B0 B1 B3 B4 B7 B8 B9 F8 F9 FAХ
958c0a иFB FC FD FF BB BC BD BE C0 C1 C3 C5 C6 C7 C8 C9 CA CB CC CD CE CF D0 D1 D2 D3 Х
09fa11 D4 D5 D6 D7 D8 D9 DA DB DC DD DE DF E0 E1 E2 E3 E4 # E5 E6 E7 E8 E9 EA EB EC EDХ
473f52 иEE EF F0 F1 F2 F3 F4 F5 F6 F7 F8 F9 FA FB FC FD FE FF
638b27 0124801248012480 иии' XOR MASK
3745a7 FFFFFFFFFFFFFFFF иии' Ciphertext 0
1d2ba4 0000000000000000 иии' Ciphertext 1
d6b12c 80 иииииииииииииииии' Plaintext byte mask
72cdad 1 ииииииииииииииииии' use CBC
37d84f 0 ииииииииииииииииии' extra XOR
e85b0d 1 ииииииииииииииииии' don't seed PRNG (use this input file)
afa481 00000000000000 иииии' starting key
e49df9 10000 ииииииииииииии' number of clocks
34af5a
--b787 000d22ad6f780040007 Page 1 of des.c
8d2d03 /*****************************************************************************
d729eb и* ииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии*
b2074d и* иииииииииииииииSoftware Model of ASIC DES Implementation. ииииииииииииииии*
4a29eb и* ииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии*
9f9048 и* иWritten by Paul Kocher, Tel: 415-397-0111, Email: paul@cryptography.com и*
ce29eb и* ииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии*
e7489b и*****************************************************************************
de29eb и* ииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии*
c515cb и* ииIMPLEMENTATION NOTES: ииииииииииииииииииииииииииииииииииииииииииииииииии*
3429eb и* ииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии*
987602 и* ииThis DES implementation adheres to the FIPS PUB 46 spec and produces иии*
a90da9 и* ииstandard output. иThe internal operation of the algorithm is quite иииии*
9a876e и* ииdifferent from the FIPS. иFor example, bit orderings are reversed ииииии*
a41be6 и* ии(the right-hand bit is now labelled as bit 0), the S tables have иииииии*
06b9c7 и* ииrearranged to simplify implementation, and several permutations have иии*
44966d и* ииbeen inverted. иNo performance optimizations were attempted. иииииииииии*
1829eb и* ииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии*
3e489b и*****************************************************************************
aa29eb и* ииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии*
496eef и* ииREVISION HISTORY: ииииииииииииииииииииииииииииииииииииииииииииииииииииии*
ba29eb и* ииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии*
0bc443 и* ииVersion 1.0: иInitial release и-- PCK. иииииииииииииииииииииииииииииииии*
d7b74c и* ииVersion 1.1: иAltered DecryptDES exchanges to match EncryptDES. -- PCK и*
fa5c27 и* ииVersion 1.2: иMinor edits and beautifications. и-- PCK иииииииииииииииии*
e0d8c3 и*****************************************************************************/
9aaf5a
a8af5a
00feb2 #include <stdio.h>
a3bea3 #include <stdlib.h>
94324c #include <string.h>
e92bac #include "des.h"
fbaf5a
f77461 static void ComputeRoundKey(bool roundKey[56], bool key[56]);
6d84a3 static void RotateRoundKeyLeft(bool roundKey[56]);
57ccfa static void RotateRoundKeyRight(bool roundKey[56]);
741504 static void ComputeIP(bool L[32], bool R[32], bool inBlk[64]);
1c07da static void ComputeFP(bool outBlk[64], bool L[32], bool R[32]);
fe017b static void ComputeF(bool fout[32], bool R[32], bool roundKey[56]);
ef94fe static void ComputeP(bool output[32], bool input[32]);
7f7fae static void ComputeS_Lookup(int k, bool output[4], bool input[6]);
25abe7 static void ComputePC2(bool subkey[48], bool roundKey[56]);
fdfd9c static void ComputeExpansionE(bool expandedBlock[48], bool R[32]);
662f30 static void DumpBin(char *str, bool *b, int bits);
ad43bc static void Exchange_L_and_R(bool L[32], bool R[32]);
39af5a
efc223 int EnableDumpBin = 0;
f5af5a
7caf5a
84af5a
d84d6c /**********************************************************************/
a5c68f /* иииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии*/
033c1a /* иииииииииииииииииииииииииииDES TABLES иииииииииииииииииииииииииииии*/
14c68f /* иииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии*/
264d6c /**********************************************************************/
6faf5a
76af5a
8838e5 /*
aa556a и* иIP: Output bit table_DES_IP[i] equals input bit i.
30495d и*/
09c166 static int table_DES_IP[64] = {
829d69 ииии39, и7, 47, 15, 55, 23, 63, 31,
10c827 ииии38, и6, 46, 14, 54, 22, 62, 30,
4b38ae ииии37, и5, 45, 13, 53, 21, 61, 29,
2b6de0 ииии36, и4, 44, 12, 52, 20, 60, 28,
f5b247 ииии35, и3, 43, 11, 51, 19, 59, 27,
c7e709 ииии34, и2, 42, 10, 50, 18, 58, 26,
28829e ииии33, и1, 41, и9, 49, 17, 57, 25,
4811ff ииии32, и0, 40, и8, 48, 16, 56, 24
2882f7 };
39af5a
95af5a
d238e5 /*
--43e9 000e122426b80040007 Page 2 of des.c
ac48ca и* иFP: Output bit table_DES_FP[i] equals input bit i.
c0495d и*/
2ddd2a static int table_DES_FP[64] = {
675b71 ииии57, 49, 41, 33, 25, 17, и9, и1,
768cd9 ииии59, 51, 43, 35, 27, 19, 11, и3,
b79996 ииии61, 53, 45, 37, 29, 21, 13, и5,
93b571 ииии63, 55, 47, 39, 31, 23, 15, и7,
040e3f ииии56, 48, 40, 32, 24, 16, и8, и0,
62d997 ииии58, 50, 42, 34, 26, 18, 10, и2,
f5ccd8 ииии60, 52, 44, 36, 28, 20, 12, и4,
664da9 ииии62, 54, 46, 38, 30, 22, 14, и6
2d82f7 };
7baf5a
b0af5a
0f38e5 /*
85da05 и* иPC1: Permutation choice 1, used to pre-process the key
da495d и*/
a40c38 static int table_DES_PC1[56] = {
0db89e ииии27, 19, 11, 31, 39, 47, 55,
bb28e4 ииии26, 18, 10, 30, 38, 46, 54,
cf8d2c ииии25, 17, и9, 29, 37, 45, 53,
ce1d56 ииии24, 16, и8, 28, 36, 44, 52,
62bf91 ииии23, 15, и7, и3, 35, 43, 51,
d72feb ииии22, 14, и6, и2, 34, 42, 50,
b491e6 ииии21, 13, и5, и1, 33, 41, 49,
b0d02f ииии20, 12, и4, и0, 32, 40, 48
1782f7 };
67af5a
16af5a
b638e5 /*
2af37a и* иPC2: Map 56-bit round key to a 48-bit subkey
89495d и*/
097fcf static int table_DES_PC2[48] = {
e98889 ииии24, 27, 20, и6, 14, 10, и3, 22,
1b30a5 иииии0, 17, и7, 12, и8, 23, 11, и5,
893fa5 ииии16, 26, и1, и9, 19, 25, и4, 15,
dee272 ииии54, 43, 36, 29, 49, 40, 48, 30,
566356 ииии52, 44, 37, 33, 46, 35, 50, 41,
ab7786 ииии28, 53, 51, 55, 32, 45, 39, 42
2a82f7 };

11af5a
c0af5a
2238e5 /*
9adb31 и* иE: Expand 32-bit R to 48 bits.
35495d и*/
846a87 static int table_DES_E[48] = {
78e6fb ииии31, и0, и1, и2, и3, и4, и3, и4,
fa2634 иииии5, и6, и7, и8, и7, и8, и9, 10,
16d06b ииии11, 12, 11, 12, 13, 14, 15, 16,
117fa0 ииии15, 16, 17, 18, 19, 20, 19, 20,
184d0d ииии21, 22, 23, 24, 23, 24, 25, 26,
139708 ииии27, 28, 27, 28, 29, 30, 31, и0
8a82f7 };
79af5a
cdaf5a
a738e5 /*
69c34a и* иP: Permutation of S table outputs
ea495d и*/
745137 static int table_DES_P[32] = {
aaf612 ииии11, 17, и5, 27, 25, 10, 20, и0,
3fb9f8 ииии13, 21, и3, 28, 29, и7, 18, 24,
8fcde3 ииии31, 22, 12, и6, 26, и2, 16, и8,
d560a7 ииии14, 30, и4, 19, и1, и9, 15, 23
8482f7 };
79af5a
8eaf5a
d038e5 /*
2b6f34 и* иS Tables: Introduce nonlinearity and avalanche
d2495d и*/
b71e19 static int table_DES_S[8][64] = {
8bd69a ииии/* table S[0] */
e1846d ииииииии{ ии13, и1, и2, 15, и8, 13, и4, и8, и6, 10, 15, и3, 11, и7, и1, и4,
--1f22 000be80f13a80040007 Page 3 of des.c
f065af ииииииииииии10, 12, и9, и5, и3, и6, 14, 11, и5, и0, и0, 14, 12, и9, и7, и2,

12d5b0 иииииииииииии7, и2, 11, и1, и4, 14, и1, и7, и9, и4, 12, 10, 14, и8, и2, 13,
5a3ee1 иииииииииииии0, 15, и6, 12, 10, и9, 13, и0, 15, и3, и3, и5, и5, и6, и8, 11 и},
d0d2b1 ииии/* table S[1] */
8b4b6a ииииииии{ иии4, 13, 11, и0, и2, 11, 14, и7, 15, и4, и0, и9, и8, и1, 13, 10,
0cdf4d иииииииииииии3, 14, 12, и3, и9, и5, и7, 12, и5, и2, 10, 15, и6, и8, и1, и6,
8bf575 иииииииииииии1, и6, и4, 11, 11, 13, 13, и8, 12, и1, и3, и4, и7, 10, 14, и7,
cf6234 ииииииииииии10, и9, 15, и5, и6, и0, и8, 15, и0, 14, и5, и2, и9, и3, и2, 12 и},
38decc ииии/* table S[2] */
7df108 ииииииии{ ии12, 10, и1, 15, 10, и4, 15, и2, и9, и7, и2, 12, и6, и9, и8, и5,
a3d582 иииииииииииии0, и6, 13, и1, и3, 13, и4, 14, 14, и0, и7, 11, и5, и3, 11, и8,
fd0bbf иииииииииииии9, и4, 14, и3, 15, и2, и5, 12, и2, и9, и8, и5, 12, 15, и3, 10,
137505 иииииииииииии7, 11, и0, 14, и4, и1, 10, и7, и1, и6, 13, и0, 11, и8, и6, 13 и},
9fdae7 ииии/* table S[3] */
f35c4d ииииииии{ иии2, 14, 12, 11, и4, и2, и1, 12, и7, и4, 10, и7, 11, 13, и6, и1,
2c0156 иииииииииииии8, и5, и5, и0, и3, 15, 15, 10, 13, и3, и0, и9, 14, и8, и9, и6,
def5dc иииииииииииии4, 11, и2, и8, и1, 12, 11, и7, 10, и1, 13, 14, и7, и2, и8, 13,
62d332 ииииииииииии15, и6, и9, 15, 12, и0, и5, и9, и6, 10, и3, и4, и0, и5, 14, и3 и},
97c636 ииии/* table S[4] */
d74850 ииииииии{ иии7, 13, 13, и8, 14, 11, и3, и5, и0, и6, и6, 15, и9, и0, 10, и3,
aef1a6 иииииииииииии1, и4, и2, и7, и8, и2, и5, 12, 11, и1, 12, 10, и4, 14, 15, и9,
5af43f ииииииииииии10, и3, и6, 15, и9, и0, и0, и6, 12, 10, 11, и1, и7, 13, 13, и8,
87d830 ииииииииииии15, и9, и1, и4, и3, и5, 14, 11, и5, 12, и2, и7, и8, и2, и4, 14 и},
fbc21d ииии/* table S[5] */
e2ea9b ииииииии{ ии10, 13, и0, и7, и9, и0, 14, и9, и6, и3, и3, и4, 15, и6, и5, 10,
35bd2c иииииииииииии1, и2, 13, и8, 12, и5, и7, 14, 11, 12, и4, 11, и2, 15, и8, и1,
55d567 ииииииииииии13, и1, и6, 10, и4, 13, и9, и0, и8, и6, 15, и9, и3, и8, и0, и7,
9b8261 ииииииииииии11, и4, и1, 15, и2, 14, 12, и3, и5, 11, 10, и5, 14, и2, и7, 12 и},
09ce60 ииии/* table S[6] */
fea636 ииииииии{ ии15, и3, и1, 13, и8, и4, 14, и7, и6, 15, 11, и2, и3, и8, и4, 14,
baac1c иииииииииииии9, 12, и7, и0, и2, и1, 13, 10, 12, и6, и0, и9, и5, 11, 10, и5,
677311 иииииииииииии0, 13, 14, и8, и7, 10, 11, и1, 10, и3, и4, 15, 13, и4, и1, и2,
f8b1aa иииииииииииии5, 11, и8, и6, 12, и7, и6, 12, и9, и0, и3, и5, и2, 14, 15, и9 и},
c1ca4b ииии/* table S[7] */
e8cf66 ииииииии{ ии14, и0, и4, 15, 13, и7, и1, и4, и2, 14, 15, и2, 11, 13, и8, и1,
e3aacb иииииииииииии3, 10, 10, и6, и6, 12, 12, 11, и5, и9, и9, и5, и0, и3, и7, и8,
fa2f45 иииииииииииии4, 15, и1, 12, 14, и8, и8, и2, 13, и4, и6, и9, и2, и1, 11, и7,
252777 ииииииииииии15, и5, 12, 11, и9, и3, и7, 14, и3, 10, 10, и0, и5, и6, и0, 13 и}
0d82f7 };
44af5a
88af5a
1eaf5a
51af5a
be4d6c /**********************************************************************/
25c68f /* иииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии*/
4ecabf /* ииииииииииииииииииииииииииииDES CODE ииииииииииииииииииииииииииииии*/
77c68f /* иииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии*/
494d6c /**********************************************************************/
e8af5a
8aaf5a
9138e5 /*
11b080 и* иEncryptDES: Encrypt a block using DES. Set verbose for debugging info.
65770b и* и(This loop does both loops on the "DES Encryption" page of the flowchart.)
1e495d и*/
5a5620 void EncryptDES(bool key[56], bool outBlk[64], bool inBlk[64], int verbose) {
d72b1c ииint i,round;
3a9aa1 ииbool R[32], L[32], fout[32];
1cbfaf ииbool roundKey[56];
24af5a
eb94e2 ииEnableDumpBin = verbose; иииииииииииииииииии/* set debugging on/off flag */
ebcb2a ииDumpBin("input(left)", inBlk+32, 32);
558fb2 ииDumpBin("input(right)", inBlk, 32);
bc0a8e ииDumpBin("raw key(left )", key+28, 28);
8a5585 ииDumpBin("raw key(right)", key, 28);
eeaf5a
f4c1be ии/* Compute the first roundkey by performing PC1 */
53b264 ииComputeRoundKey(roundKey, key);
86af5a
6795d4 ииDumpBin("roundKey(L)", roundKey+28, 28);
070a5f ииDumpBin("roundKey(R)", roundKey, 28);
09af5a
be1340 ии/* Compute the initial permutation and divide the result into L and R */
--e2ca 0004f895fba80040007 Page 4 of des.c
d8d1a8 ииComputeIP(L,R,inBlk);
c8af5a
b277ba ииDumpBin("after IP(L)", L, 32);
4b7699 ииDumpBin("after IP(R)", R, 32);
56af5a
44f437 ииfor (round = 0; round < 16; round++) {
d221bf ииииif (verbose)
5f91a0 ииииииprintf("-------------- BEGIN ENCRYPT ROUND %d -------------\n", round);
aa8034 ииииDumpBin("round start(L)", L, 32);
ec8117 ииииDumpBin("round start(R)", R, 32);
d8af5a
f27fc3 ииии/* Rotate roundKey halves left once or twice (depending on round) */
3ec8ba ииииRotateRoundKeyLeft(roundKey);
031467 ииииif (round != 0 && round != 1 && round != 8 && round != 15)
9650e7 ииииииRotateRoundKeyLeft(roundKey);
dd3cd7 ииииDumpBin("roundKey(L)", roundKey+28, 28);
3f1bd4 ииииDumpBin("roundKey(R)", roundKey, 28);
8baf5a
2a033b ииии/* Compute f(R, roundKey) and exclusive-OR onto the value in L */
73d969 ииииComputeF(fout, R, roundKey);
1054e7 ииииDumpBin("f(R,key)", fout, 32);

834739 ииииfor (i = 0; i < 32; i++)
eaa9e6 ииииииL[i] ^= fout[i];
aca5ab ииииDumpBin("L^f(R,key)", L, 32);
92af5a
8f68b4 ииииExchange_L_and_R(L,R);
c2af5a
a5a140 ииииDumpBin("round end(L)", L, 32);
9da063 ииииDumpBin("round end(R)", R, 32);
0c21bf ииииif (verbose)
ee4514 ииииииprintf("--------------- END ROUND %d --------------\n", round);
bedf1c ии}
39af5a
f08e68 ииExchange_L_and_R(L,R);
7baf5a
a7370b ии/* Combine L and R then compute the final permutation */
e3cf94 ииComputeFP(outBlk,L,R);

668b91 ииDumpBin("FP out( left)", outBlk+32, 32);
a4f675 ииDumpBin("FP out(right)", outBlk, 32);
ffefe6 }
bbaf5a
64af5a
1faf5a
2638e5 /*
c19b68 и* иDecryptDES: Decrypt a block using DES. Set verbose for debugging info.
83a5c7 и* и(This loop does both loops on the "DES Decryption" page of the flowchart.)
7e495d и*/
c36de8 void DecryptDES(bool key[56], bool outBlk[64], bool inBlk[64], int verbose) {
c02b1c ииint i,round;
a89aa1 ииbool R[32], L[32], fout[32];
52bfaf ииbool roundKey[56];
87af5a
6e94e2 ииEnableDumpBin = verbose; иииииииииииииииииии/* set debugging on/off flag */
e2cb2a ииDumpBin("input(left)", inBlk+32, 32);

ef8fb2 ииDumpBin("input(right)", inBlk, 32);
340a8e ииDumpBin("raw key(left )", key+28, 28);
ed5585 ииDumpBin("raw key(right)", key, 28);
9faf5a
3ac1be ии/* Compute the first roundkey by performing PC1 */
20b264 ииComputeRoundKey(roundKey, key);
afaf5a
c595d4 ииDumpBin("roundKey(L)", roundKey+28, 28);
c90a5f ииDumpBin("roundKey(R)", roundKey, 28);
f4af5a
311340 ии/* Compute the initial permutation and divide the result into L and R */
03d1a8 ииComputeIP(L,R,inBlk);
a8af5a
c277ba ииDumpBin("after IP(L)", L, 32);
2f7699 ииDumpBin("after IP(R)", R, 32);
a6af5a
1bf437 ииfor (round = 0; round < 16; round++) {
4f21bf ииииif (verbose)
--4cd6 000642b0cd180040007 Page 5 of des.c
db2cb4 ииииииprintf("-------------- BEGIN DECRYPT ROUND %d -------------\n", round);
908034 ииииDumpBin("round start(L)", L, 32);
a48117 ииииDumpBin("round start(R)", R, 32);
c5af5a
3d033b ииии/* Compute f(R, roundKey) and exclusive-OR onto the value in L */
b5d969 ииииComputeF(fout, R, roundKey);
5d54e7 ииииDumpBin("f(R,key)", fout, 32);
c84739 ииииfor (i = 0; i < 32; i++)


d5a9e6 ииииииL[i] ^= fout[i];
5ba5ab ииииDumpBin("L^f(R,key)", L, 32);

b2af5a
fa68b4 ииииExchange_L_and_R(L,R);
18af5a
f3c90d ииии/* Rotate roundKey halves right once or twice (depending on round) */
6e48f3 ииииDumpBin("roundKey(L)", roundKey+28, 28); и/* show keys before shift */
7f1bd4 ииииDumpBin("roundKey(R)", roundKey, 28);
90f5db ииииRotateRoundKeyRight(roundKey);
8711ff ииииif (round != 0 && round != 7 && round != 14 && round != 15)
ba7c23 ииииииRotateRoundKeyRight(roundKey);
5baf5a
69a140 ииииDumpBin("round end(L)", L, 32);
c6a063 ииииDumpBin("round end(R)", R, 32);
f621bf ииииif (verbose)

784514 ииииииprintf("--------------- END ROUND %d --------------\n", round);
23df1c ии}
30af5a
ec8e68 ииExchange_L_and_R(L,R);
f5af5a
f5370b ии/* Combine L and R then compute the final permutation */
f5cf94 ииComputeFP(outBlk,L,R);
8d8b91 ииDumpBin("FP out( left)", outBlk+32, 32);
94f675 ииDumpBin("FP out(right)", outBlk, 32);
efefe6 }
3daf5a
deaf5a
41af5a
fc38e5 /*
4b8d8b и* иComputeRoundKey: Compute PC1 on the key and store the result in roundKey
c1495d и*/
3e988e static void ComputeRoundKey(bool roundKey[56], bool key[56]) {
9e17e0 ииint i;
60af5a
f9815b ииfor (i = 0; i < 56; i++)
70d64b ииииroundKey[table_DES_PC1[i]] = key[i];
54efe6 }
24af5a
8caf5a
daaf5a
1b38e5 /*
8155cb и* иRotateRoundKeyLeft: Rotate each of the halves of roundKey left one bit
44495d и*/
737d60 static void RotateRoundKeyLeft(bool roundKey[56]) {
cf483e ииbool temp1, temp2;
7217e0 ииint i;
c7af5a
0ff689 ииtemp1 = roundKey[27];
83fe1b ииtemp2 = roundKey[55];

9c300b ииfor (i = 27; i >= 1; i--) {
95575a ииииroundKey[i] = roundKey[i-1];
0b3242 ииииroundKey[i+28] = roundKey[i+28-1];
aadf1c ии}
bc7b9f ииroundKey[ 0] = temp1;
b3cf9d ииroundKey[28] = temp2;
51efe6 }
fbaf5a
5caf5a
51af5a
0c38e5 /*

3bc6ad и* иRotateRoundKeyRight: Rotate each of the halves of roundKey right one bit
87495d и*/
57b26c static void RotateRoundKeyRight(bool roundKey[56]) {
64483e ииbool temp1, temp2;
--20a0 000e89a59d480040007 Page 6 of des.c
eb17e0 ииint i;
71af5a
085025 ииtemp1 = roundKey[0];
754548 ииtemp2 = roundKey[28];
78e568 ииfor (i = 0; i < 27; i++) {
806cc2 ииииroundKey[i] = roundKey[i+1];
fd09da ииииroundKey[i+28] = roundKey[i+28+1];
c1df1c ии}
d5a88d ииroundKey[27] = temp1;
365d11 ииroundKey[55] = temp2;
29efe6 }
5daf5a
45af5a
d8af5a
2f38e5 /*
022903 и* иComputeIP: Compute the initial permutation and split into L and R halves.
fb495d и*/
fcac44 static void ComputeIP(bool L[32], bool R[32], bool inBlk[64]) {
826085 ииbool output[64];
f917e0 ииint i;
bdaf5a
81aeaf ии/* Permute
71f9a6 иии*/
466406 ииfor (i = 63; i >= 0; i--)
a8c750 ииииoutput[table_DES_IP[i]] = inBlk[i];
0aaf5a
af0318 ии/* Split into R and L. иBits 63..32 go in L, bits 31..0 go in R.
54f9a6 иии*/
b8ba85 ииfor (i = 63; i >= 0; i--) {
5b0368 ииииif (i >= 32)
67f2b8 ииииииL[i-32] = output[i];
50842c ииииelse
7970b5 ииииииR[i] = output[i];
22df1c ии}
04efe6 }
46af5a
c0af5a
96af5a
6a38e5 /*
d84ffe и* иComputeFP: Combine the L and R halves and do the final permutation.
65495d и*/
9893a5 static void ComputeFP(bool outBlk[64], bool L[32], bool R[32]) {
ee42e9 ииbool input[64];
0b17e0 ииint i;
0faf5a
056c41 ии/* Combine L and R into input[64]
30f9a6 иии*/
836406 ииfor (i = 63; i >= 0; i--)
5a8397 ииииinput[i] = (i >= 32) ? L[i - 32] : R[i];
4caf5a
97aeaf ии/* Permute
1cf9a6 иии*/
e16406 ииfor (i = 63; i >= 0; i--)
fbe116 ииииoutBlk[table_DES_FP[i]] = input[i];
c4efe6 }
3baf5a
13af5a
b9af5a
a438e5 /*
33810f и* иComputeF: Compute the DES f function and store the result in fout.
14495d и*/
af2720 static void ComputeF(bool fout[32], bool R[32], bool roundKey[56]) {
a9f6a2 ииbool expandedBlock[48], subkey[48], sout[32];
51bbe6 ииint i,k;
23af5a
291a04 ии/* Expand R into 48 bits using the E expansion */
a599d7 ииComputeExpansionE(expandedBlock, R);
f1f0ba ииDumpBin("expanded E", expandedBlock, 48);
81af5a
7c93ff ии/* Convert the roundKey into the subkey using PC2 */
f17840 ииComputePC2(subkey, roundKey);
e8d717 ииDumpBin("subkey", subkey, 48);
--4509 0001cf13c2680040007 Page 7 of des.c
e0af5a
c3154c ии/* XOR the subkey onto the expanded block */
adfcab ииfor (i = 0; i < 48; i++)
4f6512 ииииexpandedBlock[i] ^= subkey[i];
c0af5a
870740 ии/* Divide expandedBlock into 6-bit chunks and do S table lookups */
1d25c6 ииfor (k = 0; k < 8; k++)
6585c7 ииииComputeS_Lookup(k, sout+4*k, expandedBlock+6*k);
f8af5a
b3fd35 ии/* To complete the f() calculation, do permutation P on the S table output */
e92d52 ииComputeP(fout, sout);
deefe6 }
3baf5a
25af5a
0faf5a
8438e5 /*
00913f и* иComputeP: Compute the P permutation on the S table outputs.
25495d и*/
0bf410 static void ComputeP(bool output[32], bool input[32]) {
5a17e0 ииint i;
b6af5a
95339a ииfor (i = 0; i < 32; i++)
347688 ииииoutput[table_DES_P[i]] = input[i];
57efe6 }
80af5a
67af5a
75af5a
e638e5 /*

2a859b и* иLook up a 6-bit input in S table k and store the result as a 4-bit output.
2e495d и*/
59a67e static void ComputeS_Lookup(int k, bool output[4], bool input[6]) {
d0f3da ииint inputValue, outputValue;
3daf5a
261a9e ии/* Convert the input bits into an integer */
e2fccb ииinputValue = input[0] + 2*input[1] + 4*input[2] + 8*input[3] +
468c1a ииииииииии16*input[4] + 32*input[5];
1caf5a
a64a3e ии/* Do the S table lookup */
a2b706 ииoutputValue = table_DES_S[k][inputValue];
eeaf5a
df8aed ии/* Convert the result into binary form */
529a60 ииoutput[0] = (outputValue & 1) ? 1 : 0;
2c6aec ииoutput[1] = (outputValue & 2) ? 1 : 0;
a4f487 ииoutput[2] = (outputValue & 4) ? 1 : 0;
208c7f ииoutput[3] = (outputValue & 8) ? 1 : 0;
27efe6 }
dcaf5a
d8af5a
f4af5a
5938e5 /*
9781cc и* иComputePC2: Map a 56-bit round key onto a 48-bit subkey
a8495d и*/
07796f static void ComputePC2(bool subkey[48], bool roundKey[56]) {
ea17e0 ииint i;
2faf5a
64fcab ииfor (i = 0; i < 48; i++)
c3c8bc ииииsubkey[i] = roundKey[table_DES_PC2[i]];
f8efe6 }
89af5a
4eaf5a
8eaf5a
3b38e5 /*
7a459d и* иComputeExpansionE: Compute the E expansion to prepare to use S tables.
89495d и*/
89b46d static void ComputeExpansionE(bool expandedBlock[48], bool R[32]) {
bf17e0 ииint i;
94af5a
79fcab ииfor (i = 0; i < 48; i++)
d9b971 ииииexpandedBlock[i] = R[table_DES_E[i]];
8fefe6 }
9daf5a
1caf5a
--bb13 0016ae66eb080040007 Page 8 of des.c
e0af5a
d338e5 /*
4cf923 и* иExchange_L_and_R: иSwap L and R
ba495d и*/
f195d1 static void Exchange_L_and_R(bool L[32], bool R[32]) {
3f17e0 ииint i;
c2af5a
74339a ииfor (i = 0; i < 32; i++)
19fe8b ииииL[i] ^= R[i] ^= L[i] ^= R[i]; ииии/* exchanges L[i] and R[i] */
3cefe6 }
4faf5a
72af5a
feaf5a
a438e5 /*
439231 и* иDumpBin: Display intermediate values if emableDumpBin is set.
52495d и*/
9cdbd9 static void DumpBin(char *str, bool *b, int bits) {
0217e0 ииint i;
80af5a
c98af7 ииif ((bits % 4)!=0 || bits>48) {
17b2e5 ииииprintf("Bad call to DumpBin (bits > 48 or bit len not a multiple of 4\n");
4b646c ииииexit(1);
a6df1c ии}
adaf5a
783332 ииif (EnableDumpBin) {
35f079 ииииfor (i = strlen(str); i < 14; i++)
1ac8c3 ииииииprintf(" ");
1c5fc3 ииииprintf("%s: ", str);
56eac8 ииииfor (i = bits-1; i >= 0; i--)
22de5b ииииииprintf("%d", b[i]);
123177 ииииprintf(" ");
9c821f ииииfor (i = bits; i < 48; i++)
72c8c3 ииииииprintf(" ");
d86b57 ииииprintf("(");
9105d7 ииииfor (i = bits-4; i >= 0; i-=4)
c6f78c ииииииprintf("%X", b[i]+2*b[i+1]+4*b[i+2]+8*b[i+3]);
89fa6f ииииprintf(")\n");
e4df1c ии}
56efe6 }
6aaf5a
--e8aa 0017f449fe180040008 Page 1 of des.h
3008c5 typedef char bool;
d29629 void EncryptDES(bool key[56], bool outBlk[64], bool inBlk[64], int verbose);
2e8db3 void DecryptDES(bool key[56], bool outBlk[64], bool inBlk[64], int verbose);
7faf5a
--842b 001c97afa9d80040009 Page 1 of ecb.scr
f64ce1 00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F 10 11 12 13 14 15 16 17 18 19 1Х
fdb9bc A 1B 1C 1D 1E 1F 20 21 22 23 24 25 26 27 28 29 2A 2B 2C 2D 2E 2F30 31 32 33 34 Х
b5f9a7 35 36 37 38 39 3A 3B 3C 3D 3E 3F 40 41 42 43 44 45 46 47 48 49 4A 4B 4C 4D 4E 4Х
4c9b42 F50 51 52 53 54 55 56 57 58 59 5A 5B 5C 5D 5E 5F 60 61 62 63 64 65 66 67 68 69 Х
57b101 6A 6B 6C 6D 6E 6F70 71 72 73 74 75 76 77 78 79 7A 7B 7C 7D 7E 7F 80 81 82 83 84Х
5c2c39 и85 86 87 88 89 8A 8B 8C 8D 8E 8F90 91 92 93 94 95 96 97 98 99 9A 9B 9C 9D 9E 9Х
4a1c73 F # A0 A1 A2 A3 A4 A5 A6 A7 A8 A9 AA AB AC AD AE AFB0 B1 B2 B3 B4 B5 B6 B7 B8 BХ
36fc0a 9 BA BB BC BD BE BF C0 C1 C2 C3 C4 C5 C6 C7 C8 C9 CA CB CC CD CE CFD0 D1 D2 D3 Х
5b5b61 D4 D5 D6 D7 D8 D9 DA DB DC DD DE DF E0 E1 E2 E3 E4 E5 E6 E7 E8 E9 EA EB EC ED EХ
ea9439 E EFF0 F1 F2 F3 F4 F5 F6 F7 F8 F9 FA FB FC FD FE FF
829ec4 0000000000000000 иии' XOR MASK
b745a7 FFFFFFFFFFFFFFFF иии' Ciphertext 0
642ba4 0000000000000000 иии' Ciphertext 1
658c19 00 иииииииииииииииии' Plaintext byte mask
aacdad 1 ииииииииииииииииии' use CBC
ffd84f 0 ииииииииииииииииии' extra XOR
fb5b0d 1 ииииииииииииииииии' don't seed PRNG (use this input file)
332fcc 01020304050607 иииии' starting key
769df9 10000 ииииииииииииии' number of clocks
c9af5a
--cc30 001d5e0f0268004000a Page 1 of mini.scr
d6f4f1 5C416114B9D1D2D9B2550DF690FA75E798CC26203B1D79EB346229EDADE314B483321AA44BA4233Х
8ec7a2 8899568FDF85C1A9DEF1DE864EB2EAB4E52D7E075ADAA992D85DBAC85DD3A9A32
f39ec4 0000000000000000 иии' XOR MASK
fc10d0 123456789ABCDEF0 иии' Ciphertext 0
2e6a3f 0102030405060708 иии' Ciphertext 1
8b8c19 00 иииииииииииииииии' Plaintext byte mask
a1ed5e 0 ииииииииииииииииии' use CBC
89d84f 0 ииииииииииииииииии' extra XOR
ad5b0d 1 ииииииииииииииииии' don't seed PRNG (use this input file)
6eabc7 010203040505D5 иииии' starting key
80d03f 2000 ииииииииииииииии' number of clocks
d5af5a
--1b19 000748214c28004000b Page 1 of misc.c
56feb2 #include <stdio.h>
a1bea3 #include <stdlib.h>
a9c737 #include <memory.h>
79324c #include <string.h>
242bac #include "des.h"
3da50a #include "misc.h"
feaf5a
985854 #define VERBOSE
69af5a
1ac502 void GetUserInfo(unsigned char plaintextVector[32],и
d257e7 ииииииииunsigned char plaintextXorMask[8],и
13910f ииииииииunsigned char ciphertext0[8], unsigned char ciphertext[8],

5e446e ииииииииunsigned char *plaintextByteMask, int *useCBC, int *extraXor,
0ee00d ииииииииint *quickStart, unsigned char startKey[7], long *numClocks);
2b0986 void increment32(unsigned char *v);
5fb70b void decrement32(unsigned char *v);
61f314 void desDecrypt(unsigned char m[8], unsigned char c[8], unsigned char k[7]);
f5a5c5 void printHexString(char *tag, unsigned char *data, int len);
29708e static void EXIT_ERR(char *s) { fprintf(stderr, s); exit(1); }
f1560a int hex2bin(char *hex, unsigned char *bin);
87af5a
f3af5a
56c502 void GetUserInfo(unsigned char plaintextVector[32],и
6e57e7 ииииииииunsigned char plaintextXorMask[8],и
d31fa8 ииииииииunsigned char ciphertext0[8], unsigned char ciphertext1[8],
ad446e ииииииииunsigned char *plaintextByteMask, int *useCBC, int *extraXor,
7c3170 ииииииииint *quickStart, unsigned char startKey[7], long *numClocks) {
970e71 ииchar buffer[1024];
8cc6d6 ииunsigned char tmp[512];
ea17e0 ииint i;
b8af5a
ff4264 #ifdef VERBOSE
18659f ииprintf("Enter plaintextVector values: ");
657454 #endif
89766e ииgets(buffer);
30b72a ииi = hex2bin(buffer, tmp);
b053dd ииif (i <= 0 || i >= 256)
bc112c ииииEXIT_ERR("Must have at least 1 plaintextVector entry and at most 255.\n");
141bcb ииmemset(plaintextVector, 0, 32);
55f545 ииwhile (i--)
4a0422 ииииplaintextVector[tmp[i]/8] |= (128 >> (tmp[i] % 8));
46af5a
f74264 #ifdef VERBOSE
92ee8b ииprintf(" иииEnter plaintext xor mask: ");

267454 #endif
7d766e ииgets(buffer);
ecb72a ииi = hex2bin(buffer, tmp);
a11856 ииif (i != 8)
9ea670 ииииEXIT_ERR("Must have 8 plaintext xor mask bytes.");
11b657 ииmemcpy(plaintextXorMask, tmp, 8);
8caf5a
0d4264 #ifdef VERBOSE
3c3a0c ииprintf(" иииииииииEnter ciphertext 0: ");
9c7454 #endif
91766e ииgets(buffer);
34b72a ииi = hex2bin(buffer, tmp);
211856 ииif (i != 8)
adcf62 ииииEXIT_ERR("Must have 8 bytes in ciphertext 0.");
6398f3 ииmemcpy(ciphertext0, tmp, 8);
2baf5a
cd4264 #ifdef VERBOSE
31a5d9 ииprintf(" иииииииииEnter ciphertext 1: ");
797454 #endif
a6766e ииgets(buffer);
52b72a ииi = hex2bin(buffer, tmp);
a01856 ииif (i != 8)
eccb49 ииииEXIT_ERR("Must have 8 bytes in ciphertext 1.");
b11da6 ииmemcpy(ciphertext1, tmp, 8);
05af5a
184264 #ifdef VERBOSE
f5d221 ииprintf(" ииEnter plaintext byte mask: ");
747454 #endif
--9cbe 0004b9f4b098004000b Page 2 of misc.c
74766e ииgets(buffer);
82b72a ииi = hex2bin(buffer, tmp);
8a8448 ииif (i != 1)

b7f706 ииииEXIT_ERR("Plaintext byte mask is 1 byte long.");
6bc2b5 ии*plaintextByteMask = tmp[0];
7aaf5a
9d4264 #ifdef VERBOSE
7d1b21 ииprintf(" ииииииEnter useCBC (0 or 1): ");
f57454 #endif
56766e ииgets(buffer);
eab72a ииi = hex2bin(buffer, tmp);
e515b9 ииif (i != 1 || tmp[0] > 1)
b819c6 ииииEXIT_ERR("Must enter 0 or 1 for useCBC.");
68e2c1 ии*useCBC = tmp[0];
37af5a
264264 #ifdef VERBOSE
7bf965 ииprintf(" ииииEnter extraXor (0 or 1): ");
887454 #endif
4e766e ииgets(buffer);
61b72a ииi = hex2bin(buffer, tmp);
7e15b9 ииif (i != 1 || tmp[0] > 1)
776c75 ииииEXIT_ERR("Must enter 0 or 1 for extraXor.");
522353 ии*extraXor = tmp[0];
29af5a
a04264 #ifdef VERBOSE
a7e0e1 ииprintf(" ииEnter quickStart (0 or 1): ");
757454 #endif
ce766e ииgets(buffer);
19b72a ииi = hex2bin(buffer, tmp);
a015b9 ииif (i != 1 || tmp[0] > 1)
b12f69 ииииEXIT_ERR("Must enter 0 or 1 for quickStart\n");
83bd7b ии*quickStart = tmp[0];
91af5a
0eaf5a
514264 #ifdef VERBOSE
02c8bf ииprintf(" иииииииииEnter starting key: ");
187454 #endif
d3766e ииgets(buffer);
08e684 ииif (hex2bin(buffer, tmp) != 7)
f6a5e4 ииииEXIT_ERR("Must enter 7 hex bytes as the key.\n");
130ed3 ииmemcpy(startKey, tmp, 7);
86af5a
5f4264 #ifdef VERBOSE
43f4f6 ииprintf(" иииииEnter number of clocks: ");
1c7454 #endif
6f766e ииgets(buffer);
c677e8 ииsscanf(buffer, "%ld", numClocks);
4b8b81 ииif (*numClocks < 1 || *numClocks > 1000000000L)
d6b093 ииииEXIT_ERR("Must have between 1 and 1 billion clocks.\n");
6daf5a
134264 #ifdef VERBOSE
db186d ииprintHexString("\n иPtxtVector = ", plaintextVector, 32);
a4a738 ииprintHexString(" PtxtXorMask = ", plaintextXorMask, 8);
5dffc6 ииprintHexString("Ciphertext 0 = ", ciphertext0, 8);
b93b57 ииprintHexString("Ciphertext 1 = ", ciphertext1, 8);
99dd31 ииprintHexString("PtxtByteMask = ", plaintextByteMask, 1);
72e15b ииprintf( иииииии" иииииuseCBC = %d\n", *useCBC);
2b2f30 ииprintf( иииииии" иииextraXor = %d\n", *extraXor);
6817dc ииprintf( иииииии" иquickStart = %d\n", *quickStart);
5f1535 ииprintHexString("Starting key = ", startKey, 7);
157214 ииprintf( иииииии"Total clocks = %ld\n\n", *numClocks);
517454 #endif
ebefe6 }
7caf5a
25af5a
020b42 void increment32(unsigned char *v) {
fae2f8 ииif ((++(v[3])) == 0)
c7ab75 ииииif ((++(v[2])) == 0)
74b31a ииииииif ((++(v[1])) == 0)

584058 ииииииии++v[0];
9befe6 }
4baf5a
--0a18 0005d5aab618004000b Page 3 of misc.c
e45411 void decrement32(unsigned char *v) {
0dc266 ииif (((v[3])--) == 0)
b2dbd7 ииииif (((v[2])--) == 0)
f033fc ииииииif (((v[1])--) == 0)
2a3c05 ииииииииv[0]--;
d8efe6 }
adaf5a



e6bc23 void desDecrypt(unsigned char m[8], unsigned char c[8], unsigned char k[7]) {
15f65b ииbool key[56], message[64];
fd17e0 ииint i;
68af5a
54ec0c // иprintf("DES_DECRYPT(k="); for (i=0; i<7;i++) printf("%02X",k[i]); и//!!!
4cf514 // иprintf(", c="); for (i=0; i<8;i++) printf("%02X",c[i]); иииииииииии//!!!
f8af5a
13815b ииfor (i = 0; i < 56; i++)
ae9345 ииииkey[55-i] = ((k[i/8] << (i & 7)) & 128) ? 1 : 0;
f35c33 ииfor (i = 0; i < 64; i++)
10e5ed ииииmessage[63-i] = ((c[i/8] << (i & 7)) & 128) ? 1 : 0;
eac59d ииDecryptDES(key, message, message, 0);
5b1f76 ииfor (i = 0; i < 8; i++)
6f452e ииииm[i] = 0;
f55c33 ииfor (i = 0; i < 64; i++)
fa7511 ииииif (message[63-i])
59fe29 ииииииm[i/8] |= 128 >> (i%8);
f2af5a
04641f // иprintf(")="); for (i=0; i<8;i++) printf("%02X",m[i]); printf("\n"); //!!!
b8af5a
43efe6 }
17af5a
e5af5a
30c2bf int unhex(char c) {
bc53c4 ииif (c >= '0' && c <= '9')
1603d6 ииииreturn (c - '0');
8d8db1 ииif (c >= 'a' && c <= 'f')
480ada ииииreturn (c - 'a' + 10);
3449e3 ииif (c >= 'A' && c <= 'F')
28a66f ииииreturn (c - 'A' + 10);
c712d4 ииreturn (-1);
2eefe6 }
85af5a
46af5a
ed4579 int hex2bin(char *hex, unsigned char *bin) {
53c22f ииint i = 0;
876a41 ииint j = 0;
efaf5a
598ef6 ии/* Trim string if comments present */
b08b28 ииif (strchr(hex, '#') != NULL)
c252e6 ииии*strchr(hex, '#') = 0;
1ba3ed ииif (strchr(hex, '*') != NULL)
7760d1 ииии*strchr(hex, '*') = 0;
e7a6e5 ииif (strchr(hex, '\'') != NULL)
7c2462 ииии*strchr(hex, '\'') = 0;
abaf5a
5a1f4a ииfor (i = 0; i < strlen(hex); i++) {
6a8e69 ииииif (hex[i] >= '0' && unhex(hex[i]) < 0)
fed278 ииииииEXIT_ERR("Bad hex digit encountered.\n");

09df1c ии}
4baf5a
4f1f4a ииfor (i = 0; i < strlen(hex); i++) {
c1f5b0 ииииif (hex[i] < '0')
2f5f6a ииииииcontinue;
26643e ииииif (hex[i] >= '0' && hex[i+1] >= '0') {
567935 ииииииbin[j++] = unhex(hex[i])*16+unhex(hex[i+1]);
dbc028 ииииииi++; иии// skip one

195f6a ииииииcontinue;
8b6fe7 ииии}
3fe16f ииииif (hex[i] >= '0') {
a78539 ииииииbin[j++] = unhex(hex[i]);
ea6fe7 ииии}
efdf1c ии}
68c1d2 ииreturn (j);
5defe6 }
--3c7b 0014804ceb88004000b Page 4 of misc.c
e0af5a
1aaf5a
027b71 void printHexString(char *tag, unsigned char *data, int len) {
aa17e0 ииint i;
20af5a
469650 ииprintf("%s", tag);
526c12 ииfor (i = 0; i < len; i++)
21cd57 ииииprintf("%02X", data[i]);
bafee8 ииprintf("\n");
b6efe6 }
48af5a
--77c4 001029468fd8004000c Page 1 of misc.h
e0af5a
32c502 void GetUserInfo(unsigned char plaintextVector[32],и
6657e7 ииииииииunsigned char plaintextXorMask[8],и
e5910f ииииииииunsigned char ciphertext0[8], unsigned char ciphertext[8],
4c446e ииииииииunsigned char *plaintextByteMask, int *useCBC, int *extraXor,
25e00d ииииииииint *quickStart, unsigned char startKey[7], long *numClocks);
560986 void increment32(unsigned char *v);
edb70b void decrement32(unsigned char *v);

4cf314 void desDecrypt(unsigned char m[8], unsigned char c[8], unsigned char k[7]);
fea5c5 void printHexString(char *tag, unsigned char *data, int len);
f9560a int hex2bin(char *hex, unsigned char *bin);
02af5a
--91c4 001d95d620a8004000d Page 1 of random.scr
1b9f56 00
4e9ec4 0000000000000000 иии' XOR MASK
c4327c 0000000000000000 иии' Ciphertext 0
892ba4 0000000000000000 иии' Ciphertext 1
918c19 00 иииииииииииииииии' Plaintext byte mask
05ed5e 0 ииииииииииииииииии' use CBC
37d84f 0 ииииииииииииииииии' extra XOR
260627 0 ииииииииииииииииии' random vector (0=seed with timer, 1=use input, >1=seed)
63a481 00000000000000 иииии' starting key
8bd03f 2000 ииииииииииииииии' number of clocks
d9af5a
--0289 000317f111e8004000e Page 1 of ref.c
56feb2 #include <stdio.h>
a1bea3 #include <stdlib.h>
a9c737 #include <memory.h>
79324c #include <string.h>

242bac #include "des.h"
3da50a #include "misc.h"
feaf5a
e7f8b5 #define CLOCKS_PER_DES 18
d8af5a
7a4525 int plaintextMatch(unsigned char plaintextVector[32], unsigned char m[8],
c46e85 ииииииииunsigned char plaintextByteMask, int ciphertext, unsigned char key[7]);
8787d4 void checkKey(unsigned char key[7], unsigned char plaintextVector[32],и
4357e7 ииииииииunsigned char plaintextXorMask[8],и
d31fa8 ииииииииunsigned char ciphertext0[8], unsigned char ciphertext1[8],
7d5e1b ииииииииunsigned char plaintextByteMask, int useCBC, int extraXor);
64af5a
57a2c4 void main(void) {
2b7ab8 ииunsigned char startKey[7], plaintextVector[32];
776f32 ииunsigned char plaintextXorMask[8];
01ed17 ииunsigned char ciphertext0[8];
52e93c ииunsigned char ciphertext1[8];
37b1b4 ииunsigned char plaintextByteMask;
36c9d8 ииint useCBC, extraXor, quickStart;
38e13a ииint i,j;
948520 ииlong numClocks;
ac5ec8 ииunsigned char key[7];
d7af5a
8a50e3 ииGetUserInfo(plaintextVector, plaintextXorMask, ciphertext0, ciphertext1,и
8fd756 ииииииииии&plaintextByteMask, &useCBC, &extraXor, &quickStart, startKey,
47ab3c ииииииииии&numClocks);
2aaf5a

7fee44 ииfor (i = 0; i < numClocks; i += CLOCKS_PER_DES) {
dea2d3 ииииfor (j = 0; j < 24; j++) {
22beb4 ииииииmemcpy(key, startKey, 8);
08c578 ииииииkey[0] += j;
ab91ec ииииииcheckKey(key, plaintextVector, plaintextXorMask, ciphertext0,и
5320a7 ииииииииииciphertext1, plaintextByteMask, useCBC, extraXor);
3e6fe7 ииии}
71ddad ииииincrement32(startKey+3);
96df1c ии}
aeefe6 }
8caf5a
00af5a
d287d4 void checkKey(unsigned char key[7], unsigned char plaintextVector[32],и
5c57e7 ииииииииunsigned char plaintextXorMask[8],и
381fa8 ииииииииunsigned char ciphertext0[8], unsigned char ciphertext1[8],
5f4479 ииииииииunsigned char plaintextByteMask, int useCBC, int extraXor) {
3c0a0b ииunsigned char m[8];
1417e0 ииint i;
d4af5a
a4f09d ииdesDecrypt(m, ciphertext0, key);
26835d ииprintf("DES_decrypt(K="); for (i = 0; i < 7; i++) printf("%02X", key[i]);и
188cf0 ииprintf(", C0="); for (i = 0; i < 8; i++) printf("%02X", ciphertext0[i]);
d849c7 ииprintf(") -> "); for (i = 0; i < 8; i++) printf("%02X", m[i]); printf("\n");
24667c ииif (extraXor) {
0bd985 ииииm[0] ^= m[4];
db406b ииииm[1] ^= m[5];
f2e248 ииииm[2] ^= m[6];
607ba6 ииииm[3] ^= m[7];
7cdf1c ии}
bb1f76 ииfor (i = 0; i < 8; i++)
45e88c ииииm[i] ^= plaintextXorMask[i];
17af5a
c64534 ииif (plaintextMatch(plaintextVector, m, plaintextByteMask, 0, key)) {
b53498 ииииdesDecrypt(m, ciphertext1, key);
96553a ииииprintf("DES_decrypt(K="); for (i = 0; i < 7; i++) printf("%02X", key[i]);и
6dda88 ииииprintf(", C1="); for (i = 0; i < 8; i++) printf("%02X", ciphertext1[i]);
ead221 ииииprintf(") -> "); for (i = 0; i < 8; i++) printf("%02X", m[i]); printf("\n");
37952a ииииif (extraXor) {
af2ad3 ииииииm[0] ^= m[4];
b6b33d ииииииm[1] ^= m[5];
31111e ииииииm[2] ^= m[6];
--62a0 0018ac4c1498004000e Page 2 of ref.c
4c88f0 ииииииm[3] ^= m[7];
5b6fe7 ииии}
5b662a ииииif (useCBC) {

429494 ииииииfor (i = 0; i < 8; i++)
e1f3f9 ииииииииm[i] ^= ciphertext0[i];
2b6fe7 ииии}
10e5be ииииif (plaintextMatch(plaintextVector, m, plaintextByteMask, 1, key)) {
5246ff ииииииprintf("------- VALID MATCH--------\n");

059a8a ииииииfprintf(stderr, "Match found at key =");
c22526 ииииииfor (i = 0; i < 7; i++)
3f44d0 ииииииииfprintf(stderr, "%02X", key[i]);
0f5501 ииииииfprintf(stderr, "\n");
736fe7 ииии}
6adf1c ии}
19efe6 }
81af5a
01af5a
004525 int plaintextMatch(unsigned char plaintextVector[32], unsigned char m[8],
8aa762 иииииииunsigned char plaintextByteMask, int ciphertext, unsigned char key[7]) {
b817e0 ииint i;
f0af5a
068715 ииfor (i = 0; i < 8; i++) {
c585ef ииииif ((plaintextByteMask & (128>>i)) == 1)
388e03 ииииииcontinue; ии/* this byte is skipped */
b98ec8 ииииif (plaintextVector[m[i]/8] & (128 >> (m[i]%8)))
d65f6a ииииииcontinue;
854210 ииииreturn (0); ииииииииии/* no match */
13df1c ии}
ceaf5a
957381 ииprintf("Match of C%d with key ", ciphertext);
2daec4 ииfor (i = 0; i < 7; i++)
80dac3 ииииprintf("%02X", key[i]);
b461e2 ииprintf(" = ");
021f76 ииfor (i = 0; i < 8; i++)

6511eb ииииprintf("%02X", m[i]);
b7fee8 ииprintf("\n");
93af5a
35ec77 ииfprintf(stderr, "Match of C%d with key ", ciphertext);
bdaec4 ииfor (i = 0; i < 7; i++)
5fedd0 ииииfprintf(stderr, "%02X", key[i]);
d29064 ииfprintf(stderr, " = ");
371f76 ииfor (i = 0; i < 8; i++)
d7651e ииииfprintf(stderr, "%02X", m[i]);
96c77e ииfprintf(stderr, "\n");
10af5a
e0d4d1 ииreturn (1);
d9efe6 }
a1af5a
8aaf5a
--c93c 000f4b51cf08004000f Page 1 of sim.c
8d2d03 /*****************************************************************************
0833b1 и* sim.c ииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии*
b33dcc и* иииииииииииииииииSoftware Simulator for DES keysearch ASIC иииииииииииииии*
6a29eb и* ииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии*
4509fc и* иииWritten 1998 by Cryptography Research (http://www.cryptography.com) иии*
5f8aaf и* ииииииand Paul Kocher for the Electronic Frontier Foundation (EFF). ииииии*
38caeb и* ииииииPlaced in the public domain by Cryptography Research and EFF. ииииии*
f74992 и* иTHIS IS UNSUPPORTED FREE SOFTWARE. USE AND DISTRIBUTE AT YOUR OWN RISK. и*
c129eb и* ииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии*
66c755 и* иIMPORTANT: U.S. LAW MAY REGULATE THE USE AND/OR EXPORT OF THIS PROGRAM. и*
8129eb и* ииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии*
fb489b и*****************************************************************************
a729eb и* ииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии*
126eef и* ииREVISION HISTORY: ииииииииииииииииииииииииииииииииииииииииииииииииииииии*
e329eb и* ииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии*
d97744 и* ииVersion 1.0: иInitial version. иииииииииииииииииииииииииииииииииииииииии*
4fbaf4 и* ииVersion 1.1: иInitial release by Cryptography Research to EFF. иииииииии*
6ce429 и* ииииииииииииииии(Fixed byte/bit ordering notation to match VHDL.) ииииииии*
3a29eb и* ииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии*
74d8c3 и*****************************************************************************/
9daf5a
33feb2 #include <stdio.h>
b5bea3 #include <stdlib.h>
b8c737 #include <memory.h>
80324c #include <string.h>
e72bac #include "des.h"
2fbd71 #include "sim.h"
0aaf5a
b051c3 #define DEBUG
d6af5a
67a99d long getClockCounter(void);
54b42e int peekState(int addr);
1d7608 int RunChip(char *input, FILE *outfile, int useRaw);
2aaf5a
28708e static void EXIT_ERR(char *s) { fprintf(stderr, s); exit(1); }
62725e static void parseInput(char *input, int *reset, int *boardEn, int *ale,
7f8541 ииииииииint *adrsel1, int *web, int *rdb, int *adrsel2, int *allactIn,
a060c4 ииииииииint *addr, int *chipId, int *data);
bb79bd static int unhex(char c);
9bf453 static void RunClock(void);
f9d39e static void desDecrypt(unsigned char m[8], unsigned char c[8],
753286 ииииииииunsigned char k[7]);
a2acca static void increment32(unsigned char *num);
91cc8b static void decrement32(unsigned char *num);

b8b1ae static void printKeyInfo(FILE *outDev, char *preamble, int searchUnit);
31af5a
34ec7c static unsigned char ALLACTIVE_IN = 1; ииииииииииии/* not held between calls */
0dfec4 unsigned char ALLACTIVE_OUT иииии= 0;
40af5a
6ee4e3 unsigned char STATE[256];
41e3e4 unsigned char SELECTED_CHIP;
710ab3 иииииииииlong CLOCK_COUNTER = 1;
cc8af3 ииииииииииint DES_POSITION;
0c913b unsigned char WORKING_CTXT[24*8]; иииииииии/* last DES input ииииииииииииииии*/
538181 unsigned char WORKING_PTXT[24*8]; иииииииии/* last DES out (for ptxt check) и*/
c053df unsigned char RAW_DES_OUT[24*8]; ииииииииии/* raw DES outputs иииииииииииииии*/
daa765 int ииииииииииWORKING_KDELTA[24]; иииииииии/* key delta (-1, 0, or +1) ииииии*/
533efd unsigned char WORKING_LAST_SELECTOR[24]; ии/* last ciphertext selector ииииии*/
4ce4be unsigned char WORKING_NEXT_SELECTOR[24]; ии/* next ciphertext selector ииииии*/
689e18 ииииииииииint STARTUP_DELAY[24]; ииииииииии/* startup delay иииииииииииииииии*/
24f67e unsigned char THIS_KEY[24*7]; иииииииииииии/* current DES key иииииииииииииии*/
d35f18 unsigned char NEXT_KEY[24*7]; иииииииииииии/* next DES key ииииииииииииииииии*/
1c11b6 иииииииииint иPENDING_UPDATE_ADDR1 = -1, PENDING_UPDATE_DATA1 = -1;
cb8c2d иииииииииint иPENDING_UPDATE_ADDR2 = -1, PENDING_UPDATE_DATA2 = -1;
3300ab иииииииииint иPENDING_UPDATE_ADDR3 = -1, PENDING_UPDATE_DATA3 = -1;
17c6c2 unsigned char MATCH[24];
23af5a
11af5a
d1af5a
b1a885 static void resetChip(void) {
1aab8b ииmemset(STATE, 0, sizeof(STATE)); иииииииииииииииииииииииииииииииии/* RESET */
f46530 ииSELECTED_CHIP = 0;
--ba12 0009cc27d6a8004000f Page 2 of sim.c
417126 ииDES_POSITION = 13;
9fa8d9 ииmemset(WORKING_CTXT, 0, sizeof(WORKING_CTXT));
e2ae80 ииmemset(WORKING_PTXT, 0, sizeof(WORKING_PTXT));
b5afb1 ииmemset(RAW_DES_OUT, 0, sizeof(RAW_DES_OUT));
677ba0 ииmemset(WORKING_KDELTA, 0, sizeof(WORKING_KDELTA));
c1e6c6 ииmemset(WORKING_LAST_SELECTOR, 1, sizeof(WORKING_LAST_SELECTOR));
c48102 ииmemset(WORKING_NEXT_SELECTOR, 1, sizeof(WORKING_NEXT_SELECTOR));
699bcb ииmemset(STARTUP_DELAY, 0, sizeof(STARTUP_DELAY));
8f3fe2 ииmemset(THIS_KEY, 0, sizeof(THIS_KEY));
849161 ииmemset(NEXT_KEY, 0, sizeof(NEXT_KEY));
850ce5 ииPENDING_UPDATE_ADDR1 = -1;
c98635 ииPENDING_UPDATE_ADDR2 = -1;
28078a ииPENDING_UPDATE_ADDR3 = -1;
4f19ae ииmemset(MATCH, 0, sizeof(MATCH));
49efe6 }
52af5a
04af5a
51a5b0 long getClockCounter(void) {
8eb11d ииreturn (CLOCK_COUNTER);
7eefe6 }
85af5a
98af5a
5f22bd int peekState(int addr) {
c69e96 ииreturn (STATE[addr]);
78efe6 }
c0af5a
7caf5a
66664b int RunChip(char *input, FILE *outfile, int useRaw) {
686c17 ииint reset,boardEn,ale,adrsel1,web,rdb,adrsel2,allactiveIn,addr,chipId,data;
ef86d5 ииint dataOut;
41e13a ииint i,j;
6eaf5a
75261a ииparseInput(input, &reset, &boardEn, &ale, &adrsel1, &web, &rdb, &adrsel2,

29b7df ииииииииии&allactiveIn, &addr, &chipId, &data);
4e7493 ииALLACTIVE_IN = (unsigned char)allactiveIn;
30af5a
183f21 ииdataOut = data; ииииииииииииииииииииииииииииииииииииииииииииииии/* default */
9d58d6 ииif (reset == 0) { иииииииииииииииииииииииииииииииииииииииииииииии/* reset? */
54b64f ииииresetChip();
a281d3 ииииRunClock();
129dff ии} else if (boardEn == 0) { иииииииииииииииииииииииииииии/* board disabled? */
5581d3 ииииRunClock();
3cbc66 ии} else if (ale == 1) { иииииииииииииииииииииииииииииии/* select chip/board */
0081d3 ииииRunClock();
fa6af8 ииииif (adrsel1 == 1)
bb80de ииииииSELECTED_CHIP = (unsigned char)addr;
90842c ииииelse
21294b ииииии{ /* board select done off-chip */ }
7302c3 ии} else if (chipId != SELECTED_CHIP) { иииииииииииииииии/* chipId not ours? */
8781d3 ииииRunClock();
66d581 ии} else if (web == 0) { иииииииииииииииииииииииииииииии/* writing register? */
df81d3 ииииRunClock();
ebb10b ииииif (addr >= REG_SEARCH_KEY(0)) {
7b50c6 ииииииPENDING_UPDATE_ADDR2 = addr; иииииииииииииииииииииииииииииииииии/* key */
3bda60 ииииииPENDING_UPDATE_DATA2 = data;
b64b08 ииииииif (((addr & 7) == 7) && (data & 1) && ((STATE[addr] & 1) == 0)) {
2b22fc ииииииииif (CLOCK_COUNTER < 750)
33d675 ииииииииииSTARTUP_DELAY[(addr - 0x47) / 8] = 21; иииииииииииииииии/* adjust? */
f805d7 ииииииииelse {
c78561 ииииииииииSTARTUP_DELAY[(addr - 0x47) / 8] = 2*CLOCKS_PER_DES - DES_POSITION;
44c934 ииииииииииif (DES_POSITION >= 15)
b2a6a3 ииииииииииииSTARTUP_DELAY[(addr - 0x47) / 8] += CLOCKS_PER_DES;
59e0f6 #if 0 иииииииииииииииииииииииииии/* uncomment for debugging message on halts */
143237 ииииииииииfprintf(stderr,"Startup with DES_POSITION=%d in unit %d, delay=%d\n",
545d8e ииииииииииииииииDES_POSITION, (addr-0x47)/8, STARTUP_DELAY[(addr - 0x47) / 8]);
977454 #endif
be7fb0 ииииииии}
7342cc ииииии}
056a79 ииии} else {
a6b05a ииииииPENDING_UPDATE_ADDR2 = addr; иииииииииииииииииииииииииииии/* other reg */
f5da60 ииииииPENDING_UPDATE_DATA2 = data;
9c6fe7 ииии}
--eb12 000b9c238be8004000f Page 3 of sim.c
5be4b8 ии} else if (rdb == 0) { иииииииииииииииииииииииииииииииии/* read a register */
e34a99 ииииdataOut = STATE[addr];
2e81d3 ииииRunClock();
1249d8 ии} else {
8981d3 ииииRunClock();
fadf1c ии}
eaaf5a
671c5c ииif (CLOCK_COUNTER >= 2) {
123cea ииииif (useRaw) {
e1a3f4 ииииииfprintf(outfile, "%02X %d\n", dataOut, ALLACTIVE_OUT);
9c6a79 ииии} else {
fe2044 ииииииfprintf(outfile, " (Addr: %02X) и(Exp: 00) (Get: %02X) at Cycle:%ld\n",
e9f86f ииииииииииииииaddr, dataOut, CLOCK_COUNTER);

01457c ииииииfor (i = 0; i < 24; i++) {
31e69a ииииииииfor (j = 6; j >= 0; j--)


ff590a ииииииииииfprintf(outfile, "%02X", STATE[REG_SEARCH_KEY(i)+j]);
91798f ииииииииfprintf(outfile, " ");
35555b ииииииииif (CLOCK_COUNTER < 22)
78dc93 ииииииииииfprintf(outfile, "0000000000000000");
fe00e6 ииииииииelse if (CLOCK_COUNTER <= 37)
3054ea ииииииииииfprintf(outfile, "094CCE83D677160F");
8305d7 ииииииииelse {
a8dcd6 ииииииииииfor (j = 7; j >= 0; j--)

5cad27 ииииииииииииfprintf(outfile, "%02X", RAW_DES_OUT[8*i+j]);
387fb0 ииииииии}
9978b2 #if 0 иииииииииииииииииииии/* uncomment to print information about the MATCH */
c42b60 ииииииии{
451685 ииииииииииstatic int latch[24]={0,0,0,0,0,0,0,0,0,0,0,0,0,0,
4515b3 ииииииииииииииииииииииииииииииии0,0,0,0,0,0,0,0,0,0};
c2132c ииииииииииif (DES_POSITION==10) latch[i] = MATCH[i];
a6ab83 ииииииииииfprintf(outfile, " %d", latch[i]);
ad7fb0 ииииииии}
b67454 #endif
2ca770 #if 0 иииииииииииииииии/* uncomment to print information about NEXT_SELECTOR */
a32b60 ииииииии{
c51fc2 ииииииииииstatic int latch[24]={1,1,1,1,1,1,1,1,1,1,1,1,1,1,
2c5bf8 ииииииииииииииииииииииииииииииии1,1,1,1,1,1,1,1,1,1};
298e7e ииииииииииif (DES_POSITION==15) latch[i] = WORKING_NEXT_SELECTOR[i];
1a4ad8 ииииииииииfprintf(outfile, "%d", latch[i]);
8f7fb0 ииииииии}
017454 #endif
3767a5 ииииииииfprintf(outfile, " : Unit%d\n", i);
6a42cc ииииии}
22b96e ииииииfprintf(outfile, "\n");
e86fe7 ииии}
23df1c ии}
a3755d ииCLOCK_COUNTER++;
f75593 ииreturn (dataOut);
0cefe6 }
d7af5a
e7af5a
d4725e static void parseInput(char *input, int *reset, int *boardEn, int *ale,
ce8541 ииииииииint *adrsel1, int *web, int *rdb, int *adrsel2, int *allactIn,

746a3d ииииииииint *addr, int *chipId, int *data) {
a117e0 ииint i;
47af5a
c69eb9 ииif (strlen(input) < 17 || input[8]!=' ' || input[11]!=' ' || input[14]!=' ')
ccda15 иииииEXIT_ERR("Bad input.\n");

558715 ииfor (i = 0; i < 8; i++) {
c1c3f7 ииииif (input[i] != '0' && input[i] != '1')
93b045 ииииииEXIT_ERR("Bad input (first 8 digits must be binary.)\n");
c1df1c ии}
38b959 ииif (unhex(input[9]) < 0 || unhex(input[10]) < 0 ||
70bbf9 ииииииииunhex(input[12]) < 0 || unhex(input[13]) < 0 ||
6401b9 ииииииииunhex(input[15]) < 0 || unhex(input[16]) < 0) {
78422f ииииEXIT_ERR("Bad input (addr, chipId, data must be hex)");
fddf1c ии}
d4af5a
958f00 ии*reset иии= input[0]-'0';
4a25a2 ии*boardEn и= input[1]-'0';
7c660a ии*ale иииии= input[2]-'0';
b92dfa ии*adrsel1 и= input[3]-'0';
--9ad7 00064eb0a748004000f Page 4 of sim.c
48111b ии*web иииии= input[4]-'0';
71de77 ии*rdb иииии= input[5]-'0';
060751 ии*adrsel2 и= input[6]-'0';
c1d2b3 ии*allactIn = input[7]-'0';
449a0b ии*addr ииии= 16*unhex(input[9]) + unhex(input[10]);
3842c3 ии*chipId ии= 16*unhex(input[12]) + unhex(input[13]);
2d9e2a ии*data ииии= 16*unhex(input[15]) + unhex(input[16]);
0fefe6 }
c0af5a
0caf5a
62d93f /* Decodes a hex char or returns -1 if bad. */
8d8462 static int unhex(char c) {
6b53c4 ииif (c >= '0' && c <= '9')
f203d6 ииииreturn (c - '0');
2f8db1 ииif (c >= 'a' && c <= 'f')
3f0ada ииииreturn (c - 'a' + 10);
a149e3 ииif (c >= 'A' && c <= 'F')
86a66f ииииreturn (c - 'A' + 10);
0f12d4 ииreturn (-1);
95efe6 }
f4af5a
7baf5a
1baf5a
4f38e5 /*
dea850 и* ииRun the system for one clock cycle and update the state.
89495d и*/
4442ee void RunClock(void) {
5c6275 ииint i,j,k,b;
dd470b ииunsigned char key[7], m[8], c[8];
77af5a
9c9101 ииfor (i = 0; i < 24; i++) {
84543c ииииif (STARTUP_DELAY[i] > 0) {
604f54 ииииииSTARTUP_DELAY[i]--;
3a4600 ииииииif (STARTUP_DELAY[i] == 0)
340ea6 ииииииииSTARTUP_DELAY[i] = -1; ииииииииииииии/* prevent stop if 1st C0=match */
8e6fe7 ииии}
76df1c ии}
14af5a
586df4 ии/* DES CLOCK 5: Plaintext vector result from last DES is ready. */
e94ae1 ииif (DES_POSITION == 5) {
8e23cf ииииfor (i = 0; i < 24; i++) { ииииииииииииии/* i = search engine иииииииииии*/
c6d1c1 ииииииk = 0; ииииииииииииииииииииииииииииииии/* k = result of byte lookups ии*/
bd642b ииииииfor (j = 0; j < 8; j++) { иииииииииииии/* j = byte idx ииииииииииииииии*/
a0178a ииииииииb = WORKING_PTXT[8*i+j]; ииииииииииии/* b = byte value ииииииииииииии*/
c9fb5d ииииииииif (STATE[b/8] & (1 << (b%8))) ииииии/* check plaintext vector ииииии*/
ce346c ииииииииииk = (k >> 1) | 128; иииииииииииииии/* ииmatch = load 1 in k msb иии*/
1e359e ииииииииelse ииииииииииииииииииииииииииииииии/* иииииииииииииииииииииииииииии*/
f40eb7 ииииииииииk = (k >> 1) | 0; иииииииииииииииии/* ииno match = load 0 into k ии*/
a042cc ииииии}
f83f33 ииииииk |= STATE[REG_PTXT_BYTE_MASK]; иииииии/* set bits where bytemask=1 иии*/
b11a90 ииииииMATCH[i] = (unsigned char)((k == 255) ? 1 : 0);

f1af5a
dd663d ииииииif ((STATE[REG_SEARCH_STATUS(i)] & 1) == 0 || STARTUP_DELAY[i] > 0) {
b9b83a ииииииии/* If search not active, key delta = 0 and do C0 next */
e3472c ииииииииWORKING_KDELTA[i] = 0;
dfe9d7 ииииииииWORKING_NEXT_SELECTOR[i] = 1;
0f373c ииииии} else if (k != 0xFF || (STATE[REG_SEARCH_STATUS(i)] & 2) ||
4b09fe ииииииииииииииSTARTUP_DELAY[i] < 0) {
28e722 ииииииии/* If no match or CURRENTLY doing C1 or first DES result,
3da57c иииииииии* ииииkey delta = 1 and do C0 next.
a05af3 иииииииии*/

701df0 ииииииииWORKING_KDELTA[i] = 1;
8bb30b ииииииииWORKING_NEXT_SELECTOR[i] = 0;
cad29b ииииииииif (k==0xFF)
de670b ииииииииииprintKeyInfo(stderr, "ALERT: Skip match while doing C1 ", i);
ee2e47 ииииииииif (k == 0xFF && STARTUP_DELAY[i] < 0)
9b3369 ииииииииииprintKeyInfo(stderr, "ALERT: иии(C1 above is startup phantom.)", i);
2869ea ииииии} else if (WORKING_LAST_SELECTOR[i] == 0) {
d2b8e7 ииииииии/* If doing C0 and got a match from C0, back up and do C1 */
ced05d ииииииииWORKING_KDELTA[i] = -1;
4ae9d7 ииииииииWORKING_NEXT_SELECTOR[i] = 1;

648f35 ииииииииprintKeyInfo(stderr, "ALERT: Match C0; will backup for C1 ", i);
--0c27 000479329b38004000f Page 5 of sim.c
6ccfc7 ииииии} else {
8a2ce9 ииииииии/* If doing C0 and got a match from C1, halt */
b22aaa ииииииииSTATE[REG_SEARCH_STATUS(i)] &= (255-1);
62472c ииииииииWORKING_KDELTA[i] = 0;
1be9d7 ииииииииWORKING_NEXT_SELECTOR[i] = 1;
dd98d4 ииииииииprintKeyInfo(stderr, "ALERT: Matched C1; halting ", i);
ea42cc ииииии}
8eb3e1 ииииииif (STARTUP_DELAY[i] < 0)
5ece10 ииииииииSTARTUP_DELAY[i]++;
326fe7 ииии}
cedf1c ии}
aeaf5a
c03071 ииif (DES_POSITION == 15) {
fa2135 ииииfor (i = 0; i < 24; i++) {
ccc53f ииииииmemcpy(THIS_KEY+i*7, NEXT_KEY+i*7, 7);
ef7e92 ииииииmemcpy(NEXT_KEY+i*7, STATE+REG_SEARCH_KEY(i), 7);
136fe7 ииии}
8adf1c ии}
d0af5a
018fcd ии/* END OF DES CYCLE: Extract results */
77ea42 ииif (DES_POSITION == CLOCKS_PER_DES-1) {
6b2135 ииииfor (i = 0; i < 24; i++) {
7aaf5a
d9c284 ииииии/* Do the DES decryption */
8502ce ииииииfor (j = 0; j < 7; j++)
9e22c0 ииииииииkey[j] = THIS_KEY[i*7+(6-j)];
77b37c ииииииfor (j = 0; j < 8; j++)

a3ccfb ииииииииc[j] = WORKING_CTXT[8*i+7-j];
0d481f ииииииdesDecrypt(m, c, key);
481503 ииииииfor (j = 0; j < 8; j++) {
7d3bd1 ииииииииWORKING_PTXT[8*i+7-j] = m[j];
a60d03 ииииииииRAW_DES_OUT[8*i+7-j] = m[j];
b042cc ииииии}
20af5a
84b9ef ииииииif (STATE[REG_SEARCHINFO] & 2) { ииииииииииииииииииии/* if extraXOR иии*/
025020 ииииииииWORKING_PTXT[8*i+4] ^= WORKING_PTXT[8*i+0]; иииииии/* иииL = L xor R */
fe6d21 ииииииииWORKING_PTXT[8*i+5] ^= WORKING_PTXT[8*i+1]; иииииии/* иииии" ииииииии*/
ceada9 ииииииииWORKING_PTXT[8*i+6] ^= WORKING_PTXT[8*i+2]; иииииии/* иииии" ииииииии*/
6615de ииииииииWORKING_PTXT[8*i+7] ^= WORKING_PTXT[8*i+3]; иииииии/* иииии" ииииииии*/
1542cc ииииии}
ea89a7 ииииииif ((STATE[REG_SEARCH_STATUS(i)] & 2) == 0) { ииииииии/* if c0, иииииии*/
cd6b8a ииииииииWORKING_PTXT[8*i+0] ^= STATE[REG_PTXT_XOR_MASK+0]; и/* do ptxtXorMsk */
265511 ииииииииWORKING_PTXT[8*i+1] ^= STATE[REG_PTXT_XOR_MASK+1]; и/* иииии" иииииии*/
6800b2 ииииииииWORKING_PTXT[8*i+2] ^= STATE[REG_PTXT_XOR_MASK+2]; и/* иииии" иииииии*/
78cbdc ииииииииWORKING_PTXT[8*i+3] ^= STATE[REG_PTXT_XOR_MASK+3]; и/* иииии" иииииии*/
3aabf4 ииииииииWORKING_PTXT[8*i+4] ^= STATE[REG_PTXT_XOR_MASK+4]; и/* иииии" иииииии*/
36609a ииииииииWORKING_PTXT[8*i+5] ^= STATE[REG_PTXT_XOR_MASK+5]; и/* иииии" иииииии*/
353539 ииииииииWORKING_PTXT[8*i+6] ^= STATE[REG_PTXT_XOR_MASK+6]; и/* иииии" иииииии*/
5f3c97 ииииииииWORKING_PTXT[8*i+7] ^= STATE[REG_PTXT_XOR_MASK+7];
4d5d4c ииииии} else { иииииииииииииииииииииииииииииииииииииииииииии/* if c1 ииииииии*/
9afc9c ииииииииif (STATE[REG_SEARCHINFO] & 1) { иииииииииииииииииии/* if useCBC ииии*/
b784fd ииииииииииWORKING_PTXT[8*i+0] ^= STATE[REG_CIPHERTEXT0+0]; и/* xor with c0 ии*/
8c4de8 ииииииииииWORKING_PTXT[8*i+1] ^= STATE[REG_CIPHERTEXT0+1]; и/* иииии" иииииии*/
3605d1 ииииииииииWORKING_PTXT[8*i+2] ^= STATE[REG_CIPHERTEXT0+2]; и/* иииии" иииииии*/
dcc5c9 ииииииииииWORKING_PTXT[8*i+3] ^= STATE[REG_CIPHERTEXT0+3]; и/* иииии" иииииии*/
8995a3 ииииииииииWORKING_PTXT[8*i+4] ^= STATE[REG_CIPHERTEXT0+4]; и/* иииии" иииииии*/
6c55bb ииииииииииWORKING_PTXT[8*i+5] ^= STATE[REG_CIPHERTEXT0+5]; и/* иииии" иииииии*/
811d82 ииииииииииWORKING_PTXT[8*i+6] ^= STATE[REG_CIPHERTEXT0+6]; и/* иииии" иииииии*/
33dd9a ииииииииииWORKING_PTXT[8*i+7] ^= STATE[REG_CIPHERTEXT0+7]; и/* иииии" иииииии*/
637fb0 ииииииии}
e942cc ииииии}
1aaf5a
e370b8 ииииии/* Update ciphertext selector (state & last) */
569701 ииииииWORKING_LAST_SELECTOR[i] = (STATE[0x47+8*i] & 2) ? 1 : 0;
5ad73b ииииииSTATE[0x47+8*i] &= 0xFD; иииииииииииииииииииии/* select ciphertext 0 ии*/
25abd6 ииииииif (WORKING_NEXT_SELECTOR[i]) ииииииииииииииии/* ... unless we want c1 */
8e98a9 ииииииииSTATE[0x47+8*i] |= 2; ииииииииииииииииииииии/* ... then select c1 иии*/
206fe7 ииии}
1ddf1c ии}
a1af5a
80cda8 ии/* LAST DES CLOCK: Load in the updated key */
473b35 ииif (DES_POSITION == 14) {
--4c9a 0007dd476568004000f Page 6 of sim.c
e02135 ииииfor (i = 0; i < 24; i++) {
b45d9d ииииииif (WORKING_KDELTA[i] == 1) { иииииииииииииииииии/* ииif key delta = 1 */
635981 ииииииииincrement32(STATE+REG_SEARCH_KEY(i));
4242cc ииииии}
a6f8e9 ииииииif (WORKING_KDELTA[i] == -1) { иииииииииииииииии/* ииif key delta = -1 */
e80a03 ииииииииdecrement32(STATE+REG_SEARCH_KEY(i));

0a42cc ииииии}
406fe7 ииии}
dedf1c ии}
d1af5a
a964de ии/* DES CLOCK 0: Latch in new working keys and working ciphertexts */
5c6cb5 ииif (DES_POSITION == 0) {
f70d66 ииииfor (i = 0; i < 24; i++) { иииииииииииииииииииииииии/* i = search engine */
34dbbd ииииии/* pick between ctxt 0 and ctxt 1? */
d38aeb ииииииif ((STATE[REG_SEARCH_STATUS(i)] & 2) == 0 && STARTUP_DELAY[i] == 0)
b7afe2 ииииииииmemcpy(WORKING_CTXT+8*i, STATE+REG_CIPHERTEXT0, 8); ииииии/* copy c0 */
f13dfa ииииииelse
4ff6ee ииииииииmemcpy(WORKING_CTXT+8*i, STATE+REG_CIPHERTEXT1, 8); ииииии/* copy c1 */
1a6fe7 ииии}
eedf1c ии}
0faf5a
c82d95 ии/* Update ChipAllActive, board all active */
57519a ииj = 1;
a763d6 ииfor (i = 0; i < 24; i++)
bd9656 ииииj &= STATE[0x47+i*8];
455974 ииj = (j & 1) ? 1 : 0;
fefe54 ииSTATE[REG_SEARCHINFO] &= (255-4); иииииии/* set ChipAllActive иииииииииииии*/

e632f7 ииSTATE[REG_SEARCHINFO] |= (4*j); иииииииии/* иии" ииииииииииииииииииииииииии*/
95fdfb ииif ((STATE[REG_SEARCHINFO] & 16) == 0) ии/* If board all active enable = 0 */
3b3c9d ииииALLACTIVE_OUT = ALLACTIVE_IN;
051bd0 ииelse
b33a4d ииииALLACTIVE_OUT = ALLACTIVE_IN & j;

045e2a ииSTATE[REG_SEARCHINFO] &= (255-8); иииииииииииииииии/* set board all active */
5c7b9a ииSTATE[REG_SEARCHINFO] |= (8*ALLACTIVE_OUT); иииииии/* set board all active */
71af5a
b34cd8 ии/* Do any pending updates and update DES cycle position */
52cfb8 ииif (PENDING_UPDATE_ADDR1 >= 0)
f286c6 ииииSTATE[PENDING_UPDATE_ADDR1] = PENDING_UPDATE_DATA1;
023f74 ииPENDING_UPDATE_ADDR1 = PENDING_UPDATE_ADDR2;
c854a4 ииPENDING_UPDATE_DATA1 = PENDING_UPDATE_DATA2;
9e3a49 ииPENDING_UPDATE_ADDR2 = PENDING_UPDATE_ADDR3;
6a5199 ииPENDING_UPDATE_DATA2 = PENDING_UPDATE_DATA3;
9f078a ииPENDING_UPDATE_ADDR3 = -1;
6cc7f8 ииDES_POSITION = (DES_POSITION + 1) % CLOCKS_PER_DES;
8eefe6 }
c9af5a
a4af5a
34d39e static void desDecrypt(unsigned char m[8], unsigned char c[8],
cc0b79 ииииииииunsigned char k[7]) {
77f65b ииbool key[56], message[64];
5717e0 ииint i;
16af5a
2dd545 #ifdef DEBUG
e060e0 ииprintf("DES_DECRYPT(k="); for (i=0; i<7;i++) printf("%02X",k[i]);
75e4d8 ииprintf(", c="); for (i=0; i<8;i++) printf("%02X",c[i]);
ad7454 #endif
20af5a
9f815b ииfor (i = 0; i < 56; i++)
6e9345 ииииkey[55-i] = ((k[i/8] << (i & 7)) & 128) ? 1 : 0;
8f5c33 ииfor (i = 0; i < 64; i++)
0de5ed ииииmessage[63-i] = ((c[i/8] << (i & 7)) & 128) ? 1 : 0;
c3c59d ииDecryptDES(key, message, message, 0);
be1f76 ииfor (i = 0; i < 8; i++)
4d452e ииииm[i] = 0;
c35c33 ииfor (i = 0; i < 64; i++)
9d7511 ииииif (message[63-i])
42fe29 ииииииm[i/8] |= 128 >> (i%8);
45af5a
72d545 #ifdef DEBUG
ea47c0 ииprintf(")=");
3d17d3 ииfor (i=0; i<8;i++)
7dcdbd ииииprintf("%02X",m[i]);
--a790 001522c46c68004000f Page 7 of sim.c
3bfeb7 ииprintf(", clk=%ld\n",CLOCK_COUNTER);
b87454 #endif
1eaf5a
87efe6 }
97af5a
26af5a
e3af5a
2eaf5a
dba6b0 static void printKeyInfo(FILE *outDev, char *preamble, int searchUnit) {
eac359 ииfprintf(outDev, preamble);
b97d84 ииfprintf(outDev, "(K=%02X%02X%02X%02X%02X%02X%02X, clk=%ld, searchUnit=%d)\n",
d06867 ииииииииииииииииSTATE[0x40+8*searchUnit+6],STATE[0x40+8*searchUnit+5],

9fa184 ииииииииииииииииSTATE[0x40+8*searchUnit+4],STATE[0x40+8*searchUnit+3],
3b1668 ииииииииииииииииSTATE[0x40+8*searchUnit+2],STATE[0x40+8*searchUnit+1],
10ceed ииииииииииииииииSTATE[0x40+8*searchUnit+0], CLOCK_COUNTER, searchUnit);
b3af5a
607332 ииprintf(preamble);
b7f622 ииprintf("(K=%02X%02X%02X%02X%02X%02X%02X, clk=%ld, searchUnit=%d)\n",
e66867 ииииииииииииииииSTATE[0x40+8*searchUnit+6],STATE[0x40+8*searchUnit+5],
f6a184 ииииииииииииииииSTATE[0x40+8*searchUnit+4],STATE[0x40+8*searchUnit+3],
ba1668 ииииииииииииииииSTATE[0x40+8*searchUnit+2],STATE[0x40+8*searchUnit+1],
abceed ииииииииииииииииSTATE[0x40+8*searchUnit+0], CLOCK_COUNTER, searchUnit);
adaf5a
58efe6 }
c0af5a
e6af5a
67838f static void increment32(unsigned char *num) {
68708d ииif ((++(num[0])) == 0)
f2c3c0 ииииif ((++(num[1])) == 0)
0949d0 ииииииif ((++(num[2])) == 0)
7754ed ииииииии++(num[3]);
e7efe6 }
b8af5a
f5af5a
1fd062 static void decrement32(unsigned char *num) {
ded7cb ииif (((num[0])--) == 0)
8334ba ииииif (((num[1])--) == 0)
654eee ииииииif (((num[2])--) == 0)
251e5b ииииииии(num[3])--;
a0efe6 }
44af5a
52af5a

--6ca6 001193e4aa680040010 Page 1 of sim.h

8d2d03 /*****************************************************************************
516967 и* sim.h ииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии*
8c93bc и* иииииииииииииииииииииииииииHeader file for sim.c иииииииииииииииииииииииии*
d629eb и* ииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии*
dd09fc и* иииWritten 1998 by Cryptography Research (http://www.cryptography.com) иии*
708aaf и* ииииииand Paul Kocher for the Electronic Frontier Foundation (EFF). ииииии*
20caeb и* ииииииPlaced in the public domain by Cryptography Research and EFF. ииииии*
784992 и* иTHIS IS UNSUPPORTED FREE SOFTWARE. USE AND DISTRIBUTE AT YOUR OWN RISK. и*
c329eb и* ииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии*
afc755 и* иIMPORTANT: U.S. LAW MAY REGULATE THE USE AND/OR EXPORT OF THIS PROGRAM. и*
0629eb и* ииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии*
eb489b и*****************************************************************************
4629eb и* ииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии*

726eef и* ииREVISION HISTORY: ииииииииииииииииииииииииииииииииииииииииииииииииииииии*
6829eb и* ииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии*
8628d9 и* ииVersion 1.0: иInitial release by Cryptography Research to EFF. иииииииии*
6129eb и* ииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии*
75d8c3 и*****************************************************************************/
a1af5a
2aaf5a
1ac928 #define REG_PTXT_VECTOR иииии(0x00)
f821cd #define REG_PTXT_XOR_MASK иии(0x20)
75b3c1 #define REG_CIPHERTEXT0 иииии(0x28)
5a1752 #define REG_CIPHERTEXT1 иииии(0x30)
74db81 #define REG_PTXT_BYTE_MASK ии(0x38)
39107b #define REG_SEARCHINFO ииииии(0x3F)
b2b9aa #define REG_SEARCH_KEY(x) иии(0x40 + 8*(x))
86701d #define REG_SEARCH_STATUS(x) (0x47+8*(x))
1d60ef #define CLOCKS_PER_DES ииииии16
ebaf5a
bd7608 int RunChip(char *input, FILE *outfile, int useRaw);
7da99d long getClockCounter(void);
5273d4 int peekState(int reg); иииииииииииииииииии/* runs chip & returns DATA value */
19af5a


--dfa5 000a2c967de80040011 Page 1 of testvec.c
8d2d03 /*****************************************************************************
a1132a и* testvec.c ииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии*
8bd58f и* ииииииииииииDES ASIC Simlator, Test Vector Generation Program ииииииииииии*
9429eb и* ииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии*
5409fc и* иииWritten 1998 by Cryptography Research (http://www.cryptography.com) иии*
058aaf и* ииииииand Paul Kocher for the Electronic Frontier Foundation (EFF). ииииии*
71caeb и* ииииииPlaced in the public domain by Cryptography Research and EFF. ииииии*
5e4992 и* иTHIS IS UNSUPPORTED FREE SOFTWARE. USE AND DISTRIBUTE AT YOUR OWN RISK. и*
9529eb и* ииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии*
15c755 и* иIMPORTANT: U.S. LAW MAY REGULATE THE USE AND/OR EXPORT OF THIS PROGRAM. и*
5a29eb и* ииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии*
65489b и*****************************************************************************
b629eb и* ииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии*
d815cb и* ииIMPLEMENTATION NOTES: ииииииииииииииииииииииииииииииииииииииииииииииииии*
8829eb и* ииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии*
53a8b8 и* ииThis program automatically determines the configuration of a search ииии*
521db9 и* ииarray. иAdditional diagnostic code should be added to detect common ииии*
9a87f9 и* ииchip failures (once these are known). ииииииииииииииииииииииииииииииииии*
e029eb и* ииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии*
76489b и*****************************************************************************
6329eb и* ииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии*
566eef и* ииREVISION HISTORY: ииииииииииииииииииииииииииииииииииииииииииииииииииииии*
ba29eb и* ииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии*
a028d9 и* ииVersion 1.0: иInitial release by Cryptography Research to EFF. иииииииии*
5b29eb и* ииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии*
aad8c3 и*****************************************************************************/
a8af5a
d6feb2 #include <stdio.h>
63bea3 #include <stdlib.h>
9fc737 #include <memory.h>
93324c #include <string.h>
1a0a8b #include <time.h>
11bd71 #include "sim.h"
9aaf5a
31decb int USE_RAW_IO = 0;
b0a91d FILE *FILE_TOCHIP, *FILE_FROMCHIP; иииииии/* TOCHIP can be input *or* output */
4fca8d int иCREATING_VECTOR; иииииииииииииииииииии/* reading vs writing TOCHIP file */
3e98dc unsigned char HARDWIRED_CHIP_ID и= 0x3A;
e0af5a
7f583a int ALLACTIVE_IN = 1; ииииииииииииииииииииииииииииии/* gets toggled randomly */
2ce03a int BOARD_EN_IN и= 1; ииииииииииииииииииииии/* input value for run_set/check */
13b9cd int ADRSEL1_IN ии= 1;
36af5a
60af5a
e17897 void GetUserInfo(unsigned char plaintextVector[32],
302461 ииииииииunsigned char plaintextXorMask[8],
90910f ииииииииunsigned char ciphertext0[8], unsigned char ciphertext[8],
b5446e ииииииииunsigned char *plaintextByteMask, int *useCBC, int *extraXor,
7bc016 ииииииииint *randomVector, unsigned char startKey[7], long *totalClocks);
cd1884 void LoadState(unsigned char plaintextVector[32],
fb2461 ииииииииunsigned char plaintextXorMask[8],
481fa8 ииииииииunsigned char ciphertext0[8], unsigned char ciphertext1[8],
d0a024 ииииииииunsigned char plaintextByteMask, int useCBC, int extraXor,
c80ccc ииииииииunsigned char startKey[7]);
511a5e void RunSimulator_SetRegister(int addr, int data);
8b5fd9 unsigned char RunSimulator_CheckRegister(int addr);
80703f void RunSimulator_DummyIO(void);
94708e static void EXIT_ERR(char *s) { fprintf(stderr, s); exit(1); }
ebaf5a
d6f314 void desDecrypt(unsigned char m[8], unsigned char c[8], unsigned char k[7]);
6eabe4 void increment32(unsigned char *num);
42cba5 void decrement32(unsigned char *num);
2d560a int hex2bin(char *hex, unsigned char *bin);
77a5c5 void printHexString(char *tag, unsigned char *data, int len);
33f163 void OpenFiles(char *toChipFilename, char *fromChipFilename, int useRaw);
b2bd55 void printKeyInfo(FILE *outDev, char *preamble, int searchUnit);
65a99d long getClockCounter(void);
8b3363 void proceedNormal(long totalClocks);
c7a6a5 void proceedRandom(void);
caaf5a
11af5a
a238e5 /*

--8051 0009399d7c480040011 Page 2 of testvec.c
4f775e и*
ac775e и*
0ff92c и* ииTHESE FUNCTIONS CREATE AND MANAGE THE TEST VECTORS.
5b775e и*
9a775e и*
81775e и*
2d495d и*/
b6af5a
6daf5a
b179bf void main(int argc, char **argv) {
5a7ab8 ииunsigned char startKey[7], plaintextVector[32];
736f32 ииunsigned char plaintextXorMask[8];
aded17 ииunsigned char ciphertext0[8];
fce93c ииunsigned char ciphertext1[8];
81b1b4 ииunsigned char plaintextByteMask;
5bcc34 ииint useCBC, extraXor, randomVector;
b9f974 ииlong totalClocks;
ac92d0 ииchar buffer[512];
1aaf5a
0796ed ииif (argc != 3 && argc != 4) {
c0795d ииииfprintf(stderr,"Command line: TO_CHIP.OUT FROM_CHIP.OUT [RAW]\n");
5626d6 ииииfprintf(stderr," иTO_CHIP.OUT иииииFile for data going to chip\n");
8134ad ииииfprintf(stderr," ииииииии(If this file exists, it will be simulated.\n");

114f39 ииииfprintf(stderr," ииииииииOtherwise, a new file will be created.)\n");
67803c ииииfprintf(stderr," иFROM_CHIP.OUT иииFile for chip's output\n");
703172 ииииfprintf(stderr," иRAW иииииииииииииGives unix CRLFs & no header.\n");
8b646c ииииexit(1);

37df1c ии}
16af5a
026000 ии/*
802ba4 иии* Open files and set CREATING_VECTOR to:
3369bb иии* ииии0=reading TOCHIP file,
cfdf37 иии* ииии1=create TOCHIP from user input,
7fbbb4 иии* ииии2=create random vector
def9a6 иии*/
18bbf9 ииOpenFiles(argv[1], argv[2], (argc == 4) ? 1 : 0);
a3af5a
97ee0b ииif (CREATING_VECTOR == 0) {
ac50a4 ииииfprintf(stderr, "Using input vector from file.\n");
e6eb83 ииииwhile (1) {

66b843 ииииииif (fgets(buffer, 500, FILE_TOCHIP) == NULL)
a52d5f ииииииииbreak;
01563f ииииииif (strlen(buffer) < 10)
1a2d5f ииииииииbreak;
97f0ee ииииииRunChip(buffer, FILE_FROMCHIP, USE_RAW_IO);
b86fe7 ииии}
4a49d8 ии} else {
89ae2b ииииGetUserInfo(plaintextVector, plaintextXorMask, ciphertext0, ciphertext1,

08828a ииииииииииии&plaintextByteMask, &useCBC, &extraXor, &randomVector, startKey,
f497e4 ииииииииииии&totalClocks);
ac3a38 ииииif (randomVector == 0) {
f635be ииииииfprintf(stderr, "Seed=random (time-based)\n");
b694d0 ииииииsrand((unsigned) time(NULL));
95c26c ииииииHARDWIRED_CHIP_ID = (unsigned char)(rand() & 255);
717a5a ииии} else if (randomVector == 1) {
a1a0a2 ииииииfprintf(stderr, "Using user params.\n");
e16a79 ииии} else {

5ac986 ииииииfprintf(stderr, "Seed=%d\n", randomVector);
cfccdd ииииииsrand(randomVector);
91c26c ииииииHARDWIRED_CHIP_ID = (unsigned char)(rand() & 255);
456fe7 ииии}
33af5a
21f70d ииии/* Reset chip and set the chip ID */
a00659 ииииsprintf(buffer, "01011111 00 %02X 00\n", HARDWIRED_CHIP_ID);
5c55a3 ииииRunChip(buffer, FILE_FROMCHIP, USE_RAW_IO); fputs(buffer, FILE_TOCHIP);
3d55a3 ииииRunChip(buffer, FILE_FROMCHIP, USE_RAW_IO); fputs(buffer, FILE_TOCHIP);
cd55a3 ииииRunChip(buffer, FILE_FROMCHIP, USE_RAW_IO); fputs(buffer, FILE_TOCHIP);
7655a3 ииииRunChip(buffer, FILE_FROMCHIP, USE_RAW_IO); fputs(buffer, FILE_TOCHIP);
62a71b ииииsprintf(buffer, "11011111 %02X %02X 00\n", HARDWIRED_CHIP_ID,
9ff16b ииииииииииииHARDWIRED_CHIP_ID);
1eb67c ииииRunChip(buffer, FILE_FROMCHIP, USE_RAW_IO);
93084e ииииfputs(buffer, FILE_TOCHIP);

--02cc 00029e33ba580040011 Page 3 of testvec.c
ba5b1f ииииbuffer[2] = '1';
34b67c ииииRunChip(buffer, FILE_FROMCHIP, USE_RAW_IO);
7a084e ииииfputs(buffer, FILE_TOCHIP);
ce47a4 ииииbuffer[2] = '0';
e3b67c ииииRunChip(buffer, FILE_FROMCHIP, USE_RAW_IO);
80084e ииииfputs(buffer, FILE_TOCHIP);
b0af5a
fd317c ииииif (randomVector == 1) {
971b90 ииииииLoadState(plaintextVector, plaintextXorMask, ciphertext0, ciphertext1,
4b91ef ииииииииииииииplaintextByteMask, useCBC, extraXor, startKey);
6d3cb4 ииииииproceedNormal(totalClocks);
916a79 ииии} else {
92057c ииииииproceedRandom();
7f6fe7 ииии}
4bdf1c ии}
a7af5a
a46b7f ии/* Clean up a bit (doesn't really matter -- this is test code :-) */
fd9918 ииfclose(FILE_FROMCHIP);
a9650b ииfclose(FILE_TOCHIP);
0defe6 }
b7af5a
b4af5a
b3bbdb void proceedNormal(long totalClocks) {
3be2b8 ииlong numClocks = getClockCounter();
341614 ииunsigned char goodKey[8];
0b929f ииint i,j,r;
80af5a
27a415 ииwhile (++numClocks < totalClocks) {
a40a43 ииииr = RunSimulator_CheckRegister(REG_SEARCHINFO);
021f4e ииииif (r & 4) {
e8b4b9 ииииииfprintf(stderr, "------- Idle --------\n");
318957 ииииииRunSimulator_DummyIO();
325f6a ииииииcontinue;
9b6fe7 ииии}
442135 ииииfor (i = 0; i < 24; i++) {
9ab4ea ииииии/* If we're going to see a stall, give some settling time */
d7bdac ииииииif ((peekState(REG_SEARCH_STATUS(i)) & 1) == 0) { иииииииии/* stalled? */
3ca6ab ииииииииRunSimulator_DummyIO(); иииииииииииииииииииииииии/* wait before read */
b9fe40 ииииииииRunSimulator_DummyIO();
d4fe40 ииииииииRunSimulator_DummyIO();
ff42cc ииииии}
c7d86b ииииииr = RunSimulator_CheckRegister(REG_SEARCH_STATUS(i));

7e760d ииииииif ((r & 1) == 0) { иииииииииииииииииииииииииииииииииииииии/* stalled? */
598b76 ииииииииgoodKey[6] = RunSimulator_CheckRegister(REG_SEARCH_KEY(i)+0);
4c6426 ииииииииgoodKey[5] = RunSimulator_CheckRegister(REG_SEARCH_KEY(i)+1);
c910b2 ииииииииgoodKey[4] = RunSimulator_CheckRegister(REG_SEARCH_KEY(i)+2);
2cb297 ииииииииgoodKey[3] = RunSimulator_CheckRegister(REG_SEARCH_KEY(i)+3);
91b4ef ииииииииgoodKey[2] = RunSimulator_CheckRegister(REG_SEARCH_KEY(i)+4);
1b5bbf ииииииииgoodKey[1] = RunSimulator_CheckRegister(REG_SEARCH_KEY(i)+5);
1a2f2b ииииииииgoodKey[0] = RunSimulator_CheckRegister(REG_SEARCH_KEY(i)+6);
fbaf5a
abf636 ииииииииfprintf(stderr, "ALERT: Full match in unit %d; extracted k = ", i);
b15425 ииииииииprintf("ALERT: Full match in unit %d; extracted k = ", i);
64677e ииииииииfor (j = 0; j < 7; j++) {
652f98 ииииииииииfprintf(stderr, "%02X", goodKey[j]);
1d7e87 ииииииииииprintf("%02X", goodKey[j]);
9e7fb0 ииииииии}
0de535 ииииииииfprintf(stderr, "\n");
e10493 ииииииииprintf("\n");
db75ed ииииииииRunSimulator_DummyIO(); ииииииииииииииииииииииииииии/* Settling time */
6afe40 ииииииииRunSimulator_DummyIO();
e336ec ииииииииRunSimulator_SetRegister(REG_SEARCH_STATUS(i), 1); иииииии/* restart */
4242cc ииииии}
dd6fe7 ииии}
06df1c ии}
f1efe6 }
adaf5a
0baf5a
d31874 void proceedRandom(void) {
840515 ииunsigned char readout[256];
74a4ed ииunsigned char goodKey[7];
29e13a ииint i,j;
--a796 0002667342680040011 Page 4 of testvec.c
4afe41 ииunsigned char plaintextVector[32];
14d1fd ииchar buffer[256];
23af5a
6c852a ии/* chip has already been set and the chip ID has been loaded */
73af5a
42c34a ии/* Create plaintext vector with 181 bits set */
ae477e ииmemset(plaintextVector, 0, sizeof(plaintextVector));
70a328 ииi = 0;
0d13b4 ииwhile (i < 181) {
926486 ииииj = rand() & 255;
21e479 ииииif ((plaintextVector[j/8] & (1 << (j % 8))) == 0) {
54e749 ииииииplaintextVector[j/8] |= (1 << (j % 8));
52079a ииииииi++;
2f6fe7 ииии}
dcdf1c ии}
84af5a
68fd4c ии/* Load state */
03339a ииfor (i = 0; i < 32; i++)
579479 ииииRunSimulator_SetRegister(REG_PTXT_VECTOR + i, plaintextVector[i]);
c61f76 ииfor (i = 0; i < 8; i++)
d332be ииииRunSimulator_SetRegister(REG_PTXT_XOR_MASK + i, rand() & 255);
671f76 ииfor (i = 0; i < 8; i++)
cce0be ииииRunSimulator_SetRegister(REG_CIPHERTEXT0 + i, rand() & 255);
631f76 ииfor (i = 0; i < 8; i++)
7849e3 ииииRunSimulator_SetRegister(REG_CIPHERTEXT1 + i, rand() & 255);
e1c5ca ииRunSimulator_SetRegister(REG_PTXT_BYTE_MASK, 1 << (rand() & 7));
c99aac ииi = (rand() % 3) + (rand() & 16); и/* 0/1/2 for CBC & extraXor. 16=activOn */
0bf2a6 ииииfprintf(stderr, "Using mode %d with ActiveOn=%d.\n", (i&3), i/16);
02b125 ииииRunSimulator_SetRegister(REG_SEARCHINFO, i);


040688 ииfor (i = 0; i < 24; i++) { иииииииииииииииииииииииииииии/* for each engine */
891cca ииииfor (j = 0; j < 7; j++) иииииииииииииииииииииииии/* set random start key */
0b98b9 ииииииRunSimulator_SetRegister(REG_SEARCH_KEY(i)+j, rand() & 255);
ecfdd9 ииииRunSimulator_SetRegister(REG_SEARCH_STATUS(i), 1);
98df1c ии}
daaf5a
8ea083 ии/* Read out all registers (real and not) except for ptxt vector */
df1999 ииfor (i = 255; i >= 32; i--)
6b1901 ииииreadout[i] = RunSimulator_CheckRegister(i);
d59097 ии/* Change the key in any stopped units */
219101 ииfor (i = 0; i < 24; i++) {
385173 ииииif ((readout[REG_SEARCH_STATUS(i)] & 1) == 0) иииииииииииииии/* stalled? */
3d6ca2 ииииииRunSimulator_SetRegister(REG_SEARCH_KEY(i),
65571a ииииииииииииииreadout[REG_SEARCH_KEY(i)] ^ 0x08); ииииииииииииииии/* fix key */
51df1c ии}
b31dc8 ии/* Read out ptxt vector */
632004 ииfor (i = 31; i >= 0; i--)
151901 ииииreadout[i] = RunSimulator_CheckRegister(i);
8c809e ии/* scan stopped units */
539101 ииfor (i = 0; i < 24; i++) {
f12abb ииииif ((readout[REG_SEARCH_STATUS(i)] & 1) == 0) { иииииииииииии/* stalled? */
97e66a ииииииgoodKey[6] = RunSimulator_CheckRegister(REG_SEARCH_KEY(i)+0);
b1093a ииииииgoodKey[5] = RunSimulator_CheckRegister(REG_SEARCH_KEY(i)+1);
217dae ииииииgoodKey[4] = RunSimulator_CheckRegister(REG_SEARCH_KEY(i)+2);
d2df8b ииииииgoodKey[3] = RunSimulator_CheckRegister(REG_SEARCH_KEY(i)+3);
cfd9f3 ииииииgoodKey[2] = RunSimulator_CheckRegister(REG_SEARCH_KEY(i)+4);
1536a3 ииииииgoodKey[1] = RunSimulator_CheckRegister(REG_SEARCH_KEY(i)+5);
3b4237 ииииииgoodKey[0] = RunSimulator_CheckRegister(REG_SEARCH_KEY(i)+6);
1d0767 ииииииif (rand() % 8)
8436ec ииииииииRunSimulator_SetRegister(REG_SEARCH_STATUS(i), 1); иииииии/* restart */
53ca8d ииииииfprintf(stderr, "****** Full match in unit %d; extracted k = ", i);
02b8df ииииииfor (j = 0; j < 7; j++) {
8a3d3b ииииииииfprintf(stderr, "%02X", goodKey[j]);
b905c9 ииииииииprintf("%02X", goodKey[j]);
8642cc ииииии}
c65501 ииииииfprintf(stderr, "\n");
de6fe7 ииии}
cbdf1c ии}
fbaf5a
ab917c ии/* pick a different chip, read/write some registers, and reset chip id */
3fef47 ииdo { i = rand() & 255; } while (i == HARDWIRED_CHIP_ID);
308260 ииsprintf(buffer, "11011111 %02X %02X 00\n", i, HARDWIRED_CHIP_ID);
2621ff ииRunChip(buffer, FILE_FROMCHIP, USE_RAW_IO);

--5543 0004f88973480040011 Page 5 of testvec.c
477f59 ииfputs(buffer, FILE_TOCHIP);
146c5f ииbuffer[2] = '1';
8921ff ииRunChip(buffer, FILE_FROMCHIP, USE_RAW_IO);
527f59 ииfputs(buffer, FILE_TOCHIP);
0f70e4 ииbuffer[2] = '0';
a421ff ииRunChip(buffer, FILE_FROMCHIP, USE_RAW_IO);
b07f59 ииfputs(buffer, FILE_TOCHIP);

6b1f76 ииfor (i = 0; i < 8; i++)
feca76 ииииRunSimulator_SetRegister(rand() & 255, rand() & 255);
161f76 ииfor (i = 0; i < 8; i++)
46b8cf ииииRunSimulator_CheckRegister(rand() & 255);
6615e8 ииsprintf(buffer, "11011111 %02X %02X 00\n", HARDWIRED_CHIP_ID,
04867c ииииииииииHARDWIRED_CHIP_ID);
5b21ff ииRunChip(buffer, FILE_FROMCHIP, USE_RAW_IO);
a57f59 ииfputs(buffer, FILE_TOCHIP);
836c5f ииbuffer[2] = '1';
ed21ff ииRunChip(buffer, FILE_FROMCHIP, USE_RAW_IO);
1f7f59 ииfputs(buffer, FILE_TOCHIP);
cc70e4 ииbuffer[2] = '0';
7b21ff ииRunChip(buffer, FILE_FROMCHIP, USE_RAW_IO);
1c7f59 ииfputs(buffer, FILE_TOCHIP);
9daf5a
3074d9 ии/* Test board enable and ADRSEL1 */
234255 ииBOARD_EN_IN = 0;
71cb06 ииADRSEL1_IN = 0;
732414 ииfor (i = 0; i < 4; i++)
42ca76 ииииRunSimulator_SetRegister(rand() & 255, rand() & 255);
0e2414 ииfor (i = 0; i < 4; i++)
0fb8cf ииииRunSimulator_CheckRegister(rand() & 255);
594255 ииBOARD_EN_IN = 0;
9891da ииADRSEL1_IN = 1;
241f76 ииfor (i = 0; i < 8; i++)
71ca76 ииииRunSimulator_SetRegister(rand() & 255, rand() & 255);
7b1f76 ииfor (i = 0; i < 8; i++)
54b8cf ииииRunSimulator_CheckRegister(rand() & 255);
2c1889 ииBOARD_EN_IN = 1;
fbcb06 ииADRSEL1_IN = 0;
da1f76 ииfor (i = 0; i < 8; i++)
aeca76 ииииRunSimulator_SetRegister(rand() & 255, rand() & 255);
e41f76 ииfor (i = 0; i < 8; i++)
b8b8cf ииииRunSimulator_CheckRegister(rand() & 255);
f81889 ииBOARD_EN_IN = 1;
1491da ииADRSEL1_IN = 1;
4caf5a
8ce7e0 ии/* Make a final pass reading all the registers */
99741b ииfor (i = 255; i >= 0; i--)
771901 ииииreadout[i] = RunSimulator_CheckRegister(i);
7e809e ии/* scan stopped units */
199101 ииfor (i = 0; i < 24; i++) {

b02abb ииииif ((readout[REG_SEARCH_STATUS(i)] & 1) == 0) { иииииииииииии/* stalled? */
76e66a ииииииgoodKey[6] = RunSimulator_CheckRegister(REG_SEARCH_KEY(i)+0);
c2093a ииииииgoodKey[5] = RunSimulator_CheckRegister(REG_SEARCH_KEY(i)+1);
287dae ииииииgoodKey[4] = RunSimulator_CheckRegister(REG_SEARCH_KEY(i)+2);
96df8b ииииииgoodKey[3] = RunSimulator_CheckRegister(REG_SEARCH_KEY(i)+3);
43d9f3 ииииииgoodKey[2] = RunSimulator_CheckRegister(REG_SEARCH_KEY(i)+4);
eb36a3 ииииииgoodKey[1] = RunSimulator_CheckRegister(REG_SEARCH_KEY(i)+5);
c34237 ииииииgoodKey[0] = RunSimulator_CheckRegister(REG_SEARCH_KEY(i)+6);
9bc697 ииииииRunSimulator_SetRegister(REG_SEARCH_STATUS(i), 1); иииииииии/* restart */
5aca8d ииииииfprintf(stderr, "****** Full match in unit %d; extracted k = ", i);
34b8df ииииииfor (j = 0; j < 7; j++) {
883d3b ииииииииfprintf(stderr, "%02X", goodKey[j]);
fc05c9 ииииииииprintf("%02X", goodKey[j]);
f742cc ииииии}
d85501 ииииииfprintf(stderr, "\n");
a56fe7 ииии}
04df1c ии}
81efe6 }
b2af5a
8baf5a
dbaf5a
be7897 void GetUserInfo(unsigned char plaintextVector[32],
4f2461 ииииииииunsigned char plaintextXorMask[8],

--53eb 000af645a6880040011 Page 6 of testvec.c
261fa8 ииииииииunsigned char ciphertext0[8], unsigned char ciphertext1[8],
49446e ииииииииunsigned char *plaintextByteMask, int *useCBC, int *extraXor,
8b9f02 ииииииииint *randomVector, unsigned char startKey[7], long *totalClocks) {
ef0e71 ииchar buffer[1024];
98c6d6 ииunsigned char tmp[512];
fe17e0 ииint i;
b5af5a
77659f ииprintf("Enter plaintextVector values: ");
10766e ииgets(buffer);
13b72a ииi = hex2bin(buffer, tmp);
4953dd ииif (i <= 0 || i >= 256)
b0112c ииииEXIT_ERR("Must have at least 1 plaintextVector entry and at most 255.\n");
481bcb ииmemset(plaintextVector, 0, 32);
83f545 ииwhile (i--)
24f3bf ииииplaintextVector[tmp[i]/8] |= (1 << (tmp[i] % 8));
9aaf5a
51ee8b ииprintf(" иииEnter plaintext xor mask: ");

14766e ииgets(buffer);
2db72a ииi = hex2bin(buffer, tmp);
aa1856 ииif (i != 8)
fba670 ииииEXIT_ERR("Must have 8 plaintext xor mask bytes.");
91b657 ииmemcpy(plaintextXorMask, tmp, 8);
b9af5a
b83a0c ииprintf(" иииииииииEnter ciphertext 0: ");
b6766e ииgets(buffer);
67b72a ииi = hex2bin(buffer, tmp);

a21856 ииif (i != 8)
c0cf62 ииииEXIT_ERR("Must have 8 bytes in ciphertext 0.");
2998f3 ииmemcpy(ciphertext0, tmp, 8);
16af5a
e9a5d9 ииprintf(" иииииииииEnter ciphertext 1: ");
eb766e ииgets(buffer);
26b72a ииi = hex2bin(buffer, tmp);
c41856 ииif (i != 8)
21cb49 ииииEXIT_ERR("Must have 8 bytes in ciphertext 1.");
1e1da6 ииmemcpy(ciphertext1, tmp, 8);
51af5a
fed221 ииprintf(" ииEnter plaintext byte mask: ");
9f766e ииgets(buffer);
b5b72a ииi = hex2bin(buffer, tmp);
968448 ииif (i != 1)
69f706 ииииEXIT_ERR("Plaintext byte mask is 1 byte long.");
1dc2b5 ии*plaintextByteMask = tmp[0];
93af5a
a51b21 ииprintf(" ииииииEnter useCBC (0 or 1): ");
72766e ииgets(buffer);
1bb72a ииi = hex2bin(buffer, tmp);
a415b9 ииif (i != 1 || tmp[0] > 1)
1519c6 ииииEXIT_ERR("Must enter 0 or 1 for useCBC.");
cde2c1 ии*useCBC = tmp[0];
7caf5a
bdf965 ииprintf(" ииииEnter extraXor (0 or 1): ");
28766e ииgets(buffer);
3ab72a ииi = hex2bin(buffer, tmp);
e915b9 ииif (i != 1 || tmp[0] > 1)
7a6c75 ииииEXIT_ERR("Must enter 0 or 1 for extraXor.");
8e2353 ии*extraXor = tmp[0];
92af5a
2e04d5 ииprintf(" Enter randomVector (0=randomize, 1=user input, >1=seed): ");
35766e ииgets(buffer);
3eb72a ииi = hex2bin(buffer, tmp);
a68448 ииif (i != 1)
6fbb66 ииииEXIT_ERR("Must enter 0=randomize 1=use input, >1=value for prng seed).");
9db530 ии*randomVector = tmp[0];
d4af5a
40c8bf ииprintf(" иииииииииEnter starting key: ");
a2766e ииgets(buffer);
07e684 ииif (hex2bin(buffer, tmp) != 7)
c3a5e4 ииииEXIT_ERR("Must enter 7 hex bytes as the key.\n");
f30ed3 ииmemcpy(startKey, tmp, 7);
6caf5a
aff4f6 ииprintf(" иииииEnter number of clocks: ");

--5aef 000e933bd7d80040011 Page 7 of testvec.c
74766e ииgets(buffer);
775582 ииsscanf(buffer, "%ld", totalClocks);

0f9780 ииif (*totalClocks < 1 || *totalClocks > 1000000000L)

e4b093 ииииEXIT_ERR("Must have between 1 and 1 billion clocks.\n");

33af5a
62186d ииprintHexString("\n иPtxtVector = ", plaintextVector, 32);
5aa738 ииprintHexString(" PtxtXorMask = ", plaintextXorMask, 8);
44ffc6 ииprintHexString("Ciphertext 0 = ", ciphertext0, 8);
913b57 ииprintHexString("Ciphertext 1 = ", ciphertext1, 8);

83dd31 ииprintHexString("PtxtByteMask = ", plaintextByteMask, 1);
37e15b ииprintf( иииииии" иииииuseCBC = %d\n", *useCBC);
012f30 ииprintf( иииииии" иииextraXor = %d\n", *extraXor);
bbe751 ииprintf( иииииии"randomVector = %x\n", *randomVector);
b81535 ииprintHexString("Starting key = ", startKey, 7);
bed787 ииprintf( иииииии"Total clocks = %ld\n\n", *totalClocks);
e2efe6 }
e0af5a
daaf5a
711884 void LoadState(unsigned char plaintextVector[32],
182461 ииииииииunsigned char plaintextXorMask[8],
541fa8 ииииииииunsigned char ciphertext0[8], unsigned char ciphertext1[8],
e3a024 ииииииииunsigned char plaintextByteMask, int useCBC, int extraXor,
40e619 ииииииииunsigned char startKey[7]) {
c917e0 ииint i;
0baf5a
af339a ииfor (i = 0; i < 32; i++)
a19479 ииииRunSimulator_SetRegister(REG_PTXT_VECTOR + i, plaintextVector[i]);
371f76 ииfor (i = 0; i < 8; i++)
c0a554 ииииRunSimulator_SetRegister(REG_PTXT_XOR_MASK + i, plaintextXorMask[7-i]);
131f76 ииfor (i = 0; i < 8; i++)
6d2b06 ииииRunSimulator_SetRegister(REG_CIPHERTEXT0 + i, ciphertext0[7-i]);
031f76 ииfor (i = 0; i < 8; i++)
02abab ииииRunSimulator_SetRegister(REG_CIPHERTEXT1 + i, ciphertext1[7-i]);
05ea2e ииRunSimulator_SetRegister(REG_PTXT_BYTE_MASK, plaintextByteMask);
5b35f1 ииRunSimulator_SetRegister(REG_SEARCHINFO, (useCBC?1:0) |

7e824a ииииииииии(extraXor?2:0) | 16); ииииииииииииииииииииии/* enable board active */
9d0688 ииfor (i = 0; i < 24; i++) { иииииииииииииииииииииииииииии/* for each engine */
c40441 ииииRunSimulator_SetRegister(REG_SEARCH_KEY(i)+0, startKey[6]);
da0982 ииииRunSimulator_SetRegister(REG_SEARCH_KEY(i)+1, startKey[5]);
d432d7 ииииRunSimulator_SetRegister(REG_SEARCH_KEY(i)+2, startKey[4]);
751204 ииииRunSimulator_SetRegister(REG_SEARCH_KEY(i)+3, startKey[3]);
a3696d ииииRunSimulator_SetRegister(REG_SEARCH_KEY(i)+4, startKey[2]);
b864ae ииииRunSimulator_SetRegister(REG_SEARCH_KEY(i)+5, startKey[1]);
4d13e5 ииииRunSimulator_SetRegister(REG_SEARCH_KEY(i)+6, (startKey[0] + i) & 255);
e7fdd9 ииииRunSimulator_SetRegister(REG_SEARCH_STATUS(i), 1);
8adf1c ии}
54efe6 }
15af5a
5daf5a
adaf5a
8b5194 void RunSimulator_SetRegister(int addr, int data) {
abd1fd ииchar buffer[256];
f8af5a
3c9186 ии/* RESET,BOARD_EN,ALE,ADRSEL1,WRB,RDB,ADRSEL2,ALLACT_IN,ADDR,CHIP_ID,DATA */
d25f05 ииsprintf(buffer, "1%d0%d110%d %02x %02x %02x\n", BOARD_EN_IN, ADRSEL1_IN,
afa8dd ииииииииииALLACTIVE_IN, addr, HARDWIRED_CHIP_ID, data);
7721ff ииRunChip(buffer, FILE_FROMCHIP, USE_RAW_IO);
047f59 ииfputs(buffer, FILE_TOCHIP);
d1af5a
6ecb50 ииsprintf(buffer, "1%d0%d010%d %02x %02x %02x\n", BOARD_EN_IN, ADRSEL1_IN,
93a8dd ииииииииииALLACTIVE_IN, addr, HARDWIRED_CHIP_ID, data);
c621ff ииRunChip(buffer, FILE_FROMCHIP, USE_RAW_IO);
3d7f59 ииfputs(buffer, FILE_TOCHIP);
44af5a
bb5f05 ииsprintf(buffer, "1%d0%d110%d %02x %02x %02x\n", BOARD_EN_IN, ADRSEL1_IN,
cda8dd ииииииииииALLACTIVE_IN, addr, HARDWIRED_CHIP_ID, data);
8821ff ииRunChip(buffer, FILE_FROMCHIP, USE_RAW_IO);
b57f59 ииfputs(buffer, FILE_TOCHIP);
6faf5a
073db7 ииif ((rand() & 31) == 0)
1debd9 ииииALLACTIVE_IN = 1-ALLACTIVE_IN;
e9efe6 }



--0bd8 000b2bfff2680040011 Page 8 of testvec.c
e0af5a
1aaf5a
562371 void RunSimulator_DummyIO(void) {
5fd1fd ииchar buffer[256];
dd5ffc ииint i,b,addr,chip;
f0af5a
bbb5a8 ииif ((rand() & 3) > 0) {
6df7c5 ииииaddr = rand() & 255;
7c7b22 ииииchip = (rand() & 7) ? HARDWIRED_CHIP_ID : (rand() & 255);
b40f2c ииииb = (rand() & 7) ? 1 : 0;
116e4c ииии/*RESET,BOARD_EN,ALE,ADRSEL1,WRB,RDB,ADRSEL2,ALLACT_IN,ADDR,CHIP_ID,DATA*/
58d814 ииииsprintf(buffer, "1%d01110%d %02x %02x 00\n", b, ALLACTIVE_IN, addr, chip);
34b67c ииииRunChip(buffer, FILE_FROMCHIP, USE_RAW_IO);
e1084e ииииfputs(buffer, FILE_TOCHIP);
b7b67c ииииRunChip(buffer, FILE_FROMCHIP, USE_RAW_IO);
4a084e ииииfputs(buffer, FILE_TOCHIP);
dea7f6 ииииsprintf(buffer, "1%d01100%d %02x %02x 00\n", b, ALLACTIVE_IN, addr, chip);
26b67c ииииRunChip(buffer, FILE_FROMCHIP, USE_RAW_IO);
7d084e ииииfputs(buffer, FILE_TOCHIP);
e2b67c ииииRunChip(buffer, FILE_FROMCHIP, USE_RAW_IO);
b2084e ииииfputs(buffer, FILE_TOCHIP);
0cdda8 ииииsprintf(buffer, "1%d01111%d %02x %02x 00\n", b, ALLACTIVE_IN, addr, chip);
d9b67c ииииRunChip(buffer, FILE_FROMCHIP, USE_RAW_IO);
a3084e ииииfputs(buffer, FILE_TOCHIP);
dbb67c ииииRunChip(buffer, FILE_FROMCHIP, USE_RAW_IO);
d1084e ииииfputs(buffer, FILE_TOCHIP);
64b67c ииииRunChip(buffer, FILE_FROMCHIP, USE_RAW_IO);
53084e ииииfputs(buffer, FILE_TOCHIP);
1149d8 ии} else {
1ad2a6 ииииsprintf(buffer, "1101111%d FF %02x FF\n", ALLACTIVE_IN, HARDWIRED_CHIP_ID);
6cd137 ииииfor (i = rand() & 7; i > 0; i--) {
73f0ee ииииииRunChip(buffer, FILE_FROMCHIP, USE_RAW_IO);
3ad7ef ииииииfputs(buffer, FILE_TOCHIP);
0e6fe7 ииии}
98df1c ии}
f8efe6 }
50af5a
55af5a
4caf5a
aba166 unsigned char RunSimulator_CheckRegister(int addr) {
9299d0 ииunsigned char rval;
d7d1fd ииchar buffer[256];
72af5a
229186 ии/* RESET,BOARD_EN,ALE,ADRSEL1,WRB,RDB,ADRSEL2,ALLACT_IN,ADDR,CHIP_ID,DATA */
fbac2d ииsprintf(buffer, "1%d0%d110%d %02x %02x 00\n", BOARD_EN_IN, ADRSEL1_IN,
e0278e ииииииииииALLACTIVE_IN, addr, HARDWIRED_CHIP_ID /*no data*/);

4121ff ииRunChip(buffer, FILE_FROMCHIP, USE_RAW_IO);
317f59 ииfputs(buffer, FILE_TOCHIP);
09af5a
0faa92 ииsprintf(buffer, "1%d0%d100%d %02x %02x 00\n", BOARD_EN_IN, ADRSEL1_IN,
35278e ииииииииииALLACTIVE_IN, addr, HARDWIRED_CHIP_ID /*no data*/);
cf49fa ииrval=(unsigned char)RunChip(buffer, FILE_FROMCHIP, USE_RAW_IO);
dc7f59 ииfputs(buffer, FILE_TOCHIP);
deaf5a
a2234b ииsprintf(buffer, "1%d0%d111%d %02x %02x 00\n", BOARD_EN_IN, ADRSEL1_IN,
ac278e ииииииииииALLACTIVE_IN, addr, HARDWIRED_CHIP_ID /*no data*/);
0321ff ииRunChip(buffer, FILE_FROMCHIP, USE_RAW_IO);
b77f59 ииfputs(buffer, FILE_TOCHIP);
cbaf5a
2076c9 ииreturn (rval);
c6efe6 }
36af5a
adaf5a
4bc2bf int unhex(char c) {
af53c4 ииif (c >= '0' && c <= '9')
f203d6 ииииreturn (c - '0');
618db1 ииif (c >= 'a' && c <= 'f')
180ada ииииreturn (c - 'a' + 10);
e449e3 ииif (c >= 'A' && c <= 'F')
d7a66f ииииreturn (c - 'A' + 10);
9912d4 ииreturn (-1);
b2efe6 }

--3d19 000c2e4763180040011 Page 9 of testvec.c
e0af5a
1aaf5a
4c4579 int hex2bin(char *hex, unsigned char *bin) {

dcc22f ииint i = 0;
a66a41 ииint j = 0;
66af5a
688ef6 ии/* Trim string if comments present */
078b28 ииif (strchr(hex, '#') != NULL)
a052e6 ииии*strchr(hex, '#') = 0;
d8a3ed ииif (strchr(hex, '*') != NULL)
2560d1 ииии*strchr(hex, '*') = 0;
d8a6e5 ииif (strchr(hex, '\'') != NULL)
762462 ииии*strchr(hex, '\'') = 0;
6caf5a
9447de ииfor (i = 0; i < (int)strlen(hex); i++) {
d28e69 ииииif (hex[i] >= '0' && unhex(hex[i]) < 0)
d3d278 ииииииEXIT_ERR("Bad hex digit encountered.\n");
81df1c ии}
27af5a
1b47de ииfor (i = 0; i < (int)strlen(hex); i++) {
34f5b0 ииииif (hex[i] < '0')
875f6a ииииииcontinue;
51643e ииииif (hex[i] >= '0' && hex[i+1] >= '0') {
57f2a4 ииииииbin[j++] = (unsigned char)(unhex(hex[i])*16+unhex(hex[i+1]));
0039d3 ииииииi++; ииииииииииииииииииииииииииииииииииииииииииииииииииииии/* skip one */
245f6a ииииииcontinue;
ab6fe7 ииии}
a3e16f ииииif (hex[i] >= '0') {
339eae ииииииbin[j++] = (unsigned char)(unhex(hex[i]));
3d6fe7 ииии}
5fdf1c ии}
ebc1d2 ииreturn (j);
8cefe6 }
c2af5a
f2af5a
847b71 void printHexString(char *tag, unsigned char *data, int len) {
3d17e0 ииint i;
dbaf5a
449650 ииprintf("%s", tag);
fc6c12 ииfor (i = 0; i < len; i++)
20cd57 ииииprintf("%02X", data[i]);
8afee8 ииprintf("\n");
eaefe6 }
8aaf5a
24af5a
18bb19 void OpenFiles(char *toChipFilename, char *fromChipFilename, int useRaw) {
e27959 ииFILE_TOCHIP = fopen(toChipFilename, useRaw ? "rb" : "r");
c0f096 ииif (FILE_TOCHIP != NULL) {
9d1260 ииииCREATING_VECTOR = 0;
6449d8 ии} else {
335eff ииииFILE_TOCHIP = fopen(toChipFilename, useRaw ? "wb" : "w");
c5d318 ииииif (FILE_TOCHIP == NULL) {
445716 ииииииfprintf(stderr, "Can't open \"s\" for toChip file\n", toChipFilename);
e4c1d2 ииииииexit(1);
d56fe7 ииии}
0c48bc ииииCREATING_VECTOR = 1;
69df1c ии}
ebaf5a
7da670 ииFILE_FROMCHIP = fopen(fromChipFilename, useRaw ? "wb" : "w");
8d870f ииif (FILE_FROMCHIP == NULL) {

9842e1 ииииfprintf(stderr, "Can't open \"s\" for fromChip file\n", fromChipFilename);
25646c ииииexit(1);
fddf1c ии}
7baf5a
d359dc ииUSE_RAW_IO = useRaw;
7dc563 #if 0 ииииииииииииии/* Activate this to add column descriptors in the output */
4e14fa ииif (!useRaw){
e382e3 ииииfprintf(FILE_TOCHIP, "RESET\n");
4d7cf5 ииииfprintf(FILE_TOCHIP, "|BOARD_EN\n");
d6f02c ииииfprintf(FILE_TOCHIP, "||ALE\n");
da1111 ииииfprintf(FILE_TOCHIP, "|||ADRSEL1\n");
c287b0 ииииfprintf(FILE_TOCHIP, "||||WRB\n");

--c2ba 001857ff29a80040011 Page 10 of testvec.c
93a32c ииииfprintf(FILE_TOCHIP, "|||||RDB\n");
71b3bd ииииfprintf(FILE_TOCHIP, "||||||ADRSEL2\n");
d017df ииииfprintf(FILE_TOCHIP, "|||||||ALLACTIVE_IN\n");
6bed08 ииииfprintf(FILE_TOCHIP, "|||||||| ADDR\n");
173c97 ииииfprintf(FILE_TOCHIP, "|||||||| /\\ CHIP_ID\n");
f1102a ииииfprintf(FILE_TOCHIP, "|||||||| || /\\ DATA\n");
4aea2f ииииfprintf(FILE_TOCHIP, "|||||||| || || /\\ ALLACTIVE_OUT\n");
e1e4e9 ииииfprintf(FILE_FROMCHIP, "DATA\n");
541499 ииииfprintf(FILE_FROMCHIP, "/\\ ALLACTIVE_OUT\n");
4dc3ec ииииfprintf(FILE_FROMCHIP, "|| | /-- IsActive [0..23] --\\\n");
a6df1c ии}
187454 #endif
217c65 ииfprintf(FILE_FROMCHIP, "KEY иииииииииииDES_OUT иииииииииMATCH & SELECT1:\n");
1aefe6 }
85af5a

