
          The  Cleanroom  Process  for  Software  Development*

                              Dr.   Chris  Lokan
                     Department  of  Computer  Science
                         University  College,  UNSW
                   Australian  Defence  Force  Academy

                Computer Science Department Report CS2/93


1   Introduction


Software  development  methods  traditionally  produce  software
containing  many  errors.   Such  software  is  expensive  to
develop  and  maintain,  and  development  productivity  is  low.
Better  development  processes  are  required.   Software  quality
management  standards  such  as  AS  3563[1 ],  and  the  Software
Engineering  Institute's  ``Capability  Maturity  Model''[2 ],
are  helping  to  focus  attention  on  defining  and  improving
software  development  processes.
Cleanroom  is  a  software  development  process  developed  at  IBM
during  the  1980's.   It  is  valuable  in  several  ways:

    o  software  produced  with  Cleanroom  tends  to  have  very  few
       defects  (zero  defects  in  operation  is  commonly
       observed);

    o  software  development  can  be  placed  under  statistical
       quality  control;

    o  development  productivity  is  greater  than  with
       traditional  methods.

In  some  respects  Cleanroom  represents  a  radical  departure
from  traditional  methods.   This  can  make  adopting  Cleanroom
seem  rather  daunting.   It  need  not  be  adopted  all  at  once,
however  ---  many  of  the  benefits  of  Cleanroom  can  be
achieved  by  adopting  some  of  its  elements  individually  and
incrementally.
________________________________*
     This  article  summarises  a  talk  given  by  the  author  to  the
Canberra  Branch  of  the  Australian  Computer  Society  on  21
October  1992.
                                        1


This  article  gives  a  brief  introduction  to  Cleanroom.
Section  2  describes  the  overall  process,  and  the  six  main
elements  of  the  Cleanroom  process.   Section  3  describes  some
practical  experience  with  Cleanroom.   Section  4  outlines  how
the  elements  of  Cleanroom  can  be  adopted  incrementally.
Section  5  summarises  the  main  points  of  the  article.


2   What  is  Cleanroom?


Cleanroom  is  a  method  for  placing  software  development  under
statistical  process  control,  and  developing  software  with
known  reliability.   The  term  ``Cleanroom''  signifies  a
development  process  that  aims  to  prevent  the  introduction  of
defects  during  development.
The  original  idea  of  Cleanroom  was  that:

       By  conducting  software  development  under  closely
       managed  and  controlled  conditions,  that  track  the
       entire  history  of  software  from  creation  to
       incorporation  in  a  product,  a  certified  reliability
       in  MTBF  (Mean  Time  Between  Failures)  of  the  product
       can  be  developed  concurrently  with  the  product[3 ].

Quality  and  reliability  are  considered  from  the  point  of
view  of  the  users  of  the  software.
>From  this  original  idea,  the  Cleanroom  method  has  evolved.
It  incorporates  some  well-established  elements,  such  as
top-down  design,  as  well  as  some  tools  and  techniques  that
had  to  be  newly  developed.
Figure  1  illustrates  the  flow  of  events  in  a  Cleanroom
development.   In  overall  form  it  resembles  a  standard
development  cycle;  the  differences  lie  in  how  the  individual
activities  are  carried  out.   Incremental  development  of
software  is  encouraged,  and  forms  an  important  part  of
reliability  measurement;  thus  the  process  shown  in  Figure  1
is  generally  repeated  several  times.


                                        2



                   Figure  1:   The  Cleanroom  process
The  fundamental  goal  of  Cleanroom  is  to  place  software
development  under  statistical  process  control.   From  this
goal  follows  the  need  for  each  of  the  main  elements  of
Cleanroom:

    o  statistical  quality  control  is  based  on  measurements  of
       software  reliability.   This  required  the  development  of
       new  theory  and  models  for  predicting  reliability,  and
       also  that  testing  be  conducted  on  a  statistical  basis.

    o  Reliability  measurement  would  be  almost  meaningless
       unless  the  software  contained  few  defects  to  start  with.
       Formal  methods  were  needed  for  specification,  design,
       and  verification  of  software  in  order  to  achieve  this
       initial  quality.

                                        3


The  six  main  elements  of  Cleanroom  to  be  described  are
software  specification,  design  and  development,  correctness
verification,  statistical  testing,  reliability  measurement,
and  statistical  process  control.


2.1    Specification

Software  specification  involves  defining  the  functional
requirements  that  must  be  implemented  by  the  software;  any
constraints  on  execution  time,  space,  environment,  etc.
that  must  be  observed;  and  a  construction  plan  for
developing  the  software  in  a  series  of  increments.   In
Cleanroom,  all  of  these  things  are  described  from  the  user's
perspective  in  an  ``external  specification''.   They  must
also  be  spelled  out  in  detail  from  the  developer's
perspective,  in  an  ``internal  specification''.
Cleanroom  requires  that  specification  be  completed
rigorously  and  formally,  before  design  and  development
begin.   Formal  notation  is  required  in  the  internal
specification,  to  support  correctness  verification  during
design.   Natural  language  is  not  sufficient,  because  it  is
generally  too  imprecise.   Formal  methods  force  a  careful
analysis  of  requirements,  and  tend  to  minimise  ambiguity,
inconsistency,  and  incompleteness  in  the  specification.
Suitable  notations  for  the  internal  specification  include
box  structuring  techniques[6 ],  formal  specification
languages  like  VDM[4 ]  and  Z[5 ],  and  appropriate
problem-specific  grammars.
To  the  criticism  that  requirements  can  rarely  be  specified
in  such  detail  so  early  in  development,  the  Cleanroom
response  is  essentially  that  you  cannot  afford  not  to  ---
imprecision  and  ambiguity  are  too  costly  in  the  long  run  to
be  tolerated.   Experience  is  that  the  verification  objective
causes  a  more  complete  requirements  analysis  to  be  done,
resulting  in  a  more  complete  and  accurate  specification.
Note  that  nothing  in  Cleanroom  says  that  prototypes  or  any
other  method  cannot  be  used  for  requirements  elicitation;
before  design  commences,  though,  a  formal  specification  of
the  requirements  as  known  must  be  completed.
Cleanroom  requires  one  more  important  thing  in  the  software
specification:   a  description  of  the  expected  usage  of  the
software.   This  makes  it  possible  to  test  the  software  in
ways  that  simulate  its  expected  use  in  production,  and  hence

                                        4


to  predict  the  reliability  of  the  software  (in  MTTF1)  as  the
user  will  see  it.   A  target  reliability  should  be  specified
as  well.


2.2    Design  and  Development

A  rigorous  and  formal  design  method  is  required  for
generating  software  whose  correctness  can  be  verified.
The  inventors  of  Cleanroom  recommend  the  use  of  box
structures[6 ].   Box  structures  view  software  from  three
perspectives:

   1.  an  implementation-independent  ``black  box''  view  defines
       the  responses  of  the  software  to  stimuli  histories.

   2.  in  the  data-driven  ``state  box''  view,  state  data  needed
       to  represent  stimuli  histories  are  defined.   The  black
       box  description  is  then  elaborated,  to  represent
       responses  in  terms  of  the  current  stimuli  and  state
       data.

   3.  the  process-driven  ``clear  box''  view  expands  on  the
       state  box  view.   Processing  logic  is  added,  and  data
       abstractions  are  selected  to  represent  the  state  data.
       Responses  are  represented  in  terms  of  current  stimuli,
       state  data,  and  invocations  of  lower  level  black  boxes.

An  eleven-step  process  for  expanding  a  black  box  to  its
state  box  and  clear  box  views  is  described,  with  an  example,
in  [6 ].
The  advantages  of  box  structures  are  that  the  same  notation
and  technique  can  be  used  from  specification  (the  top-level
black  box  specifies  the  functional  requirements)  right  down
to  low  level  elements  of  the  design;  data-driven  and
process-driven  aspects  of  design  are  both  considered;  and
they  provide  a  rigorous  algorithm  that  guides  system  design
in  an  orderly  way.
Each  level  of  the  design  should  be  checked  for  correctness
in  a  design  review  before  the  next  level  of  design  begins.
Alternatives  to  box  structures  can  be  used.   Any  top-down
stepwise  refinement  technique,  using  a  limited  set  of
primitives  for  expressing  logic  and  describing  data,  is
________________________________
    1``Mean  Time  To  Failure''  is  the  term  generally  used  in

reliability  theory,  rather  than  the  ``Mean  Time  Between
Failures''  that  Mills  originally  mentioned.



                                        5


suitable.   The  important  thing  is  to  make  sure  that  the
design  is  specified  precisely  and  completely  at  each  level,
so  that  it  is  possible  to  verify  that  each  piece  of  the
design  correctly  implements  its  specification.
Once  the  design  is  complete,  the  programming  team  expands
the  clear  box  descriptions  into  code.


2.3    Correctness  Verification

In  Cleanroom,  the  development  team  does  not  test,  or  even
compile,  the  code.   Testing  is  left  to  the  certification
team,  which  tests  the  system  as  a  whole;  there  is  no  such
thing  as  unit  testing  in  Cleanroom.
Instead  of  unit  testing,  programmers  use  mathematical
verification  techniques  to  demonstrate  the  correctness  of
each  code  unit.   By  reasoning  about  the  effect  of  each
statement,  individually  and  then  in  combination,  the
programmer  should  be  able  to  prove  that  the  each  code  unit
meets  its  specification.
Verification  consists  essentially  of  answering  questions
like  ``Does  the  effect  of  statement  X  followed  by  the  effect
of  statement  Y  give  me  the  overall  effect  I  need  from  those
statements?''   On  an  informal  level,  all  programmers  should
be  asking  themselves  questions  like  this  anyway  as  they
program;  there  is  nothing  unique  to  Cleanroom  in  this.
Cleanroom  programmers  are  expected  to  write  and  check  their
code  carefully  in  this  way;  the  correctness  of  the  code  is
then  checked  in  code  reviews.
Cleanroom  code  reviews  are  quite  different  to  standard  code
reviews.   Tools  can  process  the  code  to  generate  a  list  of
verification  questions  to  be  answered.   The  review  then
consists  of  reviewers  checking  that  the  questions  can  be
answered  affirmatively.   Informal  reasoning  should  usually
be  sufficient.   Formal  verification  techniques  need  be  used
only  if  the  correctness  of  a  piece  of  code  is  not  clear;
alternatively,  the  design  or  code  can  be  reworked  to
simplify  it.


2.4    Statistical  Testing

All  testing  of  software  is  carried  out  by  a  separate  testing
team.   Only  functional  testing  is  performed.
Testing  is  carried  out  on  a  statistical  basis.   This  means
that  test  cases  are  not  generated  by  trying  to  cover  all
                                        6


execution  paths,  or  by  contriving  test  cases  to  exercise
particular  functions  of  the  software.   Instead,  test  cases
are  generated  randomly,  with  a  distribution  of  test  data
values  that  reflects  the  expected  usage  of  the  software  by
the  user.
The  idea  behind  this  approach  is  that  to  maximise  expected
MTTF,  we  need  to  concentrate  on  the  failures  that  are  likely
to  occur  frequently  in  the  user's  environment.   The  best  way
to  do  this  is  to  simulate  the  user's  usage  of  the  software.
Coverage  testing  is  equally  likely  to  find  low-frequency  and
high-frequency  errors;  statistical  testing  is  more  likely  to
find  the  high-frequency  errors.
Another  benefit  of  statistical  testing  is  that  statistical
theory  can  indicate  how  many  test  cases  are  needed  in  order
to  give  a  desired  level  of  confidence  in  the  results.
Statistical  testing  is  an  effective  testing  technique.   It
has  been  shown  to  be  as  effective  as  standard  testing
techniques  in  both  finding  errors  and  in  requirements
coverage[7 ].
Statistical  testing  requires  a  lot  of  planning  and
preparation.

    o  A  profile  of  expected  usage  is  part  of  the  initial
       specification.   To  determine  it  one  must  identify  the
       relative  frequencies  with  which  each  function  will  be
       triggered,  and  the  probabilities  associated  with  the
       data  values  of  each  of  the  inputs  that  will  be  supplied.
       This  can  involve  considerable  research.   It  also  has
       some  dangers:   it  can  be  difficult  to  anticipate  how  a
       completely  new  system  will  be  used;  and  the  introduction
       of  a  computer  system  into  a  work  environment  changes
       that  environment,  so  that  actual  usage  may  end  up
       different  from  anticipated  usage.

    o  For  software  of  any  reasonable  complexity,  a  lot  of  data
       is  required  to  characterise  the  functions,  inputs,  and
       associated  probabilities.   Tools  are  needed  to  store
       this  information  in  a  data  base,  and  to  generate  test
       cases  from  the  stored  data.

       What  constitutes  a  test  case  depends  on  the  application.
       For  example,  a  test  case  generator  for  a  COBOL  program
       re-structurer[8 ]  must  randomly  generate  COBOL  programs
       with  a  typical  mix  of  different  types  of  statements;
       flight  control  software  might  be  tested  with  scripts



                                        7


       that  simulate  the  actions  of  aircraft  personnel  in  using
       a  display  panel  to  select  various  functions[7 ];  a  data
       base  program  must  be  tested  with  a  typical  mix  of
       transactions.   A  different  test  case  generator  will
       probably  need  to  be  built  for  each  project.   This  will
       generally  be  a  major  task.

Note  that  statistical  testing  could  be  applied  in  any
development;  it  is  not  restricted  to  Cleanroom.


2.5    Reliability  Measurement

Software  reliability  requires  a  different  theory  to  hardware
reliability.   Software  failures  are  logical,  not  physical,
and  are  due  to  development  errors  rather  than  aging.
The  approach  taken  to  estimate  software  reliability  is  to
consider  each  execution  of  the  program  as  a  separate  event.
Given  software  that  contains  errors,  some  executions  will
result  in  failure  while  others  complete  successfully.   If
the  entire  population  of  possible  executions  is  sampled
according  to  expected  usage,  and  a  record  of  failures  and
successes  is  maintained,  statistics  can  be  used  to  estimate
reliability.
Several  models  for  estimating  reliability  have  been  proposed
along  these  lines.   The  model  proposed  by  the  inventors  of
Cleanroom  is  described  in  [9 ].   It  involves  running  a  series
of  test  cases,  timing  their  execution,  and  observing  the
points  at  which  each  new  error  is  exposed.   A  formula  is
then  used  to  estimate  MTTF  (in  units  of  execution  time)  from
the  observed  inter-failure  intervals.
The  complete  testing  history,  as  the  software  goes  through  a
series  of  increments  and  as  errors  are  found  and  fixed  in
each  increment,  must  be  known  in  order  that  MTTF  can  be
tracked.   This  is  why  no  testing  by  the  programmers  is
allowed.
If  the  software  contains  a  large  number  of  defects,  it  will
fail  frequently  and  MTTF  will  be  too  low  to  be  meaningful
(what  use  is  software  that  is  expected  to  fail  every  few
seconds!).   There  must  be  few  defects  to  start  with  in  order
for  the  reliability  measurement  to  be  useful  ---  hence  the
emphasis  on  getting  the  software  correct  to  start  with.

                                        8


2.6    Statistical  Process  Control

Two  important  benefits  should  follow  if  software  development
can  be  placed  under  statistical  quality  control.   First,  it
should  be  possible  to  assess  the  quality  of  the  product
(perhaps  even  leading  to  software  with  genuine  warranties!).
Second,  it  becomes  possible  to  evaluate  the  quality  of  the
development  process  itself,  so  attention  can  be  directed  to
those  activities  where  defects  are  introduced.   Evaluation
and  improvement  of  the  development  process  is  the
cornerstone  of  the  top  (``optimising'')  level  of  SEI's
Capability  Maturity  Model[2 ].
Cleanroom's  reliability  measurement  provides  a  basis  for
statistical  process  control.   For  product  assessment,
reliability  expressed  as  MTTF  in  a  user's  environment  is
clearly  a  valuable  measure  of  software  quality.
Furthermore,  it  is  directly  relevant  to  the  user,  unlike  the
indirect  measures  (eg  defects  per  KLOC)  that  are  often  used
to  ``measure''  quality.
Reliability  certification  provides  several  opportunities  for
guiding  and  improving  the  development  process.   To  start
with,  the  very  introduction  of  measurement  into  a  process
tends  to  improve  that  process,  as  people  pay  more  attention
to  detail  and  quality.   Secondly,  if  testing  reveals  an
unacceptably  high  error  density  it  is  more  cost-effective  to
abort  the  testing  and  return  to  design  and  verification;
this  might  not  be  recognised  were  measurements  not  being
taken.   Thirdly,  if  MTTF  of  a  product  is  tracked  while  the
product  goes  through  several  increments,  it  can  be  compared
with  the  target  MTTF.  If  the  target  is  not  being  met,  or  if
reliability  does  not  appear  to  be  growing,  analysis  of  the
problems  can  show  where  attention  is  most  necessary.


3   Experience  with  Cleanroom


Reported  case  studies  using  Cleanroom  include  an  80,000  line
COBOL  restructurer,  written  in  PL/1  at  IBM[8 ];  a  34,000  line
satellite  control  program,  written  in  FORTRAN  at  NASA[10 ];
an  1,800  line  4GL  database  program  for  the  US  Navy[11 ];  and
a  1,500  line  electronic  mail  program  developed  in  an
experiment  at  the  University  of  Maryland[12 ].   Observations
from  other  uses  of  Cleanroom  are  described  in  [7 ].
These  have  been  the  experiences:

    o  Designs  are  produced  that  are  clear,  simple,



                                        9


       conservative,  easy  to  verify,  and  meet  their
       specification  exactly.

    o  Informal  verification  is  sufficient  for  all  but  about  1%
       of  the  design  or  code,  which  is  usually  in  areas  whose
       correctness  is  critical.

    o  Few  errors  are  made,  and  over  90%  of  them  are  found
       before  testing.   About  1--3  errors  per  KLOC  survive
       until  testing,  and  less  than  1  per  KLOC  survive  into
       production.   Zero  failures  in  operation  may  be  observed.

    o  The  time  from  problem  detection  to  closure  is  much
       smaller  than  with  traditional  methods,  largely  due  to
       the  simplicity  of  designs.

    o  Despite  the  overhead  of  initial  training,  development
       productivity  is  the  same  or  better  (by  up  to  a  factor  of
       3)  than  with  traditional  methods.


4   Incremental  Adoption  of  Cleanroom


Like  any  new  technique,  it  requires  training  and  a  change  of
development  culture  to  adopt  Cleanroom.   Even  though
substantial  benefits  can  be  achieved  with  Cleanroom,  the
magnitude  of  the  change  from  traditional  methods  to
Cleanroom  is  quite  daunting.   Perhaps  this  is  why  all  of  the
uses  of  Cleanroom  so  far  (except  for  the  university
experiment)  have  been  by  large  organisations  that  could
afford  to  experiment  and  which  were  their  own  customers  for
the  software  produced.
Fortunately,  it  is  possible  to  adopt  some  of  the  elements  of
Cleanroom  individually  and  still  gain  many  of  the  benefits.
First  of  all,  a  baseline  development  process  is  assumed.
The  baseline  process  includes  some  form  of  top-down  design
method,  structured  programming,  and  formal  inspections.
Organisations  that  do  not  have  these  elements  as  part  of
their  development  process  should  put  them  in  place  before
trying  to  adopt  any  of  the  elements  of  Cleanroom  (this  alone
should  improve  the  quality  of  their  software!).
                                       10


     Figure  2:   Order  for  Introducing  Elements  of  Cleanroom
Figure  2  shows  how  the  various  aspects  of  Cleanroom  can  be
adopted  incrementally:

   1.  Place  all  software  under  configuration  control  prior  to
       its  first  execution  ---  even  before  any  compilation  or
       unit  testing.   This  immediately  introduces  a  culture  in
       which  people  are  very  careful  to  avoid  errors  right  from
       the  start.   This  might  be  termed  ``quality  control  by
       embarrassment'',  since  developers  know  that  all  errors
       will  be  publicly  visible!

   2.  Do  away  with  testing  by  the  developers.   This  forces  the
       use  of  other  techniques,  particularly  logical
       correctness  verification,  to  make  sure  the  software  is
       correct;  in  turn  this  leads  to  more  care  in
       specification  and  design.   Whatever  form  of  code  reviews
       are  in  use  should  be  replaced  by  the
       verification-oriented  reviews  described  in  section  2.3.
                                       11


       Although  this  step  appears  to  be  the  most  radical  change
       in  Cleanroom,  it  turns  out  that  as  confidence  grows  in
       the  ability  of  reviews  to  detect  errors,  the  desire  and
       need  for  developer  testing  diminish.

   3.  Statistical  testing  can  be  introduced  independently  of
       the  first  two  elements.

   4.  MTTF  measurement  can  be  instituted  once  statistical
       testing  is  being  used.   To  be  effective,  it  requires  the
       relatively  defect-free  software  produced  by  verification
       rather  than  unit  testing;  thus  all  of  elements  1--3
       should  be  in  place.

   5.  Statistical  process  control  is  possible  once  MTTF  is
       being  measured.


5   Conclusion


Cleanroom  draws  together  some  old  and  some  new  ideas  to  form
a  software  development  process  with  significant  advantages
over  traditional  methods.   For  the  first  time,  it  is
possible  to  develop  software  under  statistical  process
control.   Development  productivity  is  improved,  and  the
software  produced  has  high  quality  and  certifiable
reliability.
Common  initial  reactions  to  Cleanroom  are  that  it  seems  too
clinical  and  theoretical  ---  that  it  couldn't  work  in  real
software  development  environments,  and  takes  all  the  fun  out
of  software  development.   The  first  objection  has  been
answered  by  case  studies  that  have  shown  that  it  does  work
in  practice.   On  the  second  point:   Cleanroom  doesn't  remove
the  creativity  from  software  development,  it  just  requires
that  things  be  done  carefully  and  properly.   In  that  sense
it  is  no  different  to  any  other  approach  that  aims  to  help
solve  the  software  crisis.
In  many  respects  Cleanroom  represents  a  major  departure  from
traditional  software  development  methods.   So  far  it  has
only  been  tested  by  large  organisations  that  can  afford  to
experiment,  but  the  results  of  those  experiments  are  so
convincing  that  we  can  expect  to  hear  a  lot  more  of
Cleanroom  in  the  future.   Managing  and  improving  the
software  development  process  is  increasingly  important
today;  it  would  be  worth  any  software  development
organisation's  while  to  consider  Cleanroom.



                                       12


Acknowledgements


Figure  1  is  taken  from  reference[11 ].   Figure  2  is  adapted
from  reference[7 ].


References


  [1]  Standards  Association  of  Australia.  Australian  standard
       3563:   Software  quality  management  system,  1988.

  [2]  W.S.  Humphrey.  Managing  the  Software  Process.
       Addison-Wesley,  1989.

  [3]  H.D.  Mills.  Software  of  certifiable  reliability.
       (quoted  in  [Dyer,  1992],  page  2),  1980.

  [4]  C.B.  Jones.  Systematic  Software  Development  Using  VDM.
       Prentice  Hall,  1986.

  [5]  M.  Spivey.  The  Z  Notation:   a  Reference  Manual.  Oxford
       University  Research  Group,  1987.

  [6]  H.D.  Mills.  Stepwise  refinement  and  verification  in
       box-structured  systems.  IEEE  Computer,  21(6):23--36,
       June  1988.

  [7]  M.  Dyer.  The  Cleanroom  Approach  to  Quality  Software
       Development.  Wiley,  1992.

  [8]  R.C.  Linger  and  H.D.  Mills.  Case  study  in  Cleanroom
       software  engineering.  In  COMPSAC  '88  Proceedings,  1988.

  [9]  P.A.  Currit,  M.  Dyer,  and  H.D.  Mills.  Certifying  the
       reliability  of  software.  IEEE  Transactions  on  Software
       Engineering,  SE-12(1):3--11,  January  1986.

[10]   S.  Green  et  al.  The  Cleanroom  case  study  in  the  SEL.
       Technical  Report  SEL-90-002,  NASA  Goddard  SEL,  1990.

[11]   C.J.  Trammell,  L.H.  Binder,  and  C.E.  Snyder.  The
       automated  production  control  documentation  system:   A
       case  study  in  Cleanroom  software  engineering.  ACM
       Transactions  on  Software  Engineering  and  Methodology,
       1(1):81--94,  January  1992.

[12]   R.W.  Selby,  V.R.  Basili,  and  F.T.  Baker.  Cleanroom
       software  development:   an  empirical  evaluation.  IEEE
       Transactions  on  Software  Engineering,
       SE-13(9):1027--1037,  September  1987.
                                       13

