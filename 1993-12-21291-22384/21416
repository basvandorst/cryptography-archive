Path: msuinfo!uwm.edu!cs.utexas.edu!usc!elroy.jpl.nasa.gov!decwrl!oracle!unrepliable!bounce
Newsgroups: sci.crypt
From: rjenkins@uucp (Robert Jenkins)
Subject: another RNG
Message-ID: <1993Nov24.050303.5236@oracle.us.oracle.com>
Keywords: RNG, C, pool
Sender: usenet@oracle.us.oracle.com (Oracle News Poster)
Nntp-Posting-Host: kr2seq.us.oracle.com
Organization: Oracle Corporation
Date: Wed, 24 Nov 1993 05:03:03 GMT
X-Disclaimer: This message was written by an unauthenticated user
              at Oracle Corporation.  The opinions expressed are those
              of the user and not necessarily those of Oracle.
Lines: 58

/*
---------------------------------------------------------
A cryptographically secure pseudorandom number generator?
Generates 10^9 bits in 11.2 seconds on a SPARCstation 10.
---------------------------------------------------------
*/

#define ALPHA 9                   /* arrays of size 2^alpha */
#define SIZE  (1<<ALPHA)
#define OMEGA 32                  /* omega bits per value */

typedef  unsigned long int  u4;   /* u4 is unsigned, 4 bytes */
static u4 za, zb;                 /* za,zb: secret values */
static u4 m[SIZE];                /* m: pool of secret memory */
static u4 r[SIZE];                /* r: results given to the user */

static void zgen()                /* fill r[] with new values */
{
  register u4 a,b,c,i,j,k;

  a = za;  b = zb;
  for (i=0; i<SIZE; ++i) 
  {
    j = m[(b >> (OMEGA-ALPHA))] + b;
    k = m[(c = (j >> (OMEGA-ALPHA)))] + a;
    a = m[i];
    b = c ^ (j << ALPHA);         /* b is j barrelshifted by alpha */
    m[i] = b + k;                 /* a's value is no longer in m */
    r[i] = k;
  }
  zb = b;  za = a;
}

int main()
{
  u4 i;
  za = zb = 1;                      /* something must be nonzero */
  for (i=0; i<SIZE; ++i) m[i] = 0;  /* put the seed in m[] */
  for (i=0; i<100; ++i) zgen();     /* stir things up some */

  for (i=0; i<62500; ++i) zgen();   /* generate 10^9 bits */
}


=======================================================================

The essence of this generator is looking up a few values pseudorandomly
from a large pool of unknown values.  As the pool gets larger, more
bits are used to look up each value.  My best cracking method involves
guessing 512 consecutive values of c, at 9 bits apiece.  Bleah.

This passed the distribution, frequency, and run tests for as long as I
was willing to run them.  So what might be wrong with the generator?
A simple, secure generator faster than LCG would be a good thing.

                                        - Bob Jenkins
                                        rjenkins@oracle.oracle.com

