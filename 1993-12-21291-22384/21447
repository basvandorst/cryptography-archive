Newsgroups: sci.crypt
Path: msuinfo!agate!howland.reston.ans.net!pipex!uknet!EU.net!sunic!kth.se!orinoco.nada.kth.se!md85-epi
From: md85-epi@orinoco.nada.kth.se (Urban Koistinen)
Subject: Re: another RNG
Message-ID: <1993Nov25.161818.10604@kth.se>
Keywords: RNG, C, pool
Sender: usenet@kth.se
Nntp-Posting-Host: orinoco.nada.kth.se
Organization: Royal Institute of Technology, Stockholm, Sweden
References: <1993Nov24.050303.5236@oracle.us.oracle.com>
Date: Thu, 25 Nov 1993 16:18:18 GMT
Lines: 66

In <1993Nov24.050303.5236@oracle.us.oracle.com> rjenkins@uucp (Robert Jenkins) writes:

: ---------------------------------------------------------
: A cryptographically secure pseudorandom number generator?
: Generates 10^9 bits in 11.2 seconds on a SPARCstation 10.
: ---------------------------------------------------------

: static void zgen()                /* fill r[] with new values */
: {
:   register u4 a,b,c,i,j,k;

:   a = za;  b = zb;
:   for (i=0; i<SIZE; ++i) 
:   {
:     j = m[(b >> (OMEGA-ALPHA))] + b;
:     k = m[(c = (j >> (OMEGA-ALPHA)))] + a;
:     a = m[i];
:     b = c ^ (j << ALPHA);         /* b is j barrelshifted by alpha */
:     m[i] = b + k;                 /* a's value is no longer in m */
:     r[i] = k;
:   }
:   zb = b;  za = a;
: }

: =======================================================================

: The essence of this generator is looking up a few values pseudorandomly
: from a large pool of unknown values.  As the pool gets larger, more
: bits are used to look up each value.  My best cracking method involves
: guessing 512 consecutive values of c, at 9 bits apiece.  Bleah.

: This passed the distribution, frequency, and run tests for as long as I
: was willing to run them.  So what might be wrong with the generator?
: A simple, secure generator faster than LCG would be a good thing.

This is similar to the last hashing function I posted.
You use two pseudorandom lookups on each pass where I
use one and you use two state registers where I use one.
You shift three times where I shift once.
Your ALPHA is 9 where mine is 10. (just different constant)
I use every other value in the array as result, every other I
leave secret. I apply my function at least twice to get a good
scramble. (64 times for a very good)

My function:
for (i=1<<ALPHA;i--;)
  s[i] += f(i)+g(i,32); /* the last + might be ^ (don't remember) */

#define AM ((1<<ALPHA)-1)
f(i) if ((s[i]&AM)==i) return (0);
     else return (s[s[(i+1)&AM]&AM]);
g(i,n) if (n) return ((s[i&AM]>>(32-n)) ^ g((i+1)&AM,n-1));
       else return (0);

The above is easy to optimize.

">>" is as in your function. All variables are 32-bit unsigned ints.

Your function look good to me.
Might be useful for encrypted swap.

:                                         - Bob Jenkins
:                                         rjenkins@oracle.oracle.com
-- 
Urban Koistinen - md85-epi@nada.kth.se
Stop software patents, interface copyrights:  contact lpf@uunet.uu.net
