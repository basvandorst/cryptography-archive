Newsgroups: sci.crypt
Path: msuinfo!agate!howland.reston.ans.net!noc.near.net!das-news.harvard.edu!das-news!tlb
From: tlb@chardonnay.harvard.edu (Trevor Blackwell)
Subject: Re: Group-based security
Message-ID: <TLB.93Dec18212359@chardonnay.harvard.edu>
Sender: usenet@das.harvard.edu (Network News)
Organization: Aiken Computation Lab, Harvard University
Date: Sun, 19 Dec 1993 02:23:59 GMT
Lines: 55


[Sorry, did I ever write the last post in a hurry. Corrected version
follows.]

bontchev@fbihh.informatik.uni-hamburg.de (Vesselin Bontchev) writes:
> Besides, AFAIK, there are no known attacks against RSA based on the
> fact that you have several cyphertexts which represent one and the
> same plaintext, encrypted with several public keys.

I assume AFAIK stands for "except the well known, very cheap, and easy
to implement one described in, among other places, Weiner, M.J., IEEE
Transactions on Information Theory, 1990." [p.s. Hi Mike] I don't have
the paper in front of me, but I think he cites a reference from 1985,
so it's not a very new idea. (The main point of the paper is to
describe an interesting class of short exponent attacks, valid even
when the message is only encrypted once).

Assume RSA is using e=3 as an exponent, which many implementations do.
Remember, the cost of an encryption is proportional to the log of the
exponent, so most textbooks seem to assume e=3 as the default.

If the proverbial Alice encrypts plaintext M 3 times to get 3
cipertexts c1,c2,c3  

c1 = M^3 (mod n1)
c2 = M^3 (mod n2)
c3 = M^3 (mod n3)

where n1,n2,n3 are 3 different public keys of 3 people you're sending
the message to. If an adversary sees c1,c2,c3, then by Chinese
remaindering, he can compute M. 

Specifically: It's easy for the adversary to find (a Chinese remainder
basis vector) r1,r2,r3 such that 

  r  = 1 (mod n )
   i           i

  r  = 0 (mod n )   i<>j
   i           j

Then, the adversary can compute M^3 = c1*r1 + c2*r2 + c3*r3 (mod n1n2n3). Since
M^3 is less than n1n2n3 (or at least less than O(n1n2n3), so you might have
to try O(1) possibilities), you can just compute 
M = (c1*r1+c2*r2+c3*r3)^(1/3) in the natural numbers, which is fast.

One way to get around this is to ensure that the same message is never
sent twice, such as by adding a random pad to each encrypted message.

Anyone who didn't know this is strongly encouraged to read Wiener's
paper and its references. You won't use e=3 anymore.
--
--
Trevor Blackwell         tlb@das.harvard.edu          (617) 495-8912
(info and words of wit in my .plan)
