Newsgroups: comp.security.misc,sci.crypt
Path: msuinfo!uwm.edu!cs.utexas.edu!usc!elroy.jpl.nasa.gov!decwrl!csus.edu!netcom.com!phr
From: phr@netcom.com (Paul Rubin)
Subject: Re: Proposal for new login authentication method
Message-ID: <phrCHynuz.6B5@netcom.com>
Organization: Netcom - Online Communication Services (408 241-9760 guest)
References: <phrCHwp09.8JA@netcom.com> <2efc9gINN3gb@hancock.cc.williams.edu> <1993Dec12.180912.12713@lokkur.dexter.mi.us>
Date: Mon, 13 Dec 1993 06:40:10 GMT
Lines: 47
Xref: msuinfo comp.security.misc:6855 sci.crypt:21958

In article <1993Dec12.180912.12713@lokkur.dexter.mi.us> scs@lokkur.dexter.mi.us (Steve Simmons) writes:
>95cms@williams.edu (Matt Schroth) writes:
>
>>What if I am on your local subnet and can cause some collision at
>>"just the right time?"  Conceivably, I could "hear" your password but
>>the host you're logging in to would not, so that I'd have a password
>>for later use, if you decided next to try another password.  It'd be
>>nice if this sort of problem could be avoided somehow.
>
>There is only one topology under which this could even theoretically
>work.  You'd have to have your tap physically between the client (the
>machine which generates the ethernet frame containing the password),
>the server, and the client would have to be a fair distance from you.
>At that point you'd have to be able to:
>
>Detect the password-containing frame on the net;
>Generate a short burst of "static" on the net before the frame has
>  finished passing you, corrupting the frame so the destination will
>  reject it.  This implies that the distance between you and the
>  client must be sufficient that the static does not reach the
>  client before he concludes the frame transmission; otherwise the
>  client would detect a collision.  Note also that a frame containing
>  a password is probably the minimal size ethernet frame, further
>  increasing your difficulty.
	[... more difficult stuff]

Hmmm.  One way to defeat this would be for the authentication program
to insist you type two *consecutive* passwords from the one time pad
when you want to log in (call them P1 and P2).  As soon as you
finished typing P1, the login program would disable the entries
for both P1 and P2 in the hash file, but still wouldn't let you
login until you typed P2.  If you typed P2 incorrectly or failed
to type it in a certain amount of time, you'd have to start all over
with two new passwords.  So no eavesdropper could get a useable
pair of passwords before they had been already disabled.  But
this makes for an inconveniently large amount of typing--needing
to type 10 or so random characters is bad enough already.  Typing
twice that many would be awful.

Another way is to actually store the random passwords unreadably
(maybe encrypted) on the remote host.  Then typing first 5 chars or so
of a random password would be enough to let the authentication program
disable it.  But I was hoping to avoid needing to store any secrets on
disk.

Perhaps there is a better simple solution that I'm too sleepy to think
of right now.
