Newsgroups: sci.crypt
Path: msuinfo!agate!library.ucla.edu!europa.eng.gtefsd.com!emory!wupost!waikato!aukuni.ac.nz!cs18.cs.aukuni.ac.nz!pgut1
From: pgut1@cs.aukuni.ac.nz (Peter Gutmann)
Subject: Re: Stopping parallel passphrase search
References: <01H6ZO36UZUW94KMO2@delphi.com> <phrCIso8x.HHz@netcom.com>
Organization: Computer Science Dept. University of Auckland
Date: Wed, 29 Dec 1993 15:28:28 GMT
Message-ID: <1993Dec29.152828.13156@cs.aukuni.ac.nz>
Lines: 47

In <phrCIso8x.HHz@netcom.com> phr@netcom.com (Paul Rubin) writes:

>I think the basic idea is: generate a big buffer full of data based on the
>password, sort the buffer in order to ensure that it all must be kept in
>memory at once (or slow secondary devices), then MD5 the sorted buffer to get
>a key. You might instead mean to MD5 all the sorted passwords separately
>somehow, but I don't think that's as good.  Also, rather than just prepending
>a counter to each of N copies of the passphrase, each piece of the buffer
>should be generated by hashing something depending on the previous piece.
>Otherwise, the attacker could easily generate the N hashed pieces in parallel.
 
I'll offer a dissenting opinion here... it's a very nice idea, but I think you
should be aiming to make it difficult to do custom hardware implementations
rather than trying to out-consume system resources with an attacker.  Let's say
your system will run on a standard peecee with it's generous 640K of memory, of
which you can use (say) 256K for the key setup.  Against this you have
something like the current best CM5 with 1024 processors (maybe the NSA has the
projected 16K-CPU model already, who knows).  This is 1024 40MHz SPARC CPU's
with 32MB of memory per CPU, and all sorts of auxiliary chips for each node
which aren't important at the moment except that you may be able to do
something fancy with the four vector units - it depends on what algorithm you
want to attack.  Memory bandwidth for these units is 512MB/sec per node.  What
you're using to compete against this is maybe a 33MHz '486 with 256K of usable
memory and a memory bandwidth of 32MB/sec.  It just isn't going to happen.
 
Let's take the approach of using special hardware to attack the proposed
system.  You need to:
 
    1. generate n hashes
    2. sort them
    3. hash the lot
 
All of these steps are open to a pipelined implementation which can crank out a
new result every cycle.  Sure, it won't be simple, but it can be done.
 
The approach is a nice idea, but I'd rather try and kill passphrase searches by
making custom hardware impractically complex than by trying to out-consume
system resources with an attacker.  Use lots of serial computation which is
difficult to parallelize/pipeline.  The method I'm using at the moment
repeatedly iterates over a block of data, re-injecting the data back into the
system at each iteration.  Attacking this with custom hardware requires either
iterating with re-injection as the software version does (which kills any
pipelining), or fully unrolling the whole thing, which allows a nice pipelined
implementation... with 16,000 stages (or more, as the iteration count is
user-defined). 

Peter.
