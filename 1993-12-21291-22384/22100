Newsgroups: sci.crypt
Path: msuinfo!uwm.edu!cs.utexas.edu!swrinde!elroy.jpl.nasa.gov!decwrl!netcomsv!netcom.com!phr
From: phr@netcom.com (Paul Rubin)
Subject: Re: Crypto review of Secure Drive wanted
Message-ID: <phrCIA5tE.2BL@netcom.com>
Organization: Netcom - Online Communication Services (408 241-9760 guest)
References: <01H6NEY6KGCI937BF4@delphi.com>
Date: Sun, 19 Dec 1993 11:41:38 GMT
Lines: 70

In article <01H6NEY6KGCI937BF4@delphi.com> MIKEINGLE@delphi.com (Mike Ingle) writes:
>The program accepts a passphrase, which can be up to 255 characters,
>and takes its MD5. This is put through the normal IDEA key expansion
>(code pulled from idea.c in pgp), and each word of the expanded key
>is xor'ed with 0DAE hex. I was told that this last step would eliminate
>weak keys. The expanded key is then loaded into the TSR's key buffer....

I don't think this is such a good idea.  The passphrase is a weak spot
in any such system (because of dictionary attacks etc.).  Also, the
IDEA key should not be the same for every filesystem with the same
passphrase.  If someone captures the IDEA key somehow without getting
the passphrase, such as by seizing your computer while the program is
running, they get all of your data from all of your filesystems
instead of from just one.

I recommend generating a RANDOM encryption key (call it KF) for each
file system.  You would encrypt this random key using the passphrase,
and store the encrypted random key on the disk.  This makes the keys
separate for each filesystem.  It also allows the program to delete
delete the encrypted key if it detects an intruder (e.g. person boots
the machine and doesn't supply the passphrase within a time limit) or
if you hit a "panic button".  Deleting the encrypted key could be done
very quickly and would make the entire disk unrecoverable even if the
attacker beats the passphrase out of you.

For real paranoids, besides generating a random key KF for each
encrypted filesystem, there could be an additional, permanent random
key KR stored in the computer's CMOS RAM (not on disk).  KF and KR
would be XOR'd together to make the actual IDEA key.  Then, someone
trying to read your disk on another computer would not have KR,
stopping dictionary attacks altogether.  If the attacker was foolish
enough to boot your disk instead of just trying to analyze it, the
program would treat the absence of a correct KR as an intruder alert
(see above) and delete KF.  Obviously KR should be optional since you
might *want* some filesystems to be able to work on any computer,
though normally you'd just want to use computers under your control,
so you'd arrange for these computers to all have the same KR in RAM.
Encrypted info on the disk would indicate if KR was needed for that
disk.

Because of the possibility of KF and KR getting erased, either on
purpose or by battery failure or the like, you might want to store
backup copies of these random keys.  The backups could be stored at a
separate location from the computer; if desired, the backup could be
split into several pieces using "shared secret" techniques so you
could give the pieces to trusted friends.  With the two-key system,
the panic button might, at your option, delete only KR and not KF.
Then you'd only have to back up one piece of data.  (True paranoids
would still have it delete both).

>The program uses the first 32 bits of a double MD5 to verify keys.
>The passphrase is MD5ed, then the 16-byte result is MD5ed again, and
>the first 4 bytes of the double hash are written to the disk to
>check whether the correct passphrase was used. This could facilitate
>a precomputation of common passphrases and their double MD5's, but
>there is a lot of known plaintext in the system areas of the hard
>drive, so such an attack would probably be possible in any case.
>A strong passphrase should eliminate the problem.

This is bad because it tells the attacker that your N different
floppies are all encrypted with the same passphrase, or that certain
ones have a different passphrase, or whatever.  It also depends on the
encryption key coming solely from the passphrase, which is bad (see
above).  And finally, there's no point in *ever* needlessly giving
away information about the passphrase.

Instead, why not just encrypt a fixed string and store the encrypted
string on the disk?  If the encrypted fixed string decrypts correctly,
the person has the right passphrase.

