Newsgroups: sci.crypt
Path: msuinfo!agate!usenet.ins.cwru.edu!eff!news.umbc.edu!europa.eng.gtefsd.com!MathWorks.Com!noc.near.net!das-news.harvard.edu!das-news!tlb
From: tlb@chardonnay.harvard.edu (Trevor Blackwell)
Subject: Re: CRC & MD5
Message-ID: <TLB.93Dec20104554@chardonnay.harvard.edu>
Sender: usenet@das.harvard.edu (Network News)
Organization: Aiken Computation Lab, Harvard University
Date: Mon, 20 Dec 1993 15:45:54 GMT
Lines: 51


> The other attack requires finding two messages M1 and M2 that have the
> same hash value, and doing something like sending M1 and later
> claiming you sent M2.  This is a classic "birthday problem", and takes
> an average of SQRT(2**N_bits_in_hash) tries, i.e. 2**(N/2).  
> To be feasible, you not only need to calculate the hashes, you need to
> store them so you can tell if you've got a match.  For MD5, this is
> 2**64 tries, and requires storing somewhere between 24 and several
> hundred bytes per try; since large-capacity tape drives hold between
> 2**32 and 2**40 bytes per tape, this attack is currently quite infeasible,
> but technology may make it feasible in the next few hundred years.

Actually, it's quite feasible. There's a much easier technique than
storing all the keys and comparing them. It what you might call a
'generalized rho attack', that works like Pollard's factoring
heuristic, which in turn works like the O(n) algorithm for deciding if
a linked list is circular.

Define the recurrence

   X[i+1] = Hash(MyMessage:X[i])

where MyMessage is the common part of the two messages, and the :
operator is some form of concatenation or interleaving that puts the
right hand side in some unimportant part of the message. Details
unimportant. 

This recurrence will eventually repeat with some cycle length. By the
Birthday property, the expected cycle length is sqrt(2^N), where N is
the number of bits in the hash function.

You can detect the repetition very easily, something like

X = 0
Y = X;
DO
  X := Hash(MyMessage:X)
  if (X=Y) they we found a match
  i:=i+1
  if (isPowerOf2(i)) then
    Y:=X
END

This takes expected time 2*sqrt(2^N) iterations for a strong hash
function.

p.s. Nifty hack: on a 2's complement machine, isPowerOf2(i) is ((i & -i) == i).
--
--
Trevor Blackwell         tlb@das.harvard.edu          (617) 495-8912
(info and words of wit in my .plan)
