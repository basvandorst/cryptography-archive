Path: msuinfo!agate!howland.reston.ans.net!europa.eng.gtefsd.com!uunet!gatekeeper.us.oracle.com!oracle!unrepliable!bounce
Newsgroups: sci.crypt
From: rjenkins@uucp (Robert Jenkins)
Subject: cycle lengths
Message-ID: <1993Nov29.063616.24048@oracle.us.oracle.com>
Keywords: period sum cycle length
Sender: usenet@oracle.us.oracle.com (Oracle News Poster)
Nntp-Posting-Host: kr2seq.us.oracle.com
Organization: Oracle Corporation
References: <TLB.93Nov24132658@chardonnay.harvard.edu>
Date: Mon, 29 Nov 1993 06:36:16 GMT
X-Disclaimer: This message was written by an unauthenticated user
              at Oracle Corporation.  The opinions expressed are those
              of the user and not necessarily those of Oracle.
Lines: 55

(this was Re: another RNG, random number generator)
In article <TLB.93Nov24132658@chardonnay.harvard.edu> tlb@chardonnay.harvard.edu (Trevor Blackwell) writes:
...
>You need to have _proof_, that for any chosen values of the seed, you
>will not end up with a short-length periodic sequence. I think this
...
>Trevor Blackwell         tlb@das.harvard.edu          (617) 495-8912
>Aiken G9 / Harvard University / 33 Oxford St / Cambridge, MA / 02138

Let an RNG with n bits of internal state be given.  If it is a permutation,
cycle lengths (periods) should be about 2^(n-1), otherwise about 2^(n/2).  
This result does not show that my generator (or any other specific 
generator) has all long cycles, or even ANY long cycles, but it does give 
reason to expect most cycles to be long.


Any RNG is a mapping of internal states to new internal states, f:D->D.
If x is the original state, f(x) is the state after the first transition, 
f(f(x)) after the second and so on.  Define the LIFETIME of f as the 
number of the states before the first repetition.  That is, the lifetime
of f with seed x is the minimum i s.t. f^i(x) = f^j(x) for some j less 
than i.

Given that f has made n transitions without entering a cycle, what is the
probability that the next transition will start a cycle?  Call this g(f,n).
The expected lifetime of f is 
  sum(i=1..#D) (i * (prod(j=1..i-1)(1-g(f,j))) * g(f,i)) .

If f is a permutation (each internal state has a unique preceding state),
then g(f,i) = 1/(#D-i) and the expected lifetime of f is 
  1(1/#D) + 2((#D-1)/#D)(1/(#D-1)) + ...
= 1(1/#D) + 2(1/#D) + ... 
= (#D+1)/2 .

If f is an arbitrary mapping (my generator is not a permutation) then
g(f,i) = i/#D, the sum for the lifetime is 
  sum(i=1..#D) (i * (1-(#D!)/((#D^i)(i!)))),
and the expected lifetime is about 1.25*sqrt(#D).  (I needed to sum the
series on my computer to get this lifetime; so far I can't prove it.)


I tested my generator, and many mutations of it, with small values and
arrays.  These generators, with 4..64 bits of internal state, had 
measurable cycle lengths.  The two bounds (2^(n-1) for permutations, 
2^(n/2) otherwise) both proved very reliable, and much more steady than 
Knuth's run, frequency, and distribution tests.  In particular, 
generators that failed any of Knuth's tests very early still had 
cycles of about the expected length.

A RNG should not be abandoned just because there is no proven lower 
bound on its cycle lengths.  I think unproven cycle lengths are a 
good thing.  They mean the sequences are more unpredictable.  I think
arbitrary mappings are better than permutations for about the same 
reason, although they require twice the internal state to have the 
same cycle lengths.
