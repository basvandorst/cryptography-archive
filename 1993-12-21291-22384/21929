Newsgroups: comp.security.misc,sci.crypt
Path: msuinfo!agate!apple.com!amd!netcomsv!netcom.com!phr
From: phr@netcom.com (Paul Rubin)
Subject: Proposal for new login authentication method
Message-ID: <phrCHwnFq.6LC@netcom.com>
Organization: Netcom - Online Communication Services (408 241-9760 guest)
Date: Sun, 12 Dec 1993 04:35:50 GMT
Lines: 73
Xref: msuinfo comp.security.misc:6834 sci.crypt:21929

PROBLEM: Lately there's been a spate of crackers running "network
sniffing" programs that capture passwords when people telnet into
remote machines.  Sending cleartext passwords across vulnerable
networks (or wireless connections) is a bad idea.  The usual solution
is to use a cryptographic protocol to log in (Kerberos, ARAP, etc.).
The trouble with this is it requires computation at both ends to do
the encryption/decryption.  If you are travelling or something
similar, you might only be able to get access to dumb terminals or
emulators, which cannot encrypt.  You don't want to have to carry a
portable computer everywhere just for things like this.

I have thought up a simple hack which seems to me to be a good
alternative.  It seems to provide most of the advantages of the
SecureID system which does something similar to it but needs special
hardware and a hairy authentication server.  Here goes:

Write a program that generates random passwords (unpronouncable
alphanumeric strings are fine).  The program would print the passwords
on a piece of paper---hundreds of them can fit on a 3x5 card using a
small font on a laser printer--while storing a cryptographic hash
of each password in stored in a file (the "hash file").  The
actual passwords need not ever be written to disk.

A user would run this program to print out a supply of passwords to
carry in his/her wallet, and store the hash file on the remote host
(or on a secure server).

The login program on the remote host, instead of accepting a single
unchanging password, would let the user log in using any password that
hashes to one of the strings in the user's hash file.  Then it would
mark that string in the hash file as no longer useable, so each
password would work exactly once.  That way, a snooper could capture
the password but it wouldn't be of any use to him, while the user
would not need any special hardware except a piece of paper.  As
mentioned a 3x5 card can hold a several months supply of passwords.

Normally the user would just use the first remaining password on his
list and cross it off, but if he didn't have a pencil and forgot which
passwords had already been used, or used some in the wrong order, or
if part of his printout became illegible somehow, he shouldn't be
screwed.  This is why the login program should accept any password
rather than requiring them to be used in order.

Note that the hash file doesn't need to be generated on the remote
host and doesn't need to be transmitted on an unreadable channel or
stored unreadably.  You could generate it on a PC and upload it.
Also, since none of the software involved does actual encryption (only
cryptographic hashes), it should not be subject to to the US crypto
export restrictions.

Caveats:
1) the random passwords should be generated from a cryptographically
strong RNG, at the very least.  The truly paranoid could generate
passwords from sources of physical randomness, print only on
electromagnetically shielded printers, etc.

2) In case a cracker forges packets during the upload process, the
generation program should compute a cryptographic checksum of the
whole hash file and print it out with the passwords.  The login
program would compute and present the same checksum the first
time the user logs in with a newly uploaded hash file.

3) because of the birthday paradox, the random passwords need to
be pretty long, e.g. containing 64 or so random bits.  This would
make them 10 or 11 characters (upper+lower case alphanumerics plus
a couple punctuation).  This doesn't seem too bad--typing them in
would be a slight nuisance, but such long passwords would be hard
for a shoulder surfer to memorize.

4) Obviously, don't let the piece of paper get stolen! 

Comments?  If no one thinks up any holes or improvements, I'll
probably implement this for Linux and post the code.
