Newsgroups: sci.crypt
Path: msuinfo!agate!howland.reston.ans.net!cs.utexas.edu!uunet!newsgate.watson.ibm.com!watnews.watson.ibm.com!yktnews.watson.ibm.com!c1smolin
From: c1smolin@watson.ibm.com (John Smolin)
Subject: Re: more computer shopper challenge
Sender: news@hawnews.watson.ibm.com (NNTP News Poster)
Message-ID: <CGwqsq.EIJ@hawnews.watson.ibm.com>
Date: Mon, 22 Nov 1993 19:14:50 GMT
Disclaimer: This posting represents the poster's views, not necessarily those of IBM.
References: <752376077snx@netacsys.com> <1993Nov8.172303.18937@convex.com> <2bojud$62l@aja.rand.org> <PCL.93Nov22150643@rhodium.ox.ac.uk> <2cqpsc$htk@rand.org> <CGwoJG.oB7@hawnews.watson.ibm.com>
Nntp-Posting-Host: yktclust.watson.ibm.com
Organization: IBM T.J. Watson Research Center
Lines: 67

A repost, with distribution outside of ibm this time I hope.....


In article <CGwoJG.oB7@hawnews.watson.ibm.com>, c1smolin@watson.ibm.com (John Smolin) writes:
|> |> 
|> |> My current guess is that it's option (a): different keys for the two
|> |> messages, using a system like Smolin suggested (4 bits select how much to
|> |> shift the 32-bit word, with a botch that sometimes shifts all the bits
|> |> away).  The problem I have with it is that we don't see enough hex 21
|> |> characters -- if it's really 4 equally likely bits for the shifter, then
|> |> 0x01 should be half as common a mask as 0x00, shouldn't it?
|> |> 
|> |> -- 
|> |> 	Jim Gillogly
|> |> 	Mersday, 2 Foreyule S.R. 1993, 16:37
|> 
|> 
|> I thought about this problem too.  The following code produces the
|> right kind of output.  I'm not saying this is the right choice, but
|> it is an example of a bug that puts out a lot of 0x00's and not a
|> lot of 0x01's etc.
|> 
|> 
|> long RandomSeed;
|> 
|> int mod(long a,long b)
|> {
|> return(a%b);
|> /* here you may need a differt version of mod, depeding
|>  on what your compiler does with negative modulo numbers.....*/
|> } 
|> 
|> int GetRandomNumber( void)
|>   {
|>   int a;
|>  
|>   RandomSeed = MULTIPLIER * RandomSeed + INCREMENT;
|>   a=9+mod(RandomSeed>>4,11);
|>   if(a>=0) return( (RandomSeed >> a )  & 0xff);
|>   else return(0);
|>   }
|> 
|> 
|> 
|> The idea here is that since RandomSeed is signed, it messes up and
|> takes the mod of a negative number, and therefore shifts the
|> right a negative amount once in a while.  I put in explicitly that
|> when this occurs, it just returns a 0, a reasonable assumption for
|> what a compiler might do.  ANSI C has no spec for what should happen,
|> just about anything is allowed I believe. 
|> 
|> My mod function returns  (-9) % 11 as -9, some might return -2, or some
|> positive value.....
|> 
|> I have gotten just about nowhere with this scheme, other than to produce
|> ciphertext that looks to me a lot like secrt1 and secrt2 starting
|> with any plaintext I want.  But that doesn't really help decode it,
|> since a variety of shemes could do the same.
|> 
|> Another thought I had was that if the plaintext is ascii (7 bits) then
|> all of the ciphertext with the 8th bit set has been encrypted with a
|> non-zero character.  The converse is not true, ie not all of the 0x20's
|> in the ouput are due to the extra 0's that the ring makes, some of
|> them would occur even if the encryption worked right.
|> 
|> John
|> 
