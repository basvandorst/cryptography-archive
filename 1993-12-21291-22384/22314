Newsgroups: sci.crypt
Path: msuinfo!agate!howland.reston.ans.net!pipex!doc.ic.ac.uk!decwrl!pa.dec.com!delphi.com!MIKEINGLE
From: MIKEINGLE@delphi.com (Mike Ingle)
Subject: Stopping parallel passphrase search
Message-ID: <01H6ZO36UZUW94KMO2@delphi.com>
Date: Mon, 27 Dec 1993 22:30:04 -0400 (EDT)
X-Received: by usenet.pa.dec.com; id AA28985; Tue, 28 Dec 93 10:56:18 -0800
X-Received: by inet-gw-1.pa.dec.com; id AA21737; Tue, 28 Dec 93 10:53:44 -0800
X-Received: from delphi.com by delphi.com (PMDF V4.2-11 #4520) id
 <01H6ZO36UZUU94KMO2@delphi.com>; Mon, 27 Dec 1993 22:30:04 EDT
X-To: sci.crypt.usenet
X-Vms-To: INTERNET"sci.crypt.usenet@decwrl.dec.com"
X-Mime-Version: 1.0
X-Content-Type: TEXT/PLAIN; CHARSET=US-ASCII
X-Content-Transfer-Encoding: 7BIT
Lines: 28

I'm working on a version 1.1 of secure drive (bug fix, and better
security.) One problem with the present one is the ease of running a
passphrase search. The key is just the md5 of the passphrase, and the
key check bytes are the first 32 bits of a double md5. This allows you
to check passphrases very quickly.

The new version will have a slow passphrase hash to prevent this. It is
easy enough to append a counter to the passphrase, generate many md5's,
and xor them together to produce a necessarily slow hash. But someone
could still use a parallel machine to run the passphrases quickly. One
weakness of parallel machines is that they usually don't have much
memory per CPU. So it should be possible to prevent the parallel attack
by using a hash which has a minimum memory requirement as well as a
minimum time.

What is the best way of doing this? How about using the counter, prepended
to the passphrase, to generate a large number (a few thousand) different
hashes, then sorting the hashes into ascending order, and md5ing them all
in ascending order to produce the final key? To compute this, you would
need a minimum 16 bytes * the number of hashes. This could make it
impractical to use a parallel machine, because each processor would not
have enough local memory to run the algorithm. How much memory is enough?
(i.e. how much do most parallel machines have per processor?) and is the
sorting method a good way to make a hash function with a minimum required
amount of memory? Is there a better way?

--- Mike
   
