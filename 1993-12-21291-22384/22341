Path: msuinfo!agate!howland.reston.ans.net!gatech!concert!rutgers!att-out!cbnewsh!wcs
From: wcs@cbnewsh.cb.att.com (bill.stewart@pleasantonca.ncr.com +1-510-484-6204)
Newsgroups: sci.crypt
Subject: Re: Stopping parallel passphrase search
Message-ID: <CItt1r.LBB@cbnewsh.cb.att.com>
Date: 30 Dec 93 02:17:50 GMT
References: <01H6ZO36UZUW94KMO2@delphi.com>
Organization: NCR, an AT&T Company, Pleasanton CA Field Office
Lines: 101
In-Reply-To: MIKEINGLE@delphi.com's message of Mon, 27 Dec 1993 22:30:04 -0400 (EDT)

[Sorry if this got posted twice.]

There are two main threats you have to worry about, and fortunately
the cheaper, more dangerous threat is easy to block:

1) Somebody takes a list of a billion popular passphrases (Moby Passphrase?:-)
	and crunches it against the data on your machine.
	This is somewhat expensive, but maybe they really want to get you
	and maybe they've got MD-5 in hardware.

2)Somebody takes Moby Passphrase, crunches it through MD-5, and saves
	the results, so they can check the passphrases on *anybody's* machine.

The way to prevent the latter is to make the passphrase encryption
instance-dependent - the old Unix "salt" technique works fine with enough bits.
For example, if you're using MD5 as the passphrase cruncher, when you
initialize the drive, generate a 64-bit random number, and prepend it
to the passphrase before hashing:  H = MD5( salt, passphrase ).
Store the salt on your machine, so you can reproduce it when you need it.
Since 2**64 is too many MD5 tables to store, this kills threat 2.

If you're still paranoid (and they're probably out to get *one* of
your customers in the next 50 years), or if you're worried that
somebody may find a hole in MD5, one way to substantially reduce the
risk of massively parallel hardware-supported search is to use two algorithms.
For example, instead of storing the salt itself, store the salt
encrypted with something password-dependent, such as
	Generate salt1, salt2, randomkey, and encrypt the disk with randomkey
	K1  = MD5(salt1, passphrase)        -- store salt1 
	K2  = IDEA(salt2, encryptkey=K1)    -- store K2
	K3  = MD5(salt1, salt2, passphrase) 
	salt3 = K3 xor randomkey            -- store salt3
	      (salt3 makes it easy to update passphrases without
	      re-encrypting the entire drive, or vice versa.)
	VER = FirstNBits(MD5("Verify", salt2, salt3, K1)) -- store VER

When using the disk drive, you calculate K1, decrypt K2 to find salt2,
and then calculate K3 for use.  Since the Bad Guys are unlikely to
build a key-crunch machine that does both MD5 and IDEA, this forces
them to rent time on TWO keycrunchers.  It also makes your system
secure if MD5 is broken, because it depends on IDEA as well.
On the other hand, if IDEA is broken, you've got more serious problems.
A useful variant, in case anybody else wants to adopt this approach,
is to begin each of the MD5 strings with the name of the application, e.g.
	K1 = MD5("SecureDrive", salt1, passphrase)

If you're also worried about the information leaked by the "that's the
right key" verification, make N be a small number of bits, like 4-8
- this increases the probability of false positives, which are easy
enough to detect when the system is running, because the FAT or
equivalent will be garbage, but which are hard to detect from a key-cruncher,
since it needs even more code and time to calculate this.
If you keep it relatively short, it's also easy to find a different
passphrase that matches the verification check but isn't valid, e.g.
	duressphrase = "Give Bob Dobbs $#####"
where ##### is chosen by brute-force to make the VER code match, but
sets off the self-destruct device, which is probably only useful
against amateurs like the local police, rather than professionals like NSA.

Making it slow enough - ultimately, you've got to use good passphrases.
Going to two algorithms will probably defeat most special-purpose
minimal-memory crunchers, so your major threat becomes fast
general-purpose machines.  You could try your 1000 runs of MD5, sort
the output, and MD5 again approach, but that's really just a scale
factor, trading the amount of crunch time up front for you vs. the
amount of crunch time on the Bad Guy's machine.  Assuming his
technology will gain speed about as fast as yours, you can decide how
long you're willing to wait, and a factor of 1000 buys about 10-15 years.

One good approach is to make it parametric - let the user decide how
many times to crank the MD5s, and store that parameter on disk along
with the salts.  Maybe this year the answer is 1 for most people and
10 for whistleblowers and spies, but two years from now you've upgraded
your 386sx to a Pentium without retiring MS-DOS :-) or getting raided,
so you upgrade the drive to a parameter-10 file system (salt3 makes it
easy to do this in place without needing to re-encrypt the whole drive.)
Or let the user specify the number of seconds, and have SecureDrive pick the
number of iterations when initializing.  (That's probably too big a
hunk of code to bother putting in the run-time; providing a separate
utility that does this would work fine.  Unfortunately, you probably
also don't want to waste space with a passphrase-quality checker
fancier than just a minimum-length check.)

If you want to make things more dynamic, you can play games with salt3,
such as xoring it with some file-dependent data, such as the last 
16 bytes of the disk block containing the FAT, updated every time you
change that block so you can recover correctly next time.
(Assuming Secure-Drive uses IDEA in CBC mode, this should be very volatile.)
(If you do this, you should use a much faster hash for VER, such as a CRC.)
This means that just recording Secure-Drive's parameters isn't enough
for later use, since you can re-encrypt the whole disk while keeping
the same passphrase, with salt3 to store the slack, and they can't
tell just from changes in salt3.)

				Bill

-- 
#				Pray for peace;      Bill
# Bill.Stewart@pleasantonca.ncr.com 1-510-484-6204 fax-6399
# NCR Corporation, 6870 Koll Center Pkwy, Pleasanton CA 94566
# Please reply to this address rather than my news server.
