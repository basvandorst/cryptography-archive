Path: msuinfo!uwm.edu!cs.utexas.edu!asuvax!ukma!n-f-m
From: jedwards@ms.uky.edu (Jonathan Edwards)
Newsgroups: sci.crypt
Subject: Re: help with bit commitment protocol understanding
Date: 21 Nov 1993 11:51:01 -0500
Organization: University of Kentucky, Dept. of Math Sciences
Lines: 30
Message-ID: <2co69l$115@s.ms.uky.edu>
References: <931121.34243.BOBES_PIERRE@delphi.com>
NNTP-Posting-Host: s.ms.uky.edu

BOBES_PIERRE@delphi.com writes:

>I have been rfeading a description of a prtocol that uses a one way function
>for bit commitment and need some help understanding it. The protocol is
>roughly as follows:
>1)Alice generates two random bit strings r1 and r2.
>2)Alice creates a message consisting of the random bit strings and the bit she
>wishes to commit to (or several bits)------ (r1,r2,b)
>3)Alice hashes the message and sends the result to bob as well as one of
>the randome strings, say r1.
>When it comes time to reveal her bit
>4)Alice sends bob the orginal message (r1,r2,b)
>5)Bob hashes the message and compares it and r1 with hash and r1 he received in
>step 3.
>I do not understand why alice must send one of the random strings as well as
>the hash. Why is not comparing the hashes absolute confirmation? Why not work
>the whole protocol with just one random string and the bit, b?
>thanks from a beginner

I think it's to prevent Alice from cheating as follows:

   Alice creates a message (r1,b), hashes it, and sends the result to
   Bob.  Alice then uses her formidable computing power to find an r2
   such that the hash of (r2,~b) is the same as the hash of (r1,b).
   Note that Alice only wants to fix a single bit of the input (~b),
   so the problem may be tractable.

   By requiring Alice to send R1 in step 3), the protocol makes it 
   much less likely that she will be able to find (r1,r3,~b) whose
   hash matches (r1,r2,b).
