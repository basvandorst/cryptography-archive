Newsgroups: sci.crypt
Path: msuinfo!uwm.edu!spool.mu.edu!sgiblab!swrinde!elroy.jpl.nasa.gov!decwrl!netcomsv!netcom.com!phr
From: phr@netcom.com (Paul Rubin)
Subject: Re: Stopping parallel passphrase search
Message-ID: <phrCIso8x.HHz@netcom.com>
Organization: Netcom - Online Communication Services (408 241-9760 guest)
References: <01H6ZO36UZUW94KMO2@delphi.com>
Date: Wed, 29 Dec 1993 11:36:33 GMT
Lines: 81

In article <01H6ZO36UZUW94KMO2@delphi.com> MIKEINGLE@delphi.com (Mike Ingle) writes:

>...someone could still use a parallel machine to run the passphrases
>quickly. One weakness of parallel machines is that they usually don't
>have much memory per CPU. So it should be possible to prevent the
>parallel attack by using a hash which has a minimum memory
>requirement as well as a minimum time....  What is the best way of
>doing this? How about using the counter, prepended to the passphrase,
>to generate a large number (a few thousand) different hashes, then
>sorting the hashes into ascending order, and md5ing them all in
>ascending order to produce the final key? To compute this, you would
>need a minimum 16 bytes * the number of hashes. This could make it
>impractical to use a parallel machine, because each processor would
>not have enough local memory to run the algorithm. How much memory is
>enough?  (i.e. how much do most parallel machines have per
>processor?) and is the sorting method a good way to make a hash
>function with a minimum required amount of memory? Is there a better way?

This is a very clever idea, thanks for posting it.  I think the basic
idea is: generate a big buffer full of data based on the password,
sort the buffer in order to ensure that it all must be kept in memory
at once (or slow secondary devices), then MD5 the sorted buffer to get
a key.  You might instead mean to MD5 all the sorted passwords separately
somehow, but I don't think that's as good.  Also, rather than just
prepending a counter to each of N copies of the passphrase, each
piece of the buffer should be generated by hashing something depending
on the previous piece.  Otherwise, the attacker could easily generate
the N hashed pieces in parallel.

I don't think it makes much sense to ask how much memory most parallel
machines have per processor.  If you're worried about such attacks,
you might as well assume the attacker is using purpose-built hardware.
And the amount of memory per processor will increase as technology
progresses, just like PC memory sizes have.

Therefore, I think the buffer size should be chosen to be as large as
possible, within the constraints of fitting in the user's PC, and
making the whole operation run acceptably fast.  This will vary
depending on the size and speed of the machine, of course--i.e., the
buffer size should be a user controlled parameter.  (It could be
automatically determined by default, but should be manually settable
because the user might want to use the volume on another machine).  Of
course this means that if the user changes the setting, the encryption
key generated by any given passphrase will also change.  So (sorry for
sounding like a broken record), this means the passphrase-generated
key should not be used to encrypt the whole volume, but rather, to
encrypt a per-filesystem key that is generated randomly, as discussed
in the "security review" thread.  Of course, I hope you do this anyway
for the other reasons described there too.

For concrete numbers: I'd say go ahead and use all the available DOS
memory for passphrase crunching, you'll only need it for a few
seconds.  This is 500-600k on most dos machines, but typically about
100k on the HP-100LX.  You could also use EMS memory if that's not too
hard.  Sooner or later it will be desirable to do this but for now
500k seems like enough.

================================================================

Regarding computation time: one perennial problem is that cheap special
hardware can do many crypto calculations much faster than software
even on fancy PC's.  DES is a case in point and I think MD5 has
similar properties.  So the attacker can test passwords with special
hardware a lot faster than the SD program can--and it's not nice
for users to make SD take several minutes to accept a password,
just in order to slow down hardware-based attacks.

I think an interesting challenge for sci.cryppies is to figure out a
passphrase crunching function that can be done almost as fast in
software on fast PC's (i.e. within an order or two of magnitude) as in
hardware.  My best idea so far is to use lots of floating point
arithmetic, since the fpu's on fast PC's approach the speed of the
best special hardware, and fpu's are complicated enough that massive
parallelism couldn't be made cheaply (for now), i.e. you can't put
1000 of them on a chip.  Of course the function should require serial
computation.  One that comes to mind is numerically integrating some
chaotic DE system over many steps, from starting parameters generated
by the passphrase (ensuring that the attacker cannot cut corners in
implementing the exact roundoff properties of the PC's arithmetic).
But maybe someone else can suggest something more, well,
cryptographic.  Comments?
