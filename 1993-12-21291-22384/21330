Newsgroups: sci.crypt
Path: msuinfo!netnews.upenn.edu!newsserver.jvnc.net!gmd.de!xlink.net!howland.reston.ans.net!europa.eng.gtefsd.com!uunet!newsgate.watson.ibm.com!yktnews.watson.ibm.com!c1smolin
From: c1smolin@watson.ibm.com (John Smolin)
Subject: more computer shopper challenge
Sender: news@yktnews.watson.ibm.com (NNTP News Poster)
Message-ID: <CG6qD5.11o2@yktnews.watson.ibm.com>
Date: Mon, 8 Nov 1993 18:07:53 GMT
References: <752376077snx@netacsys.com> <2bgtnv$mpm@aja.rand.org>
Nntp-Posting-Host: yktclust.watson.ibm.com
Organization: IBM T.J. Watson Research Center
Lines: 59


In article <2bgtnv$mpm@aja.rand.org>, jim@rand.org (Jim Gillogly) writes:
|> Question: How many excess zeroes are there in the key stream?
|> 
.....stuff deleted....
|> see whether we get consistent estimates.  Here are the results for a few:
|> 
|> 			Excess 0's
|> 			per this
|> 			many bytes
|> 	Letter  E(freq) Sec1 Sec2
|> 
|> 	space  16.70%   22   17
|> 	   e    9.95%   20   26
|> 	   t    6.64%   16   16
|> 	   a    5.97%   25   2
|> 	   o    5.78%   22   18
|> 	   i    5.11%   14   22
|> 	   n    5.43%   20   23
|> 	   s    4.72%   38   19
|> 
|> 		mean:   22   20
|> 
|> Perhaps one could get a better estimate by weighting these, or by taking
|> more letters, but the consistency is good enough to give some confidence


Qeustion:  What sort of algorithm has a bug that produces this characteristic?

Notice also this:  For the combined secrt1 and secrt2 the character 0xd0 is
the most common character outside of the usual ascii range.  Originally
I figured that this must mean the plaintext was not ascii, but what about
the idea that not only does the broken scheme put too many 0's in, it also
puts in too many 0xf0's.  Because

0xf0 xor 0x20 = 0xd0    !

        (space)

By my calculations code must have a bug that not only puts out 0  1/20th of the
time, but also puts out 0xf0 1/128th of the time.  Note also that 

1/32 + 1/64 = 1/21.33  

so maybe we have something like this:

1/32  output 00
1/64  output 00
1/128 output f0

Does this give anyone any ideas about what the bug is?


Another thing that the sample cipher.c program suggests is that the writer
hasn't heard of using 'unsigned' in front of his longs.  Realize that a 
signed number modulo 256 can return an answer from +255 to -255 !

John
email to smolin@vesta.physics.ucla.edu (don't believe the header yet!)
