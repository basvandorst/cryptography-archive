Newsgroups: sci.crypt
Path: msuinfo!uwm.edu!math.ohio-state.edu!cs.utexas.edu!uunet!mnemosyne.cs.du.edu!nyx10!colin
From: colin@nyx10.cs.du.edu (Colin Plumb)
Subject: Re: Crypto review of Secure Drive wanted
Message-ID: <1993Dec19.195005.13505@mnemosyne.cs.du.edu>
X-Disclaimer: Nyx is a public access Unix system run by the University
 	of Denver for the Denver community.  The University has neither
 	control over nor responsibility for the opinions of users.
Sender: usenet@mnemosyne.cs.du.edu (netnews admin account)
Organization: Nyx, Public Access Unix at U. of Denver Math/CS dept.
References: <01H6NEY6KGCI937BF4@delphi.com> <9312191146591.davesparks.DLITE@delphi.com>
Date: Sun, 19 Dec 93 19:50:05 GMT
Lines: 41

In article <9312191146591.davesparks.DLITE@delphi.com>,
Dave Sparks <davesparks@delphi.com> wrote:
> >> This is put through the normal IDEA key expansion (code pulled from
> >> idea.c in pgp), and each word of the expanded key is xor'ed with 0DAE
> >> hex. I was told that this last step would eliminate weak keys.
>
>Interesting idea.  (No pun intended.)  I'm still looking for some info on
>IDEA, like a "validation suite" and some clues as to what constitutes a
>"weak key" in IDEA.

Get some IDEA code and test your against it.  The reference source is
on isibee.isi.ethz.ch.  The nice thing about crypto code is that, since
it amplifies errors like mad, any error in implementation tends to show
up VERY fast.  (With IDEA, you have to test for the zero in software,
since that's generally done with special-case code.)

Regarding weak keys, they are described in a paper by Joan Daemen,
Rene' Govaerts and Jook Vandewalle of the Katholieke Universiteit Leuven
in Belgium.  They are a set of keys with a lot of zeros is special places.

These zeros produce a lot of zero or one internal subkeys in the
multiplication operations (remember that in IDEA, a zero multiplication
subkey really means -1) which lets you find some linear dependencies
between input and output.  They're spectacularly unlikely to occur by
chance.  The largest class found requires 77 zero bits (in positions
0-25, 41-71, 84-98 and 124-127, if you care), which means that if every
person on the planet (2^32) were to generate a thousand keys a second
(2^10) for a thousand years (2^35 seconds), you would expect *one* of
those keys to be weak.  If you only need a measley trillion keys, the
odds of your generating any weak ones is on the order of your odds
of getting killed in the next 24 hours by lightning.

>As for XORing the key, since the XOR is a reversible operation, wouldn't
>XORing a key be as likely to create a weak key as cure one?

The XOR is applied to the *expanded* key.  This has the result that zeros
in the 128-bit "user" key don't map onto zeros in the expanded working
key.  It's really belt-and-suspenders overkill, but what the hell, this
is crypto.  Paranoia goes with the territiry.
-- 
	-Colin
