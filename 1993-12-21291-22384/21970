Newsgroups: sci.crypt
Path: msuinfo!agate!howland.reston.ans.net!pipex!zaphod.crihan.fr!jussieu.fr!univ-lyon1.fr!swidir.switch.ch!scsing.switch.ch!ubilab!svelte.flur.zuerich.ubs.ch!wsdavros!zhmhd
From: zhmhd@zh014.ubs.ubs.ch (Mihailescu Preda)
Subject: Generate provable primes
Message-ID: <1993Dec13.152704.16451@zh014.ubs.ubs.ch>
Sender: news@zh014.ubs.ubs.ch
Nntp-Posting-Host: wsdavros.flur.zuerich.ubs.ch
Reply-To: zhmhd@zh014.ubs.ubs.ch
Organization: Union Bank Switzerland, CH
References: <1913@beacon.rain.com>
Date: Mon, 13 Dec 1993 15:27:04 GMT
Lines: 112

In article 1913@beacon.rain.com, Ted.Rolle@f36.n105.z1.fidonet.org (Ted Rolle) writes:

> Would you give out the algorithm here?  Along with some C code??
> 

Hello Ted & Others!

I was thick at home. I am back with two news: a bad one and a good one!

The good one: No, I will not provide C code, for two reasons. It does not only depend
on me and it is irrelevant: my code is not optimal, and if you read the algorithm and
use your favorite long integer ingredients (I used PARI library, public domain, don't
know the address but someone out there surely will!) a nice robust implementation is 
less than 100 lines of code - you can do it and spare ftp.
The bad one: I shall give the algorithm description, so if you are interested, you have
to read through it.
You can implement different flavours of the same basic ideas of the algorithm: I shall
point out possible variants and let it up to anyone to consider his own optimization
criteria.

I. Prerequisites.
-----------------

1. Lemma (Morrison ?). Let n be an integer and F be a completely factored part of n-1.
If for all primes q|F (i.e. q dividing n), there is an integer a_q with:
(i) a_q ^(n-1) = 1 mod n
(ii) a_q ^((n-1)/q) \neq 1 mod n
then any prime r|n is of the shape r=k.F+1, with k integer.

Consequences:
2. If F > sqrt(n) and the premises of 1. hold, n is prime (i.e. proved, no doubt -
sorry for precising this).
3. (The Quisquater cubic root trick) If premises of 1. hold, F > cubicrt(n) and
n'=(n-1)/F, s=n' mod F and t=n' div F so that (s^2-4.t) is not a perfect square, then
n is a prime.
Idea: In this case, if n is composite, it is a product of exactly two primes, say
aF+1 and bF+1. Their product is t and their sum is s, so a and b exist (i.e. n is 
composite exactly when the discriminant s^2-4t is a perfect square).

II. Algorithm
_____________

 You want a prime N with n bits. 
A. Start with a completely factored F with more than
n/2 bits (if you use 2. for proving primality) or more than n/3 bits - if you use 3.
F can be in practice one single prime, or a product of two or more primes - these are
flavours: criteria are efficiency and distribution of the primes generated. One single 
prime is most simple and I prove for this choice, that, for instance for n=384, the
algorithm produces more than 1/2000 of all primes with 384 bits (i.e. ~2^376/2000
primes!) and their distribution is close to uniform, in the sense that the probability
ratio between the most probable and the less probable prime is ~log(N) = 266. Compare
this to 2^376/2000 ...
Ok. In order to get F, you obviously make recursive use of this algorithm, until the 
number of bits in the primes seeked is low enough, so  that trial division is possible.
B. Throw a random k, such that 2kF+1 has n bits.
C. Seek a prime in the *arithmetic progression* N_m = 2.k.F+1+m.(2.F). Here m is a
 parameter, which goes 0,1, ... until N_m can be proved prime. To do this,
C.a. Choose an upper bound M for the values of m (seek interval). In practice,
something between 3n and 5n will do (I never needed more than 3n but did get close to
this bound!).
C.b. For all primes p<P (an upper bound with optimum about 2^18 - pretty close to an 
heuristic estimate found in a contribution to this group) compute R_p=N_0 mod p and
r_p = 2F mod p.
Now you do Eratosthenes SIEVing: for all p, *mark* those indices 0<m<M for which
R_p + m.r_p = 0 mod p. The mark is unique (independent of p). This can be done by cheap
arithmetic modulo p. After crossing the pimes <P, all N_m for marked m are divisible by
some small prime. Erase them from your list of prime candidates (Of course, you do not
carry a real list of candidates, only of the indices m for which N_m is a candidate.)
C.c. Let m be the first in the sieved list of candidates. Do following:

C.c.1. Check 2^(N_m-1) = 1 mod N_m. If not true, get next m and repeat C.c.1.

C.c.2. For all primes q|F (in particular for q=F if F is prime) check:
	2^((N_m-1)/q) \neq 1 mod N_m. If this is not true (you are really unlucky, this
	should happen with probability 2^(-q)) get next m and go to C.c.1.

C.c.3. If you use consequence 2, N_m is proved prime at this point stop.
       If you use consequence 3, check the discriminant issue. If the discriminant is 
       no perfect square, N_m is proved prime: stop. Otherwise, next m and go to C.c.1.

That finishes the algorithm description.

III. Comments
_____________

1. The number 2 is used as base - rather than a random base - because exponentiation
base 2 is particularly cheap on a computer ... and you loose nothing, since you end
up with a primality proof!

2. If the issue of test C.c.2 is not true for some q (very improbable, as said), you acually need not skip to the next m, but first try some more bases (3, 5, 7, etc ...).
I let the reader think out the (simple) details for this scarce case.

3. The cubic root trick might look more complicated, but it has the advantage of making
   the recursion steeper. How do you prove a discriminant d (=s^2-4t) is not a perfect
   square? Either (i) take the integer part of the square root and show its square is
   not d. Or (ii) Make a list of small integers p, with product > d. Check that d is 
   not a square modulo p for at least one prime in this list (you actually stop as soon
   as one such prime is found: then d is no perfect integer square). If no such prime
   is found, d is surely a perfect square. If the list of primes in (ii) is too long,
   one can also (iii) do the same as in (ii), only for a subset of the primes. If d is
   not a perfect square modulo one such prime, the primality proof is finished, so 
   you do not produce unproved primes. But if d is a square for all the primes in the
   subset, it is not certain that d is an integer square, so you might loose a prime.
   Make your own choice as to which method to use!  

Have fun and feel free to ask any question!
PM

Note: I shall not provide a paper for the moment, since I am working on an upgrade
with sharper estimates of the analytic number theory part proving the facts about
the distribution of the primes produced. This has no influence on the algorithm itself.

