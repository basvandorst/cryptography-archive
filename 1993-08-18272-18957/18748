Newsgroups: sci.math.num-analysis,sci.math,sci.crypt
Path: msuinfo!agate!howland.reston.ans.net!europa.eng.gtefsd.com!uunet!decwrl!pa.dec.com!e2big.mko.dec.com!peavax.mlo.dec.com!3d.enet.dec.com!roth
From: roth@3d.enet.dec.com (Jim Roth)
Subject: Re: Shift Register Taps for Length 64
Message-ID: <1993Aug20.001316.6418@peavax.mlo.dec.com>
Sender: usenet@peavax.mlo.dec.com (USENET News System)
Organization: Digital Equipment Corporation
Date: Fri, 20 Aug 1993 01:00:47 GMT
Lines: 46
Xref: msuinfo sci.math.num-analysis:9760 sci.math:50356 sci.crypt:18748


In article <1993Aug19.151156.15619@ast.saic.com>, agnew@actd.saic.com () writes...

>I'm trying to find shift register taps other than the (64,4,3,1,0) that I
>got from Numerical Recipies. I need anoother maximal length sequence with more
>non-zero coefficients. I am using the parallel algorithm (i.e. xor with 64 bit word
>and rotate left one bit). I would like as many as half of the coefficients to be non
>zero, but I'd settle for just getting 1 or 2 in the upper 32 bits or better yet at least one in each byte. I'm trying to generate sequences in which many bits change on
>each shift. I don't have access to Watson or even Peterson although, if I remember correctly, Peterson and Berlycamp just give the minimal tap polynomials in order
>to conserve xor gates in the conventional SR implementation. Thanks for any help.

You'll find that published tables tend to focus on very sparse
polynomials; an exception is some of the tables in Peterson, but these
are only "dense" for low degree polynomials.

You're probably best off writing a little program to test for primitivity,
since even a simple minded program should quickly find primitive polys
for such a low degree as n = 64.  Just populate with random bits and
test until you find some examples.

The procedure to use is to first test if x^(2^64) mod p(x) == x.
This is easy to do by successive squaring mod your p(x), which
can be done with shifts and xors in a pair of unsigned 32 bit
integers.

If this passes, then since 2^64 - 1 is not prime, you have to
do a further check that x^((2^64 - 1)/q) mod p(x) != 1 for each
prime divisor q of 2^64.  Again, use successive squaring and
multiplying; one does not loop 2^64 times :-)

In fact, generating lists of prime divisors is more of a headache
than programming these tests.

For what it's worth, the prime divisors of 2^64-1 are

    (3) (5) (17) (257) (641) (6700417) (65537)

You can check your procedure against the sparse example you
mentioned, as well as by checking that a bit reversed poly you
find also passes the test.

Alternatively, if you have access to a symbolic algebra system, just
use a primitive polynomial test on randomly generated polys till
you find one!

- Jim
