Newsgroups: sci.crypt
Path: msuinfo!agate!howland.reston.ans.net!europa.eng.gtefsd.com!uunet!pipex!uknet!comlab.ox.ac.uk!pcl
From: pcl@ox.ac.uk (Paul C Leyland)
Subject: Re: Real-Time Encryption
Message-ID: <PCL.93Aug16095213@rhodium.ox.ac.uk>
In-reply-to: doug@midget.towson.edu's message of 14 Aug 1993 19:08:00 GMT
Organization: Oxford University Computing Services, 13 Banbury Rd Oxford OX2
	6NN
References: <Gene_Ruebsamen.041d@republik.fidonet.org>
	<DOUG.93Aug14150800@midget.towson.edu>
Date: 16 Aug 93 09:52:13
Lines: 40

In article <DOUG.93Aug14150800@midget.towson.edu> doug@midget.towson.edu (Doug McNaught) writes:

      I am working on a serial.device driver for the Amiga Computer.  What it
      does it take ANY ASCII data passing through the serial device and encrypts
      it.  The reciever would have the same serial.device and would have to have
      the same password file to read the data. I was planning on using either
      IDEA or the DES algorithm, as I can get very decent speed from both
      algorithm's running on an Amiga 3000 (Motorla 68030) or Amiga 4000 (Motorola
      68040).  What I wanted to know is should I encrypt each character as it
      passed through the serial device, or would it be better to buffer the
      output and encrpyt all the buffered data every 5 seconds or so?..

      Can a single character be encrypted successfully?  I tried with the IDEA
      algorithm to encrypt the letter h, and the ciphertext was 12 bytes!

   Well, aren't IDEA and DES both block ciphers? DES for example works on
   8-byte blocks, so if you encrypt a single character the encryption
   routine will add 7 bytes of nulls and generate 8 bytes of ciphertext
   (which if converted to a printable-ASCII representational a la Unix
   crypt() will occupy 12 bytes). So use the natural block size of your
   algorithm as your chunk size.

Unfortunately, this method will mean that your program reading from the
serial port will not be able to acquire any input until a block of data
has been encrypted.  Better is to generate a block's worth of random
numbers from your encryption algorithm (start off with block generated
from the password or whatever) and then XOR each incoming character with
the succcessive bytes of the block.  Keep hold of the characters so that
when the block is exhausted, yu can use them to key the next block.
There are other variants on this scheme for converting a block cipher to
a stream cipher, but you get the idea.

Paul

--
Paul Leyland <pcl@oxford.ac.uk>          | Hanging on in quiet desperation is
Oxford University Computing Service      |     the English way.
13 Banbury Road, Oxford, OX2 6NN, UK     | The time is come, the song is over.
Tel: +44-865-273200  Fax: +44-865-273275 | Thought I'd something more to say.
Finger pcl@black.ox.ac.uk for PGP key    |
