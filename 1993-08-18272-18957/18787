Path: msuinfo!uwm.edu!vixen.cso.uiuc.edu!moe.ksu.ksu.edu!engr.uark.edu!news.ualr.edu!grapevine!john.eichler
Newsgroups: sci.crypt
Subject: random number generation
Message-ID: <9784.517.uupcb@grapevine.lrk.ar.us>
From: john.eichler@grapevine.lrk.ar.us (John Eichler) 
Date: 21 Aug 93 15:35:00 GMT
Reply-To: john.eichler@grapevine.lrk.ar.us (John Eichler) 
References: <25491kINN905@twain.ucs.umass.edu>
Distribution: world
Organization: The GrapeVine BBS *** N. Little Rock, AR *** (501) 753-8121
Lines: 69


Part 1 of 3

A few weeks ago I had a need to generate some random numbers. Rather
than use the normal C rand() function, I decided to get a little bit
more creative and thought I would share the results with those of you
who are interested in such matters.

I first inputted a series of random (?) keystrokes and timed the
intervals between each such stroke (in much the same manner as PGP
does for key generation).  This resulted in the obtaining of 26 dif-
ferent values which hopefully was close to being random in nature.
This provided a 'seed' value.  (The reason for using 26 values was
because that provided 52 bytes which were to be used for shuffling
a deck of cards.  No other particular significance.)  The results
of this input was as follows:

2828  7a4  a7a  4bc 893f  a79  4d0 13a5  f49  470  c60  46f 126a
87a5 1e7e 16da  93f  60a  127  4cf 860a  a66  c74  8df  45c  7a5

I then regarded pairs of values (i.e., 4-byte groupings) as making
up 13 (once again no black magic value) entries in a simple array.

giving: 282807a4  0a7a04bc  893f0a79  ...  0c7408df  045c07a5
entry1    entry2    entry3         entry12   entry13

I next started at byte 0 (the leftmost above, i.e., 28) and calcu-
lated a standard ethernet 32-bit CRC over all 52 bytes (ending with
byte 51, i.e., a5).  This CRC then represents contributions from
all the bits of the 52 bytes.

Next I substituted the 32-bit CRC just found for a new entry1 so
enrty1 was no longer 282807a4.  Next I calculated another new CRC
starting at byte 4 (i.e., 0a in entry2 above) which once again
covered not only the remaining bytes through entry13 but looped
around to include all the new 4 bytes of the new entry1 (the last
CRC found).  The second new CRC found in this way was substituted
for entry2 above.

This procedure was followed until all the original 13 4-byte entries
had been replaced by CRC covering 52 bytes (since I wrapped around).
After one pass through this 'mixing' procedure, the result look as
follows:

10b 6dd9 7968 f597  95d 4404 e1a1 95af 91d5 e7c5 cea4 591c c5f1
525d 6247 a4b6 5df8 bd2c 5e35 fd3d 5da2 2c07 9bcf 6346 84ab 5cd0

Since I was only interested in values between 0 and 51 for my applica-
tion, I used a bit mask to limit the value to the rightmost 6 bits of
each byte and simply discarded any values between 52 and 63.  Further-
more, since 52 is the number of upper and lower case alpha characters,
I could substitute alpha characters for each of the byte bit values
I had found.  (Note: I didn't discard the original 8-bit byte values
since I needed these later but rather did this procedure in temporary
storage.)  Each line below represents the 52 values I would get from
one 'mix' of the above data values using the 'mixing' procedure out-
lined above.  I did this for a total of 32 lines (32 mixes) to see
if I could see any patterns which might be obvious visually but not
computationally.

(to be continued in next message)

---
. SM 1.06 ----- . Email: john.eichler@grapevine.lrk.ar.us

----
The GrapeVine / Ferret Face BBS  (501) 753-8121
PGP Distribution Site, UseNet, RIME, ThrobNet, MediaNet, U'niNet, ForthNet
RecoveryNet, MetroLink.  Putting Communications back in Telecommunication
