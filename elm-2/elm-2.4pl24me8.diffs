This is a patch for elm-2.4pl24me8 against elm-2.4pl24.
Use patch -p1 < this_file to apply it.


diff -c /dev/null elm-2.4pl24me8/ANNOUNCE.ME
*** /dev/null	Thu Sep 21 15:27:01 1995
--- elm-2.4pl24me8/ANNOUNCE.ME	Thu Sep 21 15:25:05 1995
***************
*** 0 ****
--- 1,280 ----
+ ELM 2.4 PL24 ME8
+ 
+ This is an announcement for Patchlevel ME8 for Elm 2.4pl24.
+ 
+ The most current version of this document is available via the web:
+ http://www.cs.hmc.edu/~me/elm/announce.html. You can also visit the "ME" home
+ page at http://www.cs.hmc.edu/~me/elm/me.html.
+ NOTE THAT THIS ADDRESS HAS CHANGED FROM THE PREVIOUS ANNOUNCEMENT!
+ 
+ What's new:
+ 
+    * Anonymous remailer support (plus chaining, PGP encryption & MIME support)
+    * mime.types file when guessing the content-type of an attachment.
+    * Forwarded messages can be attached as MESSAGE/RFC822 data
+    * Supports extraction of PGP public keys directly
+    * Support for application/pgp type inside multipart/mixed and message/rfc822
+      messages
+ 
+ Changes from ME7a:
+ 
+    * Replying to MULTIPART messages now works correctly.
+    * MESSAGE/RFC822 is now properly supported.
+    * BINARY encoding is better supported.
+    * Fixed bugs with BASE64 and QUOTED-PRINTABLE encodings.
+    * Enhanced attachment menu
+    * Improved interface for PGP encrypting messages
+ 
+ Where to get it:
+ 
+    * ftp://cs.hmc.edu/pub/me/elm-2.4pl24me8.tar.Z
+    * ftp://cs.hmc.edu/pub/me/elm-2.4pl24me8.tar.gz
+    * ftp://cs.hmc.edu/pub/me/elm-2.4pl24me8.diffs.Z
+    * ftp://cs.hmc.edu/pub/me/elm-2.4pl24me7a-8.diffs.Z
+ 
+ -OR-
+ 
+    * ftp://uiarchive.cso.uiuc.edu/pub/packages/mail/elm/me/elm-2.4pl24me8.tar.Z
+    * ftp://uiarchive.cso.uiuc.edu/pub/packages/mail/elm/me/elm-2.4pl24me8.tar.gz
+    * ftp://uiarchive.cso.uiuc.edu/pub/packages/mail/elm/me/elm-2.4pl24me8.diffs.Z
+    * ftp://uiarchive.cso.uiuc.edu/pub/packages/mail/elm/me/elm-2.4pl24me7a-8.diffs.Z
+ 
+ -------------------------------------------------------------------------------
+ 
+ STATUS
+ 
+ These patches are not an official release of Elm, and are not supported by the
+ Elm Development Group. Features included in this patch may or may not be
+ included in the next official release of Elm. I can say for certain that the
+ PGP portion will not. I am hoping that my MIME patches will be included in the
+ 2.5 release, but that is still an open question. Should the 2.5 release appear
+ without these patches, I plan on "porting" them and using 2.5 as the base.
+ -------------------------------------------------------------------------------
+ And now on to the interesting stuff...
+ 
+ PGP SUPPORT
+ 
+ [This work was inspired by pgpelm which was started by Mic the Missing and
+ furthur developed by Ken Cox (kenc@viewlogic.com). This version is a complete
+ rewrite of that system but looks very similar.]
+ 
+ Features include: mark on folder menu showing PGP encrypted messages and public
+ key blocks, encryption/signing of outgoing messages, decrypting/signature
+ check, mailing public key blocks, and extracting public key blocks from
+ messages. Special feature allows you to have ELM keep track of your PGP
+ passphrase so you only need to enter it a minimal number of times.
+ 
+ I have written a primer for using PGP with this version of ELM which can be
+ found at http://www.cs.hmc.edu/~me/elm/pgp.html. It contains everything you
+ need to know about how to use PGP with ELM.
+ 
+ MIME SUPPORT
+ 
+ With this version of Elm, the need for metamail is much less since it can now
+ handle the MIME encodings and multipart/* messages internally. The only case in
+ which metamail is called is when there is a content-type which Elm does not
+ understand (eg. image/*, audio/*). In most cases you will probably only receive
+ this as attachments anyway, so you might still not require metamail.
+ 
+    * Incoming Attachments
+ 
+      Access to individual portions of a MIME mulitpart message can be accessed
+      via the "Attachments" menu (type 'v' in the index menu). This brings up a
+      menu listing the attachments for the current message. You then have the
+      option of viewing or saving the attachment.
+ 
+    * Outgoing Attachments
+ 
+      In addition to using the "[include ..." construct when editing your
+      message, there is now an "Attachments" menu accesible from the "Send" menu
+      (it is abbreviated to "a)tt" because of space problems). Simply type "a"
+      to get into the Attachments menu. You may then add/delete/edit/modify
+      attachments. When possible, Elm will attempt to guess the correct
+      Content-Type (based on file extension, see the "mime.types" section below)
+      and Content-Transfer-Encoding.
+ 
+    * Automatic encoding for outgoing messages.
+ 
+      If Elm finds 8bit or control characters in text files to be attached, it
+      will automatically encode them QUOTED-PRINTABLE if Elm has been compiled
+      without the 8BITMIME option (meaning that your MTA isn't 8bit clean). This
+      behavior can be overriden with the "noencoding" elmrc option (see below)
+      in cases where your sendmail is 8bit clean, but doesn't support the
+      -B8BITMIME option.
+ 
+    * mime.types file
+ 
+      Elm now mime.types file which maps filename extensions to Content-Type
+      field when sending attachments via the new attachment menu. The format of
+      these files is as follows:
+ 
+      <extension> <content-type>
+ 
+      A hash character ('#') may be used as a comment, but it must be in the
+      first column of a line.
+ 
+      Here is an example of mime.types file:
+ 
+      # This is a commented line
+      html    text/html
+      tgz     application/octet-stream; type=tar; conversions="x-gzip"
+ 
+      Note that the content-type field is not limited to just the type/subtype
+      part; in can also include suplementary information.
+ 
+      Elm first looks to see if the user has a ~/.elm/mime.types file. If there
+      is no match, Elm will then try to read the system types file (typically
+      /usr/local/lib/elm.mimetypes). Failing that, Elm has a few builtin types
+      that it understands.
+ 
+      You might want to pick up a copy of my mime.types file as a starting point
+      for either your personal or system file at
+      http://www.cs.hmc.edu/~me/elm/mime.types.
+ 
+ REMAILER SUPPORT
+ 
+ This version of Elm has the ability to prepare messages for use with anonymous
+ remailers (if you don't know what that is, read alt.privacy.anon-server for
+ more information).
+ 
+ Elm gets its information about anonymous servers by either fingering
+ "remailer-list@kiwi.cs.berkeley.edu" or by reading ~/.elm/remailers (if this
+ file exists, it overrides the "finger" so you can still use this feature even
+ if you are not directly net connected.)
+ 
+ To send an anonymous message, first compose your message as you normally would,
+ entering the name of the person who should ultimately receive the message as
+ the To: address. Then, at the "send" menu, you can type "r" to get into the
+ "remailer" menu.
+ 
+ There are several options in this menu: remail, chain, path and encrypt.
+ The "remail" option indicates whether or not the current message will be
+ remailed.
+ 
+ "chain" indicates how many servers this message should be sent through (the
+ higher chain is, the more secure, but the tradeoff is how long until the
+ receiver gets the message).
+ 
+ "path" is where you can specify which servers you would like this message to go
+ through (this overrides "chain"). You can specify a semi-colon (";") separated
+ list of server "nicknames" here.
+ 
+ "encrypt" means that Elm should encrypt your messages with the PGP public key
+ of server you are remailing through (note that if chain > 1 or there is more
+ that one server in "path", Elm will do the "right" thing and call PGP multiple
+ times for each hop).
+ 
+ Once the desired options are set, you can quit the menu and send the message.
+ What you see next will vary... If you are a PGP user and set encrypt=TRUE in
+ the remailer menu, you will see the call(s) to pgp flash across your screen.
+ Otherwise you will most likely just see the "Mail sent." message.
+ 
+ If you have MIME defined, it should be possible for you to include attachments
+ in your anonymous mail in the normal manner. Most servers these days support
+ the "hash" option which Elm makes use of to pass the proper MIME headers.
+ 
+ NEW ELMRC OPTIONS
+ 
+    * usepgppass = [ ON | OFF ]
+      Default: usepgppass = OFF
+         o OFF: Elm does not keep your passphrase in memory. You must enter it
+           each time you want to decrypt a pgp mail.
+         o ON: Elm keep your passphrase in memory for "keeppassfor" seconds.
+    * keeppassfor = <number>
+      Default: keeppassfor = 0
+         o keeppassfor>=0: Elm will keep your passphrase in memory for seconds
+           after entering the passphrase.
+         o keeppassfor<0: Elm will keep your passphrase in memory without
+           clearing it from memory.
+    * noencoding = <level>
+      Default: noencoding = 0
+ 
+      This control makes it possible to send raw 8bit or binary data when the
+      MTA doesn't support 8BITMIME and the -B8BITMIME option or BINARYMIME and
+      the -BBINARYMIME option.
+ 
+      Possible values:
+         o  0 : Always convert 8BIT and BINARY data to QUOTED-PRINTABLE if the
+           MTA doesn't support the -B8BITMIME and -BBINARYMIME options.
+         o  1 : Allow 8bit without -B8BITMIME, but binary data is encoded
+         o  2+: Allow binary without -BBINARYMIME and and 8bit without
+           -B8BITMIME
+      It is STRONGLY recommended that it be left set to 0 unless you know what
+      you are doing!!
+    * showto = [ ON | OFF ]
+      Default: showto = OFF
+         o ON: Elm should show you who the message is addressed to rather than
+           who it is from if the message is not addressed to you.
+         o OFF: normal behavior
+    * pagemultipart = [ ON | OFF ]
+      Default: pagemultipart = ON
+         o ON: Use the internal MIME support to display MULTIPART messages
+           rather than calling metamail
+         o OFF: display MULTIPART messages with metamail
+    * mimeforward = [ ON | OFF ]
+      Default: mimeforward = OFF
+         o ON: When forwarding a message, Elm will attach as a MIME body part of
+           type MESSAGE/RFC822.
+         o OFF: Elm will include the forwarded message in your message, just
+           like it always has.
+ 
+ BUILTIN++ PAGER
+ 
+ This pager looks a lot like more, but has some of the movement features of
+ less, most notably, paging backwards through your messages. Press '?' inside of
+ the pager for a list of valid keystroke commands.
+ 
+ TAGS
+ 
+ Use the keyword "tagged" in the "Delete messages with pattern" (invoked by ^D
+ in the index menu) to delete all tagged messages.
+ 
+ You can now use the keyword "all" to tag all visible messages.
+ 
+ LIMIT FUNCTIONALITY
+ 
+    * Simple compound statements can be made using '|' (OR) and '&' (AND).
+    * The "Cc:" field is now availible for search.
+    * New keyword "tagged" for narrowing to only the currently tagged messages.
+ 
+ MISCELLANEOUS
+ 
+ '*' may be used as a wildcard in the "alternatives" list in the elmrc file. For
+ instance, "me@*.hmc.edu" would me to match the user "me" in all hosts from the
+ "hmc.edu" domain.
+ 
+ Elm will keep track of the messages which you have replied to with an 'r' mark
+ in the index menu.
+ 
+ Forwarded messages are encapsulated instead of quoted like replies:
+ 
+         ----- Forwarded message from Joe User  -----
+         [...]
+         ----- End of forwarded message from Joe User  -----
+ 
+ You can effect an automatic Bcc: line by setting the address(es) in the "BCC"
+ environment variable. Note that this is non-standard, but provided as a means
+ of accomplishing the task.
+ 
+ BUGS
+ 
+ A list of known bugs can be found at
+ http://www.cs.hmc.edu/~elkins/elm/bugs.html.
+ 
+ AUTHOR
+ 
+ Michael Elkins <elkins@aero.org>
+ Home Page: http://www.cs.hmc.edu/~me/index.html
+ 
+ If you are interested in knowing what my future plans are, you can browse my
+ "TO DO" list at http://www.cs.hmc.edu/~me/elm/todo.html
+ 
+ THANKS
+ 
+ Kari Hurrta <Kari.Hurtta@fmi.fi> has contributed a great deal to the MIME
+ support (and fixed lots of my stupid bugs ;-)
+ 
+ I would also like to thank everyone who took the time to report bugs or suggest
+ improvements!
+ -------------------------------------------------------------------------------
+ Last updated Sept 21, 1995.

diff -c /dev/null elm-2.4pl24me8/ChangeLog.ME
*** /dev/null	Thu Sep 21 15:27:01 1995
--- elm-2.4pl24me8/ChangeLog.ME	Thu Sep 21 14:54:58 1995
***************
*** 0 ****
--- 1,739 ----
+ -----------------------
+ Changes from ME8alpha19
+ -----------------------
+ Fixed bug where external pager did not work with non-MIME messages when
+ USE_PGP is defined.
+ 
+ Cleaned up mime_pgp_decode so that it does not need to look at the
+ header_rec for the current message any longer.
+ 
+ Do text/plain => application/pgp conversion in newmbox.c if PGP type data
+ is discovered in the message.  This supports those who are sending PGP
+ messages but are not compliant with what Elm expects.
+ 
+ Added the control-E (extract public key) command to showmsg_c.c.
+ 
+ Security fix from Olaf Kirch <okir@monad.swb.de> which forces Elm to write
+ the temp spool mailbox in the user's home directory instead of /tmp.  This
+ prevents exploitation of symlinks to create a .rhosts in the user's 
+ directory.
+ 
+ Fixed bug in show_status where flags from the previous message were not
+ being properly cleared with USE_PGP was defined and MIME was not.
+ 
+ -----------------------
+ Changes from ME8alpha18
+ -----------------------
+ added application_decode for support of APPLICATION/* types.  Calls
+ null_decode if the subtype is unknown.
+ 
+ rfc822_decode now matches the headers against the weedlist when printing
+ out.  You can view all the headers for a message by pressing 'h' while
+ viewing a message just as you normally would.
+ 
+ added mime_pgp_decode for inline decoding of application/pgp parts.
+ application/pgp at the top level is still handled by metapager since some
+ people will be configured without MIME.  I might eventually require that
+ to use PGP, you must also define MIME, but not yet!
+ 
+ Status header was printed in the wrong place with BINARY encoding.
+ From: Kari.Hurtta@fmi.fi
+ 
+ Added the DONT_ADD_FROM and NEEDS_LONE_PERIOD_ESCAPE checks to write_encoded,
+ and other MIME text parts.
+ From: Kari.Hurtta@fmi.fi
+ 
+ Added a "type_opts" field in mime_send_t.
+ 
+ mime_write_header now just writes the MIME headers.  The code to add the
+ boundary for multipart messages and the charset for text/plain was moved into
+ mailmsg2.c.
+ 
+ Changed pgp code to set MIME fields to use add_parameter and type_opts instead
+ of directly writing to subtype.
+ 
+ Made some changes in the Content-Type for PGP messages to be more compliant
+ with the unofficial standard.
+ 
+ -----------------------
+ Changes from ME8alpha17
+ -----------------------
+ MIME header code in write_header_info() was moved to 
+ mime_write_header in mime_encode.c.  This was done to greatly simplify the
+ code, and to make it possible for me to send MIME messages with the
+ remailer code.  This will also make it possible for me to have PGP
+ encrypted MIME messages in the future.
+ 
+ Content-Length headers are generated regardless of whether or not MIME
+ is defined.
+ 
+ Lots of changes to the remailer code to make it work with MIME.
+ 
+ -----------------------
+ Changes from ME8alpha16
+ -----------------------
+ Removed Content-Length header from attachments included by the "[include ...]"
+ statement.
+ 
+ Made the existing global variables that set the toplevel Content-Length header
+ a part of mime_send_t.  This has the side effect that if MIME is not
+ defined, no Content-Length header will be added on outgoing messages.
+ 
+ Commented out the code which reads the content-length header from attachments
+ in mime_parse.c.  It should now ignore that header and figure out the length
+ in multipart_parse().
+ 
+ -----------------------
+ Changes from ME8alpha15
+ -----------------------
+ New option "mimeforward" controls whether or not forwarded messages are
+ sent as MESSAGE/RFC822 MIME messages, or are sent in the old non-MIME
+ way.
+ 
+ - Fixes for my mistakes in alpha15.
+ - text_unsupported_decode() added for printing warning message about
+ unsupported text subtypes.
+ From: Kari.Hurtta@fmi.fi
+ 
+ Changed disposition handing such that a message saying that the user should
+ type 'v' to view an attachment which is declared something other than
+ "inline".
+ 
+ -----------------------
+ Changes from ME8alpha14
+ -----------------------
+ Make sure that arguments to fseek(), etc., are type long.
+ From: Kari.Hurtta@fmi.fi
+ 
+ Added some general access commands for attachments in the attach_menu.c
+ routines.
+ From: Kari.Hurtta@fmi.fi
+ 
+ The disposition is now displayed in the little mini-header.  This looks nicer
+ than the previous message about "[Content-Disposition: attachment, skipping]".
+ 
+ select_CT_decoder now returns text_decode for all TEXT types.  My reasoning
+ here is that since the MIME spec says that all unknown subtypes of TEXT
+ should be treated as TEXT/PLAIN so long as the charset is understood, then
+ all TEXT can be treated in this manner.
+ 
+ Made sure that the pgp field of header_rec gets set to zero when initializing
+ in attach_viewer and also in newmbox.c.
+ 
+ Removed lots of unused variables.
+ 
+ Added some parentheses in places to make "gcc -Wparentheses" happy.
+ 
+ -----------------------
+ Changes from ME8alpha13
+ -----------------------
+ Forgot to initialize usepass=FALSE in pgp_decrypt_init.  This caused elm
+ to hang when trying to decode a signed message while pgp was waiting for
+ the passphrase...
+ 
+ The attachment menu should now work properly for viewing message/rfc822
+ messages with the builtin pager.
+ 
+ When attaching a message/rfc822 with the "forward" command, you should
+ now be able to perform all the actions in attach_menu() as for a "normal"
+ attachment.
+ 
+ -----------------------
+ Changes from ME8alpha12
+ -----------------------
+ Tried to fix MIME_NOTPLAIN code again.  This time MESSAGE/RFC822 will not
+ have it set, which MULTIPART will if pagemultipart=OFF.
+ 
+ Fixed attach_menu so that Elm does not segfault when you try to do an
+ operation on an attachment when there are no attachments defined.
+ 
+ Removed the MIME_NOTPLAIN flag and made it a one-bit flag in mime_t instead.
+ Removed PGP flags from defs.h and use a 3-bit field in header_rec instead.
+ These two now ensure that the "status" field of header_rec is always less
+ than 65536 so that 16bit integer machines will not have troubles.
+ 
+ Elm now pays attention to what the MIME-Version header says and passes any
+ messages with an unknown MIME-Version header value to metamail, or displays
+ an error if $NOMETAMAIL is set.
+ From: Kari.Hurtta@fmi.fi
+ 
+ -----------------------
+ Changes from ME8alpha11
+ -----------------------
+ pgp_call() now uses the expanded_* address lists so that aliases are 
+ expanded before trying to look up the ids with PGP.
+ 
+ Fixed calls in mailmsg2.c with wrong number of arguments (botched job
+ including Kari Hurtta's patch).
+ From: Kari.Hurtta@fmi.fi
+ 
+ Reordered the preMIME code in newmbox.c to make it a little more efficient.
+ 
+ Fixed bug in write_header_info() where a spurious newline was being printed
+ after the Content-Type header for TEXT.  This was causing the remaining 
+ fields not to be a part of the message header.
+ 
+ Removed check for old-style RFCXXX Mime-Version header.  I don't believe
+ anybody uses that anymore since RFC1341 has been out so long.
+ 
+ pgp_status needed to be reset when the user aborts sending a message,
+ otherwise you can't encrypt another message until you successfully send
+ another message.
+ 
+ MIME_NOTPLAIN is not set for multipart messages if "pagemultipart" is TRUE.
+ 
+ Cleaned up code for deciding if metamail mail should be called to display
+ a message in showmsg.c.  Created a need routine, need_meta(), for this
+ purpose.
+ 
+ -----------------------
+ Changes from ME8alpha10
+ -----------------------
+ Fixes to remove some global MIME variables used for composing.
+ From: Kari.Hurtta@fmi.fi
+ 
+ Added a redraw command to the attachment menu.
+ 
+ Fixed the code in newmbox.c where MIME_NOTPLAIN was not set for non-TEXT
+ content-types.  Also, check for "plain" should be "text" for old-style
+ pre-MIME content-type headers.
+ 
+ Added a print command to the attachment menu.
+ 
+ Made the remailer support a Configure option.
+ 
+ ----------------------
+ Changes from ME8alpha9
+ ----------------------
+ Use Elm's error routines in the attachment menu. 
+ Protected iscntrl() more calling isascii() before it in builtin++.
+ From: Kari Hurtta <Kari.Hurtta@fmi.fi>
+ 
+ Added bit of code lost from old showmsg.c which centers the subject line 
+ after the title line in the case where "subject" is in the weedlist.
+ 
+ Viewing attachments with metamail while in send mode now works.  It required
+ different arguments to be passed to metamail.
+ 
+ -----------------------
+ Changes from ME8alpha8a
+ -----------------------
+ mime_t_clear() now sets the defaults of TEXT/PLAIN, ENCODING_7BIT, DISP_INLINE,
+ when called.
+ 
+ More fixes from Kari Hurtta <kari.hurtta@fmi.fi>
+ 
+ Removed padding bitfield from struct mimeinfo since it isn't needed.
+ 
+ Added +clearsig=ON when adding a PGP signature to a message.
+ 
+ Added prototypes for the functions defined in pgp.c.
+ 
+ Elm will now allow you to edit the list of usernames to encrypt to when
+ using PGP.  This fixes the problem where sometimes the return address
+ doesn't match the address on the key.  However, it still requires that
+ the user know this.
+ 
+ Implemented Kari Hurtta's suggestion of using a "state" variable for the
+ MIME output when decoding messages.  This will make it easier to add new
+ extensions for output.  The state information is defined in hdrs/state.h
+ 
+ The user interface for the attachment menu now is more consistent with
+ the mailbox menu.  (Kari.Hurtta@fmi.fi)
+ 
+ User is now asked for confirmation upon deleting an attachment from the
+ attachment menu if "ask=ON" in the elmrc.
+ 
+ Fixed replying to messages with PGP signatures.  They were getting sucked
+ into the new MIME code and getting skipped as an unknown type.
+ 
+ Added new procedure to allow for extraction of PGP public keys directly
+ instead of relying on metamail.
+ 
+ If Elm can't find a PGP key that it is looking for, it now tells the user
+ which key instead of just that there was an error.
+ 
+ The user is now allowed to re-edit the filename in attach_modify() if the
+ file was not found.  This also allows a user to change the file associated
+ with an attachment.
+ 
+ Fixed very old bug of MMDF separators being printed when displaying a
+ message.
+ 
+ ----------------------
+ Changes from ME8alpha8
+ ----------------------
+ Fixed problem where you couldn't edit the default filename in attach_save().
+ 
+ ----------------------
+ Changes from ME8alpha7
+ ----------------------
+ Use safe_malloc() and safe_realloc() instead. (Kari Hurtta)
+ 
+ Fixed bug where no EOLN token was printed after the Content-Type header
+ when type_opts was NULL in attach_generate_message().
+ 
+ Reorganized struct mimeinfo so that bitfields are next to each other and
+ added padding to make them 1 byte long total.
+ 
+ -----------------------
+ Changes from ME8alpha6+
+ -----------------------
+ Reduced memory usage in "struct mimeinfo" by using bitfields or pointers
+ instead of predefined strings when possible.  Also removed the "comments"
+ fields.
+ 
+ New routine lib/strmcpy.c for doing malloc/realloc and strcpy in one shot.
+ Helps out with the above objective.
+ 
+ The attachment menu now defaults to disposition "inline" when sending
+ mail.
+ 
+ Reorganized the screen in the attachment "configuration" menu.
+ 
+ Removed code for adding "name=" field to APPLICATION/OCTET-STREAM types.
+ Uses Kari's code for Content-Disposition "filename" instead.  attach_menu()
+ still supports both for getting default filename when saving an
+ attachment.
+ 
+ Removed MIME_MULTIPART flag.  Use MIME_TYPE_MULTIPART with "type" instead.
+ 
+ Removed "encoding" field from "header_rec".  Use "encoding" in "mimeinfo"
+ instead (this was already mostly true, but there were a few cases left
+ over from the early support for encoding...)
+ 
+ ----------------------
+ Changes from ME8alpha6
+ ----------------------
+ Incorporated changes from Kari Hurtta <Kari.Hurtta@FMI.FI>.
+ Big changes are the use of Content-Disposition and routines to better parse
+ rfc822 headers.  Also fixed multi-line MIME header problem in newmbox.c
+ 
+ ----------------------
+ Changes from ME8alpha5
+ ----------------------
+ Fixed places where "/tmp" was hardcoded for temporary files instead of using
+ "temp_dir" in the ME extensions.
+ 
+ Fixed more isspace() problems with "signed char".
+ 
+ Made some formatting improvements in multipart_decode().
+ 
+ Fixed bug where multi-line Content-Type headers were not properly parsed in
+ newmbox.c.
+ 
+ Added builtin++2.c which contains a tempfile based pager which may become
+ part of the "official" distribution.  For right now it is "experimental".
+ 
+ ----------------------
+ Changes from ME8alpha4
+ ----------------------
+ Fixed attach_modify() to use ->type and ->subtype like the rest of the
+ attachment routines.
+ 
+ Viewing an attachment while sending didn't work because it read from
+ mailfile...  Now it can view external files as well.
+ 
+ Fixed problem with signed char and iscntrl() in AddLineToCache().
+ This fixes the problem with umlaut characters in some sets.
+ From: guy@netapp.com.
+ 
+ Modified mime_generate_boundary() to use mime_count as a counter so that
+ subsequent calls will generate different values.
+ 
+ Elm will now read ~/.elm/mime.types and $libdir/elm.mimetypes (system
+ mime.types file), if they exist, to map filename extensions to
+ Content-Type values when sending attachments.  The format of this file
+ is:
+ 	<suffix> <content-type>
+ There must be no line breaks in the Content-Type field.
+ Example:
+ 	tar	application/octet-stream; type=tar
+ for .tar files.
+ NOTE: data which is declared "application/octet-stream" will automatically
+       get the option "name=<default_filename>" added to it, so there is no
+       need to put it in the definition.
+ 
+ Modified attach_info() so that it uses BASE64 encoding for "application"
+ types that have 8bit or control chars in them.
+ Also, "image" automatically defaults to BASE64 without reading the file.
+ 
+ attach_save() now uses the "name=<default_filename>" field of "application"
+ types as the default filename.
+ 
+ Added '+' as a synonym for NEXT_PAGE in builtin++ per popular request.
+ 
+ attach_generate_msg() no longer puts Content-Length headers on parts that
+ it generates.
+ 
+ ----------------------
+ Changes from ME8alpha3
+ ----------------------
+ Added support for multi-line Content-Type: headers in read_headers() and
+ mime_read_headers().
+ 
+ me.h now contains prototypes for functions defined by this set of patches.
+ 
+ Fixed some problems with using PGP and remailers.
+ 
+ Fixed parsing of options in the Content-Type header so that semicolons
+ inside quotes are protected.
+ 
+ If MIME is defined, forwarded messages will be an attachment of type
+ MESSAGE/RFC822.
+ 
+ Fixed problem with viewing MULTIPART or MESSAGE/RFC822 attachments from
+ the attachment menu.
+ 
+ Replaced MIME_BOUNDARY with a function (mime_generate_boundary()) that
+ sets the global variable "mime_boundary" to generate unique multipart
+ boundaries.  This is important now that Elm will be sending out
+ MESSAGE/RFC822 data which Elm might have originally generated...
+ 
+ ----------------------
+ Changes from ME8alpha2
+ ----------------------
+ Added a second line for menu items in verify_transmission() since adding
+ the "r)emailer" option didn't fit on the first line.
+ 
+ Modified the PGP code a little for more flexibility.  You can now specify
+ a string of "ids" to encrypt with in pgp_call().
+ 
+ ---------------------
+ Changes from ME8alpha
+ ---------------------
+ The menus from attach.c and attach_send.c were combined into a single
+ menu in attach_menu.c which servers both purposes.  The difference is
+ whether or not the user is allowed to modify the given attachments.
+ 
+ The rest of attach_send.c was renamed as mime_encode.c.
+ 
+ -----------------
+ Changes from ME7a
+ -----------------
+ 
+ Added a check in quoted_printable_decode() to make sure that the index
+ into outbuf[] does not run off the end and cause problems.
+ 
+ attach_edit() didn't return TRUE after editing in one spot, which causes
+ problems on some platforms, namely Solaris.
+ From: Martin Walter <mawa@ruf.uni-freiburg.de>
+ 
+ base64_decode() was broken because it would fread() a data chunk, and 
+ wasn't always a multiple of 4 bytes, causing the decoding to break.
+ 
+ Changed char => unsigned char in most places in *_encode() to fix problems
+ with ISO characters >127.
+ 
+ Added message about PGP support for the 'elm -v' command in args.c.
+ 
+ Support for anonymous remailers. [ALPHA]
+ 
+ Major rewrite of the MIME handling code.  MULTIPART and MESSAGE/RFC822
+ messages are parsed the first time they are accessed (eg. viewed/replied)
+ and then are ready to use without parsing after that.  See mime_parse.c
+ and mime_decode.c for details.
+ 
+ From: Kari Hurtta <Kari.Hurtta@fmi.fi>
+   Put a loop around verify_transmission() so that Elm will no longer just
+   be lame when an error occurs in [include ...] statements.  (Way cool! -Ed)
+ 
+   Don't allow user read or writes files as attachmentds which he don't heve 
+   access. Notice that elm is (usually) setgid mail.
+ 
+   Consider if MTA supports 8BITMIME also when encoding attachments.
+ 
+   Now mail is encoded with quoted-printable if it includes control characters.
+   8BITMIME doesn't help in this case.
+ 
+   Attachments are checked for 8bit characters, then content-transfer-encoding
+   7bit is not allowed.
+ 
+   If any of subpart (also attachments) have content-tarnsfer-encoding 8bit
+   or binary it propagates to content-transfer-encoding of top multipart -type.
+ 
+   Now taken note of MIME's canonical encoding model:
+   - End of line in text -subtypes when they have encoded with BASE64
+     must be encoded as CR LF.
+   - Also CR and LF must be encoded in quoted-printable-encoding if
+     type have binary data (ie. not line oriented).
+   - Done mapping CR LF -> LF when decoding text -subtypes.
+ 
+   These content-transfer-encoding checks for attachments are also done
+   for [include ...] keywords when sending.
+ 
+   Now [include ...] also don't need metamail's help (they use same routines
+   than attachments menu).
+ 
+   Added configuration file option 'noencoding' (see elmrc-info for details
+   on what this does).
+ 
+ ----------------
+ Changes from ME7
+ ----------------
+ 
+ Forgot to kill the newline from the PGP output before putting it in to the
+ builtin++ pager.  This resulted in messages being displayed double-spaced.
+ Ick!
+ 
+ ----------------
+ Changes from ME6
+ ----------------
+ 
+ attach_send.c needs <sys/stat.h> on some machines.
+ 
+ Fixed initialization of arrays in attach_send.c because CC isn't quite
+ ANSI compliant.  You can only initialize static arrays.
+ From: Guy Harris <guy@netapp.com>
+ 
+ Added support for sendmail 8.7 which has support for 8BIT content 
+ encoding.  Uses the -B8BITMIME option.
+ From: Kari Hurtta <hurtta@dionysos.fmi.fi>
+ 
+ Fixed problem where QUOTED-PRINTABLE messages were not decoded when
+ replying if USE_PGP was not defined.
+ From: Kari Hurtta <hurtta@dionysos.fmi.fi>
+ 
+ [keyword ...] constructs are no longer broken when using MIME and the
+ message is to be encoded QUOTED-PRINTABLE.
+ From: Kari Hurtta <hurtta@dionysos.fmi.fi>
+ 
+ Made the QUOTED-PRINTABLE encoding routine more compliant with the
+ standard.
+ From: Kari Hurtta <hurtta@dionysos.fmi.fi>
+ 
+ Added patch to mark messages NEW in all folders (not just the SPOOL)
+ if there is no status: line.
+ NOTE: This will probably go away when 2.5 is released.  Instead, they
+ will use some sort of "magic" flag to accomplish the same thing.
+ 
+ Added check to make sure that we don't run off the end of outbuf[] in
+ base64_decode() in mime.c.
+ From: Kurt.Jaeger@rus.uni-stuttgart.de
+ 
+ Fixed type casting problem with BSD 4.4 derivatives in mime.c.
+ From: Andrey A. Chernov <ache@astral.msk.su>
+ 
+ KOI8-R added as a valid compat charset.
+ From: Andrey A. Chernov <ache@astral.msk.su>
+ 
+ builtin++ now wraps the line at the number of columns on the screen, not
+ one character before.  NewLine() apparently "does the right thing" and
+ doesn't print an extra line if the last character is in the last column.
+ From: Kari Hurtta <Kari.Hurtta@fmi.fi>
+ 
+ The arrow keys now do what they did before instead of controlling the
+ bultin++ pager.
+ 
+ builtin++ always clears the screen before displaying the next (or
+ previous) page.
+ 
+ The length of a line in the cache for builtin++ is increased to 150
+ chars because the old value of 128 didn't work with hpterms with a 
+ width of 134 chars.
+ 
+ Fixed problem where Elm would SIGBUS if you tried to use the
+ attachments menu in an empty folder.
+ From: Kari Hurtta <Kari.Hurtta@fmi.fi>
+ 
+ buf[STRING] was too short in AttachmentMenu() and caused certain Elm to
+ bomb out on certain messages which had header lines which were too
+ long.
+ 
+ AddLineToCache() can now handle multiline input.  This meant that
+ calls to it from metapager had to remove the trailing newlines.
+ 
+ Changed the MIME mini-header format in metapager().
+ 
+ attach_edit() looks more like header_edit() now.  Makes the interface
+ more consistent.
+ 
+ lib/getrealname.c needed <ctype.h> on older BSD systems.
+ 
+ Fixed nasty bug where the blank line in between the headers and the body
+ of a NEW message would get deleted when resync'ing in the spool folder.
+ 
+ Fixed infinite loop in Configure when run with the -d option.
+ 
+ ----------------
+ Changes from ME5
+ ----------------
+ 
+ Added the DoAll() call so that the keyword "all" can be used when tagging
+ or deleting.
+ 
+ Decoupled PGP and MIME support such that you don't need MIME to use PGP.
+ 
+ Added lots of error checking code in metapager.c.
+ From: guy@netapp.com (Guy Harris).
+ 
+ Fixed bug in quoted_printable_decode() where I did not convert read
+ characters to base16.
+ 
+ Added hex() function to protect index_hex from bad values.
+ 
+ metapager() prompts for a command if necessary after running the external
+ pager, just as Elm used to do.
+ 
+ Fixed the From: line in write_header_info() where I broke it before.
+ 
+ Fixed bug where the MIME multipart boundary would be written after the
+ MMDF separator when copy=ON and the message was being copied to the user's
+ desired folder.
+ 
+ Added an "Attachments" menu in verify_transmission() for including 
+ attachments.  This works in addition to the current method of using
+ "[include ..."
+ 
+ Elm now directly supports writing of BASE64 and QUOTED-PRINTABLE
+ encodings.
+ 
+ Changed the return value of match_address() to be zero, since it
+ returns an int, and NULL is not always an int.
+ From: Michael Shields <shields@tembel.org>
+ 
+ AttachViewer() now uses notplain() to determine whether or not
+ metamail is needed to view the message.
+ From: Guy Harris <guy@netapp.com>
+ 
+ needs_mmdecode() now takes the integer version of the encoding rather
+ than a string.  This avoids parsing the string twice.
+ From: Guy Harris <guy@netapp.com>
+ 
+ Elm now checks outgoing messages to see if there are any non-printable
+ characters, and if so encodes the message QUOTED-PRINTABLE.
+ 
+ Cleaned up PGP code by moving more code to pgp.c so that other files
+ require less modification (ie. the diffs will be simpler).
+ 
+ Fixed showmsg.c so that it passes anything that doesn't require metamail
+ to the metapager.  This fixed the problem where messages with no
+ Mime-Version header but had a Content-Type header wouldn't get displayed.
+ From: Guy Harris <guy@netapp.com>
+ 
+ Fixed bug in dispaddr.c so that if a message is from the user, it will
+ always use the TO address to display.
+ 
+ Moved get_real_name() to its own file in lib so it can be used by
+ dispaddr.c.
+ 
+ Modified get_real_name() so that if it sees an address like
+ "<elkins@aero.org>" it will return "elkins@aero.org" instead of a zero
+ length string.
+ 
+ ----------------
+ Changes from ME4
+ ----------------
+ 
+ Introduced the "metapager".  It replaces most of the code in showmsg.c.
+ It also takes care of all the MIME and PGP functions the bultin++ pager
+ used to perform, so that the user doesn't have to use builtin++ in those
+ cases.
+ 
+ PGP decrypting function was rewritten using pipes so no temp files are
+ required!
+ 
+ The attachment handling code was modified to handle multiline content-type
+ headers generate by such mailers as zmailer.  It also looks through each
+ modifier in the line intead of just assuming that the boundary field will
+ be the first.
+ From: guy@netapp.com (Guy Harris)
+ 
+ The "command" status line in the builtin++ pager now floats around instead
+ of always being on the bottom.  This was done to facilitate the ^L in
+ the pager so it didn't look stupid.
+ 
+ Moved the MIME QUOTED-PRINTABLE and BASE64 decoding code to mime.c so it
+ can be shared.
+ 
+ Fixed copy_message() so that it will automatically decode MIME B64 and QP
+ encodings.  This means that replies to these types of messages do what the
+ user will expect.
+ 
+ ----------------
+ Changes from ME3
+ ----------------
+ 
+ Fixed problems in builtin++.c and pgp.c where I used the return value
+ from sprintf() as a char* when in SYSV systems it returns an int. 
+ This caused Elm to seg fault while decrypting messages.
+ 
+ Configure now asks about PGP support and automatically sets up
+ config.h.  Thanks to Ken Cox (kenc@viewlogic.com) for additional help.
+ 
+ PGP messages are now automatically decrypted when replying if
+ usepgppass = ON.
+ 
+ Back to using the application/pgp format content-type.  Use
+ format=keys-only for send a public key block.
+ 
+ PGPCall() now uses the pgp option +encrypttoself=on instead of tacking
+ the username on the end of the TO list.
+ 
+ Fixed problem where any messages after sending a PGP public key had
+ the key text included before the included message text.
+ 
+ Use rename() if availible instead of copying the file in PGPCall(). 
+ Otherwise use link(), unlink().  This should be a little more
+ efficient.
+ 
+ pgp is now called with the -w (wipe) option when encrypting.
+ 
+ builtin++ can now handle text which is QUOTED-PRINTABLE or BASE64
+ encoded.
+ 
+ Fixed bug where the last line of messages was not being printed.
+ 
+ Elm will no longer seg fault if you hit return without entering your
+ PGP passphrase.
+ 
+ Discovered the +batchmode option for pgp.  This makes dealing with
+ incorrect passphrases much easier!
+ 
+ Fixed bug in builtin++ where the last line of pgp messages would be
+ printed more than once while at the end of the message under certain
+ circumstances.
+ 
+ Changed notplain() in mime.c to support message/* content-type.
+ 
+ Cleaned up the multipart handling by removing the boundary string from
+ header_rec to conserve memory.  This is now handled by builtin++ and
+ AttachMenu().
+ 
+ builtin++ can now handle multipart/digest correctly.
+ 
+ SaveAttach() no longer needs to call metamail to decode QUOTED-PRINTABLE
+ or BASE64 encodings.
+ 
+ -----------------
+ Changes from ME2a
+ -----------------
+ 
+ Elm will now keep track of your PGP passphrase for your RSA secret key.
+ To use this feature, add the line "usepgppass = ON" to your .elmrc.
+ There is also a timeout feature which will cause Elm to "forget" your
+ passphrase after so many seconds if you don't use it.  The default is
+ 300 seconds, but this can be changes by setting the variable
+ "keeppassfor" in your .elmrc.
+ 
+ The builtin++ pager was completely rewritten (again) so that it can now
+ handle normal messages, MIME multipart messages, automatic decryption
+ and automatic signature checking for PGP messages.  It also seems to be
+ lacking some of the memory allocation bugs that the previous pager had.
+ 
+ Fixed a bug in DynamicArray() which causes DestroyDynamicArray() to
+ seg fault if exactly max+n elements were allocated. (weo@recco.de)
+ 
+ ----------------
+ Changes from ME2
+ ----------------
+ 
+ It is now possible to delete all "tagged" messages by entering "tagged"
+ as the pattern to match after typing <control>-d (^D).
+ 
+ fixed a bug in the limit command where you could not "un"limit the
+ display of headers.  Thanks to guy@netapp.com (Guy Harris) for
+ pointing it out!
+ 
+ fixed a bug in is_multipart() where the "boundary" token match was
+ case-sensitive.

diff -c elm-2.4pl24/Configure elm-2.4pl24me8/Configure
*** elm-2.4pl24/Configure	Mon May 30 09:55:55 1994
--- elm-2.4pl24me8/Configure	Tue Sep 19 10:45:20 1995
***************
*** 160,166 ****
  d_mallocvoid=''
  d_mboxedit=''
  d_mime=''
! defencoding=''
  defcharset=''
  defdispcharset=''
  d_mmdf=''
--- 160,168 ----
  d_mallocvoid=''
  d_mboxedit=''
  d_mime=''
! # defencoding=''
! d_8bitmime=''
! d_binarymime=''
  defcharset=''
  defdispcharset=''
  d_mmdf=''
***************
*** 267,272 ****
--- 269,278 ----
  xenlf=''
  d_xenix=''
  d_bsd=''
+ d_pgp=''
+ pgp=''
+ pgp_path=''
+ d_remailer=''
  CONFIG=''
  : set package name
  package=elm2
***************
*** 602,607 ****
--- 608,614 ----
  nroff
  pack
  pg
+ pgp
  pmake
  pr
  rmail
***************
*** 3240,3247 ****
  with its companion programs (mmencode) must be installed somewhere in
  the search path, usually /usr/local/bin.
    
  
- 
  EOM
  
  rp="Should support for MIME be compiled in? [$dflt]"
--- 3247,3255 ----
  with its companion programs (mmencode) must be installed somewhere in
  the search path, usually /usr/local/bin.
    
+ If you don't have metamail program installed, define environment
+ variable \$NOMETAMAIL if MIME is compiled in.
  
  EOM
  
  rp="Should support for MIME be compiled in? [$dflt]"
***************
*** 3263,3277 ****
  *) defdispcharset="$defdispcharset";;
  esac
  
! case "$defencoding" in
! '') if $test "$defcharset" = "US-ASCII"; then
! 		defencoding="7bit"
! 	else
! 		defencoding="8bit"
! 	fi;;
! *) defencoding="$defencoding";;
  esac
  
  if $test "$d_mime" = "$define"; then
  	dflt="$defcharset"
  cat <<EOM
--- 3271,3295 ----
  *) defdispcharset="$defdispcharset";;
  esac
  
! case "$d_8bitmime" in
! '') d_8bitmime="$undef";;
! *) d_8bitmime="$d_8bitmime";;
  esac
  
+ case "$d_binarymime" in
+ '') d_binarymime="$undef";;
+ *) d_binarymime="$d_binarymime";;
+ esac
+ 
+ # case "$defencoding" in
+ # '') if $test "$defcharset" = "US-ASCII"; then
+ # 		defencoding="7bit"
+ # 	else
+ # 		defencoding="8bit"
+ # 	fi;;
+ # *) defencoding="$defencoding";;
+ # esac
+ 
  if $test "$d_mime" = "$define"; then
  	dflt="$defcharset"
  cat <<EOM
***************
*** 3300,3322 ****
  	. myread
  	defdispcharset="$ans"
  
! 	dflt="$defencoding"
! 	$cat <<EOM
! Default Content-Transfer-Encoding for MIME Content-type text.
! If you are using the default US-ASCII charset, you should use
! 7bit encoding. But if you are using some other national character
! set, 8bit is recommended, unless you are using a 7bit character set.
! For 8bit encoding your transport paths should be 8bit clean, which
! is not true all over the world. base64 or quoted-printable aren't
! yet supported for the default Content-Transfer-Encoding.
  
  EOM
! 	rp="Default Content-Transfer-Encoding for MIME Content-type text? [$dflt]"
! 	$echo $n "$rp $c"
! 	. myread
! 	defencoding="$ans"
  fi
  
  : see if mkdir exists
  set mkdir d_mkdir
  eval $inlibc
--- 3318,3461 ----
  	. myread
  	defdispcharset="$ans"
  
! # 	dflt="$defencoding"
! # 	$cat <<EOM
! # Default Content-Transfer-Encoding for MIME Content-type text.
! # If you are using the default US-ASCII charset, you should use
! # 7bit encoding. But if you are using some other national character
! # set, 8bit is recommended, unless you are using a 7bit character set.
! # For 8bit encoding your transport paths should be 8bit clean, which
! # is not true all over the world. base64 or quoted-printable aren't
! # yet supported for the default Content-Transfer-Encoding.
! # 
! # EOM
! # 	rp="Default Content-Transfer-Encoding for MIME Content-type text? [$dflt]"
! # 	$echo $n "$rp $c"
! # 	. myread
! # 	defencoding="$ans"
  
+ case "$d_8bitmime" in
+ "$define") dflt=y;;
+ *)  dflt=n;;
+ esac
+ 
+ cat <<EOM
+ 
+ If your MTA (Mail transport Agent) supports 8BITMIME ESMTP -extension
+ and accepts also option -B8BITMIME (that is BODYTYPE=8BITMIME), Elm
+ can left doing encoding from 8bit to quoted_printable to MTA. Otherwise
+ Elm does encoding of 8bit data itself. Sendmail version 8.7 supports
+ 8BITMIME -extension.
+ 
  EOM
! rp="MTA supports -B8BITMIME -option? [$dflt]"
! $echo $n "$rp $c"
! . myread
! case "$ans" in
! y*) d_8bitmime="$define";;
! *)  d_8bitmime="$undef";;
! esac
! 
! # If mailer don't support 8BITMIME it also don't support BINARYMIME
! case "$d_8bitmime" in
! "$define")
! 
! case "$d_binarymime" in
! "$define") dflt=y;;
! *)  dflt=n;;
! esac
! 
! cat <<EOM
! 
! If your MTA (Mail transport Agent) supports BINARYMIME ESMTP -extension
! and accepts also option -BBINARYMIME (that is BODYTYPE=BINARYMIME), Elm
! can left doing encoding from BINARY to base64 or quoted-printabe to MTA. 
! Otherwise Elm does encoding of binary data itself. Passing of binary data
! requires that all text data lines are terminated with CRLF -- Unix's
! LF is NOT sufficient. Currently ELM don't use CRLF as line terminator
! in every places when using -BBINARYMIME option (so that option is only
! partially implemented by Elm). Notice also that isn't known any MTA (mailer)
! what implements BINARYMIME or accepts -BBINARYMIME option. Notice also
! that BINARYMIME is Experimental Protocol (as stated in RFC1830).
! 
! EOM
! rp="MTA supports -BBINARYMIME -option? [$dflt]"
! $echo $n "$rp $c"
! . myread
! case "$ans" in
! y*) d_binarymime="$define";;
! *)  d_binarymime="$undef";;
! esac
! 
! ;;
! *) d_binarymime="$undef";;
! esac
! 
  fi
  
+ : ask about PGP support
+ if $test "$d_pgp" = "$define"; then
+ 	dflt=y
+ 	pgp=$pgp_path
+ else
+ 	dflt=n
+ fi
+ echo ''
+ rp="Should PGP (Pretty Good Privacy) support be compiled in? [$dflt]"
+ echo $n "$rp $c"
+ . myread
+ if test "$ans" = "y"; then
+ 	d_pgp="$define"
+ 	cont=true
+ 	dflt="$pgp"
+ 	while $test "$cont"; do
+                 rp="Where is the pgp binary located? [$dflt]"
+ 		echo $n "$rp $c"
+ 		. myread
+ 		pgp_path="$ans"
+ 		case "$ans" in
+ 		/*)
+ 			if $test -f $ans; then
+ 				cont=''
+ 			else
+ 				if $test "$fastread" = yes; then
+ 					dflt=y
+ 				else
+ 					dflt=n
+ 				fi
+ 				rp="File $ans doesn't exist.  Use that name anyway? [$dflt]"
+ 				echo $n "$rp $c"
+ 				. myread
+ 				case "$ans" in
+ 				y*) cont='';;
+ 				esac
+ 			fi
+ 			;;
+ 		*)
+ 			echo "Please give the full pathname."
+ 			;;
+ 		esac
+ 	done
+ else
+ 	d_pgp="$undef"
+ fi
+ 
+ : ask about remailer support
+ if $test "$d_remailer" = "$define"; then
+ 	dflt='y'
+ else
+ 	dflt='n'
+ fi
+ echo ''
+ rp="Should support for anonymous remailers be included? [$dflt]"
+ echo $n "$rp $c"
+ . myread
+ if $test "$ans" = "y"; then
+ 	d_remailer="$define"
+ else
+ 	d_remailer="$undef"
+ fi
+ 
  : see if mkdir exists
  set mkdir d_mkdir
  eval $inlibc
***************
*** 4348,4354 ****
  
  : ask the preferred pager for this system.
  case "$pager" in
! '') dflt="builtin+";;
  *)  dflt="$pager";;
  esac
  
--- 4487,4493 ----
  
  : ask the preferred pager for this system.
  case "$pager" in
! '') dflt="builtin++";;
  *)  dflt="$pager";;
  esac
  
***************
*** 4367,4372 ****
--- 4506,4514 ----
      builtin+)
          cont=''
  	;;
+     builtin++)
+         cont=''
+         ;;
      /*)
  	if $test -f "$ans"; then
  	    cont=''
***************
*** 4829,4834 ****
--- 4971,4978 ----
  d_mboxedit='$d_mboxedit'
  d_mime='$d_mime'
  defencoding='$defencoding'
+ d_8bitmime='$d_8bitmime'
+ d_binarymime='$d_binarymime'
  defcharset='$defcharset'
  defdispcharset='$defdispcharset'
  d_mmdf='$d_mmdf'
***************
*** 4935,4940 ****
--- 5079,5088 ----
  xenlf='$xenlf'
  d_xenix='$d_xenix'
  d_bsd='$d_bsd'
+ d_pgp='$d_pgp'
+ pgp='$pgp'
+ pgp_path='$pgp_path'
+ d_remailer='$d_remailer'
  CONFIG=true
  EOT
  

diff -c elm-2.4pl24/MANIFEST elm-2.4pl24me8/MANIFEST
*** elm-2.4pl24/MANIFEST	Thu Mar 10 09:14:46 1994
--- elm-2.4pl24me8/MANIFEST	Thu Sep 14 19:56:12 1995
***************
*** 1,3 ****
--- 1,5 ----
+ ANNOUNCE.ME
+ ChangeLog.ME
  Changes
  Configure
  Instruct
***************
*** 31,36 ****
--- 33,39 ----
  doc/frm.1
  doc/listalias.1
  doc/messages.1
+ doc/mime.types
  doc/newalias.1
  doc/newmail.1
  doc/printmail.1
***************
*** 55,60 ****
--- 58,66 ----
  hdrs/headers.h
  hdrs/mcprt.h
  hdrs/mcprtlib.h
+ hdrs/me.h
+ hdrs/menu.h
+ hdrs/menu2.h
  hdrs/mime.h
  hdrs/msgcat.h
  hdrs/ndbz.h
***************
*** 84,89 ****
--- 90,97 ----
  lib/can_open.c
  lib/chloc.c
  lib/date_util.c
+ lib/dispaddr.c
+ lib/dynarray.c
  lib/errno.c
  lib/expand.c
  lib/figadrssee.c
***************
*** 92,97 ****
--- 100,106 ----
  lib/getaddrfrm.c
  lib/getarpdate.c
  lib/getfullnam.c
+ lib/getrealname.c
  lib/getword.c
  lib/header_cmp.c
  lib/in_list.c
***************
*** 124,129 ****
--- 133,139 ----
  lib/strftime.c
  lib/strincmp.c
  lib/striparens.c
+ lib/strmcpy.c
  lib/strstr.c
  lib/strtokq.c
  lib/tail_of.c
***************
*** 159,166 ****
  src/alias.c
  src/aliaslib.c
  src/args.c
  src/bouncebk.c
! src/builtin.c
  src/calendar.c
  src/curses.c
  src/date.c
--- 169,177 ----
  src/alias.c
  src/aliaslib.c
  src/args.c
+ src/attach_menu.c
  src/bouncebk.c
! src/builtin++.c
  src/calendar.c
  src/curses.c
  src/date.c
***************
*** 185,200 ****
--- 196,219 ----
  src/lock.c
  src/mailmsg1.c
  src/mailmsg2.c
+ src/menu.c
+ src/menu2.c
+ src/metapager.c
  src/mime.c
+ src/mime_decode.c
+ src/mime_encode.c
+ src/mime_parse.c
  src/mkhdrs.c
  src/newmbox.c
  src/options.c
  src/out_utils.c
  src/pattern.c
+ src/pgp.c
  src/pmalloc.c
  src/quit.c
  src/read_rc.c
  src/remail.c
+ src/remailer.c
  src/reply.c
  src/returnadd.c
  src/save_opts.c

diff -c elm-2.4pl24/config.h.SH elm-2.4pl24me8/config.h.SH
*** elm-2.4pl24/config.h.SH	Mon May 30 09:55:57 1994
--- elm-2.4pl24me8/config.h.SH	Mon Sep 11 10:09:38 1995
***************
*** 292,297 ****
--- 292,325 ----
   */
  #$d_mime	MIME	/**/
  
+ /* USE_8BITMIME
+  *     Mailer accepts -B8BITMIME option
+  *     -B == BODYTYPE
+  */
+ #$d_8bitmime     USE_8BITMIME      /**/
+ 
+ /* USE_BINARYMIME
+  *     Mailer accepts -BBINARYMIME option
+  *     -B == BODYTYPE
+  *
+  * Elm don't yet fully support BINARYMIME: it requires that lines are
+  * terminated with \r\n, Unix's \n isn't sufficient!
+  * That is only partially implemented in this version of Elm.
+  *
+  * Quote from RFC 1830 (Experimental Protocol): 
+  *  SMTP Service Extensions for Transmission of Large and Binary MIME Messages
+  *
+  *      It is important to note that when using BINARYMIME, it is
+  *      especially important to ensure that the MIME message itself is
+  *      properly formed.  In particular, it is essential that text be
+  *      canonically encoded with each line properly terminated with <CR>
+  *      <LF>.  Any transformation of text into non-canonical MIME to
+  *      observe local storage conventions must be reversed before sending
+  *      as BINARYMIME.  The usual line-oriented shortcuts will break if
+  *      used with BINARYMIME.
+  */
+ #$d_binarymime     USE_BINARYMIME      /**/
+ 
  /* MMDF:
   *	This symbol, if defined, indicates that mailboxes are in
   *	the MMDF format.
***************
*** 602,605 ****
--- 630,649 ----
  #$d_xenix	XENIX	/**/
  #$d_bsd	BSD	/**/
  
+ /* USE_PGP:
+  *	This symbol, if defined, means that PGP support should be compiled in.
+  */
+ /* PGP_PATH:
+  *	The path to the PGP binary.
+  */
+ #$d_pgp USE_PGP /**/
+ #ifdef USE_PGP
+ #define PGP_PATH "$pgp_path"
+ #endif
+ 
+ /* USE_REMAILER:
+  *	If defined, includes support for anonymous remailing, chaining, and
+  *      if USE_PGP is defined, encryption.
+  */
+ #$d_remailer USE_REMAILER /**/
  !GROK!THIS!

diff -c elm-2.4pl24/doc/elmrc-info elm-2.4pl24me8/doc/elmrc-info
*** elm-2.4pl24/doc/elmrc-info	Fri Mar 11 13:19:26 1994
--- elm-2.4pl24me8/doc/elmrc-info	Mon Sep 18 14:37:51 1995
***************
*** 88,93 ****
--- 88,123 ----
  weed
  # enable the weedout list to be read?
  
+ noencoding
+ # This control makes it possible to send raw 8bit or binary data when the MTA
+ # doesn't support 8BITMIME and the -B8BITMIME option or
+ # BINARYMIME and the -BBINARYMIME option
+ #
+ # Possible values:
+ #    0 : Always convert 8BIT and BINARY data to QUOTED-PRINTABLE if the MTA
+ #        doesn't support the -B8BITMIME and -BBINARYMIME options.
+ #    1 : Allow 8bit without -B8BITMIME, but binary data is encoded
+ #    2+: Allow binary without -BBINARYMIME and and 8bit without -B8BITMIME
+ #
+ # It is STRONGLY recommended that it be left set to 0 unless you know what
+ # you are doing!!
+ #
+ # Elm doesn't yet fully support BINARYMIME: it requires that text lines are
+ # terminated with \r\n, Unix's \n isn't sufficient!
+ # That is only partially implemented in this version of Elm.
+ #
+ # Quote from RFC 1830 (Experimental Protocol): 
+ #  SMTP Service Extensions for Transmission of Large and Binary MIME Messages
+ #
+ #      It is important to note that when using BINARYMIME, it is
+ #      especially important to ensure that the MIME message itself is
+ #      properly formed.  In particular, it is essential that text be
+ #      canonically encoded with each line properly terminated with <CR>
+ #      <LF>.  Any transformation of text into non-canonical MIME to
+ #      observe local storage conventions must be reversed before sending
+ #      as BINARYMIME.  The usual line-oriented shortcuts will break if
+ #      used with BINARYMIME.
+ 
  noheader
  # when messages are copied into the outbound buffer, don't include headers?
  
***************
*** 247,250 ****
  textencoding
  # Type of encoding to be put into the MIME Content-Transfer-Encoding header.
  # Usual values are 7bit or 8bit.
! # NOTE: Elm will not encode your message based on this variable.
--- 277,306 ----
  textencoding
  # Type of encoding to be put into the MIME Content-Transfer-Encoding header.
  # Usual values are 7bit or 8bit.
! #
! # -- NOT Used in this version of elm (2.4 PL24 ME7)
! # Now elm analyzes mail when sending and does that encoding of quoted-printable
! # when necessary.
! 
! showto
! # if this variable is ON, Elm will show who the message is to rather than
! # who it is from in the headers display.
! 
! usepgppass
! # If ON, Elm will prompt you for your PGP passphrase and use it whenever
! # necessary to make it more convenient to hand PGP messages.
! 
! keeppassfor
! # The number of seconds Elm should remember your passphrase.  -1 means never
! # expire it.
! 
! pagemultipart
! # Should Elm use "pager" to display MIME multipart messages?
! 
! mimeforward
! # This option controls how Elm will forward messages when MIME is defined.
! #	ON: Causes Elm to send the message as a MIME attachment of type
! #		MESSAGE/RFC822.  Highly recommended when forwarding MIME
! #		messages so that the receiver can correctly view the message!
! #	OFF: Elm will include the forwarded message in your editor instead
! #		of making it an attachment.

diff -c /dev/null elm-2.4pl24me8/doc/mime.types
*** /dev/null	Thu Sep 21 15:27:01 1995
--- elm-2.4pl24me8/doc/mime.types	Mon Aug 28 17:53:49 1995
***************
*** 0 ****
--- 1,27 ----
+ # mime.types for Elm 2.4PL24 ME8 (or greater)
+ #
+ # Format of this file:
+ # <suffix> <content-type>
+ #
+ # Elm already has the following "builtin" definitions:
+ # ps	application/postscript
+ # gif	image/gif
+ # tiff	image/tiff
+ # jpeg	image/jpeg
+ #
+ # NOTE: data which is declared "application/octet-stream" will automatically
+ # have the "name=<default_filename>" option added to it, so you should not
+ # put it in your definitions.
+ 
+ gz	application/octet-stream
+ pbm	image/pbm
+ pgm	image/pgm
+ ppm	image/ppm
+ taz	application/octet-stream; type=tar; conversions=x-compress
+ tgz	application/octet-stream; type=tar; conversions=x-gzip
+ tar	application/octet-stream; type=tar
+ Z	application/octet-stream
+ zip	application/octet-stream; type=zip
+ 
+ # PGP users might want the following
+ pgp	application/pgp

diff -c elm-2.4pl24/hdrs/defs.h elm-2.4pl24me8/hdrs/defs.h
*** elm-2.4pl24/hdrs/defs.h	Thu Sep  1 12:42:39 1994
--- elm-2.4pl24me8/hdrs/defs.h	Thu Sep 21 15:05:01 1995
***************
*** 271,276 ****
--- 271,277 ----
  #define CM_MMDF_HEAD		(1<<3)	/* strip mmdf message seperator */
  #define CM_REMAIL		(1<<4)	/* Add Sender: and Orig-To: headers */
  #define CM_DECODE		(1<<5)	/* prompt for key if message is encrypted */
+ #define CM_REPLY		(1<<6)  /* this message is a reply */
  
  #define EXECUTE_ACCESS	1		/* These five are 	   */
  #define WRITE_ACCESS	2		/*    for the calls	   */
***************
*** 320,331 ****
  #define URGENT		256
  #define VISIBLE		512
  #define UNREAD		1024
! #define STATUS_CHANGED	2048
  #define MIME_MESSAGE	4096	/* indicates existence of MIME Header */
! #define MIME_NEEDDECOD	8192	/* indicates that we need to call mmdecode */
! #define	MIME_NOTPLAIN	16384	/* indicates that we have a content-type,
! 				   for which we need metamail anyway. */
  
  /** some defines for the "type" field of the alias record **/
  
  #define SYSTEM		1		/* bit masks, of course */
--- 321,337 ----
  #define URGENT		256
  #define VISIBLE		512
  #define UNREAD		1024
! #define REPLIED		2048
  #define MIME_MESSAGE	4096	/* indicates existence of MIME Header */
! #define PRE_MIME_CONTENT 8192
! #define MIME_UNSUPPORTED 16384
  
+ #ifdef USE_PGP
+ #define PGP_MESSAGE		1
+ #define PGP_SIGNED_MESSAGE	2
+ #define PGP_PUBLIC_KEY		4
+ #endif
+ 
  /** some defines for the "type" field of the alias record **/
  
  #define SYSTEM		1		/* bit masks, of course */
***************
*** 521,526 ****
--- 527,562 ----
  
  /* some random structs... */
  
+ #ifdef MIME
+ typedef struct mimeinfo {
+   unsigned int type : 3;        /* see mime.h for MIME_TYPE_* */
+   unsigned int disposition : 1; /* DISP_INLINE or DISP_ATTACH */
+   unsigned int unlink : 1;      /* used to mark that the file should be
+                                  * unlinked after sending the attachment */
+   unsigned int notplain : 1;
+ 
+   char subtype[WLEN];
+   char *type_opts;
+   char *disposition_opts;
+   char *description;
+ 
+   int encoding;      /* Notice: ENCODING_ILLEGAL == -1, ENCODING_* in mime.h */
+   long length;
+   long begin_offset; /* the beginning of the attachment (includes headers) */
+   long offset;       /* where the real data starts */
+   int flags;
+ 
+   struct mimeinfo *parts; /* If this is a multipart message, pointer
+                            * to the list of parts contained inside it */
+   
+   struct mimeinfo *next; /* pointer to the next attachment in the list */
+   
+   /* These next fields are only used when sending multipart messages. */
+   char *pathname;
+   struct mimeinfo *prev;
+ } mime_t;
+ #endif
+ 
  struct header_rec {
  	int  lines;		/** # of lines in the message	**/
  	int  status;		/** Urgent, Deleted, Expired?	**/
***************
*** 532,538 ****
  	long offset;		/** offset in bytes of message	**/
  	time_t received_time;	/** when elm received here	**/
  	char from[STRING];	/** who sent the message?	**/
! 	char to[STRING];	/** who it was sent to		**/
  	char messageid[STRING];	/** the Message-ID: value	**/
  	char time_zone[12];	/**                incl. tz	**/
  	time_t time_sent;	/** gmt when sent for sorting	**/
--- 568,575 ----
  	long offset;		/** offset in bytes of message	**/
  	time_t received_time;	/** when elm received here	**/
  	char from[STRING];	/** who sent the message?	**/
! 	char to[LONG_STRING];	/** who it was sent to		**/
!         char cc[LONG_STRING];
  	char messageid[STRING];	/** the Message-ID: value	**/
  	char time_zone[12];	/**                incl. tz	**/
  	time_t time_sent;	/** gmt when sent for sorting	**/
***************
*** 540,545 ****
--- 577,588 ----
  	time_t tz_offset;	/** offset to gmt of time sent	**/
  	char subject[STRING];   /** The subject of the mail	**/
  	char mailx_status[WLEN];/** mailx status flags (RO...)	**/
+ #ifdef MIME
+ 	mime_t mime_rec;        /** MIME information for this message **/
+ #endif
+ #ifdef USE_PGP
+ 	unsigned int pgp : 3;
+ #endif
         };
  
  #ifdef __alpha
***************
*** 666,672 ****
  
  #ifdef POSIX_SIGNALS
  #define signal posix_signal
! #if ANSI_C
  extern SIGHAND_TYPE (*posix_signal(int, SIGHAND_TYPE (*)(int)))(int);
  #else	/* ANSI_C */
  extern SIGHAND_TYPE (*posix_signal())();
--- 709,715 ----
  
  #ifdef POSIX_SIGNALS
  #define signal posix_signal
! #ifdef ANSI_C
  extern SIGHAND_TYPE (*posix_signal(int, SIGHAND_TYPE (*)(int)))(int);
  #else	/* ANSI_C */
  extern SIGHAND_TYPE (*posix_signal())();

diff -c elm-2.4pl24/hdrs/elm.h elm-2.4pl24me8/hdrs/elm.h
*** elm-2.4pl24/hdrs/elm.h	Thu Sep  1 12:42:40 1994
--- elm-2.4pl24me8/hdrs/elm.h	Thu Sep 21 15:06:21 1995
***************
*** 124,130 ****
  char display_charset[SLEN] = {0};	/* the charset, the display supports */
  char charset_compatlist[SLEN] = {0};	/* list of charsets which are a
  					   superset of us-ascii */
! char text_encoding[SLEN] = {0};	/* default encoding for text/plain */
  #endif
  char cur_folder[SLEN] = {0};	/* name of current folder */
  char cur_tempfolder[SLEN] = {0};/* name of temp folder open for a mailbox */
--- 124,133 ----
  char display_charset[SLEN] = {0};	/* the charset, the display supports */
  char charset_compatlist[SLEN] = {0};	/* list of charsets which are a
  					   superset of us-ascii */
! char text_encoding[SLEN] = {0};	/* default encoding for text/plain -- NOT USED */
! int allow_no_encoding = 0;      /* 1: Allow 8bit without -B8BITMIME
!                                  * 2: Allow binary without -BBINARYMIME and
!                                  *    and 8bit without -B8BITMIME */
  #endif
  char cur_folder[SLEN] = {0};	/* name of current folder */
  char cur_tempfolder[SLEN] = {0};/* name of temp folder open for a mailbox */
***************
*** 292,294 ****
--- 295,314 ----
  
  JMP_BUF GetPromptBuf;		/* setjmp buffer */
  int InGetPrompt;		/* set if in GetPrompt() in read() */
+ #ifdef USE_PGP
+ int pgp_status=0; /* var to keep track of pgp internals */
+ int pgp_keeppass; /* should Elm keep the passphrase in memory? */
+ #endif
+ int me_retcode;
+ int showto;
+ #ifdef MIME
+ int pagemultipart=1;
+ short mime_count = 0; /* A counter used so that each call to
+                        * mime_generate_boundary() returns a unique value.
+                        */
+ mime_t *attachments = NULL;
+ int mimeforward = FALSE;
+ #endif
+ #ifdef USE_REMAILER
+ int remailing;
+ #endif

diff -c elm-2.4pl24/hdrs/headers.h elm-2.4pl24me8/hdrs/headers.h
*** elm-2.4pl24/hdrs/headers.h	Thu Sep  1 12:42:40 1994
--- elm-2.4pl24me8/hdrs/headers.h	Thu Sep 21 15:05:01 1995
***************
*** 120,125 ****
--- 120,128 ----
  extern char charset_compatlist[SLEN];	/* list of charsets which are a
  					   superset of us-ascii */
  extern char text_encoding[SLEN];	/* default encoding for text/plain */
+ extern allow_no_encoding;           /* 1: Allow 8bit without -B8BITMIME
+                                      * 2: Allow binary without -BBINARYMIME
+                                      *    and 8bit without -B8BITMIME */
  #endif
  extern char cur_folder[SLEN];	/* name of current folder */
  extern char cur_tempfolder[SLEN]; /* name of temp folder open for a mailbox */
***************
*** 283,285 ****
--- 286,301 ----
  
  extern JMP_BUF GetPromptBuf;	/* setjmp buffer */
  extern int InGetPrompt;		/* set if in GetPrompt() in read() */
+ #ifdef USE_PGP
+ extern int pgp_status;
+ extern int pgp_keeppass; /* should Elm keep the passphrase? */
+ extern int pgp_keeppassfor; /* how long to keep it before expiring */
+ #endif
+ extern int  showto;
+ extern int me_retcode;
+ #ifdef MIME
+ extern int pagemultipart;
+ extern char *mime_encode_names[]; /* defined in mime.c */
+ extern char *mime_types[];
+ extern int mimeforward;
+ #endif

diff -c /dev/null elm-2.4pl24me8/hdrs/me.h
*** /dev/null	Thu Sep 21 15:27:01 1995
--- elm-2.4pl24me8/hdrs/me.h	Thu Sep 21 13:20:31 1995
***************
*** 0 ****
--- 1,113 ----
+ #ifdef MIME
+ 
+ /** Definitions for state operations **/
+ typedef struct state {
+   FILE *fpin;
+   FILE *fpout;
+   char *prefix;
+   unsigned int displaying : 1;
+ } state_t;
+ 
+ #define state_put(x,y,z) fwrite(x,1,y,z->fpout)
+ #define state_putc(c,s) fputc(c,s->fpout)
+ #define state_puts(x,y) fputs(x,y->fpout)
+ #define state_add_prefix(x) if(x->prefix)state_puts(x->prefix,x)
+ 
+ #endif
+ 
+ #undef PARAM
+ #ifdef __STDC__
+ #define PARAM(x) x
+ #else
+ #define PARAM(x) ()
+ #endif
+ 
+ /* Function prototypes */
+ 
+ /* lib/strmcpy.c */
+ extern char *strmcpy PARAM((char *, char *));
+ 
+ #ifdef USE_REMAILER
+ #ifdef MIME
+ extern int remailer_copy_message_across PARAM((FILE *, FILE *, int, mime_send_t *));
+ #else
+ extern int remailer_copy_message_across PARAM((FILE *, FILE *, int));
+ #endif
+ extern void remailer_proc PARAM((void));
+ #endif
+ 
+ #ifdef USE_PGP
+ extern int pgp_decrypt_init		PARAM((FILE **, FILE **, int));
+ extern int pgp_encrypt			PARAM((char *, char *, int));
+ extern int pgp_menu			PARAM((char *));
+ extern int pgp_extract_public_key	PARAM((void));
+ #ifdef MIME
+ extern void mime_pgp_decode		PARAM((mime_t *, state_t *));
+ #endif
+ #endif
+ 
+ extern int metapager		PARAM((FILE *, struct header_rec *, int));
+ extern int builtinplusplus	PARAM((FILE *, long, int, char **, int));
+ 
+ #ifdef MIME
+ extern int save_copy		PARAM((char *, char *, char *, char *, 
+ 				       char *, int, mime_send_t *));
+ extern int append_copy_to_file	PARAM((char *, char *, char *, char *, 
+ 				       char *, int, mime_send_t *));
+ extern FILE *write_header_info	PARAM((char *, char *, char *, char *, 
+ 				       int, int, mime_send_t *));
+ extern int copy_message_across	PARAM((FILE *, FILE *, int, mime_send_t *));
+ extern int check_for_multipart	PARAM((FILE *, mime_send_t *));
+ extern int Include_Part		PARAM((FILE *, char *, int, mime_send_t *, 
+ 				       int));
+ 
+ /* mime_decode.c */
+ extern void Xbit_decode			PARAM((state_t *, int));
+ extern void base64_decode		PARAM((state_t *, int, int));
+ extern void quoted_printable_decode	PARAM((state_t *, int, int));
+ extern void multipart_decode		PARAM((mime_t *, state_t *));
+ extern void multipart_0_decode          PARAM((mime_t *, state_t *));
+ extern void rfc822_decode		PARAM((mime_t *, state_t *));
+ extern void text_decode			PARAM((mime_t *, state_t *));
+ extern void text_unsupported_decode	PARAM((mime_t *, state_t *));
+ extern void null_decode			PARAM((mime_t *, state_t *));
+ extern void mime_decode			PARAM((mime_t *, state_t *));
+ 
+ typedef void CT_decoder			PARAM((mime_t *, state_t *));
+ typedef CT_decoder *CT_decoder_t;
+ extern CT_decoder_t select_CT_decoder	PARAM((mime_t *));
+ 
+ /* mime_encode.c */
+ extern void attach_generate_message		PARAM((mime_t *, FILE *, int,
+ 						       mime_send_t *));
+ extern void base64_encode	PARAM((FILE *, FILE *, int, mime_send_t *));
+ extern void line_quoted_printable_encode	PARAM((char *, FILE *, int, int,
+ 						       int, mime_send_t *));
+ extern void quoted_printable_encode		PARAM((FILE *, FILE *, int,
+ 						       int, mime_send_t *));
+ extern int is_text_type				PARAM((char *, char *, int));
+ extern char *mime_generate_boundary		PARAM((char *));
+ extern void add_parameter		PARAM((char *,char *,char *,int, int));
+ extern void print_EOLN				PARAM((FILE *,int));
+ extern int update_encoding			PARAM((int *,int));
+ extern void write_encoded PARAM((FILE *, FILE *, int, int, int,mime_send_t *));
+ extern void mime_write_header			PARAM((FILE *, mime_send_t *));
+ 
+ /* mime_parse.c */
+ extern mime_t *mime_t_alloc             PARAM((void));
+ extern void mime_t_zero                 PARAM((mime_t *));
+ extern void mime_destroy		PARAM((mime_t *));
+ extern void mime_get_disposition        PARAM((char *, mime_t *));
+ extern void mime_get_content		PARAM((char *, mime_t *));
+ extern int mime_get_charset             PARAM((char *, char *, int));
+ extern char * mime_parse_content_opts	PARAM((char *));
+ extern void rfc822_reap_comments        PARAM((char *, char *, int));
+ extern int read_header_line             PARAM((FILE *,char *,int));
+ extern int mime_get_param               PARAM((char *,char *,char *,int));
+ extern void mime_warnings		PARAM((struct header_rec *));
+ extern mime_t *rfc822_parse		PARAM((FILE *, int));
+ extern void attach_parse		PARAM((struct header_rec *,FILE *));
+ 
+ /* attach_menu.c */
+ extern mime_t *attach_menu		PARAM((mime_t *, int));
+ #endif

diff -c /dev/null elm-2.4pl24me8/hdrs/menu.h
*** /dev/null	Thu Sep 21 15:27:01 1995
--- elm-2.4pl24me8/hdrs/menu.h	Tue Aug 22 23:21:01 1995
***************
*** 0 ****
--- 1,24 ----
+ /* $Id: $
+  *
+  * $Log: $
+  */
+ 
+ /* returns the number of the current selection from the menu */
+ #define MenuCurrent(X) X.current
+ 
+ /* this will make MenuLoop() update the screen on the next call */
+ #define MenuUpdate(X) (X.update = 1)
+ 
+ struct menu_object {
+   char **data;
+   char *title;
+   char *prompt;
+   char *help;
+   int prompt_length;
+   int len;
+   int max;
+   int current;
+   int pagetop; /* the index of the first entry on this page */
+   unsigned int update : 1;
+ };
+ typedef struct menu_object menu_t;

diff -c /dev/null elm-2.4pl24me8/hdrs/menu2.h
*** /dev/null	Thu Sep 21 15:27:01 1995
--- elm-2.4pl24me8/hdrs/menu2.h	Wed Aug  9 16:01:26 1995
***************
*** 0 ****
--- 1,10 ----
+ struct menu_item {
+   char *option;
+   char key;
+   char offset;
+   char type;
+   union ptrs { 
+     char *c;
+     int *i; /* used by BOL and INT */
+   } d;
+ };

diff -c elm-2.4pl24/hdrs/mime.h elm-2.4pl24me8/hdrs/mime.h
*** elm-2.4pl24/hdrs/mime.h	Sat Nov  7 12:50:23 1992
--- elm-2.4pl24me8/hdrs/mime.h	Wed Sep 20 16:06:50 1995
***************
*** 30,42 ****
  #define	MIME_HEADER	"MIME-Version: 1.0"
  #define	MIME_HEADER_NAME	"MIME-Version"
  #define	MIME_HEADER_VERSION	"1.0"
- #define	MIME_OLDVERSION	"MIME-Version: RFCXXXX"
- #define	MIME_HEADER_OLDVERSION	"RFCXXXX"
  #define	MIME_INCLUDE	"[include"
- #define MIME_BOUNDARY	"%#%record%#%"	/* default boundary */
  #define	MIME_CONTENTTYPE	"Content-Type:"
  #define	MIME_HEADER_CONTENTTYPE	"Content-Type"
  #define	MIME_CONTENTENCOD	"Content-Transfer-Encoding:"
  #define	MIME_HEADER_CONTENTENCOD	"Content-Transfer-Encoding"
  
  /* Encoding types */
--- 30,41 ----
  #define	MIME_HEADER	"MIME-Version: 1.0"
  #define	MIME_HEADER_NAME	"MIME-Version"
  #define	MIME_HEADER_VERSION	"1.0"
  #define	MIME_INCLUDE	"[include"
  #define	MIME_CONTENTTYPE	"Content-Type:"
+ #define	MIME_CONTENTTYPE_LEN	13
  #define	MIME_HEADER_CONTENTTYPE	"Content-Type"
  #define	MIME_CONTENTENCOD	"Content-Transfer-Encoding:"
+ #define	MIME_CONTENTENCOD_LEN	26
  #define	MIME_HEADER_CONTENTENCOD	"Content-Transfer-Encoding"
  
  /* Encoding types */
***************
*** 56,62 ****
  #define	ENC_NAME_QUOTED "quoted-printable"
  #define	ENC_NAME_BASE64	"base64"
  
! /* default charsets, which are a superset of US-ASCII, so we did not
     have to go out to metamail for us-ascii */
  
! #define COMPAT_CHARSETS "ISO-8859-1 ISO-8859-2 ISO-8859-3 ISO-8859-4 ISO-8859-5 ISO-8859-7 ISO-8859-8 ISO-8859-9"
--- 55,117 ----
  #define	ENC_NAME_QUOTED "quoted-printable"
  #define	ENC_NAME_BASE64	"base64"
  
! /* Default charsets, which are a superset of US-ASCII, so we do not
     have to go out to metamail for us-ascii */
  
! #define COMPAT_CHARSETS "ISO-8859-1 ISO-8859-2 ISO-8859-3 ISO-8859-4 ISO-8859-5 ISO-8859-7 ISO-8859-8 ISO-8859-9 KOI8-R"
! 
! /* These are for figuring out what the encoding on outgoing messages should
!  * be.
!  */
! #define HAVE_8BIT 1
! #define HAVE_CTRL 4
! #define HAVE_BINARY 8
! 
! /* Possible major types in Content-Type field. */
! #define MIME_TYPE_UNKNOWN	0
! #define MIME_TYPE_APPLICATION	1
! #define MIME_TYPE_AUDIO		2
! #define MIME_TYPE_IMAGE		3
! #define MIME_TYPE_MESSAGE	4
! #define MIME_TYPE_MULTIPART	5
! #define MIME_TYPE_TEXT		6
! #define MIME_TYPE_VIDEO		7
! 
! /* Values for the "flag" field in "mimeinfo" */
! #define MIME_RFC822 1
! #define MIME_MIXED 2
! #define MIME_DIGEST 4
! 
! /* Content-Disposition */
! #define DISP_INLINE	0
! #define DISP_ATTACH	1
! 
! #define DISPOSITION(x) (x == DISP_INLINE ? "inline" : "attachment")
! #define TYPE(x) (mime_types[(x)])
! #define NONULL(x) (x ? x : "")
! #define ENCODING(x) (x >= 0 ? mime_encode_names[x] : "<ILLEGAL>")
! 
! typedef struct mime_send {    /* Mime parameters for this mail */
!   int encoding_top; /* Encoding for top multipart type.
!                      * ENCODING_8BIT:   add content_transfer_encoding: 8bit
!                      *                  pass -B8BITMIME to mailer
!                      * ENCODING_BINARY: add content_transfer_encoding: binary
! 		     *                  pass -BBINARYMIME to mailer
!                      */
!   int encoding_text;/* Encoding of text parts (nt attachments)
! 		     * ENCODING_QUOTED: 
! 		     *         add content_transfer_encoding: quoted-printable
! 		     * ENCODING_8BIT:
! 		     *         add content_transfer_encoding: 8bit
! 		     */
!   char * Charset;   /* Charset of text */
!   int need_enc;     /* Bitmask: HAVE_8BIT:   have 8-bit data
! 		     *          HAVE_BINARY: have 'binary' data
! 		     *          HAVE_CTRL:   have control characters
! 		     */
!   int msg_is_multipart;
!   char mime_boundary[STRING];
!   unsigned int type : 3;
!   char subtype[STRING];
!   char type_opts[STRING];
! } mime_send_t;

diff -c elm-2.4pl24/hdrs/patchlevel.h elm-2.4pl24me8/hdrs/patchlevel.h
*** elm-2.4pl24/hdrs/patchlevel.h	Fri Sep 23 18:37:45 1994
--- elm-2.4pl24me8/hdrs/patchlevel.h	Thu Sep 21 15:19:18 1995
***************
*** 1 ****
! #define PATCHLEVEL "24"
--- 1 ----
! #define PATCHLEVEL "24 ME8"

diff -c elm-2.4pl24/hdrs/s_elm.h elm-2.4pl24me8/hdrs/s_elm.h
*** elm-2.4pl24/hdrs/s_elm.h	Tue Aug  3 11:58:35 1993
--- elm-2.4pl24me8/hdrs/s_elm.h	Mon Jul 24 11:28:04 1995
***************
*** 759,761 ****
--- 759,762 ----
  #define ElmVfyMenuSndFgt	0x34e
  #define ElmVfyMessageKept	0x34f
  #define ElmVfyNoFieldsInForm	0x350
+ #define ElmHelpViewAttach       0x351

diff -c elm-2.4pl24/hdrs/save_opts.h elm-2.4pl24me8/hdrs/save_opts.h
*** elm-2.4pl24/hdrs/save_opts.h	Tue Aug 10 11:49:32 1993
--- elm-2.4pl24me8/hdrs/save_opts.h	Mon Sep 18 14:17:42 1995
***************
*** 196,201 ****
--- 196,204 ----
  {"hpsoftkeys",		-1L,DT_SYN,"softkeys"},
  {"keep",		-1L,DT_SYN,"keepempty"},
  {"keepempty",		-1L,DT_BOL,(char *)&keep_empty_files},
+ #ifdef USE_PGP
+ {"keeppassfor", -1L,DT_NUM,(char *)&pgp_keeppassfor},
+ #endif
  {"keypad",		-1L,DT_BOL|FL_OR,(char *)&hp_terminal},
  {"localsignature",	-1L,DT_STR,raw_local_signature},
  {"mailbox",		-1L,DT_SYN,"receivedmail"},
***************
*** 204,215 ****
--- 207,230 ----
  {"menu",		-1L,DT_BOL|FL_AND,(char *)&mini_menu},
  {"menus",		-1L,DT_SYN,"menu"},
  {"metoo",		-1L,DT_BOL,(char *)&metoo},
+ #ifdef MIME
+ {"mimeforward",		-1L,DT_BOL,(char *)&mimeforward},
+ #endif
  {"movepage",		-1L,DT_BOL,(char *)&move_when_paged},
  {"movewhenpaged",	-1L,DT_SYN,"movepage"},
  {"name",		-1L,DT_SYN,"fullname"},
  {"names",		-1L,DT_BOL,(char *)&names_only},
+ #ifdef MIME
+ {"noencoding",-1L,DT_NUM,(char *)&allow_no_encoding},
+                                  /* 1: Allow 8bit without -B8BITMIME
+                                   * 2: Allow binary without -BBINARYMIME and
+                                   *    and 8bit without -B8BITMIME */
+ #endif /* MIME **/
  {"noheader",		-1L,DT_BOL,(char *)&noheader},
  {"page",		-1L,DT_SYN,"pager"},
+ #ifdef MIME
+ {"pagemultipart",	-1L,DT_BOL,(char *)&pagemultipart},
+ #endif /* MIME */
  {"pager",		-1L,DT_STR,raw_pager},
  {"pointnew",		-1L,DT_BOL,(char *)&point_to_new},
  {"pointtonew",		-1L,DT_SYN,"pointnew"},
***************
*** 229,234 ****
--- 244,250 ----
  {"saveto",		-1L,DT_SYN,"sentmail"},
  {"sentmail",		-1L,DT_STR,raw_sentmail},
  {"shell",		-1L,DT_STR,raw_shell},
+ {"showto",		-1L,DT_BOL,(char *)&showto},
  {"sigdashes",		-1L,DT_BOL,(char *)&sig_dashes},
  {"signature",		-1L,DT_MLT,(char *)SIGS},
  {"sleepmsg",		-1L,DT_NUM,(char *)&sleepmsg},
***************
*** 242,247 ****
--- 258,266 ----
  {"timeout",		-1L,DT_NUM,(char *)&timeout},
  {"titles",		-1L,DT_BOL,(char *)&title_messages},
  {"tmpdir",		-1L,DT_STR,raw_temp_dir},
+ #ifdef USE_PGP
+ {"usepgppass",          -1L,DT_BOL,(char *)&pgp_keeppass},
+ #endif
  {"userlevel",		-1L,DT_NUM,(char *)&user_level},
  {"username",		-1L,DT_SYN,"fullname"},
  {"usetite",		-1L,DT_BOL|FL_AND,(char *)&use_tite},

diff -c elm-2.4pl24/hdrs/sysdefs.SH elm-2.4pl24me8/hdrs/sysdefs.SH
*** elm-2.4pl24/hdrs/sysdefs.SH	Thu Dec 24 11:24:11 1992
--- elm-2.4pl24me8/hdrs/sysdefs.SH	Thu Sep 21 14:40:13 1995
***************
*** 54,60 ****
  
  /**  System level, configurable, defines for the ELM mail system.  **/
  
- 
  #define MAX_IN_WEEDLIST 150	/* max headers to weed out               */
  
  #define MAX_HOPS	35	/* max hops in return addr to E)veryone  */
--- 54,59 ----
***************
*** 81,86 ****
--- 80,86 ----
  #define system_text_file        "$lib/aliases.text"
  #define system_data_file        "$lib/aliases"
  #define system_rc_file		"$lib/elm.rc"
+ #define system_mime_types	"$lib/elm.mimetypes"
  
  #define ALIAS_TEXT		".elm/aliases.text"
  #define ALIAS_DATA		".elm/aliases"
***************
*** 94,100 ****
  #define	default_temp   	"$tmpdir/"
  #define temp_file	"snd."
  #define temp_form_file	"form."
! #define temp_mbox	"mbox."
  #define temp_print      "print."
  #define temp_edit	"elm-edit"
  #define temp_uuname	"uuname."
--- 94,100 ----
  #define	default_temp   	"$tmpdir/"
  #define temp_file	"snd."
  #define temp_form_file	"form."
! #define temp_mbox	".mbox."
  #define temp_print      "print."
  #define temp_edit	"elm-edit"
  #define temp_uuname	"uuname."

diff -c elm-2.4pl24/lib/Makefile.SH elm-2.4pl24me8/lib/Makefile.SH
*** elm-2.4pl24/lib/Makefile.SH	Tue Aug  3 12:28:46 1993
--- elm-2.4pl24me8/lib/Makefile.SH	Tue Sep  5 14:21:01 1995
***************
*** 188,193 ****
--- 188,195 ----
  			can_open.c	\
  			chloc.c		\
  			date_util.c	\
+ 			dispaddr.c	\
+ 			dynarray.c	\
  			errno.c		\
  			expand.c	\
  			figadrssee.c	\
***************
*** 195,200 ****
--- 197,203 ----
  			getaddrfrm.c	\
  			getarpdate.c	\
  			getfullnam.c	\
+ 			getrealname.c	\
  			getword.c	\
  			get_tz.c	\
  			header_cmp.c	\
***************
*** 225,230 ****
--- 228,234 ----
  			striparens.c	\
  			$(STRSRC)	\
  			$(FTIMESRC)	\
+ 			strmcpy.c	\
  			strtokq.c	\
  			tail_of.c	\
  			validname.c
***************
*** 239,244 ****
--- 243,250 ----
  			can_open.o	\
  			chloc.o		\
  			date_util.o	\
+ 			dispaddr.o	\
+ 			dynarray.o	\
  			errno.o		\
  			expand.o	\
  			figadrssee.o	\
***************
*** 247,252 ****
--- 253,259 ----
  			getaddrfrm.o	\
  			getarpdate.o	\
  			getfullnam.o	\
+ 			getrealname.o	\
  			getword.o	\
  			header_cmp.o	\
  			in_list.o	\
***************
*** 276,281 ****
--- 283,289 ----
  			striparens.o	\
  			$(STROBJ)	\
  			$(FTIMEOBJ)	\
+ 			strmcpy.o	\
  			strtokq.o	\
  			tail_of.o	\
  			validname.o
***************
*** 326,331 ****
--- 334,340 ----
  can_open.o:	$(INCLDIR)/headers.h
  chloc.o:	$(INCLDIR)/headers.h
  date_util.o:	$(INCLDIR)/headers.h
+ dispaddr.o:     $(INCLDIR)/headers.h
  errno.o:	$(INCLDIR)/headers.h
  expand.o:	$(INCLDIR)/defs.h $(INCLDIR)/s_elmrc.h
  figadrssee.o:	$(INCLDIR)/headers.h

diff -c /dev/null elm-2.4pl24me8/lib/dispaddr.c
*** /dev/null	Thu Sep 21 15:27:01 1995
--- elm-2.4pl24me8/lib/dispaddr.c	Thu Jul 13 11:06:52 1995
***************
*** 0 ****
--- 1,59 ----
+ /* $Id: dispaddr.c,v 1.3 1995/07/13 18:06:01 elkins Exp $
+  *
+  * $Log: dispaddr.c,v $
+  * Revision 1.3  1995/07/13  18:06:01  elkins
+  * DisplayAddress() now returns the "real name" part of the address if
+  * it is availible.
+  *
+  * Revision 1.2  1995/07/13  02:36:15  elkins
+  * fixed problem where messages in the =sent folder didn't print who the
+  * message was TO.
+  *
+  * Revision 1.1  1995/06/01  23:13:15  elkins
+  * Initial revision
+  *
+  */
+ 
+ #include "headers.h"
+ 
+ int
+ DisplayAddress (h, f)
+ struct header_rec *h;
+ char *f;
+ {
+   char *tmpc, tmpstr[STRING];
+   int i = 0, using_to = 0;
+ 
+   if (addr_matches_user (h->from, username)) {
+ 
+     /* I sent this message.  Use the TO address.  */
+ 
+     tmpc = h->to;
+     while (*tmpc && *tmpc!=',')
+       tmpstr[i++] = *tmpc++;
+     tmpstr[i] = '\0';
+     using_to = TRUE;
+   }
+   else if (okay_address(h->to, h->from) && okay_address(h->cc, h->from)) {
+ 
+     /* This message is not addressed to me. */
+ 
+     if (showto) {
+       char *tmpc;
+       int i = 0;
+       
+       tmpc = h->to;
+       while (*tmpc && *tmpc != ',')
+         tmpstr[i++] = *tmpc++;
+       tmpstr[i] = '\0';
+       using_to = 1;
+     } else
+       strcpy (tmpstr, h->from);
+   }
+   else /* This message is addressed to me. */
+     strcpy (tmpstr, h->from);
+ 
+   get_real_name (tmpstr, f);
+ 
+   return(using_to);
+ }

diff -c /dev/null elm-2.4pl24me8/lib/dynarray.c
*** /dev/null	Thu Sep 21 15:27:01 1995
--- elm-2.4pl24me8/lib/dynarray.c	Mon Sep 11 16:29:48 1995
***************
*** 0 ****
--- 1,56 ----
+ /* $Id: dynarray.c,v 1.2 1995/06/14 05:34:36 elkins Exp elkins $
+  *
+  * $Log: dynarray.c,v $
+  * Revision 1.2  1995/06/14 05:34:36  elkins
+  * fixed bug where DestroyDynamicArray will seg fault if exactly *max+n
+  * elements were allocated.
+  * From: weo@recco.de (Wolfgang Ocker)
+  *
+  * Revision 1.1  1995/06/01  23:14:35  elkins
+  * Initial revision
+  *
+  */
+ 
+ /** routines for handling of dynamic arrays **/
+ 
+ char **
+ DynamicArray (p, record_size, max, n)
+ char **p;
+ int record_size;
+ int *max;
+ int n;
+ {
+ 	int newmax, j;
+ 	char **c;
+ 
+ 	newmax = *max + n;
+ 
+ 	if (!p)
+ 		c = (char**)safe_malloc(record_size * (n+1));
+ 	else
+ 		c = (char**)safe_realloc(p, record_size * (newmax+1));
+ 
+ 	if (!c)
+ 		return(0);
+ 
+ 	for (j = *max ; j < newmax ; j++)
+ 		c[j] = 0;
+ 
+ 	*max = newmax;
+ 
+ 	return(c);
+ }
+ 
+ void
+ DestroyDynamicArray (p)
+ char **p;
+ {
+ 	char **b;
+ 
+ 	if (!p)
+ 		return;
+ 	b = p;
+ 	while (*b)
+ 		free(*b++);
+ 	free(p);
+ }

diff -c /dev/null elm-2.4pl24me8/lib/getrealname.c
*** /dev/null	Thu Sep 21 15:27:01 1995
--- elm-2.4pl24me8/lib/getrealname.c	Wed Aug  2 10:52:55 1995
***************
*** 0 ****
--- 1,45 ----
+ /* $Id: getrealname.c,v 1.2 1995/08/02 17:52:27 elkins Exp $
+  *
+  * This code originally written by Michael Elkins <elkins@aero.org>
+  *
+  * $Log: getrealname.c,v $
+  * Revision 1.2  1995/08/02  17:52:27  elkins
+  * older BSD systems need <ctype.h>
+  * From: Michael Finken <finken@conware.de>
+  *
+  * Revision 1.1  1995/07/13  18:07:32  elkins
+  * Initial revision
+  *
+  */
+ 
+ #include <ctype.h>
+ 
+ /* copies the "real name" part of s to d */
+ get_real_name (s, d)
+ char *s, *d;
+ {
+   char *p;
+   int i = 0;
+ 
+   if ((p = (char*)strchr(s, '(')) != 0) {
+     p++;
+     while (*p && *p != ')')
+       d[i++] = *p++;
+     d[i] = '\0';
+   } else {
+     while (*s && (isspace(*s) || *s == '"')) ++s;
+     if (*s == '<') {
+       /* with addresses like "<elkins@aero.org>", use the email address
+          instead of a zero length string (no real name part). */
+       s++;
+       while (*s && *s!='>')
+         d[i++] = *s++;
+     }
+     else {
+       while (*s && *s != '"' && *s != '<')
+         d[i++] = *s++;
+     }
+     d[i] = '\0';
+     remove_possible_trailing_spaces(d);
+   }
+ }

diff -c elm-2.4pl24/lib/in_list.c elm-2.4pl24me8/lib/in_list.c
*** elm-2.4pl24/lib/in_list.c	Sat Oct  3 15:42:24 1992
--- elm-2.4pl24me8/lib/in_list.c	Thu Jun  1 16:46:41 1995
***************
*** 66,71 ****
--- 66,75 ----
  	    if(strcmp(next_item, lower_target) == 0)
  		return(TRUE);
  
+             if(index(lower_target,'*')!=0){
+ 	      if (globmatch(next_item,lower_target))
+                 return(TRUE);
+             } else
  	    if(strpbrk(lower_target,"!@%:") != NULL) {
  
  	      /* Target is complex */
***************
*** 85,88 ****
--- 89,128 ----
  	    rest_of_list = NULL;
  	}
  	return(FALSE);
+ }
+ 
+ int
+ globmatch (string, pat)
+ char *string, *pat;
+ {
+   char buf[1024];
+   int i=0,j=0,k,offset=0;
+   
+   for (;;) {
+     k=0;
+     while (pat[j]!='*' && pat[j]!='\0') {
+       buf[k++]=pat[j++];
+     }
+     buf[k]='\0';
+ 
+     /* check everything up to the first '*' */
+     if (strncmp(string+offset,buf,i=strlen(buf))!=0)
+       return(FALSE);
+ 
+     /* if we have run out of pattern, then the string matches... */
+     if (pat[j]=='\0' || pat[j+1]=='\0')
+       return(TRUE);
+ 
+     ++j; /* advance to the next 'real' character in the pattern */
+ 
+     /* ffwd to the next real char that matches */
+     while (string[i] != pat[j]) {
+       /* if we still have pattern, but no string, then it doesn't match */
+       if (string[i]=='\0')
+ 	return(FALSE);
+       i++;
+     }
+     offset+=i;
+   }
+   /* not reached */
  }

diff -c /dev/null elm-2.4pl24me8/lib/strmcpy.c
*** /dev/null	Thu Sep 21 15:27:01 1995
--- elm-2.4pl24me8/lib/strmcpy.c	Wed Sep  6 11:58:42 1995
***************
*** 0 ****
--- 1,13 ----
+ char *
+ strmcpy (dest, src)
+ 	char *dest, *src;
+ {
+ 	int len = strlen (src) + 1;
+ 
+ 	if (dest)
+ 		dest = (char *) safe_realloc (dest, len);
+ 	else
+ 		dest = (char *) safe_malloc (len);
+ 	strcpy (dest, src);
+ 	return dest;
+ }

diff -c elm-2.4pl24/lib/tail_of.c elm-2.4pl24me8/lib/tail_of.c
*** elm-2.4pl24/lib/tail_of.c	Sat Oct  3 15:42:30 1992
--- elm-2.4pl24me8/lib/tail_of.c	Wed Apr 12 15:29:19 1995
***************
*** 105,110 ****
--- 105,113 ----
  	  } else
  	    strcpy(buffer, full_username);
  
+ 	} else if (showto && to != 0 && strcmp (to, username) != 0) {
+ 		tail_of (to, buffer, (char *)0);
+ 		using_to = 1;
  	} else {					/* user%host@host? */
  
  	  /** The logic here is that we're going to use 'loc' as a handy

diff -c elm-2.4pl24/src/Makefile.SH elm-2.4pl24me8/src/Makefile.SH
*** elm-2.4pl24/src/Makefile.SH	Thu Dec 24 13:42:05 1992
--- elm-2.4pl24me8/src/Makefile.SH	Thu Sep 14 22:05:06 1995
***************
*** 92,99 ****
  			a_screen.c	\
  			a_sort.c	\
  			a_quit.c	\
  			bouncebk.c	\
! 			builtin.c	\
  			calendar.c	\
  			curses.c	\
  			date.c		\
--- 92,100 ----
  			a_screen.c	\
  			a_sort.c	\
  			a_quit.c	\
+ 			attach_menu.c	\
  			bouncebk.c	\
! 			builtin++.c	\
  			calendar.c	\
  			curses.c	\
  			date.c		\
***************
*** 118,133 ****
--- 119,142 ----
  			limit.c		\
  			mailmsg1.c	\
  			mailmsg2.c	\
+ 			menu.c		\
+ 			menu2.c		\
+ 			metapager.c	\
  			mime.c		\
+ 			mime_decode.c	\
+ 			mime_encode.c	\
+ 			mime_parse.c	\
  			mkhdrs.c	\
  			newmbox.c	\
  			options.c	\
  			out_utils.c	\
  			pattern.c	\
+ 			pgp.c		\
  			pmalloc.c	\
  			quit.c		\
  			read_rc.c	\
  			remail.c	\
+ 			remailer.c	\
  			reply.c		\
  			returnadd.c	\
  			save_opts.c	\
***************
*** 149,160 ****
  			alias.o		\
  			aliaslib.o	\
  			args.o		\
  			a_edit.o	\
  			a_screen.o	\
  			a_sort.o	\
  			a_quit.o	\
  			bouncebk.o	\
! 			builtin.o	\
  			calendar.o	\
  			curses.o	\
  			date.o		\
--- 158,170 ----
  			alias.o		\
  			aliaslib.o	\
  			args.o		\
+ 			attach_menu.o	\
  			a_edit.o	\
  			a_screen.o	\
  			a_sort.o	\
  			a_quit.o	\
  			bouncebk.o	\
! 			builtin++.o	\
  			calendar.o	\
  			curses.o	\
  			date.o		\
***************
*** 179,194 ****
--- 189,212 ----
  			limit.o		\
  			mailmsg1.o	\
  			mailmsg2.o	\
+ 			menu.o		\
+ 			menu2.o		\
+ 			metapager.o	\
  			mime.o		\
+ 			mime_decode.o	\
+ 			mime_encode.o   \
+ 			mime_parse.o	\
  			mkhdrs.o	\
  			newmbox.o	\
  			options.o	\
  			out_utils.o	\
  			pattern.o	\
+ 			pgp.o		\
  			pmalloc.o	\
  			quit.o		\
  			read_rc.o	\
  			remail.o	\
+ 			remailer.o	\
  			reply.o		\
  			returnadd.o	\
  			save_opts.o	\
***************
*** 254,260 ****
  			$(CHMOD) u+w $@
  			$(TOUCH) $@
  
! $(INCLDIR)/headers.h:	$(INCLDIR)/curses.h $(INCLDIR)/defs.h
  			$(CHMOD) u+w $@
  			$(TOUCH) $@
  
--- 272,278 ----
  			$(CHMOD) u+w $@
  			$(TOUCH) $@
  
! $(INCLDIR)/headers.h:	$(INCLDIR)/curses.h $(INCLDIR)/defs.h $(INCLDIR)/mime.h
  			$(CHMOD) u+w $@
  			$(TOUCH) $@
  
***************
*** 267,274 ****
  a_screen.o:	$(INCLDIR)/headers.h $(INCLDIR)/s_aliases.h
  a_sort.o:	$(INCLDIR)/headers.h $(INCLDIR)/s_aliases.h
  a_quit.o:	$(INCLDIR)/headers.h $(INCLDIR)/s_aliases.h
  bouncebk.o:	$(INCLDIR)/headers.h
! builtin.o:	$(INCLDIR)/headers.h $(INCLDIR)/s_elm.h
  calendar.o:	$(INCLDIR)/headers.h
  curses.o:	$(INCLDIR)/headers.h
  date.o:		$(INCLDIR)/headers.h
--- 285,293 ----
  a_screen.o:	$(INCLDIR)/headers.h $(INCLDIR)/s_aliases.h
  a_sort.o:	$(INCLDIR)/headers.h $(INCLDIR)/s_aliases.h
  a_quit.o:	$(INCLDIR)/headers.h $(INCLDIR)/s_aliases.h
+ attach_menu.o:	$(INCLDIR)/headers.h $(INCLDIR)/me.h
  bouncebk.o:	$(INCLDIR)/headers.h
! builtin++.o:	$(INCLDIR)/headers.h $(INCLDIR)/me.h
  calendar.o:	$(INCLDIR)/headers.h
  curses.o:	$(INCLDIR)/headers.h
  date.o:		$(INCLDIR)/headers.h
***************
*** 275,287 ****
  delete.o:	$(INCLDIR)/headers.h $(INCLDIR)/s_elm.h
  edit.o:		$(INCLDIR)/headers.h $(INCLDIR)/s_elm.h
  editmsg.o:	$(INCLDIR)/headers.h $(INCLDIR)/s_elm.h
! elm.o:		$(INCLDIR)/elm.h $(INCLDIR)/s_elm.h
  encode.o:	$(INCLDIR)/headers.h $(INCLDIR)/s_elm.h
  exitprog.o:	$(INCLDIR)/headers.h $(INCLDIR)/s_elm.h
  expires.o:	$(INCLDIR)/headers.h
  file.o:		$(INCLDIR)/headers.h $(INCLDIR)/s_elm.h
  file_util.o:	$(INCLDIR)/headers.h $(INCLDIR)/s_elm.h
! fileio.o:	$(INCLDIR)/headers.h $(INCLDIR)/s_elm.h
  find_alias.o:	$(INCLDIR)/headers.h
  forms.o:	$(INCLDIR)/headers.h $(INCLDIR)/s_elm.h
  hdrconfg.o:	$(INCLDIR)/headers.h $(INCLDIR)/s_elm.h
--- 294,306 ----
  delete.o:	$(INCLDIR)/headers.h $(INCLDIR)/s_elm.h
  edit.o:		$(INCLDIR)/headers.h $(INCLDIR)/s_elm.h
  editmsg.o:	$(INCLDIR)/headers.h $(INCLDIR)/s_elm.h
! elm.o:		$(INCLDIR)/elm.h $(INCLDIR)/s_elm.h $(INCLDIR)/me.h
  encode.o:	$(INCLDIR)/headers.h $(INCLDIR)/s_elm.h
  exitprog.o:	$(INCLDIR)/headers.h $(INCLDIR)/s_elm.h
  expires.o:	$(INCLDIR)/headers.h
  file.o:		$(INCLDIR)/headers.h $(INCLDIR)/s_elm.h
  file_util.o:	$(INCLDIR)/headers.h $(INCLDIR)/s_elm.h
! fileio.o:	$(INCLDIR)/headers.h $(INCLDIR)/s_elm.h $(INCLDIR)/me.h
  find_alias.o:	$(INCLDIR)/headers.h
  forms.o:	$(INCLDIR)/headers.h $(INCLDIR)/s_elm.h
  hdrconfg.o:	$(INCLDIR)/headers.h $(INCLDIR)/s_elm.h
***************
*** 289,308 ****
  in_utils.o:	$(INCLDIR)/headers.h $(INCLDIR)/s_elm.h
  init.o:		$(INCLDIR)/headers.h $(INCLDIR)/patchlevel.h $(INCLDIR)/s_elm.h
  leavembox.o:	$(INCLDIR)/headers.h $(INCLDIR)/s_elm.h
- lock.o:		$(INCLDIR)/headers.h $(INCLDIR)/s_elm.h
  limit.o:	$(INCLDIR)/headers.h $(INCLDIR)/s_elm.h $(INCLDIR)/s_aliases.h
  mailmsg1.o:	$(INCLDIR)/headers.h $(INCLDIR)/s_elm.h
  mailmsg2.o:	$(INCLDIR)/headers.h $(INCLDIR)/s_elm.h
! mkhdrs.o:	$(INCLDIR)/headers.h $(INCLDIR)/s_elm.h
  mime.o:		$(INCLDIR)/headers.h $(INCLDIR)/s_elm.h
  newmbox.o:	$(INCLDIR)/headers.h $(INCLDIR)/s_elm.h
  options.o:	$(INCLDIR)/headers.h $(INCLDIR)/s_elm.h $(INCLDIR)/save_opts.h
  out_utils.o:	$(INCLDIR)/headers.h
  pattern.o:	$(INCLDIR)/headers.h $(INCLDIR)/s_elm.h
  pmalloc.o:	$(INCLDIR)/defs.h $(INCLDIR)/s_elm.h
  quit.o:		$(INCLDIR)/headers.h $(INCLDIR)/s_elm.h
  read_rc.o:	$(INCLDIR)/headers.h $(INCLDIR)/s_elm.h $(INCLDIR)/save_opts.h
  remail.o:	$(INCLDIR)/headers.h $(INCLDIR)/s_elm.h
  reply.o:	$(INCLDIR)/headers.h $(INCLDIR)/s_elm.h
  returnadd.o:	$(INCLDIR)/headers.h $(INCLDIR)/s_elm.h
  save_opts.o:	$(INCLDIR)/save_opts.h $(INCLDIR)/headers.h $(INCLDIR)/s_elmrc.h
--- 308,333 ----
  in_utils.o:	$(INCLDIR)/headers.h $(INCLDIR)/s_elm.h
  init.o:		$(INCLDIR)/headers.h $(INCLDIR)/patchlevel.h $(INCLDIR)/s_elm.h
  leavembox.o:	$(INCLDIR)/headers.h $(INCLDIR)/s_elm.h
  limit.o:	$(INCLDIR)/headers.h $(INCLDIR)/s_elm.h $(INCLDIR)/s_aliases.h
+ lock.o:		$(INCLDIR)/headers.h $(INCLDIR)/s_elm.h
  mailmsg1.o:	$(INCLDIR)/headers.h $(INCLDIR)/s_elm.h
  mailmsg2.o:	$(INCLDIR)/headers.h $(INCLDIR)/s_elm.h
! metapager.o:	$(INCLDIR)/headers.h $(INCLDIR)/s_elm.h $(INCLDIR)/me.h
  mime.o:		$(INCLDIR)/headers.h $(INCLDIR)/s_elm.h
+ mime_decode.o:   $(INCLDIR)/headers.h $(INCLDIR)/me.h
+ mime_encode.o:   $(INCLDIR)/headers.h $(INCLDIR)/me.h
+ mime_parse.o:   $(INCLDIR)/headers.h $(INCLDIR)/me.h
+ mkhdrs.o:	$(INCLDIR)/headers.h $(INCLDIR)/s_elm.h
  newmbox.o:	$(INCLDIR)/headers.h $(INCLDIR)/s_elm.h
  options.o:	$(INCLDIR)/headers.h $(INCLDIR)/s_elm.h $(INCLDIR)/save_opts.h
  out_utils.o:	$(INCLDIR)/headers.h
  pattern.o:	$(INCLDIR)/headers.h $(INCLDIR)/s_elm.h
+ pgp.o:		$(INCLDIR)/headers.h $(INCLDIR)/me.h
  pmalloc.o:	$(INCLDIR)/defs.h $(INCLDIR)/s_elm.h
  quit.o:		$(INCLDIR)/headers.h $(INCLDIR)/s_elm.h
  read_rc.o:	$(INCLDIR)/headers.h $(INCLDIR)/s_elm.h $(INCLDIR)/save_opts.h
  remail.o:	$(INCLDIR)/headers.h $(INCLDIR)/s_elm.h
+ remailer.o:	$(INCLDIR)/headers.h $(INCLDIR)/me.h
  reply.o:	$(INCLDIR)/headers.h $(INCLDIR)/s_elm.h
  returnadd.o:	$(INCLDIR)/headers.h $(INCLDIR)/s_elm.h
  save_opts.o:	$(INCLDIR)/save_opts.h $(INCLDIR)/headers.h $(INCLDIR)/s_elmrc.h

diff -c elm-2.4pl24/src/a_quit.c elm-2.4pl24me8/src/a_quit.c
*** elm-2.4pl24/src/a_quit.c	Sun Apr 11 19:34:36 1993
--- elm-2.4pl24me8/src/a_quit.c	Wed Sep  6 11:58:42 1995
***************
*** 117,123 ****
  	  }
  
  	  if(answer == *def_ans_yes) {
! 	    list = (char **) malloc(marked_deleted*sizeof(*list));
  	    for (i = 0; i < message_count; i++) {
  	      if (ison(aliases[i]->status, DELETED)) {
  		list[to_delete] = aliases[i]->alias;
--- 117,123 ----
  	  }
  
  	  if(answer == *def_ans_yes) {
! 	    list = (char **) safe_malloc(marked_deleted*sizeof(*list));
  	    for (i = 0; i < message_count; i++) {
  	      if (ison(aliases[i]->status, DELETED)) {
  		list[to_delete] = aliases[i]->alias;

diff -c elm-2.4pl24/src/a_screen.c elm-2.4pl24me8/src/a_screen.c
*** elm-2.4pl24/src/a_screen.c	Thu Apr 15 20:54:15 1993
--- elm-2.4pl24me8/src/a_screen.c	Wed Sep 13 16:19:32 1995
***************
*** 161,167 ****
  
  	sprintf(buffer, "%s%s%c%-3d ",
  		(highlight && arrow_cursor)? "->" : "  ",
! 		show_status(entry->status),
  		(entry->status & TAGGED?  '+' : ' '),
  		message_number);
  
--- 161,167 ----
  
  	sprintf(buffer, "%s%s%c%-3d ",
  		(highlight && arrow_cursor)? "->" : "  ",
! 		show_status(entry->status,NULL),
  		(entry->status & TAGGED?  '+' : ' '),
  		message_number);
  

diff -c elm-2.4pl24/src/args.c elm-2.4pl24me8/src/args.c
*** elm-2.4pl24/src/args.c	Sun Apr 11 20:35:24 1993
--- elm-2.4pl24me8/src/args.c	Mon Sep 11 10:01:01 1995
***************
*** 218,223 ****
--- 218,237 ----
  
  #ifdef MIME
  	printf("\tSupport Multipurpose Internet Mail Extensions: MIME\n");
+ 
+ #ifdef USE_8BITMIME
+       printf("\tUse 8BIT content_transfer_encoding and -B8BITMIME -option: USE_8BITMIME\n");
+ #else /* USE_8BITMIME */
+       printf("\tDon't use 8BIT content_transfer_encoding with -B8BITMIME -option: not USE_8BITMIME\n");
+ #endif /* USE_8BITMIME */
+ 
+ #ifdef USE_BINARYMIME
+       printf("\tUse BINARY content_transfer_encoding and -BBINARYMIME -option: USE_BINARYMIME");
+ #else /* USE_BINARYMIME */
+       printf("\tDon't use BINARY content_transfer_encoding with -BBINARYMIME -option: not USE_BINARYMIME");
+ #endif /* USE_BINARYMIME */
+       printf(" (This option isn't fully implemented yet.)\n");
+ 
  #else /* MIME */
  	printf("\tIgnore Multipurpose Internet Mail Extensions: not MIME\n");
  #endif /* MIME */
***************
*** 266,271 ****
--- 280,295 ----
  	printf("\tCalendar file feature disabled: not ENABLE_CALENDAR\n");
  #endif /* ENABLE_CALENDAR */
  
+ #ifdef USE_PGP
+ 	printf("\tPGP support enabled: USE_PGP\n");
+ #else
+ 	printf("\tPGP support disabled: not USE_PGP\n");
+ #endif
+ #ifdef USE_REMAILER
+ 	printf("\tRemailer support enabled: USE_REMAILER\n");
+ #else
+ 	printf("\tRemailer support disabled: not USE_REMAILER\n");
+ #endif
  	printf("\n\n");
  	exit(1);
  

diff -c /dev/null elm-2.4pl24me8/src/attach_menu.c
*** /dev/null	Thu Sep 21 15:27:01 1995
--- elm-2.4pl24me8/src/attach_menu.c	Thu Sep 21 10:05:47 1995
***************
*** 0 ****
--- 1,1152 ----
+ #include "headers.h"
+ 
+ #ifdef MIME
+ #include <sys/errno.h>
+ #include <sys/stat.h>
+ #include <sys/wait.h>
+ #include <unistd.h>     /* For access */
+ #include "me.h"
+ 
+ extern int errno;
+ extern int COLUMNS;
+ 
+ static int can_save(filename) 
+      char *filename;
+ {
+   if (access(filename,R_OK) < 0) {
+     if (errno == ENOENT)
+       return 1;    /* File not exists -- can save ! */
+     return 0;     /* Other error -- don't save with that name ! */
+   } else
+     return 0;    /* Is readable file -- don't save over ! */
+ }
+ 
+ static FILE * 
+ get_attachment(mail_fd,att)
+      FILE * mail_fd;
+      mime_t *att;
+ {
+   FILE * result = NULL;
+   if (att->pathname) {
+     if (can_open(att->pathname,"r") != 0) {
+       error1 ("%.50s isn't readable by user!", att->pathname);
+       return NULL;
+     }
+ 
+     result = fopen(att->pathname,"r");
+     if (!result) {
+       error1("Can't open attachment: %.50s",att->pathname);
+     }
+   } else if (!mail_fd) {
+       error("Internal error: no parent fd!");
+   } else {
+     result = mail_fd;
+     if (fseek(mail_fd,att->offset,SEEK_SET) != 0) {
+       error("Failed to seek beginning of attachment!");
+       result = NULL;
+     }
+   }
+   return result;
+ }
+ 
+ void close_attachment(mail_fd, tmpfd)
+      FILE * mail_fd, *tmpfd;
+ {
+   if (!tmpfd)
+     return;
+   if (mail_fd != tmpfd)
+     fclose(tmpfd);
+ }
+ 
+ void attachment_copy(att, tmpfd, outfd)
+      FILE *tmpfd, *outfd;
+      mime_t *att;
+ {
+   if (att->pathname) {  /* Already decoded */
+     char buf[VERY_LONG_STRING];
+     int len;
+     while (0 < (len = fread(buf,1,sizeof(buf),tmpfd))) {
+       if (fwrite(buf,1,len,outfd) != len) {
+ 	error("Write error when copying attachment!");
+ 	break;
+       }
+     }
+     if (ferror(tmpfd)) {
+       error("Error reading from %.50s",att->pathname);
+     }
+   } else { /* Needs decode */
+     state_t state;
+     state.fpout      = outfd;
+     state.displaying = FALSE;
+     state.fpin       = tmpfd;
+     mime_decode(att,&state);
+   }
+ }
+ 
+ static void
+ attach_print (att)
+      mime_t *att;
+ {
+   state_t state;
+   char tempfile[STRING];
+   char buf[VERY_LONG_STRING];
+   
+   sprintf(tempfile,"%selm.%d", temp_dir, getpid());
+ 
+   if (att->type == MIME_TYPE_TEXT && istrcmp(att->subtype,"plain") == 0) {
+     int ret;
+ 
+     dprint(3,(debugfile,"attach_print: printing directly\n"));
+     state.fpout = fopen(tempfile,"w");
+     if (!state.fpout) {
+       error("Error creating tempfile!");
+       return;
+     }
+     state.displaying = FALSE;
+     state.fpin = get_attachment(mailfile,att);
+     if (!state.fpin) {
+       fclose(state.fpout);
+       return;
+     }
+     attachment_copy(att,state.fpin,state.fpout);
+       
+     fclose(state.fpout);
+     sprintf(buf, printout, tempfile);
+     ret = system_call(buf,0);
+     if (ret == 0)
+       error("Print job spooled.");
+     else
+       error("Error while printing!");
+     unlink(tempfile);
+     close_attachment(mailfile,state.fpin);
+   }
+   else if (!getenv("NOMETAMAIL")) {
+     dprint(3,(debugfile,"attach_print: printing via metamail\n"));
+     if (att->pathname)
+       sprintf(buf,"metamail -m Elm -h -b -c %s/%s %s",
+ 	      TYPE(att->type), att->subtype, att->pathname);
+     else {
+       FILE *fpout;
+ 
+       fpout = fopen(tempfile,"w");
+       fseek(mailfile,att->begin_offset,0);
+       while (ftell(mailfile) < att->offset + att->length) {
+ 	int len = mail_gets(buf,VERY_LONG_STRING,mailfile);
+ 	if (len <= 0) 
+ 	  break; /* Error ? */
+ 	fwrite(buf,1,len,fpout);
+       }
+       fclose(fpout);
+       sprintf(buf,"metamail -m Elm -h -z %s", tempfile);
+     }
+     Raw(OFF);
+     system_call(buf,0);
+     PressAnyKeyToContinue();
+     Raw(ON);
+   }
+   else
+     error("Don't know how to print this type of data!");
+ }
+ 
+ static void
+ attach_save (a)
+      mime_t *a;
+ {
+   char savefile[STRING] = {0}, buf[VERY_LONG_STRING], tmp[STRING];
+   int bytes=0, err, is_text;
+   state_t state;
+   
+   if (a->type == MIME_TYPE_APPLICATION &&
+       istrcmp (a->subtype, "octet-stream") == 0) {
+ 
+     /* See if there is a name=<...> field for the default filename */
+     tmp[0] = '\0';
+     if (a->type_opts &&
+ 	mime_get_param ("name", tmp, a->type_opts, sizeof(tmp))) {
+       char *p = strrchr (tmp, '/');
+       if (p)
+ 	p++;
+       else
+ 	p = tmp;
+       if (can_save(p))
+ 	strfcpy (savefile, p, sizeof (savefile));
+     }
+   }
+ 
+    /* See if there is a filename=<...> field for the default filename */
+   tmp[0] = '\0';
+   if (a->disposition_opts &&
+       mime_get_param ("filename", tmp, a->disposition_opts, sizeof(tmp))) {
+     char *p = strrchr (tmp, '/');
+     if (p)
+       p++;
+     else
+       p = tmp;
+     if (can_save(p))
+       strfcpy (savefile, p, sizeof (savefile));
+   }
+ 
+   ClearLine (LINES-2);
+   PutLine0 (LINES-2, 0, "To file: ");
+   
+   if (optionally_enter(savefile, LINES-2, 9, TRUE, 0) < 0 || savefile[0]=='\0'){
+     ClearLine(LINES-2);
+     error("Mail not saved.");
+     return;
+   }
+ 
+   ClearLine(LINES-2);
+ 
+   state.fpin = get_attachment(mailfile,a);
+   if (!state.fpin) 
+     return;
+ 
+   if (can_open (savefile,"w") != 0) {
+     error ("You do not have permission to write that file!");
+ 	
+     if (sleepmsg > 0)
+       sleep(sleepmsg);
+ 
+     return;
+   }
+ 
+   state.fpout = fopen(savefile, "w");
+   if (! state.fpout) {
+     error ("Error opening file!");
+ 	
+     if (sleepmsg > 0)
+       sleep(sleepmsg);
+ 
+     return;
+   }
+ 
+   is_text = is_text_type (TYPE(a->type), a->subtype, a->encoding);
+ 
+   state.prefix = NULL;
+   state.displaying = 0;
+ 
+   if (a->encoding == ENCODING_BASE64 && !a->pathname)
+      base64_decode (&state, a->length, is_text);
+   else if (a->encoding == ENCODING_QUOTED && !a->pathname)
+      quoted_printable_decode (&state, a->length, is_text);
+   else {
+     if (a->encoding != ENCODING_NONE && a->encoding != ENCODING_7BIT &&
+ 	a->encoding != ENCODING_8BIT && a->encoding != ENCODING_BINARY
+ 	&& !a->pathname) {
+       error("Unsupported encoding! Decode manually!");
+       
+       if (sleepmsg > 0)
+ 	sleep(sleepmsg);
+       /* save without decoding ! */
+     }
+     while (bytes < a->length) {
+       int chunk = VERY_LONG_STRING;
+       int len;
+ 
+       if (chunk > a->length - bytes)
+ 	chunk = a->length - bytes;
+       if ((len = mail_gets (buf, chunk, state.fpin)) <= 0)
+ 	break;
+       bytes += len;
+       if (is_text > 0) { /* replace CRLF with LF */
+ 	if (len >= 2 && buf[len-2] == '\r' && buf[len-1] == '\n') {
+ 	  buf[len-2] = '\n';
+ 	  buf[len-1] = '\0';
+ 	  len--;
+ 	}
+       }
+       fwrite (buf, 1, len, state.fpout);
+     }
+   }
+ 
+   err = ferror (state.fpout);
+   err = err || fclose (state.fpout) != 0;
+   elm_chown (savefile, userid, groupid);
+ 
+   close_attachment(mailfile,state.fpin);
+ 
+   if (err)
+     error ("Error saving file!");
+   else
+     error ("Mail saved.");
+   return;
+ }
+ 
+ static int attach_info ();
+ 
+ static void
+ attach_edit (ptr)
+      mime_t *ptr;
+ {
+   int savetime;
+   struct stat sb;
+   char buf[STRING];
+ 
+   if (!ptr->pathname)
+     return;
+ 
+   if (-1 == stat (ptr->pathname, &sb)) {
+     error("Can't stat file!");
+     return;
+   }
+   if (strlen(ptr->pathname) + strlen(editor) > STRING-5)
+     return;
+   savetime = sb.st_mtime;
+   Raw(OFF);
+   sprintf (buf, "%s %s", editor, ptr->pathname);
+   system_call (buf, 0);
+   Raw(ON);
+   if (stat (ptr->pathname, &sb) == -1 || sb.st_mtime != savetime)
+     (void) attach_info (ptr);  /* update the information on this attachment */
+   return;
+ }
+ 
+ static void
+ attach_viewer (a)
+      mime_t *a;
+ {
+   char buf[LONG_STRING];
+ 
+   /* there is nothing to display! */
+   if (a->length <= 0)
+     return;
+ 
+   if (!mime_notplain(a) || getenv("NOMETAMAIL")) {
+     struct header_rec tmp;
+     FILE *tmpfp = NULL;
+     struct stat sb;
+ 
+     /* The next line is required so that mime_t_clear() doesn't call
+      * mime_destroy() or free() on bad pointers
+      */
+     mime_t_zero (&tmp.mime_rec);
+     mime_t_clear (&tmp.mime_rec);
+ 
+     
+     /* So that metapager() doesn't try to do special handling */
+     tmp.status = MIME_MESSAGE;  /* Now I test again MIME_MESSAGE
+ 				 * - K E H   <hurtta@dionysos.FMI.FI>
+ 				 */
+     tmp.mime_rec.flags = a->flags;
+     tmp.mime_rec.parts = a->parts;
+     tmp.mime_rec.type = a->type;
+     strcpy (tmp.mime_rec.subtype,a->subtype);
+     tmp.mime_rec.type_opts = a->type_opts;
+     tmp.mime_rec.disposition = DISP_INLINE;  /* Show it ! */
+ #ifdef USE_PGP
+     tmp.pgp = headers[current-1]->pgp;
+ #endif
+ 
+     if (a->pathname) {
+       if (can_open(a->pathname,"r") != 0) {
+ 	error1 ("%.50s isn't readable by user!", a->pathname);
+ 	return;
+       }
+ 
+       tmpfp = fopen (a->pathname, "r");
+       if (! tmpfp) {
+         error ("Could not open file for reading!");
+         if (sleepmsg > 0)
+           sleep (sleepmsg);
+         return;
+       }
+       tmp.offset = tmp.mime_rec.offset = 0;
+       tmp.mime_rec.encoding = ENCODING_7BIT;
+       stat(a->pathname, &sb);
+       tmp.content_length = tmp.mime_rec.length = sb.st_size;
+       attach_parse(&tmp, tmpfp);
+     }
+     else {
+       tmp.mime_rec.offset = tmp.offset = a->offset;
+       tmp.mime_rec.encoding = a->encoding;
+       tmp.content_length = tmp.mime_rec.length = a->length;
+     }
+ 
+     metapager (tmpfp == NULL ? mailfile : tmpfp, &tmp, FALSE);
+ 
+     if (tmpfp) {
+       mime_destroy(tmp.mime_rec.parts);
+       fclose (tmpfp);
+     }
+     return;
+   }
+ 
+   /* otherwise call metamail */
+ 
+   if (!a->pathname) {
+     char tmpfile[STRING], c;
+     FILE *out;
+     int bytes;
+ 
+     sprintf (tmpfile, "%s/elm.%d", temp_dir, getpid());
+     out = fopen (tmpfile, "w");
+     if (out == NULL) {
+       error ("Could not open temp file!");
+       return;
+     }
+     /* copy the headers plus the message to a temp file */
+     fseek (mailfile, a->begin_offset, 0);
+     bytes = a->begin_offset - a->offset;
+     while (bytes < a->length) {
+       c = fgetc (mailfile);
+       fputc (c, out);
+       bytes++;
+     }
+     fclose (out);
+     sprintf (buf, "metamail -m Elm -p -z %s", tmpfile);
+   }
+   else
+     /* This is the case when we are viewing attachments for an outgoing
+      * message.
+      */
+     sprintf(buf,"metamail -m Elm -p -b -c %s/%s %s", TYPE(a->type), a->subtype,
+             a->pathname);
+ 
+   Raw (OFF);
+   ClearScreen();
+   printf ("executing: %s\n", buf);
+   system_call (buf, 0);
+   PressAnyKeyToContinue();
+   Raw (ON);
+   return;
+ }
+ 
+ static int
+ attach_modify (att, new)
+      mime_t *att;
+      int new;
+ {
+   char buf[STRING]={0}, ch;
+   int update = TRUE, prompt = TRUE, need_enc = 0;
+   int is_text = -1;
+ 
+   if (new) {
+     /* set the default charset */
+     buf[0] = '\0';
+     add_parameter (buf, "charset", charset, sizeof (buf), 0);
+     att->type_opts = strmcpy (att->type_opts, buf);
+ 
+     /* force a prompt for a filename */
+     prompt = FALSE;
+     ch = 'f';
+   }
+   
+   /* 1 if is text type (true)
+    * 0 if not text type
+    * -1 if can't be encoded (ie structured) Message/ or Multpart/
+    */
+   is_text = is_text_type (TYPE(att->type), att->subtype, att->encoding);
+ 
+   for (;;) {
+     if (update) {
+       int add = 0;
+       ClearScreen ();
+       
+       Centerline (1, "Attachment Configuration");
+       
+       sprintf (buf, "%-26.26s: %.*s", "F)ilename", 
+ 	       sizeof(buf)-30, NONULL(att->pathname));
+       PutLine0 (3, 0, buf);
+       sprintf (buf, "%-26.26s: %.*s", "D)escription", 
+ 	       sizeof(buf)-30, NONULL(att->description));
+       PutLine0 (4, 0, buf);
+ 
+       sprintf (buf, "%-26.26s: %.15s/%.30s", "content-T)ype",
+                TYPE(att->type), att->subtype);
+       if (att->type_opts) strcat(buf,";");
+       PutLine0 (5, 0, buf);
+       if (att->type_opts) {
+ 	PutLine0 (6+add, 28, att->type_opts);
+ 	add++;
+       }
+       sprintf (buf, "%-26.26s: %s", "content-transfer-E)ncoding",
+ 	       ENCODING(att->encoding));
+       PutLine0 (6+add, 0, buf);
+       
+ 
+       sprintf (buf, "%-26.26s: %.15s", "content-disP)osition", 
+ 	       DISPOSITION(att->disposition));
+       if (att->disposition_opts)
+         strcat(buf,";");
+       PutLine0 (7+add, 0, buf);
+       if (att->disposition_opts) {
+ 	PutLine0 (8+add, 28, att->disposition_opts);
+ 	add++;
+       }
+ 
+       if (is_text < 0)
+ 	sprintf (buf, "%-26.26s: %s", "CRLF-conversions",
+ 		 "structured (direct content-encoding not allowed)");
+       else if (is_text)
+ 	sprintf (buf, "%-26.26s: %s", "CRLF-conversions",
+ 		 "Text (line orienteed, convert LF <-> CRLF)");
+       else 
+ 	sprintf (buf, "%-26.26s: %s", "CRLF-conversions",
+ 		 "Binary (no conversions)");
+       PutLine0 (9+add, 0, buf);
+ 
+       update = FALSE;
+       show_last_error();
+     }
+     
+     if (prompt) {
+       PutLine0 (LINES-2, 0, "Enter letter or RETURN to quit: ");
+       ch = ReadCh();
+       clear_error();
+     }
+     
+     if (ch == '\n' || ch == 'q' || ch == 'Q' || ch == 'x' || ch == 'X')
+       return (TRUE);
+     else if (ch == ctrl('L'))
+       update = TRUE;
+     else if (ch == 'f' || ch == 'F') {
+       if (att->pathname)
+ 	strfcpy(buf, att->pathname, sizeof(buf));
+       else
+ 	buf[0] = '\0';
+       PutLine0 (LINES-2, 0, "Filename: ");
+       optionally_enter (buf, LINES-2, 10, TRUE, FALSE);
+       if (buf[0] != '\0')
+         att->pathname = strmcpy (att->pathname, buf);
+       else {
+         if (att->pathname) {
+           free (att->pathname);
+           att->pathname = NULL;
+         }
+         if (new)
+           return FALSE;
+         else
+           continue;
+       }
+ 
+       /* Set some information about this attachment */
+       need_enc = attach_info (att);
+       if (need_enc < 0)
+ 	continue;
+ 
+       /* 1 if is text type (true)
+        * 0 if not text type
+        * -1 if can't be encoded (ie structured) Message/ or Multpart/
+        */
+       is_text = is_text_type (TYPE(att->type), att->subtype, att->encoding);
+       if (is_text < 0 && (att->encoding == ENCODING_QUOTED || 
+ 			  att->encoding == ENCODING_BASE64)) {
+ 	/* Reconsider encoding ... */
+ 	ch = 'e';
+ 	prompt = FALSE;
+ 	update = TRUE;
+ 	error ("Structured types don't allow encoding of data.");
+ 	
+         if (sleepmsg > 0)
+ 	  sleep (sleepmsg);
+ 
+ 	break;
+       } 
+ 
+       /* now let the user do what they want */
+       if (new)
+ 	prompt = TRUE;
+       
+       /* need to update since encoding could have changed */
+       update = TRUE;
+     }
+     else if (ch == 'd' || ch == 'D') {
+       PutLine0 (LINES-2, 0, "Description: ");
+       buf[0] = '\0';
+       optionally_enter (buf, LINES-2, 13, TRUE, FALSE);
+       if (buf[0])
+         att->description = strmcpy (att->description, buf);
+       else if (att->description) {
+         free (att->description);
+ 	att->description = NULL;
+       }
+       update = TRUE;
+     }
+     else if (ch == 't' || ch == 'T') {
+       prompt = TRUE;
+       PutLine0 (LINES-2, 0, "Content-Type: ");
+       att -> flags &= ~(MIME_RFC822);
+       sprintf (buf, "%.15s/%.30s", TYPE(att->type), att->subtype);
+       if (att->type_opts) {
+ 	int l;
+ 
+ 	strcat (buf, "; ");
+         l = strlen (buf);
+ 	strfcpy (buf + l, att->type_opts, sizeof (buf) - l);
+       }
+       
+       optionally_enter (buf, LINES-2, 14, TRUE, FALSE);
+       mime_get_content (buf, att);
+       if (att->type == MIME_TYPE_TEXT && (need_enc & HAVE_8BIT) &&
+ 	  !mime_get_param("charset",buf,att->type_opts,sizeof (buf)))
+ 	add_parameter(att->type_opts, "charset", charset,
+ 		      sizeof (att->type_opts),0);
+       
+       /* 1 if is text type (true)
+        * 0 if not text type
+        * -1 if can't be encoded (ie structured) Message/ or Multpart/
+        */
+       is_text = is_text_type (mime_types[att->type], att->subtype, att->encoding);
+       update = TRUE;
+       if (is_text < 0 && (att->encoding == ENCODING_QUOTED || 
+ 			  att->encoding == ENCODING_BASE64)) {
+ 	/* Reconsider encoding ... */
+ 	ch = 'e';
+ 	prompt = FALSE;
+ 	error ("Structured types don't allow encoding of data.");
+ 	
+ 	if (sleepmsg > 0)
+ 	  sleep(sleepmsg);
+ 	
+       } 
+     }
+     else if (ch == 'p' || ch == 'P') {
+       prompt = TRUE;
+       PutLine0 (LINES-2, 0, "Content-Disposition: ");
+       strcpy (buf, DISPOSITION(att->disposition));
+       if (att->disposition_opts) {
+ 	int l;
+ 
+ 	strcat (buf,"; ");
+         l = strlen (buf);
+ 	strfcpy (buf + l, att->disposition_opts, sizeof (buf) - l);
+       }
+       
+       optionally_enter (buf, LINES-2, 21, TRUE, FALSE);
+       mime_get_disposition (buf, att);
+       update = TRUE;
+     }
+     else if (ch == 'e' || ch == 'E') {
+       prompt = TRUE;
+       PutLine0 (LINES-2, 0, "Content-Transfer-Encoding: ");
+       Centerline (LINES-1, "<SPACE> for next value, <RETURN> to accept.");
+       for (;;) {
+ 	MoveCursor (LINES-2, 27);
+ 	CleartoEOLN ();
+ 
+ #define NEXT_ENCODING  { \
+ 			   att->encoding++; \
+ 			   if (att->encoding > 5) att->encoding = 1; \
+ 			   continue; \
+ 		       }
+ 
+ #ifndef USE_8BITMIME
+ 	if (allow_no_encoding < 1) {
+ 	  if (att->encoding == ENCODING_8BIT) {  /* Mailer won't support ! */
+ 	    /* TRY next encosing instead */
+ 	    NEXT_ENCODING;
+ 	  }
+ 	}
+ #endif
+ 	
+ #ifndef USE_BINARYMIME
+ 	if (allow_no_encoding < 2) {
+ 	  if (att->encoding == ENCODING_BINARY) {  /* Mailer won't support ! */
+ 	    /* TRY next encoding instead */
+ 	    NEXT_ENCODING;
+ 	  }
+ 	}
+ #endif
+ 
+ 	/* Don't allow 7bit if the file contains 8bit chars... 
+ 	 * 7bit encoding is allowed if file includes control characters 
+ 	 */
+ 	if (att->encoding == ENCODING_7BIT && (need_enc & HAVE_8BIT)) {
+ 	  NEXT_ENCODING;
+ 	}
+ 	/* Don't allow 7bit or 8bit if the file required binary
+ 	 * encoding according of Mime Draft Standard.
+ 	 */
+ 	if ((att->encoding == ENCODING_7BIT || att->encoding == ENCODING_8BIT)
+ 	    && (need_enc & HAVE_BINARY)) {
+ 	  NEXT_ENCODING;
+ 	}
+ 
+ 	/* Don't allow encoding for Multipart/ and Message/ 
+ 	 * See mime Draft Standard. Be carefull that don't create
+ 	 * infinitive loop! */
+ 
+ 	if (is_text < 0) {
+ 	  static int again = 0;    /* Prevent looping */
+ 	  if (att->encoding == ENCODING_QUOTED || 
+ 	      att->encoding == ENCODING_BASE64) {
+ 	    if (again == att->encoding) {
+ 	      error("Structured types must be encoded in leaf type!");
+ 	
+ 	      if (sleepmsg > 0)
+ 		sleep(sleepmsg);
+ 
+ 	      /* prompt for new content-type */
+ 	      prompt = FALSE;
+ 	      ch = 't';
+ 	      break;
+ 	    } else {
+ 	      if (!again)
+ 		again = att->encoding;
+ 	      NEXT_ENCODING;
+ 	    }
+ 	  } else
+ 	    again = 0;
+ 	}
+ 
+ 	Write_to_screen (ENCODING(att->encoding), 0);
+ 	ch = ReadCh();
+ 	if (ch == '\n')
+ 	  break;
+ 	else if (ch == ' ') {
+ 	  NEXT_ENCODING;
+ 	}
+       }
+ 
+ #undef NEXT_ENCODING
+ 
+       ClearLine (LINES-1);
+       /* 1 if is text type (true)
+        * 0 if not text type
+        * -1 if can't be encoded (ie structured) Message/ or Multpart/
+        */
+       is_text = is_text_type (mime_types[att->type], att->subtype, att->encoding);
+       update = TRUE;
+     }
+     else
+       error ("Unknown command.");
+   }
+   /* Not reached. */
+ }
+ 
+ static void
+ mime_guess_content_type (ptr)
+      mime_t *ptr;
+ {
+   /* This routine tries to guess the content-type of an attachment by looking
+    * at the suffix of ptr->pathname.  It first looks to see if it can find
+    * an entry in ~/.elm/mime.types, then in "system_mime_types", and failing
+    * that, to a small list of builtin definitions.
+    */
+   int i, found = FALSE;
+   char *p, *c, buf[LONG_STRING];
+   FILE *fp;
+ 
+   dprint (3, (debugfile, "mime_guess_content_type: pathname=%s\n",
+ 	      ptr->pathname));
+ 
+   p = (char *) strrchr (ptr->pathname, '.');
+   if (! p)
+     return;
+ 
+   p++;
+ 
+   for (i = 0; i < 3; i++) {
+   dprint (3, (debugfile, 
+ 	      "mime_guess_content_type: searching \"%s\", i=%d\n",
+ 	      p,i));
+     if (i == 0) {
+       
+       /* First try the user's mime.types file */
+       
+       sprintf (buf, "%s/.elm/mime.types", home);
+       fp = fopen (buf, "r");
+       if (!fp)
+ 	continue;
+     }
+     else if (i == 1) {
+       
+       /* If it wasn't there, try the system file... */
+       
+       fp = fopen (system_mime_types, "r");
+       if (! fp)
+ 	continue;
+     }
+     else {
+       /* Couldn't find user or system mime.types file,
+        * use these defaults...
+        */
+       if (istrcmp (p, "ps") == 0) {
+ 	ptr->type = MIME_TYPE_APPLICATION;
+ 	strcpy (ptr->subtype, "postscript");
+         if (ptr->type_opts)
+           free (ptr->type_opts);
+       }
+       else if (istrcmp (p, "gif") == 0 || istrcmp (p, "jpeg") == 0 ||
+ 	       istrcmp (p, "tiff") == 0) {
+ 	ptr->type = MIME_TYPE_IMAGE;
+ 	strcpy (ptr->subtype, p);
+         if (ptr->type_opts)
+           free (ptr->type_opts);
+       }
+       dprint (3, (debugfile, 
+ 		  "mime_guess_content_type: built-in default \"%s\" as \"%s/%s\"\n", 
+ 		  p, TYPE(ptr->type), ptr->subtype));
+     }
+     
+     if (i < 2) {
+       while (fgets (buf, LONG_STRING, fp) != NULL) {
+ 	if (buf[0] == '#') /* Skip comments */
+ 	  continue;
+ 	c = buf;
+ 	while (*c && isspace ((unsigned char) *c)) /* skip leading whitespace */
+ 	  c++;
+ 	if (! *c)
+ 	  continue;
+ 	if (strincmp (c, p, strlen (p)) == 0) {
+ 	  buf[strlen (buf) - 1] = '\0';
+ 	  mime_get_content (c + strlen (p), ptr);
+ 	  dprint (3, (debugfile, "mime_guess_content_type: user defined \"%s\" as \"%s/%s\"\n", p, TYPE(ptr->type), ptr->subtype));
+ 	  found = TRUE;
+ 	  break;
+ 	}
+       }
+       fclose (fp);
+       if (found)
+ 	break;
+     }
+   }
+ 
+   p = strrchr (ptr->pathname, '/');
+   if (p)
+     p++;
+   else
+     p = ptr->pathname;
+   
+   /* Set the "filename" field for content-disposition */
+   buf[0] = '\0';
+   add_parameter(buf,"filename",p,
+ 		sizeof(buf),0);
+   ptr->disposition_opts = strmcpy (ptr->disposition_opts, buf);
+ 
+   return;
+ }
+ 
+ static int
+ attach_info (ptr)
+      mime_t *ptr;
+ {
+   struct stat sb;
+   FILE *fp;
+   int need_enc;
+ 
+   if (stat (ptr->pathname, &sb) == -1) {
+     if (errno == ENOENT)
+       error ("That file does not exist!");
+     else
+       error ("Could not stat file!");
+     return (-1);
+   }
+ 
+   ptr->length = sb.st_size;
+ 
+   if (can_open(ptr->pathname,"r") != 0) {
+     error1 ("%.50s isn't readable by user!", ptr->pathname);
+     ptr->pathname[0] = '\0';
+     return (-1);
+   }
+ 
+   mime_guess_content_type (ptr);
+ 
+   /* Figure out what the default encoding is... */
+ 
+   error1 ("Reading %s...", ptr->pathname);
+   fp = fopen (ptr->pathname, "r");
+   if (!fp) {
+     error1 ("Can't open %s!", ptr->pathname);
+     return -1;
+   }
+ 
+   need_enc = needs_encoding (fp);
+   
+   if (need_enc & HAVE_CTRL)
+     ptr->encoding = (need_enc & HAVE_BINARY) 
+       ? ENCODING_BASE64 : ENCODING_QUOTED;
+   else if (need_enc & HAVE_BINARY) { 
+     /* HAVE_BINARY, but not HAVE_CTRL so that have long lines! */
+ #ifdef USE_BINARYMIME
+     ptr->encoding = ENCODING_BINARY;
+ #else
+     ptr->encoding = ENCODING_QUOTED;
+ #endif
+   }
+   else if (need_enc & HAVE_8BIT) {
+ #ifdef USE_8BITMIME
+     ptr->encoding = ENCODING_8BIT;
+ #else
+     ptr->encoding = ENCODING_QUOTED;
+ #endif
+   }
+   fclose (fp);
+   clear_error();  /* Remove reading ... -message */
+ 
+   dprint(3,(debugfile,"attach_info: need_enc=%d, encoding=%d, pathname=%s\n",
+ 	    need_enc,ptr->encoding,ptr->pathname));
+   return (need_enc);
+ }
+ 
+ static void
+ attach_header (mt, num, is_cur, use_desc, offset)
+      mime_t *mt;
+      int num, is_cur, offset, use_desc;
+ {
+   /* Displays a header for a menu for the specified attachment. */
+   char *Encoding = "???";
+  
+   char buf[LONG_STRING], buf2[LONG_STRING];
+   int len, len2;
+   int Width = COLUMNS;     /* Protect arbitary big values of COLUMNS */
+   if (Width > sizeof (buf)-1)
+     Width = sizeof (buf)-1;
+ 
+   Encoding = ENCODING(mt->encoding);
+ 
+   sprintf (buf,
+ 	   "%4d %-30.30s (%d) ",
+ 	   num,
+ 	   use_desc ? NONULL(mt->description) : NONULL(mt->pathname),
+ 	   mt->length);
+   if (mt->length < 10)
+     strcat (buf, "   ");
+   else if (mt->length < 100)
+     strcat (buf, "  ");
+   else if (mt->length < 1000)
+     strcat (buf, " ");
+   sprintf (buf2, "%.15s/%.30s", TYPE(mt->type), mt->subtype);
+   strcat (buf, buf2);
+   len = Width - strlen (buf);
+   len2 = strlen (Encoding) + 3;
+   if (len2 > len) {
+     buf[Width-len2] = '\0';
+     len = len2 = 0;
+   }
+   sprintf (buf2, "%s %*.*s[%s]", buf, len-len2, len-len2, "", Encoding);
+   
+   if (is_cur)
+     StartBold();
+   PutLine0 (offset, 0, buf2);
+   if (is_cur)
+     EndBold();
+ }
+ 
+ mime_t *
+ attach_menu (mt, rdonly)
+      mime_t *mt;
+      int rdonly;
+ {
+   /* A generic attachment menu.  "rdonly" controls whether or not the list
+    * of attachments "mt" may be edited.
+    */
+ 
+   mime_t **ptrs = NULL, *tmp, *ret = NULL;
+   int ptr_len = 0, ptr_max = 0, i, cur = 0, offset = 3, key_offset, ch;
+   int update = TRUE;
+   char buf[STRING];
+   int top = 0;
+ 
+   /* Generate an array of pointers so it is easier to work with. */
+   while (mt) {
+     if (ptr_len == ptr_max)
+       ptrs = (mime_t **) DynamicArray (ptrs, sizeof (mime_t *), &ptr_len, 5);
+     ptrs[ptr_max++] = mt;
+     mt = mt->next;
+   }
+ 
+   for (;;) {
+     if (cur < top || cur >= top + LINES-3-offset) {
+       if (cur < top) 
+ 	top -= LINES-3-offset;
+       if (cur >= top + LINES-3-offset) 
+ 	top += LINES-3-offset;
+       if (top >= ptr_max)
+ 	top = ptr_max - LINES +3 +offset;
+       if (top < 0)
+ 	top = 0;
+       update = TRUE;
+     }
+     if (update) {
+       ClearScreen ();
+       sprintf (buf, "Attachment Menu (%d attachments)", ptr_max);
+       Centerline (1, buf);
+       if (! rdonly)
+ 	strcpy (buf, "a)dd, e)dit, d)elete, m)odify, ");
+       else
+ 	buf[0] = '\0';
+       strcat (buf, "p)rint, s)ave, v)iew subparts, q)uit");
+       Centerline (LINES-1, buf);
+       for (i = top; i < ptr_max && i < top + LINES -3 - offset; i++)
+ 	attach_header (ptrs[i], i + 1, i == cur, rdonly, offset + i - top);
+       update = FALSE;
+       show_last_error(); 
+     }
+     ClearLine (LINES-2);
+     PutLine0 (LINES-2, 0, "Attachments: ");
+     ch = ReadCh ();
+     clear_error(); /* Clear the error message (from buffer also) */
+     switch (ch) {
+     case 's':
+       if (ptr_max > 0)
+         attach_save (ptrs[cur]);
+       else
+         error("There are no attachments!");
+       break;
+     case ' ':
+     case '\n':
+       if (ptr_max > 0) {
+         attach_viewer (ptrs[cur]);
+         update = TRUE;
+       }
+       else
+         error("There are no attachments!");
+       break;
+     case 'p':
+       if (ptr_max > 0)
+         attach_print(ptrs[cur]);
+       else
+         error("There are no attachments!");
+       break;
+     case 'v': /* Perhaps it is better that attachment meny shows whole
+ 	       * structure -- but this is temporary hack.... */
+       if (ptr_max == 0) {
+         error("There are no attachments!");
+         break;
+       }
+       if (ptrs[cur]->parts) {
+ 	attach_menu(ptrs[cur]->parts,TRUE);
+ 	update = TRUE;
+       }
+       break;
+     case 'e':
+       if (! rdonly) {
+         if (ptr_max == 0) {
+           error("There are no attachments!");
+           break;
+         }
+ 	attach_edit (ptrs[cur]);
+ 	update = TRUE;
+       }
+       break;
+     case 'd':
+       if (! rdonly) {
+         if (ptr_max == 0) {
+           error("There are no attachments!");
+           break;
+         }
+ 	if (question_me) {
+ 	  for(;;) {
+ 	    PutLine0(LINES-2, 0, "Are you sure? (y/n): y");
+ 	    MoveCursor(LINES-2, 21);
+ 	    ch = ReadCh();
+ 	    if (ch == 'y' || ch == '\n' || ch == 'n')
+ 	      break;
+ 	  }
+ 	  ClearLine(LINES-2);
+ 	  if (ch == 'n')
+ 	    break;
+ 	}
+       delete_it:
+   	free (ptrs[cur]);
+ 	ptrs[cur] = NULL;
+ 	/* Shift the rest of the pointers down by one. */
+ 	for (i = cur + 1; i < ptr_max; i++)
+ 	  ptrs[i-1] = ptrs[i];
+ 	ptrs[ptr_max-1] = NULL;
+         ptr_max--;
+ 	update = TRUE;
+       }
+       break;
+     case 'a':
+       if (! rdonly) {
+ 	tmp = (mime_t *) mime_t_alloc ();
+ 	if (attach_modify (tmp, TRUE)) {
+ 	  if (ptr_len == ptr_max)
+ 	    ptrs = (mime_t **) DynamicArray (ptrs, sizeof (mime_t *), &ptr_len, 5);
+ 	  ptrs[ptr_max++] = tmp;
+ 	}
+ 	else
+ 	  free (tmp);
+         update = TRUE;
+       }
+       break;
+     case 'm':
+       if (! rdonly) {
+         if (ptr_max == 0) {
+           error("There are no attachments!");
+           break;
+         }
+ 	attach_modify (ptrs[cur], FALSE);
+ 	/* If there is not pathname it is otherwise assumed to be 
+ 	 * part from mailfile...!
+ 	 */
+ 	if (ptrs[cur]->pathname == NULL)
+ 	  goto delete_it;
+         update = TRUE;
+       }
+       break;
+     case 'j':
+     case 'J':
+     case 'n':
+     case ctrl('N'):
+     NEXT_ATTACH:
+       if (cur >= ptr_max - 1) {
+ 	error ("You are on the last attachment!");
+ 	break;
+       }
+       attach_header (ptrs[cur], cur+1, FALSE, rdonly, offset + cur - top);
+       cur++;
+       if (cur < top + LINES -3 - offset)
+ 	attach_header (ptrs[cur], cur+1, TRUE, rdonly, offset + cur - top);
+       break;
+     case 'k':
+     case 'K':
+     case ctrl('K'):
+     PREV_ATTACH:
+       if (cur == 0) {
+ 	error ("You are on the first attachment!");
+ 	break;
+       }
+       attach_header (ptrs[cur], cur+1, FALSE, rdonly, offset + cur - top);
+       cur--;
+       if (cur >= top)
+ 	attach_header (ptrs[cur], cur+1, TRUE, rdonly, offset + cur - top);
+       break;
+     case ESCAPE:
+       key_offset = 1;
+       ch = ReadCh ();
+       if (ch == '[' || ch == 'O') {
+ 	key_offset++;
+ 	ch = ReadCh ();
+       }
+       if (ch == up[key_offset])
+ 	goto PREV_ATTACH;
+       else if (ch == down[key_offset])
+ 	goto NEXT_ATTACH;
+       break;
+     case 'i':
+       if (! rdonly)
+         break;
+       /* else fall through to next statement! */
+     case 'q':
+     case 'x':
+       if (ptrs == NULL)
+         return NULL;
+       if (! rdonly) {
+ 	/* The attachments might have been edited, so rebuild the list */
+ 	ret = tmp = ptrs[0];
+ 	for (i = 1; i < ptr_max; i++) {
+ 	  tmp->next = ptrs[i];
+ 	  tmp = tmp->next;
+ 	}
+ 	if (tmp)
+ 	  tmp->next = NULL;
+       }
+       else
+ 	ret = mt;
+       free (ptrs);
+       return ret;
+     case ctrl('L'):
+       update = TRUE;
+       break;
+     default:
+       error1 ("Unknown command: %c", ch);
+     }
+   }
+ 
+   return;
+ }
+ #endif /* MIME */

diff -c /dev/null elm-2.4pl24me8/src/builtin++.c
*** /dev/null	Thu Sep 21 15:27:01 1995
--- elm-2.4pl24me8/src/builtin++.c	Thu Sep 21 13:12:07 1995
***************
*** 0 ****
--- 1,295 ----
+ #include "headers.h"
+ #include "me.h"
+ 
+ extern int errno;
+ extern int tabspacing;
+ 
+ static void
+ builtin_help () {
+   /* A help screen for the pager below. */
+ 
+   ClearScreen ();
+   Write_to_screen ("Help for builtin++", 0);
+   NewLine ();
+   NewLine ();
+   Write_to_screen ("Key\t\tAction", 0);
+   NewLine ();
+   Write_to_screen ("---\t\t------", 0);
+   NewLine ();
+   Write_to_screen ("<SPACE>, +\tNext page.", 0);
+   NewLine ();
+   Write_to_screen ("-\t\tPrevious page.", 0);
+   NewLine ();
+   Write_to_screen ("<RETURN>\tNext line.", 0);
+   NewLine ();
+   Write_to_screen ("q, x, i\t\tReturn to the index menu.", 0);
+   NewLine ();
+   Write_to_screen ("/\t\tSearch for pattern in message.", 0);
+   NewLine ();
+   Write_to_screen ("^\t\tFirst page.", 0);
+   NewLine ();
+   Write_to_screen ("G\t\tLast page", 0);
+   NewLine ();
+   Write_to_screen ("^L\t\tRefresh display.", 0);
+   NewLine ();
+   Write_to_screen ("^P\t\tUp one line.", 0);
+   NewLine ();
+   Write_to_screen ("^D\t\tDown one-half page.", 0);
+   NewLine ();
+   Write_to_screen ("^U\t\tUp one-half page.", 0);
+   NewLine ();
+   Write_to_screen ("?\t\tThis help screen.", 0);
+   NewLine ();
+   PutLine0 (LINES, 0, "Press any key to return...");
+   ReadCh ();
+   return;
+ }
+ 
+ int
+ builtinplusplus (fp, begin, length, text, textlen)
+      FILE *fp;
+      long begin;
+      int length, textlen;
+      char **text;
+ {
+   char buffer[LONG_STRING], searchword[STRING], *pending = NULL;
+   long **offsets = NULL;
+   int offset_len = 0, offset_max = 0;
+   int lines = 0, saveidx, ch, len, chars;
+   int slurping = FALSE; /* used to find the end of the file */
+   int searching = FALSE;
+   long end_offset = begin + length;
+   int idx = -textlen, cur_line_len;
+ 
+   if (fseek (fp, begin, 0) == -1) {
+     dprint (1, (debugfile, "pager2(): fseek() returned errno %d!\n", errno));
+     error1 ("Failed to seek %d bytes into file!", begin);
+     if (sleepmsg > 0)
+       sleep (sleepmsg);
+     return (0);
+   }
+ 
+   clear_error();
+   ClearScreen();
+ 
+   for (;;) {
+     while (ftell (fp) < end_offset && 
+ 	   (lines < LINES || searching || slurping)) {
+ 
+       if (pending == NULL) {
+ 	/* There is no pending data to output, so we need to grab another
+ 	 * line.
+ 	 */
+ 	if (idx < 0) {
+ 	  /* Negative index numbers refer to the text block passed to pager2.
+ 	   * this is necessary for doings things like adding a title and
+ 	   * weeding unwanted headers.
+ 	   */
+ 	  pending = text[textlen+idx];
+ 	  idx++;
+ 	}
+ 	else {
+ 	  if (offset_len >= offset_max - 1)
+ 	    offsets = (long **) DynamicArray (offsets, sizeof (long *), &offset_max, LINES + 1);
+ 	  if (idx == offset_len) {
+ 	    if (! offsets[idx]) {
+ 	      offsets[idx] = (long *) safe_malloc (sizeof (long));
+ 	      offset_len++;
+ 	    }
+ 	    *offsets[idx] = ftell (fp);
+ 	  }
+ 	
+ 	  if ((cur_line_len= mail_gets (buffer, LONG_STRING, fp)) <= 0) {
+ 	    if (slurping) {
+ 	      slurping = FALSE;
+ 	      idx -= LINES;
+ 	      if (idx < -textlen)
+ 		idx = -textlen;
+ 	      fseek (fp, *offsets[idx > -1 ? idx : 0], 0);
+ 	      continue;
+ 	    }
+ 	    if (searching) {
+ 	      searching = FALSE;
+ 	      ClearLine (LINES);
+ 	      PutLine0 (LINES, 0, "NOT FOUND!");
+ 	      if (sleepmsg > 0)
+ 		sleep (sleepmsg);	 
+ 	      ClearLine (LINES);
+ 	      /* Reposition the file at the appropriate place */
+ 	      idx = saveidx;
+ 	      fseek (fp, *offsets[idx > 0 ? idx : 0], 0);
+ 	    }
+ 	    break;
+ 	  }
+ 	  
+ 	  idx++;
+ 
+ 	  if (slurping)
+ 	    continue;
+ 	  
+ 	  if (searching) {
+ 	    if (in_string (buffer, searchword)) {
+ 	      searching = FALSE;
+ 	      idx -= 3;
+ 	      if (idx < -textlen)
+ 		idx = -textlen;
+ 	      fseek (fp, *offsets[idx > 0 ? idx : 0], 0);
+ 	      ClearScreen ();
+ 	      lines = 0;
+ 	    }
+ 	    continue;
+ 	  }
+ 
+ 	  if (cur_line_len > 0 && buffer[cur_line_len-1] == '\n') {
+ 	    buffer[cur_line_len-1] = '\0';
+ 	    if (cur_line_len > 1 && buffer[cur_line_len-2] == '\r') 
+ 	      buffer[cur_line_len-2] = '\0';
+ 	  }
+ 
+ 	  pending = buffer;
+ 	}
+       }
+ 
+       /* This is the part of the code that actually displays on the screen */
+       chars = 0;
+       while (*pending) {
+ 	if (chars >= COLUMNS)
+ 	  break;
+ 
+ 	if (*pending == '\t') {
+ 	  Writechar('\t');
+ 	  chars += tabspacing;
+ 	}
+ #ifdef ASCII_CTYPE
+         else if (!isascii(*pending)) {
+           Writechar('?');
+           chars++;
+         }
+ #endif
+ 	else if (iscntrl((unsigned char)*pending)) {
+ 	  if (*pending >= 0 && *pending <= 31) {    
+             /* This won't fit on the line, so just skip it for now */
+             if (chars == COLUMNS - 1)
+               break;
+ 
+             Writechar('^');
+             Writechar(*pending + 64);
+             chars += 2;
+ 
+             /* Honor the formfeed character */
+             if (*pending == ctrl('L'))
+               break;
+           }
+           else {
+             Writechar('?');
+             chars++;
+           }
+ 	}
+ 	else {
+ 	  Writechar(*pending);
+ 	  chars++;
+ 	}
+ 	pending++;
+       }
+       NewLine();
+       lines++;
+ 
+       /* Check to see if we are finished with this line */
+       if (*pending == '\0')
+ 	pending = NULL;
+     }
+ 
+     StartBold();
+     len = 100 * (ftell (fp) - begin) / length;
+     if (len == 100)
+       Write_to_screen ("Command ('i' to return to index):", 0);
+     else {
+       sprintf (buffer, "MORE (you've seen %d%%):", len);
+       Write_to_screen (buffer, 0);
+     }
+     EndBold();
+ 
+     ch = ReadCh ();
+     switch (ch) {
+     case ' ':
+     case '+':
+       if (len == 100) {
+ 	DestroyDynamicArray (offsets);
+ 	return (' ');
+       }
+       lines = 0;
+       ClearScreen ();
+       break;
+     case '^':      
+       idx = 0;
+       fseek (fp, begin, 0);
+       lines = 0;
+       ClearScreen ();
+       break;
+     case 'G':
+       idx = offset_len;
+       fseek (fp, *offsets[idx-1], 0);
+       slurping = TRUE;
+       lines = 0;
+       ClearScreen ();
+       break;
+     case '/':
+       ClearLine (LINES);
+       PutLine0 (LINES, 0, "Search: ");
+       searchword[0] = '\0';
+       optionally_enter (searchword, LINES, 8, FALSE, FALSE);
+       if (searchword[0])
+ 	searching = TRUE;
+       saveidx = idx;
+       break;	
+     case '-':
+       idx -= LINES * 2;
+       if (idx < -textlen)
+ 	idx = -textlen;
+       fseek (fp, *offsets[idx > 0 ? idx : 0], 0);
+       ClearScreen ();
+       lines = 0;
+       break;
+     case ctrl('P'):
+       idx -= LINES + 1;
+       if (idx < -textlen)
+ 	idx = -textlen;
+       lines = 0;
+       ClearScreen();
+       break;
+     case ctrl('D'):
+       lines = LINES / 2;
+       ClearScreen ();
+       break;
+     case ctrl('U'):
+       idx -= LINES + (LINES / 2);
+       if (idx < -textlen)
+ 	idx = -textlen;
+       lines = 0;
+       ClearScreen ();
+       break;      
+     case '?':
+       builtin_help ();
+     case ctrl('L'):
+       idx -= LINES;
+       if (idx < -textlen)
+ 	idx = -textlen;
+       fseek (fp, *offsets[idx > 0 ? idx : 0], 0);
+       ClearScreen ();
+       lines = 0;
+       break;
+     case '\n':
+       {
+ 	int x, y;
+ 
+ 	GetXYLocation (&x, &y);
+ 	ClearLine (x);
+       }
+       lines = LINES - 1;
+       break;
+     default:
+       DestroyDynamicArray (offsets);
+       return (ch == 'q' || ch == 'x' ? 0 : ch);
+     }
+   }
+ }

diff -c elm-2.4pl24/src/delete.c elm-2.4pl24me8/src/delete.c
*** elm-2.4pl24/src/delete.c	Sat Oct  3 15:58:49 1992
--- elm-2.4pl24me8/src/delete.c	Wed Sep 13 16:21:38 1995
***************
*** 90,96 ****
  	char tempbuf[3];
  
  	strcpy(tempbuf, show_status(ifmain(headers[msg]->status,
! 	                                   aliases[msg]->status)));
  
  	if (on_page(msg)) {
  	  MoveCursor(((compute_visible(msg+1)-1) % headers_per_page) + 4, 2);
--- 90,97 ----
  	char tempbuf[3];
  
  	strcpy(tempbuf, show_status(ifmain(headers[msg]->status,
! 	                                   aliases[msg]->status),
! 				    ifmain(headers[msg], NULL)));
  
  	if (on_page(msg)) {
  	  MoveCursor(((compute_visible(msg+1)-1) % headers_per_page) + 4, 2);
***************
*** 165,171 ****
  	    StartBold();
  	    PutLine2(((compute_visible(msg+1)-1) % headers_per_page) + 4,
  		   2, "%s%c", show_status(ifmain(headers[msg]->status,
! 		                                 aliases[msg]->status)),
  		   ison(ifmain(headers[msg]->status,
  		               aliases[msg]->status), TAGGED )? '+' : ' ');
  	    EndBold();
--- 166,173 ----
  	    StartBold();
  	    PutLine2(((compute_visible(msg+1)-1) % headers_per_page) + 4,
  		   2, "%s%c", show_status(ifmain(headers[msg]->status,
! 		                                 aliases[msg]->status),
! 					  ifmain(headers[msg], NULL)),
  		   ison(ifmain(headers[msg]->status,
  		               aliases[msg]->status), TAGGED )? '+' : ' ');
  	    EndBold();
***************
*** 173,179 ****
  	  else
  	    PutLine2(((compute_visible(msg+1)-1) % headers_per_page) + 4,
  		   2, "%s%c", show_status(ifmain(headers[msg]->status,
! 		                                 aliases[msg]->status)),
  		   ison(ifmain(headers[msg]->status,
  		               aliases[msg]->status), TAGGED )? '+' : ' ');
  }
--- 175,203 ----
  	  else
  	    PutLine2(((compute_visible(msg+1)-1) % headers_per_page) + 4,
  		   2, "%s%c", show_status(ifmain(headers[msg]->status,
! 		                                 aliases[msg]->status),
! 					ifmain(headers[msg], NULL)),
  		   ison(ifmain(headers[msg]->status,
  		               aliases[msg]->status), TAGGED )? '+' : ' ');
+ }
+ 
+ int
+ DeleteTagged()
+ {
+ /** delete all tagged messages.  return TRUE if the current message was
+     deleted. **/
+   int iindex, count = 0;
+   char buf[STRING];
+ 
+   if (!inalias) {
+     for (iindex=0; iindex < message_count; iindex++)
+       if (headers[iindex]->status & TAGGED) {
+         headers[iindex]->status |= DELETED;
+         count++;
+         show_new_status(iindex);
+       }
+     sprintf(buf, "%d message%s deleted.", count, count != 1 ? "s" : "");
+     Centerline(LINES, buf);
+     return(headers[current-1]->status & DELETED ? 1 : 0);
+   }
  }

diff -c elm-2.4pl24/src/elm.c elm-2.4pl24me8/src/elm.c
*** elm-2.4pl24/src/elm.c	Mon May 30 09:26:14 1994
--- elm-2.4pl24me8/src/elm.c	Thu Sep 14 22:08:51 1995
***************
*** 143,148 ****
--- 143,153 ----
  #  include <sys/timeb.h>
  #endif
  
+ #ifdef MIME
+ #include "mime.h"
+ #endif
+ #include "me.h"
+ 
  long bytes();
  char *format_long(), *parse_arguments(), *error_description();
  
***************
*** 258,264 ****
  	    if (cursor_control)
  	      transmit_functions(ON);	/* insurance */
  	  }
- 
  	  prompt(Prompt);
  
  	  CleartoEOLN();
--- 263,268 ----
***************
*** 402,408 ****
  			  fflush(stdin);
  			  break;
  #endif
! 		
  	    case 'f'    :  PutLine0(LINES-3, strlen(Prompt),
  			     catgets(elm_msg_cat, ElmSet, ElmForward,
  			     "Forward"));
--- 406,421 ----
  			  fflush(stdin);
  			  break;
  #endif
! #ifdef USE_PGP
! 	    case ctrl('E'):
! 	      Write_to_screen("Extract PGP public key",0);
! 	      if (headers[current-1]->pgp & PGP_PUBLIC_KEY)
! 		redraw = pgp_extract_public_key();
! 	      else
! 		error("This message does not contain PGP public keys!");
! 	      break;
! #endif
! 
  	    case 'f'    :  PutLine0(LINES-3, strlen(Prompt),
  			     catgets(elm_msg_cat, ElmSet, ElmForward,
  			     "Forward"));
***************
*** 464,469 ****
--- 477,488 ----
  			       "No mail to read!"));
  			   break;
  
+ #ifdef USE_PGP
+             case ctrl('K'):
+ 	                   PutLine0(LINES-3, strlen(Prompt), "Mail PGP public key");
+ 	                   redraw = pgp_mail_public_key ();
+                            break;
+ #endif
  	    case 'm'    :  PutLine0(LINES-3, strlen(Prompt),
  			     catgets(elm_msg_cat, ElmSet, ElmMail,
  			     "Mail"));
***************
*** 615,621 ****
  			   }
  			   ClearLine(LINES-2);		
  			   break;
! 
  	    case 'X'    :  PutLine0(LINES-3, strlen(Prompt),
  			     catgets(elm_msg_cat, ElmSet, ElmQuickExit,
  			     "Quick Exit"));
--- 634,659 ----
  			   }
  			   ClearLine(LINES-2);		
  			   break;
! #ifdef MIME
! 	    case 'v'    :  if (headers) {	      
! 	                    if (headers[current-1]->status & MIME_MESSAGE) {
! 			      attach_parse (headers[current-1], mailfile);
! 			      if (headers[current-1]->mime_rec.parts)
! 				(void) attach_menu (headers[current-1]->
! 						    mime_rec.parts, TRUE);
! 			      else 
! 				/* So we can save mail in decoded ... */
! 				(void) attach_menu (&(headers[current-1]->
! 						      mime_rec),TRUE);
! 			      redraw++;
! 			    }
!                              else
!                                error ("This is not a MIME message!");
!                            }
!                            else
!                              error ("There are no messages!");
!                            break;
! #endif
  	    case 'X'    :  PutLine0(LINES-3, strlen(Prompt),
  			     catgets(elm_msg_cat, ElmSet, ElmQuickExit,
  			     "Quick Exit"));
***************
*** 622,628 ****
                             fflush(stdout);
  			   leave(0);
  			   break;
! 
  	    case ctrl('Q') :
  	    case 'x'    :  PutLine0(LINES-3, strlen(Prompt),
  			     catgets(elm_msg_cat, ElmSet, ElmExit,
--- 660,666 ----
                             fflush(stdout);
  			   leave(0);
  			   break;
! 		
  	    case ctrl('Q') :
  	    case 'x'    :  PutLine0(LINES-3, strlen(Prompt),
  			     catgets(elm_msg_cat, ElmSet, ElmExit,
***************
*** 745,751 ****
  	Write_to_screen(     "            \t\t\t        n  f  d  d  m  e  o  a        v  d  n  i\n\r", 0);
  
  	sprintf(buffer, 
! 		"\n\rOffset: %ld\t\t\t        %d  %d  %d  %d  %d  %d  %d  %d",
  		current_header->offset,
  		(current_header->status & ACTION) != 0,
  		(current_header->status & CONFIDENTIAL) != 0,
--- 783,789 ----
  	Write_to_screen(     "            \t\t\t        n  f  d  d  m  e  o  a        v  d  n  i\n\r", 0);
  
  	sprintf(buffer, 
! 		"\n\rOffset: %ld\t\t\t        %d  %d  %d  %d  %d  %d  ",
  		current_header->offset,
  		(current_header->status & ACTION) != 0,
  		(current_header->status & CONFIDENTIAL) != 0,
***************
*** 752,760 ****
  		(current_header->status & DELETED) != 0,
  		(current_header->status & EXPIRED) != 0,
  		(current_header->status & FORM_LETTER) != 0,
! 		(current_header->status & MIME_MESSAGE) != 0,
! 		(current_header->status & MIME_NEEDDECOD) != 0,
! 		(current_header->status & MIME_NOTPLAIN) != 0);
  	sprintf(buffer + strlen(buffer),
  		"  %d  %d  %d  %d  %d  %d\n",
  		(current_header->status & NEW) != 0,
--- 790,796 ----
  		(current_header->status & DELETED) != 0,
  		(current_header->status & EXPIRED) != 0,
  		(current_header->status & FORM_LETTER) != 0,
! 		(current_header->status & MIME_MESSAGE) != 0);
  	sprintf(buffer + strlen(buffer),
  		"  %d  %d  %d  %d  %d  %d\n",
  		(current_header->status & NEW) != 0,
***************
*** 790,795 ****
--- 826,848 ----
  		current_header->messageid : "<none>");
  
  	Write_to_screen("Status: %s\n\r", 1, current_header->mailx_status);
+ 
+ #ifdef MIME
+ 	{
+ 	  char *tmp = "<bad value>";
+ 	  switch (current_header->mime_rec.encoding) {
+ 	  case ENCODING_ILLEGAL: tmp = "<Illegal>"; break;
+ 	  case ENCODING_NONE:    tmp = "(none)"; break;
+ 	  case ENCODING_7BIT:    tmp = ENC_NAME_7BIT; break;
+ 	  case ENCODING_8BIT:    tmp = ENC_NAME_8BIT; break;
+ 	  case ENCODING_BINARY:  tmp = ENC_NAME_BINARY; break;
+ 	  case ENCODING_QUOTED:  tmp = ENC_NAME_QUOTED; break;
+ 	  case ENCODING_BASE64:  tmp = ENC_NAME_BINARY; break;
+ 	  case ENCODING_EXPERIMENTAL: tmp="<X-*>"; break;
+ 	  }
+ 	  Write_to_screen("Content-Transfer-Encoding: %s\n\r",1,tmp);
+ 	}
+ #endif
  	
  	PutLine0(LINES,0,"Please Press any key to return.");
  	(void) ReadCh();

diff -c elm-2.4pl24/src/fileio.c elm-2.4pl24me8/src/fileio.c
*** elm-2.4pl24/src/fileio.c	Tue Aug 30 08:08:09 1994
--- elm-2.4pl24me8/src/fileio.c	Wed Sep 20 15:02:44 1995
***************
*** 105,110 ****
--- 105,111 ----
  #include "s_elm.h"
  #include <sys/stat.h>
  #include <errno.h>
+ #include "me.h"
  
  extern int errno;
  
***************
*** 165,171 ****
--- 166,174 ----
      int sender_added = 0;
      int crypted = 0;
      int bytes_seen = 0;
+     int was_binary = 0;
      int buf_len, err;
+     int i;
  
        /** get to the first line of the message desired **/
  
***************
*** 224,230 ****
        /* are we still in the header? */
  
        if (in_header && front_line) {
! 	if (buf_len < 2) {
  	  in_header = 0;
  	  bytes_seen = 0;
  	  end_header = -1;
--- 227,237 ----
        /* are we still in the header? */
  
        if (in_header && front_line) {
! 	if (buf_len < 2 
! 	    /* Following is support for BINARYMIME: */
! 	    || buffer[0] == '\r' && buffer[1] == '\n') {
! 	  was_binary = 
! 	    (buffer[0] == '\r' && buffer[1] == '\n');
  	  in_header = 0;
  	  bytes_seen = 0;
  	  end_header = -1;
***************
*** 234,240 ****
  	    }
  	  }
  	}
! 	else if (!isspace(*buffer)
  	      && index(buffer, ':') == NULL
  #ifdef MMDF
  	      && strcmp(buffer, MSG_SEPARATOR) != 0
--- 241,247 ----
  	    }
  	  }
  	}
! 	else if (!whitespace(*buffer)
  	      && index(buffer, ':') == NULL
  #ifdef MMDF
  	      && strcmp(buffer, MSG_SEPARATOR) != 0
***************
*** 243,256 ****
  	  in_header = 0;
  	  bytes_seen = 0;
  	  end_header = 1;
  	  if (remail && !sender_added) {
! 	    if (fprintf(dest_file, "%sSender: %s\n", prefix, username) == EOF) {
  	      copy_write_error_exit();
  	    }
  	  }
  	} else if (in_header && remote && header_cmp(buffer, "Sender", NULL)) {
  	  if (remail)
! 	    if (fprintf(dest_file, "%sSender: %s\n", prefix, username) == EOF) {
  	      copy_write_error_exit();
  	    }
  	  sender_added = TRUE;
--- 250,266 ----
  	  in_header = 0;
  	  bytes_seen = 0;
  	  end_header = 1;
+ 	  was_binary = 0;
  	  if (remail && !sender_added) {
! 	    if (fprintf(dest_file, "%sSender: %s%s", prefix, username,
! 			was_binary ? "\r\n" : "\n") == EOF) {
  	      copy_write_error_exit();
  	    }
  	  }
  	} else if (in_header && remote && header_cmp(buffer, "Sender", NULL)) {
  	  if (remail)
! 	    if (fprintf(dest_file, "%sSender: %s%s", prefix, username,
! 			was_binary ? "\r\n" : "\n") == EOF) {
  	      copy_write_error_exit();
  	    }
  	  sender_added = TRUE;
***************
*** 259,276 ****
  	if (end_header) {
  	  if (update_status) {
  	      if (isoff(current_header->status, NEW)) {
  		if (ison(current_header->status, UNREAD)) {
! 		  if (fprintf(dest_file, "%sStatus: O\n", prefix) == EOF) {
  		    copy_write_error_exit();
! 		  }
! 		} else	/* read */
! #ifdef BSD
! 		  if (fprintf(dest_file, "%sStatus: OR\n", prefix) == EOF) {
! #else
! 		  if (fprintf(dest_file, "%sStatus: RO\n", prefix) == EOF) {
! #endif
  		    copy_write_error_exit();
! 		  }
  		update_status = FALSE; /* do it only once */
  	      }	/* else if NEW - indicate NEW with no Status: line. This is
  		 * important if we resync a mailfile - we don't want
--- 269,304 ----
  	if (end_header) {
  	  if (update_status) {
  	      if (isoff(current_header->status, NEW)) {
+ 		if (fprintf (dest_file, "%sStatus: ", prefix) == EOF)
+ 		  copy_write_error_exit ();
+ 
  		if (ison(current_header->status, UNREAD)) {
! 		  if (fprintf(dest_file, "O") == EOF)
  		    copy_write_error_exit();
! 		} else {	/* read */
! 		  if (fprintf(dest_file, "RO") == EOF)
  		    copy_write_error_exit();
! 
!                   if (ison(current_header->status, REPLIED)) {
!                     if (fprintf (dest_file, "r") == EOF)
!                       copy_write_error_exit ();
!                   }
!                 }
! 
!                 /* save all the status flags that ELM doesn't understand */
!                 for (i=0; current_header->mailx_status[i] != '\0'; i++)
!                   switch (current_header->mailx_status[i]) {
!                     case 'R':
!                     case 'O':
!                     case 'r':
!                       break;
!                     default:
!                       if (fprintf (dest_file, "%c", current_header->mailx_status[i]) == EOF)
!                         copy_write_error_exit ();
!                   }
! 
!                 if (fprintf (dest_file, was_binary ? "\r\n" : "\n") == EOF)
!                   copy_write_error_exit ();
  		update_status = FALSE; /* do it only once */
  	      }	/* else if NEW - indicate NEW with no Status: line. This is
  		 * important if we resync a mailfile - we don't want
***************
*** 285,291 ****
  		 */
  	      if (end_header > 0) {
  		/* add the missing newline for RFC 822 */
! 		if (fprintf(dest_file, "\n") == EOF) {
  		  copy_write_error_exit();
  		}
  	      }
--- 313,319 ----
  		 */
  	      if (end_header > 0) {
  		/* add the missing newline for RFC 822 */
! 		if (fprintf(dest_file, was_binary ? "\r\n" : "\n") == EOF) {
  		  copy_write_error_exit();
  		}
  	      }
***************
*** 357,362 ****
--- 385,448 ----
        }
        else { /* not in header */
          /* Process checks that occur after the header area */
+ #ifdef USE_PGP
+ 	/* decrypt PGP messages when replying... */
+ 	if ((cm_options & CM_REPLY) &&
+ 	    (current_header->pgp & (PGP_MESSAGE|PGP_SIGNED_MESSAGE))) {
+           FILE *fpin, *fpout;
+           int bytes, st;
+ 
+ 	  if (current_header->pgp & PGP_MESSAGE)
+ 	    error("Decrypting message...");
+ 	  else
+ 	    error("Checking signature...");
+ 
+ 	  if (current_header->pgp & PGP_MESSAGE) {
+ 	    if (!pgp_goodPassphrase())
+ 	      return (-1);
+ 	  }
+ 	  Raw(OFF);
+           if (pgp_decrypt_init(&fpin, &fpout, current_header->pgp & (PGP_MESSAGE|PGP_SIGNED_MESSAGE)) == -1) {
+ 	    Raw(ON);
+ 	    return;
+ 	  }
+           bytes = current_header->content_length;
+           while (bytes > 0) {
+             if (fgets(buffer, VERY_LONG_STRING, mailfile) == 0)
+                break;
+             bytes -= strlen(buffer);
+             fputs(buffer, fpout);
+           }
+           fclose(fpout);
+           wait(&st);
+           while (fgets(buffer, VERY_LONG_STRING, fpin) != 0)
+ 	    fprintf(dest_file, "%s%s", prefix, buffer);
+           fclose(fpin);
+           PressAnyKeyToContinue();
+           Raw(ON);
+           break;
+         }
+ #endif /* USE_PGP */
+ #ifdef MIME
+ 	if (cm_options & CM_REPLY || forwarding) {
+ 	  dprint(10,(debugfile,"Copy_message: replying or forwarding...\n"));
+ 	  /* Decode when replying. */
+ 	  
+ 	  if (current_header->status & MIME_MESSAGE) {
+ 	    state_t state;
+ 
+ 	    dprint(10,(debugfile,"Copy_message: MIME-message -- decoding\n"));
+ 
+ 	    attach_parse(current_header, mailfile);
+ 	    state.fpin = mailfile;
+ 	    state.fpout = dest_file;
+ 	    state.prefix = prefix;
+ 	    state.displaying = FALSE;
+ 	    mime_decode(&(current_header->mime_rec), &state);
+ 	    break;
+ 	  }
+ 	}
+ #endif /* MIME */
  
  	/* perform encryption checks */
  	if (buffer[0] == '[' && decode) {

diff -c elm-2.4pl24/src/help.c elm-2.4pl24me8/src/help.c
*** elm-2.4pl24/src/help.c	Mon May 30 09:42:49 1994
--- elm-2.4pl24me8/src/help.c	Mon Jul 24 11:27:18 1995
***************
*** 306,311 ****
--- 306,316 ----
  	    case ctrl('U') : s = catgets(elm_msg_cat, ElmSet, ElmHelpUndeletePattern,
  		      "^U = Undelete all messages with the specified pattern.");
  		      break;
+ #ifdef MIME
+             case 'v':  s = catgets(elm_msg_cat, ElmSet, ElmHelpViewAttach,
+                        "v = View Attachments in current message.");
+                        break;
+ #endif
  
  	    case 'x': s = catgets(elm_msg_cat, ElmSet, ElmHelpExitFolder,
  			"x = Exit leaving the folder untouched, ask permission if changed.");

diff -c elm-2.4pl24/src/limit.c elm-2.4pl24me8/src/limit.c
*** elm-2.4pl24/src/limit.c	Sun May 15 16:10:11 1994
--- elm-2.4pl24me8/src/limit.c	Mon Jul  3 17:48:54 1995
***************
*** 52,59 ****
--- 52,61 ----
  
  #define TO		1
  #define FROM		2
+ #define CC              3
  
  char *shift_lower();
+ void ClearSelection();
  
  int
  limit()
***************
*** 83,91 ****
  		"Adding criteria..."));
  	  } else {
  	    Write_to_screen(catgets(elm_msg_cat, ElmSet, ElmNoWord, "No."), 0);
- 	    selected = 0;
  	    PutLine0(LINES-3, COLUMNS-30, catgets(elm_msg_cat, ElmSet, ElmLimitChanging,
  		"Change criteria..."));
  	  }
  	}
  
--- 85,93 ----
  		"Adding criteria..."));
  	  } else {
  	    Write_to_screen(catgets(elm_msg_cat, ElmSet, ElmNoWord, "No."), 0);
  	    PutLine0(LINES-3, COLUMNS-30, catgets(elm_msg_cat, ElmSet, ElmLimitChanging,
  		"Change criteria..."));
+ 	    selected = 0;
  	  }
  	}
  
***************
*** 142,151 ****
  	    if (equal(first, "?")) {
  	      if (last_selected)
  	        error(catgets(elm_msg_cat, ElmSet, ElmEnterLastSelected,
! 	          "Enter: {\"subject\",\"to\",\"from\"} [pattern] OR \"all\""));
  	      else
  	        error(catgets(elm_msg_cat, ElmSet, ElmEnterSelected,
! 		  "Enter: {\"subject\",\"to\",\"from\"} [pattern]"));
  	      continue;
  	    }
  	    else if (equal(first, "all")) {
--- 144,153 ----
  	    if (equal(first, "?")) {
  	      if (last_selected)
  	        error(catgets(elm_msg_cat, ElmSet, ElmEnterLastSelected,
! 	          "Enter: {\"subject\",\"to\",\"from\",\"cc\"} [pattern] OR \"tagged\" OR \"all\""));
  	      else
  	        error(catgets(elm_msg_cat, ElmSet, ElmEnterSelected,
! 		  "Enter: {\"subject\",\"to\",\"from\"} [pattern] OR \"tagged\""));
  	      continue;
  	    }
  	    else if (equal(first, "all")) {
***************
*** 152,171 ****
  	      all++;
  	      selected = 0;
  	    }
! 	    else if (equal(first, "subj") || equal(first, "subject"))
! 	      selected = limit_selection(SUBJECT, rest, selected);
! 	    else if (equal(first, "to"))
! 	      selected = limit_selection(TO, rest, selected);
! 	    else if (equal(first, "from"))
! 	      selected = limit_selection(FROM, rest, selected);
  	    else {
! 	      error1(catgets(elm_msg_cat, ElmSet, ElmLimitNotValidCriterion,
! 		"\"%s\" not a valid criterion."), first);
! 	      continue;
  	    }
  	    break;
  	  }
! 	}
  
  	if (all && last_selected)
  	  strcpy(msg, catgets(elm_msg_cat, ElmSet, ElmLimitReturnToUnlimited,
--- 154,211 ----
  	      all++;
  	      selected = 0;
  	    }
! 	    else if (equal(first, "tagged"))
! 	      selected = SelectTaggedMessages();
  	    else {
! 	      char *c, *p, buf[STRING], buf2[STRING];
! 	      int complx = 0, err = 0, iter = 0;
! 
! 	      if (!selected)
! 		ClearSelection();
! 		
! 	      /* this next bit of code assumes that the input string is a
! 		 list of "and"ed or "or"ed items.  NOTE: it assumes that
! 		 if the first operator is "and", then all operators are "and",
! 		 and vice-versa. */
! 	      strcpy(buf, first);
! 	      strcat(buf, " ");
! 	      strcat(buf, rest);
! 	      p = buf;
! 	      if (index(p, '&') != NULL)
! 		complx = 1;
! 	      while ((c = strtok(p, "|&")) != NULL) {
! 		while (*c && isspace(*c)) ++c;
! 		p = c;
! 		while (*p && !isspace(*p)) ++p;
! 		while (*p && isspace(*p)) ++p;
! 		strcpy(buf2, p);
! 		remove_possible_trailing_spaces(buf2);
! 		if (strncmp(c, "subj", 4) == 0)
! 		  limit_selection(SUBJECT, buf2, selected||(complx&&iter!=0));
! 		else if (strncmp(c, "to", 2) == 0)
! 		  limit_selection(TO, buf2, selected||(complx&&iter!=0));
! 		else if (strncmp(c, "cc", 2) == 0)
! 		  limit_selection(CC, buf2, selected||(complx&&iter!=0));
! 		else if (strncmp(c, "from", 4) == 0)
! 		  limit_selection(FROM, buf2, selected||(complx&&iter!=0));
! 		else {
! 		  if ((p = index(c, ' ')) != NULL)
! 		    *p = '\0';
! 		  error1(catgets(elm_msg_cat, ElmSet, ElmLimitNotValidCriterion,
! 				 "\"%s\" not a valid criterion."), c);
! 		  err = 1;
! 		  break;
! 		}
! 		p = NULL;
! 		++iter;
! 	      }
! 	      if (err)
! 		continue;
! 	      selected = TallySelection();
  	    }
  	    break;
  	  }
!         }
  
  	if (all && last_selected)
  	  strcpy(msg, catgets(elm_msg_cat, ElmSet, ElmLimitReturnToUnlimited,
***************
*** 214,231 ****
  int based_on, additional_criteria;
  char *pattern;
  {
- 	/** Given the type of criteria, and the pattern, mark all
- 	    non-matching headers as ! VISIBLE.  If additional_criteria,
- 	    don't mark as visible something that isn't currently!
- 	**/
- 
  	register int iindex;
  	register char *hdr_value;
- 	int count = 0;
  
- 	dprint(2, (debugfile, "\n\n\n**limit on %d - '%s' - (%s) **\n\n",
- 		   based_on, pattern, additional_criteria?"add'tl":"base"));
- 
  	for (iindex = 0 ; iindex < message_count ; iindex++) {
  
  	    switch (based_on) {
--- 254,262 ----
***************
*** 235,240 ****
--- 266,274 ----
  	    case TO:
  		hdr_value = headers[iindex]->to;
  		break;
+ 	    case CC:
+ 		hdr_value = headers[iindex]->cc;
+ 		break;
  	    case SUBJECT:
  	    default:
  		hdr_value = headers[iindex]->subject;
***************
*** 241,262 ****
  		break;
  	    }
  
! 	    if (!in_string(shift_lower(hdr_value), pattern))
! 		headers[iindex]->status &= ~VISIBLE;
! 	    else if (additional_criteria && !(headers[iindex]->status&VISIBLE))
! 		; /* leave this marked not visible */
! 	    else {
! 		headers[iindex]->status |= VISIBLE;
! 		count++;
! 		dprint(5, (debugfile,
! 		    "  Message %d (%s from %s) marked as visible\n",
! 		    iindex, headers[iindex]->subject, headers[iindex]->from));
  	    }
! 
! 	}
! 
! 	dprint(4, (debugfile, "\n** returning %d selected **\n\n\n", count));
! 	return(count);
  }
  
  int
--- 275,289 ----
  		break;
  	    }
  
! 	    if (additional_criteria) {
! 	      if (headers[iindex]->status & VISIBLE) {
! 		if (!in_string(shift_lower(hdr_value), pattern))
! 		  headers[iindex]->status &= ~VISIBLE;
! 	      }
  	    }
! 	    else if (in_string(shift_lower(hdr_value), pattern))
! 	      headers[iindex]->status |= VISIBLE;
!         }
  }
  
  int
***************
*** 438,441 ****
--- 465,499 ----
  	dprint(4, (debugfile, "index %d is NOT displayed!\n", message));
  
  	return(message_count+1);
+ }
+ 
+ void
+ ClearSelection() {
+   int iindex;
+ 
+   for (iindex = 0; iindex < message_count; iindex++)
+     headers[iindex]->status &= ~VISIBLE;
+ }
+ 
+ int
+ TallySelection() {
+   int iindex, count = 0;
+ 
+   for (iindex = 0 ; iindex < message_count ; iindex++)
+     if (headers[iindex]->status & VISIBLE)
+       ++count;
+   return(count);
+ }
+ 
+ int
+ SelectTaggedMessages() {
+   int iindex, count = 0;
+ 
+   for (iindex = 0; iindex < message_count; iindex++)
+     if (headers[iindex]->status & TAGGED) {
+       headers[iindex]->status |= VISIBLE;
+       ++count;
+     } else
+       headers[iindex]->status &= ~VISIBLE;
+   return(count);
  }

diff -c elm-2.4pl24/src/mailmsg1.c elm-2.4pl24me8/src/mailmsg1.c
*** elm-2.4pl24/src/mailmsg1.c	Mon Jul 19 19:46:14 1993
--- elm-2.4pl24me8/src/mailmsg1.c	Sun Jul 16 11:53:11 1995
***************
*** 229,234 ****
--- 229,238 ----
  	if ((p = getenv("REPLYTO")) != NULL)
  	  strcpy(reply_to, p);
  
+         /* auto bcc line */
+         if ((p = getenv("BCC")) != NULL)
+           strcpy(bcc, p);
+ 
  	/******* And now the real stuff! *******/
  
  	/* copy msg into edit buffer? */
***************
*** 246,255 ****
  	if (reply_to[0])
  	  build_address(strip_commas(reply_to), expanded_reply_to);
  
  	/** if we're batchmailing, let's send it and GET OUTTA HERE! **/
  
  	if (batch_only) {
! 	  return(mail(FALSE, FALSE, form_letter));
  	}
  
  	display_to(expanded_to);	/* display the To: field on screen... */
--- 250,263 ----
  	if (reply_to[0])
  	  build_address(strip_commas(reply_to), expanded_reply_to);
  
+ 	/* expand the bcc address */
+ 	if (bcc[0])
+ 	  build_address(strip_commas(bcc), expanded_bcc);
+ 
  	/** if we're batchmailing, let's send it and GET OUTTA HERE! **/
  
  	if (batch_only) {
! 	  return(mail(FALSE, FALSE, form_letter, FALSE));
  	}
  
  	display_to(expanded_to);	/* display the To: field on screen... */
***************
*** 276,282 ****
  	dprint(4, (debugfile, "subject=\"%s\"\n",subject));
  	dprint(5, (debugfile, "cc=\"%s\" expanded_cc=\"%s\"\n",cc,expanded_cc));
  	dprint(5, (debugfile, "bcc=\"%s\" expanded_bcc=\"%s\"\n",bcc,expanded_bcc));
! 	return(mail(copy_msg, edit_message, form_letter));
  }
  
  int
--- 284,290 ----
  	dprint(4, (debugfile, "subject=\"%s\"\n",subject));
  	dprint(5, (debugfile, "cc=\"%s\" expanded_cc=\"%s\"\n",cc,expanded_cc));
  	dprint(5, (debugfile, "bcc=\"%s\" expanded_bcc=\"%s\"\n",bcc,expanded_bcc));
! 	return(mail(copy_msg, edit_message, form_letter, replying));
  }
  
  int
***************
*** 483,489 ****
  	dprint(5, (debugfile, "bcc=\"%s\" expanded_bcc=\"%s\"\n",bcc,expanded_bcc));
  
  	main_state();
! 	ret = mail(FALSE, edit_message, form_letter);
  	main_state();
  
  /*
--- 491,497 ----
  	dprint(5, (debugfile, "bcc=\"%s\" expanded_bcc=\"%s\"\n",bcc,expanded_bcc));
  
  	main_state();
! 	ret = mail(FALSE, edit_message, form_letter, FALSE);
  	main_state();
  
  /*

diff -c elm-2.4pl24/src/mailmsg2.c elm-2.4pl24me8/src/mailmsg2.c
*** elm-2.4pl24/src/mailmsg2.c	Mon May 30 10:24:48 1994
--- elm-2.4pl24me8/src/mailmsg2.c	Wed Sep 20 16:49:01 1995
***************
*** 1,4 ****
- 
  static char rcsid[] = "@(#)$Id: mailmsg2.c,v 5.39 1994/05/30 17:24:38 syd Exp $";
  
  /*******************************************************************************
--- 1,3 ----
***************
*** 243,248 ****
--- 242,248 ----
  #include "headers.h"
  #include "s_elm.h"
  #include <errno.h>
+ #include "me.h"
  
  extern int errno;
  extern char version_buff[];
***************
*** 266,278 ****
  	    bcc[VERY_LONG_STRING], expanded_bcc[VERY_LONG_STRING],
  	    precedence[SLEN], expires_days[SLEN];
  
  
  #ifdef	MIME
! int msg_is_multipart;
  #endif /* MIME */
! long C_L_Position[2];   /*To Remember position of the Content-Length*/
! long C_StartData[2];    /*To Remember length of Header Area */
! long C_EndData[2];	/* To Remember the end of the BodyPart */
  
  int  gotten_key;
  char *bounce_off_remote();
--- 266,281 ----
  	    bcc[VERY_LONG_STRING], expanded_bcc[VERY_LONG_STRING],
  	    precedence[SLEN], expires_days[SLEN];
  
+ long cl_offset;
+ long cl_start;
+ long cl_end;
  
  #ifdef	MIME
! extern mime_t *attachments;
  #endif /* MIME */
! #ifdef USE_REMAILER
! extern int remailing;
! #endif
  
  int  gotten_key;
  char *bounce_off_remote();
***************
*** 315,322 ****
  }
  
  int
! mail(copy_msg, edit_message, form)
! int  copy_msg, edit_message, form;
  {
  	/** Given the addresses and various other miscellany (specifically, 
  	    'copy-msg' indicates whether a copy of the current message should 
--- 318,325 ----
  }
  
  int
! mail(copy_msg, edit_message, form, replying)
! int  copy_msg, edit_message, form, replying;
  {
  	/** Given the addresses and various other miscellany (specifically, 
  	    'copy-msg' indicates whether a copy of the current message should 
***************
*** 341,352 ****
  	int	 signature_done = FALSE;
  	int	 need_redraw = 0;
  	int	 err;
  
  	static int cancelled_msg = 0;
  
  	dprint(4, (debugfile, "\nMailing to \"%s\" (with%s editing)\n",
  		  expanded_to, edit_message? "" : "out"));
! 	
  	gotten_key = 0;		/* ignore previously gotten encryption key */
  
  	/** first generate the temporary filename **/
--- 344,375 ----
  	int	 signature_done = FALSE;
  	int	 need_redraw = 0;
  	int	 err;
+ 	int reask_verify = FALSE;
+ #ifdef MIME
+ 	mime_send_t MIME_info;
+ #endif
  
  	static int cancelled_msg = 0;
+ #ifdef MIME
+ 	/* Initialize structure */
+ 	MIME_info.encoding_top = ENCODING_7BIT;
+ 	MIME_info.encoding_text = ENCODING_7BIT;
+ 	MIME_info.Charset = charset;
+ 	MIME_info.need_enc = 0;
+ 	MIME_info.type = MIME_TYPE_TEXT;
+ 	strcpy (MIME_info.subtype, "plain");
+         MIME_info.type_opts[0] = '\0';
+ #endif /* MIME */
+ #ifdef USE_REMAILER
+         remailing = FALSE;
+ #endif
+ 	cl_offset = cl_start = cl_end = 0;
  
  	dprint(4, (debugfile, "\nMailing to \"%s\" (with%s editing)\n",
  		  expanded_to, edit_message? "" : "out"));
! 	/* this will get set to 1 on a successful reply */ 
! 	me_retcode = 0;
! 
  	gotten_key = 0;		/* ignore previously gotten encryption key */
  
  	/** first generate the temporary filename **/
***************
*** 438,458 ****
  	  precedence[0] = '\0';
  	}
  	else if (copy_msg && ! retransmit) {  /* if retransmit we have it! */
! 	  if (attribution[0]) {
! 	    fprintf(reply, attribution, headers[current-1]->from);
! 	    fputc('\n', reply);
  	  }
! 	  else if (forwarding) {
! 	    fputs("Forwarded message:\n", reply);
  	  }
! 	  if (edit_message) {
! 	    copy_message(prefixchars, reply,
! 		( noheader ? CM_REMOVE_HEADER : 0 ) | CM_MMDF_HEAD | CM_DECODE);
! 	    already_has_text = TRUE;	/* we just added it, right? */
! 	  }
! 	  else
! 	    copy_message("", reply,
! 		( noheader ? CM_REMOVE_HEADER : 0 ) | CM_MMDF_HEAD);
  	}
  
          /* append signature now if we are going to use an external editor */
--- 461,550 ----
  	  precedence[0] = '\0';
  	}
  	else if (copy_msg && ! retransmit) {  /* if retransmit we have it! */
! #ifdef MIME
! 	  if (!forwarding || (forwarding && !mimeforward)) {
! #endif
! 	    if (forwarding) {
! 	      fprintf (reply, "----- Forwarded message from %s -----\n\n", 
! 		       headers[current-1]->from);
! 	    }
! 	    else if (attribution[0]) {
! 	      fprintf(reply, attribution, headers[current-1]->from);
! 	      fputc('\n', reply);
! 	    }
! 	    if (edit_message) {
! 	      copy_message(forwarding ? "" : prefixchars, reply,
! 			   ( noheader ? CM_REMOVE_HEADER : 0 ) 
! 			   | CM_MMDF_HEAD | CM_DECODE | 
! 			   (replying ? CM_REPLY : 0));
! 	      already_has_text = TRUE;	/* we just added it, right? */
! 	    }
! 	    else
! 	      copy_message("", reply,
! 			   ( noheader ? CM_REMOVE_HEADER : 0 ) | CM_MMDF_HEAD);
! 
! 	    if (forwarding)
! 	      fprintf (reply, "----- End of forwarded message from %s -----\n",
! 		       headers[current-1]->from);
! #ifdef MIME
  	  }
! 	  else {
! 	    FILE *tmpfp;
! 	    int bytes = 0,len,first_line = 1;
! 	    int in_headers = TRUE;
! 
! 	    /* Use MESSAGE/RFC822 to forward messages. */
! 
! 	    attachments = (mime_t *) mime_t_alloc ();
! 	    attachments->flags = MIME_RFC822;
! 	    sprintf (very_long_buffer, "%selmfwd.%d", temp_dir, getpid ());
! 	    attachments->pathname = (char *) strmcpy(attachments->pathname, very_long_buffer);
! 	    tmpfp = fopen (attachments->pathname, "w");
! 	    fseek (mailfile, headers[current-1]->offset, 0);
! 	    while (0 < (len = mail_gets (very_long_buffer, 
! 					 VERY_LONG_STRING, mailfile))) {
! 	      if (first_line) {  /* Skip "From " ... 
! 				  * it is NOT part of RFC822!
! 				  */
! 		first_line = 0;
! 		if (0 == strncmp(very_long_buffer,"From ",5)) 
! 		  continue;
! #ifdef MMDF
! 		if (0 == strcmp(very_long_buffer,MSG_SEPARATOR)) {
! 		  first_line = 1;
! 		  continue;
! 		}
! #endif
! 	      }
! 	      fwrite (very_long_buffer, 1, len, tmpfp);
! 	      if (in_headers) {
! 		if (very_long_buffer[0] == '\n')
! 		  in_headers = FALSE;
! 		else if (very_long_buffer[0] == '\r' &&
! 			 very_long_buffer[1] == '\n')
! 		  in_headers = FALSE;
! 	      }
! 	      else {
! 		bytes += len;
! 		if (bytes >= headers[current-1]->content_length)
! 		  break;
! 	      }
! 	    }
! 	    fclose (tmpfp);
! 	    attachments->unlink = 1; /* mark for later deletion */
! 	    attachments->type = MIME_TYPE_MESSAGE;
! 	    strcpy (attachments->subtype, "rfc822");
! 	    sprintf (very_long_buffer, "Forwarded message from %s", headers[current-1]->from);
! 	    attachments->description = (char *)strmcpy (attachments->description,
! 							very_long_buffer);
! 	    
! 	    /* Pick up the encoding from the message. */
! 	    attachments->encoding = ENCODING_7BIT;
! 	    (void) update_encoding (&(attachments->encoding),
! 				    headers[current-1]->mime_rec.encoding);
! 	    attachments->length = bytes;
  	  }
! #endif /* MIME */
  	}
  
          /* append signature now if we are going to use an external editor */
***************
*** 484,538 ****
  	  }
  	} else *copy_file = '\0';	/* signals to not save a copy */
  
! 	/* ask the user to confirm transmission of the message */
! 	if (!batch_only) {
  	    ch = (edit_message? 'e' : '\0');
  	    if (verify_transmission(filename, &form, &need_redraw,
! 		    already_has_text, copy_file, ch) != 0) {
! 		cancelled_msg = (bytes(filename) > 0);
! 		return need_redraw;
  	    }
  	    if (form == YES && format_form(filename) < 1) {
! 		cancelled_msg = (bytes(filename) > 0);
! 		return need_redraw;
  	    }
! 	}
  
! 	if ((reply = fopen(filename,"r")) == NULL) {
  	    err = errno;
  	    dprint(1, (debugfile,
! 		"Attempt to open file %s for reading failed with error %s (mail)\n",
! 		filename, error_description(err)));
  	    if (!batch_only) {
! 		error1(catgets(elm_msg_cat, ElmSet, ElmCouldNotOpenReply,
! 		    "Could not open reply file (%s)."), error_description(err));
  	    } else {
! 		printf(catgets(elm_msg_cat, ElmSet, ElmCouldNotOpenReply,
! 		    "Could not open reply file (%s)."), error_description(err));
! 		putchar('\n');
  	    }
  	    return need_redraw;
! 	}
  
! 	cancelled_msg = FALSE;	/* it ain't cancelled, is it? */
  
! 	/** ask about bounceback if the user wants us to.... **/
! 
! 	if (uucp_hops(to) > bounceback && bounceback > 0 && copy_msg != FORM) 
! 	  if (verify_bounceback() == TRUE) {
! 	    if (strlen(cc) > 0) strcat(expanded_cc, ", ");
! 	    strcat(expanded_cc, bounce_off_remote(to));
! 	  }
  
  #ifdef	MIME
! 	/* Look if its a Multimedia/multipart Message */
! 	msg_is_multipart = check_for_multipart(reply);
  
! 	if (msg_is_multipart == -1) {
! 		return(need_redraw);
! 	}
! #endif /* MIME */
  
  	/** grab a copy if the user so desires... **/
  
  	remove_hostbang(expanded_to);
--- 576,796 ----
  	  }
  	} else *copy_file = '\0';	/* signals to not save a copy */
  
! 	do { /* So we can return here if check_for_multipart() fails
! 	      * - K E H <hurtta@dionysos.FMI.FI>    */
! 
! 	  reask_verify = 0;
! 
! 	  /* ask the user to confirm transmission of the message */
! 	  if (!batch_only) {
  	    ch = (edit_message? 'e' : '\0');
+ #ifdef USE_PGP
  	    if (verify_transmission(filename, &form, &need_redraw,
! 				    already_has_text, copy_file, ch, replying) != 0) {
! 	      cancelled_msg = (bytes(filename) > 0);
! # ifdef MIME
! 	      if (attachments) {
! 		mime_destroy (attachments);
! 		attachments = 0;
! 	      }
! # endif
! 	      return need_redraw;
  	    }
+ #else
+ 	    if (verify_transmission(filename, &form, &need_redraw,
+ 				    already_has_text, copy_file, ch) != 0) {
+ 	      cancelled_msg = (bytes(filename) > 0);
+ # ifdef MIME
+ 	      if (attachments) {
+ 		mime_destroy (attachments);
+ 		attachments = 0;
+ 	      }
+ # endif
+ 	      return need_redraw;
+ 	    }
+ #endif /* USE_PGP */
  	    if (form == YES && format_form(filename) < 1) {
! 	      cancelled_msg = (bytes(filename) > 0);
! 	      return need_redraw;
  	    }
!             /* so we can mark the reply flag */
!             me_retcode = 1;
! 	  }
  
! 	  if ((reply = fopen(filename,"r")) == NULL) {
  	    err = errno;
  	    dprint(1, (debugfile,
! 		       "Attempt to open file %s for reading failed with error %s (mail)\n",
! 		       filename, error_description(err)));
  	    if (!batch_only) {
! 	      error1(catgets(elm_msg_cat, ElmSet, ElmCouldNotOpenReply,
! 			     "Could not open reply file (%s)."), error_description(err));
  	    } else {
! 	      printf(catgets(elm_msg_cat, ElmSet, ElmCouldNotOpenReply,
! 			     "Could not open reply file (%s)."), error_description(err));
! 	      putchar('\n');
  	    }
  	    return need_redraw;
! 	  }
! #ifdef MIME
! 	  MIME_info.encoding_top  = ENCODING_7BIT;/* Encoding for Multipart/ */
! 	  MIME_info.encoding_text = ENCODING_7BIT;/* Encoding for Text/plain */
! 	  {
! 	    /* Determine how this message should be MIME encoded:
! 	     * 7BIT, 8BIT, BINARY or QUOTED-PRINTABLE.
! 	     */
! 	    MIME_info.need_enc = needs_encoding (reply);
! 	    
! 	    if (MIME_info.need_enc & HAVE_BINARY) {
! #ifdef USE_BINARYMIME
! 	      MIME_info.encoding_text =  ENCODING_BINARY;
! #else
! 	      if (allow_no_encoding >= 0)
! 		/* Just send BINARY anyway */
! 		MIME_info.encoding_text = ENCODING_BINARY;
! 	      else
! 		/* no -BBINARYMIME option */
! 		MIME_info.encoding_text = ENCODING_QUOTED;
! #endif
! 	    }
! 	    else if (MIME_info.need_enc & HAVE_8BIT) {
! #ifdef USE_8BITMIME
! 	      MIME_info.encoding_text =  ENCODING_8BIT;
! #else
! 	      if (allow_no_encoding >= 0)
! 		/* Just send 8BIT anyway */
! 		MIME_info.encoding_text = ENCODING_8BIT;
! 	      else
! 		/* no -B8BITMIME option */
! 		MIME_info.encoding_text = ENCODING_QUOTED;
! #endif
! 	    }
! 	    /* Control characters can send with encoding 7BIT
! 	     * HAVE_BINARY takes care really severe stuff */
! 	    if ((MIME_info.need_enc & HAVE_CTRL) &&
! 		MIME_info.encoding_text != ENCODING_QUOTED) {
! 	      if (batch_only) 		
! 		MIME_info.encoding_text =  ENCODING_QUOTED;
! 	      else { 
! 		int ch;
! 		ch = want_to("Text have control characters. \
! Encode text with quoted-printable? ",*def_ans_yes,LINES-1,0);
! 		if (ch == *def_ans_yes) 
! 		  MIME_info.encoding_text =  ENCODING_QUOTED;
! 		else if (ch != *def_ans_no) {
! 		  edit_message = FALSE;
! 		  reask_verify = TRUE;
! 		  continue;    /* Go again to verify_transmission loop */
! 		}
! 	      }
! 	    }
! 	  }
  
! 	  (void) update_encoding(&MIME_info.encoding_top,
! 				 MIME_info.encoding_text);
  
! 	  /* Update Charset */
! 	  MIME_info.Charset = charset;
! 	  if (!(MIME_info.need_enc & HAVE_8BIT) &&
! 	      istrcmp(charset,"US-ASCII") != 0 &&
! 	      charset_ok(charset))
! 	    MIME_info.Charset="US-ASCII";
! 	  else if ((MIME_info.need_enc & HAVE_8BIT) &&
! 		   istrcmp(charset,"US-ASCII") == 0 &&
! 		   istrcmp(display_charset,"US-ASCII") != 0 &&
! 		   charset_ok(display_charset))
! 	    MIME_info.Charset=display_charset;
! 	  else if ((MIME_info.need_enc & HAVE_8BIT) &&
! 		   istrcmp(charset,"US-ASCII") == 0) {
! 	    error("Text has 8BIT data and charset=US-ASCII, using charset=UNKNOWN-8BIT instead.");
! 	    
! 	    if (sleepmsg > 0)
! 	      sleep(sleepmsg);
! 	    
! 	    MIME_info.Charset="UNKNOWN-8BIT";           
!          }
  
+ #endif /* MIME */
+ 
+ 	  cancelled_msg = FALSE;	/* it ain't cancelled, is it? */
+ 
+ 	  /** ask about bounceback if the user wants us to.... **/
+ 
+ 	  if (uucp_hops(to) > bounceback && bounceback > 0 && copy_msg != FORM)
+ 	    if (verify_bounceback() == TRUE) {
+ 	      if (strlen(cc) > 0) strcat(expanded_cc, ", ");
+ 	      strcat(expanded_cc, bounce_off_remote(to));
+ 	    }
+ 
  #ifdef	MIME
! 	  MIME_info.msg_is_multipart = check_for_multipart(reply, &MIME_info);
! 	  if (MIME_info.msg_is_multipart < 0) { /* Error in [include ...] */
! 	    if (!batch_only) {
! 	      error ("Please fix [include ...] lines!");
! 	      if (sleepmsg > 0)
! 		sleep (sleepmsg);
  
! 	      edit_message = FALSE;
! 	      reask_verify = TRUE; /* Go to verify_transmission again. */
! 	    }
! 	  }
  
+ 	  if (attachments != 0) {
+ 	    /* Determine what the top level Content-Transfer-Encoding: field
+ 	     * should be.  BINARY has the highest weight, followed by
+ 	     * 8BIT.  NOTE: no checking to see if the mailer supports those
+ 	     * encodings since that will already have been done in the
+ 	     * attach_menu() routine.
+ 	     */
+ 	    mime_t *tmp;
+ 	    
+ 	    MIME_info.msg_is_multipart = TRUE;
+ 	    
+ 	    for (tmp = attachments; tmp != 0; tmp = tmp->next) 
+ 	      (void) update_encoding(&MIME_info.encoding_top,tmp->encoding);   
+ 	  }
+ #endif /* MIME */
+ 	  /* End of check_for_multipart failure loop */
+ 	} while (!batch_only && reask_verify);
+ #ifdef MIME
+ 	if (MIME_info.msg_is_multipart) {
+ 	  (void) mime_generate_boundary (MIME_info.mime_boundary);
+ 	  MIME_info.type = MIME_TYPE_MULTIPART;
+ 	  strcpy(MIME_info.subtype, "mixed");
+           add_parameter(MIME_info.type_opts, "boundary",
+                         MIME_info.mime_boundary, sizeof(MIME_info.type_opts),
+                         FALSE);
+ 	}
+ #ifdef USE_PGP
+         if (pgp_status & (PGP_MESSAGE | PGP_SIGNED_MESSAGE | PGP_PUBLIC_KEY)) {
+           MIME_info.type = MIME_TYPE_APPLICATION;
+           strcpy(MIME_info.subtype, "pgp");
+ 	  if (pgp_status & PGP_PUBLIC_KEY)
+             add_parameter(MIME_info.type_opts,"format","keys-only",
+                           sizeof(MIME_info.type_opts), FALSE);
+           else {
+             add_parameter(MIME_info.type_opts, "format", "text",
+                           sizeof(MIME_info.type_opts), FALSE);
+             /* This next bit is a non-non-standard, but exmh does this and it
+              * can be very useful when parsing the message.
+              */
+             if (pgp_status & PGP_MESSAGE) {
+               add_parameter(MIME_info.type_opts, "x-action",
+                             (pgp_status & PGP_SIGNED_MESSAGE) ? "encryptsign" : "encrypt",
+                             sizeof(MIME_info.type_opts),FALSE);
+             }
+             else
+               add_parameter(MIME_info.type_opts, "x-action", "sign",
+                             sizeof(MIME_info.type_opts), FALSE);
+           }
+         }
+ #endif
+         if (MIME_info.type == MIME_TYPE_TEXT &&
+             (istrcmp(MIME_info.subtype, "plain") == 0))
+           add_parameter(MIME_info.type_opts, "charset", MIME_info.Charset,
+                         sizeof(MIME_info.type_opts), FALSE);
+ #endif
+          
  	/** grab a copy if the user so desires... **/
  
  	remove_hostbang(expanded_to);
***************
*** 539,547 ****
--- 797,820 ----
  	remove_hostbang(expanded_cc);
  	remove_hostbang(expanded_bcc);
  
+ #ifdef USE_REMAILER
+ 	if (remailing)
+ 	  /* Retrieves the database of remailers and sets the To: address
+ 	   * to the appropriate remailer.  This is done here so that a
+ 	   * saved copy of this message will look the same as the outgoing
+ 	   * message.
+ 	   */
+ 	  remailer_proc();
+ #endif
+ 
  	if (*copy_file) /* i.e. if copy_file contains a name */
+ #ifdef MIME
  	  save_copy(expanded_to, expanded_cc, expanded_bcc,
+ 	       filename, copy_file, form, &MIME_info);
+ #else
+ 	  save_copy(expanded_to, expanded_cc, expanded_bcc,
  	       filename, copy_file, form);
+ #endif
  
  	/** write all header information into whole_msg_file **/
  
***************
*** 569,576 ****
  		  expanded_to, expanded_cc, expanded_bcc, subject));
  
  	if ((real_reply = 
  	   write_header_info(whole_msg_file, expanded_to,
! 	     expanded_cc, expanded_bcc, form == YES, FALSE)) == NULL) {
  
  	  /** IT FAILED!!  MEIN GOTT!  Use a dumb mailer instead! **/
  
--- 842,855 ----
  		  expanded_to, expanded_cc, expanded_bcc, subject));
  
  	if ((real_reply = 
+ #ifdef MIME
  	   write_header_info(whole_msg_file, expanded_to,
! 	     expanded_cc, expanded_bcc, form == YES, FALSE, &MIME_info)
! #else
! 	   write_header_info(whole_msg_file, expanded_to,
! 	     expanded_cc, expanded_bcc, form == YES, FALSE)
! #endif
! 	     ) == NULL) {
  
  	  /** IT FAILED!!  MEIN GOTT!  Use a dumb mailer instead! **/
  
***************
*** 598,629 ****
  
  	}
  	else {
  
! 	  C_StartData[0] = ftell(real_reply);
  
! 	  copy_message_across(reply, real_reply, FALSE);
  
            /* Append signature if not done earlier */
  
            if (!signature_done && !retransmit && copy_msg != FORM)
                 append_sig(real_reply);
- 	  
- #ifdef MIME
- 	  if (!copy_msg != FORM && msg_is_multipart) {
- 	    fprintf(real_reply, "\n--%s--\n", MIME_BOUNDARY);
- 	    if (C_L_Position[1] != 0L) {
- 	      C_EndData[1] = ftell(real_reply);
- 	      C_L_Position[1] = fseek(real_reply, C_L_Position[1], 0);
- 	      fprintf(real_reply, "%d", C_EndData[1] - C_StartData[1]);
- 	      fseek(real_reply, C_EndData[1], 0);
- 	    }
- 	  }
- #endif
  
- 	  C_EndData[0] = ftell(real_reply);
- 	    
- 	  fseek(real_reply, C_L_Position[0], 0);
- 	  fprintf(real_reply, "%d", C_EndData[0] - C_StartData[0]);
  	  fclose(real_reply);
  
  	  if (cc[0] != '\0')  				         /* copies! */
--- 877,944 ----
  
  	}
  	else {
+ 	  cl_start = ftell(real_reply);
+ #ifdef MIME
+ #ifdef USE_REMAILER
+ 	  if (remailing) {
+ 	    int ret;
  
! 	    ret = remailer_copy_message_across(reply, real_reply, FALSE,
! 					       &MIME_info);
! 	    remailer_destroy_db();
! 	    /* Check for error to ensure that the message is not sent if
! 	     * there was a problem, or else the sender's anonymity could
! 	     * be compromised!
! 	     */
! 	    if (ret == -1) {
! 	      fclose(reply);
! 	      fclose(real_reply);
! 	      free(whole_msg_file);
! 	      unlink(filename);
! 	      return TRUE;
! 	    }
! 	  }
! 	  else
! #endif
! 	    copy_message_across(reply, real_reply, FALSE, &MIME_info);
  
! 	  /* clean up the allocated space */
! 	  if (attachments) {
! 	    mime_destroy (attachments);
! 	    attachments = 0;
! 	  }
! #else
! #ifdef USE_REMAILER
! 	  if (remailing) {
! 	    int ret;
  
+ 	    ret = remailer_copy_message_across(reply, real_reply, FALSE);
+ 	    remailer_destroy_db();
+ 	    /* Check for error to ensure that the message is not sent if
+ 	     * there was a problem, or else the sender's anonymity could
+ 	     * be compromised!
+ 	     */
+ 	    if (ret == -1) {
+ 	      fclose(reply);
+ 	      fclose(real_reply);
+ 	      free(whole_msg_file);
+ 	      unlink(filename);
+ 	      return TRUE;
+ 	    }
+ 	  }
+ 	  else
+ #endif
+ 	    copy_message_across(reply, real_reply, FALSE);
+ #endif
+ 	  cl_end = ftell(real_reply);	    
+ 	  fseek(real_reply, cl_offset, 0);
+ 	  fprintf(real_reply, "%d", cl_end - cl_start);
+ 
            /* Append signature if not done earlier */
  
            if (!signature_done && !retransmit && copy_msg != FORM)
                 append_sig(real_reply);
  
  	  fclose(real_reply);
  
  	  if (cc[0] != '\0')  				         /* copies! */
***************
*** 649,654 ****
--- 964,982 ----
  	  } else
  	    mailerflags[0] ='\0';
  
+ #ifdef MIME
+ #ifdef USE_8BITMIME
+ 	  if (MIME_info.encoding_top == ENCODING_8BIT)
+ 	    strcat(mailerflags," -B8BITMIME");
+ #endif
+ #ifdef USE_BINARYMIME
+           if (MIME_info.encoding_top == ENCODING_BINARY)
+             /* With -BBINARYMIME lines must terminate with \r\n
+              * Unix's \n is _NOT_ sufficient - K E H              */
+             strcat(mailerflags," -BBINARYMIME");
+ #endif
+ #endif
+ 
  	  if (strcmp(submitmail, mailer) == 0)
  	    strcpy(expanded_to, " ");
  	  else {
***************
*** 708,714 ****
  	 * file just hang after we're finished with it.
  	 */
  	(void)unlink(filename);
! 
  	return(need_redraw);
  }
  
--- 1036,1044 ----
  	 * file just hang after we're finished with it.
  	 */
  	(void)unlink(filename);
! #ifdef USE_PGP
!         pgp_status=0;
! #endif
  	return(need_redraw);
  }
  
***************
*** 720,727 ****
  	strcpy(subject, subj);
  	strcpy(to, address);
  	strcpy(expanded_to, address);
! 
! 	return(mail(FORM, NO, NO));
  }
  
  int
--- 1050,1056 ----
  	strcpy(subject, subj);
  	strcpy(to, address);
  	strcpy(expanded_to, address);
! 	return(mail(FORM, NO, NO, FALSE));
  }
  
  int
***************
*** 778,785 ****
--- 1107,1119 ----
   * message.  Returns 0 to send it, -1 to forget it.
   */
  int
+ #ifdef USE_PGP
  verify_transmission(filename, form_p, need_redraw_p,
+ 	already_has_text, copy_file, force_cmd, replying)
+ #else
+ verify_transmission(filename, form_p, need_redraw_p,
  	already_has_text, copy_file, force_cmd)
+ #endif
  char *filename;		/* pathname to mail mssg composition file	*/
  int  *form_p;		/* pointer to form message state		*/
  int *need_redraw_p;	/* pointer to flag indicating screen stepped on	*/
***************
*** 786,794 ****
  int already_has_text;	/* indicates there is already text in the mssg	*/
  char *copy_file;	/* pointer to buffer holding copy file name	*/
  int force_cmd;		/* command to do, '\0' to prompt user for cmd	*/
  {
      char *prompt_mssg;		/* message to display prompting for cmd	*/
!     char prompt_menu[SLEN];	/* menu of available commands		*/
      int bad_cmd;		/* set TRUE to bitch about user's entry	*/
      int did_prompt;		/* TRUE if cmd prompted for and entered	*/
      int prev_form;		/* "*form_p" value last time thru loop	*/
--- 1120,1132 ----
  int already_has_text;	/* indicates there is already text in the mssg	*/
  char *copy_file;	/* pointer to buffer holding copy file name	*/
  int force_cmd;		/* command to do, '\0' to prompt user for cmd	*/
+ #ifdef USE_PGP
+ int replying;
+ #endif
  {
      char *prompt_mssg;		/* message to display prompting for cmd	*/
!     char prompt_menu[SLEN],	/* menu of available commands		*/
!          prompt_menu2[SLEN];
      int bad_cmd;		/* set TRUE to bitch about user's entry	*/
      int did_prompt;		/* TRUE if cmd prompted for and entered	*/
      int prev_form;		/* "*form_p" value last time thru loop	*/
***************
*** 809,814 ****
--- 1147,1153 ----
  		"Please choose one of the following options by parenthesized letter: s");
  	    strcpy(prompt_menu, catgets(elm_msg_cat, ElmSet, ElmVfyMenuUser0,
  		"e)dit message, edit h)eaders, s)end it, or f)orget it."));
+             strcpy(prompt_menu2, "");
  	} else {
  	    prompt_mssg = catgets(elm_msg_cat, ElmSet, ElmVfyPromptAndNow,
  		"And now: s");
***************
*** 839,844 ****
--- 1178,1192 ----
  	    strcat(prompt_menu, catgets(elm_msg_cat, ElmSet, ElmVfyMenuShell,
  		"!)shell, "));
  #endif
+             /* The previous line was getting too full... */
+             strcpy(prompt_menu2, "");
+ #ifdef MIME
+ 	    strcat(prompt_menu2, "a)ttachments, ");
+ #endif
+ #ifdef USE_PGP
+             strcat(prompt_menu2, "p)gp, ");
+ #endif
+ 	    strcat(prompt_menu2, "r)emailer");
  	    strcat(prompt_menu, catgets(elm_msg_cat, ElmSet, ElmVfyMenuSndFgt,
  		"s)end, or f)orget"));
  	}
***************
*** 858,869 ****
  	    force_cmd = '\0';
  	    did_prompt = FALSE;
  	} else {
! 	    MoveCursor(LINES-2, 0);
! 	    CleartoEOS();
! 	    PutLine0(LINES-2, 0, prompt_mssg);
  	    GetXYLocation(&x_coord, &y_coord);
  	    y_coord--; /* backspace over default answer */
! 	    Centerline(LINES-1, prompt_menu);
  	    fflush(stdin);
  	    fflush(stdout);
  	    Raw(ON); /* double check... testing only... */
--- 1206,1219 ----
  	    force_cmd = '\0';
  	    did_prompt = FALSE;
  	} else {
! 	    ClearLine(LINES-3);
! 	    PutLine0(LINES-3, 0, prompt_mssg);
  	    GetXYLocation(&x_coord, &y_coord);
  	    y_coord--; /* backspace over default answer */
! 	    ClearLine(LINES-2);
! 	    Centerline(LINES-2, prompt_menu);
!             ClearLine(LINES-1);
!             Centerline(LINES-1, prompt_menu2);
  	    fflush(stdin);
  	    fflush(stdout);
  	    Raw(ON); /* double check... testing only... */
***************
*** 878,904 ****
  	/* handle command */
  	switch (cmd) {
  
  	case '\n':
  	case '\r':
  	case 's':
  	    if (did_prompt)
! 		Write_to_screen("Send", 0);
  	    return 0;
  	    /*NOTREACHED*/
  
! 	case 'f': 
  	    if (did_prompt)
  		Write_to_screen("Forget", 0);
  	    if (bytes(filename) <= 0) {
  		; /* forget about empty files */
  	    } else if (mail_only) {
! 		sprintf(lbuf, "%s/%s", home, dead_letter);
! 		(void) append_copy_to_file(to, cc, bcc, lbuf, filename,
! 		    *form_p);
  	    } else if (user_level > 0) {
  		set_error(catgets(elm_msg_cat, ElmSet, ElmVfyMessageKept,
  		    "Message kept.  Can be restored at next f)orward, m)ail or r)eply."));
  	    }
  	    return -1;
  	    /*NOTREACHED*/
  
--- 1228,1311 ----
  	/* handle command */
  	switch (cmd) {
  
+ #ifdef  MIME
+ 	case 'a':
+ 	  attachments = (mime_t *) attach_menu (attachments, FALSE);
+ 	  break;
+ #endif
  	case '\n':
  	case '\r':
  	case 's':
  	    if (did_prompt)
! 	        Write_to_screen("Send", 0);
! #ifdef USE_PGP
! 	    if (replying && (headers[current-1]->pgp & PGP_MESSAGE) &&
! 		! (pgp_status & PGP_MESSAGE)) {
!               ClearLine(LINES-2);
! 	      PutLine0(LINES-2, 0, "The recv'd message was PGP encoded, are you sure? ");
! 	      for (;;) {
! 		cmd = ReadCh();
! 		if (cmd == 'y' || cmd == 'Y') {
! 		  Write_to_screen("Yes", 0);
! 		  return(0);
! 		}
! 		if (cmd == 'n' || cmd == 'N')
! 		  break;
! 	      }
! 	      break;
! 	    }
! #endif /* USE_PGP */
  	    return 0;
  	    /*NOTREACHED*/
  
!        case 'f': 
  	    if (did_prompt)
  		Write_to_screen("Forget", 0);
  	    if (bytes(filename) <= 0) {
  		; /* forget about empty files */
  	    } else if (mail_only) {
! #ifdef MIME
! 	      FILE * fd;
! 	      mime_send_t MIME_info;
! 	      
! 	      MIME_info.encoding_top  = ENCODING_7BIT;
! 	      if ((fd = fopen(filename,"r")) != NULL) {
! 		MIME_info.msg_is_multipart = 
! 		  check_for_multipart(fd,&MIME_info);
! 		MIME_info.need_enc = needs_encoding (fd);
! 		fclose(fd);
! 	      } else {
! 		MIME_info.msg_is_multipart = 0;
! 		MIME_info.need_enc = 0;
! 	      }
! 	      MIME_info.encoding_text =  ENCODING_7BIT;
! 	      MIME_info.Charset       =  charset;
! 	      
! 	      if (MIME_info.need_enc & HAVE_BINARY) 
! 		MIME_info.encoding_text =  ENCODING_BINARY;
! 	      else  if (MIME_info.need_enc & HAVE_8BIT) 
! 		MIME_info.encoding_text =  ENCODING_8BIT;
! 	      
! 	      update_encoding(&MIME_info.encoding_top,MIME_info.encoding_text);
! 	      
! 	      if (MIME_info.msg_is_multipart)
! 		(void) mime_generate_boundary (MIME_info.mime_boundary);
! 	      
! 	      sprintf(lbuf, "%s/%s", home, dead_letter);
! 	      (void) append_copy_to_file(to, cc, bcc, lbuf, filename,
! 					 *form_p, &MIME_info);
! #else
! 	      sprintf(lbuf, "%s/%s", home, dead_letter);
! 	      (void) append_copy_to_file(to, cc, bcc, lbuf, filename,
! 					 *form_p);
! #endif
  	    } else if (user_level > 0) {
  		set_error(catgets(elm_msg_cat, ElmSet, ElmVfyMessageKept,
  		    "Message kept.  Can be restored at next f)orward, m)ail or r)eply."));
  	    }
+ #ifdef USE_PGP
+             pgp_status = 0; /* make sure to reset! */
+ #endif
  	    return -1;
  	    /*NOTREACHED*/
  
***************
*** 981,987 ****
  	    }
  	    break;
  #endif
! 
  	default:
  	    bad_cmd = TRUE;
  	    break;
--- 1388,1408 ----
  	    }
  	    break;
  #endif
! #ifdef USE_PGP
!         case 'p':
! 	    if (!pgp_status) {
! 	      pgp_status = pgp_menu (filename);
! 	      *need_redraw_p = TRUE;
! 	    }
!             else
! 	      error ("This message is already encrypted and/or signed!");
!             break;
! #endif
! #ifdef USE_REMAILER
! 	case 'r':
! 		remailer_menu ();
! 		break;
! #endif
  	default:
  	    bad_cmd = TRUE;
  	    break;
***************
*** 992,1000 ****
  
  }
  
- 
  FILE *
  write_header_info(filename, long_to, long_cc, long_bcc, form, copy)
  char *filename, *long_to, *long_cc, *long_bcc;
  int   form, copy;
  {
--- 1413,1425 ----
  
  }
  
  FILE *
+ #ifdef MIME
+ write_header_info(filename, long_to, long_cc, long_bcc, form, copy, mime_info)
+ mime_send_t *mime_info;
+ #else
  write_header_info(filename, long_to, long_cc, long_bcc, form, copy)
+ #endif
  char *filename, *long_to, *long_cc, *long_bcc;
  int   form, copy;
  {
***************
*** 1184,1221 ****
  	fprintf(filedesc, "X-Mailer: ELM [version %s]\n", version_buff);
  #endif /* !NO_XHEADER */
  
! 	if (form)
  	  fprintf(filedesc, "Content-Type: mailform\n");
- #ifdef MIME
- 	else if (msg_is_multipart) {
- 	  fprintf(filedesc, "%s\n", MIME_HEADER);
- 	  fprintf(filedesc,
- 		"%s multipart/mixed; boundary=%s\n", MIME_CONTENTTYPE, MIME_BOUNDARY);
- 	}
- #endif /* MIME */
  	else {
! #ifdef	MIME
! 	  fprintf(filedesc, "%s\n", MIME_HEADER);
! 	  fprintf(filedesc, "%s text/plain; charset=%s\n",
! 		  MIME_CONTENTTYPE, charset);
! 	  fprintf(filedesc, "Content-Transfer-Encoding: %s\n",
! 		  (!strincmp ("us-ascii", charset)
! 		   && strincmp ("7bit", text_encoding))
! 		  ? "7bit" : text_encoding);
  #else
  	  fprintf(filedesc, "Content-Type: text\n");
  #endif /* MIME */
  	}
  	fprintf(filedesc, "Content-Length: ");
! 	C_L_Position[0] = ftell(filedesc);
! 	fprintf(filedesc, "          \n"); /* Print Blanks as Placeholders */
! 
! 	putc('\n', filedesc);
! 
  	return((FILE *) filedesc);
  }
  
  copy_message_across(source, dest, copy)
  FILE *source, *dest;
  int copy;
  {
--- 1609,1648 ----
  	fprintf(filedesc, "X-Mailer: ELM [version %s]\n", version_buff);
  #endif /* !NO_XHEADER */
  
! 	if (form) 
  	  fprintf(filedesc, "Content-Type: mailform\n");
  	else {
! #ifdef MIME
! #ifdef USE_REMAILER
! 	  if (!remailing)
! 	    /* Don't write the MIME header if we are remailing.  It will be
! 	     * taken care of by the remailing code.
! 	     */
! #endif
! 	    mime_write_header (filedesc, mime_info);
  #else
  	  fprintf(filedesc, "Content-Type: text\n");
  #endif /* MIME */
  	}
  	fprintf(filedesc, "Content-Length: ");
! 	cl_offset = ftell(filedesc);
! 	fprintf(filedesc, "          "); /* Print Blanks as Placeholders */
! #ifdef MIME
! 	print_EOLN(filedesc,mime_info->encoding_top);
! 	print_EOLN(filedesc,mime_info->encoding_top);
! #else
! 	fputc('\n',filedesc);
! 	fputc('\n',filedesc);
! #endif
  	return((FILE *) filedesc);
  }
  
+ #ifdef MIME
+ copy_message_across(source, dest, copy, mime_info)
+ mime_send_t *mime_info;
+ #else
  copy_message_across(source, dest, copy)
+ #endif
  FILE *source, *dest;
  int copy;
  {
***************
*** 1230,1243 ****
  #ifdef MIME
  	int	text_lines = 0;
  	int	at_boundary = FALSE;
- 
- 	C_L_Position[1] = 0L;
- 	C_StartData[1] = 0L;
- 	C_EndData[1] = 0L;
- 
  #endif /* MIME */
  
! 	while (line_len = mail_gets(buffer, SLEN, source)) {
  	  if (buffer[0] == '[') {
  	    if (strncmp(buffer, START_ENCODE, strlen(START_ENCODE))==0)
  	      crypted = TRUE;
--- 1657,1668 ----
  #ifdef MIME
  	int	text_lines = 0;
  	int	at_boundary = FALSE;
  #endif /* MIME */
  
! 	/* Reserve one byte for conversion LF -> CR LF in
! 	 * case of binary mime transmission:
! 	 */
! 	while (line_len = mail_gets(buffer, SLEN-1, source)) {
  	  if (buffer[0] == '[') {
  	    if (strncmp(buffer, START_ENCODE, strlen(START_ENCODE))==0)
  	      crypted = TRUE;
***************
*** 1251,1266 ****
  	    } else if (strncmp(buffer, MIME_INCLUDE, strlen(MIME_INCLUDE))==0) {
  	      text_lines = 0;
  	      if (!at_boundary) {
! 		if (C_L_Position[1] != 0L) {
! 		  C_EndData[1] = ftell(dest);
! 		  C_L_Position[1] = fseek(dest, C_L_Position[1], 0);
! 		  fprintf(dest, "%d", C_EndData[1] - C_StartData[1]);
! 		  fseek(dest, C_EndData[1], 0);
! 		}
! 		fprintf(dest, "\n--%s\n", MIME_BOUNDARY);
  	      }
! 	      Include_Part(dest, buffer, FALSE);
! 	      fprintf(dest, "--%s\n", MIME_BOUNDARY);
  	      at_boundary = TRUE;
  	      continue;
  #endif /* MIME */
--- 1676,1689 ----
  	    } else if (strncmp(buffer, MIME_INCLUDE, strlen(MIME_INCLUDE))==0) {
  	      text_lines = 0;
  	      if (!at_boundary) {
! 		print_EOLN(dest,mime_info->encoding_top);
! 		fprintf(dest, "--%s", mime_info->mime_boundary);
! 		print_EOLN(dest,mime_info->encoding_top);
  	      }
! 	      Include_Part(dest, buffer, FALSE, mime_info, copy);
! 	      print_EOLN(dest,mime_info->encoding_top);
! 	      fprintf(dest, "--%s", mime_info->mime_boundary);
! 	      print_EOLN(dest,mime_info->encoding_top);
  	      at_boundary = TRUE;
  	      continue;
  #endif /* MIME */
***************
*** 1293,1313 ****
  #ifdef MIME
  	  } else {
  	    if (text_lines == 0) {
! 	      if (msg_is_multipart) {
  		if (!at_boundary) {
! 	 	  fprintf(dest,"--%s\n",MIME_BOUNDARY);
  		}
! 	        fprintf(dest, "%s text/plain; charset=%s\n",
! 			MIME_CONTENTTYPE, charset);
! 		fprintf(dest, "Content-Transfer-Encoding: %s\n",
! 			(!strincmp ("us-ascii", charset)
! 			 && strincmp ("7bit", text_encoding))
! 			? "7bit" : text_encoding);
! 		fprintf(dest, "Content-Length: ");
! 		C_L_Position[1] = ftell(dest);
! 		fprintf(dest, "          \n"); /* Print Placeholders */
! 	        fprintf(dest, "\n");
! 		C_StartData[1] = ftell(dest);
  		at_boundary = FALSE;
  	      }
  	    }	
--- 1716,1741 ----
  #ifdef MIME
  	  } else {
  	    if (text_lines == 0) {
! 	      char tmp[STRING];
! 	      if (mime_info->msg_is_multipart) {
  		if (!at_boundary) {
! 		  print_EOLN(dest,mime_info->encoding_top);
! 	 	  fprintf(dest,"--%s",mime_info->mime_boundary);
! 		  print_EOLN(dest,mime_info->encoding_top);
  		}
! 
! 		tmp[0] = '\0';
! 		add_parameter(tmp,"charset",mime_info->Charset,sizeof(tmp),0);
! 	        fprintf(dest, "%s text/plain; %s",
! 			MIME_CONTENTTYPE, tmp);
! 		print_EOLN(dest,mime_info->encoding_top);
! 		if (mime_info->encoding_text != ENCODING_NONE) {
!  		  fprintf(dest, "%s %s", 
! 			  MIME_CONTENTENCOD,
! 			  ENCODING(mime_info->encoding_text));
! 		  print_EOLN(dest,mime_info->encoding_top);
! 		}
! 		print_EOLN(dest,mime_info->encoding_top);
  		at_boundary = FALSE;
  	      }
  	    }	
***************
*** 1315,1320 ****
--- 1743,1773 ----
  #endif /* MIME */
            }
  
+ #ifdef MIME
+ 	  if (mime_info->encoding_top == ENCODING_BINARY) {
+ 	    /* It is better perhaps use canonical eol (CRLF) when mail have
+ 	     * content transfer encoding BINARY somewhere (see notes about 
+ 	     * BINARYMIME)
+ 	     */
+ 
+ 	    if (buffer[line_len-1] == '\n') {
+ 	      int add = 1;
+ 	      if (line_len >1 && buffer[line_len-2] == '\r')
+ 		add = 0;
+ 	      if (add) {
+ 		buffer[line_len-1] = '\r';
+ 		buffer[line_len] = '\n';
+ 		line_len++;
+ 	      }	      
+ 	    }
+ 	  }
+ 
+ 	  /* Do QUOTED-PRINTABLE conversion if necessary... */
+ 	  if (mime_info->encoding_text == ENCODING_QUOTED)
+ 	    line_quoted_printable_encode(buffer,dest,copy,line_len,TRUE,
+ 					 mime_info);
+ 	  else
+ #endif
  #ifndef DONT_ESCAPE_MESSAGES
  	  if (copy && (strncmp(buffer, "From ", 5) == 0)) {
  	    /* Add in the > to a From on our copy */
***************
*** 1344,1349 ****
--- 1797,1813 ----
  		emergency_exit();
  	    }
  	} 
+ #ifdef MIME
+ 	if (mime_info->msg_is_multipart) {
+ 	  /* now add any attachments (NEW STYLE) */
+ 	  if (attachments)
+ 	    attach_generate_message (attachments, dest, copy, mime_info);
+ 
+ 	  print_EOLN(dest,mime_info->encoding_top);
+ 	  fprintf(dest,"--%s--", mime_info->mime_boundary);
+ 	  print_EOLN(dest,mime_info->encoding_top);
+ 	}
+ #endif /* MIME */
  #ifdef MMDF
  	if (copy) fputs(MSG_SEPARATOR, dest);
  #else
***************
*** 1444,1447 ****
  return FALSE;
  
  }
- 
--- 1908,1910 ----

diff -c /dev/null elm-2.4pl24me8/src/menu.c
*** /dev/null	Thu Sep 21 15:27:01 1995
--- elm-2.4pl24me8/src/menu.c	Wed Sep  6 11:59:20 1995
***************
*** 0 ****
--- 1,219 ----
+ /* $Id: menu.c,v 1.2 1995/06/23 21:45:10 elkins Exp $
+  *
+  * API for creating menus in Elm.
+  * Initially written by: Michael Elkins <elkins@aero.org>, 17 May 1995.
+  *
+  * PLEASE SEND ME ANY CHANGES YOU MAKE TO THIS API!
+  *
+  * The basic sequence of using this api is as follows:
+  *
+  *  menu_t menu;
+  *
+  *  MenuInit(&menu, "Test Menu", "Please Select an option: ", "q)uit");
+  *  for (...)
+  *    MenuAdd(&menu, "Menu item n");
+  *  for (;;) {
+  *    switch(MenuLoop(&menu)) {
+  *    case '\n':
+  *      selected_item = MenuCurrent(&menu);
+  *      MenuDestroy(&menu);
+  *      return(selected_item);
+  *    }
+  *  }
+  *
+  * $Log: menu.c,v $
+  * Revision 1.2  1995/06/23  21:45:10  elkins
+  * MenuLoop() should always display the prompt.
+  *
+  * Revision 1.1  1995/06/01  23:06:50  elkins
+  * Initial revision
+  *
+  *
+  */
+ 
+ #include "menu.h"
+ #include "headers.h"
+ 
+ /* creates a new menu instance.  'm' is a pointer to a 'menu_t', 't' is the
+    menu title, 'p' is the prompt string and 'h' is a help string. 'h' may
+    be specified as NULL if no help line is desired.  */
+ void
+ MenuInit (m, t, p, h)
+ menu_t *m;
+ char *t, *p, *h;
+ {
+   m->data = 0;
+   m->max = m->len = m->current = 0;
+   m->update = 1; /* so we can see something on the first MenuLoop() call! */
+   m->title = (char *) safe_malloc(sizeof(char) * (strlen(t) + 1));
+   strcpy(m->title, t);
+   m->prompt = (char *) safe_malloc(sizeof(char) * (strlen(p) + 1));
+   strcpy(m->prompt, p);
+   m->prompt_length = strlen(m->prompt);
+   if (h) {
+     m->help = (char *) safe_malloc(sizeof(char) * (strlen(h) + 1));
+     strcpy(m->help, h);
+   } else
+     m->help = 0;
+   m->pagetop = 0;
+ }
+ 
+ void
+ MenuDestroy (m)
+ menu_t *m;
+ {
+   if (m->title)
+     free(m->title);
+   if (m->prompt)
+     free(m->prompt);
+   DestroyDynamicArray(m->data);
+ }
+ 
+ int
+ MenuAdd (m, s)
+ menu_t *m;
+ char *s;
+ {
+   if (m->len == m->max)
+     m->data = (char **) DynamicArray(m->data, sizeof(char*),
+ 				     &m->max, LINES);
+   if (!m->data)
+     return(-1);
+   m->data[m->len] = (char *) safe_malloc(sizeof(char) * (strlen(s) + 1));
+   strcpy(m->data[m->len], s);
+   ++m->len;
+   return(0);
+ }
+ 
+ int
+ MenuPrintLine (s, voffset, isCurrent) 
+ char *s;
+ int voffset, isCurrent;
+ {
+   char *buf = (char*)safe_malloc(sizeof(char)*(COLUMNS+1));
+ 
+   if (!buf)
+     return(-1);
+ 
+   if (isCurrent && !arrow_cursor)
+     StartInverse();
+   sprintf(buf, "%s %-*.*s", isCurrent && arrow_cursor ? "->" : "  ",
+ 	  COLUMNS-4, COLUMNS-4, s);
+   PutLine0 (voffset, 0, buf);
+   if (isCurrent && !arrow_cursor)
+     EndInverse();
+   free(buf);
+   return(0);
+ }
+ 
+ /* the main loop for a menu.  it takes care of moving the selection and
+    returns the command that the user selected. */
+ int
+ MenuLoop (m)
+ menu_t *m;
+ {
+   int j, key_offset;
+   char cmd;
+ 
+   for (;;) {
+     if (m->update) {
+       ClearScreen();
+       Centerline(1, m->title);
+       for (j = 0; j < LINES-6 && m->pagetop + j < m->len; j++)
+ 	MenuPrintLine(m->data[m->pagetop+j], 3+j, m->pagetop+j == m->current);
+       if (m->help)
+ 	Centerline(LINES-1, m->help);
+       m->update = 0;
+     }
+     PutLine0(LINES-2, 0, m->prompt);
+ 
+     switch(cmd = ReadCh()) {
+     case ESCAPE:
+       if (cursor_control) {
+ 	key_offset = 1;
+ 	cmd = ReadCh();
+ 	if (cmd == '[' || cmd == 'O') {
+ 	  cmd = ReadCh();
+ 	  key_offset++;
+ 	}
+ 	if (cmd == up[key_offset])
+ 	  goto previous_entry;
+ 	else if (cmd == down[key_offset])
+ 	  goto next_entry;
+ 	else if (cmd == right[key_offset]) {
+ 	  if (m->pagetop + LINES-6 < m->len) {
+ 	    m->pagetop += LINES-6;
+ 	    m->current = m->pagetop;
+ 	    m->update = 1;
+ 	  } else
+ 	    Centerline(LINES, "You are already on the last page!");
+ 	}
+ 	else if (cmd == left[key_offset]) {
+ 	  if (m->pagetop != 0) {
+ 	    m->pagetop -= LINES-6;
+ 	    if (m->pagetop < 0)
+ 	      m->pagetop = 0;
+ 	    m->current = m->pagetop;
+ 	    m->update = 1;
+ 	  } else
+ 	    Centerline(LINES, "You are on the first page!");
+ 	}
+       }
+       break;
+     case ctrl('L'):
+       m->update = 1;
+       break;
+     case '=': /* first item */
+       m->current = 0;
+       m->pagetop = 0;
+       m->update = 1;
+       break;
+     case '*': /* last item */
+       m->current = m->len - 1;
+       m->pagetop = m->len - LINES + 6;
+       if (m->pagetop < 0)
+ 	m->pagetop = 0;
+       m->update = 1;
+       break;
+     case 'k':
+     case 'K':
+     case ctrl('P'):
+ previous_entry:
+       if (m->current > 0) {
+ 	if (m->current != m->pagetop) {
+ 	  MenuPrintLine(m->data[m->current], 3 + m->current - m->pagetop, 0);
+ 	  --m->current;
+ 	  MenuPrintLine(m->data[m->current], 3 + m->current - m->pagetop, 1);
+ 	} else { /* move to the previous page */
+ 	  --m->current;
+ 	  m->pagetop -= LINES-6;
+ 	  if (m->pagetop < 0)
+ 	    m->pagetop = 0;
+ 	  m->update = 1;
+ 	}
+       }
+       break;
+     case 'j':
+     case 'J':
+     case ctrl('N'):
+     case 'n':
+ next_entry:
+       if (m->current < m->len-1) {
+ 	if (m->current < m->pagetop + LINES-7) {
+ 	  MenuPrintLine(m->data[m->current], 3 + m->current -  m->pagetop, 0);
+ 	  ++m->current;
+ 	  MenuPrintLine(m->data[m->current], 3 + m->current - m->pagetop, 1);
+ 	} else { /* move to the next page */
+ 	  ++m->current;
+ 	  m->pagetop = m->current;
+ 	  m->update = 1;
+ 	}
+       } else
+ 	Centerline(LINES, "You are on the last item!");
+       break;
+     default:
+       return(cmd);
+     }
+   }
+   /* not reached */
+ }

diff -c /dev/null elm-2.4pl24me8/src/menu2.c
*** /dev/null	Thu Sep 21 15:27:01 1995
--- elm-2.4pl24me8/src/menu2.c	Sun Aug 27 19:10:02 1995
***************
*** 0 ****
--- 1,104 ----
+ /* $Id: menu2.c,v 1.1 1995/08/28 02:08:24 elkins Exp $
+  *
+  * This code originally written by Michael Elkins <elkins@aero.org>.
+  *
+  * $Log: menu2.c,v $
+  * Revision 1.1  1995/08/28 02:08:24  elkins
+  * Initial revision
+  *
+  */
+ 
+ #include "headers.h"
+ #include "menu2.h"
+ 
+ #define BOL 1
+ #define STR 2
+ #define INT 3
+ 
+ void
+ do_item (it)
+      struct menu_item *it;
+ {
+   short len;
+   char ch, buf[STRING];
+ 
+   ClearLine (LINES-2);
+   Write_to_screen (it->option, 0);
+   len = strlen (it->option) + 1;
+   if (it->type == STR)
+     optionally_enter (it->d.c, LINES-2, len, TRUE, FALSE);
+   else if (it->type == BOL) {
+     for (;;) {
+       MoveCursor (LINES-2, len);
+       CleartoEOLN ();
+       if (*it->d.i == TRUE)
+ 	Write_to_screen ("TRUE", 0);
+       else if (*it->d.i == FALSE)
+ 	Write_to_screen ("FALSE", 0);
+       ch = ReadCh ();
+       if (ch == '\n')
+ 	return;
+       else if (ch == ' ')
+ 	*it->d.i = *it->d.i ? FALSE : TRUE;
+     }
+   }
+   else if (it->type == INT) {
+     sprintf (buf, "%d", *it->d.i);
+     optionally_enter (buf, LINES-2, len, TRUE, FALSE);
+     *it->d.i = atoi (buf);
+   }
+   return;
+ }
+ 
+ void
+ generic_menu (items, max, title, prompt)
+      struct menu_item items[];
+      short max;
+      char *prompt, *title;
+ {
+   short i = 0;
+   char buf[STRING], buf2[STRING];
+   char ch;
+   short update = TRUE;
+ 
+   ClearScreen ();
+   for (;;) {
+     if (update) {
+       Centerline (1, title);
+       for (i = 0 ; i < max ; i++) {
+ 	sprintf (buf, "%-30.30s", items[i].option);
+ 	if (items[i].type == BOL) {
+ 	  if (*items[i].d.i == TRUE)
+ 	    strcat (buf, "TRUE");
+ 	  else
+ 	    strcat (buf, "FALSE");
+ 	}
+ 	else if (items[i].type == STR)
+ 	  strcat (buf, items[i].d.c);
+ 	else if (items[i].type == INT) {
+ 	  sprintf (buf2, "%d", *items[i].d.i);
+ 	  strcat (buf, buf2);
+ 	}
+ 	ClearLine(items[i].offset);
+ 	PutLine0 (items[i].offset, 0, buf);
+       }
+       update = FALSE;
+     }
+     ClearLine (LINES-2);
+     PutLine0 (LINES-2, 0, prompt);
+     ch = ReadCh ();
+     switch (ch) {
+     case '\n':
+       return;
+     default:
+       for (i = 0; i < max ; i++) {
+ 	if (ch == items[i].key) {
+ 	  do_item (items[i]);
+ 	  update = TRUE;
+ 	  break;
+ 	}
+       }
+     }
+   }
+   /* Not reached. */
+ }

diff -c /dev/null elm-2.4pl24me8/src/metapager.c
*** /dev/null	Thu Sep 21 15:27:01 1995
--- elm-2.4pl24me8/src/metapager.c	Thu Sep 21 14:25:59 1995
***************
*** 0 ****
--- 1,455 ----
+ #include <errno.h>
+ #include "headers.h"
+ #include "s_elm.h"
+ #include "me.h"
+ 
+ #ifdef MIME
+ extern int errno;
+ #endif /* MIME */
+ 
+ void
+ PressAnyKeyToContinue()
+ {
+   Raw(ON | NO_TITE);
+   PutLine0(LINES, 0, "Press any key to continue...");
+   ReadCh();
+   Raw(OFF | NO_TITE);
+   printf("\n\r");
+ }
+ 
+ metapager (fp, hdr, do_headers)
+      FILE *fp;
+      struct header_rec *hdr;
+      int do_headers;
+ {
+ 
+   int p[2], builtin = 0, matched = 0, status, len, line_len;
+   long start_offset = hdr->offset, end_offset;
+   char ch, buf[VERY_LONG_STRING];
+   FILE *fpout = NULL;
+   int wait_ret;                         /* wait return value */
+   int fork_ret;				/* fork return value */
+   int err;				/* place holder for errno */
+   char **text = 0;
+   int text_idx = 0, text_len = 0;
+   char tempfile[STRING];
+ #ifdef MIME
+   int istext;
+ #endif
+ #ifdef USE_PGP
+   int pgp = 0;
+   FILE *fpin, *tfpout;
+ 
+   /* must ask about key up here since the external pager could be forked
+      off and steal stdin */
+ 
+   if (hdr->pgp & (PGP_MESSAGE|PGP_SIGNED_MESSAGE)) {
+     if ((hdr->pgp & PGP_MESSAGE) && pgp_keeppass)
+       if (! pgp_goodPassphrase())
+         return (0);
+ #ifdef MIME
+     if (hdr->mime_rec.type == MIME_TYPE_APPLICATION &&
+ 	(istrcmp(hdr->mime_rec.subtype, "pgp") == 0))
+ #endif /* MIME */
+     {
+       if (hdr->pgp & PGP_MESSAGE)
+         error("Decrypting message...");
+       else
+         error("Checking signature...");
+       pgp = hdr->pgp; /* handle PGP at the top level */
+     }
+   }
+ #endif
+ 
+   /* check to see if we want the internal pager */
+   if ((strncmp(pager, "builtin", 7) == 0 && (pager[7]=='\0' || pager[7]=='+'))
+     || (strncmp(pager, "internal", 8) == 0 && (pager[8]=='\0' || pager[8]=='+'))
+     || (builtin_lines < 0 ? hdr->lines < LINES + builtin_lines :
+ 	    hdr->lines < builtin_lines)) {
+ 
+     builtin++;
+ 
+ #ifdef MIME
+ # ifdef USE_PGP
+     if ((pgp & (PGP_MESSAGE | PGP_SIGNED_MESSAGE)) ||
+ 	mime_needs_processing (&hdr->mime_rec))
+ # else
+     if (mime_needs_processing (&hdr->mime_rec))
+ # endif
+ #else
+ # ifdef USE_PGP
+     if (pgp & (PGP_MESSAGE | PGP_SIGNED_MESSAGE))
+ # endif
+ #endif
+       
+ #if defined (MIME) || defined (USE_PGP)
+     {
+       sprintf (tempfile, "%s/elm.%d", temp_dir, getpid());
+       fpout = fopen (tempfile, "w");
+       (void) elm_chown (tempfile, userid, groupid);
+       chmod (tempfile, 0600);
+       dprint (1, (debugfile, "metapager(): [experimental] using tempfile %s\n", tempfile));
+     }
+     else {
+       dprint (1, (debugfile, "metapager(): [experimental] look ma!  no tempfile!\n"));
+ #endif
+       builtin++;
+ #if defined (MIME) || defined (USE_PGP)
+     }
+ #endif
+   }
+   else {
+     /* put terminal out of raw mode so external pager has normal env */
+     Raw (OFF);
+ 
+     /* create pipe for external pager and fork */
+ 
+     if (pipe (p) == -1) {
+       err = errno;
+       dprint(1, (debugfile, "Error: pipe failed, errno %s (metapager)\n",
+         error_description(err)));
+       error1(catgets(elm_msg_cat, ElmSet, ElmPreparePagerPipe,
+         "Could not prepare for external pager(pipe()-%s)."),
+         error_description(err));	
+       PressAnyKeyToContinue();
+       Raw (ON);
+       return (0);
+     }
+ 
+     if ((fork_ret = fork()) == -1) {
+       err = errno;
+       close (p[0]);
+       close (p[1]);
+       dprint(1, (debugfile, "Error: fork failed, errno %s (metapager)\n",
+         error_description(err)));
+       error1(catgets(elm_msg_cat, ElmSet, ElmPreparePagerFork,
+         "Could not prepare for external pager(fork()-%s)."),
+         error_description(err));	
+       PressAnyKeyToContinue();
+       Raw (ON);
+       return (0);
+     } else if (fork_ret == 0) {
+       /* child fork */
+ 
+       /* close write-only pipe fd and fit read-only pipe fd to stdin */
+ 
+       close (p[1]);
+       close (0);
+       if (dup (p[0]) == -1) {
+ 	err = errno;
+ 	dprint(1, (debugfile, "Error: dup failed, errno %s (metapager)\n",
+ 	  error_description(err)));
+ 	error1(catgets(elm_msg_cat, ElmSet, ElmPreparePagerDup,
+ 	  "Could not prepare for external pager(dup()-%s)."),
+ 	  error_description(err));	
+ 	_exit(err);
+       }
+ 
+       /* now execute pager and exit */
+ 	    
+       /* system_call() will return user to user's normal permissions.
+        * This is what makes this pipe secure - user won't have elm's
+        * special setgid permissions (if so configured) and will only
+        * be able to execute a pager that user normally has permission
+        * to execute */
+ 
+       _exit(system_call(pager, SY_ENAB_SIGINT));
+     }
+ 
+     close (p[0]);
+     fpout = fdopen (p[1], "w");
+     if (fpout == NULL) {
+       err = errno;
+       close (p[1]);
+       dprint(1, (debugfile, "Error: parent fdopen failed, errno %s (metapager)\n",
+         error_description(err)));
+       error1(catgets(elm_msg_cat, ElmSet, ElmPreparePagerParentFdopen,
+         "Could not prepare for external pager(parent fdopen()-%s)."),
+         error_description(err));	
+       PressAnyKeyToContinue();
+       Raw (ON);
+       return (0);
+     }
+ 
+     ClearScreen();
+   }
+ 
+   if (fseek (fp, hdr->offset, 0) == -1) {
+     err = errno;
+     dprint(1, (debugfile,
+ 	  "Error: seek %d bytes into file, errno %s (show_message)\n",
+ 	  hdr->offset, error_description(err)));
+     error2(catgets(elm_msg_cat, ElmSet, ElmSeekFailedFile,
+ 	  "ELM [seek] couldn't read %d bytes into file (%s)."),
+ 	  hdr->offset, error_description(err));	
+     return (0);
+   }
+       
+   /* this is only true if metapager() is not called from ViewAttachment() */
+   if (do_headers) {
+     if (title_messages) {
+       char buf2[STRING], buf3[STRING];
+ 
+       /* first print a title line */
+ 
+       elm_date_str(buf2, hdr->time_sent + hdr->tz_offset);
+       strcat(buf2, " ");
+       strcat(buf2, hdr->time_zone);
+       sprintf(buf, "%s %d/%d ",
+ 	      hdr->status & DELETED ? "[Deleted]" : "Message",
+ 	      current,
+ 	      message_count);
+       len = COLUMNS - 2 - strlen(buf) - strlen(buf2),
+       sprintf(buf3, "%s%-*.*s %s",
+ 	      buf,
+ 	      len,
+ 	      len,
+ 	      hdr->from,
+ 	      buf2);
+       
+       if (builtin > 1) {
+ 	if (text_idx == text_len)
+ 	  text = (char **) DynamicArray (text, sizeof (char *), &text_len, 5);
+ 	text[text_idx] = strmcpy (text[text_idx], buf3);
+ 	text_idx++;
+       }
+       else {
+ 	fputs (buf3, fpout);
+ 	fputs ("\n", fpout);
+       }
+ 
+       /** Print the subject line centered if there is enough room **/
+       if ((len = strlen(hdr->subject)) > 0 && matches_weedlist("subject")) {
+         len = (COLUMNS-len)/2;
+         if (len < 0)
+           len = 0;
+         sprintf(buf,"%*.*s%s",len,len,"",hdr->subject);
+         if (builtin > 1)
+           text[text_idx++] = strmcpy(text[text_idx], buf);
+         else
+           fprintf(fpout, "%s\n", buf);
+       }
+       else {
+         if (builtin > 1) {
+           text[text_idx] = (char *) safe_malloc(1);
+           *text[text_idx++] = '\0';
+         }
+         else
+           fputc('\n', fpout);
+       }
+       
+       /* now some information about this message */
+       
+       buf[0]='\0';
+ #ifdef USE_PGP
+       if (pgp & PGP_MESSAGE)
+ 	strcpy(buf, "(** This message is PGP encrypted");
+       else if (pgp & PGP_SIGNED_MESSAGE)
+ 	strcpy(buf, "(** This message is PGP signed");
+ #endif
+       if (hdr->status & EXPIRED) {
+ 	if (buf[0] == '\0')
+ 	  strcpy(buf, "(** This message has EXPIRED");
+ 	else
+ 	  strcat(buf, ", and has EXPIRED");
+       }
+       if (hdr->status & CONFIDENTIAL) {
+ 	if (buf[0] == '\0')
+ 	  strcpy(buf, "(** This message is tagged CONFIDENTIAL");
+ 	else
+ 	  strcat(buf, ", and is tagged CONFIDENTIAL");
+       }      
+       if (hdr->status & URGENT) {
+ 	if (buf[0] == '\0')
+ 	  strcpy(buf, "(** This message is tagged URGENT");
+ 	else if (hdr->status & CONFIDENTIAL)
+ 	  strcat(buf, ", and URGENT");
+ 	else
+ 	  strcat(buf, ", and is tagged URGENT");
+       }
+       
+       if (buf[0] != '\0') {
+ 	strcat(buf, " **)");
+ 	if (builtin > 1) {
+ 	  text[text_idx] = strmcpy (text[text_idx], buf);
+ 	  text_idx++;
+ 	  text[text_idx] = (char *) safe_malloc (1);
+ 	  *text[text_idx] = '\0';
+ 	  text_idx++;
+ 	}
+ 	else	  {
+ 	  fputs (buf, fpout);
+ 	  fputs ("\n\n", fpout);
+ 	}
+       }
+     }
+ 
+ #ifdef MIME
+     istext = is_text_type(TYPE(hdr->mime_rec.type),hdr->mime_rec.subtype,
+ 			  hdr->mime_rec.encoding);
+ #endif /* MIME */
+ 
+     /** Now do the headers. **/
+     
+     while (0 < (line_len = mail_gets (buf, VERY_LONG_STRING, fp))) {
+       int is_end = 0;
+ #ifdef MMDF
+       if (strcmp (buf, MSG_SEPARATOR) == 0)
+         continue;
+ #endif
+       if (filter) {
+ 	if (matches_weedlist (buf) || (whitespace (buf[0]) && matched)) {
+ 	  matched = 1;
+ 	  continue;
+ 	}
+ 	else
+ 	  matched = 0;
+       }
+       
+       if (buf[0] == '\n') is_end = 1;
+       else if (buf[0] == '\r' && buf[1] == '\n') is_end = 1;
+ 
+       if (builtin > 1) {
+ 	if (buf[line_len-1] == '\n') {
+ 	  buf[line_len-1] = '\0';
+ 	  if (line_len > 1 && buf[line_len-2] == '\r') 
+ 	    buf[line_len-2] = '\0';
+ 	}
+ 
+ 	if (text_idx >= text_len - 1)
+ 	  text = (char **) DynamicArray (text, sizeof (char *), &text_len, 5);
+ 	text[text_idx] = strmcpy (text[text_idx], buf);
+ 	text_idx++;
+       }
+       else 
+ 	fputs (buf, fpout);
+       
+       if (is_end) {
+ #ifndef MIME
+ 	start_offset = ftell(fp);
+ #endif
+ 	break;
+       }
+     }
+   }
+ 
+ #ifdef MIME
+   start_offset = hdr->mime_rec.offset;
+ #endif
+   
+   /* finally the body */
+ 
+   if (builtin > 1) {
+ #ifdef MIME
+     if (hdr->status & MIME_MESSAGE)
+       mime_warnings(hdr);
+ #endif
+ 
+     /* No special processing needs to take place, so just start the pager! */
+     
+     ch = builtinplusplus (fp, start_offset, hdr->content_length, text, text_idx);
+     DestroyDynamicArray (text);
+     return ch;
+   }
+ 
+   end_offset = ftell(fp) + hdr->content_length;
+ 
+ #ifdef USE_PGP
+   if (pgp & (PGP_MESSAGE | PGP_SIGNED_MESSAGE)) {
+     if (pgp_decrypt_init(&fpin, &tfpout, pgp & (PGP_MESSAGE | PGP_SIGNED_MESSAGE)) == -1) {
+        Raw(ON);
+        return(0);
+     }
+     pgp=TRUE;
+   }
+ #endif
+ 
+ #ifdef MIME
+   if ((hdr->status & MIME_MESSAGE)
+ #ifdef USE_PGP    
+ 	   && !pgp
+ #endif
+       ) {
+     state_t state;
+ 
+     state.fpin = fp;
+     state.fpout =  fpout;
+     state.displaying = TRUE;
+     state.prefix = NULL;
+ 
+     attach_parse(hdr, fp);
+     mime_decode(&hdr->mime_rec, &state);
+   }
+   else {
+ #endif /* MIME */
+ #ifdef USE_PGP
+     if (pgp) {
+       /* for a PGP message, just pipe everything to the child process */
+       
+       while (ftell(fp) < end_offset) {
+ 	if (fgets (buf, VERY_LONG_STRING, fp) == NULL)
+ 	  break;
+ 	
+ 	fputs(buf, tfpout);
+ 	fflush (tfpout);
+ 	
+       }
+       fclose (tfpout);
+       while (fgets(buf,VERY_LONG_STRING,fpin)!=NULL)
+ 	fputs(buf,fpout);
+       fclose(fpin);
+       PressAnyKeyToContinue();
+       if (builtin)
+ 	Raw(ON);
+     }
+     else
+ #endif
+       while (ftell(fp) < end_offset) {
+ 	if (fgets (buf, VERY_LONG_STRING, fp) == NULL)
+ 	  break;
+ 	fputs(buf, fpout);
+       }
+ #ifdef MIME
+   }
+ #endif
+ 
+   /** Now run the pager! **/
+ 
+   if (builtin) {
+     /* This is a trick.  I unlink the temp file while it is still open so the
+      * file disappears, but we can still access the data so long as the stream
+      * is still open.
+      */
+     fpout = freopen (tempfile, "r", fpout);
+     unlink (tempfile);
+     fseek (fpout, (long)0, 2);
+     ch = builtinplusplus (fpout, (long) 0, ftell (fpout), NULL, 0);
+     fclose (fpout);
+     return (ch);
+   }
+ 
+   /** The rest of the code is for an external pager. **/
+ 
+   fclose (fpout);
+ 
+   while ((wait_ret = wait (&status)) != fork_ret && wait_ret != -1)
+     ;
+   /* turn raw on **after** child terminates in case child
+    * doesn't put us back to cooked mode after we return ourselves to
+    * raw.
+    */
+   Raw(ON);
+ 
+   if (prompt_after_pager) {
+     StartBold ();
+     PutLine0 (LINES, 0, catgets(elm_msg_cat, ElmSet, ElmCommandIToReturn,
+ 				" Command ('i' to return to index): "));
+     EndBold ();
+     fflush (stdout);
+     ch = ReadCh();
+   }
+   else
+     ch = 0;
+ 
+   return (ch == 'i' || ch == 'q' ? 0 : ch);
+ }

diff -c elm-2.4pl24/src/mime.c elm-2.4pl24me8/src/mime.c
*** elm-2.4pl24/src/mime.c	Sun Aug 22 19:55:06 1993
--- elm-2.4pl24me8/src/mime.c	Wed Sep 20 14:48:27 1995
***************
*** 125,132 ****
  #include <errno.h>
  #include <sys/stat.h>
  
! int check_for_multipart(filedesc)
! FILE *filedesc;
  {
    char buffer[SLEN];
    int Multi_Part = FALSE;
--- 125,146 ----
  #include <errno.h>
  #include <sys/stat.h>
  
! /* Notice that ENCODING_ILLEGAL is -1 
!  */
! 
! char *mime_encode_names[] = {
!   "none", /* Not used. */
!   "7bit",
!   "8bit",
!   "binary",
!   "quoted-printable",
!   "base64",
!   "X-???"         /* ENCODING_EXPERIMENTAL */
! };
! 
! int check_for_multipart(filedesc, mime_info)
!      FILE *filedesc;
!      mime_send_t *mime_info;
  {
    char buffer[SLEN];
    int Multi_Part = FALSE;
***************
*** 139,145 ****
      if (buffer[0] == '[') {
        if (strncmp(buffer, MIME_INCLUDE, strlen(MIME_INCLUDE)) == 0) {
        	Multi_Part = TRUE;
! 	if (Include_Part((FILE *)NULL, buffer, TRUE) == -1) {
  	   return(-1);
  	}
        }
--- 153,159 ----
      if (buffer[0] == '[') {
        if (strncmp(buffer, MIME_INCLUDE, strlen(MIME_INCLUDE)) == 0) {
        	Multi_Part = TRUE;
! 	if (Include_Part((FILE *)NULL, buffer, TRUE, mime_info, FALSE) == -1) {
  	   return(-1);
  	}
        }
***************
*** 148,157 ****
    return(Multi_Part);
  }
  
! Include_Part(dest, buffer, check)
! FILE *dest;
! char *buffer;
! int	check;
  {
    char *ptr;
    char *incptr;
--- 162,174 ----
    return(Multi_Part);
  }
  
! int
! Include_Part(dest, buffer, check, mime_info, copy)
!      FILE *dest;
!      char *buffer;
!      int  check;
!      mime_send_t *mime_info;
!      int copy;
  {
    char *ptr;
    char *incptr;
***************
*** 159,192 ****
    char Expanded_Filename[SLEN];
    char tmp_fn[SLEN];
    char *filename;
!   char Content_Type[SLEN];
    char Encoding[SLEN];
    char sh_buffer[SLEN];
    char Encode_Flag[3];
    int  Enc_Type;
    FILE *incfile;
-   struct stat	file_status;
    int  line_len;
  
    ptr = buffer + strlen(MIME_INCLUDE);
    while ((*ptr != '\0') && (*ptr == ' '))
      ptr++;
    incptr = Include_Filename;
!   while ((*ptr != ' ') && (*ptr != ']') && (*ptr != '\0'))
      *incptr++ = *ptr++;
    *incptr = '\0';
  
    while ((*ptr != '\0') && (*ptr == ' '))
      ptr++;
!   incptr = Content_Type;
!   while ((*ptr != ' ') && (*ptr != ']') && (*ptr != '\0'))
      *incptr++ = *ptr++;
    *incptr = '\0';
  
    while ((*ptr != '\0') && (*ptr == ' '))
      ptr++;
    incptr = Encoding;
!   while ((*ptr != ' ') && (*ptr != ']') && (*ptr != '\0'))
      *incptr++ = *ptr++;
    *incptr = '\0';
  
--- 176,248 ----
    char Expanded_Filename[SLEN];
    char tmp_fn[SLEN];
    char *filename;
!   char Primary_Type[SLEN];
!   char SubType[SLEN];
!   char Params[STRING];
    char Encoding[SLEN];
    char sh_buffer[SLEN];
    char Encode_Flag[3];
    int  Enc_Type;
    FILE *incfile;
    int  line_len;
+   int is_text;
  
    ptr = buffer + strlen(MIME_INCLUDE);
    while ((*ptr != '\0') && (*ptr == ' '))
      ptr++;
    incptr = Include_Filename;
!   while ((*ptr != ' ') && (*ptr != ']') && (*ptr != '\0') &&
! 	 (incptr < Include_Filename + sizeof(Include_Filename) -1))
      *incptr++ = *ptr++;
    *incptr = '\0';
  
    while ((*ptr != '\0') && (*ptr == ' '))
      ptr++;
!   incptr = Primary_Type;
!   while ((*ptr != ' ') && (*ptr != ']') && (*ptr != '\0') && (*ptr!='/')
! 	 && (*ptr != ';') 
! 	 && (incptr < Primary_Type + sizeof(Primary_Type) -1))
      *incptr++ = *ptr++;
    *incptr = '\0';
+   while ((*ptr != '\0') && (*ptr == ' '))
+     ptr++;
+   incptr = SubType;
+   if (*ptr == '/') {
+     ptr++;
+     while ((*ptr != '\0') && (*ptr == ' '))
+       ptr++;
+     while ((*ptr != ' ') && (*ptr != ']') && (*ptr != '\0') && (*ptr!=';')
+ 	   && (incptr < SubType + sizeof(SubType) -1))
+       *incptr++ = *ptr++;
+   }
+   *incptr = '\0';
+   while ((*ptr != '\0') && (*ptr == ' '))
+     ptr++;
+   incptr = Params;
+   while (*ptr == ';') {
+     ptr++;
+     if (incptr > Params) {
+       *incptr++ = ';';
+     } else if (*ptr == ' ')
+       ptr++;
  
+     while ((*ptr != '\0') && (*ptr == ' ')
+ 	   && (incptr < Params + sizeof(Params) -1))
+       *incptr++ = *ptr++;
+ 
+     while ((*ptr != ' ') && (*ptr != ']') && (*ptr != '\0') && (*ptr!=';')
+ 	   && (incptr < Params + sizeof(Params) -1))
+       *incptr++ = *ptr++;
+     while ((*ptr != '\0') && (*ptr == ' '))
+       ptr++;
+   }
+   *incptr = '\0';
+ 
    while ((*ptr != '\0') && (*ptr == ' '))
      ptr++;
    incptr = Encoding;
!   while ((*ptr != ' ') && (*ptr != ']') && (*ptr != '\0')
! 	 && (incptr < Encoding + sizeof(Encoding) -1))
      *incptr++ = *ptr++;
    *incptr = '\0';
  
***************
*** 199,205 ****
    }
    (void) expand_env(Expanded_Filename, Include_Filename, sizeof(Expanded_Filename));
  
!   if (strlen(Content_Type) == 0) {
      Write_to_screen(catgets(elm_msg_cat, ElmSet, ElmNoContentTypeGiven,
                      "\n\rNo Content-type given, include line ignored\n\r"), 0);
      if (sleepmsg > 0)
--- 255,261 ----
    }
    (void) expand_env(Expanded_Filename, Include_Filename, sizeof(Expanded_Filename));
  
!   if (strlen(Primary_Type) == 0 || strlen(SubType) == 0 ) {
      Write_to_screen(catgets(elm_msg_cat, ElmSet, ElmNoContentTypeGiven,
                      "\n\rNo Content-type given, include line ignored\n\r"), 0);
      if (sleepmsg > 0)
***************
*** 224,289 ****
  		sleep(sleepmsg);
  	return(-1);
    }
!   if (check) {
! 	return(0);
    }
!   if (Enc_Type == ENCODING_7BIT || Enc_Type == ENCODING_8BIT ||
! 	Enc_Type == ENCODING_BINARY || Enc_Type == ENCODING_NONE ||
! 	Enc_Type == ENCODING_EXPERIMENTAL) {
!     /* No explicit encoding, assume 7-BIT */
!     filename = Expanded_Filename;
!   } else {
!     sprintf(tmp_fn, "%semm.%d.%d", temp_dir, getpid(), getuid());
!     filename = tmp_fn;
!     if (Enc_Type == ENCODING_BASE64) {
!       strcpy(Encode_Flag, "-b");
!     } else if (Enc_Type == ENCODING_QUOTED) {
!       strcpy(Encode_Flag, "-q");
!     } else {
!       Write_to_screen(catgets(elm_msg_cat, ElmSet, ElmUnknownEncodingInInclude,
! 		      "\n\rUnknown Encoding, include line ignored\n\r"), 0);
        if (sleepmsg > 0)
! 	    sleep(sleepmsg);
!       return(-1);
      }
!     sprintf(sh_buffer, "mmencode %s %s >%s", Encode_Flag, Expanded_Filename,
! 			tmp_fn);
!     (void) system_call(sh_buffer, 0);
    }
!   if ((incfile = fopen(filename, "r")) != NULL) {
!     if (stat(filename, &file_status) != 0) {
!         Write_to_screen(catgets(elm_msg_cat, ElmSet, ElmCantStatIncludedFile,
! 			"\n\rCan't stat included File,ignored\n\r"), 0);
! 	if (sleepmsg > 0)
! 		sleep(sleepmsg);
! 	return(-1);
      }
!     fprintf(dest, "%s %s\n", MIME_CONTENTTYPE, Content_Type);
!     fprintf(dest, "Content-Name: %s\n", Include_Filename);
!     fprintf(dest, "Content-Length: %d\n", file_status.st_size);
!     if (Enc_Type != ENCODING_NONE) {
! 	fprintf(dest, "Content-Transfer-Encoding: %s\n", Encoding);
      }
-     fprintf(dest, "\n");
-     while (line_len = fread(buffer, 1, sizeof(buffer), incfile)) {
-       if (fwrite(buffer, 1, line_len, dest) != line_len) {
- 	MoveCursor(LINES, 0);
- 	Raw(OFF);
-         Write_to_screen(catgets(elm_msg_cat, ElmSet, ElmWriteFailedCopyAcross,
- 	        "\nWrite failed in copy_message_across\n"), 0);
-         emergency_exit();
-       }
-     } 
  
! /*  write CRLF after body-part */
  
!     fprintf(dest, "\n");
  
!     fclose(incfile);
!     if (filename == tmp_fn) {
! 	unlink(tmp_fn);
      }
!   } else {
      MoveCursor(LINES, 0);
      Raw(OFF);
      Write_to_screen(catgets(elm_msg_cat, ElmSet, ElmCantOpenIncludedFile,
--- 280,430 ----
  		sleep(sleepmsg);
  	return(-1);
    }
! 
!   /* Don't allow 7BIT if 8-bit charcters in any type,    
!    * don't allow 8BIT if 'binary' characters       - K E H */
!   if (Enc_Type == ENCODING_7BIT || Enc_Type == ENCODING_NONE
!       || Enc_Type == ENCODING_8BIT) {
!     
!     FILE * fp = fopen (Expanded_Filename, "r");
!     if (fp) {
!       int tmp = needs_encoding (fp);
!       if (tmp & HAVE_BINARY) {
! 
! 	error ("Include file has BINARY data.");
! 	
!         if (sleepmsg > 0)
! 	  sleep(sleepmsg);
! 	
! 	if (Enc_Type == ENCODING_7BIT || Enc_Type == ENCODING_8BIT) {
! 	  if (check)
! 	    return -1; /* indicate failure */
! 	}
! 	
! 	Enc_Type = ENCODING_BINARY;
! 
!       } else if ((tmp & HAVE_8BIT) && Enc_Type != ENCODING_8BIT) {
! 	
! 	error ("Include file has 8BIT data.");
! 	
!         if (sleepmsg > 0)
! 	  sleep(sleepmsg);
! 	
! 	if (Enc_Type == ENCODING_7BIT) {
! 	  if (check)
! 	    return -1; /* indicate failure */
! 	}
! 	
! 	Enc_Type = ENCODING_8BIT;
! 	
!       }
!       fclose(fp);
!     }
    }
! 
!   if (Enc_Type == ENCODING_8BIT) {
! #ifndef USE_8BITMIME
!     if (allow_no_encoding < 1) {
!       Enc_Type = ENCODING_QUOTED;
!       error ("Mailer (MTA) doesn't support 8BIT encoding.");
        if (sleepmsg > 0)
! 	sleep(sleepmsg);
!       
!       if (check)
! 	return -1; /* indicate failure */
      }
! #endif
    }
! 
!   if (Enc_Type == ENCODING_BINARY) {
! #ifndef USE_BINARYMIME
!     if (allow_no_encoding < 2) {
!       /* Convert to QUOTED-PRINTABLE */
!       Enc_Type = ENCODING_QUOTED;
!       error ("Mailer (MTA) doesn't support BINARY encoding!");
!       if (sleepmsg > 0)
! 	sleep (sleepmsg);
!       if (check)
! 	return (-1);
      }
! #endif
!   }
! 
!   is_text = is_text_type(Primary_Type, SubType, Enc_Type);
!   /* 1 if is text type (true)
!    * 0 if not text type
!    * -1 if can't be encoded (ie structured) Message/ or Multipart/ 
!    */
!     
!   if (is_text < 0 && (Enc_Type == ENCODING_QUOTED ||
! 		      Enc_Type == ENCODING_BASE64)) {
!       error ("Content-Type don't allow encoding -- ignoring this part.");
!       if (sleepmsg > 0)
! 	sleep (sleepmsg);
!       return (-1);
!   }
! 
! 
!   (void) update_encoding(&(mime_info->encoding_top),Enc_Type);
! 
!   if (check) {
! 	return(0);
!   }
! 
!   incfile = fopen (Expanded_Filename, "r");
!   if (incfile) {
! 
!     dprint (10, (debugfile, 
! 		 "Include_Part: '%s' C-T=%s/%s Params=%s Enc=%d is_text=%d\n",
! 		 Expanded_Filename,Primary_Type,SubType, Params, Enc_Type,
! 		 is_text));
! 
!     fprintf(dest, "%s %s/%s", MIME_CONTENTTYPE, Primary_Type, SubType);
!     if (Params[0] == '\0') 
!       print_EOLN(dest,mime_info->encoding_top);
!     else { 
!       if (strlen(Primary_Type) + strlen(SubType) + strlen(Params) > 60) {
! 	fprintf(dest,";");
! 	print_EOLN(dest,mime_info->encoding_top);
! 	fputc('\t',dest);
!       } else
! 	fprintf(dest,"; ");
!       fprintf(dest,"%s",Params);
!       print_EOLN(dest,mime_info->encoding_top);
      }
  
!     {
!       char buf[STRING];
!       buf [0] = 0;
  
!       add_parameter(buf,"filename",Include_Filename,sizeof(buf),0);
!       
!       /* When user uses [include ...] it is better use disposition
!        * 'inline' instead of 'attachment'
!        */
!       fprintf(dest,"Content-Disposition: inline; %s",buf);
!       print_EOLN(dest,mime_info->encoding_top);
!     }
  
!     if (Enc_Type != ENCODING_NONE) {
!       if (Enc_Type < ENCODING_EXPERIMENTAL) 
! 	fprintf(dest, "%s %s", MIME_CONTENTENCOD, 
! 		ENCODING(Enc_Type));
!       else /* For ENCODING_EXPERIMENTAL */
! 	fprintf(dest, "%s %s", MIME_CONTENTENCOD, Encoding);
!       print_EOLN(dest,mime_info->encoding_top);
      }
!     print_EOLN(dest,mime_info->encoding_top);
! 
!     /* encoding rules are different for text and no text 
!      * for text we must do \n -> \r\n before base64 encoding */
!     
!     /* For ENCODING_EXPERIMENTAL this is already supposed to be encoded */
!     (void)write_encoded(incfile,dest,Enc_Type,copy,is_text,mime_info);
!     
!     fclose(incfile);
!   }
!   else {
      MoveCursor(LINES, 0);
      Raw(OFF);
      Write_to_screen(catgets(elm_msg_cat, ElmSet, ElmCantOpenIncludedFile,
***************
*** 311,333 ****
  	return(ENCODING_ILLEGAL);
  }
  
! needs_mmdecode(s)
! char *s;
  {
- 	char buf[SLEN];
- 	char *t;
- 	int EncType;
- 
- 	if (!s) return(1);
- 	while (*s && isspace(*s)) ++s;
- 	t = buf;
- 	while (*s && !isspace(*s) && ((t-buf) < (SLEN-1))) *t++ = *s++;
- 	*t = '\0';
- 	EncType = check_encoding(buf);
  	if ((EncType == ENCODING_NONE) ||
  	    (EncType == ENCODING_7BIT) ||
  	    (EncType == ENCODING_8BIT) ||
! 	    (EncType == ENCODING_BINARY)) {
  	    /* We don't need to go out to mmdecode, return 0 */
  	    return(0);
  	} else {
--- 452,466 ----
  	return(ENCODING_ILLEGAL);
  }
  
! needs_mmdecode(EncType)
! int EncType;
  {
  	if ((EncType == ENCODING_NONE) ||
  	    (EncType == ENCODING_7BIT) ||
  	    (EncType == ENCODING_8BIT) ||
! 	    (EncType == ENCODING_BINARY) ||
! 	    (EncType == ENCODING_QUOTED) ||
! 	    (EncType == ENCODING_BASE64)) {
  	    /* We don't need to go out to mmdecode, return 0 */
  	    return(0);
  	} else {
***************
*** 335,377 ****
  	}
  }
  
- notplain(s)
- char *s;
- {
- 	char *t;
- 	if (!s) return(1);
- 	while (*s && isspace(*s)) ++s;
- 	if (istrcmp(s, "text\n") == 0) {
- 		/* old MIME spec, subtype now obligat, accept it as
- 		   "text/plain; charset=us-ascii" for compatibility
- 		   reason */
- 		return(0);
- 	}
- 	if (strincmp(s, "text/plain", 10)) return(1);
- 	t = (char *) index(s, ';');
- 	while (t) {
- 		++t;
- 		while (*t && isspace(*t)) ++t;
- 		if (!strincmp(t, "charset", 7)) {
- 			s = (char *) index(t, '=');
- 			if (s) {
- 				++s;
- 				while (*s && (isspace(*s) || *s == '\"')) ++s;
- 				if (!strincmp(s, display_charset, strlen(display_charset)))
- 					return(0);
- 				if (!strincmp(s, "us-ascii", 8)) {
- 					/* check if configured charset could
- 					   display us-ascii */
- 					if(charset_ok(display_charset)) return(0);
- 				}
- 			}
- 			return(1);
- 		}
- 		t = (char *) index(t, ';');
- 	}
- 	return(0); /* no charset, was text/plain */
- }
- 
  int charset_ok(s)
  char *s;
  {
--- 468,473 ----
***************
*** 393,397 ****
--- 489,547 ----
  	return(FALSE);
      }
      return(TRUE);
+ }
+ 
+ /* Determine whether or not the data in "fp" needs to be QUOTED-PRINTABLE
+     encoded.  Used when sending a message.
+        1 == have 8bit data                (HAVE_8BIT)
+        4 == have control charcters        (HAVE_CTRL)
+        8 == mime requires encoding BINARY (HAVE_BINARY)
+ */
+ needs_encoding (fp)
+ FILE *fp;
+ {
+   int ch;
+   int ret = FALSE;
+   int len = 0;
+ 
+   rewind (fp);
+   while ((ch = fgetc (fp)) != EOF) {
+     /* check for end of line */
+     if (ch == 13) {   /* CR */
+       ch = fgetc(fp);
+       if (ch != 10) {  /* Not CR LF */
+ 	dprint (3, (debugfile, "\nneeds_encoding(): found CR without LF\n"));
+ 	ret |= HAVE_BINARY;
+       }
+       if (ch == EOF)
+ 	break;
+     }
+     if (ch == 10) {
+       len = 0;
+       continue; /* skip newlines and tabs */
+     }
+     len++;
+     if (len > 990) {
+       dprint (3, (debugfile,"\nneeds_encoding(): Line over 990 characters\n"));
+ 	ret |= HAVE_BINARY;
+     }
+ 
+     if (ch == 9) /* skip newlines and tabs */
+       continue;
+     if (ch < 32 || ch > 126) {
+       dprint (3, (debugfile, "\nneeds_encoding(): found char decimal=%d\n", ch));
+       if (ch == 0) 
+ 	ret |= HAVE_BINARY;
+       if (ch < 32 || ch == 127)
+ 	ret |= HAVE_CTRL;
+       if (ch > 127)
+ 	ret |= HAVE_8BIT;
+     }
+     if (ret == (HAVE_8BIT | HAVE_CTRL | HAVE_BINARY))
+       break;
+ 
+   }
+   rewind (fp);
+   return (ret);
  }
  #endif /* MIME */

diff -c /dev/null elm-2.4pl24me8/src/mime_decode.c
*** /dev/null	Thu Sep 21 15:27:01 1995
--- elm-2.4pl24me8/src/mime_decode.c	Thu Sep 21 13:57:42 1995
***************
*** 0 ****
--- 1,553 ----
+ #include "headers.h"
+ #include "me.h"
+ 
+ #ifdef MIME
+ static int index_hex[128] = {
+     -1,-1,-1,-1, -1,-1,-1,-1, -1,-1,-1,-1, -1,-1,-1,-1,
+     -1,-1,-1,-1, -1,-1,-1,-1, -1,-1,-1,-1, -1,-1,-1,-1,
+     -1,-1,-1,-1, -1,-1,-1,-1, -1,-1,-1,-1, -1,-1,-1,-1,
+      0, 1, 2, 3,  4, 5, 6, 7,  8, 9,-1,-1, -1,-1,-1,-1,
+     -1,10,11,12, 13,14,15,-1, -1,-1,-1,-1, -1,-1,-1,-1,
+     -1,-1,-1,-1, -1,-1,-1,-1, -1,-1,-1,-1, -1,-1,-1,-1,
+     -1,10,11,12, 13,14,15,-1, -1,-1,-1,-1, -1,-1,-1,-1,
+     -1,-1,-1,-1, -1,-1,-1,-1, -1,-1,-1,-1, -1,-1,-1,-1
+ };
+ 
+ static int index_64[128] = {
+     -1,-1,-1,-1, -1,-1,-1,-1, -1,-1,-1,-1, -1,-1,-1,-1,
+     -1,-1,-1,-1, -1,-1,-1,-1, -1,-1,-1,-1, -1,-1,-1,-1,
+     -1,-1,-1,-1, -1,-1,-1,-1, -1,-1,-1,62, -1,-1,-1,63,
+     52,53,54,55, 56,57,58,59, 60,61,-1,-1, -1,-1,-1,-1,
+     -1, 0, 1, 2,  3, 4, 5, 6,  7, 8, 9,10, 11,12,13,14,
+     15,16,17,18, 19,20,21,22, 23,24,25,-1, -1,-1,-1,-1,
+     -1,26,27,28, 29,30,31,32, 33,34,35,36, 37,38,39,40,
+     41,42,43,44, 45,46,47,48, 49,50,51,-1, -1,-1,-1,-1
+ };
+ 
+ #define base64(c) ((((c) > 0) && ((c) < 127)) ? index_64[ (c) ] : -1)
+ #define hex(c) ((((c) > 0) && ((c) < 127)) ? index_hex[ (c) ] : -1)
+ 
+ void
+ Xbit_decode (s, len)
+      state_t *s;
+      int len;
+ {
+   char buf[VERY_LONG_STRING];
+   int offset = 0, length;
+ 
+   if (s->prefix) {
+     strcpy (buf, s->prefix);
+     offset = strlen (buf);
+   }
+   while (len > 0) {
+     if (0 ==
+ 	(length = mail_gets (buf + offset, VERY_LONG_STRING - offset, s->fpin)))
+       break;
+     len -= length;
+ 
+     /* Take care of CRLF => LF conversion */
+     if (length > 1 &&
+ 	buf[offset + length - 1] == '\n' &&
+         buf[offset + length - 2] == '\r') {
+       buf[offset + length - 2] = '\n';
+       buf[offset + length - 1] = '\0';
+       length--;
+     }
+ 
+     state_put(buf,offset+length,s);
+   }
+ }
+ 
+ void mime_decode ();
+ 
+ void
+ base64_decode (s, length, astext)
+      state_t *s;
+      int length;
+      int astext;
+ {
+   /* Notes:  this routine assumes that strlen(line length) % 4 == 0.
+      Most intelligent software will do this, so I haven't worried
+      about being *completely* compliant with the standard.  I've
+      not run into any encoded data where this was not true.  */
+   
+   char buf[STRING], *p;
+   int
+     bytes = 0, /* the total number of bytes read so far */
+     terminate = FALSE,
+     c1, c2, c3, c4;
+   unsigned char
+     ch,
+     store_ch = 0; /* for astext */
+   int corrupted = FALSE;
+ 
+   dprint(10,(debugfile,
+            "base64_decode: length=%d, prefix=%s, astext=%d\n",
+            length,
+            s->prefix ? s->prefix : "<NULL>",
+            astext));
+ 
+   /* Make sure to quote the first line! */
+   state_add_prefix(s);
+       
+   while (! terminate) {
+     if (bytes >= length)
+       break;
+ 
+     if (fgets (buf, VERY_LONG_STRING, s->fpin) == NULL)
+       break;
+ 
+     bytes += strlen (buf);
+ 
+     p = buf;
+     while (*p) {
+       c1 = *p++;
+ 
+       if (base64(c1) == -1) {
+         p--;
+         /* partial fix -- K E H   <hurtta@dionysos.FMi.FI>  */
+ 
+         while (*p == ' ' || *p == '\t' || *p == '\r')
+           p++;
+ 
+         if (*p != '\n')
+           corrupted = TRUE;  /* Perhaps corrupted */
+ 
+         if (*p == 0)
+           break;
+ 
+         c1 = *p++;
+       }
+ 
+       /* End of the line. */
+       if (c1 == '\n')
+ 	continue;
+ 
+       c2 = *p++;
+       
+       c1 = base64(c1);
+       if (c1 == -1)
+         corrupted = TRUE;
+       c2 = base64(c2);
+       if (c2 == -1)
+         corrupted = TRUE;
+       ch = (c1 << 2) | (c2 >> 4);
+       
+       if (store_ch && ch != '\n') /* for astext */
+ 	state_putc(store_ch,s);
+ 
+       store_ch = 0;
+       if (astext && ch == '\r')
+         store_ch = ch;
+       else {
+ 	state_putc(ch,s);
+ 	if (ch == '\n')
+ 	  state_add_prefix(s);
+       }      
+     
+       c3 = *p++;
+       if (c3 == '=') {
+ 	terminate = TRUE;
+ 	break;
+       }
+       c3 = base64(c3);
+       if (c3 == -1)
+ 	corrupted = TRUE;
+       ch = ((c2 & 0xf) << 4) | (c3 >> 2);
+ 
+       if (store_ch && ch != '\n')
+ 	state_putc(store_ch,s);
+ 
+       store_ch = 0;
+ 
+       if (astext && ch == '\r')
+ 	store_ch = ch;
+       else {
+ 	state_putc(ch,s);
+ 	if (ch == '\n')
+ 	  state_add_prefix(s);
+       }
+   
+       c4 = *p++;
+       if (c4 == '=') {
+ 	terminate = TRUE;
+ 	break;
+       }
+       
+       c4 = base64(c4);
+       if (c4 == -1)
+ 	corrupted = TRUE;
+       ch = ((c3 & 0x3) << 6) | c4;
+       
+       if (store_ch && ch != '\n')
+ 	state_putc(store_ch,s);
+ 
+       store_ch = 0;
+ 
+       if (astext && ch == '\r') {
+ 	store_ch = ch;
+       }
+       else {
+ 	state_putc(ch,s);
+ 	if (ch=='\n')
+ 	  state_add_prefix(s);
+       }
+     }
+   }
+ 
+   /* Make sure to flush anything left in the internal buffer. */
+   if (store_ch)  /* for astext */
+     state_putc(store_ch,s);
+ 
+   if (corrupted) {
+     error ("BASE64 data was corrupt!");
+     if (sleepmsg > 0)
+       sleep (sleepmsg);
+   }
+ 
+   dprint(10,(debugfile,"base64_decode: readed=%d bytes, corrupted=%d.\n",
+ 	     bytes,corrupted));   
+ 
+   return;
+ }
+ 
+ void
+ quoted_printable_decode (s, length, astext)
+      state_t *s;
+      int length;
+      int astext;
+ {
+   int bytes = 0; /* number of bytes read */
+   int nl = TRUE; /* flag to indicate hitting a new line */
+   char *p;
+   int c1, c2;
+   unsigned char ch, store_ch = 0;
+   char buf[VERY_LONG_STRING];
+   int corrupted = 0;
+ 
+   dprint(10,(debugfile,
+ 	     "quoted_printable_decode: length=%d, prefix=%s, astext=%d\n",
+ 	     length,
+ 	     s->prefix ? s->prefix : "<NULL>",
+ 	     astext));
+ 
+   for (;;) {
+     if (length && length - bytes <= 0)
+       break;
+ 
+     if (fgets (buf, VERY_LONG_STRING, s->fpin) == NULL)
+       break;
+     bytes += strlen (buf);
+ 
+     p = buf;
+     while (*p) {
+ 
+       /* If there is a prefix and this is the beginning of a new line... */
+       if (nl) {
+ 	state_add_prefix(s);
+ 	nl = FALSE;
+       }
+ 
+       if (store_ch)
+ 	state_putc(store_ch,s);
+       
+       if (*p == '=') {
+ 	p++;
+ 	/* Ignore spaces in end of line   -- see MIME */
+ 	if (*p == '\r' || *p == ' ' || *p == '\t') {
+ 	  char *t = p;
+ 	  while (*t && (*t == '\r' || *t == ' ' || *t == '\t'))
+ 	    t++;
+ 	  if (*t && *t == '\n')
+ 	    p = t;
+ 	}
+ 
+ 	if (*p == '\n') { /* soft linebreak */
+ 	  if (length == 0)
+ 	    break;
+ 	  p++;
+ 	}
+ 	else {
+ 	  c1 = hex(*p);
+ 	  if (c1 == -1)
+ 	    corrupted = TRUE;
+ 	  p++;
+ 	  c2 = hex(*p);
+ 	  if (c2 == -1)
+ 	    corrupted = TRUE;
+ 	  p++;
+ 	  ch = (c1 << 4) | c2;
+ 
+ 	  /* We not need here CR LF -> LF removing, because
+ 	   * CRLF's which presents end of line should NOT be encoded.
+ 	   *                             - K E H <hurtta@dionysos.FMI.FI> */
+ 
+ 	  state_putc(ch,s);
+ 	}
+       }
+       else {
+        if (astext && *p == '\r')
+          store_ch = *p;
+        else
+ 	 state_putc(*p,s);
+ 	 
+        if (*p == '\n') {
+ 	 nl = TRUE;
+ 	 if (length == 0)
+ 	   break;
+        }
+ 
+        p++;
+       }  
+     }
+   }
+ 
+   /* Flush anything left in the buffer */
+   if (store_ch) /* for astext */
+     state_putc(store_ch,s);
+ 
+   if (corrupted) {
+     error ("Seems that QUOTED-PRINTABLE data was corrupted.");
+     if (sleepmsg > 0)
+       sleep(sleepmsg);
+   }
+   
+   dprint(10,(debugfile,
+ 	     "quoted_printable_decode: readed=%d bytes, corrupted=%d.\n",
+ 	     bytes,corrupted));
+ 
+   return;
+ }
+ 
+ void
+ multipart_decode (att, state)
+      mime_t *att; /* The list of attachments for this MULTIPART data */
+      state_t *state;
+ {
+   int nattach = 0;
+   char buf[VERY_LONG_STRING];
+ 
+   while (att) {
+     fseek (state->fpin, att->offset, 0);
+     nattach++;
+     if (state->displaying) {
+       char *Encoding = "???";
+        
+       Encoding = ENCODING(att->encoding);
+       
+       /* First print out a nice display line about this attachment */
+       sprintf (buf,
+ 	       "%s[Attach #%d: \"%.60s\"]\n[Type: %.15s/%.30s, Encoding: %s, Size: %d]\n",
+                nattach > 1 ? "\n" : "",
+ 	       nattach, NONULL(att->description),
+ 	       mime_types[att->type], att->subtype,
+ 	       Encoding, att->length);
+     }
+     else {
+       buf[0] = '\0';
+       if (nattach > 1)
+         strcpy (buf, "\n");
+       if (att->description && (strlen(att->description) < sizeof(buf) -30)) {
+ 	strcat (buf, "Content-Description: ");
+ 	strcat (buf, att->description);
+ 	strcat (buf, "\n\n");
+       }
+     }
+       
+     state_puts(buf,state);
+     if (state->displaying)
+       state_putc('\n', state);
+     mime_decode (att, state);
+     att = att->next;
+   }
+ }
+ 
+ void
+ multipart_0_decode (ptr, state)
+      mime_t *ptr;
+      state_t *state;
+ {
+   if (ptr->parts)
+     multipart_decode (ptr->parts, state);
+   else
+     state_puts ("[Content-Type: multipart/*, internal error]\n", state);
+ }
+ 
+ void
+ rfc822_decode (mt, state)
+      mime_t *mt;
+      state_t *state;
+ {
+   /* This looks a lot like multipart_decode() except that we want to print
+    * the headers for the message.  NOTE: "mt" should be a pointer to the
+    * RFC822 attachment, NOT its subpart, since we need the offset in order
+    * to print out the headers.
+    */
+ 
+   int done = FALSE, matched = FALSE;
+   char buf[VERY_LONG_STRING];
+   
+   fseek (state->fpin, mt->offset, 0);
+   
+   /** Print out the headers. **/
+   while (! done) {
+     int len;
+     
+     if (0 == (len = mail_gets (buf, VERY_LONG_STRING, state->fpin)))
+       break;
+     
+     if (filter) {
+       if (matches_weedlist (buf) || (whitespace (buf[0]) && matched)) {
+         matched = TRUE;
+         continue;
+       }
+       else
+         matched = FALSE;
+     }
+ 
+     if (buf[0] == '\n' || (buf[0] == '\r' && buf[1] == '\n'))
+       done = TRUE;
+ 
+     state_puts(buf,state);
+   }
+   mime_decode (mt->parts, state);
+   return;
+ }
+ 
+ void 
+ text_decode(ptr, state) 
+      mime_t *ptr;
+      state_t *state;
+ {
+   char buf[STRING];
+   char tmp[SLEN];
+ 
+ 
+   dprint(12,(debugfile,
+ 	     "text_decode -> state: offset=%d, length=%d; ftell=%ld\n",
+ 	     ptr -> offset, ptr -> length, ftell(state->fpin)));
+ 
+   if (!mime_get_charset (tmp, ptr->type_opts, sizeof(tmp))) {
+     
+     /* Don't show this part (or copy to reply buffer) ... */
+ 	  
+     sprintf (buf, "[Charset: %.15s, skipping]\n", tmp);
+     state_puts(buf,state);
+   }
+   else {
+     if (ptr->encoding == ENCODING_BASE64)
+       base64_decode (state, ptr->length, TRUE);
+     else if (ptr->encoding == ENCODING_QUOTED)
+       quoted_printable_decode (state, ptr->length, TRUE);
+     else if (ptr->encoding != ENCODING_NONE && 
+ 	     ptr->encoding != ENCODING_7BIT &&
+ 	     ptr->encoding != ENCODING_8BIT &&
+ 	     ptr->encoding != ENCODING_BINARY) {
+ 	  
+       state_puts("[Unsupported encoding, skipping]\n",state);
+     }
+     else
+       Xbit_decode (state, ptr->length);
+   }
+ 
+ 
+   dprint(12,(debugfile,
+ 	     "text_decode <- END; ftell=%ld\n",
+ 	     ftell(state->fpin)));
+ 
+ }
+ 
+ void 
+ text_unsupported_decode(ptr, state) 
+      mime_t *ptr;
+      state_t *state;
+ {
+   char buf[STRING];
+ 
+   dprint(12,(debugfile,
+ 	     "text_unsupported_decode -> state: offset=%d, length=%d; ftell=%ld\n",
+ 	     ptr -> offset, ptr -> length, ftell(state->fpin)));
+ 
+ 
+   sprintf (buf, "[%s/%.30s is unsupported, treating like TEXT/PLAIN]\n\n", 
+ 	   TYPE(ptr->type), ptr->subtype);
+   state_puts(buf,state);
+   text_decode(ptr,state);
+ 
+   dprint(12,(debugfile,
+ 	     "text_unsupported_decode <- END; ftell=%ld\n",
+ 	     ftell(state->fpin)));
+ }
+ 
+ void 
+ null_decode(ptr, state) 
+      mime_t *ptr;
+      state_t *state;
+ {
+   char buf[STRING];
+ 
+ 
+   dprint(12,(debugfile,
+ 	     "null_decode <-> state: offset=%d, length=%d; ftell=%ld\n",
+ 	     ptr -> offset, ptr -> length, ftell(state->fpin)));
+ 
+   sprintf (buf, "[%.15s/%.30s is not supported, skipping...]\n",
+ 	   TYPE(ptr->type),ptr->subtype);
+   state_puts(buf,state);
+ }
+ 
+ CT_decoder_t 
+ select_CT_decoder (ptr) 
+      mime_t *ptr;
+ {
+     if (ptr->type == MIME_TYPE_MULTIPART)
+       return multipart_0_decode;
+     else if (ptr->flags & MIME_RFC822)    
+       return rfc822_decode;
+     else if (ptr->type == MIME_TYPE_MESSAGE &&
+ 	     (0 == istrcmp(ptr->subtype, "delivery-status") ||
+ 	      0 == strincmp(ptr->subtype,"X-delivery-status-",18)))
+       return text_decode;
+     else if (ptr->type == MIME_TYPE_TEXT) {
+       if (0 == istrcmp(ptr->subtype, "rfc822-headers") ||
+ 	  0 == istrcmp(ptr->subtype, "plain"))
+ 	return text_decode;
+       return text_unsupported_decode; /* For that type we try use
+ 					 metamail if available! */
+     }
+ #ifdef USE_PGP
+     else if (ptr->type == MIME_TYPE_APPLICATION &&
+              (istrcmp(ptr->subtype, "pgp") == 0))
+       return mime_pgp_decode;
+ #endif
+ 
+     return null_decode;
+ }
+ 
+ 
+ void
+ mime_decode (ptr, state)
+      mime_t *ptr;
+      state_t *state;
+ {
+   /* This routine calls the appropriate routine to decode the data
+    * described in "ptr".
+    */
+ 
+   dprint(12,(debugfile,"mime_decode -> state: offset=%d, length=%d\n",
+ 	    ptr -> offset, ptr -> length));
+ 
+   if (ptr->disposition == DISP_INLINE) {
+     CT_decoder_t decoder = select_CT_decoder(ptr);
+ 
+     fseek (state->fpin, ptr->offset, 0);
+     decoder (ptr, state);    
+   }
+   else
+     state_puts("[Attachment, skipping...  Use 'v' to view this part.]\n",
+                state);
+ 
+   dprint(12,(debugfile,"mime_decode <- END\n"));
+ 
+ }
+ #endif /* MIME */

diff -c /dev/null elm-2.4pl24me8/src/mime_encode.c
*** /dev/null	Thu Sep 21 15:27:01 1995
--- elm-2.4pl24me8/src/mime_encode.c	Wed Sep 20 16:46:10 1995
***************
*** 0 ****
--- 1,568 ----
+ #include "headers.h"
+ #include "s_elm.h"
+ #include "me.h"
+ 
+ #ifdef MIME
+ #include <sys/time.h>
+ 
+ extern short mime_count;
+ 
+ static char base64chars[64] = {
+ 	'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N',
+ 	'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b',
+ 	'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p',
+ 	'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', '0', '1', '2', '3',
+ 	'4', '5', '6', '7', '8', '9', '+', '/'
+ };
+ #define to64(c) (((c) >= 0) && ((c) < 64)) ? base64chars[(c)] : -1
+ 
+ static char hexchars[16] = {
+ 	'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D',
+ 	'E', 'F',
+ };
+ #define hexchar(c) (((c) >= 0) && ((c) < 16)) ? hexchars[(c)] : -1
+ 
+ int
+ update_encoding(top_encoding,encoding)
+ int *top_encoding;
+ int encoding;
+ {
+   if (encoding == ENCODING_8BIT &&
+       (*top_encoding) != ENCODING_BINARY)
+     (*top_encoding) = ENCODING_8BIT;
+   if (encoding == ENCODING_BINARY)
+     (*top_encoding) = ENCODING_BINARY;
+   
+   return (*top_encoding);
+ }
+ 
+ void
+ print_EOLN(fp,top_encoding) 
+      FILE *fp;
+      int top_encoding;
+ {  /* Write canoniocal end of line of we are sending binary mail */
+   if (top_encoding == ENCODING_BINARY)
+     fputc('\r',fp);
+   fputc('\n',fp);
+ }
+ 
+ char *
+ mime_generate_boundary (str)
+      char *str;
+ {
+   time_t t = time (NULL);
+ 	
+   sprintf (str, "ELM%d-%d-%d_", t, getpid(), mime_count++);
+   return str;
+ }
+ 
+ void 
+ add_parameter(opts,name,value,size,quoted) 
+      char *opts, *name, *value;
+      int size, quoted;
+ {
+   int len = strlen(opts);
+   int ln = strlen(name);
+   char * ptr = opts + len, *c;
+   int need_quotation = 0;
+   
+   /* Following characters require quotation: ( ) < > @ , ; : \ " / [ ] ? =
+    * Also whitespace requires quotation. See Mime Draft Standard
+    */
+   if (!quoted && (NULL != strpbrk(value,"()<>@,;:\\\"/[]?= \t")
+ 		  || value[0] == '\0'))
+     need_quotation = 1;
+ 
+   if (len + strlen(value) + ln + 4 + 2 * need_quotation > size)
+     return; /* Don't fit anyway */
+ 
+   if (ptr != opts) {
+     *ptr++ = ';'; *ptr++ = ' ';
+   }
+   strcpy(ptr,name);  ptr += ln;
+   *ptr++ = '=';
+ 
+   if (need_quotation) 
+     *ptr++ = '"';
+ 
+   for (c = value; *c != '\0'; c++) {
+     if (need_quotation && ('\\' == *c || '"' == *c)) {
+       if (ptr < opts + size - 3) {
+ 	*ptr++ = '\\';
+ 	*ptr++ = *c;
+       } else
+ 	break;
+     } else {
+       if (ptr < opts + size - need_quotation - 1) 
+ 	*ptr++ = *c;
+       else
+ 	break;
+     }
+   }
+ 
+   if (need_quotation) 
+     *ptr++ = '"';
+   *ptr = '\0';
+   return;
+ }
+ 
+ void write_encoded();
+ 
+ void
+ attach_generate_message (gopher, fpout, copy, mime_info)
+      mime_t *gopher;
+      FILE *fpout;
+      int copy;
+      mime_send_t *mime_info;
+ {
+ /* given a list of attachments, write them in MIME format to the specified
+  * output stream */
+ 
+   FILE *srcfp;
+   int is_text;
+ 
+   while (gopher) {
+     if (can_open(gopher->pathname,"r") != 0) {
+       gopher = gopher -> next;
+       continue;
+     }
+     srcfp = fopen (gopher->pathname, "r");
+ 
+     if (srcfp) {
+ 
+         /* 1 if is text type (true)
+          * 0 if not text type
+          * -1 if can't be encoded (ie structured) Message/ or Multpart/
+          */
+         is_text = is_text_type (mime_types[gopher->type], gopher->subtype, 
+ 				gopher->encoding);
+ 
+         /* write the attachment header */
+ 	print_EOLN(fpout,mime_info->encoding_top);
+         fprintf (fpout, "--%s", mime_info->mime_boundary);
+ 	print_EOLN(fpout,mime_info->encoding_top);
+         fprintf (fpout, "Content-Type: %s/%s", mime_types[gopher->type], gopher->subtype);
+         if (gopher->type_opts) {
+           fputc (';', fpout);
+           if (strlen (gopher->type_opts) > 45) {
+             print_EOLN (fpout, mime_info->encoding_top);
+             fputc ('\t', fpout);
+           }
+           else
+             fputc (' ', fpout);
+           fputs (gopher->type_opts, fpout);
+ 	}
+         print_EOLN (fpout, mime_info->encoding_top);
+ 
+         /* Now add the Content-Disposition header */
+ 	fprintf (fpout, "Content-Disposition: %s",
+ 		 DISPOSITION(gopher->disposition));
+         if (gopher->disposition_opts) {
+           fputc (';', fpout);
+           if (strlen (gopher->disposition_opts) > 45) {
+             print_EOLN (fpout, mime_info->encoding_top);
+             fputc ('\t', fpout);
+           }
+           else
+             fputc (' ', fpout);
+           fputs (gopher->disposition_opts, fpout);
+         }
+         print_EOLN (fpout, mime_info->encoding_top);
+ 
+ 	fprintf (fpout, "Content-Description: ");
+         if (gopher->description)
+           fputs (gopher->description, fpout);
+         else
+           fputs (gopher->pathname, fpout);
+ 	print_EOLN(fpout,mime_info->encoding_top);
+ 	fprintf (fpout, "Content-Transfer-Encoding: %s",
+                  ENCODING(gopher->encoding));
+ 	print_EOLN(fpout,mime_info->encoding_top);
+ 	print_EOLN(fpout,mime_info->encoding_top);
+ 
+ 	(void) write_encoded (srcfp, fpout, gopher->encoding, copy, is_text,
+ 			      mime_info);
+ 
+ 	fclose (srcfp);
+     }
+     else {
+       error1 ("Error opening %s!", gopher->pathname);
+       dprint (1, (debugfile, "mime_gen_msg(): could not open %s\n", gopher->pathname));
+     }
+ 
+     gopher = gopher->next;
+   }
+   return;
+ }
+ 
+ void
+ base64_encode (srcfp, fpout, istext, mime_info)
+      FILE *srcfp, *fpout;
+      int istext;
+      mime_send_t * mime_info;
+ {
+   int c1, c2, c3;
+   char ch1, ch2, ch3, ch4;
+   int chars = 0;
+   int last_c = 0;
+ 
+   for (;;) {
+     c1 = fgetc (srcfp);
+     if (c1 == -1)
+       break;
+     if (istext && last_c != '\r' && c1 == '\n') {
+       /* In text end of line must be coded as CR LF */
+       c1 = '\r';
+       c2 = '\n';
+     }
+     else
+       c2 = fgetc (srcfp);
+ 
+     if (istext && c1 != '\r' && c2 == '\n') {
+       /* In text end of line must be coded as CR LF */
+       c2 = '\r';
+       c3 = '\n';
+     }
+     else if (c2 != -1)
+       c3 = fgetc (srcfp);
+  
+     if (istext && c2 != '\r' && c3 == '\n') {
+       /* In text end of line must be coded as CR LF */
+       ungetc(c3,srcfp);
+       c3 = '\r';
+     }
+       
+     last_c = c3;
+  
+     ch1 = c1 >> 2;
+     ch1 = to64(ch1);
+     
+     if (c2 != -1) {
+       ch2 = ((c1 & 0x3) << 4) | (c2 >> 4);
+       ch2 = to64(ch2);
+       
+       if (c3 != -1) {
+ 	ch3 = ((c2 & 0xf) << 2) | (c3 >> 6);
+ 	ch3 = to64(ch3);
+ 	ch4 = c3 & 0x3f;
+ 	ch4 = to64(ch4);
+       }
+       else {
+ 	ch3 = (c2 & 0xf) << 2;
+ 	ch3 = to64(ch3);
+ 	ch4 = '=';
+       }
+     }
+     else {
+       ch2 = (c1 & 0x3) << 4;
+       ch2 = to64(ch2);
+       ch3 = '=';
+       ch4 = '=';
+     }
+     
+     fputc (ch1, fpout);
+     fputc (ch2, fpout);
+     fputc (ch3, fpout);
+     fputc (ch4, fpout);
+     chars += 4;
+     
+     if (chars >= 76) {
+       print_EOLN(fpout,mime_info->encoding_top);
+       chars = 0;
+     }	
+   }
+   print_EOLN(fpout,mime_info->encoding_top);
+   return;
+ }
+ 
+ void
+ line_quoted_printable_encode (input,fpout,copy,len,istext,mime_info) 
+      char *input;
+      FILE *fpout;
+      int copy; /* whether or not this is a copy of the message */
+      int len; /* length of data -- be binary clean */
+      int istext; /* if binary (not text) also CRLF need to be encoded */
+      mime_send_t *mime_info;
+ {
+   int chars = 0;
+   char buffer[STRING];
+   unsigned char c1, c2, c3;
+   unsigned char lastchar = 0;
+   unsigned char lastchar2 = 0;
+   
+   dprint (10, (debugfile, 
+ 	       "line_quoted_printable_encode: copy=%d, len=%d, istext=%d\n",
+ 	       copy,len,istext));
+ 
+   if (istext) {  
+     if (len > 0 && input[len-1] == '\n') {
+       lastchar = input[len-1];
+       input[len-1] = '\0';
+       len--;
+       if (len > 0 && input[len-1] == '\r')  {   /* Was CR LF */
+         lastchar2 = input[len-1];
+         input[len-1] = '\0';
+         len--;
+       } else if (mime_info->encoding_top == ENCODING_BINARY)
+ 	lastchar2 = '\r';     /* Simulate it */
+     }
+   }
+ 
+   /* I don't test agaist macros bacause these encodings are recommended
+    * according MIME Draft Standard anyway and MIME encodings are
+    * reversible.
+    *
+    * DONT_ESCAPE_MESSAGES refers '>' escaping -- not reversible
+    * MIME encoding -- '>' escaping was not reversible -- this is.
+    *
+    * We also want do these encodings when sending (copy == 0)
+    * not only when copying to another folder 
+    *            -- K E H <hurtta@dionysos.FMI.FI>                     */
+ 
+   while (len > 0)  {
+     /* Assume that buffer don't have newlines (or they have binary data) ...
+        this routine encodes one line */
+     c1 = (unsigned char) *input++;
+     len--;
+ 
+     if (c1 == '=') {
+       if (chars > 72) {	    
+ 	buffer[chars++] = '=';
+ 	buffer[chars++] = '\0';
+ 	chars = 0;
+ 
+ 	fputs (buffer, fpout);
+ 	print_EOLN(fpout,mime_info->encoding_top);
+       }
+       buffer[chars++] = '=';
+       buffer[chars++] = '3';
+       buffer[chars++] = 'D';
+     }    
+     /*  printable characters -- EXCEPT:   Encode "From " in beginning */
+     else if ((c1 > 31 && c1 < 127) && ((c1 != ' ' || chars != 4 || 
+ 					strncmp(buffer,"From",4) != 0)
+ 				       /* Encode "." if only in line alone */
+ 				       && (c1 != '.' || chars != 0 || len > 0)
+ 				       /* Last space must encode also */
+ 				       && (c1 != ' ' || len > 0)) 
+ 	     ||
+ 	     (c1 == 9 && len > 0 && istext)) { 
+       /* Don't make sense wrap before last character, when last character
+        * is not encoded -- wrapping and character use equal number of columns.
+        * But left space for '=\n' if we will print it in end of function
+        * instead of '\n'. */
+       if (chars > 74 && (len > 0 || !lastchar)) {
+ 	buffer[chars++] = '=';
+ 	buffer[chars++] = '\0';
+ 	chars = 0;
+ 
+ 	fputs (buffer, fpout);
+ 	print_EOLN(fpout,mime_info->encoding_top);
+       }
+       buffer[chars++] = c1;
+     }
+     else {
+       if (chars > 72) {
+ 	buffer[chars++] = '=';
+ 	buffer[chars++] = '\0';
+ 	chars = 0;
+ 
+ 	fputs (buffer, fpout);
+ 	print_EOLN(fpout,mime_info->encoding_top);
+       }
+       c2 = (c1 >> 4) & 0xf;
+       c3 = c1 & 0xf;
+       buffer[chars++] = '=';
+       buffer[chars++] = hexchar(c2);
+       buffer[chars++] = hexchar(c3);
+     }
+   }
+ 
+   /* Make sure to flush the buffer.  */
+   if (chars > 0) {
+     buffer[chars] = '\0';
+     fputs (buffer, fpout);
+   }
+   if (lastchar2)
+     fputc (lastchar2, fpout);
+   if (lastchar) {
+     fputc(lastchar,fpout);
+   } else { /* If input line don't terminate NL then print shoft wrap to end
+ 	    * instead of hard NL */
+     fputs ("=", fpout);
+     print_EOLN(fpout,mime_info->encoding_top);
+   }
+ }
+ 
+ void
+ quoted_printable_encode (srcfp, fpout, copy, istext, mime_info)
+      FILE *srcfp, *fpout;
+      int copy;    /* whether or not this is a copy of the message */
+      int istext;  /* if binary (not text) also CRLF need to be encoded */
+      mime_send_t *mime_info;
+ {
+   char buffer[VERY_LONG_STRING];
+   int len;
+ 
+   if (istext) {
+     /* mail_gets is in ../lib -- it handles also NUL characters */
+     while ((len = mail_gets (buffer, VERY_LONG_STRING, srcfp)) > 0)
+       line_quoted_printable_encode (buffer, fpout, copy, len, istext,
+ 				    mime_info);
+   } else {
+     /* mail_gets may add LF to end of file if file don't end with LF
+      * So it is not good for binary data */
+     while ((len = fread(buffer, 1, sizeof(buffer), srcfp)) > 0)
+       line_quoted_printable_encode (buffer, fpout, copy, len, istext,
+ 				    mime_info);
+   }
+ 
+   return;
+ }
+ 
+ int
+ is_text_type (primary_type, subtype, enc)
+      char *primary_type, *subtype;
+      int enc;
+ {
+  /* encoding rules are different for text and no text 
+   * for text we must do \n -> \r\n before base64 encoding */
+ 
+  /* Current MIME Draft Standard says that part is text
+   * (ie. line oriented) when it is Text/ -type -- otherwise no.
+   *
+   * new draft for Mime standards allows also other parts ot be text.
+   * It says that content-transfer-encodings: 7bit and 8bit are only
+   * allowed for line orienteed types */
+ 
+   /* Actually Message/ and Multipart/ can't be newer encoded directly */
+   if ( istrcmp(primary_type,"Message") == 0 ||
+        istrcmp(primary_type,"Multipart") == 0)
+     return -1;
+ 
+   if (istrcmp(primary_type,"Text") == 0) 
+     return 1;               /* Subtypes of text are always text (ie.
+                              * line oriented). */
+     
+   if (enc == ENCODING_NONE || enc == ENCODING_7BIT || enc == ENCODING_8BIT)
+     return 1;             /* It is text */
+ 
+   if (enc == ENCODING_BINARY)
+     return 0;            /* It is probably binary (or very long lines) */
+ 
+   if (istrcmp(primary_type,"Application") == 0 &&
+       istrcmp(subtype,"Postscript") == 0)
+     return 1;            /*  Postscript is often text */
+   
+   return 0;              /* Default: It is binary */
+ }
+ 
+ void
+ write_encoded (srcfp, fpout, encoding, copy, is_text, mime_info)
+      FILE *srcfp, *fpout;
+      int encoding, copy, is_text;
+      mime_send_t *mime_info;
+ {
+   char buffer[VERY_LONG_STRING];
+   int line_len;
+ 
+   if (encoding == ENCODING_BASE64)
+     base64_encode (srcfp, fpout, is_text, mime_info);
+   else if (encoding == ENCODING_QUOTED)
+     quoted_printable_encode (srcfp, fpout, copy, is_text, mime_info);
+   else if (mime_info-> encoding_top == ENCODING_BINARY && is_text > 0) {
+     /* It is better perhaps use canonical eol (CRLF) when mail have
+      * content transfer encoding BINARY somewhere (see notes about BINARYMIME)
+      */
+     while ((line_len = mail_gets(buffer, sizeof(buffer)-1, srcfp)) > 0) {
+       if (buffer[line_len-1] == '\n') {
+         int add = 1;
+         if (line_len >1 && buffer[line_len-2] == '\r')
+           add = 0;
+         if (add) {
+           buffer[line_len-1] = '\r';
+           buffer[line_len] = '\n';
+           line_len++;
+         }
+       }
+       if (fwrite(buffer, 1, line_len, fpout) != line_len) {
+         MoveCursor(LINES, 0);
+         Raw(OFF);
+         Write_to_screen("\nWrite failed in write_encoded\n", 0);
+         emergency_exit();
+       }
+     }
+   }
+   else {
+     /* BUG: This may add extra \n in end of file if file does not end with \n
+      * but we can't read that with fread when we to need look for escaping of
+      * "From " or lone "."
+      */
+     while (1) {
+ #ifndef DONT_ESCAPE_MESSAGES
+       if (mime_info->encoding_top != ENCODING_BINARY) {
+ 	if ((line_len = mail_gets(buffer, sizeof(buffer)-1, srcfp)) <= 0)
+ 	  break;
+       }
+       else
+ #endif
+ 	if ((line_len = fread(buffer, 1,sizeof(buffer)-1, srcfp)) <= 0)
+ 	  break;
+       
+       if (mime_info-> encoding_top != ENCODING_BINARY) {
+ #ifndef DONT_ESCAPE_MESSAGES
+ 	if (copy && (strncmp(buffer, "From ", 5) == 0)) {
+ 	  /* Add in the > to a From on our copy */
+ 	  fprintf(fpout, ">");
+ 	  if (fwrite(buffer, 1, line_len, fpout) != line_len) {
+ 	    MoveCursor(LINES, 0);
+ 	    Raw(OFF);
+ 	    Write_to_screen("\nWrite failed in write_encoded()\n", 0);
+ 	    emergency_exit();
+ 	  }
+ 	}
+ #ifdef NEED_LONE_PERIOD_ESCAPE
+ 	else if (!copy && strcmp(buffer, ".\n") == 0)
+ 	  /* Because some mail transport agents take a lone period to
+ 	   * mean EOF, we add a blank space on outbound message.
+ 	   */
+ 	  fputs(". \n", fpout);
+ #endif /* NEED_LONE_PERIOD_ESCAPE */
+ 	else
+ #endif /* DONT_ESCAPE_MESSAGES */
+ 	  if (fwrite(buffer, 1, line_len, fpout) != line_len) {
+ 	    MoveCursor(LINES, 0);
+ 	    Raw(OFF);
+ 	    Write_to_screen("\nWrite failed in write_encoded()\n", 0);
+ 	    emergency_exit();
+ 	  }
+       }
+       else if (fwrite(buffer, 1, line_len, fpout) != line_len) {
+ 	MoveCursor(LINES, 0);
+ 	Raw(OFF);
+ 	Write_to_screen("\nWrite failed in write_encoded()\n", 0);
+ 	emergency_exit();
+       }
+     }
+   }
+   return;
+ }
+ 
+ void
+ mime_write_header(fp, ptr)
+      FILE *fp;
+      mime_send_t *ptr;
+ {
+   fputs(MIME_HEADER, fp);
+   print_EOLN(fp, ptr->encoding_top);  
+   fprintf(fp, "%s %s/%s", MIME_CONTENTTYPE, TYPE(ptr->type), ptr->subtype);
+   if (ptr->type_opts[0])
+     fprintf(fp, "; %s", ptr->type_opts);
+   print_EOLN(fp, ptr->encoding_top);
+ 
+   if (ptr->encoding_top != ENCODING_NONE) {
+     fprintf(fp, "%s %s", MIME_CONTENTENCOD, ENCODING(ptr->encoding_top));
+     print_EOLN(fp, ptr->encoding_top);
+   }
+ }
+ #endif /* MIME */

diff -c /dev/null elm-2.4pl24me8/src/mime_parse.c
*** /dev/null	Thu Sep 21 15:27:01 1995
--- elm-2.4pl24me8/src/mime_parse.c	Thu Sep 21 13:20:00 1995
***************
*** 0 ****
--- 1,949 ----
+ #include "headers.h"
+ #include "me.h"
+ 
+ #ifdef MIME
+ /* As ordered in mime.h */
+ char *mime_types[] = {
+ 	"unknown",
+ 	"application",
+ 	"audio",
+ 	"image",
+ 	"message",
+ 	"multipart",
+ 	"text",
+ 	"video",
+         NULL
+ };
+ 
+ int
+ mime_needs_processing (p)
+      mime_t *p;
+ {
+   /* A routing which metapager() calls to determine if the message specified
+    * by "p" to determine whether or not any special MIME processing needs
+    * to be performed.  This information is used to decide if a temp file
+    * needs to be used in order to effect backwards paging, or if we can page
+    * directly out of the mailbox file.
+    */
+ 
+   if (p->type != MIME_TYPE_TEXT)
+     return TRUE;
+ 
+   /* This is to support those poor unfortunate folk who don't have true
+    * MIME support.  Often, you see "Content-Type: text".  We'll just
+    * assume that it's normal text.
+    */
+   if (p->subtype[0] == '\0')
+     return FALSE;
+ 
+   if (istrcmp (p->subtype, "plain") != 0)
+     return TRUE;
+   if (p->encoding != ENCODING_7BIT && p->encoding != ENCODING_8BIT)
+     return TRUE;
+ 
+   return FALSE;
+ }
+ 
+ int
+ mime_notplain (p)
+      mime_t *p;
+ {
+   CT_decoder_t d = select_CT_decoder(p);
+   char buf[STRING];
+   
+   if (d == rfc822_decode)
+     return FALSE;
+   
+   /* Notice: if (d == text_unsupported_decode)
+    *         we return TRUE, because we want call metamail
+    *         if it is available
+    */
+   
+   if (d == text_decode) {
+     if (mime_get_charset(buf,p->type_opts,sizeof(buf)))
+       return FALSE;
+   }
+   else if (p->type == MIME_TYPE_MULTIPART && pagemultipart)
+     return FALSE;
+ #ifdef USE_PGP
+   else if (d == mime_pgp_decode)
+     return FALSE;
+ #endif
+   return TRUE;
+ }
+ 
+ char *
+ mime_parse_content_opts (str)
+      char *str;
+ {
+   /* A routine for parsing the options in a Content-Type: field.  The
+    * important point here is to skip the semi-colon if it appears
+    * inside of quotes.  This works sort of like strtok, except that
+    * the token is already known.
+    */
+   static char *ptr;
+   char *ret;
+   int in_quote = 0;
+ 
+   /* This is the initialization call */
+   if (str)
+     ptr = str;
+   
+   if (*ptr == '\0')
+     return NULL;
+ 
+   ret = ptr;
+   while (*ptr) {
+     if (*ptr == '\\' && in_quote) {		  
+       /* \ escapes next character  
+        * (not allowed outside of quotes) */
+       ptr++;
+       if (*ptr == '\0')
+ 	break;
+     } else if (*ptr == '\"') {
+       if (in_quote)
+ 	in_quote = 0;
+       else
+ 	in_quote = 1;
+     }
+     else if (! in_quote) {
+       if (*ptr == ';') {
+ 	*ptr++ = '\0';
+ 	/* skip leading spaces */
+ 	while (*ptr && isspace ((unsigned char)*ptr))
+ 	  ptr++;
+ 	return (ret);
+       }
+     } 
+     ptr++;
+   }
+   return (ret);
+ }
+ 
+ /* Removes comments from string */
+ void 
+ rfc822_reap_comments (ptr, comments, size) 
+      char *ptr, *comments;
+      int size;
+ {
+   char *w_ptr = ptr, *c_ptr = comments;
+   int comment_level = 0, saved_level = 0;
+   int in_quote = 0;
+   
+   while (*ptr) {
+     if (*ptr == '\\' && (in_quote || comment_level > 0)) {		  
+       /* \ escapes next character  
+        * (not allowed outside of quotes or comments) */
+       ptr++;
+       if (*ptr == '\0')
+ 	break;
+       if (comment_level > 0 && comments) {
+ 	if (c_ptr < comments + size - saved_level -3) {
+ 	  *c_ptr++ = '\\';
+ 	  *c_ptr++ = *ptr;
+ 	}
+       }
+       if (comment_level == 0) {
+ 	*w_ptr++ = '\\';
+ 	*w_ptr++ = *ptr;
+       }
+       ptr++;
+       continue;
+     } else if (comment_level > 0) {
+       if (*ptr == ')')
+ 	comment_level --;
+       if (*ptr == '(')
+ 	comment_level ++;
+       if (comments && c_ptr < comments + size - saved_level -3) {
+ 	*c_ptr++ = *ptr;
+ 	saved_level = comment_level;
+       }
+     } else if (*ptr == '\"') {
+       if (in_quote)
+ 	in_quote = 0;
+       else
+ 	in_quote = 1;
+     } else if (!in_quote && *ptr == '(') {
+       comment_level ++;
+       if (comments && c_ptr < comments + size - saved_level -4) {
+ 	if (c_ptr != comments)
+ 	  *c_ptr++ = ' ';
+ 	*c_ptr++ = *ptr;
+ 	saved_level = comment_level;
+       }
+       *w_ptr++ = ' ';  /* RFC 822 (STD 11) says that 
+ 			  comments represents one space */
+     }
+     if (comment_level == 0 && *ptr != ')')
+       *w_ptr++ = *ptr;
+     ptr++;
+   }
+   while (comments && saved_level > 0) {
+     *c_ptr++ = ')';
+     saved_level--;
+   }
+ 
+   if (comments)
+     *c_ptr = '\0';
+   *w_ptr = '\0';
+ }
+ 
+ void
+ mime_destroy (ptr)
+      mime_t *ptr;
+ {
+   mime_t *tmp;
+ 
+   while (ptr) {
+     tmp = ptr;
+     ptr = ptr->next;
+ 
+     if (tmp->description)
+       free (tmp->description);
+     if (tmp->type_opts)
+       free (tmp->type_opts);
+     if (tmp->disposition_opts)
+       free (tmp->disposition_opts);
+ 
+     if (tmp->parts)
+       mime_destroy (tmp->parts);
+ 
+     if (tmp->unlink)
+       unlink (tmp->pathname);
+ 
+     free (tmp);
+   }
+   return;
+ }
+ 
+ void
+ mime_t_clear (mt)
+      mime_t *mt;
+ {
+   mt->flags = mt->offset = mt->begin_offset = mt->length = 0;
+   mt->encoding = ENCODING_7BIT;
+   mt->unlink = 0;
+   mt->type = MIME_TYPE_TEXT;
+   mt->disposition = DISP_INLINE;
+   mt->notplain = 0;
+ 
+   if (mt->parts)
+     mime_destroy (mt->parts);
+   if (mt->next)
+     mime_destroy (mt->next);
+ 
+   mt->next = mt->prev = mt->parts = NULL;
+ 
+   if (mt->description)
+     free (mt->description);
+   mt->description = NULL;
+   if (mt->type_opts)
+     free (mt->type_opts);
+   mt->type_opts = NULL;
+   if (mt->disposition_opts)
+     free (mt->disposition_opts);
+   mt->disposition_opts = NULL;
+   if (mt->pathname)
+     free (mt->pathname);
+   mt->pathname = NULL;
+ 
+   strcpy (mt->subtype, "plain");
+ 
+   return;
+ }
+ 
+ void
+ mime_get_disposition (str, mt)
+      char *str;
+      mime_t *mt;
+ {
+   char *c, tmp[VERY_LONG_STRING];
+ 
+   dprint (2, (debugfile, "mime_get_disposition(): str=\"%s\"\n", str));
+   
+   /* Don't harm "str" */
+   strfcpy (tmp, str, sizeof(tmp));
+   
+   rfc822_reap_comments (tmp, NULL, 0);
+   
+   /* Look for the options field */
+   if ((c = strchr (tmp, ';')) != NULL) {
+     char *d = c;
+     while (d > tmp && whitespace(*(d-1)))
+       d--;
+     *d = '\0';
+     c++;
+     while (*c && whitespace(*c))
+       c++;
+     mt->disposition_opts = strmcpy (mt->disposition_opts, c);
+   }
+   else {
+     char *d = tmp + strlen(tmp);
+     while (d > tmp && whitespace(*(d-1)))
+       d--;
+     *d = '\0';
+     if (mt->disposition_opts) {
+       free (mt->disposition_opts);
+       mt->disposition_opts = NULL;
+     }
+   }
+   
+   /* All that's left now is the main disposition */
+   c = tmp;
+   while (*c && whitespace(*c))
+     c++;
+   /* No Content-Disposition -header     -> DISP_INLINE
+    *    Content-Disposition: inline     -> DISP_INLINE
+    *    Content-Disposition: attachment -> DISP_ATTACH
+    *    Content-Disposition: {unknown}  -> DISP_ATTACH
+    * See RFC 1806 (Experimental protocol) for details.
+    */   
+   if (istrcmp (c, "inline") != 0)
+     mt->disposition = DISP_ATTACH;
+   else
+     mt->disposition = DISP_INLINE;
+      
+   dprint (2, (debugfile,
+ 	     "mime_get_disposition(): disposition=\"%s\", disposition_opts=\"%s\"\n",
+ 	     DISPOSITION(mt->disposition), NONULL(mt->disposition_opts)));
+ }
+ 
+ int
+ mime_check_type (str)
+ 	char *str;
+ {
+   if (istrcmp (str, "text") == 0)
+     return MIME_TYPE_TEXT;
+   if (istrcmp (str, "multipart") == 0)
+     return MIME_TYPE_MULTIPART;
+   if (istrcmp (str, "message") == 0)
+     return MIME_TYPE_MESSAGE;
+   if (istrcmp (str, "application") == 0)
+     return MIME_TYPE_APPLICATION;
+   if (istrcmp (str, "image") == 0)
+     return MIME_TYPE_IMAGE;
+   if (istrcmp (str, "audio") == 0)
+     return MIME_TYPE_AUDIO;
+   if (istrcmp (str, "video") == 0)
+     return MIME_TYPE_VIDEO;
+   return MIME_TYPE_UNKNOWN;
+ }
+ 
+ void
+ mime_get_content (str, mt)
+      char *str;
+      mime_t *mt;
+ {
+   char *c, tmp[VERY_LONG_STRING];
+ 
+   dprint (2, (debugfile, "mime_get_content(): str=\"%s\"\n", str));
+ 
+   /* Don't harm "str" */
+   strfcpy (tmp, str, sizeof(tmp));
+ 
+   rfc822_reap_comments (tmp, NULL, 0);
+ 
+   /* Look for the options field */
+   if ((c = strchr (tmp, ';')) != NULL) {
+     char *d = c;
+     while (d > tmp && whitespace(*(d-1)))
+       d--;
+     *d = '\0';
+     c++;
+     while (*c && whitespace(*c))
+       c++;
+     mt->type_opts = strmcpy (mt->type_opts, c);
+   }
+   else {
+     char *d = tmp + strlen(tmp);
+     while (d > tmp && whitespace(*(d-1)))
+       d--;
+     *d = '\0';
+     if (mt->type_opts) {
+       free (mt->type_opts);
+       mt->type_opts = NULL;
+     }
+   }
+   
+   mt->subtype[0] = '\0';
+   /* Get the subtype */
+   if ((c = strchr (tmp, '/')) != NULL) {
+     char *d = c;
+     while (d > tmp && whitespace(*(d-1)))
+       d--;
+     *d = '\0';
+ 
+     c++;
+     while (*c && whitespace(*c))
+       c++;
+     strfcpy (mt->subtype, c, sizeof(mt->subtype));
+   }
+   
+   /* All that's left now is the main type */
+   c = tmp;
+   while (*c && whitespace(*c))
+     c++;
+   mt->type = mime_check_type (c);
+ 
+   /* Mark MESSAGE/RFC822 so we can do special handling later */
+   if (mt->type == MIME_TYPE_MESSAGE && istrcmp (mt->subtype, "rfc822") == 0)
+     mt->flags |= MIME_RFC822;
+ 
+   dprint (2,(debugfile,
+ 	     "mime_get_content(): type=\"%s\", subtype=\"%s\", opts=\"%s\"\n",
+ 	     mime_types[mt->type], mt->subtype, NONULL(mt->type_opts)));
+ 
+   return;
+ }
+ 
+ int
+ mime_get_param (name, value, opts, size)
+      char *name, *opts, *value;
+      int size;
+ {
+   char *c, tmp[VERY_LONG_STRING];
+   int i = 0, quoted = FALSE, found = FALSE;
+ 
+   value[0] = '\0';
+ 
+   if (!opts) {
+     dprint(11, (debugfile,"mime_get_param: name=\"%s\", opts=NULL\n",name));
+     return 0;
+   }
+ 
+   dprint(11, (debugfile,"mime_get_param: name=\"%s\", opts=\"%s\"\n",
+ 	      name,opts));
+ 
+   /* Make sure not to harm opts */
+   strfcpy (tmp, opts, sizeof (tmp));
+   
+   c = tmp;
+   while ((c = mime_parse_content_opts (c)) != NULL && !found) {
+     char * d = strchr(c,'=');
+     if (!d) {
+       c = NULL;
+       continue;    /* bad paramater */
+     }
+     while (d > c && (whitespace (*(d-1))))
+       d--;
+     *d = '\0';
+     
+     while (*c && whitespace(*c))
+       c++;
+     
+     if (istrcmp (c, name) == 0) {
+       found = TRUE;
+       
+       c = d+1;
+       while (*c && whitespace(*c))
+ 	c++;
+       if (*c == '"') {
+ 	c++;
+         quoted = TRUE;
+       }
+       /* Either look for a trailing quoted (if quoted==TRUE) or a SPACE */
+       while (*c && ((quoted && *c != '"') || (!quoted && *c != ' '))) {
+ 	if (*c == '\\' && quoted) {
+ 	  /* \ escapes next character */
+ 	  c++;
+ 	  if (!*c)
+ 	    break;
+ 	}
+ 	if (i >= size-1)
+ 	  break;    /* Avoid buffer overflow */
+ 	value[i++] = *c++;
+       }
+       value[i] = '\0';
+       break;
+     }
+     c = NULL;
+   }
+ 
+   dprint(11,(debugfile,"mime_get_param: found=%d, value=%s\n",found,value));
+ 
+   return found;
+ }
+ 
+ static void
+ mime_get_boundary (boundary, opts, size)
+      char *opts, *boundary;
+      int size;
+ {
+   if (!mime_get_param ("boundary", boundary, opts, size))
+     error ("'boundary' paramater is missing from Multipart -type!");
+ 
+   return;
+ }
+ 
+ /* There should better handling in metapager (I have one idea)
+  * Perhaps in next version ...    -K E H    <hurtta@dionysos.fmi.fi>
+  */
+ int 
+ mime_get_charset (charset_value, opts, size)
+      char *opts, *charset_value;
+      int size;
+ {  /* Returns 1 if charset is displayable with charset of text
+     *     (suitable for replying)
+     * Return 2 if cahrset is displayable with display_charset
+     *           (when replying charset should be changed to display_charset)
+     */
+   int ret = 0;
+ 
+   if (!mime_get_param("charset",charset_value,opts,size)) 
+     strcpy(charset_value,"US-ASCII"); 
+     /* Default charset if nothing specified */
+ 
+   /* Check agaist charset of text */
+   if (0 == istrcmp(charset_value,"US-ASCII") && charset_ok(charset))
+     ret = 1; /* If charset of text can show us-ascii? */
+   else if (0 == istrcmp(charset_value,charset))
+     ret = 1;
+   /* Check agaist display charset */
+   else if (0 == istrcmp(charset_value,"US-ASCII") && 
+ 	   charset_ok(display_charset))
+     ret = 2; /* If display_charset can show us-ascii? */
+   else if (0 == istrcmp(charset_value,display_charset))
+     ret = 2;
+ 
+   if (!opts) {
+     dprint(9,(debugfile,"mime_get_charset: opts=NULL\n",opts));
+   } else {
+     dprint(9,(debugfile,"mime_get_charset: opts=\"%s\"\n",opts));
+   }
+   dprint(9,(debugfile,"                : charset_value=\"%s\"\n",
+ 	    charset_value));
+   dprint(9,(debugfile,
+ 	    "                : (text)charset=\"%s\",display_charset=\"%s\"\n",
+ 	    charset,display_charset));
+   dprint(9,(debugfile,"mime_get_charset=%d\n",ret));
+ 
+   return ret;
+ }
+ 
+ void
+ mime_t_zero (ptr)
+      mime_t *ptr;
+ {
+   /* This routine should be called whenever a new "mime_t" is created.  It
+    * makes sure that the pointers inside are correctly initialized to NULL
+    * so that we don't end up calling free() on an uninitialized pointer.
+    */
+   ptr->next = ptr->parts = NULL;
+   ptr->description = ptr->type_opts = ptr->disposition_opts = 
+     ptr->pathname = NULL;
+ }
+ 
+ mime_t *
+ mime_t_alloc ()
+ {
+   mime_t *ptr;
+ 
+   ptr = (mime_t *) safe_malloc (sizeof (mime_t));
+   /* Make sure to clear the pointers initially so that later we know when
+    * to reclaim memory in mime_t_clear().
+    */
+   mime_t_zero (ptr);
+   mime_t_clear (ptr);
+   return ptr;
+ }
+ 
+ int
+ read_header_line (fp, buf, size) 
+      FILE *fp;
+      char *buf;
+      int size;
+ {
+   /* Read and unfold header line -- stores maximum size-1 bytes to buffer
+    * (plus \0). Also handle case when headers are eneded either CR LF or LF.
+    * Returns number of bytes stored. Always _read_ end of header
+    * (even when buffer fills). Returns 0 when reads empty line (only CR LF).
+    * That indicates end of headers.
+    */
+   int len = 0,c;
+   size--; /* Place for \0 */
+ 
+ #define PUTC(c) { if (len < size) buf[len++] = (c); }
+   
+   while (EOF != (c = fgetc(fp))) {
+     if ('\r' == c) {                /* Is this CR LF sequence ? */
+       if (EOF == (c = fgetc(fp)))
+ 	break;
+       if (c != '\n') 
+ 	PUTC('\r');
+     }
+     if (c == '\n') {                /* Readed CR LF or LF, check folding */
+       if (len == 0)
+ 	break;                      /* End of headers ! */
+       if (EOF == (c = fgetc(fp)))
+ 	break;
+       if (c != ' ' && c != '\t') {   /* Not a continuation line */
+ 	ungetc(c,fp);
+ 	break;
+       }
+       /* CRLF LWSP sequence should be replaced with ' ' */
+       c = ' ';
+     }
+     PUTC(c);
+   }
+ #undef PUTC
+   buf[len] = 0;
+ 
+   dprint(12,(debugfile,"read_header_line: len=%d, buf=%s\n",len,buf));
+ 
+   return len;
+ }
+ 
+ mime_t *
+ mime_read_header (fp, opts)
+      FILE *fp;
+      int opts;
+ {
+   int len;
+   char buf [VERY_LONG_STRING], *c;
+   mime_t *ptr;
+ 
+   ptr = mime_t_alloc ();
+ 
+   /* set some defaults */
+   ptr->encoding = ENCODING_7BIT;
+   if (opts & MIME_DIGEST) {
+     ptr->type = MIME_TYPE_MESSAGE;
+     strcpy (ptr->subtype, "rfc822");
+   }
+   else {
+     ptr->type = MIME_TYPE_TEXT;
+     strcpy (ptr->subtype, "plain");
+   }
+   ptr->disposition = DISP_INLINE;
+   ptr->description = NULL;
+ 
+   ptr->begin_offset = ftell (fp);
+   ptr->offset = ptr->begin_offset;
+   ptr->length = 0;
+ 
+   while ((len = read_header_line (fp, buf, VERY_LONG_STRING)) > 0) {
+     char * value;
+     /* read_header_line is already done unfolding of header line 
+      * and removing of CRLF on end of header */
+     if (NULL != (value = strchr(buf,':'))) {
+       *value = '\0';
+       value++;
+     }
+     else { /* Not a header line!! */
+       error ("Error when reading mime headers!");
+       fseek (fp, ptr->offset, SEEK_SET);     /* rewind last read .... */
+       break;
+     }
+     /* For rewind position in case of error ... */
+     ptr->offset = ftell (fp);
+ 
+     if (istrcmp (buf, "content-type") == 0)
+       mime_get_content (value, ptr);
+     else if (istrcmp (buf, "content-disposition") == 0)
+       mime_get_disposition (value, ptr);
+ #if 0
+     else if (istrcmp (buf, "content-length") == 0)
+       ptr->length = atoi (value);
+ #endif
+     else if (istrcmp (buf, "content-transfer-encoding") == 0) {
+       rfc822_reap_comments (value, NULL, 0);
+       c = value;
+       while (*c && isspace((unsigned char) *c))
+ 	c++;
+       ptr->encoding = check_encoding (c);
+     }
+     else if (istrcmp (buf, "content-description") == 0) {
+       c = buf + 20;
+       while (*c && whitespace(*c))
+ 	c++;
+       ptr->description = NULL;
+       ptr->description = strmcpy (ptr->description, c);
+     }
+   }
+ 
+   /* where the real data starts */
+   ptr->offset = ftell (fp);
+ 
+   if (ptr->type == MIME_TYPE_MULTIPART) {
+     if (istrcmp (ptr->subtype, "mixed") == 0)
+       ptr->flags |= MIME_MIXED;
+     else if (istrcmp (ptr->subtype, "digest") == 0)
+       ptr->flags |= MIME_DIGEST;
+   }
+   else if (ptr->type == MIME_TYPE_MESSAGE &&
+ 	   istrcmp (ptr->subtype, "rfc822") == 0)
+     ptr->flags |= MIME_RFC822;
+ #if 0
+   if (ptr->length) {
+     /* Check validity of Content-Length: -header. It's value can be 
+      * incorrect due the CRLF-> LF and  LF -> CRLF conversions...
+      */
+     int ok = 0, c;
+     char buffer[LONG_STRING];
+ 
+     fseek (fp, (long) (ptr->length),SEEK_CUR);   /* Seeks forward */
+     c = fgetc (fp);
+     /* There should be one newline before next mail or boundary */
+     if ('\r' == c) /* OK */
+       c = fgetc(fp);
+     if ('\n' == c) /* OK */
+       c = fgetc(fp);
+     if (c != EOF) {
+       int len = 0;
+       /* So now we must be in either end of multipart
+        * or end of mail .... */      
+       buffer[0] = c;
+       if (0 != (len = mail_gets(buffer+1,sizeof(buffer)-1,fp))) {
+ 	if (0 == strncmp(buffer,"--",2))   /* End of multipart */
+ 	  ok = 1;
+ 	/* It is ok also if next mail starts here */
+ #ifdef MMDF
+ 	if (0 == strcmp(buffer,MSG_SEPARATOR))
+ 	  ok = 1;
+ #else  
+ 	if (0 == strncmp(buffer,"From ",5))
+ 	  ok = 1;
+ #endif  /* MMDF */
+ 	dprint(5, (debugfile, 
+ 		   "mime_read_header: checking content-length, ok = %d, (%d bytes) buffer=%s\n",
+ 		   ok,len+1,buffer));
+       }
+     } else { 
+       if (feof(fp)) {
+ 	ok = 1;
+ 	dprint(5, (debugfile, 
+ 		   "mime_read_header: checking content-length, ok = %d, got EOF.\n",
+ 		   ok));
+       }
+     }
+     if (!ok) {
+       dprint(5, (debugfile, 
+ 		 "mime_read_header: content-length=%ld was incorrect!\n",
+ 		 ptr->length));
+       ptr->length = 0;     /* Reset it */
+     }
+     
+     fseek(fp,ptr->offset,SEEK_SET);   /* return to start of data */
+   }
+ #endif
+ 
+   return ptr;
+ }    
+ 
+ static mime_t *
+ multipart_parse (fp, length, boundary, opts)
+      FILE *fp;
+      int length, opts;
+      char *boundary;
+ {
+   int blen, len,last_pos;
+   long end_offset;
+   char buf[VERY_LONG_STRING], subbound[STRING];
+   mime_t *ptr = NULL, *tmp, *ret = NULL;
+ 
+   dprint(9,(debugfile,"multipart_parse --> length=%d, boundary=%s\n",
+ 	    length, boundary));
+ 
+   blen = strlen (boundary);
+   end_offset = ftell (fp) + length;
+   last_pos = ftell(fp);
+ 
+   while (ftell (fp) < end_offset) {
+     if ((len = mail_gets (buf, VERY_LONG_STRING, fp)) == 0)
+       break;
+ 
+     if (buf[0] == '-' && buf[1] == '-' &&
+         strncmp (buf + 2, boundary, blen) == 0) {
+ 
+       /* Save the length of the previous part */
+       if (ptr) {
+         ptr->length = last_pos - ptr->offset;
+ 	dprint(9,(debugfile,"multipart_parse: fixing length=%d\n",
+ 		  ptr->length));
+       }
+       /* Check for the end boundary. */
+       if (buf[blen+2] == '-' && buf[blen+3] == '-')
+         break;
+       
+       tmp = mime_read_header (fp, opts);
+ 
+       dprint(9,(debugfile,"multipart_parse: (reading) content-type=%s/%s; flags=%d\n",
+ 		mime_types[tmp->type], tmp->subtype, tmp->flags));
+ 
+       
+       if (ret == NULL)
+         ptr = ret = tmp;
+       else {
+         ptr->next = tmp;
+         ptr = ptr->next;
+       }
+ #if 0
+       if (ptr->length > 0) {
+ 	/* If the length of this part is known, skip ahead to the next
+ 	 * part.  If the length is not known, we don't have to worry
+ 	 * about it because the algorithm will search for the next
+ 	 * boundary...
+ 	 */
+         fseek (fp, (long) (ptr->length), SEEK_CUR);
+ 	continue;
+       }
+ #endif
+     }
+     if (ptr && 0 == ptr->length) { /* mark position before CR LF */
+       int pos = ftell(fp);
+       if (len > 1 && buf[len-2] == '\r' && buf[len-1] == '\n')
+ 	last_pos = pos -2;
+       else if (len > 0 && buf[len-1] == '\n')
+ 	last_pos = pos -1;
+     }
+   }
+ 
+   /* Now that we know what this message consists of, see if any of the
+    * parts contain data that needs to be parsed. */
+ 
+   for (tmp = ret; tmp != NULL; tmp = tmp->next) {
+     dprint(9,(debugfile,"multipart_parse: (parsing) content-type=%s/%s; flags=%d\n",
+ 	      mime_types[tmp->type],tmp->subtype,tmp->flags));
+ 
+     if (tmp->flags & MIME_RFC822) {
+       fseek (fp, tmp->offset, SEEK_SET);
+       tmp->parts = rfc822_parse (fp, tmp->length);
+     }
+     else if (tmp->type == MIME_TYPE_MULTIPART) {
+       fseek (fp, tmp->offset, SEEK_SET);
+       mime_get_boundary (subbound, tmp->type_opts, sizeof (subbound));
+       tmp->parts = multipart_parse (fp, tmp->length, subbound, tmp->flags);
+     }
+   }
+ 
+   /* Make sure to leave the stream at the end of the data since the
+    * calling function might be assuming this.  */
+   fseek (fp, end_offset, SEEK_SET);
+ 
+   dprint(9,(debugfile,"multipart_parse <-- DONE\n"));
+ 
+   return ret;
+ }
+ 
+ mime_t *
+ rfc822_parse (fp, len)
+      FILE *fp;
+      int len;
+ {
+   /* Called to read MESSAGE/RFC822 data.  First reads the header of the
+    * message for MIME information, then (when necessary) calls other
+    * functions to determine the content of MULTIPART or MESSAGE/RFC822
+    * data contained.
+    */
+   mime_t *ret;
+   long end_offset = ftell (fp) + len;
+   char boundary[STRING];
+ 
+   dprint(9,(debugfile,"rfc822_parse --> len=%d\n",len));
+ 
+   ret = mime_read_header (fp, MIME_MIXED);
+   
+   dprint(9,(debugfile,"rfc822_parse: content-type=%s/%s; flags=%d\n",
+ 	    mime_types[ret->type], ret->subtype,ret->flags));
+ 
+   if (ret->length == 0) { 
+     int pos = ftell(fp);
+     
+     ret->length = end_offset - pos;
+     dprint(9,(debugfile,"rfc822_parse: fixing length=%d\n",ret->length));
+   }
+ 
+   if (ret->type == MIME_TYPE_MULTIPART) {
+     mime_get_boundary (boundary, ret->type_opts, STRING);
+     ret->parts = multipart_parse (fp, ret->length, boundary, ret->flags);
+   }
+   else if (ret->flags & MIME_RFC822)
+     ret->parts = rfc822_parse (fp, ret->length);
+   
+   if (ret->length == 0) 
+     ret->length = len - (ret->offset - ret->begin_offset);
+ 
+   /* Make sure the leave the stream at the end of the data! */
+   fseek (fp, end_offset, SEEK_SET);
+ 
+   dprint(9,(debugfile,"rfc822_parse <-- DONE\n"));
+ 
+   return ret;
+ }
+ 
+ void
+ mime_warnings(hdr) 
+      struct header_rec *hdr;
+ {
+ 
+   if (hdr->status & PRE_MIME_CONTENT) {
+     error("Error: MIME-message has pre-MIME content-type!");
+     if (sleepmsg > 0)
+       sleep (sleepmsg);
+   }
+   if (hdr->status & MIME_UNSUPPORTED) {
+     error("Warning: Unsupported MIME-Version!");
+     if (sleepmsg > 0)
+       sleep (sleepmsg);
+   }
+ }
+ 
+ void
+ attach_parse (hdr, fp)
+      struct header_rec *hdr;
+      FILE *fp;
+ {
+   /* This routine checks to see if the multipart messages specified by
+    * "hdr" has been parsed for its subparts, and if not, calls the routine
+    * to do so.
+    */
+ 
+   char boundary[STRING];
+ 
+   mime_warnings(hdr);
+ 
+   /* Copy value */
+   if (hdr -> content_length >= 0)
+     hdr->mime_rec.length = hdr -> content_length;
+ 
+   if (hdr->mime_rec.begin_offset == 0) {
+     char buf[STRING];
+     int tmp;
+ 
+     fseek(fp,hdr->offset,SEEK_SET);
+     hdr->mime_rec.begin_offset = hdr->offset;
+     /* Skip mailbox's separator lines ... */
+ 
+     dprint(9,(debugfile,"attach_parse: scanning begin_offset: %d\n",
+ 	      hdr->mime_rec.begin_offset));
+     while (0 < (tmp = mail_gets(buf,sizeof(buf),fp))) {
+       dprint(9,(debugfile,"attach_parse: len=%d, got: %s\n",tmp,buf));
+ #ifdef MMDF
+       if (0 == strcmp(buf,MSG_SEPARATOR))
+ 	continue;
+ #endif
+       if (0 == strncmp(buf,"From ",5))
+ 	continue;
+       break;
+     }
+     hdr->mime_rec.begin_offset = ftell(fp) - tmp;
+     dprint(9,(debugfile,"attach_parse: begin_offset=%d\n",
+ 	      hdr->mime_rec.begin_offset));
+   }
+ 
+   if (hdr->mime_rec.type == MIME_TYPE_MULTIPART) {
+     if (hdr->mime_rec.parts == NULL) {
+       mime_get_boundary (boundary, hdr->mime_rec.type_opts, STRING);
+       fseek (fp, hdr->mime_rec.offset, SEEK_SET);
+       hdr->mime_rec.parts = multipart_parse (fp, hdr->content_length, boundary, hdr->mime_rec.flags);
+     }
+   }
+   else if (hdr->mime_rec.flags & MIME_RFC822) {
+     if (hdr->mime_rec.parts == NULL) {
+       fseek (fp, hdr->mime_rec.offset, SEEK_SET);
+       hdr->mime_rec.parts = rfc822_parse (fp, hdr->content_length);
+     }
+   }
+   return;
+ }
+ #endif /* MIME */

diff -c elm-2.4pl24/src/newmbox.c elm-2.4pl24me8/src/newmbox.c
*** elm-2.4pl24/src/newmbox.c	Sat May 14 11:42:59 1994
--- elm-2.4pl24me8/src/newmbox.c	Thu Sep 21 14:56:18 1995
***************
*** 202,207 ****
--- 202,209 ----
  #include <sys/stat.h>
  #include <errno.h>
  
+ #include "me.h"   /* for defination of null_decode and text_decode */
+ 
  #ifdef I_TIME
  #  include <time.h>
  #endif
***************
*** 382,388 ****
  
  	char *cp;
  
! 	sprintf(tempfn, "%s%s", default_temp, temp_mbox);
  	if((cp = rindex(mbox, '/')) != NULL) {
  	  cp++;
  	  if (strcmp(cp, "mbox") == 0 || strcmp(cp, "mailbox") == 0 ||
--- 384,390 ----
  
  	char *cp;
  
! 	sprintf(tempfn, "%s/%s", home, temp_mbox);
  	if((cp = rindex(mbox, '/')) != NULL) {
  	  cp++;
  	  if (strcmp(cp, "mbox") == 0 || strcmp(cp, "mailbox") == 0 ||
***************
*** 416,427 ****
  	  subj = 0, copyit = 0, in_header = FALSE;
  	int count_x, count_y = 17, err;
  	int in_to_list = FALSE, forwarding_mail = FALSE, first_line = TRUE,
! 	  content_length_found = FALSE;
  
  	static int first_read = 0;
  #ifdef MMDF
          int newheader = 0;
  #endif /* MMDF */
  
  	if (folder_type == SPOOL) {
  	  lock(INCOMING);	/* ensure no mail arrives while we do this! */
--- 418,433 ----
  	  subj = 0, copyit = 0, in_header = FALSE;
  	int count_x, count_y = 17, err;
  	int in_to_list = FALSE, forwarding_mail = FALSE, first_line = TRUE,
! 	  content_length_found = FALSE, in_cc_list = FALSE;
  
  	static int first_read = 0;
  #ifdef MMDF
          int newheader = 0;
  #endif /* MMDF */
+ #ifdef MIME
+ 	int is_content = 0;
+ 	char content_type[VERY_LONG_STRING];
+ #endif
  
  	if (folder_type == SPOOL) {
  	  lock(INCOMING);	/* ensure no mail arrives while we do this! */
***************
*** 669,674 ****
--- 675,683 ----
  			  count);
  		  leave(0);
  		}
+ #ifdef MIME
+ 		mime_t_zero (&h->mime_rec);
+ #endif
  		headers[count] = h;
  	      }
  
***************
*** 685,705 ****
  		current_header->content_length = -1; /* not found yet */
  		current_header->index_number = count+1;
  		content_length_found = FALSE;
- 		/* set default status - always 'visible'  - and
- 		 * if a spool file, presume 'new', otherwise
- 		 * 'read', for the time being until overridden
- 		 * by a Status: header.
- 		 * We presume 'read' for nonspool mailfile messages
- 		 * to be compatible messages stored with older versions of elm,
- 		 * which didn't support a Status: header.
- 		 */
- 		if(folder_type == SPOOL)
- 		  current_header->status = VISIBLE | NEW | UNREAD;
- 		else
- 		  current_header->status = VISIBLE;
  
  		strcpy(current_header->subject, "");	/* clear subj    */
  		strcpy(current_header->to, "");		/* clear to    */
  		strcpy(current_header->mailx_status, "");	/* clear status flags */
  		strcpy(current_header->time_menu, "");	/* clear menu date */
  		strcpy(current_header->messageid, "<no.id>"); /* set no id into message id */
--- 694,705 ----
  		current_header->content_length = -1; /* not found yet */
  		current_header->index_number = count+1;
  		content_length_found = FALSE;
  
+ 		current_header->status = VISIBLE | NEW | UNREAD;
+ 
  		strcpy(current_header->subject, "");	/* clear subj    */
  		strcpy(current_header->to, "");		/* clear to    */
+ 		strcpy(current_header->cc, "");
  		strcpy(current_header->mailx_status, "");	/* clear status flags */
  		strcpy(current_header->time_menu, "");	/* clear menu date */
  		strcpy(current_header->messageid, "<no.id>"); /* set no id into message id */
***************
*** 706,712 ****
  		current_header->encrypted = 0;		/* clear encrypted */
  		current_header->exit_disposition = UNSET;
  		current_header->status_chgd = FALSE;
! 
  		/* Set the number of lines for the _preceding_ message,
  		 * but only if there was a preceding message and
  		 * only if it wasn't calculated already. It would
--- 706,717 ----
  		current_header->encrypted = 0;		/* clear encrypted */
  		current_header->exit_disposition = UNSET;
  		current_header->status_chgd = FALSE;
! #ifdef MIME
! 		mime_t_clear (&current_header->mime_rec);
! #endif
! #ifdef USE_PGP
! 		current_header->pgp = 0;
! #endif
  		/* Set the number of lines for the _preceding_ message,
  		 * but only if there was a preceding message and
  		 * only if it wasn't calculated already. It would
***************
*** 751,756 ****
--- 756,762 ----
  		strcpy(current_header->from, "");		/* clear from    */
  		strcpy(current_header->subject, "");	/* clear subj    */
  		strcpy(current_header->to, "");		/* clear to    */
+ 		strcpy(current_header->cc, "");
  		strcpy(current_header->time_zone, "");	/* clear time zone name */
  		strcpy(current_header->time_menu, "");	/* clear menu date */
  		strcpy(current_header->mailx_status, "");	/* clear status flags */
***************
*** 758,764 ****
  		current_header->encrypted = 0;		/* clear encrypted */
  		current_header->exit_disposition = UNSET;
  		current_header->status_chgd = FALSE;
! 
  		/* Set the number of lines for the _preceding_ message,
  		 * but only if there was a preceding message and
  		 * only if it wasn't calculated already. It would
--- 764,775 ----
  		current_header->encrypted = 0;		/* clear encrypted */
  		current_header->exit_disposition = UNSET;
  		current_header->status_chgd = FALSE;
! #ifdef MIME
! 		mime_t_clear (&current_header->mime_rec);
! #endif
! #ifdef USE_PGP
! 		current_header->pgp = 0;
! #endif
  		/* Set the number of lines for the _preceding_ message,
  		 * but only if there was a preceding message and
  		 * only if it wasn't calculated already. It would
***************
*** 822,832 ****
  		  Raw(OFF);
  		  printf(catgets(elm_msg_cat, ElmSet, ElmCouldntSeekBytesIntoTempFile,
  		     "\nCouldn't seek %ld bytes into temp file.\n"),
! 		     mailfile_size);
  		  printf("** %s. **\n", error_description(err));
  		  dprint(1, (debugfile,
! 	"Error: Couldn't seek temp file %s: (offset %ld) Errno %s (%s)\n",
! 		     cur_tempfolder, mailfile_size, error_description(err), "reset - read_headers"));
  		  emergency_exit();
  		}
  	      fbytes = content_start;
--- 833,843 ----
  		  Raw(OFF);
  		  printf(catgets(elm_msg_cat, ElmSet, ElmCouldntSeekBytesIntoTempFile,
  		     "\nCouldn't seek %ld bytes into temp file.\n"),
! 			 mailfile_size);
  		  printf("** %s. **\n", error_description(err));
  		  dprint(1, (debugfile,
! 			     "Error: Couldn't seek temp file %s: (offset %ld) Errno %s (%s)\n",
! 			     cur_tempfolder, mailfile_size, error_description(err), "reset - read_headers"));
  		  emergency_exit();
  		}
  	      fbytes = content_start;
***************
*** 835,843 ****
  	      current_header->content_length = -1; /* mark as if not found yet */
  	      line_bytes = 0;
  	    }
! 	  }
  
! 	  if (in_header == TRUE) {
  #ifdef MMDF
  	    if (strcmp(buffer, MSG_SEPARATOR) == 0) {
  	      /*
--- 846,969 ----
  	      current_header->content_length = -1; /* mark as if not found yet */
  	      line_bytes = 0;
  	    }
! 	    }
  
! 	    /* Handling of continuation lines must be done before parsing
! 	     * next line!   or it don't work!   
! 	     *
! 	     * Another bug is that there can happen buffer overflow....
! 	     *   (well perhaps I can do quick fix for that)
! 	     *
! 	     *                              - K E H <hurtta@dionysos.FMi.FI>
! 	     */
! 
! 	    if (in_to_list == TRUE) {
! 	      dprint(12,(debugfile,"in_to_list; in_header=%d, buffer=%s\n",
! 			 in_header,buffer));
! 	      if (in_header && whitespace(buffer[0])) {
! 		strcat(current_header->to, " ");
! 		if ((c = index(buffer, '\n')) != NULL)
! 		  *c = '\0';
! 		c = buffer;
! 		while (*c && isspace(*c)) ++c;
! 		if (strlen(current_header->to) + strlen(c)
! 		    < sizeof(current_header->to) - 3)
! 		  strcat(current_header->to, c);
! 		else
! 		  in_to_list = FALSE;
! 	      } else in_to_list = FALSE;
! 	    } 
! 	    if (in_cc_list == TRUE) {
! 	      dprint(12,(debugfile,"in_cc_list; in_header=%d, buffer=%s\n",
! 			 in_header,buffer));
!               if (in_header && whitespace(buffer[0])) {
! 		strcat(current_header->cc, " ");
! 		if ((c = index(buffer, '\n')) != NULL)
! 		  *c = '\0';
! 		c = buffer;
! 		while (*c && isspace(*c)) ++c;
! 		if (strlen(current_header->cc) + strlen(c)
! 		    < sizeof(current_header->cc) - 3)
! 		  strcat(current_header->cc, c);
! 		else
! 		  in_cc_list = FALSE;
! 	      } else
! 		in_cc_list = FALSE;
! 	    }
! #ifdef MIME
! 	    if (is_content) {
! 	      dprint(12,(debugfile,"is_content; in_header=%d, buffer=%s\n",
! 			 in_header,buffer));
!               if (in_header && whitespace(buffer[0])) {
! 		int l = strlen(buffer);
! 		int l1 = strlen(content_type);
! 		buffer[0] = ' ';
! 		if (l > 1 && buffer[l-2] == '\r' && buffer[l-1] == '\n')
! 		  buffer[l-2] = 0;
! 		if (buffer[l-1] == '\n')
! 		  buffer[l-1] = 0;
! 
!                 strfcpy (content_type+l1, buffer,sizeof(content_type)-l1);
! 		dprint(12,(debugfile,
! 			   "is_content=%d,l=%d,l1=%d => content_type=%s\n",
! 			    is_content,l,l1,content_type));
!               }
!               else {
! 		char buf [STRING];
! 		dprint(12,(debugfile,
! 			   "is_content=%d => content_type=%s\n",
! 			   is_content,content_type));
! 		if (is_content == 1) {
! 		  char *ptr = strpbrk(content_type,"/;()");
! 
! 		  if (!ptr || ';' == *ptr) {
! 		    char *ptr2;
! 		    char *tmp = content_type;
! 		    while (whitespace(*tmp))
! 		      tmp++;
! 
! 		    if (ptr)
! 		      *ptr = '\0';
! 
! 		    ptr2 = strpbrk(tmp," \t");
! 		    if (ptr2)
! 		      *ptr2 = '\0';
! 
! 		    dprint(12,(debugfile,"NOT mime's content-type: %s\n",tmp));
! 
! 		    if (istrcmp(tmp,"text")!=0) {
! 		      char buf[STRING];
! 		      current_header->mime_rec.notplain = TRUE;
! 
! 		      /* Put some 'intelligent' value */
! 		      current_header->mime_rec.type = MIME_TYPE_APPLICATION;
! 		      sprintf(buf,"X-RFC1049-%.30s",tmp);
! 		      strfcpy(current_header->mime_rec.subtype,buf,
! 			      sizeof(current_header->mime_rec.subtype));
! 		    }
! 		      
! 		    current_header->status |= PRE_MIME_CONTENT;
! 		  }
!                   else {
! 		    dprint(12,(debugfile,"MIME's content-type: %s\n",
! 			       content_type));
! 
! 		    mime_get_content (content_type, &current_header->mime_rec);
!                     if (mime_notplain(&current_header->mime_rec))
!                       current_header->mime_rec.notplain = TRUE;
! 		  }
! 		}
! 		else if (is_content == 2) {
! 		  mime_get_disposition (content_type, 
! 					&current_header->mime_rec);
! 		}
! 		is_content = 0;
!               }
! 	    }
! #endif
! 
! 	 if (in_header == TRUE) {
! 
  #ifdef MMDF
  	    if (strcmp(buffer, MSG_SEPARATOR) == 0) {
  	      /*
***************
*** 924,946 ****
  	    else if (header_cmp(buffer, "Action", NULL))
  	      current_header->status |= ACTION;
  #ifdef	MIME
  	    else if (header_cmp(buffer, MIME_HEADER_NAME, MIME_HEADER_VERSION))
  	      current_header->status |= MIME_MESSAGE;
! 	    /* Next two lines for backward compatability to old drafts */
! 	    else if (header_cmp(buffer, MIME_HEADER_NAME, MIME_HEADER_OLDVERSION))
! 	      current_header->status |= MIME_MESSAGE;
! 	    /* Next two lines for minimal support for mail generated by
! 	     * Sun's Openwindows mailtool */
! 	    else if (header_cmp(buffer, "Content-Type", "X-"))
! 	      current_header->status |= MIME_MESSAGE|MIME_NOTPLAIN;
  	    else if (header_cmp(buffer, MIME_HEADER_CONTENTTYPE, NULL)) {
! 	      if (! (current_header->status & MIME_NOTPLAIN) &&
! 		  notplain(buffer+strlen(MIME_CONTENTTYPE)))
! 		current_header->status |= MIME_NOTPLAIN;
  	    }
  	    else if (header_cmp(buffer, MIME_HEADER_CONTENTENCOD, NULL)) {
! 	      if (needs_mmdecode(buffer+strlen(MIME_CONTENTENCOD)))
! 		current_header->status |= MIME_NEEDDECOD;
  	    }
  #endif /* MIME */
  
--- 1050,1095 ----
  	    else if (header_cmp(buffer, "Action", NULL))
  	      current_header->status |= ACTION;
  #ifdef	MIME
+ 	    /* We should accept headers like:
+ 	     *    MIME-Version: (MetaSend v1.7) 1.0
+ 	     * And if version number is something other accept it but give 
+ 	     * warning when message is viewed or replied.
+ 	     * Perhaps in next version. 
+ 	     */
  	    else if (header_cmp(buffer, MIME_HEADER_NAME, MIME_HEADER_VERSION))
  	      current_header->status |= MIME_MESSAGE;
!             else if (header_cmp(buffer, MIME_HEADER_NAME, NULL))
!               current_header->status |= MIME_MESSAGE|MIME_UNSUPPORTED;
  	    else if (header_cmp(buffer, MIME_HEADER_CONTENTTYPE, NULL)) {
! 	      int l = strlen(buffer);
!               is_content = 1;   /* This is quick hack -- mime headers
! 				 * should be decoded with mime_read_header
! 				 * otherwise we duplicate code ...
! 				 *     - K E H     <hurtta@dionysos.FMI.FI>
! 				 */
! 	      if (buffer[l-2] == '\r' && buffer[l-1] == '\n')
! 		buffer[l-2] = 0;
! 	      if (buffer[l-1] == '\n')
! 		buffer[l-1] = 0;
!               strcpy (content_type, buffer + 13);
  	    }
+ 	    else if (header_cmp(buffer, "Content-Disposition", NULL)) {
+ 	      int l = strlen(buffer);
+               is_content = 2;   /* This is quick hack -- mime headers
+ 				 * should be decoded with mime_read_header
+ 				 * otherwise we duplicate code ...
+ 				 *     - K E H     <hurtta@dionysos.FMI.FI>
+ 				 */	
+ 	      if (buffer[l-2] == '\r' && buffer[l-1] == '\n')
+ 		buffer[l-2] = 0;
+ 	      if (buffer[l-1] == '\n')
+ 		buffer[l-1] = 0;
+               strcpy (content_type, buffer + 20);
+ 	    }
  	    else if (header_cmp(buffer, MIME_HEADER_CONTENTENCOD, NULL)) {
!               c = buffer + MIME_CONTENTENCOD_LEN;
!               while (*c && isspace(*c)) ++c;
!               current_header->mime_rec.encoding = check_encoding (c);
  	    }
  #endif /* MIME */
  
***************
*** 948,957 ****
  
  	    else if (header_cmp(buffer, "To", NULL)) {
  	      in_to_list = TRUE;
! 	      current_header->to[0] = '\0';	/* nothing yet */
! 	      figure_out_addressee((char *) buffer +3, 
! 				   current_header->to);
  	    }
  	    else if (header_cmp(buffer, "Status", NULL)) {
  	      strfcpy(tbuffer, buffer, sizeof(tbuffer));
  	      remove_header_keyword(tbuffer);
--- 1097,1120 ----
  
  	    else if (header_cmp(buffer, "To", NULL)) {
  	      in_to_list = TRUE;
! 	      if (current_header->to[0] != '\0')
! 		strcat(current_header->to, ", ");
! 	      if ((c = index(buffer, '\n')) != NULL)
! 		*c = '\0';
! 	      c = buffer + 3;
! 	      while (*c && isspace(*c)) ++c;
! 	      strcat(current_header->to, c);
  	    }
+ 	    else if (header_cmp(buffer, "Cc", NULL)) {
+ 	      in_cc_list = TRUE;
+ 	      if (current_header->cc[0] != '\0')
+ 		strcat(current_header->cc, ", ");
+ 	      if ((c = index(buffer, '\n')) != NULL)
+ 		*c = '\0';
+ 	      c = buffer + 3;
+ 	      while (*c && isspace(*c)) ++c;
+ 	      strcat(current_header->cc, c);
+ 	    }
  	    else if (header_cmp(buffer, "Status", NULL)) {
  	      strfcpy(tbuffer, buffer, sizeof(tbuffer));
  	      remove_header_keyword(tbuffer);
***************
*** 973,1004 ****
  		current_header->status &= ~NEW;
  		current_header->status |= UNREAD;
  	      }
  	    }
  
! 	    else if (buffer[0] == LINE_FEED || buffer[0] == '\0') {
  	      in_header = FALSE;	/* in body of message! */
- 	      in_to_list = FALSE;
  	      content_remaining = current_header->content_length;
  	      content_start = fbytes + 1;
  	      lines_start = line;
  	    }
  	    if (in_header == TRUE) {
  	       if ((!whitespace(buffer[0])) && index(buffer, ':') == NULL) {
  	        in_header = FALSE;	/* in body of message! */
- 	        in_to_list = FALSE;
  	        content_remaining = current_header->content_length;
  	        content_start = fbytes;
  	        lines_start = line;
  	      }
  	    }
! 	    if (in_to_list == TRUE) {
! 	      if (whitespace(buffer[0]))
! 	        figure_out_addressee(buffer, current_header->to);
! 	      else in_to_list = FALSE;
  	    }
  	  }
- 	  if (in_header == FALSE && first_word(buffer, START_ENCODE))
- 	    current_header->encrypted = 1;
  	  fbytes += (long) line_bytes;
  	  content_remaining -= (long) line_bytes;
  	}
--- 1136,1252 ----
  		current_header->status &= ~NEW;
  		current_header->status |= UNREAD;
  	      }
+               if (index(current_header->mailx_status, 'r') != NULL)
+                 current_header->status |= REPLIED;
  	    }
  
! 	    else if (buffer[0] == LINE_FEED || buffer[0] == '\0' ||
! 		     buffer[0] == '\r' && buffer[1] == '\n') {
  	      in_header = FALSE;	/* in body of message! */
  	      content_remaining = current_header->content_length;
  	      content_start = fbytes + 1;
+ 	      if (buffer[0] == '\r' && buffer[1] == '\n')
+ 		content_start = fbytes + 2;
  	      lines_start = line;
+ #ifdef MIME
+ 	      current_header->mime_rec.offset = ftell (mailfile);
+ #endif
  	    }
  	    if (in_header == TRUE) {
  	       if ((!whitespace(buffer[0])) && index(buffer, ':') == NULL) {
  	        in_header = FALSE;	/* in body of message! */
  	        content_remaining = current_header->content_length;
  	        content_start = fbytes;
  	        lines_start = line;
+ #ifdef MIME
+ 	      current_header->mime_rec.offset = content_start;
+ #endif
  	      }
  	    }
! 	  }
! 	  if (in_header == FALSE) {
! 	    if (first_word(buffer, START_ENCODE))
! 	      current_header->encrypted = 1;
! #ifdef USE_PGP
! 	    if (strncmp(buffer, "-----BEGIN PGP", 14) == 0) {
! #ifdef MIME
! 	      char pgpbuffer[STRING];
! 
! 	      /* Text/plain can be converted to application/pgp.  There will
! 	       * a possible loss of surrounding text, but there is no way
! 	       * to get around this without having the sender use the proper
! 	       * MIME type.
! 	       */
! 	      if (current_header->mime_rec.type == MIME_TYPE_TEXT &&
! 		  (istrcmp(current_header->mime_rec.subtype,"plain")==0)) {
! 		current_header->mime_rec.type = MIME_TYPE_APPLICATION;
! 		strcpy(current_header->mime_rec.subtype, "pgp");
! 		if (current_header->mime_rec.type_opts)
! 		  free(current_header->mime_rec.type_opts);
! 	      }
! #endif
! 	      if (strncmp(buffer + 15, "PUBLIC", 6) == 0) {
! 		current_header->pgp |= PGP_PUBLIC_KEY;
! #ifdef MIME
!                 if (current_header->mime_rec.type_opts) {
! 		  if (!mime_get_param("format",pgpbuffer,current_header->mime_rec.type_opts,sizeof(pgpbuffer))) {
! 		    strcpy(pgpbuffer,current_header->mime_rec.type_opts);
! 		    add_parameter(pgpbuffer, "format",
! 				  "keys-only", sizeof(pgpbuffer), FALSE);
! 		    current_header->mime_rec.type_opts = strmcpy(current_header->mime_rec.type_opts, pgpbuffer);
! 		  }
! 		}
! 		else {
! 		  pgpbuffer[0] = '\0';
! 		  add_parameter(pgpbuffer,"format","keys-only",
! 				sizeof(pgpbuffer), FALSE);
! 		  current_header->mime_rec.type_opts = strmcpy(current_header->mime_rec.type_opts, pgpbuffer);
! 		}
! #endif
!               }
! 	      else if (strncmp(buffer + 15, "SIG", 3) == 0) {
! 		current_header->pgp |= PGP_SIGNED_MESSAGE;
! #ifdef MIME
! 		if (current_header->mime_rec.type_opts) {
! 		  if (!mime_get_param("x-action",pgpbuffer,current_header->mime_rec.type_opts,sizeof(pgpbuffer))) {
! 		    strcpy(pgpbuffer,current_header->mime_rec.type_opts);
! 		    add_parameter(current_header->mime_rec.type_opts,
! 				  "x-action", "sign",
! 				  sizeof(current_header->mime_rec.type_opts),
! 				  FALSE);
! 		    current_header->mime_rec.type_opts = strmcpy(current_header->mime_rec.type_opts, pgpbuffer);
! 		  }
! 		}
! 		else {
! 		  pgpbuffer[0] = '\0';
! 		  add_parameter(pgpbuffer,"x-action","sign",
! 				sizeof(pgpbuffer), FALSE);
! 		  current_header->mime_rec.type_opts = strmcpy(current_header->mime_rec.type_opts, pgpbuffer);
! 		}
! #endif
!               }
! 	      else {
! 		current_header->pgp |= PGP_MESSAGE;
! #ifdef MIME
! 		if (current_header->mime_rec.type_opts) {
! 		  if (!mime_get_param("x-action",pgpbuffer,current_header->mime_rec.type_opts,sizeof(pgpbuffer))) {
! 		    strcpy(pgpbuffer,current_header->mime_rec.type_opts);
! 		    add_parameter(pgpbuffer, "x-action", "encrypt",
! 				  sizeof(pgpbuffer), FALSE);
! 		    current_header->mime_rec.type_opts = strmcpy(current_header->mime_rec.type_opts, pgpbuffer);
! 		  }
! 		}
! 		else {
! 		  pgpbuffer[0] = '\0';
! 		  add_parameter(pgpbuffer,"x-action","sign",
! 				sizeof(pgpbuffer), FALSE);
! 		  current_header->mime_rec.type_opts = strmcpy(current_header->mime_rec.type_opts, pgpbuffer);
! 		}
! #endif
! 	      }
  	    }
+ #endif /* USE_PGP */
  	  }
  	  fbytes += (long) line_bytes;
  	  content_remaining -= (long) line_bytes;
  	}

diff -c elm-2.4pl24/src/pattern.c elm-2.4pl24me8/src/pattern.c
*** elm-2.4pl24/src/pattern.c	Sun May 15 16:05:20 1994
--- elm-2.4pl24me8/src/pattern.c	Fri Jul  7 19:48:24 1995
***************
*** 179,184 ****
--- 179,187 ----
  
  	strcpy(meta_pattern, shift_lower(meta_pattern));   /* lowercase it */
  
+ 	if (function == DELETED && strcmp(meta_pattern, "tagged") == 0)
+           return(DeleteTagged());
+ 
  	if (inalias) {
  	  for (i = 0; i < message_count; i++) {
  	    if (name_matches(i, meta_pattern) ||
***************
*** 201,206 ****
--- 204,212 ----
  	  }
  	}
  	else {
+           if (strcmp(meta_pattern, "all") == 0)
+             count = DoAll(function);
+           else
  	  for (i = 0; i < message_count; i++) {
  	    if (from_matches(i, meta_pattern) ||
  	        subject_matches(i, meta_pattern)) {
***************
*** 394,400 ****
  	result = get_alias_address(aliases[message_number]->alias,TRUE,&dummy);
  	if (result != NULL)
  		return(in_string(shift_lower(result), pat) );
! 	return(NULL);
  }
  
  match_in_message(pat)
--- 400,406 ----
  	result = get_alias_address(aliases[message_number]->alias,TRUE,&dummy);
  	if (result != NULL)
  		return(in_string(shift_lower(result), pat) );
! 	return(0);
  }
  
  match_in_message(pat)
***************
*** 451,454 ****
--- 457,480 ----
  	}
  
  	return(0);
+ }
+ 
+ /* This will tag, delete, or undelete all or the currently visible messages */
+ DoAll(func)
+ int func;
+ {
+         int i, count = 0;
+ 
+         for (i=0; i < message_count; i++)
+                 if (!selected ||
+                     (selected && ison(headers[i]->status,VISIBLE))) {
+                         if (func == TAGGED)
+                                 headers[i]->status |= TAGGED;
+                         else if (func == DELETED)
+                                 headers[i]->status |= DELETED;
+                         else if (func == UNDELETE)
+                                 headers[i]->status &= ~DELETED;
+                         ++count;
+                 }
+         return(count);
  }

diff -c /dev/null elm-2.4pl24me8/src/pgp.c
*** /dev/null	Thu Sep 21 15:27:01 1995
--- elm-2.4pl24me8/src/pgp.c	Thu Sep 21 13:25:23 1995
***************
*** 0 ****
--- 1,627 ----
+ #include "headers.h"
+ #include "me.h"
+ 
+ #ifdef USE_PGP
+ #include <sys/time.h>
+ #include "menu.h"
+ 
+ /* these are defined in mailmsg1.c */
+ extern char expanded_to[VERY_LONG_STRING];
+ extern char expanded_cc[VERY_LONG_STRING];
+ extern char expanded_bcc[VERY_LONG_STRING];
+ extern char subject[VERY_LONG_STRING];
+ 
+ extern int errno;
+ 
+ int pgp_keeppassfor = 300; /* 5 minutes */
+ static char pgp_passphrase[STRING];
+ static int pgp_expires;
+ 
+ /* the column in which the userid begins in the 'pgp -kv' command output */
+ #define PGP_USERID_OFFSET 30
+ 
+ void
+ pgp_void_passphrase ()
+ {
+   int i;
+ 
+   for (i = 0 ; i < STRING ; i++)
+     pgp_passphrase[i] = '\0';
+   pgp_expires = 0;
+   return;
+ }
+ 
+ static int
+ QueryExpirePassphrase()
+ {
+   struct timeval now;
+ 
+   /* negative implies never expire */
+   if (pgp_keeppassfor < 0)
+     return(0);
+   gettimeofday(&now, 0);
+   if (now.tv_sec < pgp_expires) {
+     pgp_expires = now.tv_sec + pgp_keeppassfor;
+     return(0);
+   }
+   pgp_void_passphrase ();
+   return(1);
+ }
+ 
+ /* 'n' is the key we are looking for.  'k' is the list of possible matches
+    which contains 'len' entries.  prompt the user for which key s/he really
+    wants to use. */
+ static char *
+ PGPSelectKey (n, k, len)
+ 	char *n;
+ 	char **k;
+ 	int len;
+ {
+   int i;
+   char buf[STRING];
+   menu_t menu;
+ 
+   sprintf(buf, "Multiple keys match '%s':", n);
+   MenuInit (&menu, buf, "Select key or 'q' to quit: ", 0);
+ 
+   for (i = 0; i < len; i++)
+     MenuAdd(&menu, k[i]);
+ 
+   for (;;) {
+     switch (MenuLoop(&menu)) {
+     case 'q':
+       MenuDestroy(&menu);
+       return(0);
+     case '\n':
+     case '\r':
+       MenuDestroy(&menu);
+       return(k[MenuCurrent(menu)]);
+     }
+   }
+   /* not reached */
+ }
+ 
+ static int
+ GetPGPKey (name, target)
+ 	char *name;
+ 	char *target;
+ {
+   /* given "name", return the string to use during the pgp call to specify
+      the key which the user means.  return -1 on error. */
+   char buf[STRING], address[STRING], *c, **keys=0, *pc, userpart[STRING];
+   int i=0, keys_len=0, keys_max=0, return_val=0, start=0;
+   FILE *p;
+ 
+   if (!name || !target)
+     return(-1);
+ 
+   if (index(name, '@') == NULL && index(name, '(') == NULL && index(name, '<') == NULL) {
+     /* this is either just a username, or someone's real name.  in either
+        case it only needs to be checked once. */
+ 
+     strcpy(address, name);
+     i = 2;
+   }
+   else {
+     get_address_from (name, address);
+   
+     i=0;
+     while (address[i] && address[i] != '@') {
+       userpart[i] = address[i];
+       i++;
+     }
+     userpart[i] = '\0';
+ 
+     i = 0;
+   }
+   c = address;
+ 
+   /* the following loop first checks to see if any keys with the full
+      address, or real name, or finally the username exist */
+ 
+   for (;;) {
+     sprintf(buf, "%s +verbose=0 -kv '%s'", PGP_PATH, c);
+     p = popen(buf, "r");
+     if (!p)
+       return(-1);
+     while (fgets(buf, STRING, p) != NULL) {
+       /* see if we've reached the beginning of the key listings... */
+       if (!start && strncmp(buf, "pub", 3)==0)
+ 	  start=1;
+ 
+       if (start) {
+ 
+ 	/* if we've read all the keys, stop here */
+ 	if (buf[0] != 'p' && buf[0] != ' ')
+ 	  break;
+ 
+ 	if (keys_len == keys_max)
+ 	  keys = (char**)DynamicArray(keys, sizeof(char*), &keys_max, 5);
+ 	
+ 	pc = rindex(buf, '\n');
+ 	if (!pc) /* this shouldn't happen! */
+ 	  continue;
+ 	*pc = '\0';
+ 	
+ 	pc = buf + PGP_USERID_OFFSET;
+ 	keys[keys_len] = (char*)safe_malloc(sizeof(char)*(strlen(pc)+1));
+ 	strcpy(keys[keys_len], pc);
+ 	++keys_len;
+       }
+     }
+     pclose(p);
+     if (keys_len > 0 || i > 1)
+       break;
+     else {
+       if (i == 0) {
+ 	get_real_name(name, address);
+ 
+ 	/* if there was no real name, go on to the userpart check */
+ 	if (strcmp(name, address) == 0) {
+ 	  c = userpart;
+ 	  i++;
+ 	}
+       } else if (i == 1)
+ 	c = userpart;
+       i++;
+     }
+   }
+ 
+   if (keys_len == 1) /* perfect match! */
+     strcpy(target,keys[0]);
+   else if (keys_len > 1) { /* ask the user which, if any, s/he meant */
+     c = PGPSelectKey(name, keys, keys_len);
+     if (c)
+       get_address_from(c, target);
+     else {
+       target[0] = '\0';
+       return_val = -1;
+     }
+   } else
+     return_val = -1;
+ 
+   DestroyDynamicArray(keys);
+ 
+   return(return_val);
+ }
+ 
+ static int
+ pgp_call (filename, opts)
+ 	char *filename;
+ 	int opts;
+ {
+   char tobuf[VERY_LONG_STRING] = {0};
+ 
+   if (opts & PGP_MESSAGE) {
+     /* build up the list of recipients */
+     strcpy(tobuf, expanded_to);
+     if (expanded_cc[0] != '\0') {
+       strcat(tobuf, ", ");
+       strcat(tobuf, expanded_cc);
+     }
+     if (expanded_bcc[0] != '\0') {
+       strcat(tobuf, ", ");
+       strcat(tobuf, expanded_bcc);
+     }
+     /* If the message is to be encrypted, give the user a chance to edit
+      * the list of ids to encrypt to since the given address may not always
+      * be correct.
+      */
+     PutLine0 (LINES-2, 0, "To: ");
+     if (optionally_enter (tobuf, LINES-2, 4, TRUE, FALSE) < 0 || tobuf[0] == '\0')
+       return FALSE;
+   }
+   return (pgp_encrypt (filename, tobuf, opts));
+ }
+ 
+ int
+ pgp_encrypt (filename, ids, opts)
+ 	char *filename, *ids;
+ 	int opts;
+ {
+   int i, id_len=0, id_max=0, st, usepgppass=FALSE, fd[2];
+   char
+     keyid[STRING], buf[VERY_LONG_STRING], buf2[STRING], **id_array=0, *c,
+     *p;
+   
+   dprint (2, (debugfile, "pgp_encrypt(): ids=\"%s\", encrypt=%s, sign=%s\n", ids, opts & PGP_MESSAGE ? "TRUE" : "FALSE", opts & PGP_SIGNED_MESSAGE ? "TRUE" : "FALSE"));
+ 
+   p = ids;
+   /* If this message is to be encrypted, look up the keys of all the
+      recipients */
+   if (opts & PGP_MESSAGE) {
+     i=0;
+     while ((c = strtok(p, ",")) != NULL) {
+       if (GetPGPKey(c, keyid) == -1) {
+ 	error1("Couldn't find key matching '%s'!",c);
+ 	return FALSE;
+       }
+       if (id_len == id_max)
+ 	id_array = (char**)DynamicArray(id_array, sizeof(char*), &id_max, 25);
+       id_array[id_len] = 
+ 	(char*)safe_malloc((strlen(keyid) + 1) * sizeof(char));
+       strcpy(id_array[id_len], keyid);
+       id_len++;
+       p=NULL;
+     }
+   }
+ 
+   if ((opts & PGP_SIGNED_MESSAGE) && pgp_keeppass && pgp_goodPassphrase()) {
+     usepgppass = TRUE;
+     pipe(fd);
+   }
+ 
+   /* build up the command */
+   buf[0] = '\0';
+   if (usepgppass) {
+     sprintf(buf2, "PGPPASSFD=%d; export PGPPASSFD; ", fd[0]);
+     strcat(buf, buf2);
+   }
+   strcat(buf, PGP_PATH);
+   if (auto_cc)
+     strcat(buf, " +encrypttoself=on");
+   if (usepgppass)
+     strcat(buf, " +batchmode");
+   if (opts & PGP_SIGNED_MESSAGE)
+     strcat(buf," +clearsig=on");
+ 
+   strcat(buf, " +verbose=0 -atw");
+ 
+   if (opts & PGP_SIGNED_MESSAGE)
+     strcat(buf, "s");
+   if (opts & PGP_MESSAGE)
+     strcat(buf, "e");
+ 
+   strcat(buf, " ");
+   strcat(buf, filename);
+ 
+   /* add all of the userid's protected inside quotes to prevent shell
+      no-no's */
+   if (opts & PGP_MESSAGE)
+     for (i=0; i<id_len; i++) {
+       strcat(buf, " '");
+       strcat(buf, id_array[i]);
+       strcat(buf, "'");
+     }
+   DestroyDynamicArray(id_array); /* don't need this any more... */
+ 
+   if (usepgppass) {
+ /*    strcat(buf, " > /dev/null 2>&1");/**/
+     Raw(OFF);
+     ClearScreen();/**/
+ 
+     write(fd[1], pgp_passphrase, strlen(pgp_passphrase));
+     write(fd[1], "\n", 1); /* pgp expects this as a line terminator! */
+     close(fd[1]);
+   }
+   else {
+     Raw(OFF);
+     ClearScreen();
+     printf("Executing: %s\n\n", buf);
+   }
+   st = system_call(buf, 0);
+ /*  if (!usepgppass)/**/
+     Raw(ON);
+   
+   if (st == 0) { /* pgp returns zero upon success */
+     /* copy the file into it's final destination */
+     sprintf(buf, "%s.asc", filename);
+ #ifdef RENAME
+     if (rename(buf, filename) < 0) {
+       error ("Could not rename temporary file!");
+       return FALSE;
+     }
+ #else
+     if (link(buf, filename) < 0) {
+       Centerline(LINES, "Could not create link to temporary file!");
+       return FALSE;
+     }
+     /* this is not fatal, but a warning should be given */
+     if (unlink(buf) < 0)
+       error ("Could not unlink temporary file!");
+ #endif
+   }
+   else {
+     error ("pgp returned a non-zero value!");
+     if (pgp_keeppass)
+       pgp_void_passphrase ();
+     return FALSE;
+   }
+   return opts;
+ }
+ 
+ int
+ pgp_menu (filename)
+ 	char *filename;
+ {
+   int update = TRUE;
+ 
+   for (;;) {
+     if (update) {
+       MoveCursor (LINES-3, 0);
+       CleartoEOS ();
+       Centerline (LINES-2, "e)ncrypt, s)ign, b)oth encrypt and sign");
+       PutLine0 (LINES-3, 0, "pgp: ");
+       update = FALSE;
+     }
+     switch(ReadCh()) {
+     case 'e':
+       Write_to_screen("Encrypt", 0);
+       return (pgp_call (filename, PGP_MESSAGE));
+     case 's':
+       Write_to_screen("Sign", 0);
+       return (pgp_call (filename, PGP_SIGNED_MESSAGE));
+     case 'b':
+       Write_to_screen("Sign and Encrypt", 0);
+       return (pgp_call (filename, PGP_MESSAGE | PGP_SIGNED_MESSAGE));
+     case '\n':
+     case '\r':
+       return FALSE;
+     case ctrl('L'):
+       update = 1;
+     }
+   }
+   /* not reached */
+ }
+ 
+ int
+ pgp_mail_public_key ()
+ {
+   char userid[SLEN], pgpkey[SLEN], tmpfil[STRING], cmd[STRING], subj[STRING];
+ 
+   userid[0] = '\0';
+   pgpkey[0] = '\0';
+   PutLine0(LINES-2, 0, "Enter userid of public key: ");
+   CleartoEOS ();
+   if (optionally_enter(userid, LINES-2, 28, FALSE, FALSE) != 0)
+     return(0);
+   if (GetPGPKey(userid, pgpkey) < 0) {
+     Centerline(LINES, "Sorry, couldn't find that userid.");
+     ClearLine(LINES-2);
+     return(0);
+   }
+   sprintf(tmpfil, "%s/elm.%d", temp_dir, getpid());
+   sprintf(cmd, "%s +verbose=0 -kxa '%s' %s > /dev/null 2>&1", PGP_PATH, pgpkey, tmpfil);
+   if (system_call(cmd, 0) == 0) 
+     sprintf(included_file, "%s.asc", tmpfil);
+   else {
+     ClearLine(LINES);
+     Centerline(LINES, "pgp returned a non-zero value!");
+     return(TRUE);
+   }
+ 
+   /* set the default subject for this message */
+   sprintf(subj, "PGP public key for %s", pgpkey);
+ 
+   pgp_status = PGP_PUBLIC_KEY;
+ 
+   /* Now send the message off! */
+   send_msg ("", "", subj, FALSE, allow_forms, FALSE);
+ 
+   unlink (included_file); /* make sure to clean up. */
+   included_file[0] = '\0';
+   pgp_status = 0; /* reset */
+   return(TRUE);
+ }
+ 
+ static int
+ GetPassphrase ()
+ {
+   struct timeval now;
+ 
+   PutLine0(LINES-2, 0, "Please enter your passphrase: ");
+   CleartoEOS();
+   if (optionally_enter(pgp_passphrase, LINES-2, 30, FALSE, TRUE) != 0)
+     return(0);
+   gettimeofday(&now, 0);
+   if (pgp_keeppassfor > 0)
+     pgp_expires = now.tv_sec + pgp_keeppassfor;
+   return(pgp_passphrase[0] != '\0');
+ }
+ 
+ int
+ pgp_goodPassphrase()
+ {
+   if (pgp_passphrase[0] == '\0' || QueryExpirePassphrase())
+     return(GetPassphrase());
+   else
+     return(1);
+ }
+ 
+ /* opens up a PGP process as a child and returns its stdin and stdout */
+ int
+ pgp_decrypt_init (fpin, fpout, opts)
+ FILE **fpin, **fpout;
+ int opts; /* PGP_MESSAGE or PGP_SIGNED_MESSAGE */
+ {
+   int pgp_child_in[2];
+   int pgp_child_out[2];
+   int passpipe[2];
+   int usepass=FALSE;
+   int fork_ret;
+   char cmd[STRING];
+ 
+   dprint (2, (debugfile, "pgp_descrypt_init() called with opts=%d\n", opts));
+ 
+   if (pipe(pgp_child_in) == -1)
+     return(-1);
+   if (pipe(pgp_child_out) == -1)
+     return(-1);
+   
+   if ((opts & PGP_MESSAGE) && pgp_keeppass) {
+     if (pipe(passpipe) == -1) {
+       close(pgp_child_in[0]);
+       close(pgp_child_out[0]);
+       close(pgp_child_in[1]);
+       close(pgp_child_out[1]);
+       return(-1);
+     }
+     usepass = TRUE;
+   }
+   dprint (3, (debugfile, "usepass = %d.\n", usepass));
+ 
+   Raw(OFF);
+   if ((fork_ret = fork()) == 0) {
+     close (pgp_child_in[1]);
+     close (0);
+     dup (pgp_child_in[0]);
+     close (pgp_child_in[0]);
+     
+     close (pgp_child_out[0]);
+     close (1);
+     dup (pgp_child_out[1]);
+     close (pgp_child_out[1]);
+     
+     /* build up the command */
+     if (usepass) {
+       close (passpipe[1]);
+       sprintf (cmd, "PGPPASSFD=%d; export PGPPASSFD; ",
+ 	       passpipe[0]);
+     }
+     else
+       cmd[0] = '\0';
+     strcat(cmd,PGP_PATH);
+     strcat(cmd," -f +verbose=0");
+     if (usepass || opts == PGP_SIGNED_MESSAGE)
+       strcat(cmd, " +batchmode");
+     _exit (system_call(cmd,0));	
+   }
+   
+   close (pgp_child_in[0]);
+   close (pgp_child_out[1]);
+   
+   /* now send the passphrase if needed */
+   if (usepass) {
+     dprint(3,(debugfile,"pgp_decrypt_init: sending pgp passphrase.\n"));
+     close (passpipe[0]);
+     write (passpipe[1], pgp_passphrase, strlen(pgp_passphrase));
+     write (passpipe[1], "\n", 1);
+     close (passpipe[1]);
+   }
+   
+   if ((*fpin = fdopen(pgp_child_out[0], "r")) == 0) {
+     Raw(ON);
+     return(-1);
+   }
+   if ((*fpout = fdopen(pgp_child_in[1], "w")) == 0) {
+     Raw(ON);
+     return(-1);
+   }
+   
+   return(fork_ret);
+ }
+ 
+ int
+ pgp_extract_public_key ()
+ {
+   char tempfile[STRING], buf[STRING];
+   FILE *fpout;
+ 
+   sprintf(tempfile,"%selm.%d",temp_dir,getpid());
+   fpout=fopen(tempfile,"w");
+   if (!fpout) {
+     error1("Could not open temp file %s for writing!", tempfile);
+     return FALSE;
+   }
+   copy_message("",fpout,0);
+   fclose(fpout);
+   ClearScreen();
+   Raw(OFF);
+   sprintf(buf,"%s +verbose=0 %s", PGP_PATH, tempfile);
+   printf("Executing: %s\n\n", buf);
+   system_call(buf, 0);
+   PressAnyKeyToContinue();
+   Raw(ON);
+   unlink(tempfile);
+   return TRUE;
+ }
+ 
+ #ifdef MIME
+ void
+ mime_pgp_decode (m, s)
+      mime_t *m;
+      state_t *s;
+ {
+   FILE *pgpin, *pgpout;
+   int len, raw, opts = 0, length = m->length;
+   char buffer[VERY_LONG_STRING] = {0};
+   
+   /* See if we are in Raw mode so that we can return to this state
+    * after calling PGP.
+    */
+   raw = RawState();
+ 
+   if (m->type_opts) {
+     if (mime_get_param("format", buffer, m->type_opts, sizeof(buffer))) {
+       if (istrcmp (buffer, "keys-only") ==  0)
+ 	opts = PGP_PUBLIC_KEY;
+     }
+     if (! opts) {
+       if (mime_get_param("x-action", buffer, m->type_opts, sizeof(buffer))) {
+ 	if (istrcmp(buffer, "encryptsign") == 0)
+ 	  opts = PGP_MESSAGE | PGP_SIGNED_MESSAGE;
+ 	else if (istrcmp(buffer, "encrypt") == 0)
+ 	  opts = PGP_MESSAGE;
+ 	else if (istrcmp(buffer, "sign") == 0)
+ 	  opts = PGP_SIGNED_MESSAGE;
+       }
+     }
+   }
+   if (!opts)
+     /* Assume the worst case... */
+     opts = PGP_MESSAGE;
+   dprint(2, (debugfile, "mime_pgp_decode: opts=%d\n", opts));
+ 
+   /* Tell the user why they are waiting */
+   if (opts & PGP_MESSAGE) {
+     if (raw)
+       error("Decrypting message...");
+     else
+       Write_to_screen("\nDecrypting message...\n", 0);
+   }
+   else if (opts & PGP_SIGNED_MESSAGE) {
+     if (raw)
+       error("Checking signature...");
+     else
+       Write_to_screen("\nChecking signature...\n", 0);
+   }
+   
+   if (opts & PGP_PUBLIC_KEY)
+     strcpy (buffer, "(** This message contains PGP public key(s)");
+   else {
+     if (opts & PGP_MESSAGE)
+       strcpy (buffer, "(** This message is PGP encrypted");
+     if (opts & PGP_SIGNED_MESSAGE) {
+       if (buffer[0] == '\0')
+ 	strcpy (buffer, "(** This message is PGP signed");
+       else
+ 	strcat (buffer, " and signed");
+     }
+   }
+   strcat (buffer, " **)\n\n");
+   state_puts (buffer, s);
+ 	
+   if (pgp_decrypt_init (&pgpout, &pgpin, opts) == -1) {
+     state_puts ("[Internal error while calling PGP!]\n", s);
+     if (raw)
+       Raw(ON);
+     return;
+   }
+ 
+   while (length > 0) {
+     len = mail_gets (buffer, sizeof(buffer), s->fpin);
+     if (len < 1)
+       break;
+     fputs (buffer, pgpin);
+     length -= len;
+   }
+   fclose (pgpin);
+   while ((len = mail_gets (buffer, sizeof(buffer), pgpout)) > 0)
+     state_puts (buffer, s);
+   fclose (pgpout);
+   PressAnyKeyToContinue();
+   if (raw)
+     Raw(ON);
+ }
+ #endif /* MIME */
+ #endif /* USE_PGP */

diff -c /dev/null elm-2.4pl24me8/src/remailer.c
*** /dev/null	Thu Sep 21 15:27:01 1995
--- elm-2.4pl24me8/src/remailer.c	Tue Sep 19 17:48:41 1995
***************
*** 0 ****
--- 1,579 ----
+ #include <sys/wait.h>
+ #include "headers.h"
+ 
+ #ifdef USE_REMAILER
+ extern int errno;
+ extern int remailing;
+ 
+ #define REMAILER_SITE "remailer-list@kiwi.cs.berkeley.edu"
+ 
+ #define BOL 1
+ #define STR 2
+ #define INT 3
+ 
+ typedef struct remailer {
+ 	char name[STRING];
+ 	char path[STRING];
+ 	unsigned int pgp : 1;
+ 	unsigned int eric : 1;
+ 	unsigned int cpunk : 1;
+ 	unsigned int penet : 1;
+ 	unsigned int latent : 1;
+ 	unsigned int hash : 1;
+ 	unsigned int special : 1;
+ 	long time;
+ 	struct remailer *next;
+ } remailer_t;
+ 
+ typedef struct remail {
+   int encrypt; /* Use encryption through the servers? */
+   char path[STRING]; /* User-defined route.  Overrides "chain". */
+   int chain; /* How many sites to chain this message through? */
+   remailer_t *info;
+   char address[STRING];
+ } remail_t;
+ 
+ static remail_t remailer;
+ 
+ #include "menu2.h"
+ static struct menu_item remail_items[] = {
+   { "R)email:", 'r', 3, BOL, (char *) &remailing },
+   { "C)hain:", 'c', 5, INT, (char *) &remailer.chain },
+   { "remail P)ath:", 'p', 6, STR, (char *) &remailer.path },
+   { "E)ncrypt:", 'e', 8, BOL, (char *) &remailer.encrypt }
+ };
+ #define MAX_ITEMS 4
+ 
+ void
+ remailer_menu ()
+ {
+   /* Reset to the defaults... */
+   remailer.encrypt = FALSE;
+   remailer.path[0] = '\0';
+   remailer.chain = 3;
+   remailer.info = NULL;
+ 
+   generic_menu (&remail_items, MAX_ITEMS, "Remailer Configuration", "remailer: ");
+ }
+ 
+ static void
+ remailer_print_db (db)
+      remailer_t *db;
+ {
+   dprint(3, (debugfile, "remailer_print_db:\n"));
+   while (db) {
+     dprint(3, (debugfile, "\t%s = %d\n", db->name, db->time));
+     db = db->next;
+   }
+ }
+ 
+ static void
+ remailer_parse_opts (buf, r)
+      char *buf;
+      remailer_t *r;
+ 			       
+ {
+   short i = 0;
+   char *ptr, *ptr2;
+   
+   ptr = strchr (buf, '"');
+   ptr++;
+   while (*ptr && (*ptr != '"'))
+     r->name[i++] = *ptr++;
+   r->name[i] = '\0';
+   ptr = strchr (ptr, '<');
+   ptr++;
+   i = 0;
+   while (*ptr && (*ptr != '>'))
+     r->path[i++] = *ptr++;
+   r->path[i] = '\0';
+   ptr2 = strrchr (ptr, '"');
+   *ptr2 = '\0';
+   while ((ptr2 = strtok (ptr, " ")) != NULL) {
+     if (strcmp (ptr2, "pgp") == 0)
+       r->pgp = 1;
+     else if (strcmp (ptr2, "hash") == 0)
+       r->hash = 1;
+     else if (strcmp (ptr2, "eric") == 0)
+       r->eric = 1;
+     else if (strcmp (ptr2, "penet") == 0)
+       r->penet = 1;
+     else if (strcmp (ptr2, "cpunk") == 0)
+       r->cpunk = 1;
+     else if (strcmp (ptr2, "latent") == 0)
+       r->latent = 1;
+     else if (strcmp (ptr2, "special") == 0)
+       r->special = 1;
+     ptr = 0;
+   }
+ }
+ 
+ static remailer_t *
+ remailer_lookup (char *name, remailer_t *db)
+ {
+   while (db) {
+     if (strcmp (name, db->name) == 0)
+       return (db);
+     db = db->next;
+   }
+   dprint (3, (debugfile, "remailer_lookup(): %s not found.\n", name));
+   return (0);
+ }
+ 
+ static remailer_t *
+ remailer_sort (remailer_t *p)
+ {
+   /* sorts the remailers in increasing response time. */
+ 
+   remailer_t *tmp;
+   remailer_t *ptr;
+   remailer_t *head;
+   remailer_t *gopher;
+ 
+   if (p == NULL)
+     return (NULL);
+ 
+   /* Pop the first element. */
+   head = gopher = p;
+   ptr = head->next;
+   head->next = 0;
+   
+   /* No go through the rest of the list */
+   while (ptr) {
+     tmp = ptr;
+     ptr = ptr->next;
+     tmp->next = 0;
+     
+     gopher = head;
+     while (gopher) {
+       if (tmp->time <= gopher->time) {
+ 	/* This case should only occur when gopher==head, so we don't have
+ 	 * to worry about this not being the beginning of the list.
+ 	 */
+ 	tmp->next = gopher;
+ 	head = tmp;
+ 	break;
+       }
+       else if (gopher->next && (tmp->time < gopher->next->time)) {
+ 	tmp->next = gopher->next;
+ 	gopher->next = tmp;
+ 	break;
+       }
+       gopher = gopher->next;
+     }
+   }
+   remailer_print_db(head);
+   return (head);
+ }
+ 
+ void
+ remailer_destroy_db ()
+ {
+   remailer_t *p, *db = remailer.info;
+ 
+   while (db) {
+     p = db;
+     db = db->next;
+     free (p);
+   }
+ }
+ 
+ static remailer_t *
+ remailer_get_db ()
+ {
+   /* This routine retrives the list of remailers and their properties.
+    * It first tries to read ~/.elm/remailers, and failing that, it
+    * fingers whatever is defined in REMAILER_SITE for that info.
+    */
+   FILE *fpin;
+   char buf[STRING], *c, buf2[STRING];
+   short i = 0;
+   int hour, min, sec;
+   remailer_t *mailers = 0;
+   remailer_t *end = 0;
+   remailer_t *tmp;
+ 
+   sprintf (buf, "%s/.elm/remailers", home);
+   fpin = fopen (buf, "r");
+   if (fpin == NULL) {
+     int fd[2];
+ 
+     if (pipe (fd) == -1) {
+       dprint (1, (debugfile, "remailer_get_db(): ERROR: pipe (errno %d)\n", errno));
+       return (NULL);
+     }
+   
+     if (fork () == 0) {
+       close (fd[0]);
+       close (1);
+       dup (fd[1]);
+       close (fd[1]);
+       sprintf (buf, "/usr/ucb/finger %s", REMAILER_SITE);
+       _exit (system (buf));
+     }
+   
+     close (fd[1]);
+     fpin = fdopen (fd[0], "r");
+     if (fpin == NULL) {
+       dprint (1, (debugfile, "remailer_get_db(): ERROR: fdopen (errno %d)\n", errno));
+       return (NULL);
+     }
+     error1 ("Fingering %s...", REMAILER_SITE);
+   }
+   else
+     error1 ("Reading %s...", buf);
+ 
+   while (fgets (buf, STRING, fpin) != NULL) {
+     if (strncmp (buf, "$remailer{", 10) == 0) {
+       tmp = (remailer_t *) safe_malloc (sizeof (remailer_t));
+       remailer_parse_opts (buf, tmp);
+       if (mailers == 0)
+ 	mailers = end = tmp;
+       else {
+ 	end->next = tmp;
+ 	end = end->next;
+       }
+       tmp->next = 0;
+     }
+     else if (strncmp (buf, "-----", 5) == 0)
+       break;
+   }
+ 
+   /* Phase 2 : retrieve the rankings (latency). */
+   while (fgets (buf, STRING, fpin) != NULL) {
+     c = buf;
+     i = 0;
+     while (*c && !isspace (*c))
+       buf2[i++] = *c++;
+     buf2[i] = '\0';
+     tmp = remailer_lookup (buf2, mailers);
+     if (tmp != NULL) {
+       c = strchr (buf, ':');
+       while (!isspace(*c))
+ 	c--;
+       c++;
+       i = sscanf (c, "%d:%d:%d", &hour, &min, &sec);
+       if (i == 3)
+ 	tmp->time = (hour * 3600) + min * 60 + sec;
+       else if (i == 2)
+ 	tmp->time = hour * 60 + min;
+       else {
+ 	dprint (1, (debugfile, "remailer_get_db(): error parsing time: %s\n", c));
+ 	error1 ("Could not convert time for remailer %s!", tmp->name);
+ 	if (sleepmsg > 0)
+ 	  sleep(sleepmsg);
+       }
+     }
+   }
+   remailer_print_db (mailers);
+   return (remailer_sort (mailers));
+ }
+ 
+ static int
+ #ifdef MIME
+ remailer_write_msg (pdb, to, subj, src, tmpfn, pgp, mime_info)
+      mime_send_t *mime_info;
+ #else
+ remailer_write_msg (pdb, to, subj, src, tmpfn, pgp)
+ #endif
+      remailer_t *pdb;
+      char *to, *subj, *src, *tmpfn;
+ {
+   FILE *fpin, *fpout;
+   char buf[VERY_LONG_STRING];
+ 
+   if (pdb == NULL) {
+     dprint (1, (debugfile, "remailer_write_msg(): ERROR!  pdb==NULL\n"));
+     error ("Could not retrieve list of remailers!");
+     if (sleepmsg > 0)
+       sleep(sleepmsg);
+     return(-1);
+   }
+ 
+   fpin = fopen (src, "r");
+   if (!fpin) {
+     dprint(1,(debugfile,"remailer_write_msg: %s: could not open for reading!\n",src));
+     error("Error opening temp file!");
+     if (sleepmsg > 0)
+       sleep(sleepmsg);
+     return(-1);
+   }
+     
+   fpout = fopen (tmpfn, "w");
+   if (!fpout) {
+     dprint(1,(debugfile,"remailer_write_msg: %s: could not open for writing!\n",tmpfn));
+     error("Error opening temp file!");
+     if (sleepmsg > 0)
+       sleep(sleepmsg);
+     return(-1);
+   }
+ 
+   fputs ("::\n", fpout);
+   if (pdb->cpunk)
+     fputs ("Request-Remailing-To: ", fpout);
+   else if (pdb->eric)
+     fputs ("Anon-Send-To: ", fpout);
+   else if (pdb->penet)
+     fputs ("X-Anon-To: ", fpout);
+   fprintf (fpout, "%s\n\n", to);
+   /* Some remailers require the subject line to be in the "hash" area, so
+    * use it if it's availible.
+    */
+   if (pdb->hash) {
+     fprintf (fpout, "##\nSubject: %s\n", subj);
+ #ifdef MIME
+     if (mime_info) {
+       /* If this is a MIME message, write out a header in the "hash" area
+        * so that the information will be preserved when the remailer
+        * rewrites the message.
+        */
+       mime_write_header(fpout, mime_info);
+       print_EOLN(fpout, mime_info->encoding_top);
+     }
+     else
+ #endif
+       fputc('\n', fpout);
+   }  
+   while (fgets (buf, VERY_LONG_STRING, fpin) != NULL)
+     fputs (buf, fpout);
+   fclose (fpin);
+   fclose (fpout);
+ #ifdef USE_PGP
+   if (pgp && pdb->pgp) {
+     pgp_encrypt (tmpfn, pdb->path, PGP_MESSAGE);
+     fpin = fopen (tmpfn, "r");
+     fpout = fopen (src, "w");
+     fputs ("::\nEncrypted: PGP\n\n", fpout);
+     while (fgets (buf, VERY_LONG_STRING, fpin) != NULL)
+       fputs (buf, fpout);
+     fclose (fpin);
+     fclose (fpout);
+     unlink (tmpfn);
+   }
+   else
+ #endif
+   {
+ #ifdef RENAME
+     if (rename (tmpfn, src) < 0) {
+       error ("Could not rename temp file!");
+       dprint (1, (debugfile, "remailer_write_msg: ERROR!  rename(%s,%s); errno=%d\n", src, tmpfn, errno));
+       return(-1);
+     }
+ #else
+     link (tmpfn, src);
+     unlink (tmpfn);
+ #endif
+   }
+   dprint (2, (debugfile, "remailer_write_msg: routing through %s.\n", pdb->path));
+   return 0;
+ }
+ 
+ remailer_proc ()
+ {
+   remailer_t *pdb;
+   int chain = remailer.chain;
+   char *c;
+ 
+   /* See if there is anything to do... */
+   if (chain > 0 || (remailer.path[0] != '\0')) {
+     extern char expanded_to[];
+       
+     /* Save this information for later use... */
+     pdb = remailer.info = remailer_get_db ();
+ 
+     if (remailer.path[0] != '\0') {
+       /* The user has specified a path to use. */
+       c = remailer.path;
+       while ((c = strtok (c, ";")) != NULL) {
+ 	while (*c && isspace (*c))
+ 	  c++;
+ 	pdb = remailer_lookup (c, remailer.info);
+ 	if (! pdb)
+ 	  return(-1);
+ 	c = NULL;
+       }
+     }
+     else {
+       remailer_t *savedb = 0;
+ 
+       while (chain > 0) {
+ 	if (remailer.encrypt) {
+ 	  /* Find the next remailer which supports pgp. */
+ 	  while (pdb && ((! pdb->pgp) || (pdb->time == 0)))
+ 	    pdb = pdb->next;
+ 	  if (! pdb)
+ 	    return (-1);
+ 	}
+ 	else {
+ 	  /* Some servers will only accept PGP encoded messages, so if PGP was
+ 	   * not requested, skip all servers marked "special".  Also, we want
+ 	   * to skip any servers with a time of zero, since that means there 
+ 	   * wasn't any information availible.
+ 	   */
+ 	  while (pdb && (pdb->special || (pdb->time == 0)))
+ 	    pdb = pdb->next;
+ 	  if (! pdb)
+ 	    return (-1);
+ 	}
+ 	savedb = pdb;
+ 	pdb = pdb->next;
+ 	chain--;
+       }
+       pdb = savedb;
+     }
+ 
+     /* "pdb" should now be set to the last entry.  We should set Elm's
+      * concept of the "To:" address to this remailer.
+      */
+     strcpy (remailer.address, expanded_to);
+     strcpy (expanded_to, pdb->path);
+   }
+   return(0);
+ }
+ 
+ static int
+ #ifdef MIME
+ remailer_genmsg (filename, to, subj, chain, pgp, mime_info)
+      mime_send_t *mime_info;
+ #else
+ remailer_genmsg (filename, to, subj, chain, pgp)
+ #endif
+      char *to, *subj, *filename;
+      int chain, pgp;
+ {
+   char tmpfn[STRING], *c;
+   char remailto[STRING];
+   remailer_t *db, *pdb;
+ 
+   /* Set the initial address */
+   strcpy(remailto, to);
+ 
+   if (chain < 1 && (remailer.path[0] == '\0'))
+     return (-1); /* nothing to do */
+ 
+   pdb = db = remailer.info;
+   if (db == NULL) {
+     dprint(1, (debugfile, "remailer_genmsg: no database found!\n"));
+     error("Could not find remailer database!");
+     if (sleepmsg>0)
+       sleep(sleepmsg);
+     return(-1);
+   }
+ 
+   sprintf (tmpfn, "%selmRT%d", temp_dir, getpid());
+ 
+   if (remailer.path[0] != '\0') {
+     /* The user has specified a path to use. */
+     c = remailer.path;
+     while ((c = strtok (c, ";")) != NULL) {
+       while (*c && isspace (*c))
+ 	c++;
+       pdb = remailer_lookup (c, db);
+       if (! pdb) {
+ 	dprint(1,(debugfile, "remailer_genmsg: could not find remailer '%s'\n",
+ 		  c));
+ 	error1("Could not find remailer '%c'.", c);
+ 	if (sleepmsg > 0)
+ 	  sleep(sleepmsg);
+         return (-1);
+       }
+ #ifdef MIME
+       remailer_write_msg (pdb, remailto, subj, filename, tmpfn, pgp, mime_info);
+ #else
+       remailer_write_msg (pdb, remailto, subj, filename, tmpfn, pgp);
+ #endif
+       strcpy(remailto, pdb->path);
+       c = NULL;
+     }
+   }
+   else
+     while (chain > 0) {
+       if (pgp) {
+ 	/* Find the next remailer which supports pgp. */
+ 	while (pdb && ((! pdb->pgp) || (pdb->time == 0)))
+ 	  pdb = pdb->next;
+ 	if (! pdb)
+ 	  return (-1);
+       }
+       else {
+ 	/* Some servers will only accept PGP encoded messages, so if PGP was
+ 	 * not requested, skip all servers marked "special".  Also, we want
+ 	 * to skip any servers with a time of zero, since that means there 
+ 	 * wasn't any information availible.
+ 	 */
+ 	while (pdb && (pdb->special || (pdb->time == 0)))
+ 	  pdb = pdb->next;
+         if (! pdb)
+           return (-1);
+       }
+ #ifdef MIME
+       remailer_write_msg (pdb, remailto, subj, filename, tmpfn, pgp, mime_info);
+ #else
+       remailer_write_msg (pdb, remailto, subj, filename, tmpfn, pgp);
+ #endif
+       strcpy(remailto, pdb->path);
+       pdb = pdb->next;
+       chain--;
+     }
+   return (0);
+ }
+ 
+ #ifdef MIME
+ remailer_copy_message_across (reply, real_reply, copy, mime_info)
+      mime_send_t *mime_info;
+ #else
+ remailer_copy_message_across (reply, real_reply, copy)
+ #endif
+      FILE *reply, *real_reply;
+      int copy;
+ {
+   FILE *tmpfp;
+   char tempfile[STRING], buf[VERY_LONG_STRING];
+   extern char subject[];
+   int ret;
+ 
+   sprintf(tempfile, "%selmR%d", temp_dir, getpid());
+   tmpfp = fopen(tempfile, "w");
+   if (!tmpfp) {
+     dprint(1, (debugfile, "remailer_copy_message_across: %s: could not open for writing!\n", tempfile));
+     error("Could not open temp file for writing!");
+     if (sleepmsg > 0)
+       sleep(sleepmsg);
+     return(-1);
+   }
+ 
+ #ifdef MIME
+   copy_message_across(reply, tmpfp, copy, mime_info);
+ #else
+   copy_message_across(reply, tmpfp, copy);
+ #endif
+   fclose(tmpfp);
+ #ifdef MIME
+   ret = remailer_genmsg (tempfile, remailer.address, subject, remailer.chain,
+ 			 remailer.encrypt, mime_info);
+ #else
+   ret = remailer_genmsg (tempfile, remailer.address, subject, remailer.chain,
+ 			 remailer.encrypt);
+ #endif
+   if (ret == -1) {
+     error("Error while formatting for remailer!");
+     if (sleepmsg > 0)
+       sleep(sleepmsg);
+     unlink(tempfile);
+     return(-1);
+   }
+   tmpfp = fopen(tempfile, "r");
+   if (!tmpfp) {
+     dprint(1, (debugfile, "remailer_copy_message_across: %s: could not open for reading!\n", tempfile));
+     error("Could not read temp file!");
+     if (sleepmsg>0)
+       sleep(sleepmsg);
+     unlink(tempfile);
+     return(-1);
+   }
+   while (mail_gets(buf, sizeof(buf), tmpfp) > 0)
+     fputs(buf, real_reply);
+   unlink(tempfile);
+   return 0;
+ }
+ #endif

diff -c elm-2.4pl24/src/reply.c elm-2.4pl24me8/src/reply.c
*** elm-2.4pl24/src/reply.c	Tue Aug  3 12:29:18 1993
--- elm-2.4pl24me8/src/reply.c	Wed Apr 12 15:24:25 1995
***************
*** 341,348 ****
  	}
  	if (form_letter)
  	  return_value = mail_filled_in_form(return_address, subject);
! 	else
  	  return_value = send_msg(return_address, "", subject, TRUE, NO, TRUE);
  	return(return_value);
  }
  
--- 341,353 ----
  	}
  	if (form_letter)
  	  return_value = mail_filled_in_form(return_address, subject);
! 	else {
  	  return_value = send_msg(return_address, "", subject, TRUE, NO, TRUE);
+           if (me_retcode) {
+             headers[current-1]->status |= REPLIED;
+             headers[current-1]->status_chgd = TRUE;
+           }
+         }
  	return(return_value);
  }
  
***************
*** 371,376 ****
--- 376,385 ----
  
          return_value = send_msg(return_address, full_address, subject, 
  		TRUE, NO, TRUE);
+         if (me_retcode) {
+           headers[current-1]->status |= REPLIED;
+           headers[current-1]->status_chgd = TRUE;
+         }
  	return(return_value);
  
  }

diff -c elm-2.4pl24/src/savecopy.c elm-2.4pl24me8/src/savecopy.c
*** elm-2.4pl24/src/savecopy.c	Sun May 15 16:10:12 1994
--- elm-2.4pl24me8/src/savecopy.c	Tue Sep 19 18:41:44 1995
***************
*** 101,119 ****
  #endif
  
  #include <errno.h>
  
  char *format_long(), *error_description(), *ctime();
  
  extern int errno;
  
! #ifdef MIME
! extern int msg_is_multipart;
  #endif
- extern long C_L_Position[2];   /*To Remember position of the Content-Length*/
- extern long C_StartData[2];    /*To Remember length of Header Area */
- extern long C_EndData[2];   /* To Remeber the End of the Data */
  
- 
  /*
   * save_copy() - Append a copy of the message contained in "filename" to
   * the file specified by "copy_file".  This routine simply gets all of
--- 101,122 ----
  #endif
  
  #include <errno.h>
+ #include "me.h"
  
+ 
  char *format_long(), *error_description(), *ctime();
  
  extern int errno;
  
! /* Offsets for figuring the Content-Length header */
! extern long cl_offset;
! extern long cl_start;
! extern long cl_end;
! 
! #ifdef USE_REMAILER
! extern int remailing;
  #endif
  
  /*
   * save_copy() - Append a copy of the message contained in "filename" to
   * the file specified by "copy_file".  This routine simply gets all of
***************
*** 120,128 ****
--- 123,139 ----
   * the filenames right, and then invokes "append_copy_to_file()" to do
   * the dirty work.
   */
+ int
+ #ifdef MIME
+ save_copy(to, cc, bcc, filename, copy_file, form, mime_info)
+ #else
  save_copy(to, cc, bcc, filename, copy_file, form)
+ #endif
  char *to, *cc, *bcc, *filename, *copy_file;
  int form;
+ #ifdef MIME
+ mime_send_t *mime_info;
+ #endif
  {
  	char  buffer[SLEN],	/* read buffer 		       */
  	      savename[SLEN],	/* name of file saving into    */
***************
*** 281,288 ****
  		sleep(sleepmsg);
  	  strcpy(savename, sent_mail);
  	}
! 
  	return (append_copy_to_file(to, cc, bcc, savename, filename, form)==0);
  }
  
  char *
--- 292,303 ----
  		sleep(sleepmsg);
  	  strcpy(savename, sent_mail);
  	}
! #ifdef MIME
! 	return (append_copy_to_file(to, cc, bcc, savename, filename, form,
! 				    mime_info)==0);
! #else
  	return (append_copy_to_file(to, cc, bcc, savename, filename, form)==0);
+ #endif
  }
  
  char *
***************
*** 384,390 ****
--- 399,409 ----
  
  
  int
+ #ifdef MIME
+ append_copy_to_file(to, cc, bcc, fname_copy, fname_mssg, form, mime_info)
+ #else
  append_copy_to_file(to, cc, bcc, fname_copy, fname_mssg, form)
+ #endif
  char *to;
  char *cc;
  char *bcc;
***************
*** 391,396 ****
--- 410,418 ----
  char *fname_copy;
  char *fname_mssg;
  int form;
+ #ifdef MIME
+ mime_send_t *mime_info;
+ #endif
  {
      int err;
      FILE *fp_copy, *fp_mssg;
***************
*** 412,444 ****
  
      /* dump the header to the end of the copy file */
      save_file_stats(fname_copy);
      fp_copy = write_header_info(fname_copy, to, cc, bcc, (form == YES), TRUE);
      if (fp_copy == NULL) {
  	(void) fclose(fp_mssg);
  	return -1;
      }
      restore_file_stats(fname_copy);
-     C_StartData[0] = ftell(fp_copy);
  
!     /* dump the contents of the message to the end of the copy file */
!     copy_message_across(fp_mssg, fp_copy, TRUE);
  
  #ifdef MIME
!     if (!form != NO && msg_is_multipart) {
! 	fprintf(fp_copy, "--%%#%%record%%#%%--\n");
! 	if (C_L_Position[1] != 0L) {
! 	    C_EndData[1] = ftell(fp_copy);
! 	    C_L_Position[1] = fseek(fp_copy, C_L_Position[1], 0);
! 	    fprintf(fp_copy, "%d", C_EndData[1] - C_StartData[1]);
! 	    fseek(fp_copy, C_EndData[1], 0);
! 	}
      }
  #endif
!     C_EndData[0] = ftell(fp_copy) ;
  
  #ifdef MMDF
      /*
!      * Actually, the C_EndData just calculated is wrong for MMDF.
       * Because we are saving a copy instead of handing off to
       * submit, copy_message_across will have added the trailing
       * MMDF MSG_SEPARATOR to the end of the saved message to ensure
--- 434,478 ----
  
      /* dump the header to the end of the copy file */
      save_file_stats(fname_copy);
+ #ifdef MIME
+     fp_copy = write_header_info(fname_copy, to, cc, bcc, (form == YES), TRUE,
+ 				mime_info);
+ #else
      fp_copy = write_header_info(fname_copy, to, cc, bcc, (form == YES), TRUE);
+ #endif
      if (fp_copy == NULL) {
  	(void) fclose(fp_mssg);
  	return -1;
      }
      restore_file_stats(fname_copy);
  
!     cl_start = ftell(fp_copy);
  
+     /* dump the contents of the message to the end of the copy file */
  #ifdef MIME
! #ifdef USE_REMAILER
!     if (remailing) {
!       if (remailer_copy_message_across(fp_mssg, fp_copy, TRUE, mime_info) == -1)
!         return(-1);
      }
+     else
  #endif
!     copy_message_across(fp_mssg, fp_copy, TRUE, mime_info);
! #else
! #ifdef USE_REMAILER
!     if (remailing) {
!       if (remailer_copy_message_across(fp_mssg, fp_copy, TRUE) == -1)
!         return(-1);
!     }
!     else
! #endif
!     copy_message_across(fp_mssg, fp_copy, TRUE);
! #endif
  
+     cl_end = ftell(fp_copy) ;
  #ifdef MMDF
      /*
!      * Actually, the cl_end just calculated is wrong for MMDF.
       * Because we are saving a copy instead of handing off to
       * submit, copy_message_across will have added the trailing
       * MMDF MSG_SEPARATOR to the end of the saved message to ensure
***************
*** 448,459 ****
       * localized to this function, we will just subtract off the
       * length of the MSG_SEPARATOR.
       */
!     C_EndData[0] -= strlen(MSG_SEPARATOR);
  #endif /* MMDF */
  
      /* go fixup the content length header */
!     fseek(fp_copy, C_L_Position[0], 0);
!     fprintf(fp_copy, "%d", C_EndData[0] - C_StartData[0]);
  
      /* copy successfully done */
      fclose(fp_copy);
--- 482,493 ----
       * localized to this function, we will just subtract off the
       * length of the MSG_SEPARATOR.
       */
!     cl_end -= strlen(MSG_SEPARATOR);
  #endif /* MMDF */
  
      /* go fixup the content length header */
!     fseek(fp_copy, cl_offset, 0);
!     fprintf(fp_copy, "%d", cl_end - cl_start);
  
      /* copy successfully done */
      fclose(fp_copy);
***************
*** 460,463 ****
      fclose(fp_mssg);
      return 0;
  }
- 
--- 494,496 ----

diff -c elm-2.4pl24/src/screen.c elm-2.4pl24me8/src/screen.c
*** elm-2.4pl24/src/screen.c	Tue Jan 19 19:02:41 1993
--- elm-2.4pl24me8/src/screen.c	Thu Sep 21 14:20:23 1995
***************
*** 180,188 ****
  			       FALSE);
  	  }
  	  else {
! 	  using_to = tail_of(headers[this_msg]->from, newfrom,
! 	    headers[this_msg]->to); 
! 
  	  if (this_msg == current-1) 
  	    build_header_line(buffer, headers[this_msg], this_msg+1,
  			    TRUE, newfrom, using_to);
--- 180,186 ----
  			       FALSE);
  	  }
  	  else {
! 	    using_to = DisplayAddress(headers[this_msg], newfrom);
  	  if (this_msg == current-1) 
  	    build_header_line(buffer, headers[this_msg], this_msg+1,
  			    TRUE, newfrom, using_to);
***************
*** 277,284 ****
  	    build_alias_line(new_buffer, aliases[current-1], current,
  			     TRUE);
  	  else {
! 	  using_to = tail_of(headers[current-1]->from, newfrom,
! 	    headers[current-1]->to); 
  	  build_header_line(new_buffer, headers[current-1],  current,
  		  TRUE, newfrom, using_to);
  	  }
--- 275,281 ----
  	    build_alias_line(new_buffer, aliases[current-1], current,
  			     TRUE);
  	  else {
! 	    using_to = DisplayAddress(headers[current-1], newfrom);
  	  build_header_line(new_buffer, headers[current-1],  current,
  		  TRUE, newfrom, using_to);
  	  }
***************
*** 298,305 ****
  	      build_alias_line(old_buffer, aliases[last_current-1],
  	                       last_current, FALSE);
  	    else {
! 	    using_to = tail_of(headers[last_current-1]->from, newfrom,
! 	      headers[last_current-1]->to); 
  	    build_header_line(old_buffer, headers[last_current-1], 
  		 last_current, FALSE, newfrom, using_to);
  	    }
--- 295,301 ----
  	      build_alias_line(old_buffer, aliases[last_current-1],
  	                       last_current, FALSE);
  	    else {
! 	      using_to = DisplayAddress(headers[last_current-1], newfrom);
  	    build_header_line(old_buffer, headers[last_current-1], 
  		 last_current, FALSE, newfrom, using_to);
  	    }
***************
*** 369,375 ****
  
  	sprintf(buffer, "%s%s%c%-3d %s ",
  		(highlight && arrow_cursor)? "->" : "  ",
! 		show_status(entry->status),
  		(entry->status & TAGGED?  '+' : ' '),
  	        message_number,
  	        entry->time_menu); 
--- 365,371 ----
  
  	sprintf(buffer, "%s%s%c%-3d %s ",
  		(highlight && arrow_cursor)? "->" : "  ",
! 		show_status(entry->status,entry),
  		(entry->status & TAGGED?  '+' : ' '),
  	        message_number,
  	        entry->time_menu); 
***************
*** 448,455 ****
  	return(FALSE);
  }
  
! char *show_status(status)
  int status;
  {
  	/** This routine returns a pair of characters indicative of
  	    the status of this message.  The first character represents
--- 444,452 ----
  	return(FALSE);
  }
  
! char *show_status(status,hdr)
  int status;
+ struct header_rec *hdr;
  {
  	/** This routine returns a pair of characters indicative of
  	    the status of this message.  The first character represents
***************
*** 483,488 ****
--- 480,486 ----
  	else if (status & EXPIRED)	mybuffer[0] = 'E';
  	else if (status & NEW)		mybuffer[0] = 'N';
  	else if (status & UNREAD)	mybuffer[0] = 'O';
+         else if (status & REPLIED)	mybuffer[0] = 'r';
  	else                            mybuffer[0] = ' ';
  
  	/** and the second... **/
***************
*** 492,502 ****
  	else if (status & PRIVATE)      mybuffer[1] = 'P';
  	else if (status & ACTION)       mybuffer[1] = 'A';
  	else if (status & FORM_LETTER)  mybuffer[1] = 'F';
  #ifdef MIME
! 	else if ((status & MIME_MESSAGE) &&
! 		 ((status & MIME_NOTPLAIN) ||
! 		  (status & MIME_NEEDDECOD))) mybuffer[1] = 'M';
  #endif /* MIME */
  	else 			        mybuffer[1] = ' ';
  
  	mybuffer[2] = '\0';
--- 490,513 ----
  	else if (status & PRIVATE)      mybuffer[1] = 'P';
  	else if (status & ACTION)       mybuffer[1] = 'A';
  	else if (status & FORM_LETTER)  mybuffer[1] = 'F';
+ 	else if (hdr) {
+ #ifdef USE_PGP
+ 		if (hdr->pgp & PGP_MESSAGE)		mybuffer[1] = 'P';
+ 		else if (hdr->pgp & PGP_SIGNED_MESSAGE) mybuffer[1] = 'S';
+ 		else if (hdr->pgp & PGP_PUBLIC_KEY)	mybuffer[1] = 'K';
+ 		else
+ #endif /* USE_PGP */
  #ifdef MIME
!                 if ((status & MIME_MESSAGE) && (status & MIME_UNSUPPORTED))
! 			mybuffer[1] = '?';
! 		else if ((status & MIME_MESSAGE) && hdr->mime_rec.notplain)
! 			mybuffer[1] = 'M';
! 		else if ((status & PRE_MIME_CONTENT) && hdr->mime_rec.notplain)
! 			mybuffer[1] = 'm';
! 		else
  #endif /* MIME */
+ 			mybuffer[1] = ' ';
+ 	}
  	else 			        mybuffer[1] = ' ';
  
  	mybuffer[2] = '\0';

diff -c elm-2.4pl24/src/showmsg.c elm-2.4pl24me8/src/showmsg.c
*** elm-2.4pl24/src/showmsg.c	Tue Aug 30 08:09:44 1994
--- elm-2.4pl24me8/src/showmsg.c	Thu Sep 14 20:02:48 1995
***************
*** 104,131 ****
  **/
  
  #include "headers.h"
- #include "s_elm.h"
  #include <errno.h>
  
- #ifdef BSD
- # include <sys/wait.h>
- #endif
- 
- #ifndef I_UNISTD
- void _exit();
- #endif
- 
  extern int errno;
  
! extern char *elm_date_str(), *error_description();
  
! int    memory_lock = FALSE;	/* is it available?? */
! int    pipe_abort  = FALSE;	/* did we receive a SIGNAL(SIGPIPE)? */
  
- FILE *pipe_wr_fp;		/* file pointer to write to external pager */
- extern int lines_displayed,	/* defined in "builtin" */	
- 	   lines_put_on_screen;	/*    ditto too!        */
- 
  int
  show_msg(number)
  int number;
--- 104,136 ----
  **/
  
  #include "headers.h"
  #include <errno.h>
+ #include "s_elm.h"
  
  extern int errno;
  
! int pipe_abort = FALSE; /* not used anymore, but won't compile without it */
  
! #ifdef MIME
! static int
! need_meta (hdr)
! struct header_rec *hdr;
! {
! 	/* Determine whether or not we need to call metamail to display the
! 	 * message contents.
! 	 */
! #ifdef USE_PGP
! 	if (hdr->pgp & (PGP_MESSAGE | PGP_SIGNED_MESSAGE))
! 		return 0;
! #endif
! 	if ((hdr->status & (MIME_MESSAGE)) && (hdr->status & MIME_UNSUPPORTED))
! 		return TRUE;
! 	if (hdr->status & (MIME_MESSAGE | PRE_MIME_CONTENT))
! 		return hdr->mime_rec.notplain;
! 	return 0;
! }
! #endif
  
  int
  show_msg(number)
  int number;
***************
*** 140,183 ****
  	     the index screen (to be processed via process_showmsg_cmd()).
  	***/
  
- 	char title1[SLEN], title2[SLEN], title3[SLEN], titlebuf[SLEN];
- 	char who[LONG_STRING], buffer[VERY_LONG_STRING];
- #if defined(BSD) && !defined(WEXITSTATUS)
- 	union wait wait_stat;
- #else
- 	int wait_stat;
- #endif
- 
- 	int crypted = 0;			/* encryption */
- 	int weed_header, weeding_out = 0;	/* weeding    */ 
- 	int using_to,				/* misc use   */
- 	    pipe_fd[2],				/* pipe file descriptors */
- 	    new_pipe_fd,			/* dup'ed pipe fil des */
- 	    lines,				/* num lines in msg */
- 	    fork_ret,				/* fork return value */
- 	    wait_ret,				/* wait return value */
- 	    form_letter = FALSE,		/* Form ltr?  */
- 	    form_letter_section = 0,		/* section    */
- 	    padding = 0,			/*   counter  */
- 	    builtin = FALSE,			/* our pager? */
- 	    val = 0,				/* return val */
- 	    buf_len,				/* line length */
- 	    err;				/* place holder for errno */
  	struct header_rec *current_header = headers[number-1];
- #ifdef	SIGTSTP
- 	SIGHAND_TYPE	(*oldstop)(), (*oldcont)();
- #endif
- #ifdef	SIGWINCH
- 	SIGHAND_TYPE	(*oldwinch)();
- #endif
  
- 	lines = current_header->lines; 
- 
  	dprint(4, (debugfile,"displaying %d lines from message %d using %s\n", 
! 		lines, number, pager));
  
  	if (number > message_count || number < 1)
! 	  return(val);
  
  	if(ison(current_header->status, NEW)) {
  	  clearit(current_header->status, NEW);   /* it's been read now! */
--- 145,157 ----
  	     the index screen (to be processed via process_showmsg_cmd()).
  	***/
  
  	struct header_rec *current_header = headers[number-1];
  
  	dprint(4, (debugfile,"displaying %d lines from message %d using %s\n", 
! 		current_header->lines, number, pager));
  
  	if (number > message_count || number < 1)
! 	  return(0);
  
  	if(ison(current_header->status, NEW)) {
  	  clearit(current_header->status, NEW);   /* it's been read now! */
***************
*** 188,631 ****
  	  current_header->status_chgd = TRUE;
  	}
  
- 	memory_lock = FALSE;
- 
- 	/* some explanation for that last one - We COULD use memory locking
- 	   to speed up the paging, but the action of "ClearScreen" on a screen
- 	   with memory lock turned on seems to vary considerably (amazingly so)
- 	   so it's safer to only allow memory lock to be a viable bit of
- 	   trickery when dumping text to the screen in scroll mode.
- 	   Philosophical arguments should be forwarded to Bruce at the 
- 	   University of Walamazoo, Australia, via ACSNet  *wry chuckle* */
- 
  #ifdef MIME
! 	if ((current_header->status & MIME_MESSAGE) &&
! 	    ((current_header->status & MIME_NEEDDECOD) ||
! 	     (current_header->status & MIME_NOTPLAIN)) &&
! 	    !getenv("NOMETAMAIL") ) {
! 	    char fname[STRING], Cmd[SLEN], line[VERY_LONG_STRING];
! 	    int code, err;
! 	    long lines = current_header->lines;
! 	    FILE *fpout;
  
! 	    if (fseek(mailfile, current_header->offset, 0) != -1) {
  		sprintf(fname, "%semm.%d.%d", temp_dir, getpid(), getuid());
! 		if ((fpout = fopen(fname, "w")) != NULL) {
! 		    copy_message("", fpout, CM_DECODE);
! 		    (void) fclose (fpout);
! 		    sprintf(Cmd, "metamail -p -z -m Elm %s", fname);
! 		    Raw(OFF);
!                   ClearScreen();
! 		    code = system_call(Cmd, SY_ENAB_SIGINT);
! 		    Raw(ON | NO_TITE);	/* Raw on but don't switch screen */
! 		    (void) unlink (fname);
! 		    PutLine0(LINES,0, catgets(elm_msg_cat, ElmSet, ElmPressAnyKeyIndex,
! 			     "Press any key to return to index."));
! 		    (void) ReadCh();
! 		    printf("\r\n");
! 		    Raw(OFF | NO_TITE); /* Raw off so raw on takes effect */
! 		    Raw(ON); /* Finally raw on and switch screen */
  		    return(0);
  		}
! 	    }
  	}
  #endif
! 
! 	if (fseek(mailfile, current_header->offset, 0) == -1) {
! 	  err = errno;
! 	  dprint(1, (debugfile,
! 		  "Error: seek %d bytes into file, errno %s (show_message)\n",
! 		  current_header->offset, error_description(err)));
! 	  error2(catgets(elm_msg_cat, ElmSet, ElmSeekFailedFile,
! 		  "ELM [seek] couldn't read %d bytes into file (%s)."),
! 		  current_header->offset, error_description(err));	
! 	  return(val);
! 	}
! 	if(current_header->encrypted)
! 	  getkey(OFF);
! 
! 	if(builtin=(first_word(pager,"builtin")||
! 	   first_word(pager,"internal"))||
! 	   ( builtin_lines < 0 ? lines < LINES + builtin_lines :
! 	    lines < builtin_lines))
! 
! 	  start_builtin(lines);
! 
! 	else {
! 
! 	  /* put terminal out of raw mode so external pager has normal env */
! 	  Raw(OFF);
! 
! 	  /* create pipe for external pager and fork */
! 
! 	  if(pipe(pipe_fd) == -1) {
! 	    err = errno;
! 	    dprint(1, (debugfile, "Error: pipe failed, errno %s (show_msg)\n",
! 	      error_description(err)));
! 	    error1(catgets(elm_msg_cat, ElmSet, ElmPreparePagerPipe,
! 	      "Could not prepare for external pager(pipe()-%s)."),
! 	      error_description(err));	
! 	    Raw(ON);
! 	    return(val);
! 	  }
! 
! 	  if((fork_ret = fork()) == -1) {
! 
! 	    err = errno;
! 	    dprint(1, (debugfile, "Error: fork failed, errno %s (show_msg)\n",
! 	      error_description(err)));
! 	    error1(catgets(elm_msg_cat, ElmSet, ElmPreparePagerFork,
! 	      "Could not prepare for external pager(fork()-%s)."),
! 	      error_description(err));	
! 	    Raw(ON);
! 	    return(val);
! 
! 	  } else if (fork_ret == 0) {
! 
! 	    /* child fork */
! 
! 	    /* close write-only pipe fd and fit read-only pipe fd to stdin */
! 
! 	    close(pipe_fd[1]);
! 	    close(fileno(stdin));
! 	    if((new_pipe_fd = dup(pipe_fd[0])) == -1) {
! 	      err = errno;
! 	      dprint(1, (debugfile, "Error: dup failed, errno %s (show_msg)\n",
! 		error_description(err)));
! 	      error1(catgets(elm_msg_cat, ElmSet, ElmPreparePagerDup,
! 	        "Could not prepare for external pager(dup()-%s)."),
! 		error_description(err));	
! 	      _exit(err);
! 	    }
! 	    close(pipe_fd[0]);	/* original pipe fd no longer needed */
! 
! 	    /* use stdio on new pipe fd */
! 	    if(fdopen(new_pipe_fd, "r") == NULL) {
! 	      err = errno;
! 	      dprint(1,
! 		(debugfile, "Error: child fdopen failed, errno %s (show_msg)\n",
! 		error_description(err)));
! 	      error1(catgets(elm_msg_cat, ElmSet, ElmPreparePagerChildFdopen,
! 		"Could not prepare for external pager(child fdopen()-%s)."),
! 		error_description(err));	
! 	      _exit(err);
! 	    }
! 
! 	    /* now execute pager and exit */
! 	    
! 	    /* system_call() will return user to user's normal permissions.
! 	     * This is what makes this pipe secure - user won't have elm's
! 	     * special setgid permissions (if so configured) and will only
! 	     * be able to execute a pager that user normally has permission
! 	     * to execute */
! 
! 	    _exit(system_call(pager, SY_ENAB_SIGINT));
! 	  
! 	  } /* else this is the parent fork */
! 
! 	  /* close read-only pipe fd and do write-only with stdio */
! 	  close(pipe_fd[0]);
! 
! 	  if((pipe_wr_fp = fdopen(pipe_fd[1], "w")) == NULL) {
! 	    err = errno;
! 	    dprint(1,
! 	      (debugfile, "Error: parent fdopen failed, errno %s (show_msg)\n",
! 	      error_description(err)));
! 	    error1(catgets(elm_msg_cat, ElmSet, ElmPreparePagerParentFdopen,
! 	      "Could not prepare for external pager(parent fdopen()-%s)."),
! 	      error_description(err));	
! 
! 	    /* Failure - must close pipe and wait for child */
! 	    close(pipe_fd[1]);
! 	    while ((wait_ret = wait(&wait_stat)) != fork_ret && wait_ret!= -1)
! 	      ;
! 
! 	    Raw(OFF);
! 	    return(val);	/* pager may have already touched the screen */
! 	  }
! 
! 	  /* and that's it! */
! 	  lines_displayed = 0;
! #ifdef	SIGTSTP
! 	  oldstop = signal(SIGTSTP,SIG_DFL);
! 	  oldcont = signal(SIGCONT,SIG_DFL);
! #endif 
! #ifdef	SIGWINCH
! 	  oldwinch = signal(SIGWINCH,SIG_DFL);
! #endif
! 	}
! 
! 	ClearScreen();
! 
! 	if (cursor_control) transmit_functions(OFF);
! 
! 	pipe_abort = FALSE;
! 
! 	if (form_letter = (current_header->status&FORM_LETTER)) {
! 	  if (filter)
! 	    form_letter_section = 1;	/* initialize to section 1 */
! 	}
! 
! 	if (title_messages && filter) {
! 
! 	  using_to =
! 	    tail_of(current_header->from, who, current_header->to);
! 
! 	  MCsprintf(title1, "%s %d/%d  ",
! 		    headers[current-1]->status & DELETED ? nls_deleted :
! 		    form_letter ? nls_form: nls_message,
! 		    number, message_count);
! 	  MCsprintf(title2, "%s %s", using_to? nls_to : nls_from, who);
! 	  elm_date_str(title3, current_header->time_sent + current_header->tz_offset);
! 	  strcat(title3, " ");
! 	  strcat(title3, current_header->time_zone);
! 
! 	  /* truncate or pad title2 portion on the right
! 	   * so that line fits exactly */
! 	  padding =
! 	    COLUMNS -
! 	    (strlen(title1) + (buf_len=strlen(title2)) + strlen(title3));
! 
! 	  sprintf(titlebuf, "%s%-*.*s%s\n", title1, buf_len+padding,
! 	      buf_len+padding, title2, title3);
! 
! 	  if (builtin)
! 	    display_line(titlebuf, strlen(titlebuf));
! 	  else
! 	    fprintf(pipe_wr_fp, "%s", titlebuf);
! 
! 	  /** if there's a subject, let's output it next,
! 	      centered if it fits on a single line.  **/
! 
! 	  if ((buf_len = strlen(current_header->subject)) > 0 && 
! 		matches_weedlist("Subject:")) {
! 	    padding = (buf_len < COLUMNS ? COLUMNS - buf_len : 0);
! 	    sprintf(buffer, "%*s%s\n", padding/2, "", current_header->subject);
! 	  } else
! 	    strcpy(buffer, "\n");
! 
! 	  if (builtin)
! 	    display_line(buffer, strlen(buffer));
! 	  else
! 	    fprintf(pipe_wr_fp, "%s", buffer);
! 	  
! 	  /** was this message address to us?  if not, then to whom? **/
! 
! 	  if (! using_to && matches_weedlist("To:") && filter &&
! 	      strcmp(current_header->to,username) != 0 &&
! 	      strlen(current_header->to) > 0) {
! 	    sprintf(buffer, catgets(elm_msg_cat, ElmSet, ElmMessageAddressedTo,
! 		  "%s(message addressed to %.60s)\n"), 
! 	          strlen(current_header->subject) > 0 ? "\n" : "",
! 		  current_header->to);
! 	    if (builtin)
! 	      display_line(buffer, strlen(buffer));
! 	    else
! 	      fprintf(pipe_wr_fp, "%s", buffer);
! 	  }
! 	
! 	  /** The test above is: if we didn't originally send the mail
! 	      (e.g. we're not reading "mail.sent") AND the user is currently
! 	      weeding out the "To:" line (otherwise they'll get it twice!)
! 	      AND the user is actually weeding out headers AND the message 
! 	      wasn't addressed to the user AND the 'to' address is non-zero 
! 	      (consider what happens when the message doesn't HAVE a "To:" 
! 	      line...the value is NULL but it doesn't match the username 
! 	      either.  We don't want to display something ugly like 
! 	      "(message addressed to )" which will just clutter up the 
! 	      screen!).
! 
! 	      And you thought programming was EASY!!!!
! 	  **/
! 
! 	  /** one more friendly thing - output a line indicating what sort
! 	      of status the message has (e.g. Urgent etc).  Mostly added
! 	      for X.400 support, this is nonetheless generally useful to
! 	      include...
! 	  **/
! 
! 	  buffer[0] = '\0';
! 
! 	  /* we want to flag Urgent, Confidential, Private and Expired tags */
! 
! 	  if (current_header->status & PRIVATE)
! 	    strcpy(buffer, catgets(elm_msg_cat, ElmSet, ElmTaggedPrivate,
! 		"\n(** This message is tagged Private"));
! 	  else if (current_header->status & CONFIDENTIAL) 
! 	    strcpy(buffer, catgets(elm_msg_cat, ElmSet, ElmTaggedCompanyConfidential,
! 		"\n(** This message is tagged Company Confidential"));
! 
! 	  if (current_header->status & URGENT) {
! 	    if (buffer[0] == '\0')
! 	      strcpy(buffer, catgets(elm_msg_cat, ElmSet, ElmTaggedUrgent,
! 		"\n(** This message is tagged Urgent"));
! 	    else if (current_header->status & EXPIRED)
! 	      strcat(buffer, catgets(elm_msg_cat, ElmSet, ElmCommaUrgent, ", Urgent"));
! 	    else
! 	      strcat(buffer, catgets(elm_msg_cat, ElmSet, ElmAndUrgent, " and Urgent"));
! 	  }
! 
! 	  if (current_header->status & EXPIRED) {
! 	    if (buffer[0] == '\0')
! 	      strcpy(buffer, catgets(elm_msg_cat, ElmSet, ElmMessageHasExpired,
! 		"\n(** This message has Expired"));
! 	    else
! 	      strcat(buffer, catgets(elm_msg_cat, ElmSet, ElmAndHasExpired,
! 		", and has Expired"));
! 	  }
! 
! 	  if (buffer[0] != '\0') {
! 	    strcat(buffer, " **)\n");
! 	    if (builtin)
! 	      display_line(buffer, strlen(buffer));
! 	    else
! 	      fprintf(pipe_wr_fp, buffer);
! 	  }
! 
! 	  if (builtin)			/* this is for a one-line blank    */
! 	    display_line("\n",1);	/*   separator between the title   */
! 	  else				/*   stuff and the actual message  */
! 	    fprintf(pipe_wr_fp, "\n");	/*   we're trying to display       */
! 
! 	}
! 
! 	weed_header = filter;	/* allow us to change it after header */
! 
! 	while (lines > 0 && pipe_abort == FALSE) {
! 
! 	    if ((buf_len = mail_gets(buffer, VERY_LONG_STRING, mailfile)) == 0) {
! 
! 	      dprint(1, (debugfile,
! 		"Premature end of file! Lines left = %d msg = %s (show_msg)\n",
! 		lines, number));
! 
! 	      error(catgets(elm_msg_cat, ElmSet, ElmPrematureEndOfFile,
! 		"Premature end of file!"));
! 	      if (sleepmsg > 0)
! 		    sleep(sleepmsg);
! 	      break;
! 	    }
! 	    if (buf_len > 0)  {
! 	      if(buffer[buf_len - 1] == '\n') {
! 	        lines--;
! 	        lines_displayed++;
! 		}
! 	      while(buf_len > 0 && (buffer[buf_len - 1] == '\n'
! 				    ||buffer[buf_len - 1] == '\r'))
! 		--buf_len;
! 	    }
! 
!   	    if (buf_len == 0) {
! 	      weed_header = 0;		/* past header! */
! 	      weeding_out = 0;
! 	    }
! 
! 	    if (form_letter && weed_header)
! 		/* skip it.  NEVER display random headers in forms! */;
! 	    else if (weed_header && matches_weedlist(buffer)) 
! 	      weeding_out = 1;	 /* aha!  We don't want to see this! */
! 	    else if (buffer[0] == '[') {
! 	      if (strncmp(buffer, START_ENCODE, strlen(START_ENCODE))==0)
! 	        crypted = ON;
! 	      else if (strncmp(buffer, END_ENCODE, strlen(END_ENCODE))==0)
! 	        crypted = OFF;
! 	      else if (crypted) {
!                 encode(buffer);
! 	        val = show_line(buffer, buf_len, builtin);
! 	      }
! 	      else
! 	        val = show_line(buffer, buf_len, builtin);
! 	    } 
! 	    else if (crypted) {
! 	      encode(buffer);
! 	      val = show_line(buffer, buf_len, builtin); 
! 	    }
! 	    else if (weeding_out) {
! 	      weeding_out = (whitespace(buffer[0]));	/* 'n' line weed */
! 	      if (! weeding_out) 	/* just turned on! */
! 	        val = show_line(buffer, buf_len, builtin);
! 	    } 
! 	    else if (form_letter && first_word(buffer,"***") && filter) {
! 	      strcpy(buffer,
! "\n------------------------------------------------------------------------------\n");
! 	      val = show_line(buffer, buf_len, builtin);	/* hide '***' */
! 	      form_letter_section++;
! 	    }
! 	    else if (form_letter_section == 1 || form_letter_section == 3)
! 	      /** skip this stuff - we can't deal with it... **/;
! 	    else
! 	      val = show_line(buffer, buf_len, builtin);
! 	
! 	    if (val != 0)	/* discontinue the display */
! 	      break;
! 	}
! 
!         if (cursor_control) transmit_functions(ON);
! 
! 	if (!builtin) {
! 	  fclose(pipe_wr_fp);
! 	  while ((wait_ret = wait(&wait_stat)) != fork_ret
! 		  && wait_ret!= -1)
! 	    ;
! 	  /* turn raw on **after** child terminates in case child
! 	   * doesn't put us back to cooked mode after we return ourselves
! 	   * to raw.
! 	   */
! 	  Raw(ON);
! #ifdef	SIGTSTP
! 	  (void)signal(SIGTSTP,oldstop);
! 	  (void)signal(SIGCONT,oldcont);
! #endif
! #ifdef	SIGWINCH
! 	  (void)signal(SIGWINCH,oldwinch);
! #endif
! 	}
! 
! 	/* If we are to prompt for a user input command and we don't
! 	 * already have one */
! 	if ((prompt_after_pager || builtin) && val == 0) {
! 	  MoveCursor(LINES,0);
! 	  StartBold();
! 	  Write_to_screen(catgets(elm_msg_cat, ElmSet, ElmCommandIToReturn,
! 		" Command ('i' to return to index): "), 0);
! 	  EndBold();
! 	  fflush(stdout);
! 	  val = ReadCh();
! 	}
! 	
! 	if (memory_lock) EndMemlock();	/* turn it off!! */
! 
! 	/* 'q' means quit current operation and pop back up to previous level -
! 	 * in this case it therefore means return to index screen.
! 	 */
! 	return(val == 'i' || val == 'q' ? 0 : val);
  }
- 
- int
- show_line(buffer, buf_len, builtin)
- char *buffer;
- int  buf_len;
- int  builtin;
- {
- 	/** Hands the given line to the output pipe.  'builtin' is true if
- 	    we're using the builtin pager.
- 	    Return the character entered by the user to indicate
- 	    a command other than continuing with the display (only possible
- 	    with the builtin pager), otherwise 0. **/
- 
- 	strcpy(buffer + buf_len, "\n");
- 	++buf_len;
- #ifdef MMDF
- 	if (strncmp(buffer, MSG_SEPARATOR, buf_len) == 0)
- 	  return(0);	/* no reason to show the ending terminator */
- #endif /* MMDF */
- 	if (builtin) {
- 	  return(display_line(buffer, buf_len));
- 	}
- 	errno = 0;
- 	fprintf(pipe_wr_fp, "%s", buffer);
- 	if (errno != 0)
- 	  dprint(1, (debugfile, "\terror %s hit!\n", error_description(errno)));
- 	return(0);
- }
- 
--- 162,211 ----
  	  current_header->status_chgd = TRUE;
  	}
  
  #ifdef MIME
!         if (need_meta(current_header) && !getenv("NOMETAMAIL")) {
! 		char fname[STRING], Cmd[SLEN], line[VERY_LONG_STRING];
! 		int code, err;
! 		long lines = current_header->lines;
! 		FILE *fpout;
  
! 		if (fseek(mailfile, current_header->offset, 0) == -1) {
! 		    err = errno;
! 		    dprint(1, (debugfile,
! 		      "Error: seek %d bytes into file, errno %s (show_message)\n",
! 		      current_header->offset, error_description(err)));
! 		    error2(catgets(elm_msg_cat, ElmSet, ElmSeekFailedFile,
! 		      "ELM [seek] couldn't read %d bytes into file (%s)."),
! 		      current_header->offset, error_description(err));	
! 		    return(0);
! 		}
  		sprintf(fname, "%semm.%d.%d", temp_dir, getpid(), getuid());
! 		if ((fpout = fopen(fname, "w")) == NULL) {
! 		    err = errno;
! 		    dprint(1, (debugfile,
! 		      "Error: open of temporary file %s, errno %s (show_message)\n",
! 		      fname, error_description(err)));
! 		    error2(catgets(elm_msg_cat, ElmSet, ElmCantOpenAsOutputFile,
! 		      "Can't open \"%s\" as output file! (%s)."),
! 		      fname, error_description(err));
  		    return(0);
  		}
! 		copy_message("", fpout, CM_DECODE);
! 		(void) fclose (fpout);
! 		sprintf(Cmd, "metamail -p -z -m Elm %s", fname);
! 		Raw(OFF);
! 		ClearScreen();
! 		code = system_call(Cmd, SY_ENAB_SIGINT);
! 		Raw(ON | NO_TITE);	/* Raw on but don't switch screen */
! 		(void) unlink (fname);
! 		PutLine0(LINES,0, catgets(elm_msg_cat, ElmSet, ElmPressAnyKeyIndex,
! 			     "Press any key to return to index."));
! 		(void) ReadCh();
! 		printf("\r\n");
! 		Raw(OFF | NO_TITE); /* Raw off so raw on takes effect */
! 		Raw(ON); /* Finally raw on and switch screen */
! 		return(0);
  	}
  #endif
!         return (metapager (mailfile, current_header, TRUE));
  }

diff -c elm-2.4pl24/src/showmsg_c.c elm-2.4pl24me8/src/showmsg_c.c
*** elm-2.4pl24/src/showmsg_c.c	Fri Mar 11 13:25:27 1994
--- elm-2.4pl24me8/src/showmsg_c.c	Thu Sep 21 10:17:54 1995
***************
*** 59,64 ****
--- 59,65 ----
  	   s    = save this message to a maibox/folder 
  	   t    = tag this message
  	   u    = undelete message
+            v    = view attachments
  	   x    = Exit Elm NOW 
  
      all commands not explicitly listed here are beeped at.  Use i)ndex
***************
*** 148,153 ****
--- 149,163 ----
  			 goto next_undel_msg;
  		       break;
  
+ #ifdef USE_PGP
+             case ctrl('E'):
+ 			put_cmd_name("Extract PGP public key", TRUE);
+ 			if (headers[current-1]->pgp & PGP_PUBLIC_KEY)
+ 				pgp_extract_public_key ();
+ 			else
+ 				store_msg("This message does not contain any keys!");
+ 			break;
+ #endif
  	    case 'f' : put_cmd_name(catgets(elm_msg_cat, ElmSet, ElmForwardMessage,
  				"Forward message"), TRUE);
  		       if(forward()) put_border();
***************
*** 249,255 ****
  			 goto next_msg;
  		       }
  		       break;
! 
  	    case 'X' : put_cmd_name(catgets(elm_msg_cat, ElmSet, ElmQuickExit,
  				"Quick Exit"), TRUE);
  		       leave(0);
--- 259,285 ----
  			 goto next_msg;
  		       }
  		       break;
! #ifdef MIME
! 	    case 'v' :
! 	      if (headers) {         
! 		if (headers[current-1]->status & MIME_MESSAGE) {
! 		  attach_parse (headers[current-1]);
! 		  if (headers[current-1]->mime_rec.parts)
! 		    (void) attach_menu (headers[current-1]->
! 					mime_rec.parts, TRUE);
! 		  else 
! 		    /* So we can save mail in decoded ... */
! 		    (void) attach_menu (&(headers[current-1]->
! 					  mime_rec),TRUE);
! 		  redraw++;
! 		}
! 		else
! 		  error ("This is not a MIME message!");
! 	      }
! 	      else
! 		error ("There are no messages!");
! 	      return(0);
! #endif
  	    case 'X' : put_cmd_name(catgets(elm_msg_cat, ElmSet, ElmQuickExit,
  				"Quick Exit"), TRUE);
  		       leave(0);

diff -c elm-2.4pl24/utils/from.c elm-2.4pl24me8/utils/from.c
*** elm-2.4pl24/utils/from.c	Mon May 30 09:27:00 1994
--- elm-2.4pl24me8/utils/from.c	Wed Apr 12 15:27:34 1995
***************
*** 149,154 ****
--- 149,156 ----
  
  extern char *whos_mail(), *explain();
  
+ int showto = 0;
+ 
  #ifdef DEBUG
  int debug = 0;
  FILE *debugfile = stderr;

diff -c elm-2.4pl24/utils/newmail.c elm-2.4pl24me8/utils/newmail.c
*** elm-2.4pl24/utils/newmail.c	Mon May 30 09:32:01 1994
--- elm-2.4pl24me8/utils/newmail.c	Wed Apr 12 15:27:49 1995
***************
*** 240,245 ****
--- 240,247 ----
  FILE	*fd = NULL;		/* fd to use to read folders	    */
  FILE	*debugfile = stderr;
  
+ int	showto = 0;
+ 
  #ifdef PIDCHECK
  int  parent_pid;		/* See if sucide should be attempt  */
  #endif /* PIDCHECK */
