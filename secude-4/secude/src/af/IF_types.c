/* automatically generated by pepy 8.0 #11 (tiber), do not edit! */

#include <isode/psap.h>

#ifndef lint
static char *pepyid = "pepy 8.0 #11 (tiber) of Tue Jun  1 11:43:07 MET DST 1993";
#endif

void	advise ();

/* Generated from module IF */

#include "If-types.h"
#include "af.h"  /* required due to OctetString structure below */

static PE	      encode_IF_DER_SET_OF();
OctetString  	    * aux_PE2OctetString();
PE		      aux_OctetString2PE();

#ifndef PEPYPARM
#define PEPYPARM char *
#endif /* PEPYPARM */
extern PEPYPARM NullParm;

/* ARGSUSED */

int	build_IF_AttributeType (pe, explicit, len, buffer, parm)
register PE     *pe;
int	explicit;
int	len;
char   *buffer;
struct type_IF_AttributeType * parm;
{
    register OID p0;

    p0 = parm ;
    if (p0 == NULLOID) {
        advise (NULLCP, "AttributeType %s", PEPY_ERR_INIT_FAILED);
        return NOTOK;
    }
    if (((*pe) = obj2prim (p0, PE_CLASS_UNIV, PE_PRIM_OID)) == NULLPE) {
        advise (NULLCP, "AttributeType: %s", PEPY_ERR_NOMEM);
        return NOTOK;
    }

#ifdef DEBUG
    (void) testdebug ((*pe), "IF.AttributeType");
#endif


    return OK;
}

/* ARGSUSED */

int	build_IF_AttributeValue (pe, explicit, len, buffer, parm)
PE     *pe;
int	explicit;
int	len;
char   *buffer;
struct type_IF_AttributeValue * parm;
{
    PE	p1 = parm ;

    if (p1 == NULLPE) {
        advise (NULLCP, "AttributeValue %s", PEPY_ERR_INIT_FAILED);
        return NOTOK;
    }
    ((*pe) = p1) -> pe_refcnt++;

#ifdef DEBUG
    (void) testdebug ((*pe), "IF.AttributeValue");
#endif


    return OK;
}

/* ARGSUSED */

int	build_IF_AttributeValueAssertion (pe, explicit, len, buffer, parm)
register PE     *pe;
int	explicit;
int	len;
char   *buffer;
struct type_IF_AttributeValueAssertion * parm;
{
    PE	p2_z = NULLPE;
    register PE *p2 = &p2_z;

    if (((*pe) = pe_alloc (PE_CLASS_UNIV, PE_FORM_CONS, PE_CONS_SEQ)) == NULLPE) {
        advise (NULLCP, "AttributeValueAssertion: %s", PEPY_ERR_NOMEM);
        return NOTOK;
    }
    {

            
    }
    (*p2) = NULLPE;

    {
        if (build_IF_AttributeType (p2, 0, NULL, NULLCP, parm -> element_IF_0 ) == NOTOK)
            return NOTOK;

#ifdef DEBUG
        (void) testdebug ((*p2), "element");
#endif

    }

    if ((*p2) != NULLPE)
        if (seq_add ((*pe), (*p2), -1) == NOTOK) {
            advise (NULLCP, "AttributeValueAssertion %s%s", PEPY_ERR_BAD_SEQ,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }
    (*p2) = NULLPE;

    {
        if (build_IF_AttributeValue (p2, 0, NULL, NULLCP, parm -> element_IF_1 ) == NOTOK)
            return NOTOK;

#ifdef DEBUG
        (void) testdebug ((*p2), "element");
#endif

    }

    if ((*p2) != NULLPE)
        if (seq_add ((*pe), (*p2), -1) == NOTOK) {
            advise (NULLCP, "AttributeValueAssertion %s%s", PEPY_ERR_BAD_SEQ,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }

#ifdef DEBUG
    (void) testdebug ((*pe), "IF.AttributeValueAssertion");
#endif


    return OK;
}

/* ARGSUSED */

int	build_IF_Name (pe, explicit, len, buffer, parm)
register PE     *pe;
int	explicit;
int	len;
char   *buffer;
struct type_IF_Name * parm;
{
    PE	p3 = NULLPE;
    PE	p4_z = NULLPE;
    register PE *p4 = &p4_z;

    if (((*pe) = pe_alloc (PE_CLASS_UNIV, PE_FORM_CONS, PE_CONS_SEQ)) == NULLPE) {
        advise (NULLCP, "Name: %s", PEPY_ERR_NOMEM);
        return NOTOK;
    }
    for (; parm; parm = parm -> next) {
        if (build_IF_RelativeDistinguishedName (p4, 0, NULL, NULLCP, parm -> element_IF_2 ) == NOTOK)
            return NOTOK;

#ifdef DEBUG
        (void) testdebug ((*p4), "element");
#endif

        (void) seq_addon ((*pe), p3, (*p4));
        p3 = (*p4);
    }

#ifdef DEBUG
    (void) testdebug ((*pe), "IF.Name");
#endif


    return OK;
}

/* ARGSUSED */

int	build_IF_RelativeDistinguishedName (pe, explicit, len, buffer, parm)
PE     *pe;
int	explicit;
int	len;
char   *buffer;
struct type_IF_RelativeDistinguishedName * parm;
{
    
	PE pe_enc = encode_IF_DER_SET_OF(parm, RDNAME);
	
    PE	p5 = pe_enc ;

    if (p5 == NULLPE) {
        advise (NULLCP, "RelativeDistinguishedName %s", PEPY_ERR_INIT_FAILED);
        return NOTOK;
    }
    ((*pe) = p5) -> pe_refcnt++;

#ifdef DEBUG
    (void) testdebug ((*pe), "IF.RelativeDistinguishedName");
#endif

    {

	pe_free(pe_enc);
	
    }

    return OK;
}

/* ARGSUSED */

int	build_IF_AttributeValues (pe, explicit, len, buffer, parm)
PE     *pe;
int	explicit;
int	len;
char   *buffer;
struct type_IF_AttributeValues * parm;
{
    
	PE pe_enc = encode_IF_DER_SET_OF(parm, ATTRIBUTEVALUES);
	
    PE	p6 = pe_enc ;

    if (p6 == NULLPE) {
        advise (NULLCP, "AttributeValues %s", PEPY_ERR_INIT_FAILED);
        return NOTOK;
    }
    ((*pe) = p6) -> pe_refcnt++;

#ifdef DEBUG
    (void) testdebug ((*pe), "IF.AttributeValues");
#endif

    {

	pe_free(pe_enc);
	
    }

    return OK;
}

/* ARGSUSED */

int	build_IF_Attribute (pe, explicit, len, buffer, parm)
register PE     *pe;
int	explicit;
int	len;
char   *buffer;
struct type_IF_Attribute * parm;
{
    PE	p7_z = NULLPE;
    register PE *p7 = &p7_z;

    if (((*pe) = pe_alloc (PE_CLASS_UNIV, PE_FORM_CONS, PE_CONS_SEQ)) == NULLPE) {
        advise (NULLCP, "Attribute: %s", PEPY_ERR_NOMEM);
        return NOTOK;
    }
    {

            
    }
    (*p7) = NULLPE;

    {
        if (build_IF_AttributeType (p7, 0, NULL, NULLCP, parm -> type ) == NOTOK)
            return NOTOK;

#ifdef DEBUG
        (void) testdebug ((*p7), "element");
#endif

    }

    if ((*p7) != NULLPE)
        if (seq_add ((*pe), (*p7), -1) == NOTOK) {
            advise (NULLCP, "Attribute %s%s", PEPY_ERR_BAD_SEQ,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }
    (*p7) = NULLPE;

    {
        if (build_IF_AttributeValues (p7, 0, NULL, NULLCP, parm -> values ) == NOTOK)
            return NOTOK;

#ifdef DEBUG
        (void) testdebug ((*p7), "element");
#endif

    }

    if ((*p7) != NULLPE)
        if (seq_add ((*pe), (*p7), -1) == NOTOK) {
            advise (NULLCP, "Attribute %s%s", PEPY_ERR_BAD_SEQ,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }

#ifdef DEBUG
    (void) testdebug ((*pe), "IF.Attribute");
#endif


    return OK;
}

/* ARGSUSED */

int	parse_IF_AttributeType (pe, explicit, len, buffer, parm)
register PE	pe;
int	explicit;
int    *len;
char  **buffer;
struct type_IF_AttributeType ** parm;
{
    register OID p8;

#ifdef DEBUG
    (void) testdebug (pe, "IF.AttributeType");
#endif

    if (explicit) {
        if (pe -> pe_class != PE_CLASS_UNIV
                || pe -> pe_form != PE_FORM_PRIM
                || pe -> pe_id != PE_PRIM_OID) {
            advise (NULLCP, "AttributeType bad class/form/id: %s/%d/0x%x",
                    pe_classlist[pe -> pe_class], pe -> pe_form, pe -> pe_id);
            return NOTOK;
        }
    }
    else
        if (pe -> pe_form != PE_FORM_PRIM) {
            advise (NULLCP, "AttributeType bad form: %d", pe -> pe_form);
            return NOTOK;
        }

    if ((p8 = prim2oid (pe)) == NULLOID) {
        advise (NULLCP, "AttributeType %s%s", PEPY_ERR_BAD_OID,
                pe_error (pe -> pe_errno));
        return NOTOK;
    }
    if (buffer)
        *buffer = sprintoid (p8);
    (*parm)  = oid_cpy (p8);

    return OK;
}

/* ARGSUSED */

int	parse_IF_AttributeValue (pe, explicit, len, buffer, parm)
PE	pe;
int	explicit;
int    *len;
char  **buffer;
struct type_IF_AttributeValue ** parm;
{
#ifdef DEBUG
    (void) testdebug (pe, "IF.AttributeValue");
#endif

    ((*parm)  = pe) -> pe_refcnt++;

    return OK;
}

/* ARGSUSED */

int	parse_IF_AttributeValueAssertion (pe, explicit, len, buffer, parm)
register PE	pe;
int	explicit;
int    *len;
char  **buffer;
struct type_IF_AttributeValueAssertion ** parm;
{
    register PE p9;

#ifdef DEBUG
    (void) testdebug (pe, "IF.AttributeValueAssertion");
#endif

    if (explicit) {
        if (pe -> pe_class != PE_CLASS_UNIV
                || pe -> pe_form != PE_FORM_CONS
                || pe -> pe_id != PE_CONS_SEQ) {
            advise (NULLCP, "AttributeValueAssertion bad class/form/id: %s/%d/0x%x",
                    pe_classlist[pe -> pe_class], pe -> pe_form, pe -> pe_id);
            return NOTOK;
        }
    }
    else
        if (pe -> pe_form != PE_FORM_CONS) {
            advise (NULLCP, "AttributeValueAssertion bad form: %d", pe -> pe_form);
            return NOTOK;
        }

    {

        if ((*(parm) = (struct type_IF_AttributeValueAssertion *)
                calloc (1, sizeof **(parm))) == ((struct type_IF_AttributeValueAssertion *) 0)) {
            advise (NULLCP, "%s", PEPY_ERR_NOMEM);
            return NOTOK;
        }
    
    }
    {

            
    }
    if ((p9 = prim2seq (pe)) == NULLPE) {
        advise (NULLCP, "AttributeValueAssertion %s%s", PEPY_ERR_BAD_SEQ,
                pe_error (pe -> pe_errno));
        return NOTOK;
    }
    pe = p9;

    {
        register PE p10;

        if ((p10 = first_member (pe)) != NULLPE) {
            p9 = p10;

            {
#ifdef DEBUG
                (void) testdebug (p10, "element");
#endif

                if (parse_IF_AttributeType (p10, 1, NULLIP, NULLVP, &((*parm) -> element_IF_0)) == NOTOK)
                    return NOTOK;
            }
        }
        else {
            advise (NULLCP, "AttributeValueAssertion %selement", PEPY_ERR_MISSING);
            return NOTOK;
        }

    }

    {
        register PE p11;

        if ((p11 = (pe != p9 ? next_member (pe, p9) : first_member (pe))) != NULLPE) {
            p9 = p11;

            {
#ifdef DEBUG
                (void) testdebug (p11, "element");
#endif

                if (parse_IF_AttributeValue (p11, 1, NULLIP, NULLVP, &((*parm) -> element_IF_1)) == NOTOK)
                    return NOTOK;
            }
        }
        else {
            advise (NULLCP, "AttributeValueAssertion %selement", PEPY_ERR_MISSING);
            return NOTOK;
        }

    }


    if (pe -> pe_cardinal > 2) {
        advise (NULLCP, "AttributeValueAssertion %s(2): %d", PEPY_ERR_TOO_MANY_ELEMENTS,
                pe -> pe_cardinal);
        return NOTOK;
    }

    return OK;
}

/* ARGSUSED */

int	parse_IF_Name (pe, explicit, len, buffer, parm)
register PE	pe;
int	explicit;
int    *len;
char  **buffer;
struct type_IF_Name ** parm;
{
    register PE p12;

#ifdef DEBUG
    (void) testdebug (pe, "IF.Name");
#endif

    if (explicit) {
        if (pe -> pe_class != PE_CLASS_UNIV
                || pe -> pe_form != PE_FORM_CONS
                || pe -> pe_id != PE_CONS_SEQ) {
            advise (NULLCP, "Name bad class/form/id: %s/%d/0x%x",
                    pe_classlist[pe -> pe_class], pe -> pe_form, pe -> pe_id);
            return NOTOK;
        }
    }
    else
        if (pe -> pe_form != PE_FORM_CONS) {
            advise (NULLCP, "Name bad form: %d", pe -> pe_form);
            return NOTOK;
        }

    if ((p12 = prim2seq (pe)) == NULLPE) {
        advise (NULLCP, "Name %s%s", PEPY_ERR_BAD_SEQ,
                pe_error (pe -> pe_errno));
        return NOTOK;
    }
    pe = p12;

    for (p12 = first_member (pe); p12; p12 = next_member (pe, p12)) {
        {

                if ((*(parm) = (struct type_IF_Name *)
                        calloc (1, sizeof **(parm))) == ((struct type_IF_Name *) 0)) {
                    advise (NULLCP, "%s", PEPY_ERR_NOMEM);
                    return NOTOK;
                }
            
        }
        {
#ifdef DEBUG
            (void) testdebug (p12, "element");
#endif

            if (parse_IF_RelativeDistinguishedName (p12, 1, NULLIP, NULLVP, &((*parm) -> element_IF_2)) == NOTOK)
                return NOTOK;
            {
 parm = &((*parm) -> next); 
            }
        }
    }

    return OK;
}

/* ARGSUSED */

int	parse_IF_RelativeDistinguishedName (pe, explicit, len, buffer, parm)
register PE	pe;
int	explicit;
int    *len;
char  **buffer;
struct type_IF_RelativeDistinguishedName ** parm;
{
    register PE p13;

#ifdef DEBUG
    (void) testdebug (pe, "IF.RelativeDistinguishedName");
#endif

    if (explicit) {
        if (pe -> pe_class != PE_CLASS_UNIV
                || pe -> pe_form != PE_FORM_CONS
                || pe -> pe_id != PE_CONS_SET) {
            advise (NULLCP, "RelativeDistinguishedName bad class/form/id: %s/%d/0x%x",
                    pe_classlist[pe -> pe_class], pe -> pe_form, pe -> pe_id);
            return NOTOK;
        }
    }
    else
        if (pe -> pe_form != PE_FORM_CONS) {
            advise (NULLCP, "RelativeDistinguishedName bad form: %d", pe -> pe_form);
            return NOTOK;
        }

    if ((p13 = prim2set (pe)) == NULLPE) {
        advise (NULLCP, "RelativeDistinguishedName %s%s", PEPY_ERR_BAD_SET,
                pe_error (pe -> pe_errno));
        return NOTOK;
    }
    pe = p13;

    for (p13 = first_member (pe); p13; p13 = next_member (pe, p13)) {
        {

                if ((*(parm) = (struct type_IF_RelativeDistinguishedName *)
                        calloc (1, sizeof **(parm))) == ((struct type_IF_RelativeDistinguishedName *) 0)) {
                    advise (NULLCP, "%s", PEPY_ERR_NOMEM);
                    return NOTOK;
                }
            
        }
        {
#ifdef DEBUG
            (void) testdebug (p13, "member");
#endif

            if (parse_IF_AttributeValueAssertion (p13, 1, NULLIP, NULLVP, &((*parm) -> member_IF_0)) == NOTOK)
                return NOTOK;
            {
 parm = &((*parm) -> next); 
            }
        }
    }

    return OK;
}

/* ARGSUSED */

int	parse_IF_AttributeValues (pe, explicit, len, buffer, parm)
register PE	pe;
int	explicit;
int    *len;
char  **buffer;
struct type_IF_AttributeValues ** parm;
{
    register PE p14;

#ifdef DEBUG
    (void) testdebug (pe, "IF.AttributeValues");
#endif

    if (explicit) {
        if (pe -> pe_class != PE_CLASS_UNIV
                || pe -> pe_form != PE_FORM_CONS
                || pe -> pe_id != PE_CONS_SET) {
            advise (NULLCP, "AttributeValues bad class/form/id: %s/%d/0x%x",
                    pe_classlist[pe -> pe_class], pe -> pe_form, pe -> pe_id);
            return NOTOK;
        }
    }
    else
        if (pe -> pe_form != PE_FORM_CONS) {
            advise (NULLCP, "AttributeValues bad form: %d", pe -> pe_form);
            return NOTOK;
        }

    if ((p14 = prim2set (pe)) == NULLPE) {
        advise (NULLCP, "AttributeValues %s%s", PEPY_ERR_BAD_SET,
                pe_error (pe -> pe_errno));
        return NOTOK;
    }
    pe = p14;

    for (p14 = first_member (pe); p14; p14 = next_member (pe, p14)) {
        {

                if ((*(parm) = (struct type_IF_AttributeValues *)
                        calloc (1, sizeof **(parm))) == ((struct type_IF_AttributeValues *) 0)) {
                    advise (NULLCP, "%s", PEPY_ERR_NOMEM);
                    return NOTOK;
                }
            
        }
        {
#ifdef DEBUG
            (void) testdebug (p14, "member");
#endif

            if (parse_IF_AttributeValue (p14, 1, NULLIP, NULLVP, &((*parm) -> member_IF_1)) == NOTOK)
                return NOTOK;
            {
 parm = &((*parm) -> next); 
            }
        }
    }

    return OK;
}

/* ARGSUSED */

int	parse_IF_Attribute (pe, explicit, len, buffer, parm)
register PE	pe;
int	explicit;
int    *len;
char  **buffer;
struct type_IF_Attribute ** parm;
{
    register PE p15;

#ifdef DEBUG
    (void) testdebug (pe, "IF.Attribute");
#endif

    if (explicit) {
        if (pe -> pe_class != PE_CLASS_UNIV
                || pe -> pe_form != PE_FORM_CONS
                || pe -> pe_id != PE_CONS_SEQ) {
            advise (NULLCP, "Attribute bad class/form/id: %s/%d/0x%x",
                    pe_classlist[pe -> pe_class], pe -> pe_form, pe -> pe_id);
            return NOTOK;
        }
    }
    else
        if (pe -> pe_form != PE_FORM_CONS) {
            advise (NULLCP, "Attribute bad form: %d", pe -> pe_form);
            return NOTOK;
        }

    {

        if ((*(parm) = (struct type_IF_Attribute *)
                calloc (1, sizeof **(parm))) == ((struct type_IF_Attribute *) 0)) {
            advise (NULLCP, "%s", PEPY_ERR_NOMEM);
            return NOTOK;
        }
    
    }
    {

            
    }
    if ((p15 = prim2seq (pe)) == NULLPE) {
        advise (NULLCP, "Attribute %s%s", PEPY_ERR_BAD_SEQ,
                pe_error (pe -> pe_errno));
        return NOTOK;
    }
    pe = p15;

    {
        register PE p16;

        if ((p16 = first_member (pe)) != NULLPE) {
            p15 = p16;

            {
#ifdef DEBUG
                (void) testdebug (p16, "element");
#endif

                if (parse_IF_AttributeType (p16, 1, NULLIP, NULLVP, &((*parm) -> type)) == NOTOK)
                    return NOTOK;
            }
        }
        else {
            advise (NULLCP, "Attribute %selement", PEPY_ERR_MISSING);
            return NOTOK;
        }

    }

    {
        register PE p17;

        if ((p17 = (pe != p15 ? next_member (pe, p15) : first_member (pe))) != NULLPE) {
            p15 = p17;

            {
#ifdef DEBUG
                (void) testdebug (p17, "element");
#endif

                if (parse_IF_AttributeValues (p17, 1, NULLIP, NULLVP, &((*parm) -> values)) == NOTOK)
                    return NOTOK;
            }
        }
        else {
            advise (NULLCP, "Attribute %selement", PEPY_ERR_MISSING);
            return NOTOK;
        }

    }


    if (pe -> pe_cardinal > 2) {
        advise (NULLCP, "Attribute %s(2): %d", PEPY_ERR_TOO_MANY_ELEMENTS,
                pe -> pe_cardinal);
        return NOTOK;
    }

    return OK;
}

/************************ local functions: ************************/


static
PE encode_IF_DER_SET_OF(arg, type)
caddr_t    arg;
int 	   type;
{
	AttrValues		  * attrvalues, * tmp_attrvalues;
	RDName			  * rdname, * tmp_rdname;
	OctetString 		 ** oSTK, * tmp_ostr;
	PE			    p24 = NULLPE, p25 = NULLPE, pe;
	unsigned char  		    a, b;
	int 	       		    n, i, k, j, s, cnt;


	if (! arg){
		/* Force an empty set to be coded */
		pe = pe_alloc (PE_CLASS_UNIV, PE_FORM_CONS, PE_CONS_SET);
		return(pe);
	}


	/* Individual encoding of components of Set-of type */

	switch(type) {

	case ATTRIBUTEVALUES:
		attrvalues = (AttrValues * )arg;

		for (tmp_attrvalues = attrvalues, cnt = 0; tmp_attrvalues; 
			tmp_attrvalues = tmp_attrvalues->next, cnt++)
			/* count */;
	
		oSTK = (OctetString ** )calloc(cnt, sizeof(OctetString * ));
		if(! oSTK)
			return(NULLPE);
	
		i = 0;
		tmp_attrvalues = attrvalues;

		while (tmp_attrvalues){
			tmp_ostr = aux_PE2OctetString(tmp_attrvalues->member_IF_1);		
			oSTK[i] = aux_cpy_OctetString(tmp_ostr);
			aux_free_OctetString(&tmp_ostr);
			if(! oSTK[i++])
				return(NULLPE);
			tmp_attrvalues = tmp_attrvalues->next;
		}
		break;

	case RDNAME:
		rdname = (RDName * )arg;

		for (tmp_rdname = rdname, cnt = 0; tmp_rdname; 
			tmp_rdname = tmp_rdname->next, cnt++)
			/* count */;
	
		oSTK = (OctetString ** )calloc(cnt, sizeof(OctetString * ));
		if(! oSTK)
			return(NULLPE);
	
		i = 0;
		tmp_rdname = rdname;

		while (tmp_rdname){
			tmp_ostr = e_AttributeValueAssertion(tmp_rdname->member_IF_0);		
			oSTK[i] = aux_cpy_OctetString(tmp_ostr);
			aux_free_OctetString(&tmp_ostr);
			if(! oSTK[i++])
				return(NULLPE);
			tmp_rdname = tmp_rdname->next;
		}
		break;

	default:
		return(NULLPE);

	} /* switch */



	/* sort elements of oSTK in ascending order */

	for (i = 0; i < cnt - 1; i++) {
		k = i;
		tmp_ostr = oSTK[i];
		for (j = i + 1; j < cnt; j++) {

			/* n = min(tmp_ostr->noctets, oSTK[j]->noctets) */
			n = tmp_ostr->noctets;
			if(oSTK[j]->noctets < tmp_ostr->noctets)
				n = oSTK[j]->noctets;

			s = 0;
			while (oSTK[j]->octets[s] == tmp_ostr->octets[s] && s < n)
				s++;
			if(s < n && (a = oSTK[j]->octets[s]) < (b = tmp_ostr->octets[s])){
				k = j;
				tmp_ostr = oSTK[j];
			} /* if */

		}  /* for */
		oSTK[k] = oSTK[i];
		oSTK[i] = tmp_ostr;
	}  /* for */


    	if ((pe = pe_alloc (PE_CLASS_UNIV, PE_FORM_CONS, PE_CONS_SET)) == NULLPE)
        	return NULLPE;

    	for(i = 0; i < cnt; i++) {
		p25 = aux_OctetString2PE(oSTK[i]);

        	(void) set_addon (pe, p24, p25);
        	p24 = p25;
    	}


	for(i = 0; i < cnt; i++)
		aux_free_OctetString(&oSTK[i]);

	free (oSTK);

	return(pe);
}


