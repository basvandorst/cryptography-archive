#ifndef COSINE

/* automatically generated by pepy 8.0 #11 (tiber), do not edit! */

#include "psap.h"

#ifndef lint
static char *pepyid = "pepy 8.0 #11 (tiber) of Tue Jun  1 11:43:07 MET DST 1993";
#endif

#ifdef MAC
void	advise (...);
#else
void    advise();
#endif

/* Generated from module AF */
	/* surrounding global definitions	*/
#include        "af.h"

static PE            build_revlist_tbs(), build_revcert_tbs(), build_tbs();
static PE 	     build_pemcrl_tbs();
PE                   aux_OctetString2PE();
struct type_IF_Name *aux_Name2DName();
char                *aux_DName2Name();
OctetString         *aux_PE2OctetString();

#ifndef PEPYPARM
#define PEPYPARM char *
#endif /* PEPYPARM */
extern PEPYPARM NullParm;

/* ARGSUSED */

int	build_AF_Validity (pe, explicit, len, buffer, parm)
register PE     *pe;
int	explicit;
int	len;
char   *buffer;
ToBeSigned *  parm;
{
    PE	p0_z = NULLPE;
    register PE *p0 = &p0_z;

    if (((*pe) = pe_alloc (PE_CLASS_UNIV, PE_FORM_CONS, PE_CONS_SEQ)) == NULLPE) {
        advise (NULLCP, "Validity: %s", PEPY_ERR_NOMEM);
        return NOTOK;
    }
    (*p0) = NULLPE;

    {	/* notBefore */
        if (build_UNIV_UTCTime (p0, 0, NULL, parm -> notbefore , NullParm) == NOTOK)
            return NOTOK;

#ifdef DEBUG
        (void) testdebug ((*p0), "notBefore");
#endif

    }

    if ((*p0) != NULLPE)
        if (seq_add ((*pe), (*p0), -1) == NOTOK) {
            advise (NULLCP, "Validity %s%s", PEPY_ERR_BAD_SEQ,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }
    (*p0) = NULLPE;

    {	/* notAfter */
        if (build_UNIV_UTCTime (p0, 0, NULL, parm -> notafter , NullParm) == NOTOK)
            return NOTOK;

#ifdef DEBUG
        (void) testdebug ((*p0), "notAfter");
#endif

    }

    if ((*p0) != NULLPE)
        if (seq_add ((*pe), (*p0), -1) == NOTOK) {
            advise (NULLCP, "Validity %s%s", PEPY_ERR_BAD_SEQ,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }

#ifdef DEBUG
    (void) testdebug ((*pe), "AF.Validity");
#endif


    return OK;
}

/* ARGSUSED */

int	parse_AF_Validity (pe, explicit, len, buffer, parm)
register PE	pe;
int	explicit;
int    *len;
char  **buffer;
ToBeSigned *  parm;
{
    register PE p1;

#ifdef DEBUG
    (void) testdebug (pe, "AF.Validity");
#endif

    if (explicit) {
        if (pe -> pe_class != PE_CLASS_UNIV
                || pe -> pe_form != PE_FORM_CONS
                || pe -> pe_id != PE_CONS_SEQ) {
            advise (NULLCP, "Validity bad class/form/id: %s/%d/0x%x",
                    pe_classlist[pe -> pe_class], pe -> pe_form, pe -> pe_id);
            return NOTOK;
        }
    }
    else
        if (pe -> pe_form != PE_FORM_CONS) {
            advise (NULLCP, "Validity bad form: %d", pe -> pe_form);
            return NOTOK;
        }

    if ((p1 = prim2seq (pe)) == NULLPE) {
        advise (NULLCP, "Validity %s%s", PEPY_ERR_BAD_SEQ,
                pe_error (pe -> pe_errno));
        return NOTOK;
    }
    pe = p1;

    {
        register PE p2;

        if ((p2 = first_member (pe)) != NULLPE) {
            p1 = p2;

            {	/* notBefore */
#ifdef DEBUG
                (void) testdebug (p2, "notBefore");
#endif

                if (parse_UNIV_UTCTime (p2, 1, NULLIP, &(parm -> notbefore ), NullParm) == NOTOK)
                    return NOTOK;
            }
        }
        else {
            advise (NULLCP, "Validity %snotBefore element", PEPY_ERR_MISSING);
            return NOTOK;
        }

    }

    {
        register PE p3;

        if ((p3 = (pe != p1 ? next_member (pe, p1) : first_member (pe))) != NULLPE) {
            p1 = p3;

            {	/* notAfter */
#ifdef DEBUG
                (void) testdebug (p3, "notAfter");
#endif

                if (parse_UNIV_UTCTime (p3, 1, NULLIP, &(parm -> notafter ), NullParm) == NOTOK)
                    return NOTOK;
            }
        }
        else {
            advise (NULLCP, "Validity %snotAfter element", PEPY_ERR_MISSING);
            return NOTOK;
        }

    }


    if (pe -> pe_cardinal > 2) {
        advise (NULLCP, "Validity %s(2): %d", PEPY_ERR_TOO_MANY_ELEMENTS,
                pe -> pe_cardinal);
        return NOTOK;
    }

    return OK;
}

/* ARGSUSED */

int	build_AF_PKRootValidity (pe, explicit, len, buffer, parm)
register PE     *pe;
int	explicit;
int	len;
char   *buffer;
Serial *  parm;
{
    PE	p4_z = NULLPE;
    register PE *p4 = &p4_z;

    if (((*pe) = pe_alloc (PE_CLASS_UNIV, PE_FORM_CONS, PE_CONS_SEQ)) == NULLPE) {
        advise (NULLCP, "PKRootValidity: %s", PEPY_ERR_NOMEM);
        return NOTOK;
    }
    (*p4) = NULLPE;

    {	/* notBefore */
        if (build_UNIV_UTCTime (p4, 0, NULL, parm -> notbefore , NullParm) == NOTOK)
            return NOTOK;

#ifdef DEBUG
        (void) testdebug ((*p4), "notBefore");
#endif

    }

    if ((*p4) != NULLPE)
        if (seq_add ((*pe), (*p4), -1) == NOTOK) {
            advise (NULLCP, "PKRootValidity %s%s", PEPY_ERR_BAD_SEQ,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }
    (*p4) = NULLPE;

    {	/* notAfter */
        if (build_UNIV_UTCTime (p4, 0, NULL, parm -> notafter , NullParm) == NOTOK)
            return NOTOK;

#ifdef DEBUG
        (void) testdebug ((*p4), "notAfter");
#endif

    }

    if ((*p4) != NULLPE)
        if (seq_add ((*pe), (*p4), -1) == NOTOK) {
            advise (NULLCP, "PKRootValidity %s%s", PEPY_ERR_BAD_SEQ,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }

#ifdef DEBUG
    (void) testdebug ((*pe), "AF.PKRootValidity");
#endif


    return OK;
}

/* ARGSUSED */

int	parse_AF_PKRootValidity (pe, explicit, len, buffer, parm)
register PE	pe;
int	explicit;
int    *len;
char  **buffer;
Serial *  parm;
{
    register PE p5;

#ifdef DEBUG
    (void) testdebug (pe, "AF.PKRootValidity");
#endif

    if (explicit) {
        if (pe -> pe_class != PE_CLASS_UNIV
                || pe -> pe_form != PE_FORM_CONS
                || pe -> pe_id != PE_CONS_SEQ) {
            advise (NULLCP, "PKRootValidity bad class/form/id: %s/%d/0x%x",
                    pe_classlist[pe -> pe_class], pe -> pe_form, pe -> pe_id);
            return NOTOK;
        }
    }
    else
        if (pe -> pe_form != PE_FORM_CONS) {
            advise (NULLCP, "PKRootValidity bad form: %d", pe -> pe_form);
            return NOTOK;
        }

    if ((p5 = prim2seq (pe)) == NULLPE) {
        advise (NULLCP, "PKRootValidity %s%s", PEPY_ERR_BAD_SEQ,
                pe_error (pe -> pe_errno));
        return NOTOK;
    }
    pe = p5;

    {
        register PE p6;

        if ((p6 = first_member (pe)) != NULLPE) {
            p5 = p6;

            {	/* notBefore */
#ifdef DEBUG
                (void) testdebug (p6, "notBefore");
#endif

                if (parse_UNIV_UTCTime (p6, 1, NULLIP, &(parm -> notbefore ), NullParm) == NOTOK)
                    return NOTOK;
            }
        }
        else {
            advise (NULLCP, "PKRootValidity %snotBefore element", PEPY_ERR_MISSING);
            return NOTOK;
        }

    }

    {
        register PE p7;

        if ((p7 = (pe != p5 ? next_member (pe, p5) : first_member (pe))) != NULLPE) {
            p5 = p7;

            {	/* notAfter */
#ifdef DEBUG
                (void) testdebug (p7, "notAfter");
#endif

                if (parse_UNIV_UTCTime (p7, 1, NULLIP, &(parm -> notafter ), NullParm) == NOTOK)
                    return NOTOK;
            }
        }
        else {
            advise (NULLCP, "PKRootValidity %snotAfter element", PEPY_ERR_MISSING);
            return NOTOK;
        }

    }


    if (pe -> pe_cardinal > 2) {
        advise (NULLCP, "PKRootValidity %s(2): %d", PEPY_ERR_TOO_MANY_ELEMENTS,
                pe -> pe_cardinal);
        return NOTOK;
    }

    return OK;
}

/* ARGSUSED */

int	build_AF_SerialNumbers (pe, explicit, len, buffer, parm)
register PE     *pe;
int	explicit;
int	len;
char   *buffer;
SerialNumbers * parm;
{
    PE	p8_z = NULLPE;
    register PE *p8 = &p8_z;

    if (((*pe) = pe_alloc (PE_CLASS_UNIV, PE_FORM_CONS, PE_CONS_SEQ)) == NULLPE) {
        advise (NULLCP, "SerialNumbers: %s", PEPY_ERR_NOMEM);
        return NOTOK;
    }
    (*p8) = NULLPE;

    if (parm->initial != 0) {
        register integer p9 = parm->initial ;

        if (((*p8) = num2prim (p9, PE_CLASS_UNIV, PE_PRIM_INT)) == NULLPE) {
            advise (NULLCP, "element: %s", PEPY_ERR_NOMEM);
            return NOTOK;
        }
        {	/* element TAG PUSHDOWN */
            PE p10_z;
            register PE *p10 = &p10_z;

            if ((*p10 = pe_alloc (PE_CLASS_CONT, PE_FORM_CONS, 0)) == NULLPE) {
                advise (NULLCP, "element: %s", PEPY_ERR_NOMEM);
                return NOTOK;
            }
            (*p10) -> pe_cons = (*p8);
            (*p8) = *p10;
        }

#ifdef DEBUG
        (void) testdebug ((*p8), "element");
#endif

    }

    if ((*p8) != NULLPE)
        if (seq_add ((*pe), (*p8), -1) == NOTOK) {
            advise (NULLCP, "SerialNumbers %s%s", PEPY_ERR_BAD_SEQ,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }
    (*p8) = NULLPE;

    {
        register integer p11 = parm->actual ;

        if (((*p8) = num2prim (p11, PE_CLASS_UNIV, PE_PRIM_INT)) == NULLPE) {
            advise (NULLCP, "element: %s", PEPY_ERR_NOMEM);
            return NOTOK;
        }
        {	/* element TAG PUSHDOWN */
            PE p12_z;
            register PE *p12 = &p12_z;

            if ((*p12 = pe_alloc (PE_CLASS_CONT, PE_FORM_CONS, 1)) == NULLPE) {
                advise (NULLCP, "element: %s", PEPY_ERR_NOMEM);
                return NOTOK;
            }
            (*p12) -> pe_cons = (*p8);
            (*p8) = *p12;
        }

#ifdef DEBUG
        (void) testdebug ((*p8), "element");
#endif

    }

    if ((*p8) != NULLPE)
        if (seq_add ((*pe), (*p8), -1) == NOTOK) {
            advise (NULLCP, "SerialNumbers %s%s", PEPY_ERR_BAD_SEQ,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }

#ifdef DEBUG
    (void) testdebug ((*pe), "AF.SerialNumbers");
#endif


    return OK;
}

/* ARGSUSED */

int	build_AF_PKRoot (pe, explicit, len, buffer, parm)
register PE     *pe;
int	explicit;
int	len;
char   *buffer;
PKRoot * parm;
{
    PE	p13_z = NULLPE;
    register PE *p13 = &p13_z;

    if (((*pe) = pe_alloc (PE_CLASS_UNIV, PE_FORM_CONS, PE_CONS_SEQ)) == NULLPE) {
        advise (NULLCP, "PKRoot: %s", PEPY_ERR_NOMEM);
        return NOTOK;
    }
    (*p13) = NULLPE;

    {	/* cA */
        if (build_IF_Name (p13, 0, NULL, NULLCP, parm -> ca ) == NOTOK)
            return NOTOK;

#ifdef DEBUG
        (void) testdebug ((*p13), "cA");
#endif

    }

    if ((*p13) != NULLPE)
        if (seq_add ((*pe), (*p13), -1) == NOTOK) {
            advise (NULLCP, "PKRoot %s%s", PEPY_ERR_BAD_SEQ,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }
    (*p13) = NULLPE;

    {	/* newkey */
        if (build_AF_RootKey (p13, 0, NULL, NULLCP, parm -> newkey ) == NOTOK)
            return NOTOK;

#ifdef DEBUG
        (void) testdebug ((*p13), "newkey");
#endif

    }

    if ((*p13) != NULLPE)
        if (seq_add ((*pe), (*p13), -1) == NOTOK) {
            advise (NULLCP, "PKRoot %s%s", PEPY_ERR_BAD_SEQ,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }
    (*p13) = NULLPE;

    if (parm -> oldkey) {	/* oldkey */
        if (build_AF_RootKey (p13, 0, NULL, NULLCP, parm -> oldkey ) == NOTOK)
            return NOTOK;

#ifdef DEBUG
        (void) testdebug ((*p13), "oldkey");
#endif

    }

    if ((*p13) != NULLPE)
        if (seq_add ((*pe), (*p13), -1) == NOTOK) {
            advise (NULLCP, "PKRoot %s%s", PEPY_ERR_BAD_SEQ,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }

#ifdef DEBUG
    (void) testdebug ((*pe), "AF.PKRoot");
#endif


    return OK;
}

/* ARGSUSED */

int	build_AF_RootKey (pe, explicit, len, buffer, parm)
register PE     *pe;
int	explicit;
int	len;
char   *buffer;
struct Serial * parm;
{
    PE	p14_z = NULLPE;
    register PE *p14 = &p14_z;

    if (((*pe) = pe_alloc (PE_CLASS_UNIV, PE_FORM_CONS, PE_CONS_SEQ)) == NULLPE) {
        advise (NULLCP, "RootKey: %s", PEPY_ERR_NOMEM);
        return NOTOK;
    }
    (*p14) = NULLPE;

    if (parm->version != 0) {	/* version */
        register integer p15 = parm->version ;

        if (((*p14) = num2prim (p15, PE_CLASS_UNIV, PE_PRIM_INT)) == NULLPE) {
            advise (NULLCP, "version: %s", PEPY_ERR_NOMEM);
            return NOTOK;
        }
        switch (p15) {
            case 0:	/* v1988 */
                break;
        }
        {	/* version TAG PUSHDOWN */
            PE p16_z;
            register PE *p16 = &p16_z;

            if ((*p16 = pe_alloc (PE_CLASS_CONT, PE_FORM_CONS, 0)) == NULLPE) {
                advise (NULLCP, "version: %s", PEPY_ERR_NOMEM);
                return NOTOK;
            }
            (*p16) -> pe_cons = (*p14);
            (*p14) = *p16;
        }

#ifdef DEBUG
        (void) testdebug ((*p14), "version");
#endif

    }

    if ((*p14) != NULLPE)
        if (seq_add ((*pe), (*p14), -1) == NOTOK) {
            advise (NULLCP, "RootKey %s%s", PEPY_ERR_BAD_SEQ,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }
    (*p14) = NULLPE;

    {	/* serial */
        register integer p17 = parm->serial ;

        if (((*p14) = num2prim (p17, PE_CLASS_UNIV, PE_PRIM_INT)) == NULLPE) {
            advise (NULLCP, "serial: %s", PEPY_ERR_NOMEM);
            return NOTOK;
        }

#ifdef DEBUG
        (void) testdebug ((*p14), "serial");
#endif

    }

    if ((*p14) != NULLPE)
        if (seq_add ((*pe), (*p14), -1) == NOTOK) {
            advise (NULLCP, "RootKey %s%s", PEPY_ERR_BAD_SEQ,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }
    (*p14) = NULLPE;

    {	/* key */
        if (build_SEC_KeyInfo (p14, 0, NULL, NULLCP, parm->key ) == NOTOK)
            return NOTOK;

#ifdef DEBUG
        (void) testdebug ((*p14), "key");
#endif

    }

    if ((*p14) != NULLPE)
        if (seq_add ((*pe), (*p14), -1) == NOTOK) {
            advise (NULLCP, "RootKey %s%s", PEPY_ERR_BAD_SEQ,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }
    (*p14) = NULLPE;

    if (parm->notbefore) {	/* validity */
        if (build_AF_PKRootValidity (p14, 0, NULL, NULLCP, parm ) == NOTOK)
            return NOTOK;
        {	/* validity TAG PUSHDOWN */
            PE p18_z;
            register PE *p18 = &p18_z;

            if ((*p18 = pe_alloc (PE_CLASS_CONT, PE_FORM_CONS, 1)) == NULLPE) {
                advise (NULLCP, "validity: %s", PEPY_ERR_NOMEM);
                return NOTOK;
            }
            (*p18) -> pe_cons = (*p14);
            (*p14) = *p18;
        }

#ifdef DEBUG
        (void) testdebug ((*p14), "validity");
#endif

    }

    if ((*p14) != NULLPE)
        if (seq_add ((*pe), (*p14), -1) == NOTOK) {
            advise (NULLCP, "RootKey %s%s", PEPY_ERR_BAD_SEQ,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }
    (*p14) = NULLPE;

    if (parm->sig) {	/* signAlgID */
        if (build_SEC_AlgorithmIdentifier (p14, 0, NULL, NULLCP, parm->sig->signAI ) == NOTOK)
            return NOTOK;
        {	/* signAlgID TAG PUSHDOWN */
            PE p19_z;
            register PE *p19 = &p19_z;

            if ((*p19 = pe_alloc (PE_CLASS_CONT, PE_FORM_CONS, 2)) == NULLPE) {
                advise (NULLCP, "signAlgID: %s", PEPY_ERR_NOMEM);
                return NOTOK;
            }
            (*p19) -> pe_cons = (*p14);
            (*p14) = *p19;
        }

#ifdef DEBUG
        (void) testdebug ((*p14), "signAlgID");
#endif

    }

    if ((*p14) != NULLPE)
        if (seq_add ((*pe), (*p14), -1) == NOTOK) {
            advise (NULLCP, "RootKey %s%s", PEPY_ERR_BAD_SEQ,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }
    (*p14) = NULLPE;

    if (parm -> sig) {	/* signBitString */
        PE	p20_z = NULLPE;
        register PE *p20 = &p20_z;

        char *p21;
        int p22;
        p21 = parm->sig->signature.bits ;
        p22 = 
		     parm->sig->signature.nbits ;
        (*p20) = p21 ? strb2bitstr (p21, p22, PE_CLASS_UNIV, PE_PRIM_BITS) : NULLPE;
        if ((*p20) == NULLPE) {
            advise (NULLCP, "signBitString %s", PEPY_ERR_INIT_FAILED);
            return NOTOK;
        }
        if (((*p14) = bit2prim ((*p20))) == NULLPE) {
            advise (NULLCP, "signBitString: %s", PEPY_ERR_NOMEM);
            return NOTOK;
        }

#ifdef DEBUG
        (void) testdebug ((*p14), "signBitString");
#endif

    }

    if ((*p14) != NULLPE)
        if (seq_add ((*pe), (*p14), -1) == NOTOK) {
            advise (NULLCP, "RootKey %s%s", PEPY_ERR_BAD_SEQ,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }

#ifdef DEBUG
    (void) testdebug ((*pe), "AF.RootKey");
#endif


    return OK;
}

/* ARGSUSED */

int	build_AF_TBSCertificate (pe, explicit, len, buffer, parm)
register PE     *pe;
int	explicit;
int	len;
char   *buffer;
ToBeSigned * parm;
{
    PE	p23_z = NULLPE;
    register PE *p23 = &p23_z;

    if (((*pe) = pe_alloc (PE_CLASS_UNIV, PE_FORM_CONS, PE_CONS_SEQ)) == NULLPE) {
        advise (NULLCP, "TBSCertificate: %s", PEPY_ERR_NOMEM);
        return NOTOK;
    }
    (*p23) = NULLPE;

    if (parm -> version != 0) {	/* version */
        register integer p24 = parm -> version ;

        if (((*p23) = num2prim (p24, PE_CLASS_UNIV, PE_PRIM_INT)) == NULLPE) {
            advise (NULLCP, "version: %s", PEPY_ERR_NOMEM);
            return NOTOK;
        }
        switch (p24) {
            case 0:	/* v1988 */
                break;
        }
        {	/* version TAG PUSHDOWN */
            PE p25_z;
            register PE *p25 = &p25_z;

            if ((*p25 = pe_alloc (PE_CLASS_CONT, PE_FORM_CONS, 0)) == NULLPE) {
                advise (NULLCP, "version: %s", PEPY_ERR_NOMEM);
                return NOTOK;
            }
            (*p25) -> pe_cons = (*p23);
            (*p23) = *p25;
        }

#ifdef DEBUG
        (void) testdebug ((*p23), "version");
#endif

    }

    if ((*p23) != NULLPE)
        if (seq_add ((*pe), (*p23), -1) == NOTOK) {
            advise (NULLCP, "TBSCertificate %s%s", PEPY_ERR_BAD_SEQ,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }
    (*p23) = NULLPE;

    {	/* serialNumber */
        register integer p26 = parm -> serialnumber ;

        if (((*p23) = num2prim (p26, PE_CLASS_UNIV, PE_PRIM_INT)) == NULLPE) {
            advise (NULLCP, "serialNumber: %s", PEPY_ERR_NOMEM);
            return NOTOK;
        }

#ifdef DEBUG
        (void) testdebug ((*p23), "serialNumber");
#endif

    }

    if ((*p23) != NULLPE)
        if (seq_add ((*pe), (*p23), -1) == NOTOK) {
            advise (NULLCP, "TBSCertificate %s%s", PEPY_ERR_BAD_SEQ,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }
    (*p23) = NULLPE;

    {	/* signature */
        if (build_SEC_AlgorithmIdentifier (p23, 0, NULL, NULLCP, parm -> signatureAI ) == NOTOK)
            return NOTOK;

#ifdef DEBUG
        (void) testdebug ((*p23), "signature");
#endif

    }

    if ((*p23) != NULLPE)
        if (seq_add ((*pe), (*p23), -1) == NOTOK) {
            advise (NULLCP, "TBSCertificate %s%s", PEPY_ERR_BAD_SEQ,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }
    (*p23) = NULLPE;

    {	/* issuer */
        if (build_IF_Name (p23, 0, NULL, NULLCP, parm -> issuer ) == NOTOK)
            return NOTOK;

#ifdef DEBUG
        (void) testdebug ((*p23), "issuer");
#endif

    }

    if ((*p23) != NULLPE)
        if (seq_add ((*pe), (*p23), -1) == NOTOK) {
            advise (NULLCP, "TBSCertificate %s%s", PEPY_ERR_BAD_SEQ,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }
    (*p23) = NULLPE;

    {	/* validity */
        if (build_AF_Validity (p23, 0, NULL, NULLCP, parm ) == NOTOK)
            return NOTOK;

#ifdef DEBUG
        (void) testdebug ((*p23), "validity");
#endif

    }

    if ((*p23) != NULLPE)
        if (seq_add ((*pe), (*p23), -1) == NOTOK) {
            advise (NULLCP, "TBSCertificate %s%s", PEPY_ERR_BAD_SEQ,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }
    (*p23) = NULLPE;

    {	/* subject */
        if (build_IF_Name (p23, 0, NULL, NULLCP, parm -> subject ) == NOTOK)
            return NOTOK;

#ifdef DEBUG
        (void) testdebug ((*p23), "subject");
#endif

    }

    if ((*p23) != NULLPE)
        if (seq_add ((*pe), (*p23), -1) == NOTOK) {
            advise (NULLCP, "TBSCertificate %s%s", PEPY_ERR_BAD_SEQ,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }
    (*p23) = NULLPE;

    {	/* subjectPublickeyInfo */
        if (build_SEC_KeyInfo (p23, 0, NULL, NULLCP, parm -> subjectPK ) == NOTOK)
            return NOTOK;

#ifdef DEBUG
        (void) testdebug ((*p23), "subjectPublickeyInfo");
#endif

    }

    if ((*p23) != NULLPE)
        if (seq_add ((*pe), (*p23), -1) == NOTOK) {
            advise (NULLCP, "TBSCertificate %s%s", PEPY_ERR_BAD_SEQ,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }

#ifdef DEBUG
    (void) testdebug ((*pe), "AF.TBSCertificate");
#endif


    return OK;
}

/* ARGSUSED */

int	build_AF_Certificate (pe, explicit, len, buffer, parm)
register PE     *pe;
int	explicit;
int	len;
char   *buffer;
Certificate * parm;
{
    	PE	tbs;

    PE	p27_z = NULLPE;
    register PE *p27 = &p27_z;

    if (((*pe) = pe_alloc (PE_CLASS_UNIV, PE_FORM_CONS, PE_CONS_SEQ)) == NULLPE) {
        advise (NULLCP, "Certificate: %s", PEPY_ERR_NOMEM);
        return NOTOK;
    }
    (*p27) = NULLPE;

    {
        PE	p28 = (build_tbs(parm,&tbs)) ;

        if (p28 == NULLPE) {
            advise (NULLCP, "element %s", PEPY_ERR_INIT_FAILED);
            return NOTOK;
        }
        ((*p27) = p28) -> pe_refcnt++;

#ifdef DEBUG
        (void) testdebug ((*p27), "element");
#endif

        {
    pe_free(tbs);
		
        }
    }

    if ((*p27) != NULLPE)
        if (seq_add ((*pe), (*p27), -1) == NOTOK) {
            advise (NULLCP, "Certificate %s%s", PEPY_ERR_BAD_SEQ,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }
    (*p27) = NULLPE;

    {
        if (build_SEC_AlgorithmIdentifier (p27, 0, NULL, NULLCP, parm -> sig ->signAI ) == NOTOK)
            return NOTOK;

#ifdef DEBUG
        (void) testdebug ((*p27), "element");
#endif

    }

    if ((*p27) != NULLPE)
        if (seq_add ((*pe), (*p27), -1) == NOTOK) {
            advise (NULLCP, "Certificate %s%s", PEPY_ERR_BAD_SEQ,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }
    (*p27) = NULLPE;

    {
        PE	p29_z = NULLPE;
        register PE *p29 = &p29_z;

        char *p30;
        int p31;
        p30 = parm->sig->signature.bits ;
        p31 = 
		     parm->sig->signature.nbits ;
        (*p29) = p30 ? strb2bitstr (p30, p31, PE_CLASS_UNIV, PE_PRIM_BITS) : NULLPE;
        if ((*p29) == NULLPE) {
            advise (NULLCP, "element %s", PEPY_ERR_INIT_FAILED);
            return NOTOK;
        }
        if (((*p27) = bit2prim ((*p29))) == NULLPE) {
            advise (NULLCP, "element: %s", PEPY_ERR_NOMEM);
            return NOTOK;
        }

#ifdef DEBUG
        (void) testdebug ((*p27), "element");
#endif

    }

    if ((*p27) != NULLPE)
        if (seq_add ((*pe), (*p27), -1) == NOTOK) {
            advise (NULLCP, "Certificate %s%s", PEPY_ERR_BAD_SEQ,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }

#ifdef DEBUG
    (void) testdebug ((*pe), "AF.Certificate");
#endif


    return OK;
}

/* ARGSUSED */

int	build_AF_Certificates (pe, explicit, len, buffer, parm)
register PE     *pe;
int	explicit;
int	len;
char   *buffer;
Certificates * parm;
{
    PE	p32_z = NULLPE;
    register PE *p32 = &p32_z;

    if (((*pe) = pe_alloc (PE_CLASS_UNIV, PE_FORM_CONS, PE_CONS_SEQ)) == NULLPE) {
        advise (NULLCP, "Certificates: %s", PEPY_ERR_NOMEM);
        return NOTOK;
    }
    (*p32) = NULLPE;

    {	/* certificate */
        if (build_AF_Certificate (p32, 0, NULL, NULLCP, parm -> usercertificate ) == NOTOK)
            return NOTOK;

#ifdef DEBUG
        (void) testdebug ((*p32), "certificate");
#endif

    }

    if ((*p32) != NULLPE)
        if (seq_add ((*pe), (*p32), -1) == NOTOK) {
            advise (NULLCP, "Certificates %s%s", PEPY_ERR_BAD_SEQ,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }
    (*p32) = NULLPE;

    if (parm -> forwardpath) {	/* certificationPath */
        if (build_AF_ForwardCertificationPath (p32, 0, NULL, NULLCP, parm -> forwardpath ) == NOTOK)
            return NOTOK;

#ifdef DEBUG
        (void) testdebug ((*p32), "certificationPath");
#endif

    }

    if ((*p32) != NULLPE)
        if (seq_add ((*pe), (*p32), -1) == NOTOK) {
            advise (NULLCP, "Certificates %s%s", PEPY_ERR_BAD_SEQ,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }

#ifdef DEBUG
    (void) testdebug ((*pe), "AF.Certificates");
#endif


    return OK;
}

/* ARGSUSED */

int	build_AF_ForwardCertificationPath (pe, explicit, len, buffer, parm)
register PE     *pe;
int	explicit;
int	len;
char   *buffer;
FCPath * parm;
{
    PE	p33 = NULLPE;
    PE	p34_z = NULLPE;
    register PE *p34 = &p34_z;

    if (((*pe) = pe_alloc (PE_CLASS_UNIV, PE_FORM_CONS, PE_CONS_SEQ)) == NULLPE) {
        advise (NULLCP, "ForwardCertificationPath: %s", PEPY_ERR_NOMEM);
        return NOTOK;
    }
    for (; parm; parm = parm -> next_forwardpath) {
        if (build_AF_CertificateSet (p34, 0, NULL, NULLCP, parm -> liste ) == NOTOK)
            return NOTOK;

#ifdef DEBUG
        (void) testdebug ((*p34), "element");
#endif

        (void) seq_addon ((*pe), p33, (*p34));
        p33 = (*p34);
    }

#ifdef DEBUG
    (void) testdebug ((*pe), "AF.ForwardCertificationPath");
#endif


    return OK;
}

/* ARGSUSED */

int	build_AF_CertificateSet (pe, explicit, len, buffer, parm)
register PE     *pe;
int	explicit;
int	len;
char   *buffer;
SET_OF_Certificate * parm;
{
    PE	p35 = NULLPE;
    PE	p36_z = NULLPE;
    register PE *p36 = &p36_z;

    if (((*pe) = pe_alloc (PE_CLASS_UNIV, PE_FORM_CONS, PE_CONS_SET)) == NULLPE) {
        advise (NULLCP, "CertificateSet: %s", PEPY_ERR_NOMEM);
        return NOTOK;
    }
    for (; parm; parm = parm -> next) {
        if (build_AF_Certificate (p36, 0, NULL, NULLCP, parm -> element ) == NOTOK)
            return NOTOK;

#ifdef DEBUG
        (void) testdebug ((*p36), "member");
#endif

        (void) set_addon ((*pe), p35, (*p36));
        p35 = (*p36);
    }

#ifdef DEBUG
    (void) testdebug ((*pe), "AF.CertificateSet");
#endif


    return OK;
}

/* ARGSUSED */

int	build_AF_CertificatePair (pe, explicit, len, buffer, parm)
register PE     *pe;
int	explicit;
int	len;
char   *buffer;
CertificatePair * parm;
{
    PE	p37_z = NULLPE;
    register PE *p37 = &p37_z;

    if (((*pe) = pe_alloc (PE_CLASS_UNIV, PE_FORM_CONS, PE_CONS_SEQ)) == NULLPE) {
        advise (NULLCP, "CertificatePair: %s", PEPY_ERR_NOMEM);
        return NOTOK;
    }
    (*p37) = NULLPE;

    if (parm -> forward) {	/* forward */
        if (build_AF_Certificate (p37, 0, NULL, NULLCP, parm -> forward ) == NOTOK)
            return NOTOK;
        {	/* forward TAG PUSHDOWN */
            PE p38_z;
            register PE *p38 = &p38_z;

            if ((*p38 = pe_alloc (PE_CLASS_CONT, PE_FORM_CONS, 0)) == NULLPE) {
                advise (NULLCP, "forward: %s", PEPY_ERR_NOMEM);
                return NOTOK;
            }
            (*p38) -> pe_cons = (*p37);
            (*p37) = *p38;
        }

#ifdef DEBUG
        (void) testdebug ((*p37), "forward");
#endif

    }

    if ((*p37) != NULLPE)
        if (seq_add ((*pe), (*p37), -1) == NOTOK) {
            advise (NULLCP, "CertificatePair %s%s", PEPY_ERR_BAD_SEQ,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }
    (*p37) = NULLPE;

    if (parm -> reverse) {	/* reverse */
        if (build_AF_Certificate (p37, 0, NULL, NULLCP, parm -> reverse ) == NOTOK)
            return NOTOK;
        {	/* reverse TAG PUSHDOWN */
            PE p39_z;
            register PE *p39 = &p39_z;

            if ((*p39 = pe_alloc (PE_CLASS_CONT, PE_FORM_CONS, 1)) == NULLPE) {
                advise (NULLCP, "reverse: %s", PEPY_ERR_NOMEM);
                return NOTOK;
            }
            (*p39) -> pe_cons = (*p37);
            (*p37) = *p39;
        }

#ifdef DEBUG
        (void) testdebug ((*p37), "reverse");
#endif

    }

    if ((*p37) != NULLPE)
        if (seq_add ((*pe), (*p37), -1) == NOTOK) {
            advise (NULLCP, "CertificatePair %s%s", PEPY_ERR_BAD_SEQ,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }

#ifdef DEBUG
    (void) testdebug ((*pe), "AF.CertificatePair");
#endif


    return OK;
}

/* ARGSUSED */

int	build_AF_CrossCertificatePair (pe, explicit, len, buffer, parm)
register PE     *pe;
int	explicit;
int	len;
char   *buffer;
SET_OF_CertificatePair * parm;
{
    PE	p40 = NULLPE;
    PE	p41_z = NULLPE;
    register PE *p41 = &p41_z;

    if (((*pe) = pe_alloc (PE_CLASS_UNIV, PE_FORM_CONS, PE_CONS_SET)) == NULLPE) {
        advise (NULLCP, "CrossCertificatePair: %s", PEPY_ERR_NOMEM);
        return NOTOK;
    }
    for (; parm; parm = parm -> next) {
        if (build_AF_CertificatePair (p41, 0, NULL, NULLCP, parm -> element ) == NOTOK)
            return NOTOK;

#ifdef DEBUG
        (void) testdebug ((*p41), "member");
#endif

        (void) set_addon ((*pe), p40, (*p41));
        p40 = (*p41);
    }

#ifdef DEBUG
    (void) testdebug ((*pe), "AF.CrossCertificatePair");
#endif


    return OK;
}

/* ARGSUSED */

int	build_AF_PKList (pe, explicit, len, buffer, parm)
register PE     *pe;
int	explicit;
int	len;
char   *buffer;
PKList * parm;
{
    PE	p42 = NULLPE;
    PE	p43_z = NULLPE;
    register PE *p43 = &p43_z;

    if (((*pe) = pe_alloc (PE_CLASS_UNIV, PE_FORM_CONS, PE_CONS_SET)) == NULLPE) {
        advise (NULLCP, "PKList: %s", PEPY_ERR_NOMEM);
        return NOTOK;
    }
    for (; parm; parm = parm -> next) {
        if (build_AF_TBSCertificate (p43, 0, NULL, NULLCP, parm -> element ) == NOTOK)
            return NOTOK;

#ifdef DEBUG
        (void) testdebug ((*p43), "member");
#endif

        (void) set_addon ((*pe), p42, (*p43));
        p42 = (*p43);
    }

#ifdef DEBUG
    (void) testdebug ((*pe), "AF.PKList");
#endif


    return OK;
}

/* ARGSUSED */

int	build_AF_TBSCrl (pe, explicit, len, buffer, parm)
register PE     *pe;
int	explicit;
int	len;
char   *buffer;
CrlTBS * parm;
{
    PE	p44_z = NULLPE;
    register PE *p44 = &p44_z;

    if (((*pe) = pe_alloc (PE_CLASS_UNIV, PE_FORM_CONS, PE_CONS_SEQ)) == NULLPE) {
        advise (NULLCP, "TBSCrl: %s", PEPY_ERR_NOMEM);
        return NOTOK;
    }
    (*p44) = NULLPE;

    {	/* signature */
        if (build_SEC_AlgorithmIdentifier (p44, 0, NULL, NULLCP, parm->signatureAI ) == NOTOK)
            return NOTOK;

#ifdef DEBUG
        (void) testdebug ((*p44), "signature");
#endif

    }

    if ((*p44) != NULLPE)
        if (seq_add ((*pe), (*p44), -1) == NOTOK) {
            advise (NULLCP, "TBSCrl %s%s", PEPY_ERR_BAD_SEQ,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }
    (*p44) = NULLPE;

    {	/* issuer */
        if (build_IF_Name (p44, 0, NULL, NULLCP, parm->issuer ) == NOTOK)
            return NOTOK;

#ifdef DEBUG
        (void) testdebug ((*p44), "issuer");
#endif

    }

    if ((*p44) != NULLPE)
        if (seq_add ((*pe), (*p44), -1) == NOTOK) {
            advise (NULLCP, "TBSCrl %s%s", PEPY_ERR_BAD_SEQ,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }
    (*p44) = NULLPE;

    {	/* lastUpdate */
        if (build_UNIV_UTCTime (p44, 0, NULL, parm->lastupdate , NullParm) == NOTOK)
            return NOTOK;

#ifdef DEBUG
        (void) testdebug ((*p44), "lastUpdate");
#endif

    }

    if ((*p44) != NULLPE)
        if (seq_add ((*pe), (*p44), -1) == NOTOK) {
            advise (NULLCP, "TBSCrl %s%s", PEPY_ERR_BAD_SEQ,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }
    (*p44) = NULLPE;

    if (parm->revokedcertificates) {	/* revokedCertificates */
        if (build_AF_RevCertSequence (p44, 0, NULL, NULLCP, parm->revokedcertificates ) == NOTOK)
            return NOTOK;

#ifdef DEBUG
        (void) testdebug ((*p44), "revokedCertificates");
#endif

    }

    if ((*p44) != NULLPE)
        if (seq_add ((*pe), (*p44), -1) == NOTOK) {
            advise (NULLCP, "TBSCrl %s%s", PEPY_ERR_BAD_SEQ,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }

#ifdef DEBUG
    (void) testdebug ((*pe), "AF.TBSCrl");
#endif


    return OK;
}

/* ARGSUSED */

int	build_AF_Crl (pe, explicit, len, buffer, parm)
register PE     *pe;
int	explicit;
int	len;
char   *buffer;
Crl * parm;
{
    
	PE tbs;
    
    PE	p45_z = NULLPE;
    register PE *p45 = &p45_z;

    if (((*pe) = pe_alloc (PE_CLASS_UNIV, PE_FORM_CONS, PE_CONS_SEQ)) == NULLPE) {
        advise (NULLCP, "Crl: %s", PEPY_ERR_NOMEM);
        return NOTOK;
    }
    (*p45) = NULLPE;

    {
        PE	p46 = (build_revlist_tbs(parm,&tbs)) ;

        if (p46 == NULLPE) {
            advise (NULLCP, "element %s", PEPY_ERR_INIT_FAILED);
            return NOTOK;
        }
        ((*p45) = p46) -> pe_refcnt++;

#ifdef DEBUG
        (void) testdebug ((*p45), "element");
#endif

        {
   pe_free(tbs);
		
        }
    }

    if ((*p45) != NULLPE)
        if (seq_add ((*pe), (*p45), -1) == NOTOK) {
            advise (NULLCP, "Crl %s%s", PEPY_ERR_BAD_SEQ,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }
    (*p45) = NULLPE;

    {
        if (build_SEC_AlgorithmIdentifier (p45, 0, NULL, NULLCP, parm->sig->signAI ) == NOTOK)
            return NOTOK;

#ifdef DEBUG
        (void) testdebug ((*p45), "element");
#endif

    }

    if ((*p45) != NULLPE)
        if (seq_add ((*pe), (*p45), -1) == NOTOK) {
            advise (NULLCP, "Crl %s%s", PEPY_ERR_BAD_SEQ,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }
    (*p45) = NULLPE;

    {
        PE	p47_z = NULLPE;
        register PE *p47 = &p47_z;

        char *p48;
        int p49;
        p48 = parm->sig->signature.bits ;
        p49 = 
		     parm->sig->signature.nbits ;
        (*p47) = p48 ? strb2bitstr (p48, p49, PE_CLASS_UNIV, PE_PRIM_BITS) : NULLPE;
        if ((*p47) == NULLPE) {
            advise (NULLCP, "element %s", PEPY_ERR_INIT_FAILED);
            return NOTOK;
        }
        if (((*p45) = bit2prim ((*p47))) == NULLPE) {
            advise (NULLCP, "element: %s", PEPY_ERR_NOMEM);
            return NOTOK;
        }

#ifdef DEBUG
        (void) testdebug ((*p45), "element");
#endif

    }

    if ((*p45) != NULLPE)
        if (seq_add ((*pe), (*p45), -1) == NOTOK) {
            advise (NULLCP, "Crl %s%s", PEPY_ERR_BAD_SEQ,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }

#ifdef DEBUG
    (void) testdebug ((*pe), "AF.Crl");
#endif


    return OK;
}

/* ARGSUSED */

int	build_AF_TBSRevCert (pe, explicit, len, buffer, parm)
register PE     *pe;
int	explicit;
int	len;
char   *buffer;
RevCertTBS * parm;
{
    PE	p50_z = NULLPE;
    register PE *p50 = &p50_z;

    if (((*pe) = pe_alloc (PE_CLASS_UNIV, PE_FORM_CONS, PE_CONS_SEQ)) == NULLPE) {
        advise (NULLCP, "TBSRevCert: %s", PEPY_ERR_NOMEM);
        return NOTOK;
    }
    (*p50) = NULLPE;

    {	/* signature */
        if (build_SEC_AlgorithmIdentifier (p50, 0, NULL, NULLCP, parm->signatureAI ) == NOTOK)
            return NOTOK;

#ifdef DEBUG
        (void) testdebug ((*p50), "signature");
#endif

    }

    if ((*p50) != NULLPE)
        if (seq_add ((*pe), (*p50), -1) == NOTOK) {
            advise (NULLCP, "TBSRevCert %s%s", PEPY_ERR_BAD_SEQ,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }
    (*p50) = NULLPE;

    {	/* issuer */
        if (build_IF_Name (p50, 0, NULL, NULLCP, parm->issuer ) == NOTOK)
            return NOTOK;

#ifdef DEBUG
        (void) testdebug ((*p50), "issuer");
#endif

    }

    if ((*p50) != NULLPE)
        if (seq_add ((*pe), (*p50), -1) == NOTOK) {
            advise (NULLCP, "TBSRevCert %s%s", PEPY_ERR_BAD_SEQ,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }
    (*p50) = NULLPE;

    {	/* subject */
        register integer p51 = parm->subject ;

        if (((*p50) = num2prim (p51, PE_CLASS_UNIV, PE_PRIM_INT)) == NULLPE) {
            advise (NULLCP, "subject: %s", PEPY_ERR_NOMEM);
            return NOTOK;
        }

#ifdef DEBUG
        (void) testdebug ((*p50), "subject");
#endif

    }

    if ((*p50) != NULLPE)
        if (seq_add ((*pe), (*p50), -1) == NOTOK) {
            advise (NULLCP, "TBSRevCert %s%s", PEPY_ERR_BAD_SEQ,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }
    (*p50) = NULLPE;

    {	/* revocationDate */
        if (build_UNIV_UTCTime (p50, 0, NULL, parm->revocationdate , NullParm) == NOTOK)
            return NOTOK;

#ifdef DEBUG
        (void) testdebug ((*p50), "revocationDate");
#endif

    }

    if ((*p50) != NULLPE)
        if (seq_add ((*pe), (*p50), -1) == NOTOK) {
            advise (NULLCP, "TBSRevCert %s%s", PEPY_ERR_BAD_SEQ,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }

#ifdef DEBUG
    (void) testdebug ((*pe), "AF.TBSRevCert");
#endif


    return OK;
}

/* ARGSUSED */

int	build_AF_RevCert (pe, explicit, len, buffer, parm)
register PE     *pe;
int	explicit;
int	len;
char   *buffer;
RevCert * parm;
{
    
	PE tbs;
    
    PE	p52_z = NULLPE;
    register PE *p52 = &p52_z;

    if (((*pe) = pe_alloc (PE_CLASS_UNIV, PE_FORM_CONS, PE_CONS_SEQ)) == NULLPE) {
        advise (NULLCP, "RevCert: %s", PEPY_ERR_NOMEM);
        return NOTOK;
    }
    (*p52) = NULLPE;

    {
        PE	p53 = (build_revcert_tbs(parm,&tbs)) ;

        if (p53 == NULLPE) {
            advise (NULLCP, "element %s", PEPY_ERR_INIT_FAILED);
            return NOTOK;
        }
        ((*p52) = p53) -> pe_refcnt++;

#ifdef DEBUG
        (void) testdebug ((*p52), "element");
#endif

        {
   pe_free(tbs);
		
        }
    }

    if ((*p52) != NULLPE)
        if (seq_add ((*pe), (*p52), -1) == NOTOK) {
            advise (NULLCP, "RevCert %s%s", PEPY_ERR_BAD_SEQ,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }
    (*p52) = NULLPE;

    {
        if (build_SEC_AlgorithmIdentifier (p52, 0, NULL, NULLCP, parm->sig->signAI ) == NOTOK)
            return NOTOK;

#ifdef DEBUG
        (void) testdebug ((*p52), "element");
#endif

    }

    if ((*p52) != NULLPE)
        if (seq_add ((*pe), (*p52), -1) == NOTOK) {
            advise (NULLCP, "RevCert %s%s", PEPY_ERR_BAD_SEQ,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }
    (*p52) = NULLPE;

    {
        PE	p54_z = NULLPE;
        register PE *p54 = &p54_z;

        char *p55;
        int p56;
        p55 = parm->sig->signature.bits ;
        p56 = 
		     parm->sig->signature.nbits ;
        (*p54) = p55 ? strb2bitstr (p55, p56, PE_CLASS_UNIV, PE_PRIM_BITS) : NULLPE;
        if ((*p54) == NULLPE) {
            advise (NULLCP, "element %s", PEPY_ERR_INIT_FAILED);
            return NOTOK;
        }
        if (((*p52) = bit2prim ((*p54))) == NULLPE) {
            advise (NULLCP, "element: %s", PEPY_ERR_NOMEM);
            return NOTOK;
        }

#ifdef DEBUG
        (void) testdebug ((*p52), "element");
#endif

    }

    if ((*p52) != NULLPE)
        if (seq_add ((*pe), (*p52), -1) == NOTOK) {
            advise (NULLCP, "RevCert %s%s", PEPY_ERR_BAD_SEQ,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }

#ifdef DEBUG
    (void) testdebug ((*pe), "AF.RevCert");
#endif


    return OK;
}

/* ARGSUSED */

int	build_AF_RevCertSequence (pe, explicit, len, buffer, parm)
register PE     *pe;
int	explicit;
int	len;
char   *buffer;
SEQUENCE_OF_RevCert * parm;
{
    PE	p57 = NULLPE;
    PE	p58_z = NULLPE;
    register PE *p58 = &p58_z;

    if (((*pe) = pe_alloc (PE_CLASS_UNIV, PE_FORM_CONS, PE_CONS_SEQ)) == NULLPE) {
        advise (NULLCP, "RevCertSequence: %s", PEPY_ERR_NOMEM);
        return NOTOK;
    }
    for (; parm; parm = parm->next) {
        if (build_AF_RevCert (p58, 0, NULL, NULLCP, (parm->element) ) == NOTOK)
            return NOTOK;

#ifdef DEBUG
        (void) testdebug ((*p58), "element");
#endif

        (void) seq_addon ((*pe), p57, (*p58));
        p57 = (*p58);
    }

#ifdef DEBUG
    (void) testdebug ((*pe), "AF.RevCertSequence");
#endif


    return OK;
}

/* ARGSUSED */

int	build_AF_TBSPemCrl (pe, explicit, len, buffer, parm)
register PE     *pe;
int	explicit;
int	len;
char   *buffer;
PemCrlTBS * parm;
{
    PE	p59_z = NULLPE;
    register PE *p59 = &p59_z;

    if (((*pe) = pe_alloc (PE_CLASS_UNIV, PE_FORM_CONS, PE_CONS_SEQ)) == NULLPE) {
        advise (NULLCP, "TBSPemCrl: %s", PEPY_ERR_NOMEM);
        return NOTOK;
    }
    (*p59) = NULLPE;

    {	/* signature */
        if (build_SEC_AlgorithmIdentifier (p59, 0, NULL, NULLCP, parm->signatureAI ) == NOTOK)
            return NOTOK;

#ifdef DEBUG
        (void) testdebug ((*p59), "signature");
#endif

    }

    if ((*p59) != NULLPE)
        if (seq_add ((*pe), (*p59), -1) == NOTOK) {
            advise (NULLCP, "TBSPemCrl %s%s", PEPY_ERR_BAD_SEQ,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }
    (*p59) = NULLPE;

    {	/* issuer */
        if (build_IF_Name (p59, 0, NULL, NULLCP, parm->issuer ) == NOTOK)
            return NOTOK;

#ifdef DEBUG
        (void) testdebug ((*p59), "issuer");
#endif

    }

    if ((*p59) != NULLPE)
        if (seq_add ((*pe), (*p59), -1) == NOTOK) {
            advise (NULLCP, "TBSPemCrl %s%s", PEPY_ERR_BAD_SEQ,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }
    (*p59) = NULLPE;

    {	/* lastUpdate */
        if (build_UNIV_UTCTime (p59, 0, NULL, parm->lastUpdate , NullParm) == NOTOK)
            return NOTOK;

#ifdef DEBUG
        (void) testdebug ((*p59), "lastUpdate");
#endif

    }

    if ((*p59) != NULLPE)
        if (seq_add ((*pe), (*p59), -1) == NOTOK) {
            advise (NULLCP, "TBSPemCrl %s%s", PEPY_ERR_BAD_SEQ,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }
    (*p59) = NULLPE;

    {	/* nextUpdate */
        if (build_UNIV_UTCTime (p59, 0, NULL, parm->nextUpdate , NullParm) == NOTOK)
            return NOTOK;

#ifdef DEBUG
        (void) testdebug ((*p59), "nextUpdate");
#endif

    }

    if ((*p59) != NULLPE)
        if (seq_add ((*pe), (*p59), -1) == NOTOK) {
            advise (NULLCP, "TBSPemCrl %s%s", PEPY_ERR_BAD_SEQ,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }
    (*p59) = NULLPE;

    if (parm->revokedCertificates) {	/* revokedCertificates */
        if (build_AF_RevCertPemSequence (p59, 0, NULL, NULLCP, parm->revokedCertificates ) == NOTOK)
            return NOTOK;

#ifdef DEBUG
        (void) testdebug ((*p59), "revokedCertificates");
#endif

    }

    if ((*p59) != NULLPE)
        if (seq_add ((*pe), (*p59), -1) == NOTOK) {
            advise (NULLCP, "TBSPemCrl %s%s", PEPY_ERR_BAD_SEQ,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }

#ifdef DEBUG
    (void) testdebug ((*pe), "AF.TBSPemCrl");
#endif


    return OK;
}

/* ARGSUSED */

int	build_AF_PemCrl (pe, explicit, len, buffer, parm)
register PE     *pe;
int	explicit;
int	len;
char   *buffer;
PemCrl * parm;
{
    
	PE tbs;
    
    PE	p60_z = NULLPE;
    register PE *p60 = &p60_z;

    if (((*pe) = pe_alloc (PE_CLASS_UNIV, PE_FORM_CONS, PE_CONS_SEQ)) == NULLPE) {
        advise (NULLCP, "PemCrl: %s", PEPY_ERR_NOMEM);
        return NOTOK;
    }
    (*p60) = NULLPE;

    {
        PE	p61 = (build_pemcrl_tbs(parm,&tbs)) ;

        if (p61 == NULLPE) {
            advise (NULLCP, "element %s", PEPY_ERR_INIT_FAILED);
            return NOTOK;
        }
        ((*p60) = p61) -> pe_refcnt++;

#ifdef DEBUG
        (void) testdebug ((*p60), "element");
#endif

        {
   pe_free(tbs);
		
        }
    }

    if ((*p60) != NULLPE)
        if (seq_add ((*pe), (*p60), -1) == NOTOK) {
            advise (NULLCP, "PemCrl %s%s", PEPY_ERR_BAD_SEQ,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }
    (*p60) = NULLPE;

    {
        if (build_SEC_AlgorithmIdentifier (p60, 0, NULL, NULLCP, parm->sig->signAI ) == NOTOK)
            return NOTOK;

#ifdef DEBUG
        (void) testdebug ((*p60), "element");
#endif

    }

    if ((*p60) != NULLPE)
        if (seq_add ((*pe), (*p60), -1) == NOTOK) {
            advise (NULLCP, "PemCrl %s%s", PEPY_ERR_BAD_SEQ,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }
    (*p60) = NULLPE;

    {
        PE	p62_z = NULLPE;
        register PE *p62 = &p62_z;

        char *p63;
        int p64;
        p63 = parm->sig->signature.bits ;
        p64 = 
		     parm->sig->signature.nbits ;
        (*p62) = p63 ? strb2bitstr (p63, p64, PE_CLASS_UNIV, PE_PRIM_BITS) : NULLPE;
        if ((*p62) == NULLPE) {
            advise (NULLCP, "element %s", PEPY_ERR_INIT_FAILED);
            return NOTOK;
        }
        if (((*p60) = bit2prim ((*p62))) == NULLPE) {
            advise (NULLCP, "element: %s", PEPY_ERR_NOMEM);
            return NOTOK;
        }

#ifdef DEBUG
        (void) testdebug ((*p60), "element");
#endif

    }

    if ((*p60) != NULLPE)
        if (seq_add ((*pe), (*p60), -1) == NOTOK) {
            advise (NULLCP, "PemCrl %s%s", PEPY_ERR_BAD_SEQ,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }

#ifdef DEBUG
    (void) testdebug ((*pe), "AF.PemCrl");
#endif


    return OK;
}

/* ARGSUSED */

int	build_AF_RevCertPem (pe, explicit, len, buffer, parm)
register PE     *pe;
int	explicit;
int	len;
char   *buffer;
RevCertPem * parm;
{
    PE	p65_z = NULLPE;
    register PE *p65 = &p65_z;

    if (((*pe) = pe_alloc (PE_CLASS_UNIV, PE_FORM_CONS, PE_CONS_SEQ)) == NULLPE) {
        advise (NULLCP, "RevCertPem: %s", PEPY_ERR_NOMEM);
        return NOTOK;
    }
    (*p65) = NULLPE;

    {	/* serialNumber */
        register integer p66 = parm->serialnumber ;

        if (((*p65) = num2prim (p66, PE_CLASS_UNIV, PE_PRIM_INT)) == NULLPE) {
            advise (NULLCP, "serialNumber: %s", PEPY_ERR_NOMEM);
            return NOTOK;
        }

#ifdef DEBUG
        (void) testdebug ((*p65), "serialNumber");
#endif

    }

    if ((*p65) != NULLPE)
        if (seq_add ((*pe), (*p65), -1) == NOTOK) {
            advise (NULLCP, "RevCertPem %s%s", PEPY_ERR_BAD_SEQ,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }
    (*p65) = NULLPE;

    {	/* revocationDate */
        if (build_UNIV_UTCTime (p65, 0, NULL, parm->revocationDate , NullParm) == NOTOK)
            return NOTOK;

#ifdef DEBUG
        (void) testdebug ((*p65), "revocationDate");
#endif

    }

    if ((*p65) != NULLPE)
        if (seq_add ((*pe), (*p65), -1) == NOTOK) {
            advise (NULLCP, "RevCertPem %s%s", PEPY_ERR_BAD_SEQ,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }

#ifdef DEBUG
    (void) testdebug ((*pe), "AF.RevCertPem");
#endif


    return OK;
}

/* ARGSUSED */

int	build_AF_RevCertPemSequence (pe, explicit, len, buffer, parm)
register PE     *pe;
int	explicit;
int	len;
char   *buffer;
SEQUENCE_OF_RevCertPem * parm;
{
    PE	p67 = NULLPE;
    PE	p68_z = NULLPE;
    register PE *p68 = &p68_z;

    if (((*pe) = pe_alloc (PE_CLASS_UNIV, PE_FORM_CONS, PE_CONS_SEQ)) == NULLPE) {
        advise (NULLCP, "RevCertPemSequence: %s", PEPY_ERR_NOMEM);
        return NOTOK;
    }
    for (; parm; parm = parm->next) {
        if (build_AF_RevCertPem (p68, 0, NULL, NULLCP, (parm->element) ) == NOTOK)
            return NOTOK;

#ifdef DEBUG
        (void) testdebug ((*p68), "element");
#endif

        (void) seq_addon ((*pe), p67, (*p68));
        p67 = (*p68);
    }

#ifdef DEBUG
    (void) testdebug ((*pe), "AF.RevCertPemSequence");
#endif


    return OK;
}

/* ARGSUSED */

int	build_AF_SerialSet (pe, explicit, len, buffer, parm)
register PE     *pe;
int	explicit;
int	len;
char   *buffer;
SET_OF_int * parm;
{
    PE	p69 = NULLPE;
    PE	p70_z = NULLPE;
    register PE *p70 = &p70_z;

    if (((*pe) = pe_alloc (PE_CLASS_UNIV, PE_FORM_CONS, PE_CONS_SET)) == NULLPE) {
        advise (NULLCP, "SerialSet: %s", PEPY_ERR_NOMEM);
        return NOTOK;
    }
    for (; parm; parm = parm -> next) {
        register integer p71 = parm -> element ;

        if (((*p70) = num2prim (p71, PE_CLASS_UNIV, PE_PRIM_INT)) == NULLPE) {
            advise (NULLCP, "member: %s", PEPY_ERR_NOMEM);
            return NOTOK;
        }

#ifdef DEBUG
        (void) testdebug ((*p70), "member");
#endif

        (void) set_addon ((*pe), p69, (*p70));
        p69 = (*p70);
    }

#ifdef DEBUG
    (void) testdebug ((*pe), "AF.SerialSet");
#endif


    return OK;
}

/* ARGSUSED */

int	build_AF_CrlPSE (pe, explicit, len, buffer, parm)
register PE     *pe;
int	explicit;
int	len;
char   *buffer;
CrlPSE * parm;
{
    PE	p72_z = NULLPE;
    register PE *p72 = &p72_z;

    if (((*pe) = pe_alloc (PE_CLASS_UNIV, PE_FORM_CONS, PE_CONS_SEQ)) == NULLPE) {
        advise (NULLCP, "CrlPSE: %s", PEPY_ERR_NOMEM);
        return NOTOK;
    }
    (*p72) = NULLPE;

    {	/* issuer */
        if (build_IF_Name (p72, 0, NULL, NULLCP, parm->issuer ) == NOTOK)
            return NOTOK;

#ifdef DEBUG
        (void) testdebug ((*p72), "issuer");
#endif

    }

    if ((*p72) != NULLPE)
        if (seq_add ((*pe), (*p72), -1) == NOTOK) {
            advise (NULLCP, "CrlPSE %s%s", PEPY_ERR_BAD_SEQ,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }
    (*p72) = NULLPE;

    {	/* nextUpdate */
        if (build_UNIV_UTCTime (p72, 0, NULL, parm->nextUpdate , NullParm) == NOTOK)
            return NOTOK;

#ifdef DEBUG
        (void) testdebug ((*p72), "nextUpdate");
#endif

    }

    if ((*p72) != NULLPE)
        if (seq_add ((*pe), (*p72), -1) == NOTOK) {
            advise (NULLCP, "CrlPSE %s%s", PEPY_ERR_BAD_SEQ,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }
    (*p72) = NULLPE;

    if (parm->revcerts) {	/* revcerts */
        if (build_AF_RevCertPemSequence (p72, 0, NULL, NULLCP, parm->revcerts ) == NOTOK)
            return NOTOK;

#ifdef DEBUG
        (void) testdebug ((*p72), "revcerts");
#endif

    }

    if ((*p72) != NULLPE)
        if (seq_add ((*pe), (*p72), -1) == NOTOK) {
            advise (NULLCP, "CrlPSE %s%s", PEPY_ERR_BAD_SEQ,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }

#ifdef DEBUG
    (void) testdebug ((*pe), "AF.CrlPSE");
#endif


    return OK;
}

/* ARGSUSED */

int	build_AF_CrlSet (pe, explicit, len, buffer, parm)
register PE     *pe;
int	explicit;
int	len;
char   *buffer;
CrlSet * parm;
{
    PE	p73 = NULLPE;
    PE	p74_z = NULLPE;
    register PE *p74 = &p74_z;

    if (((*pe) = pe_alloc (PE_CLASS_UNIV, PE_FORM_CONS, PE_CONS_SET)) == NULLPE) {
        advise (NULLCP, "CrlSet: %s", PEPY_ERR_NOMEM);
        return NOTOK;
    }
    for (; parm; parm = parm -> next) {
        if (build_AF_CrlPSE (p74, 0, NULL, NULLCP, parm -> element ) == NOTOK)
            return NOTOK;

#ifdef DEBUG
        (void) testdebug ((*p74), "member");
#endif

        (void) set_addon ((*pe), p73, (*p74));
        p73 = (*p74);
    }

#ifdef DEBUG
    (void) testdebug ((*pe), "AF.CrlSet");
#endif


    return OK;
}

/* ARGSUSED */

int	build_AF_OldCertificateList (pe, explicit, len, buffer, parm)
register PE     *pe;
int	explicit;
int	len;
char   *buffer;
OCList * parm;
{
    PE	p75 = NULLPE;
    PE	p76_z = NULLPE;
    register PE *p76 = &p76_z;

    if (((*pe) = pe_alloc (PE_CLASS_UNIV, PE_FORM_CONS, PE_CONS_SEQ)) == NULLPE) {
        advise (NULLCP, "OldCertificateList: %s", PEPY_ERR_NOMEM);
        return NOTOK;
    }
    for (; parm; parm = parm->next) {
        PE	p77_z = NULLPE;
        register PE *p77 = &p77_z;

        if (((*p76) = pe_alloc (PE_CLASS_UNIV, PE_FORM_CONS, PE_CONS_SEQ)) == NULLPE) {
            advise (NULLCP, "element: %s", PEPY_ERR_NOMEM);
            return NOTOK;
        }
        (*p77) = NULLPE;

        {	/* serialNumber */
            register integer p78 = parm->serialnumber ;

            if (((*p77) = num2prim (p78, PE_CLASS_UNIV, PE_PRIM_INT)) == NULLPE) {
                advise (NULLCP, "serialNumber: %s", PEPY_ERR_NOMEM);
                return NOTOK;
            }

#ifdef DEBUG
            (void) testdebug ((*p77), "serialNumber");
#endif

        }

        if ((*p77) != NULLPE)
            if (seq_add ((*p76), (*p77), -1) == NOTOK) {
                advise (NULLCP, "element %s%s", PEPY_ERR_BAD_SEQ,
                        pe_error ((*p76) -> pe_errno));
                return NOTOK;
            }
        (*p77) = NULLPE;

        {	/* crossCertificate */
            if (build_AF_Certificate (p77, 0, NULL, NULLCP, parm->ccert ) == NOTOK)
                return NOTOK;

#ifdef DEBUG
            (void) testdebug ((*p77), "crossCertificate");
#endif

        }

        if ((*p77) != NULLPE)
            if (seq_add ((*p76), (*p77), -1) == NOTOK) {
                advise (NULLCP, "element %s%s", PEPY_ERR_BAD_SEQ,
                        pe_error ((*p76) -> pe_errno));
                return NOTOK;
            }

#ifdef DEBUG
        (void) testdebug ((*p76), "element");
#endif

        (void) seq_addon ((*pe), p75, (*p76));
        p75 = (*p76);
    }

#ifdef DEBUG
    (void) testdebug ((*pe), "AF.OldCertificateList");
#endif


    return OK;
}

/* ARGSUSED */

int	build_AF_CertificationPath (pe, explicit, len, buffer, parm)
register PE     *pe;
int	explicit;
int	len;
char   *buffer;
CertificationPath * parm;
{
    PE	p79_z = NULLPE;
    register PE *p79 = &p79_z;

    if (((*pe) = pe_alloc (PE_CLASS_UNIV, PE_FORM_CONS, PE_CONS_SEQ)) == NULLPE) {
        advise (NULLCP, "CertificationPath: %s", PEPY_ERR_NOMEM);
        return NOTOK;
    }
    (*p79) = NULLPE;

    {	/* userCertificate */
        if (build_AF_Certificate (p79, 0, NULL, NULLCP, parm->userCertificate ) == NOTOK)
            return NOTOK;

#ifdef DEBUG
        (void) testdebug ((*p79), "userCertificate");
#endif

    }

    if ((*p79) != NULLPE)
        if (seq_add ((*pe), (*p79), -1) == NOTOK) {
            advise (NULLCP, "CertificationPath %s%s", PEPY_ERR_BAD_SEQ,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }
    (*p79) = NULLPE;

    if (parm->theCACertificates) {	/* theCACertificates */
        if (build_AF_CertificatePairs (p79, 0, NULL, NULLCP, parm->theCACertificates ) == NOTOK)
            return NOTOK;

#ifdef DEBUG
        (void) testdebug ((*p79), "theCACertificates");
#endif

    }

    if ((*p79) != NULLPE)
        if (seq_add ((*pe), (*p79), -1) == NOTOK) {
            advise (NULLCP, "CertificationPath %s%s", PEPY_ERR_BAD_SEQ,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }

#ifdef DEBUG
    (void) testdebug ((*pe), "AF.CertificationPath");
#endif


    return OK;
}

/* ARGSUSED */

int	build_AF_CertificatePairs (pe, explicit, len, buffer, parm)
register PE     *pe;
int	explicit;
int	len;
char   *buffer;
CertificatePairs * parm;
{
    
SEQUENCE_OF_CertificatePair * level;

    PE	p80 = NULLPE;
    PE	p81_z = NULLPE;
    register PE *p81 = &p81_z;

    if (((*pe) = pe_alloc (PE_CLASS_UNIV, PE_FORM_CONS, PE_CONS_SEQ)) == NULLPE) {
        advise (NULLCP, "CertificatePairs: %s", PEPY_ERR_NOMEM);
        return NOTOK;
    }
    for (level = (parm)? parm->liste:(SEQUENCE_OF_CertificatePair * )0; 
		  level; 
		  level = (level->next)? level->next:((parm = parm->superior)? parm->liste:(SEQUENCE_OF_CertificatePair * )0)) {
        if (build_AF_CertificatePair (p81, 0, NULL, NULLCP, level->element ) == NOTOK)
            return NOTOK;

#ifdef DEBUG
        (void) testdebug ((*p81), "element");
#endif

        (void) seq_addon ((*pe), p80, (*p81));
        p80 = (*p81);
    }

#ifdef DEBUG
    (void) testdebug ((*pe), "AF.CertificatePairs");
#endif


    return OK;
}

/* ARGSUSED */

int	build_AF_PemCrlWithCerts (pe, explicit, len, buffer, parm)
register PE     *pe;
int	explicit;
int	len;
char   *buffer;
PemCrlWithCerts * parm;
{
    PE	p82_z = NULLPE;
    register PE *p82 = &p82_z;

    if (((*pe) = pe_alloc (PE_CLASS_UNIV, PE_FORM_CONS, PE_CONS_SEQ)) == NULLPE) {
        advise (NULLCP, "PemCrlWithCerts: %s", PEPY_ERR_NOMEM);
        return NOTOK;
    }
    (*p82) = NULLPE;

    {	/* pemCRL */
        if (build_AF_PemCrl (p82, 0, NULL, NULLCP, parm->pemcrl ) == NOTOK)
            return NOTOK;

#ifdef DEBUG
        (void) testdebug ((*p82), "pemCRL");
#endif

    }

    if ((*p82) != NULLPE)
        if (seq_add ((*pe), (*p82), -1) == NOTOK) {
            advise (NULLCP, "PemCrlWithCerts %s%s", PEPY_ERR_BAD_SEQ,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }
    (*p82) = NULLPE;

    if (parm->certificates) {	/* certificates */
        if (build_AF_Certificates (p82, 0, NULL, NULLCP, parm->certificates ) == NOTOK)
            return NOTOK;

#ifdef DEBUG
        (void) testdebug ((*p82), "certificates");
#endif

    }

    if ((*p82) != NULLPE)
        if (seq_add ((*pe), (*p82), -1) == NOTOK) {
            advise (NULLCP, "PemCrlWithCerts %s%s", PEPY_ERR_BAD_SEQ,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }

#ifdef DEBUG
    (void) testdebug ((*pe), "AF.PemCrlWithCerts");
#endif


    return OK;
}

/* ARGSUSED */

int	build_AF_AliasesMember (pe, explicit, len, buffer, parm)
register PE     *pe;
int	explicit;
int	len;
char   *buffer;
Aliases * parm;
{
    PE	p83_z = NULLPE;
    register PE *p83 = &p83_z;

    if (((*pe) = pe_alloc (PE_CLASS_UNIV, PE_FORM_CONS, PE_CONS_SEQ)) == NULLPE) {
        advise (NULLCP, "AliasesMember: %s", PEPY_ERR_NOMEM);
        return NOTOK;
    }
    (*p83) = NULLPE;

    {	/* aname */
        if (build_UNIV_IA5String (p83, 0, NULL, parm->aname, NullParm) == NOTOK)
            return NOTOK;

#ifdef DEBUG
        (void) testdebug ((*p83), "aname");
#endif

    }

    if ((*p83) != NULLPE)
        if (seq_add ((*pe), (*p83), -1) == NOTOK) {
            advise (NULLCP, "AliasesMember %s%s", PEPY_ERR_BAD_SEQ,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }
    (*p83) = NULLPE;

    {	/* aliasfile */
        register integer p84 = parm->aliasfile;

        if (((*p83) = enum2prim (p84, PE_CLASS_UNIV, PE_PRIM_ENUM)) == NULLPE) {
            advise (NULLCP, "aliasfile: %s", PEPY_ERR_NOMEM);
            return NOTOK;
        }
        switch (p84) {
            case 0:	/* useralias */
                break;
            case 1:	/* sytemalias */
                break;
            default:
                advise (NULLCP, "aliasfile %s%d", PEPY_ERR_UNK_COMP, p84);
                return NOTOK;
        }

#ifdef DEBUG
        (void) testdebug ((*p83), "aliasfile");
#endif

    }

    if ((*p83) != NULLPE)
        if (seq_add ((*pe), (*p83), -1) == NOTOK) {
            advise (NULLCP, "AliasesMember %s%s", PEPY_ERR_BAD_SEQ,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }

#ifdef DEBUG
    (void) testdebug ((*pe), "AF.AliasesMember");
#endif


    return OK;
}

/* ARGSUSED */

int	build_AF_Aliases (pe, explicit, len, buffer, parm)
register PE     *pe;
int	explicit;
int	len;
char   *buffer;
Aliases * parm;
{
    PE	p85 = NULLPE;
    PE	p86_z = NULLPE;
    register PE *p86 = &p86_z;

    if (((*pe) = pe_alloc (PE_CLASS_UNIV, PE_FORM_CONS, PE_CONS_SEQ)) == NULLPE) {
        advise (NULLCP, "Aliases: %s", PEPY_ERR_NOMEM);
        return NOTOK;
    }
    for (; parm; parm = parm->next) {
        if (build_AF_AliasesMember (p86, 0, NULL, NULLCP, parm) == NOTOK)
            return NOTOK;

#ifdef DEBUG
        (void) testdebug ((*p86), "element");
#endif

        (void) seq_addon ((*pe), p85, (*p86));
        p85 = (*p86);
    }

#ifdef DEBUG
    (void) testdebug ((*pe), "AF.Aliases");
#endif


    return OK;
}

/* ARGSUSED */

int	build_AF_AliasListMember (pe, explicit, len, buffer, parm)
register PE     *pe;
int	explicit;
int	len;
char   *buffer;
AliasList * parm;
{
    PE	p87_z = NULLPE;
    register PE *p87 = &p87_z;

    if (((*pe) = pe_alloc (PE_CLASS_UNIV, PE_FORM_CONS, PE_CONS_SEQ)) == NULLPE) {
        advise (NULLCP, "AliasListMember: %s", PEPY_ERR_NOMEM);
        return NOTOK;
    }
    (*p87) = NULLPE;

    {	/* aliases */
        if (build_AF_Aliases (p87, 0, NULL, NULLCP, parm->a) == NOTOK)
            return NOTOK;

#ifdef DEBUG
        (void) testdebug ((*p87), "aliases");
#endif

    }

    if ((*p87) != NULLPE)
        if (seq_add ((*pe), (*p87), -1) == NOTOK) {
            advise (NULLCP, "AliasListMember %s%s", PEPY_ERR_BAD_SEQ,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }
    (*p87) = NULLPE;

    {	/* dname */
        if (build_UNIV_IA5String (p87, 0, NULL, parm->dname, NullParm) == NOTOK)
            return NOTOK;

#ifdef DEBUG
        (void) testdebug ((*p87), "dname");
#endif

    }

    if ((*p87) != NULLPE)
        if (seq_add ((*pe), (*p87), -1) == NOTOK) {
            advise (NULLCP, "AliasListMember %s%s", PEPY_ERR_BAD_SEQ,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }

#ifdef DEBUG
    (void) testdebug ((*pe), "AF.AliasListMember");
#endif


    return OK;
}

/* ARGSUSED */

int	build_AF_AliasList (pe, explicit, len, buffer, parm)
register PE     *pe;
int	explicit;
int	len;
char   *buffer;
AliasList * parm;
{
    PE	p88 = NULLPE;
    PE	p89_z = NULLPE;
    register PE *p89 = &p89_z;

    if (((*pe) = pe_alloc (PE_CLASS_UNIV, PE_FORM_CONS, PE_CONS_SEQ)) == NULLPE) {
        advise (NULLCP, "AliasList: %s", PEPY_ERR_NOMEM);
        return NOTOK;
    }
    for (; parm; parm = parm->next) {
        if (build_AF_AliasListMember (p89, 0, NULL, NULLCP, parm) == NOTOK)
            return NOTOK;

#ifdef DEBUG
        (void) testdebug ((*p89), "element");
#endif

        (void) seq_addon ((*pe), p88, (*p89));
        p88 = (*p89);
    }

#ifdef DEBUG
    (void) testdebug ((*pe), "AF.AliasList");
#endif


    return OK;
}

/* ARGSUSED */

int	parse_AF_SerialNumbers (pe, explicit, len, buffer, parm)
register PE	pe;
int	explicit;
int    *len;
char  **buffer;
SerialNumbers ** parm;
{
    register PE p90;

#ifdef DEBUG
    (void) testdebug (pe, "AF.SerialNumbers");
#endif

    if (explicit) {
        if (pe -> pe_class != PE_CLASS_UNIV
                || pe -> pe_form != PE_FORM_CONS
                || pe -> pe_id != PE_CONS_SEQ) {
            advise (NULLCP, "SerialNumbers bad class/form/id: %s/%d/0x%x",
                    pe_classlist[pe -> pe_class], pe -> pe_form, pe -> pe_id);
            return NOTOK;
        }
    }
    else
        if (pe -> pe_form != PE_FORM_CONS) {
            advise (NULLCP, "SerialNumbers bad form: %d", pe -> pe_form);
            return NOTOK;
        }

    {

        if ((*(parm) = (SerialNumbers *)
                calloc (1, sizeof **(parm))) == ((SerialNumbers *) 0)) {
            advise (NULLCP, "out of memory");
            return NOTOK;
        }
	(*parm)->initial = 0;
    
    }
    if ((p90 = prim2seq (pe)) == NULLPE) {
        advise (NULLCP, "SerialNumbers %s%s", PEPY_ERR_BAD_SEQ,
                pe_error (pe -> pe_errno));
        return NOTOK;
    }
    pe = p90;

    {
        register PE p91;

        if ((p91 = first_member (pe)) != NULLPE
                && PE_ID (p91 -> pe_class, p91 -> pe_id)
                        != PE_ID (PE_CLASS_CONT, 0))
            p91 = NULLPE;
        if (p91 != NULLPE) {
            p90 = p91;

            {	/* element TAG PULLUP */
                register PE p92;

                if ((p92 = prim2set (p91)) == NULLPE) {
                    advise (NULLCP, "member %selement: %s", PEPY_ERR_BAD,
                            pe_error (p91 -> pe_errno));
                    return NOTOK;
                }
                if (p92 -> pe_cardinal != 1) {
                    advise (NULLCP, "member %s element: %d", PEPY_ERR_TOO_MANY_TAGGED,
                            p92 -> pe_cardinal);
                    return NOTOK;
                }
                p91 = first_member (p92);
            }
            {
                register integer p93;

#ifdef DEBUG
                (void) testdebug (p91, "element");
#endif

                if (p91 -> pe_class != PE_CLASS_UNIV
                        || p91 -> pe_form != PE_FORM_PRIM
                        || p91 -> pe_id != PE_PRIM_INT) {
                    advise (NULLCP, "element bad class/form/id: %s/%d/0x%x",
                            pe_classlist[p91 -> pe_class], p91 -> pe_form, p91 -> pe_id);
                    return NOTOK;
                }

                if ((p93 = prim2num (p91)) == NOTOK
                        && p91 -> pe_errno != PE_ERR_NONE) {
                    advise (NULLCP, "element %s%s", PEPY_ERR_BAD_INTEGER,
                            pe_error (p91 -> pe_errno));
                    return NOTOK;
                }
                (* parm)->initial  = p93;
            }
        }
        else {
            /* set default here using yp -> yp_default */
        }

    }

    {
        register PE p94;

        if ((p94 = (pe != p90 ? next_member (pe, p90) : first_member (pe))) != NULLPE) {
            p90 = p94;

            {	/* element TAG PULLUP */
                register PE p95;

                if ((p95 = prim2set (p94)) == NULLPE) {
                    advise (NULLCP, "member %selement: %s", PEPY_ERR_BAD,
                            pe_error (p94 -> pe_errno));
                    return NOTOK;
                }
                if (p95 -> pe_cardinal != 1) {
                    advise (NULLCP, "member %s element: %d", PEPY_ERR_TOO_MANY_TAGGED,
                            p95 -> pe_cardinal);
                    return NOTOK;
                }
                p94 = first_member (p95);
            }
            {
                register integer p96;

#ifdef DEBUG
                (void) testdebug (p94, "element");
#endif

                if (p94 -> pe_class != PE_CLASS_UNIV
                        || p94 -> pe_form != PE_FORM_PRIM
                        || p94 -> pe_id != PE_PRIM_INT) {
                    advise (NULLCP, "element bad class/form/id: %s/%d/0x%x",
                            pe_classlist[p94 -> pe_class], p94 -> pe_form, p94 -> pe_id);
                    return NOTOK;
                }

                if ((p96 = prim2num (p94)) == NOTOK
                        && p94 -> pe_errno != PE_ERR_NONE) {
                    advise (NULLCP, "element %s%s", PEPY_ERR_BAD_INTEGER,
                            pe_error (p94 -> pe_errno));
                    return NOTOK;
                }
                (* parm)->actual  = p96;
            }
        }
        else {
            advise (NULLCP, "SerialNumbers %selement", PEPY_ERR_MISSING);
            return NOTOK;
        }

    }


    if (pe -> pe_cardinal > 2) {
        advise (NULLCP, "SerialNumbers %s(2): %d", PEPY_ERR_TOO_MANY_ELEMENTS,
                pe -> pe_cardinal);
        return NOTOK;
    }

    return OK;
}

/* ARGSUSED */

int	parse_AF_PKRoot (pe, explicit, len, buffer, parm)
register PE	pe;
int	explicit;
int    *len;
char  **buffer;
PKRoot ** parm;
{
    register PE p97;

#ifdef DEBUG
    (void) testdebug (pe, "AF.PKRoot");
#endif

    if (explicit) {
        if (pe -> pe_class != PE_CLASS_UNIV
                || pe -> pe_form != PE_FORM_CONS
                || pe -> pe_id != PE_CONS_SEQ) {
            advise (NULLCP, "PKRoot bad class/form/id: %s/%d/0x%x",
                    pe_classlist[pe -> pe_class], pe -> pe_form, pe -> pe_id);
            return NOTOK;
        }
    }
    else
        if (pe -> pe_form != PE_FORM_CONS) {
            advise (NULLCP, "PKRoot bad form: %d", pe -> pe_form);
            return NOTOK;
        }

    {

        if ((*(parm) = (PKRoot *)
                calloc (1, sizeof **(parm))) == ((PKRoot *) 0)) {
            advise (NULLCP, "out of memory");
            return NOTOK;
        }
    
    }
    if ((p97 = prim2seq (pe)) == NULLPE) {
        advise (NULLCP, "PKRoot %s%s", PEPY_ERR_BAD_SEQ,
                pe_error (pe -> pe_errno));
        return NOTOK;
    }
    pe = p97;

    {
        register PE p98;

        if ((p98 = first_member (pe)) != NULLPE) {
            p97 = p98;

            {	/* cA */
#ifdef DEBUG
                (void) testdebug (p98, "cA");
#endif

                if (parse_IF_Name (p98, 1, NULLIP, NULLVP, &((*parm) -> ca)) == NOTOK)
                    return NOTOK;
            }
        }
        else {
            advise (NULLCP, "PKRoot %scA element", PEPY_ERR_MISSING);
            return NOTOK;
        }

    }

    {
        register PE p99;

        if ((p99 = (pe != p97 ? next_member (pe, p97) : first_member (pe))) != NULLPE) {
            p97 = p99;

            {	/* newkey */
#ifdef DEBUG
                (void) testdebug (p99, "newkey");
#endif

                if (parse_AF_RootKey (p99, 1, NULLIP, NULLVP, &((*parm) -> newkey)) == NOTOK)
                    return NOTOK;
            }
        }
        else {
            advise (NULLCP, "PKRoot %snewkey element", PEPY_ERR_MISSING);
            return NOTOK;
        }

    }

    {
        register PE p100;

        if ((p100 = (pe != p97 ? next_member (pe, p97) : first_member (pe))) != NULLPE) {
            p97 = p100;

            {	/* oldkey */
#ifdef DEBUG
                (void) testdebug (p100, "oldkey");
#endif

                if (parse_AF_RootKey (p100, 1, NULLIP, NULLVP, &((*parm) -> oldkey)) == NOTOK)
                    return NOTOK;
            }
        }
    }


    if (pe -> pe_cardinal > 3) {
        advise (NULLCP, "PKRoot %s(3): %d", PEPY_ERR_TOO_MANY_ELEMENTS,
                pe -> pe_cardinal);
        return NOTOK;
    }

    return OK;
}

/* ARGSUSED */

int	parse_AF_RootKey (pe, explicit, len, buffer, parm)
register PE	pe;
int	explicit;
int    *len;
char  **buffer;
struct Serial ** parm;
{
    register PE p101;

#ifdef DEBUG
    (void) testdebug (pe, "AF.RootKey");
#endif

    if (explicit) {
        if (pe -> pe_class != PE_CLASS_UNIV
                || pe -> pe_form != PE_FORM_CONS
                || pe -> pe_id != PE_CONS_SEQ) {
            advise (NULLCP, "RootKey bad class/form/id: %s/%d/0x%x",
                    pe_classlist[pe -> pe_class], pe -> pe_form, pe -> pe_id);
            return NOTOK;
        }
    }
    else
        if (pe -> pe_form != PE_FORM_CONS) {
            advise (NULLCP, "RootKey bad form: %d", pe -> pe_form);
            return NOTOK;
        }

    {

        if ((*(parm) = (struct Serial *)
                calloc (1, sizeof **(parm))) == ((struct Serial *) 0)) {
            advise (NULLCP, "out of memory");
            return NOTOK;
        }
        if (((*parm)->key = (KeyInfo *)
                calloc (1, sizeof (KeyInfo))) == ((KeyInfo *) 0)) {
            advise (NULLCP, "out of memory");
            return NOTOK;
        }
        if (((*parm)->sig = (Signature *)
                calloc (1, sizeof (Signature))) == ((Signature *) 0)) {
            advise (NULLCP, "out of memory");
            return NOTOK;
        }
	(*parm)->notbefore = CNULL;
	(*parm)->notafter = CNULL;
	(*parm)->sig->signAI = NULLALGID;
	(*parm)->sig->signature.bits = CNULL;
	(*parm)->sig->signature.nbits = 0;
    
    }
    if ((p101 = prim2seq (pe)) == NULLPE) {
        advise (NULLCP, "RootKey %s%s", PEPY_ERR_BAD_SEQ,
                pe_error (pe -> pe_errno));
        return NOTOK;
    }
    pe = p101;

    {
        register PE p102;

        if ((p102 = first_member (pe)) != NULLPE
                && PE_ID (p102 -> pe_class, p102 -> pe_id)
                        != PE_ID (PE_CLASS_CONT, 0))
            p102 = NULLPE;
        if (p102 != NULLPE) {
            p101 = p102;

            {	/* element TAG PULLUP */
                register PE p103;

                if ((p103 = prim2set (p102)) == NULLPE) {
                    advise (NULLCP, "version %selement: %s", PEPY_ERR_BAD,
                            pe_error (p102 -> pe_errno));
                    return NOTOK;
                }
                if (p103 -> pe_cardinal != 1) {
                    advise (NULLCP, "version %s element: %d", PEPY_ERR_TOO_MANY_TAGGED,
                            p103 -> pe_cardinal);
                    return NOTOK;
                }
                p102 = first_member (p103);
            }
            {	/* version */
                register integer p104;

#ifdef DEBUG
                (void) testdebug (p102, "version");
#endif

                if (p102 -> pe_class != PE_CLASS_UNIV
                        || p102 -> pe_form != PE_FORM_PRIM
                        || p102 -> pe_id != PE_PRIM_INT) {
                    advise (NULLCP, "version bad class/form/id: %s/%d/0x%x",
                            pe_classlist[p102 -> pe_class], p102 -> pe_form, p102 -> pe_id);
                    return NOTOK;
                }

                if ((p104 = prim2num (p102)) == NOTOK
                        && p102 -> pe_errno != PE_ERR_NONE) {
                    advise (NULLCP, "version %s%s", PEPY_ERR_BAD_INTEGER,
                            pe_error (p102 -> pe_errno));
                    return NOTOK;
                }
                (*parm)->version  = p104;
                switch (p104) {
                    case 0:	/* v1988 */
                        break;
                    case 1:	/* v1992 */
                        break;
                }
            }
        }
        else {
            /* set default here using yp -> yp_default */
        }

    }

    {
        register PE p105;

        if ((p105 = (pe != p101 ? next_member (pe, p101) : first_member (pe))) != NULLPE) {
            p101 = p105;

            {	/* serial */
                register integer p106;

#ifdef DEBUG
                (void) testdebug (p105, "serial");
#endif

                if (p105 -> pe_class != PE_CLASS_UNIV
                        || p105 -> pe_form != PE_FORM_PRIM
                        || p105 -> pe_id != PE_PRIM_INT) {
                    advise (NULLCP, "serial bad class/form/id: %s/%d/0x%x",
                            pe_classlist[p105 -> pe_class], p105 -> pe_form, p105 -> pe_id);
                    return NOTOK;
                }

                if ((p106 = prim2num (p105)) == NOTOK
                        && p105 -> pe_errno != PE_ERR_NONE) {
                    advise (NULLCP, "serial %s%s", PEPY_ERR_BAD_INTEGER,
                            pe_error (p105 -> pe_errno));
                    return NOTOK;
                }
                (*parm)->serial  = p106;
            }
        }
        else {
            advise (NULLCP, "RootKey %sserial element", PEPY_ERR_MISSING);
            return NOTOK;
        }

    }

    {
        register PE p107;

        if ((p107 = (pe != p101 ? next_member (pe, p101) : first_member (pe))) != NULLPE) {
            p101 = p107;

            {	/* key */
#ifdef DEBUG
                (void) testdebug (p107, "key");
#endif

                if (parse_SEC_KeyInfo (p107, 1, NULLIP, NULLVP, ((*parm)->key)) == NOTOK)
                    return NOTOK;
            }
        }
        else {
            advise (NULLCP, "RootKey %skey element", PEPY_ERR_MISSING);
            return NOTOK;
        }

    }

    {
        register PE p108;

        if ((p108 = (pe != p101 ? next_member (pe, p101) : first_member (pe))) 
                    != NULLPE
                && PE_ID (p108 -> pe_class, p108 -> pe_id)
                        != PE_ID (PE_CLASS_CONT, 1))
            p108 = NULLPE;
        if (p108 != NULLPE) {
            p101 = p108;

            {	/* element TAG PULLUP */
                register PE p109;

                if ((p109 = prim2set (p108)) == NULLPE) {
                    advise (NULLCP, "validity %selement: %s", PEPY_ERR_BAD,
                            pe_error (p108 -> pe_errno));
                    return NOTOK;
                }
                if (p109 -> pe_cardinal != 1) {
                    advise (NULLCP, "validity %s element: %d", PEPY_ERR_TOO_MANY_TAGGED,
                            p109 -> pe_cardinal);
                    return NOTOK;
                }
                p108 = first_member (p109);
            }
            {	/* validity */
#ifdef DEBUG
                (void) testdebug (p108, "validity");
#endif

                if (parse_AF_PKRootValidity (p108, 1, NULLIP, NULLVP, (*parm) ) == NOTOK)
                    return NOTOK;
            }
        }
    }

    {
        register PE p110;

        if ((p110 = (pe != p101 ? next_member (pe, p101) : first_member (pe))) 
                    != NULLPE
                && PE_ID (p110 -> pe_class, p110 -> pe_id)
                        != PE_ID (PE_CLASS_CONT, 2))
            p110 = NULLPE;
        if (p110 != NULLPE) {
            p101 = p110;

            {	/* element TAG PULLUP */
                register PE p111;

                if ((p111 = prim2set (p110)) == NULLPE) {
                    advise (NULLCP, "signAlgID %selement: %s", PEPY_ERR_BAD,
                            pe_error (p110 -> pe_errno));
                    return NOTOK;
                }
                if (p111 -> pe_cardinal != 1) {
                    advise (NULLCP, "signAlgID %s element: %d", PEPY_ERR_TOO_MANY_TAGGED,
                            p111 -> pe_cardinal);
                    return NOTOK;
                }
                p110 = first_member (p111);
            }
            {	/* signAlgID */
#ifdef DEBUG
                (void) testdebug (p110, "signAlgID");
#endif

                if (parse_SEC_AlgorithmIdentifier (p110, 1, NULLIP, NULLVP, &((*parm)->sig->signAI) ) == NOTOK)
                    return NOTOK;
            }
        }
    }

    {
        register PE p112;

        if ((p112 = (pe != p101 ? next_member (pe, p101) : first_member (pe))) != NULLPE) {
            p101 = p112;

            {	/* signBitString */
                register PE p113;

#ifdef DEBUG
                (void) testdebug (p112, "signBitString");
#endif

                if (p112 -> pe_class != PE_CLASS_UNIV || p112 -> pe_id != PE_PRIM_BITS) {
                    advise (NULLCP, "signBitString bad class/form/id: %s/%d/0x%x",
                            pe_classlist[p112 -> pe_class], p112 -> pe_form, p112 -> pe_id);
                    return NOTOK;
                }

                if ((p113 = prim2bit (p112)) == NULLPE) {
                    advise (NULLCP, "signBitString %s%s", PEPY_ERR_BAD_BITS,
                            pe_error (p112 -> pe_errno));
                    return NOTOK;
                }
                (*parm)->sig->signature.bits  = bitstr2strb (p112, &(
		     (*parm)->sig->signature.nbits ));
            }
        }
    }


    if (pe -> pe_cardinal > 6) {
        advise (NULLCP, "RootKey %s(6): %d", PEPY_ERR_TOO_MANY_ELEMENTS,
                pe -> pe_cardinal);
        return NOTOK;
    }
    {

	if(! (*parm)->sig->signAI){
		aux_free_KeyInfo( (KeyInfo **) & ((*parm)->sig) );
		(*parm)->sig = (Signature * ) 0;
	}
    
    }

    return OK;
}

/* ARGSUSED */

int	parse_AF_TBSCertificate (pe, explicit, len, buffer, parm)
register PE	pe;
int	explicit;
int    *len;
char  **buffer;
ToBeSigned ** parm;
{
    register PE p114;

#ifdef DEBUG
    (void) testdebug (pe, "AF.TBSCertificate");
#endif

    if (explicit) {
        if (pe -> pe_class != PE_CLASS_UNIV
                || pe -> pe_form != PE_FORM_CONS
                || pe -> pe_id != PE_CONS_SEQ) {
            advise (NULLCP, "TBSCertificate bad class/form/id: %s/%d/0x%x",
                    pe_classlist[pe -> pe_class], pe -> pe_form, pe -> pe_id);
            return NOTOK;
        }
    }
    else
        if (pe -> pe_form != PE_FORM_CONS) {
            advise (NULLCP, "TBSCertificate bad form: %d", pe -> pe_form);
            return NOTOK;
        }

    {

        if ((*(parm) = (ToBeSigned *)
                calloc (1, sizeof **(parm))) == ((ToBeSigned *) 0)) {
            advise (NULLCP, "out of memory");
            return NOTOK;
        }
        if (((*parm)->subjectPK = (KeyInfo *)
                calloc (1, sizeof (KeyInfo))) == ((KeyInfo *) 0)) {
            advise (NULLCP, "out of memory");
            return NOTOK;
        }
	(*parm) -> version = 0;
    
    }
    if ((p114 = prim2seq (pe)) == NULLPE) {
        advise (NULLCP, "TBSCertificate %s%s", PEPY_ERR_BAD_SEQ,
                pe_error (pe -> pe_errno));
        return NOTOK;
    }
    pe = p114;

    {
        register PE p115;

        if ((p115 = first_member (pe)) != NULLPE
                && PE_ID (p115 -> pe_class, p115 -> pe_id)
                        != PE_ID (PE_CLASS_CONT, 0))
            p115 = NULLPE;
        if (p115 != NULLPE) {
            p114 = p115;

            {	/* element TAG PULLUP */
                register PE p116;

                if ((p116 = prim2set (p115)) == NULLPE) {
                    advise (NULLCP, "version %selement: %s", PEPY_ERR_BAD,
                            pe_error (p115 -> pe_errno));
                    return NOTOK;
                }
                if (p116 -> pe_cardinal != 1) {
                    advise (NULLCP, "version %s element: %d", PEPY_ERR_TOO_MANY_TAGGED,
                            p116 -> pe_cardinal);
                    return NOTOK;
                }
                p115 = first_member (p116);
            }
            {	/* version */
                register integer p117;

#ifdef DEBUG
                (void) testdebug (p115, "version");
#endif

                if (p115 -> pe_class != PE_CLASS_UNIV
                        || p115 -> pe_form != PE_FORM_PRIM
                        || p115 -> pe_id != PE_PRIM_INT) {
                    advise (NULLCP, "version bad class/form/id: %s/%d/0x%x",
                            pe_classlist[p115 -> pe_class], p115 -> pe_form, p115 -> pe_id);
                    return NOTOK;
                }

                if ((p117 = prim2num (p115)) == NOTOK
                        && p115 -> pe_errno != PE_ERR_NONE) {
                    advise (NULLCP, "version %s%s", PEPY_ERR_BAD_INTEGER,
                            pe_error (p115 -> pe_errno));
                    return NOTOK;
                }
                (*parm) -> version  = p117;
                switch (p117) {
                    case 0:	/* v1988 */
                        break;
                    case 1:	/* v1992 */
                        break;
                }
            }
        }
        else {
            /* set default here using yp -> yp_default */
        }

    }

    {
        register PE p118;

        if ((p118 = (pe != p114 ? next_member (pe, p114) : first_member (pe))) != NULLPE) {
            p114 = p118;

            {	/* serialNumber */
                register integer p119;

#ifdef DEBUG
                (void) testdebug (p118, "serialNumber");
#endif

                if (p118 -> pe_class != PE_CLASS_UNIV
                        || p118 -> pe_form != PE_FORM_PRIM
                        || p118 -> pe_id != PE_PRIM_INT) {
                    advise (NULLCP, "serialNumber bad class/form/id: %s/%d/0x%x",
                            pe_classlist[p118 -> pe_class], p118 -> pe_form, p118 -> pe_id);
                    return NOTOK;
                }

                if ((p119 = prim2num (p118)) == NOTOK
                        && p118 -> pe_errno != PE_ERR_NONE) {
                    advise (NULLCP, "serialNumber %s%s", PEPY_ERR_BAD_INTEGER,
                            pe_error (p118 -> pe_errno));
                    return NOTOK;
                }
                (*parm) -> serialnumber  = p119;
            }
        }
        else {
            advise (NULLCP, "TBSCertificate %sserialNumber element", PEPY_ERR_MISSING);
            return NOTOK;
        }

    }

    {
        register PE p120;

        if ((p120 = (pe != p114 ? next_member (pe, p114) : first_member (pe))) != NULLPE) {
            p114 = p120;

            {	/* signature */
#ifdef DEBUG
                (void) testdebug (p120, "signature");
#endif

                if (parse_SEC_AlgorithmIdentifier (p120, 1, NULLIP, NULLVP, &((*parm) -> signatureAI)) == NOTOK)
                    return NOTOK;
            }
        }
        else {
            advise (NULLCP, "TBSCertificate %ssignature element", PEPY_ERR_MISSING);
            return NOTOK;
        }

    }

    {
        register PE p121;

        if ((p121 = (pe != p114 ? next_member (pe, p114) : first_member (pe))) != NULLPE) {
            p114 = p121;

            {	/* issuer */
#ifdef DEBUG
                (void) testdebug (p121, "issuer");
#endif

                if (parse_IF_Name (p121, 1, NULLIP, NULLVP, &((*parm) -> issuer)) == NOTOK)
                    return NOTOK;
            }
        }
        else {
            advise (NULLCP, "TBSCertificate %sissuer element", PEPY_ERR_MISSING);
            return NOTOK;
        }

    }

    {
        register PE p122;

        if ((p122 = (pe != p114 ? next_member (pe, p114) : first_member (pe))) != NULLPE) {
            p114 = p122;

            {	/* validity */
#ifdef DEBUG
                (void) testdebug (p122, "validity");
#endif

                if (parse_AF_Validity (p122, 1, NULLIP, NULLVP, (*parm) ) == NOTOK)
                    return NOTOK;
            }
        }
        else {
            advise (NULLCP, "TBSCertificate %svalidity element", PEPY_ERR_MISSING);
            return NOTOK;
        }

    }

    {
        register PE p123;

        if ((p123 = (pe != p114 ? next_member (pe, p114) : first_member (pe))) != NULLPE) {
            p114 = p123;

            {	/* subject */
#ifdef DEBUG
                (void) testdebug (p123, "subject");
#endif

                if (parse_IF_Name (p123, 1, NULLIP, NULLVP, &((*parm) -> subject)) == NOTOK)
                    return NOTOK;
            }
        }
        else {
            advise (NULLCP, "TBSCertificate %ssubject element", PEPY_ERR_MISSING);
            return NOTOK;
        }

    }

    {
        register PE p124;

        if ((p124 = (pe != p114 ? next_member (pe, p114) : first_member (pe))) != NULLPE) {
            p114 = p124;

            {	/* subjectPublickeyInfo */
#ifdef DEBUG
                (void) testdebug (p124, "subjectPublickeyInfo");
#endif

                if (parse_SEC_KeyInfo (p124, 1, NULLIP, NULLVP, ((*parm) -> subjectPK)) == NOTOK)
                    return NOTOK;
            }
        }
        else {
            advise (NULLCP, "TBSCertificate %ssubjectPublickeyInfo element", PEPY_ERR_MISSING);
            return NOTOK;
        }

    }


    if (pe -> pe_cardinal > 7) {
        advise (NULLCP, "TBSCertificate %s(7): %d", PEPY_ERR_TOO_MANY_ELEMENTS,
                pe -> pe_cardinal);
        return NOTOK;
    }

    return OK;
}

/* ARGSUSED */

int	parse_AF_Certificate (pe, explicit, len, buffer, parm)
register PE	pe;
int	explicit;
int    *len;
char  **buffer;
Certificate ** parm;
{
    register PE p125;

#ifdef DEBUG
    (void) testdebug (pe, "AF.Certificate");
#endif

    if (explicit) {
        if (pe -> pe_class != PE_CLASS_UNIV
                || pe -> pe_form != PE_FORM_CONS
                || pe -> pe_id != PE_CONS_SEQ) {
            advise (NULLCP, "Certificate bad class/form/id: %s/%d/0x%x",
                    pe_classlist[pe -> pe_class], pe -> pe_form, pe -> pe_id);
            return NOTOK;
        }
    }
    else
        if (pe -> pe_form != PE_FORM_CONS) {
            advise (NULLCP, "Certificate bad form: %d", pe -> pe_form);
            return NOTOK;
        }

    {

        if ((*(parm) = (Certificate *)
                calloc (1, sizeof **(parm))) == ((Certificate *) 0)) {
            advise (NULLCP, "out of memory");
            return NOTOK;
        }
        if (((*parm)->sig = (Signature *)
                calloc (1, sizeof (Signature))) == ((Signature *) 0)) {
            advise (NULLCP, "out of memory");
            return NOTOK;
        }
    
    }
    if ((p125 = prim2seq (pe)) == NULLPE) {
        advise (NULLCP, "Certificate %s%s", PEPY_ERR_BAD_SEQ,
                pe_error (pe -> pe_errno));
        return NOTOK;
    }
    pe = p125;

    {
        register PE p126;

        if ((p126 = first_member (pe)) != NULLPE) {
            p125 = p126;

            {
#ifdef DEBUG
                (void) testdebug (p126, "element");
#endif

                if (parse_AF_TBSCertificate (p126, 1, NULLIP, NULLVP, &((*parm)->tbs) ) == NOTOK)
                    return NOTOK;
                {
 /* set x509_tbs */
		(*parm)->tbs_DERcode = aux_PE2OctetString(p126);
		if( (*parm)->tbs_DERcode == (OctetString *)0 ) return NOTOK;
	   
                }
            }
        }
        else {
            advise (NULLCP, "Certificate %selement", PEPY_ERR_MISSING);
            return NOTOK;
        }

    }

    {
        register PE p127;

        if ((p127 = (pe != p125 ? next_member (pe, p125) : first_member (pe))) != NULLPE) {
            p125 = p127;

            {
#ifdef DEBUG
                (void) testdebug (p127, "element");
#endif

                if (parse_SEC_AlgorithmIdentifier (p127, 1, NULLIP, NULLVP, &((*parm) -> sig->signAI)) == NOTOK)
                    return NOTOK;
            }
        }
        else {
            advise (NULLCP, "Certificate %selement", PEPY_ERR_MISSING);
            return NOTOK;
        }

    }

    {
        register PE p128;

        if ((p128 = (pe != p125 ? next_member (pe, p125) : first_member (pe))) != NULLPE) {
            p125 = p128;

            {
                register PE p129;

#ifdef DEBUG
                (void) testdebug (p128, "element");
#endif

                if (p128 -> pe_class != PE_CLASS_UNIV || p128 -> pe_id != PE_PRIM_BITS) {
                    advise (NULLCP, "element bad class/form/id: %s/%d/0x%x",
                            pe_classlist[p128 -> pe_class], p128 -> pe_form, p128 -> pe_id);
                    return NOTOK;
                }

                if ((p129 = prim2bit (p128)) == NULLPE) {
                    advise (NULLCP, "element %s%s", PEPY_ERR_BAD_BITS,
                            pe_error (p128 -> pe_errno));
                    return NOTOK;
                }
                (*parm)->sig->signature.bits  = bitstr2strb (p128, &(
		     (*parm)->sig->signature.nbits ));
            }
        }
        else {
            advise (NULLCP, "Certificate %selement", PEPY_ERR_MISSING);
            return NOTOK;
        }

    }


    if (pe -> pe_cardinal > 3) {
        advise (NULLCP, "Certificate %s(3): %d", PEPY_ERR_TOO_MANY_ELEMENTS,
                pe -> pe_cardinal);
        return NOTOK;
    }

    return OK;
}

/* ARGSUSED */

int	parse_AF_Certificates (pe, explicit, len, buffer, parm)
register PE	pe;
int	explicit;
int    *len;
char  **buffer;
Certificates ** parm;
{
    register PE p130;

#ifdef DEBUG
    (void) testdebug (pe, "AF.Certificates");
#endif

    if (explicit) {
        if (pe -> pe_class != PE_CLASS_UNIV
                || pe -> pe_form != PE_FORM_CONS
                || pe -> pe_id != PE_CONS_SEQ) {
            advise (NULLCP, "Certificates bad class/form/id: %s/%d/0x%x",
                    pe_classlist[pe -> pe_class], pe -> pe_form, pe -> pe_id);
            return NOTOK;
        }
    }
    else
        if (pe -> pe_form != PE_FORM_CONS) {
            advise (NULLCP, "Certificates bad form: %d", pe -> pe_form);
            return NOTOK;
        }

    {

        if ((*(parm) = (Certificates *)
                calloc (1, sizeof **(parm))) == ((Certificates *) 0)) {
            advise (NULLCP, "out of memory");
            return NOTOK;
        }
    
    }
    if ((p130 = prim2seq (pe)) == NULLPE) {
        advise (NULLCP, "Certificates %s%s", PEPY_ERR_BAD_SEQ,
                pe_error (pe -> pe_errno));
        return NOTOK;
    }
    pe = p130;

    {
        register PE p131;

        if ((p131 = first_member (pe)) != NULLPE) {
            p130 = p131;

            {	/* certificate */
#ifdef DEBUG
                (void) testdebug (p131, "certificate");
#endif

                if (parse_AF_Certificate (p131, 1, NULLIP, NULLVP, &((*parm) -> usercertificate)) == NOTOK)
                    return NOTOK;
            }
        }
        else {
            advise (NULLCP, "Certificates %scertificate element", PEPY_ERR_MISSING);
            return NOTOK;
        }

    }

    {
        register PE p132;

        if ((p132 = (pe != p130 ? next_member (pe, p130) : first_member (pe))) != NULLPE) {
            p130 = p132;

            {	/* certificationPath */
#ifdef DEBUG
                (void) testdebug (p132, "certificationPath");
#endif

                if (parse_AF_ForwardCertificationPath (p132, 1, NULLIP, NULLVP, &((*parm) -> forwardpath)) == NOTOK)
                    return NOTOK;
            }
        }
    }


    if (pe -> pe_cardinal > 2) {
        advise (NULLCP, "Certificates %s(2): %d", PEPY_ERR_TOO_MANY_ELEMENTS,
                pe -> pe_cardinal);
        return NOTOK;
    }

    return OK;
}

/* ARGSUSED */

int	parse_AF_ForwardCertificationPath (pe, explicit, len, buffer, parm)
register PE	pe;
int	explicit;
int    *len;
char  **buffer;
FCPath ** parm;
{
    register PE p133;

#ifdef DEBUG
    (void) testdebug (pe, "AF.ForwardCertificationPath");
#endif

    if (explicit) {
        if (pe -> pe_class != PE_CLASS_UNIV
                || pe -> pe_form != PE_FORM_CONS
                || pe -> pe_id != PE_CONS_SEQ) {
            advise (NULLCP, "ForwardCertificationPath bad class/form/id: %s/%d/0x%x",
                    pe_classlist[pe -> pe_class], pe -> pe_form, pe -> pe_id);
            return NOTOK;
        }
    }
    else
        if (pe -> pe_form != PE_FORM_CONS) {
            advise (NULLCP, "ForwardCertificationPath bad form: %d", pe -> pe_form);
            return NOTOK;
        }

    if ((p133 = prim2seq (pe)) == NULLPE) {
        advise (NULLCP, "ForwardCertificationPath %s%s", PEPY_ERR_BAD_SEQ,
                pe_error (pe -> pe_errno));
        return NOTOK;
    }
    pe = p133;

    for (p133 = first_member (pe); p133; p133 = next_member (pe, p133)) {
        {

                if ((*(parm) = (FCPath *)
                        calloc (1, sizeof **(parm))) == ((FCPath *) 0)) {
                    advise (NULLCP, "out of memory");
                    return NOTOK;
                }
            
        }
        {
#ifdef DEBUG
            (void) testdebug (p133, "element");
#endif

            if (parse_AF_CertificateSet (p133, 1, NULLIP, NULLVP, &((*parm) -> liste)) == NOTOK)
                return NOTOK;
            {
 parm = &((*parm) -> next_forwardpath); 
            }
        }
    }

    return OK;
}

/* ARGSUSED */

int	parse_AF_CertificateSet (pe, explicit, len, buffer, parm)
register PE	pe;
int	explicit;
int    *len;
char  **buffer;
SET_OF_Certificate ** parm;
{
    register PE p134;

#ifdef DEBUG
    (void) testdebug (pe, "AF.CertificateSet");
#endif

    if (explicit) {
        if (pe -> pe_class != PE_CLASS_UNIV
                || pe -> pe_form != PE_FORM_CONS
                || pe -> pe_id != PE_CONS_SET) {
            advise (NULLCP, "CertificateSet bad class/form/id: %s/%d/0x%x",
                    pe_classlist[pe -> pe_class], pe -> pe_form, pe -> pe_id);
            return NOTOK;
        }
    }
    else
        if (pe -> pe_form != PE_FORM_CONS) {
            advise (NULLCP, "CertificateSet bad form: %d", pe -> pe_form);
            return NOTOK;
        }

    if ((p134 = prim2set (pe)) == NULLPE) {
        advise (NULLCP, "CertificateSet %s%s", PEPY_ERR_BAD_SET,
                pe_error (pe -> pe_errno));
        return NOTOK;
    }
    pe = p134;

    for (p134 = first_member (pe); p134; p134 = next_member (pe, p134)) {
        {

                if ((*(parm) = (SET_OF_Certificate *)
                        calloc (1, sizeof **(parm))) == ((SET_OF_Certificate *) 0)) {
                    advise (NULLCP, "out of memory");
                    return NOTOK;
                }
            
        }
        {
#ifdef DEBUG
            (void) testdebug (p134, "member");
#endif

            if (parse_AF_Certificate (p134, 1, NULLIP, NULLVP, &((*parm) -> element)) == NOTOK)
                return NOTOK;
            {
 parm = &((*parm) -> next); 
            }
        }
    }

    return OK;
}

/* ARGSUSED */

int	parse_AF_CertificatePair (pe, explicit, len, buffer, parm)
register PE	pe;
int	explicit;
int    *len;
char  **buffer;
CertificatePair ** parm;
{
    register PE p135;

#ifdef DEBUG
    (void) testdebug (pe, "AF.CertificatePair");
#endif

    if (explicit) {
        if (pe -> pe_class != PE_CLASS_UNIV
                || pe -> pe_form != PE_FORM_CONS
                || pe -> pe_id != PE_CONS_SEQ) {
            advise (NULLCP, "CertificatePair bad class/form/id: %s/%d/0x%x",
                    pe_classlist[pe -> pe_class], pe -> pe_form, pe -> pe_id);
            return NOTOK;
        }
    }
    else
        if (pe -> pe_form != PE_FORM_CONS) {
            advise (NULLCP, "CertificatePair bad form: %d", pe -> pe_form);
            return NOTOK;
        }

    {

        if ((*(parm) = (CertificatePair *)
                calloc (1, sizeof **(parm))) == ((CertificatePair *) 0)) {
            advise (NULLCP, "out of memory");
            return NOTOK;
        }
    
    }
    if ((p135 = prim2seq (pe)) == NULLPE) {
        advise (NULLCP, "CertificatePair %s%s", PEPY_ERR_BAD_SEQ,
                pe_error (pe -> pe_errno));
        return NOTOK;
    }
    pe = p135;

    {
        register PE p136;

        if ((p136 = first_member (pe)) != NULLPE
                && PE_ID (p136 -> pe_class, p136 -> pe_id)
                        != PE_ID (PE_CLASS_CONT, 0))
            p136 = NULLPE;
        if (p136 != NULLPE) {
            p135 = p136;

            {	/* element TAG PULLUP */
                register PE p137;

                if ((p137 = prim2set (p136)) == NULLPE) {
                    advise (NULLCP, "forward %selement: %s", PEPY_ERR_BAD,
                            pe_error (p136 -> pe_errno));
                    return NOTOK;
                }
                if (p137 -> pe_cardinal != 1) {
                    advise (NULLCP, "forward %s element: %d", PEPY_ERR_TOO_MANY_TAGGED,
                            p137 -> pe_cardinal);
                    return NOTOK;
                }
                p136 = first_member (p137);
            }
            {	/* forward */
#ifdef DEBUG
                (void) testdebug (p136, "forward");
#endif

                if (parse_AF_Certificate (p136, 1, NULLIP, NULLVP, &((*parm) -> forward)) == NOTOK)
                    return NOTOK;
            }
        }
    }

    {
        register PE p138;

        if ((p138 = (pe != p135 ? next_member (pe, p135) : first_member (pe))) != NULLPE) {
            p135 = p138;

            {	/* element TAG PULLUP */
                register PE p139;

                if ((p139 = prim2set (p138)) == NULLPE) {
                    advise (NULLCP, "reverse %selement: %s", PEPY_ERR_BAD,
                            pe_error (p138 -> pe_errno));
                    return NOTOK;
                }
                if (p139 -> pe_cardinal != 1) {
                    advise (NULLCP, "reverse %s element: %d", PEPY_ERR_TOO_MANY_TAGGED,
                            p139 -> pe_cardinal);
                    return NOTOK;
                }
                p138 = first_member (p139);
            }
            {	/* reverse */
#ifdef DEBUG
                (void) testdebug (p138, "reverse");
#endif

                if (parse_AF_Certificate (p138, 1, NULLIP, NULLVP, &((*parm) -> reverse)) == NOTOK)
                    return NOTOK;
            }
        }
    }


    if (pe -> pe_cardinal > 2) {
        advise (NULLCP, "CertificatePair %s(2): %d", PEPY_ERR_TOO_MANY_ELEMENTS,
                pe -> pe_cardinal);
        return NOTOK;
    }

    return OK;
}

/* ARGSUSED */

int	parse_AF_CrossCertificatePair (pe, explicit, len, buffer, parm)
register PE	pe;
int	explicit;
int    *len;
char  **buffer;
SET_OF_CertificatePair ** parm;
{
    register PE p140;

#ifdef DEBUG
    (void) testdebug (pe, "AF.CrossCertificatePair");
#endif

    if (explicit) {
        if (pe -> pe_class != PE_CLASS_UNIV
                || pe -> pe_form != PE_FORM_CONS
                || pe -> pe_id != PE_CONS_SET) {
            advise (NULLCP, "CrossCertificatePair bad class/form/id: %s/%d/0x%x",
                    pe_classlist[pe -> pe_class], pe -> pe_form, pe -> pe_id);
            return NOTOK;
        }
    }
    else
        if (pe -> pe_form != PE_FORM_CONS) {
            advise (NULLCP, "CrossCertificatePair bad form: %d", pe -> pe_form);
            return NOTOK;
        }

    if ((p140 = prim2set (pe)) == NULLPE) {
        advise (NULLCP, "CrossCertificatePair %s%s", PEPY_ERR_BAD_SET,
                pe_error (pe -> pe_errno));
        return NOTOK;
    }
    pe = p140;

    for (p140 = first_member (pe); p140; p140 = next_member (pe, p140)) {
        {

                if ((*(parm) = (SET_OF_CertificatePair *)
                        calloc (1, sizeof **(parm))) == ((SET_OF_CertificatePair *) 0)) {
                    advise (NULLCP, "out of memory");
                    return NOTOK;
                }
            
        }
        {
#ifdef DEBUG
            (void) testdebug (p140, "member");
#endif

            if (parse_AF_CertificatePair (p140, 1, NULLIP, NULLVP, &((*parm) -> element)) == NOTOK)
                return NOTOK;
            {
 parm = &((*parm) -> next); 
            }
        }
    }

    return OK;
}

/* ARGSUSED */

int	parse_AF_PKList (pe, explicit, len, buffer, parm)
register PE	pe;
int	explicit;
int    *len;
char  **buffer;
PKList ** parm;
{
    register PE p141;

#ifdef DEBUG
    (void) testdebug (pe, "AF.PKList");
#endif

    if (explicit) {
        if (pe -> pe_class != PE_CLASS_UNIV
                || pe -> pe_form != PE_FORM_CONS
                || pe -> pe_id != PE_CONS_SET) {
            advise (NULLCP, "PKList bad class/form/id: %s/%d/0x%x",
                    pe_classlist[pe -> pe_class], pe -> pe_form, pe -> pe_id);
            return NOTOK;
        }
    }
    else
        if (pe -> pe_form != PE_FORM_CONS) {
            advise (NULLCP, "PKList bad form: %d", pe -> pe_form);
            return NOTOK;
        }

    if ((p141 = prim2set (pe)) == NULLPE) {
        advise (NULLCP, "PKList %s%s", PEPY_ERR_BAD_SET,
                pe_error (pe -> pe_errno));
        return NOTOK;
    }
    pe = p141;

    for (p141 = first_member (pe); p141; p141 = next_member (pe, p141)) {
        {

                if ((*(parm) = (PKList *)
                        calloc (1, sizeof **(parm))) == ((PKList *) 0)) {
                    advise (NULLCP, "out of memory");
                    return NOTOK;
                }
            
        }
        {
#ifdef DEBUG
            (void) testdebug (p141, "member");
#endif

            if (parse_AF_TBSCertificate (p141, 1, NULLIP, NULLVP, &((*parm) -> element)) == NOTOK)
                return NOTOK;
            {
 parm = &((*parm) -> next); 
            }
        }
    }

    return OK;
}

/* ARGSUSED */

int	parse_AF_TBSCrl (pe, explicit, len, buffer, parm)
register PE	pe;
int	explicit;
int    *len;
char  **buffer;
CrlTBS ** parm;
{
    register PE p142;

#ifdef DEBUG
    (void) testdebug (pe, "AF.TBSCrl");
#endif

    if (explicit) {
        if (pe -> pe_class != PE_CLASS_UNIV
                || pe -> pe_form != PE_FORM_CONS
                || pe -> pe_id != PE_CONS_SEQ) {
            advise (NULLCP, "TBSCrl bad class/form/id: %s/%d/0x%x",
                    pe_classlist[pe -> pe_class], pe -> pe_form, pe -> pe_id);
            return NOTOK;
        }
    }
    else
        if (pe -> pe_form != PE_FORM_CONS) {
            advise (NULLCP, "TBSCrl bad form: %d", pe -> pe_form);
            return NOTOK;
        }

    {

            if ((*(parm) = (CrlTBS *)
                    calloc (1, sizeof **(parm))) == ((CrlTBS *) 0)) {
                advise (NULLCP, "out of memory");
                return NOTOK;
            }
	    (*parm)->revokedcertificates = (SEQUENCE_OF_RevCert *)0;
	
    }
    if ((p142 = prim2seq (pe)) == NULLPE) {
        advise (NULLCP, "TBSCrl %s%s", PEPY_ERR_BAD_SEQ,
                pe_error (pe -> pe_errno));
        return NOTOK;
    }
    pe = p142;

    {
        register PE p143;

        if ((p143 = first_member (pe)) != NULLPE) {
            p142 = p143;

            {	/* signature */
#ifdef DEBUG
                (void) testdebug (p143, "signature");
#endif

                if (parse_SEC_AlgorithmIdentifier (p143, 1, NULLIP, NULLVP, &((*parm)->signatureAI) ) == NOTOK)
                    return NOTOK;
            }
        }
        else {
            advise (NULLCP, "TBSCrl %ssignature element", PEPY_ERR_MISSING);
            return NOTOK;
        }

    }

    {
        register PE p144;

        if ((p144 = (pe != p142 ? next_member (pe, p142) : first_member (pe))) != NULLPE) {
            p142 = p144;

            {	/* issuer */
#ifdef DEBUG
                (void) testdebug (p144, "issuer");
#endif

                if (parse_IF_Name (p144, 1, NULLIP, NULLVP, &((*parm)->issuer) ) == NOTOK)
                    return NOTOK;
            }
        }
        else {
            advise (NULLCP, "TBSCrl %sissuer element", PEPY_ERR_MISSING);
            return NOTOK;
        }

    }

    {
        register PE p145;

        if ((p145 = (pe != p142 ? next_member (pe, p142) : first_member (pe))) != NULLPE) {
            p142 = p145;

            {	/* lastUpdate */
#ifdef DEBUG
                (void) testdebug (p145, "lastUpdate");
#endif

                if (parse_UNIV_UTCTime (p145, 1, NULLIP, &(((*parm)->lastupdate) ), NullParm) == NOTOK)
                    return NOTOK;
            }
        }
        else {
            advise (NULLCP, "TBSCrl %slastUpdate element", PEPY_ERR_MISSING);
            return NOTOK;
        }

    }

    {
        register PE p146;

        if ((p146 = (pe != p142 ? next_member (pe, p142) : first_member (pe))) != NULLPE) {
            p142 = p146;

            {	/* revokedCertificates */
#ifdef DEBUG
                (void) testdebug (p146, "revokedCertificates");
#endif

                if (parse_AF_RevCertSequence (p146, 1, NULLIP, NULLVP, &((*parm)->revokedcertificates) ) == NOTOK)
                    return NOTOK;
            }
        }
    }


    if (pe -> pe_cardinal > 4) {
        advise (NULLCP, "TBSCrl %s(4): %d", PEPY_ERR_TOO_MANY_ELEMENTS,
                pe -> pe_cardinal);
        return NOTOK;
    }

    return OK;
}

/* ARGSUSED */

int	parse_AF_Crl (pe, explicit, len, buffer, parm)
register PE	pe;
int	explicit;
int    *len;
char  **buffer;
Crl ** parm;
{
    register PE p147;

#ifdef DEBUG
    (void) testdebug (pe, "AF.Crl");
#endif

    if (explicit) {
        if (pe -> pe_class != PE_CLASS_UNIV
                || pe -> pe_form != PE_FORM_CONS
                || pe -> pe_id != PE_CONS_SEQ) {
            advise (NULLCP, "Crl bad class/form/id: %s/%d/0x%x",
                    pe_classlist[pe -> pe_class], pe -> pe_form, pe -> pe_id);
            return NOTOK;
        }
    }
    else
        if (pe -> pe_form != PE_FORM_CONS) {
            advise (NULLCP, "Crl bad form: %d", pe -> pe_form);
            return NOTOK;
        }

    {

            if ((*(parm) = (Crl *)
                    calloc (1, sizeof **(parm))) == ((Crl *) 0)) {
                advise (NULLCP, "out of memory");
                return NOTOK;
            }
            if (((*parm)->sig = (Signature *)
                    calloc (1, sizeof (Signature))) == ((Signature *) 0)) {
                advise (NULLCP, "out of memory");
                return NOTOK;
            }
        
    }
    if ((p147 = prim2seq (pe)) == NULLPE) {
        advise (NULLCP, "Crl %s%s", PEPY_ERR_BAD_SEQ,
                pe_error (pe -> pe_errno));
        return NOTOK;
    }
    pe = p147;

    {
        register PE p148;

        if ((p148 = first_member (pe)) != NULLPE) {
            p147 = p148;

            {
#ifdef DEBUG
                (void) testdebug (p148, "element");
#endif

                if (parse_AF_TBSCrl (p148, 1, NULLIP, NULLVP, &((*parm)->tbs) ) == NOTOK)
                    return NOTOK;
                {
 /* set x509_tbs */
		(*parm)->tbs_DERcode = aux_PE2OctetString(p148);
		if ( (*parm)->tbs_DERcode == (OctetString *)0 ) return NOTOK;
	   
                }
            }
        }
        else {
            advise (NULLCP, "Crl %selement", PEPY_ERR_MISSING);
            return NOTOK;
        }

    }

    {
        register PE p149;

        if ((p149 = (pe != p147 ? next_member (pe, p147) : first_member (pe))) != NULLPE) {
            p147 = p149;

            {
#ifdef DEBUG
                (void) testdebug (p149, "element");
#endif

                if (parse_SEC_AlgorithmIdentifier (p149, 1, NULLIP, NULLVP, &((*parm)->sig->signAI) ) == NOTOK)
                    return NOTOK;
            }
        }
        else {
            advise (NULLCP, "Crl %selement", PEPY_ERR_MISSING);
            return NOTOK;
        }

    }

    {
        register PE p150;

        if ((p150 = (pe != p147 ? next_member (pe, p147) : first_member (pe))) != NULLPE) {
            p147 = p150;

            {
                register PE p151;

#ifdef DEBUG
                (void) testdebug (p150, "element");
#endif

                if (p150 -> pe_class != PE_CLASS_UNIV || p150 -> pe_id != PE_PRIM_BITS) {
                    advise (NULLCP, "element bad class/form/id: %s/%d/0x%x",
                            pe_classlist[p150 -> pe_class], p150 -> pe_form, p150 -> pe_id);
                    return NOTOK;
                }

                if ((p151 = prim2bit (p150)) == NULLPE) {
                    advise (NULLCP, "element %s%s", PEPY_ERR_BAD_BITS,
                            pe_error (p150 -> pe_errno));
                    return NOTOK;
                }
                (*parm)->sig->signature.bits  = bitstr2strb (p150, &(
		     (*parm)->sig->signature.nbits ));
            }
        }
        else {
            advise (NULLCP, "Crl %selement", PEPY_ERR_MISSING);
            return NOTOK;
        }

    }


    if (pe -> pe_cardinal > 3) {
        advise (NULLCP, "Crl %s(3): %d", PEPY_ERR_TOO_MANY_ELEMENTS,
                pe -> pe_cardinal);
        return NOTOK;
    }

    return OK;
}

/* ARGSUSED */

int	parse_AF_TBSRevCert (pe, explicit, len, buffer, parm)
register PE	pe;
int	explicit;
int    *len;
char  **buffer;
RevCertTBS ** parm;
{
    register PE p152;

#ifdef DEBUG
    (void) testdebug (pe, "AF.TBSRevCert");
#endif

    if (explicit) {
        if (pe -> pe_class != PE_CLASS_UNIV
                || pe -> pe_form != PE_FORM_CONS
                || pe -> pe_id != PE_CONS_SEQ) {
            advise (NULLCP, "TBSRevCert bad class/form/id: %s/%d/0x%x",
                    pe_classlist[pe -> pe_class], pe -> pe_form, pe -> pe_id);
            return NOTOK;
        }
    }
    else
        if (pe -> pe_form != PE_FORM_CONS) {
            advise (NULLCP, "TBSRevCert bad form: %d", pe -> pe_form);
            return NOTOK;
        }

    {

            if ((*(parm) = (RevCertTBS *)
                    calloc (1, sizeof **(parm))) == ((RevCertTBS *) 0)) {
                advise (NULLCP, "out of memory");
                return NOTOK;
            }
	
    }
    if ((p152 = prim2seq (pe)) == NULLPE) {
        advise (NULLCP, "TBSRevCert %s%s", PEPY_ERR_BAD_SEQ,
                pe_error (pe -> pe_errno));
        return NOTOK;
    }
    pe = p152;

    {
        register PE p153;

        if ((p153 = first_member (pe)) != NULLPE) {
            p152 = p153;

            {	/* signature */
#ifdef DEBUG
                (void) testdebug (p153, "signature");
#endif

                if (parse_SEC_AlgorithmIdentifier (p153, 1, NULLIP, NULLVP, &((*parm)->signatureAI) ) == NOTOK)
                    return NOTOK;
            }
        }
        else {
            advise (NULLCP, "TBSRevCert %ssignature element", PEPY_ERR_MISSING);
            return NOTOK;
        }

    }

    {
        register PE p154;

        if ((p154 = (pe != p152 ? next_member (pe, p152) : first_member (pe))) != NULLPE) {
            p152 = p154;

            {	/* issuer */
#ifdef DEBUG
                (void) testdebug (p154, "issuer");
#endif

                if (parse_IF_Name (p154, 1, NULLIP, NULLVP, &((*parm)->issuer) ) == NOTOK)
                    return NOTOK;
            }
        }
        else {
            advise (NULLCP, "TBSRevCert %sissuer element", PEPY_ERR_MISSING);
            return NOTOK;
        }

    }

    {
        register PE p155;

        if ((p155 = (pe != p152 ? next_member (pe, p152) : first_member (pe))) != NULLPE) {
            p152 = p155;

            {	/* subject */
                register integer p156;

#ifdef DEBUG
                (void) testdebug (p155, "subject");
#endif

                if (p155 -> pe_class != PE_CLASS_UNIV
                        || p155 -> pe_form != PE_FORM_PRIM
                        || p155 -> pe_id != PE_PRIM_INT) {
                    advise (NULLCP, "subject bad class/form/id: %s/%d/0x%x",
                            pe_classlist[p155 -> pe_class], p155 -> pe_form, p155 -> pe_id);
                    return NOTOK;
                }

                if ((p156 = prim2num (p155)) == NOTOK
                        && p155 -> pe_errno != PE_ERR_NONE) {
                    advise (NULLCP, "subject %s%s", PEPY_ERR_BAD_INTEGER,
                            pe_error (p155 -> pe_errno));
                    return NOTOK;
                }
                (*parm)->subject  = p156;
            }
        }
        else {
            advise (NULLCP, "TBSRevCert %ssubject element", PEPY_ERR_MISSING);
            return NOTOK;
        }

    }

    {
        register PE p157;

        if ((p157 = (pe != p152 ? next_member (pe, p152) : first_member (pe))) != NULLPE) {
            p152 = p157;

            {	/* revocationDate */
#ifdef DEBUG
                (void) testdebug (p157, "revocationDate");
#endif

                if (parse_UNIV_UTCTime (p157, 1, NULLIP, &(((*parm)->revocationdate) ), NullParm) == NOTOK)
                    return NOTOK;
            }
        }
        else {
            advise (NULLCP, "TBSRevCert %srevocationDate element", PEPY_ERR_MISSING);
            return NOTOK;
        }

    }


    if (pe -> pe_cardinal > 4) {
        advise (NULLCP, "TBSRevCert %s(4): %d", PEPY_ERR_TOO_MANY_ELEMENTS,
                pe -> pe_cardinal);
        return NOTOK;
    }

    return OK;
}

/* ARGSUSED */

int	parse_AF_RevCert (pe, explicit, len, buffer, parm)
register PE	pe;
int	explicit;
int    *len;
char  **buffer;
RevCert ** parm;
{
    register PE p158;

#ifdef DEBUG
    (void) testdebug (pe, "AF.RevCert");
#endif

    if (explicit) {
        if (pe -> pe_class != PE_CLASS_UNIV
                || pe -> pe_form != PE_FORM_CONS
                || pe -> pe_id != PE_CONS_SEQ) {
            advise (NULLCP, "RevCert bad class/form/id: %s/%d/0x%x",
                    pe_classlist[pe -> pe_class], pe -> pe_form, pe -> pe_id);
            return NOTOK;
        }
    }
    else
        if (pe -> pe_form != PE_FORM_CONS) {
            advise (NULLCP, "RevCert bad form: %d", pe -> pe_form);
            return NOTOK;
        }

    {

            if ((*(parm) = (RevCert *)
                    calloc (1, sizeof **(parm))) == ((RevCert *) 0)) {
                advise (NULLCP, "out of memory");
                return NOTOK;
            }
            if (((*parm)->sig = (Signature *)
                    calloc (1, sizeof (Signature))) == ((Signature *) 0)) {
                advise (NULLCP, "out of memory");
                return NOTOK;
            }
        
    }
    if ((p158 = prim2seq (pe)) == NULLPE) {
        advise (NULLCP, "RevCert %s%s", PEPY_ERR_BAD_SEQ,
                pe_error (pe -> pe_errno));
        return NOTOK;
    }
    pe = p158;

    {
        register PE p159;

        if ((p159 = first_member (pe)) != NULLPE) {
            p158 = p159;

            {
#ifdef DEBUG
                (void) testdebug (p159, "element");
#endif

                if (parse_AF_TBSRevCert (p159, 1, NULLIP, NULLVP, &((*parm)->tbs) ) == NOTOK)
                    return NOTOK;
                {
 /* set x509_tbs */
		(*parm)->tbs_DERcode = aux_PE2OctetString(p159);
		if ( (*parm)->tbs_DERcode == (OctetString *)0 ) return NOTOK;
	   
                }
            }
        }
        else {
            advise (NULLCP, "RevCert %selement", PEPY_ERR_MISSING);
            return NOTOK;
        }

    }

    {
        register PE p160;

        if ((p160 = (pe != p158 ? next_member (pe, p158) : first_member (pe))) != NULLPE) {
            p158 = p160;

            {
#ifdef DEBUG
                (void) testdebug (p160, "element");
#endif

                if (parse_SEC_AlgorithmIdentifier (p160, 1, NULLIP, NULLVP, &((*parm)->sig->signAI) ) == NOTOK)
                    return NOTOK;
            }
        }
        else {
            advise (NULLCP, "RevCert %selement", PEPY_ERR_MISSING);
            return NOTOK;
        }

    }

    {
        register PE p161;

        if ((p161 = (pe != p158 ? next_member (pe, p158) : first_member (pe))) != NULLPE) {
            p158 = p161;

            {
                register PE p162;

#ifdef DEBUG
                (void) testdebug (p161, "element");
#endif

                if (p161 -> pe_class != PE_CLASS_UNIV || p161 -> pe_id != PE_PRIM_BITS) {
                    advise (NULLCP, "element bad class/form/id: %s/%d/0x%x",
                            pe_classlist[p161 -> pe_class], p161 -> pe_form, p161 -> pe_id);
                    return NOTOK;
                }

                if ((p162 = prim2bit (p161)) == NULLPE) {
                    advise (NULLCP, "element %s%s", PEPY_ERR_BAD_BITS,
                            pe_error (p161 -> pe_errno));
                    return NOTOK;
                }
                (*parm)->sig->signature.bits  = bitstr2strb (p161, &(
		     (*parm)->sig->signature.nbits ));
            }
        }
        else {
            advise (NULLCP, "RevCert %selement", PEPY_ERR_MISSING);
            return NOTOK;
        }

    }


    if (pe -> pe_cardinal > 3) {
        advise (NULLCP, "RevCert %s(3): %d", PEPY_ERR_TOO_MANY_ELEMENTS,
                pe -> pe_cardinal);
        return NOTOK;
    }

    return OK;
}

/* ARGSUSED */

int	parse_AF_RevCertSequence (pe, explicit, len, buffer, parm)
register PE	pe;
int	explicit;
int    *len;
char  **buffer;
SEQUENCE_OF_RevCert ** parm;
{
    register PE p163;

#ifdef DEBUG
    (void) testdebug (pe, "AF.RevCertSequence");
#endif

    if (explicit) {
        if (pe -> pe_class != PE_CLASS_UNIV
                || pe -> pe_form != PE_FORM_CONS
                || pe -> pe_id != PE_CONS_SEQ) {
            advise (NULLCP, "RevCertSequence bad class/form/id: %s/%d/0x%x",
                    pe_classlist[pe -> pe_class], pe -> pe_form, pe -> pe_id);
            return NOTOK;
        }
    }
    else
        if (pe -> pe_form != PE_FORM_CONS) {
            advise (NULLCP, "RevCertSequence bad form: %d", pe -> pe_form);
            return NOTOK;
        }

    if ((p163 = prim2seq (pe)) == NULLPE) {
        advise (NULLCP, "RevCertSequence %s%s", PEPY_ERR_BAD_SEQ,
                pe_error (pe -> pe_errno));
        return NOTOK;
    }
    pe = p163;

    for (p163 = first_member (pe); p163; p163 = next_member (pe, p163)) {
        {

		if ((*(parm) = (SEQUENCE_OF_RevCert *)
			calloc (1, sizeof **(parm))) == (SEQUENCE_OF_RevCert *) 0) {
                    advise (NULLCP, "out of memory");
                    return NOTOK;
                }
		(*parm) -> next = (SEQUENCE_OF_RevCert *)0;
            
        }
        {
#ifdef DEBUG
            (void) testdebug (p163, "element");
#endif

            if (parse_AF_RevCert (p163, 1, NULLIP, NULLVP, &((*parm) -> element) ) == NOTOK)
                return NOTOK;
            {
 parm = &((*parm) -> next); 
            }
        }
    }

    return OK;
}

/* ARGSUSED */

int	parse_AF_TBSPemCrl (pe, explicit, len, buffer, parm)
register PE	pe;
int	explicit;
int    *len;
char  **buffer;
PemCrlTBS ** parm;
{
    register PE p164;

#ifdef DEBUG
    (void) testdebug (pe, "AF.TBSPemCrl");
#endif

    if (explicit) {
        if (pe -> pe_class != PE_CLASS_UNIV
                || pe -> pe_form != PE_FORM_CONS
                || pe -> pe_id != PE_CONS_SEQ) {
            advise (NULLCP, "TBSPemCrl bad class/form/id: %s/%d/0x%x",
                    pe_classlist[pe -> pe_class], pe -> pe_form, pe -> pe_id);
            return NOTOK;
        }
    }
    else
        if (pe -> pe_form != PE_FORM_CONS) {
            advise (NULLCP, "TBSPemCrl bad form: %d", pe -> pe_form);
            return NOTOK;
        }

    {

            if ((*(parm) = (PemCrlTBS *)
                    calloc (1, sizeof **(parm))) == ((PemCrlTBS *) 0)) {
                advise (NULLCP, "out of memory");
                return NOTOK;
            }
	    (*parm)->revokedCertificates = (SEQUENCE_OF_RevCertPem *)0;
	
    }
    if ((p164 = prim2seq (pe)) == NULLPE) {
        advise (NULLCP, "TBSPemCrl %s%s", PEPY_ERR_BAD_SEQ,
                pe_error (pe -> pe_errno));
        return NOTOK;
    }
    pe = p164;

    {
        register PE p165;

        if ((p165 = first_member (pe)) != NULLPE) {
            p164 = p165;

            {	/* signature */
#ifdef DEBUG
                (void) testdebug (p165, "signature");
#endif

                if (parse_SEC_AlgorithmIdentifier (p165, 1, NULLIP, NULLVP, &((*parm)->signatureAI) ) == NOTOK)
                    return NOTOK;
            }
        }
        else {
            advise (NULLCP, "TBSPemCrl %ssignature element", PEPY_ERR_MISSING);
            return NOTOK;
        }

    }

    {
        register PE p166;

        if ((p166 = (pe != p164 ? next_member (pe, p164) : first_member (pe))) != NULLPE) {
            p164 = p166;

            {	/* issuer */
#ifdef DEBUG
                (void) testdebug (p166, "issuer");
#endif

                if (parse_IF_Name (p166, 1, NULLIP, NULLVP, &((*parm)->issuer) ) == NOTOK)
                    return NOTOK;
            }
        }
        else {
            advise (NULLCP, "TBSPemCrl %sissuer element", PEPY_ERR_MISSING);
            return NOTOK;
        }

    }

    {
        register PE p167;

        if ((p167 = (pe != p164 ? next_member (pe, p164) : first_member (pe))) != NULLPE) {
            p164 = p167;

            {	/* lastUpdate */
#ifdef DEBUG
                (void) testdebug (p167, "lastUpdate");
#endif

                if (parse_UNIV_UTCTime (p167, 1, NULLIP, &(((*parm)->lastUpdate) ), NullParm) == NOTOK)
                    return NOTOK;
            }
        }
        else {
            advise (NULLCP, "TBSPemCrl %slastUpdate element", PEPY_ERR_MISSING);
            return NOTOK;
        }

    }

    {
        register PE p168;

        if ((p168 = (pe != p164 ? next_member (pe, p164) : first_member (pe))) != NULLPE) {
            p164 = p168;

            {	/* nextUpdate */
#ifdef DEBUG
                (void) testdebug (p168, "nextUpdate");
#endif

                if (parse_UNIV_UTCTime (p168, 1, NULLIP, &(((*parm)->nextUpdate) ), NullParm) == NOTOK)
                    return NOTOK;
            }
        }
        else {
            advise (NULLCP, "TBSPemCrl %snextUpdate element", PEPY_ERR_MISSING);
            return NOTOK;
        }

    }

    {
        register PE p169;

        if ((p169 = (pe != p164 ? next_member (pe, p164) : first_member (pe))) != NULLPE) {
            p164 = p169;

            {	/* revokedCertificates */
#ifdef DEBUG
                (void) testdebug (p169, "revokedCertificates");
#endif

                if (parse_AF_RevCertPemSequence (p169, 1, NULLIP, NULLVP, &((*parm)->revokedCertificates) ) == NOTOK)
                    return NOTOK;
            }
        }
    }


    if (pe -> pe_cardinal > 5) {
        advise (NULLCP, "TBSPemCrl %s(5): %d", PEPY_ERR_TOO_MANY_ELEMENTS,
                pe -> pe_cardinal);
        return NOTOK;
    }

    return OK;
}

/* ARGSUSED */

int	parse_AF_PemCrl (pe, explicit, len, buffer, parm)
register PE	pe;
int	explicit;
int    *len;
char  **buffer;
PemCrl ** parm;
{
    register PE p170;

#ifdef DEBUG
    (void) testdebug (pe, "AF.PemCrl");
#endif

    if (explicit) {
        if (pe -> pe_class != PE_CLASS_UNIV
                || pe -> pe_form != PE_FORM_CONS
                || pe -> pe_id != PE_CONS_SEQ) {
            advise (NULLCP, "PemCrl bad class/form/id: %s/%d/0x%x",
                    pe_classlist[pe -> pe_class], pe -> pe_form, pe -> pe_id);
            return NOTOK;
        }
    }
    else
        if (pe -> pe_form != PE_FORM_CONS) {
            advise (NULLCP, "PemCrl bad form: %d", pe -> pe_form);
            return NOTOK;
        }

    {

            if ((*(parm) = (PemCrl *)
                    calloc (1, sizeof **(parm))) == ((PemCrl *) 0)) {
                advise (NULLCP, "out of memory");
                return NOTOK;
            }
            if (((*parm)->sig = (Signature *)
                    calloc (1, sizeof (Signature))) == ((Signature *) 0)) {
                advise (NULLCP, "out of memory");
                return NOTOK;
            }
        
    }
    if ((p170 = prim2seq (pe)) == NULLPE) {
        advise (NULLCP, "PemCrl %s%s", PEPY_ERR_BAD_SEQ,
                pe_error (pe -> pe_errno));
        return NOTOK;
    }
    pe = p170;

    {
        register PE p171;

        if ((p171 = first_member (pe)) != NULLPE) {
            p170 = p171;

            {
#ifdef DEBUG
                (void) testdebug (p171, "element");
#endif

                if (parse_AF_TBSPemCrl (p171, 1, NULLIP, NULLVP, &((*parm)->tbs) ) == NOTOK)
                    return NOTOK;
                {
 /* set x509_tbs */
		(*parm)->tbs_DERcode = aux_PE2OctetString(p171);
		if ( (*parm)->tbs_DERcode == (OctetString *)0 ) return NOTOK;
	   
                }
            }
        }
        else {
            advise (NULLCP, "PemCrl %selement", PEPY_ERR_MISSING);
            return NOTOK;
        }

    }

    {
        register PE p172;

        if ((p172 = (pe != p170 ? next_member (pe, p170) : first_member (pe))) != NULLPE) {
            p170 = p172;

            {
#ifdef DEBUG
                (void) testdebug (p172, "element");
#endif

                if (parse_SEC_AlgorithmIdentifier (p172, 1, NULLIP, NULLVP, &((*parm)->sig->signAI) ) == NOTOK)
                    return NOTOK;
            }
        }
        else {
            advise (NULLCP, "PemCrl %selement", PEPY_ERR_MISSING);
            return NOTOK;
        }

    }

    {
        register PE p173;

        if ((p173 = (pe != p170 ? next_member (pe, p170) : first_member (pe))) != NULLPE) {
            p170 = p173;

            {
                register PE p174;

#ifdef DEBUG
                (void) testdebug (p173, "element");
#endif

                if (p173 -> pe_class != PE_CLASS_UNIV || p173 -> pe_id != PE_PRIM_BITS) {
                    advise (NULLCP, "element bad class/form/id: %s/%d/0x%x",
                            pe_classlist[p173 -> pe_class], p173 -> pe_form, p173 -> pe_id);
                    return NOTOK;
                }

                if ((p174 = prim2bit (p173)) == NULLPE) {
                    advise (NULLCP, "element %s%s", PEPY_ERR_BAD_BITS,
                            pe_error (p173 -> pe_errno));
                    return NOTOK;
                }
                (*parm)->sig->signature.bits  = bitstr2strb (p173, &(
		     (*parm)->sig->signature.nbits ));
            }
        }
        else {
            advise (NULLCP, "PemCrl %selement", PEPY_ERR_MISSING);
            return NOTOK;
        }

    }


    if (pe -> pe_cardinal > 3) {
        advise (NULLCP, "PemCrl %s(3): %d", PEPY_ERR_TOO_MANY_ELEMENTS,
                pe -> pe_cardinal);
        return NOTOK;
    }

    return OK;
}

/* ARGSUSED */

int	parse_AF_RevCertPemSequence (pe, explicit, len, buffer, parm)
register PE	pe;
int	explicit;
int    *len;
char  **buffer;
SEQUENCE_OF_RevCertPem ** parm;
{
    register PE p175;

#ifdef DEBUG
    (void) testdebug (pe, "AF.RevCertPemSequence");
#endif

    if (explicit) {
        if (pe -> pe_class != PE_CLASS_UNIV
                || pe -> pe_form != PE_FORM_CONS
                || pe -> pe_id != PE_CONS_SEQ) {
            advise (NULLCP, "RevCertPemSequence bad class/form/id: %s/%d/0x%x",
                    pe_classlist[pe -> pe_class], pe -> pe_form, pe -> pe_id);
            return NOTOK;
        }
    }
    else
        if (pe -> pe_form != PE_FORM_CONS) {
            advise (NULLCP, "RevCertPemSequence bad form: %d", pe -> pe_form);
            return NOTOK;
        }

    if ((p175 = prim2seq (pe)) == NULLPE) {
        advise (NULLCP, "RevCertPemSequence %s%s", PEPY_ERR_BAD_SEQ,
                pe_error (pe -> pe_errno));
        return NOTOK;
    }
    pe = p175;

    for (p175 = first_member (pe); p175; p175 = next_member (pe, p175)) {
        {

		if ((*(parm) = (SEQUENCE_OF_RevCertPem *)
			calloc (1, sizeof **(parm))) == (SEQUENCE_OF_RevCertPem *) 0) {
                    advise (NULLCP, "out of memory");
                    return NOTOK;
                }
		(*parm) -> next = (SEQUENCE_OF_RevCertPem *)0;
            
        }
        {
#ifdef DEBUG
            (void) testdebug (p175, "element");
#endif

            if (parse_AF_RevCertPem (p175, 1, NULLIP, NULLVP, &((*parm) -> element) ) == NOTOK)
                return NOTOK;
            {
 parm = &((*parm) -> next); 
            }
        }
    }

    return OK;
}

/* ARGSUSED */

int	parse_AF_RevCertPem (pe, explicit, len, buffer, parm)
register PE	pe;
int	explicit;
int    *len;
char  **buffer;
RevCertPem ** parm;
{
    register PE p176;

#ifdef DEBUG
    (void) testdebug (pe, "AF.RevCertPem");
#endif

    if (explicit) {
        if (pe -> pe_class != PE_CLASS_UNIV
                || pe -> pe_form != PE_FORM_CONS
                || pe -> pe_id != PE_CONS_SEQ) {
            advise (NULLCP, "RevCertPem bad class/form/id: %s/%d/0x%x",
                    pe_classlist[pe -> pe_class], pe -> pe_form, pe -> pe_id);
            return NOTOK;
        }
    }
    else
        if (pe -> pe_form != PE_FORM_CONS) {
            advise (NULLCP, "RevCertPem bad form: %d", pe -> pe_form);
            return NOTOK;
        }

    {

            if ((*(parm) = (RevCertPem *)
                    calloc (1, sizeof **(parm))) == ((RevCertPem *) 0)) {
                advise (NULLCP, "out of memory");
                return NOTOK;
            }
        
    }
    if ((p176 = prim2seq (pe)) == NULLPE) {
        advise (NULLCP, "RevCertPem %s%s", PEPY_ERR_BAD_SEQ,
                pe_error (pe -> pe_errno));
        return NOTOK;
    }
    pe = p176;

    {
        register PE p177;

        if ((p177 = first_member (pe)) != NULLPE) {
            p176 = p177;

            {	/* serialNumber */
                register integer p178;

#ifdef DEBUG
                (void) testdebug (p177, "serialNumber");
#endif

                if (p177 -> pe_class != PE_CLASS_UNIV
                        || p177 -> pe_form != PE_FORM_PRIM
                        || p177 -> pe_id != PE_PRIM_INT) {
                    advise (NULLCP, "serialNumber bad class/form/id: %s/%d/0x%x",
                            pe_classlist[p177 -> pe_class], p177 -> pe_form, p177 -> pe_id);
                    return NOTOK;
                }

                if ((p178 = prim2num (p177)) == NOTOK
                        && p177 -> pe_errno != PE_ERR_NONE) {
                    advise (NULLCP, "serialNumber %s%s", PEPY_ERR_BAD_INTEGER,
                            pe_error (p177 -> pe_errno));
                    return NOTOK;
                }
                (*parm)->serialnumber  = p178;
            }
        }
        else {
            advise (NULLCP, "RevCertPem %sserialNumber element", PEPY_ERR_MISSING);
            return NOTOK;
        }

    }

    {
        register PE p179;

        if ((p179 = (pe != p176 ? next_member (pe, p176) : first_member (pe))) != NULLPE) {
            p176 = p179;

            {	/* revocationDate */
#ifdef DEBUG
                (void) testdebug (p179, "revocationDate");
#endif

                if (parse_UNIV_UTCTime (p179, 1, NULLIP, &((*parm)->revocationDate ), NullParm) == NOTOK)
                    return NOTOK;
            }
        }
        else {
            advise (NULLCP, "RevCertPem %srevocationDate element", PEPY_ERR_MISSING);
            return NOTOK;
        }

    }


    if (pe -> pe_cardinal > 2) {
        advise (NULLCP, "RevCertPem %s(2): %d", PEPY_ERR_TOO_MANY_ELEMENTS,
                pe -> pe_cardinal);
        return NOTOK;
    }

    return OK;
}

/* ARGSUSED */

int	parse_AF_SerialSet (pe, explicit, len, buffer, parm)
register PE	pe;
int	explicit;
int    *len;
char  **buffer;
SET_OF_int ** parm;
{
    register PE p180;

#ifdef DEBUG
    (void) testdebug (pe, "AF.SerialSet");
#endif

    if (explicit) {
        if (pe -> pe_class != PE_CLASS_UNIV
                || pe -> pe_form != PE_FORM_CONS
                || pe -> pe_id != PE_CONS_SET) {
            advise (NULLCP, "SerialSet bad class/form/id: %s/%d/0x%x",
                    pe_classlist[pe -> pe_class], pe -> pe_form, pe -> pe_id);
            return NOTOK;
        }
    }
    else
        if (pe -> pe_form != PE_FORM_CONS) {
            advise (NULLCP, "SerialSet bad form: %d", pe -> pe_form);
            return NOTOK;
        }

    if ((p180 = prim2set (pe)) == NULLPE) {
        advise (NULLCP, "SerialSet %s%s", PEPY_ERR_BAD_SET,
                pe_error (pe -> pe_errno));
        return NOTOK;
    }
    pe = p180;

    for (p180 = first_member (pe); p180; p180 = next_member (pe, p180)) {
        {

                if ((*(parm) = (SET_OF_int *)
                        calloc (1, sizeof **(parm))) == ((SET_OF_int *) 0)) {
                    advise (NULLCP, "out of memory");
                    return NOTOK;
                }
            
        }
        {
            register integer p181;

#ifdef DEBUG
            (void) testdebug (p180, "member");
#endif

            if (p180 -> pe_class != PE_CLASS_UNIV
                    || p180 -> pe_form != PE_FORM_PRIM
                    || p180 -> pe_id != PE_PRIM_INT) {
                advise (NULLCP, "member bad class/form/id: %s/%d/0x%x",
                        pe_classlist[p180 -> pe_class], p180 -> pe_form, p180 -> pe_id);
                return NOTOK;
            }

            if ((p181 = prim2num (p180)) == NOTOK
                    && p180 -> pe_errno != PE_ERR_NONE) {
                advise (NULLCP, "member %s%s", PEPY_ERR_BAD_INTEGER,
                        pe_error (p180 -> pe_errno));
                return NOTOK;
            }
            (*parm) -> element  = p181;
            {
 parm = &((*parm) -> next); 
            }
        }
    }

    return OK;
}

/* ARGSUSED */

int	parse_AF_CrlPSE (pe, explicit, len, buffer, parm)
register PE	pe;
int	explicit;
int    *len;
char  **buffer;
CrlPSE ** parm;
{
    register PE p182;

#ifdef DEBUG
    (void) testdebug (pe, "AF.CrlPSE");
#endif

    if (explicit) {
        if (pe -> pe_class != PE_CLASS_UNIV
                || pe -> pe_form != PE_FORM_CONS
                || pe -> pe_id != PE_CONS_SEQ) {
            advise (NULLCP, "CrlPSE bad class/form/id: %s/%d/0x%x",
                    pe_classlist[pe -> pe_class], pe -> pe_form, pe -> pe_id);
            return NOTOK;
        }
    }
    else
        if (pe -> pe_form != PE_FORM_CONS) {
            advise (NULLCP, "CrlPSE bad form: %d", pe -> pe_form);
            return NOTOK;
        }

    {

            if ((*(parm) = (CrlPSE *)
                    calloc (1, sizeof **(parm))) == ((CrlPSE *) 0)) {
                advise (NULLCP, "out of memory");
                return NOTOK;
            }
        
    }
    if ((p182 = prim2seq (pe)) == NULLPE) {
        advise (NULLCP, "CrlPSE %s%s", PEPY_ERR_BAD_SEQ,
                pe_error (pe -> pe_errno));
        return NOTOK;
    }
    pe = p182;

    {
        register PE p183;

        if ((p183 = first_member (pe)) != NULLPE) {
            p182 = p183;

            {	/* issuer */
#ifdef DEBUG
                (void) testdebug (p183, "issuer");
#endif

                if (parse_IF_Name (p183, 1, NULLIP, NULLVP, &((*parm)->issuer) ) == NOTOK)
                    return NOTOK;
            }
        }
        else {
            advise (NULLCP, "CrlPSE %sissuer element", PEPY_ERR_MISSING);
            return NOTOK;
        }

    }

    {
        register PE p184;

        if ((p184 = (pe != p182 ? next_member (pe, p182) : first_member (pe))) != NULLPE) {
            p182 = p184;

            {	/* nextUpdate */
#ifdef DEBUG
                (void) testdebug (p184, "nextUpdate");
#endif

                if (parse_UNIV_UTCTime (p184, 1, NULLIP, &(((*parm)->nextUpdate) ), NullParm) == NOTOK)
                    return NOTOK;
            }
        }
        else {
            advise (NULLCP, "CrlPSE %snextUpdate element", PEPY_ERR_MISSING);
            return NOTOK;
        }

    }

    {
        register PE p185;

        if ((p185 = (pe != p182 ? next_member (pe, p182) : first_member (pe))) != NULLPE) {
            p182 = p185;

            {	/* revcerts */
#ifdef DEBUG
                (void) testdebug (p185, "revcerts");
#endif

                if (parse_AF_RevCertPemSequence (p185, 1, NULLIP, NULLVP, &((*parm)->revcerts) ) == NOTOK)
                    return NOTOK;
            }
        }
    }


    if (pe -> pe_cardinal > 3) {
        advise (NULLCP, "CrlPSE %s(3): %d", PEPY_ERR_TOO_MANY_ELEMENTS,
                pe -> pe_cardinal);
        return NOTOK;
    }

    return OK;
}

/* ARGSUSED */

int	parse_AF_CrlSet (pe, explicit, len, buffer, parm)
register PE	pe;
int	explicit;
int    *len;
char  **buffer;
CrlSet ** parm;
{
    register PE p186;

#ifdef DEBUG
    (void) testdebug (pe, "AF.CrlSet");
#endif

    if (explicit) {
        if (pe -> pe_class != PE_CLASS_UNIV
                || pe -> pe_form != PE_FORM_CONS
                || pe -> pe_id != PE_CONS_SET) {
            advise (NULLCP, "CrlSet bad class/form/id: %s/%d/0x%x",
                    pe_classlist[pe -> pe_class], pe -> pe_form, pe -> pe_id);
            return NOTOK;
        }
    }
    else
        if (pe -> pe_form != PE_FORM_CONS) {
            advise (NULLCP, "CrlSet bad form: %d", pe -> pe_form);
            return NOTOK;
        }

    if ((p186 = prim2set (pe)) == NULLPE) {
        advise (NULLCP, "CrlSet %s%s", PEPY_ERR_BAD_SET,
                pe_error (pe -> pe_errno));
        return NOTOK;
    }
    pe = p186;

    for (p186 = first_member (pe); p186; p186 = next_member (pe, p186)) {
        {

                if ((*(parm) = (CrlSet *)
                        calloc (1, sizeof **(parm))) == ((CrlSet *) 0)) {
                    advise (NULLCP, "out of memory");
                    return NOTOK;
                }
            
        }
        {
#ifdef DEBUG
            (void) testdebug (p186, "member");
#endif

            if (parse_AF_CrlPSE (p186, 1, NULLIP, NULLVP, &((*parm) -> element)) == NOTOK)
                return NOTOK;
            {
 parm = &((*parm) -> next); 
            }
        }
    }

    return OK;
}

/* ARGSUSED */

int	parse_AF_OldCertificateList (pe, explicit, len, buffer, parm)
register PE	pe;
int	explicit;
int    *len;
char  **buffer;
OCList ** parm;
{
    register PE p187;

#ifdef DEBUG
    (void) testdebug (pe, "AF.OldCertificateList");
#endif

    if (explicit) {
        if (pe -> pe_class != PE_CLASS_UNIV
                || pe -> pe_form != PE_FORM_CONS
                || pe -> pe_id != PE_CONS_SEQ) {
            advise (NULLCP, "OldCertificateList bad class/form/id: %s/%d/0x%x",
                    pe_classlist[pe -> pe_class], pe -> pe_form, pe -> pe_id);
            return NOTOK;
        }
    }
    else
        if (pe -> pe_form != PE_FORM_CONS) {
            advise (NULLCP, "OldCertificateList bad form: %d", pe -> pe_form);
            return NOTOK;
        }

    if ((p187 = prim2seq (pe)) == NULLPE) {
        advise (NULLCP, "OldCertificateList %s%s", PEPY_ERR_BAD_SEQ,
                pe_error (pe -> pe_errno));
        return NOTOK;
    }
    pe = p187;

    for (p187 = first_member (pe); p187; p187 = next_member (pe, p187)) {
        {

		if ((*(parm) = (OCList *)
			calloc (1, sizeof **(parm))) == (OCList *) 0) {
                    advise (NULLCP, "out of memory");
                    return NOTOK;
                }
		(*parm) -> next = (OCList *)0;
            
        }
        {
            register PE p188;

#ifdef DEBUG
            (void) testdebug (p187, "element");
#endif

            if (p187 -> pe_class != PE_CLASS_UNIV
                    || p187 -> pe_form != PE_FORM_CONS
                    || p187 -> pe_id != PE_CONS_SEQ) {
                advise (NULLCP, "element bad class/form/id: %s/%d/0x%x",
                        pe_classlist[p187 -> pe_class], p187 -> pe_form, p187 -> pe_id);
                return NOTOK;
            }

            if ((p188 = prim2seq (p187)) == NULLPE) {
                advise (NULLCP, "element %s%s", PEPY_ERR_BAD_SEQ,
                        pe_error (p187 -> pe_errno));
                return NOTOK;
            }
            p187 = p188;

            {
                register PE p189;

                if ((p189 = first_member (p187)) != NULLPE) {
                    p188 = p189;

                    {	/* serialNumber */
                        register integer p190;

#ifdef DEBUG
                        (void) testdebug (p189, "serialNumber");
#endif

                        if (p189 -> pe_class != PE_CLASS_UNIV
                                || p189 -> pe_form != PE_FORM_PRIM
                                || p189 -> pe_id != PE_PRIM_INT) {
                            advise (NULLCP, "serialNumber bad class/form/id: %s/%d/0x%x",
                                    pe_classlist[p189 -> pe_class], p189 -> pe_form, p189 -> pe_id);
                            return NOTOK;
                        }

                        if ((p190 = prim2num (p189)) == NOTOK
                                && p189 -> pe_errno != PE_ERR_NONE) {
                            advise (NULLCP, "serialNumber %s%s", PEPY_ERR_BAD_INTEGER,
                                    pe_error (p189 -> pe_errno));
                            return NOTOK;
                        }
                        (*parm) -> serialnumber  = p190;
                    }
                }
                else {
                    advise (NULLCP, "element %sserialNumber element", PEPY_ERR_MISSING);
                    return NOTOK;
                }

            }

            {
                register PE p191;

                if ((p191 = (p187 != p188 ? next_member (p187, p188) : first_member (p187))) != NULLPE) {
                    p188 = p191;

                    {	/* crossCertificate */
#ifdef DEBUG
                        (void) testdebug (p191, "crossCertificate");
#endif

                        if (parse_AF_Certificate (p191, 1, NULLIP, NULLVP, &((*parm) -> ccert) ) == NOTOK)
                            return NOTOK;
                    }
                }
                else {
                    advise (NULLCP, "element %scrossCertificate element", PEPY_ERR_MISSING);
                    return NOTOK;
                }

            }


            if (p187 -> pe_cardinal > 2) {
                advise (NULLCP, "element %s(2): %d", PEPY_ERR_TOO_MANY_ELEMENTS,
                        p187 -> pe_cardinal);
                return NOTOK;
            }
            {
 parm = &((*parm) -> next); 
            }
        }
    }

    return OK;
}

/* ARGSUSED */

int	parse_AF_PemCrlWithCerts (pe, explicit, len, buffer, parm)
register PE	pe;
int	explicit;
int    *len;
char  **buffer;
PemCrlWithCerts ** parm;
{
    register PE p192;

#ifdef DEBUG
    (void) testdebug (pe, "AF.PemCrlWithCerts");
#endif

    if (explicit) {
        if (pe -> pe_class != PE_CLASS_UNIV
                || pe -> pe_form != PE_FORM_CONS
                || pe -> pe_id != PE_CONS_SEQ) {
            advise (NULLCP, "PemCrlWithCerts bad class/form/id: %s/%d/0x%x",
                    pe_classlist[pe -> pe_class], pe -> pe_form, pe -> pe_id);
            return NOTOK;
        }
    }
    else
        if (pe -> pe_form != PE_FORM_CONS) {
            advise (NULLCP, "PemCrlWithCerts bad form: %d", pe -> pe_form);
            return NOTOK;
        }

    {

        if ((*(parm) = (PemCrlWithCerts *)
                calloc (1, sizeof **(parm))) == ((PemCrlWithCerts *) 0)) {
            advise (NULLCP, "out of memory");
            return NOTOK;
        }
	(*parm)->certificates = (Certificates * )0;
    
    }
    if ((p192 = prim2seq (pe)) == NULLPE) {
        advise (NULLCP, "PemCrlWithCerts %s%s", PEPY_ERR_BAD_SEQ,
                pe_error (pe -> pe_errno));
        return NOTOK;
    }
    pe = p192;

    {
        register PE p193;

        if ((p193 = first_member (pe)) != NULLPE) {
            p192 = p193;

            {	/* pemCRL */
#ifdef DEBUG
                (void) testdebug (p193, "pemCRL");
#endif

                if (parse_AF_PemCrl (p193, 1, NULLIP, NULLVP, &((*parm) -> pemcrl)) == NOTOK)
                    return NOTOK;
            }
        }
        else {
            advise (NULLCP, "PemCrlWithCerts %spemCRL element", PEPY_ERR_MISSING);
            return NOTOK;
        }

    }

    {
        register PE p194;

        if ((p194 = (pe != p192 ? next_member (pe, p192) : first_member (pe))) != NULLPE) {
            p192 = p194;

            {	/* certificates */
#ifdef DEBUG
                (void) testdebug (p194, "certificates");
#endif

                if (parse_AF_Certificates (p194, 1, NULLIP, NULLVP, &((*parm) -> certificates)) == NOTOK)
                    return NOTOK;
            }
        }
    }


    if (pe -> pe_cardinal > 2) {
        advise (NULLCP, "PemCrlWithCerts %s(2): %d", PEPY_ERR_TOO_MANY_ELEMENTS,
                pe -> pe_cardinal);
        return NOTOK;
    }

    return OK;
}

/* ARGSUSED */

int	parse_AF_AliasesMember (pe, explicit, len, buffer, parm)
register PE	pe;
int	explicit;
int    *len;
char  **buffer;
Aliases * parm;
{
    register PE p195;

#ifdef DEBUG
    (void) testdebug (pe, "AF.AliasesMember");
#endif

    if (explicit) {
        if (pe -> pe_class != PE_CLASS_UNIV
                || pe -> pe_form != PE_FORM_CONS
                || pe -> pe_id != PE_CONS_SEQ) {
            advise (NULLCP, "AliasesMember bad class/form/id: %s/%d/0x%x",
                    pe_classlist[pe -> pe_class], pe -> pe_form, pe -> pe_id);
            return NOTOK;
        }
    }
    else
        if (pe -> pe_form != PE_FORM_CONS) {
            advise (NULLCP, "AliasesMember bad form: %d", pe -> pe_form);
            return NOTOK;
        }

    if ((p195 = prim2seq (pe)) == NULLPE) {
        advise (NULLCP, "AliasesMember %s%s", PEPY_ERR_BAD_SEQ,
                pe_error (pe -> pe_errno));
        return NOTOK;
    }
    pe = p195;

    {
        register PE p196;

        if ((p196 = first_member (pe)) != NULLPE) {
            p195 = p196;

            {	/* aname */
#ifdef DEBUG
                (void) testdebug (p196, "aname");
#endif

                if (parse_UNIV_IA5String (p196, 1, NULLIP, &(parm->aname), NullParm) == NOTOK)
                    return NOTOK;
            }
        }
        else {
            advise (NULLCP, "AliasesMember %saname element", PEPY_ERR_MISSING);
            return NOTOK;
        }

    }

    {
        register PE p197;

        if ((p197 = (pe != p195 ? next_member (pe, p195) : first_member (pe))) != NULLPE) {
            p195 = p197;

            {	/* aliasfile */
                register integer p198;

#ifdef DEBUG
                (void) testdebug (p197, "aliasfile");
#endif

                if (p197 -> pe_class != PE_CLASS_UNIV
                        || p197 -> pe_form != PE_FORM_PRIM
                        || p197 -> pe_id != PE_PRIM_ENUM) {
                    advise (NULLCP, "aliasfile bad class/form/id: %s/%d/0x%x",
                            pe_classlist[p197 -> pe_class], p197 -> pe_form, p197 -> pe_id);
                    return NOTOK;
                }

                if ((p198 = prim2enum (p197)) == NOTOK
                        && p197 -> pe_errno != PE_ERR_NONE) {
                    advise (NULLCP, "aliasfile %s%s", PEPY_ERR_BAD_INTEGER,
                            pe_error (p197 -> pe_errno));
                    return NOTOK;
                }
                parm->aliasfile = p198;
                switch (p198) {
                    case 0:	/* useralias */
                        break;
                    case 1:	/* systemalias */
                        break;
                    default:
                        advise (NULLCP, "aliasfile %s%d", PEPY_ERR_UNK_COMP, p198);
                        return NOTOK;
                }
            }
        }
        else {
            advise (NULLCP, "AliasesMember %saliasfile element", PEPY_ERR_MISSING);
            return NOTOK;
        }

    }


    if (pe -> pe_cardinal > 2) {
        advise (NULLCP, "AliasesMember %s(2): %d", PEPY_ERR_TOO_MANY_ELEMENTS,
                pe -> pe_cardinal);
        return NOTOK;
    }

    return OK;
}

/* ARGSUSED */

int	parse_AF_Aliases (pe, explicit, len, buffer, parm)
register PE	pe;
int	explicit;
int    *len;
char  **buffer;
Aliases ** parm;
{
    register PE p199;

#ifdef DEBUG
    (void) testdebug (pe, "AF.Aliases");
#endif

    if (explicit) {
        if (pe -> pe_class != PE_CLASS_UNIV
                || pe -> pe_form != PE_FORM_CONS
                || pe -> pe_id != PE_CONS_SEQ) {
            advise (NULLCP, "Aliases bad class/form/id: %s/%d/0x%x",
                    pe_classlist[pe -> pe_class], pe -> pe_form, pe -> pe_id);
            return NOTOK;
        }
    }
    else
        if (pe -> pe_form != PE_FORM_CONS) {
            advise (NULLCP, "Aliases bad form: %d", pe -> pe_form);
            return NOTOK;
        }

    if ((p199 = prim2seq (pe)) == NULLPE) {
        advise (NULLCP, "Aliases %s%s", PEPY_ERR_BAD_SEQ,
                pe_error (pe -> pe_errno));
        return NOTOK;
    }
    pe = p199;

    for (p199 = first_member (pe); p199; p199 = next_member (pe, p199)) {
        {

                if ((*(parm) = (Aliases *)
                        calloc (1, sizeof **(parm))) == ((Aliases *) 0)) {
                    advise (NULLCP, "out of memory");
                    return NOTOK;
                }
            
        }
        {
#ifdef DEBUG
            (void) testdebug (p199, "element");
#endif

            if (parse_AF_AliasesMember (p199, 1, NULLIP, NULLVP, *parm) == NOTOK)
                return NOTOK;
            {
 parm = &((*parm) -> next); 
            }
        }
    }

    return OK;
}

/* ARGSUSED */

int	parse_AF_AliasListMember (pe, explicit, len, buffer, parm)
register PE	pe;
int	explicit;
int    *len;
char  **buffer;
AliasList * parm;
{
    register PE p200;

#ifdef DEBUG
    (void) testdebug (pe, "AF.AliasListMember");
#endif

    if (explicit) {
        if (pe -> pe_class != PE_CLASS_UNIV
                || pe -> pe_form != PE_FORM_CONS
                || pe -> pe_id != PE_CONS_SEQ) {
            advise (NULLCP, "AliasListMember bad class/form/id: %s/%d/0x%x",
                    pe_classlist[pe -> pe_class], pe -> pe_form, pe -> pe_id);
            return NOTOK;
        }
    }
    else
        if (pe -> pe_form != PE_FORM_CONS) {
            advise (NULLCP, "AliasListMember bad form: %d", pe -> pe_form);
            return NOTOK;
        }

    if ((p200 = prim2seq (pe)) == NULLPE) {
        advise (NULLCP, "AliasListMember %s%s", PEPY_ERR_BAD_SEQ,
                pe_error (pe -> pe_errno));
        return NOTOK;
    }
    pe = p200;

    {
        register PE p201;

        if ((p201 = first_member (pe)) != NULLPE) {
            p200 = p201;

            {	/* aliases */
#ifdef DEBUG
                (void) testdebug (p201, "aliases");
#endif

                if (parse_AF_Aliases (p201, 1, NULLIP, NULLVP, &(parm->a)) == NOTOK)
                    return NOTOK;
            }
        }
        else {
            advise (NULLCP, "AliasListMember %saliases element", PEPY_ERR_MISSING);
            return NOTOK;
        }

    }

    {
        register PE p202;

        if ((p202 = (pe != p200 ? next_member (pe, p200) : first_member (pe))) != NULLPE) {
            p200 = p202;

            {	/* dname */
#ifdef DEBUG
                (void) testdebug (p202, "dname");
#endif

                if (parse_UNIV_IA5String (p202, 1, NULLIP, &(parm->dname), NullParm) == NOTOK)
                    return NOTOK;
            }
        }
        else {
            advise (NULLCP, "AliasListMember %sdname element", PEPY_ERR_MISSING);
            return NOTOK;
        }

    }


    if (pe -> pe_cardinal > 2) {
        advise (NULLCP, "AliasListMember %s(2): %d", PEPY_ERR_TOO_MANY_ELEMENTS,
                pe -> pe_cardinal);
        return NOTOK;
    }

    return OK;
}

/* ARGSUSED */

int	parse_AF_AliasList (pe, explicit, len, buffer, parm)
register PE	pe;
int	explicit;
int    *len;
char  **buffer;
AliasList ** parm;
{
    register PE p203;

#ifdef DEBUG
    (void) testdebug (pe, "AF.AliasList");
#endif

    if (explicit) {
        if (pe -> pe_class != PE_CLASS_UNIV
                || pe -> pe_form != PE_FORM_CONS
                || pe -> pe_id != PE_CONS_SEQ) {
            advise (NULLCP, "AliasList bad class/form/id: %s/%d/0x%x",
                    pe_classlist[pe -> pe_class], pe -> pe_form, pe -> pe_id);
            return NOTOK;
        }
    }
    else
        if (pe -> pe_form != PE_FORM_CONS) {
            advise (NULLCP, "AliasList bad form: %d", pe -> pe_form);
            return NOTOK;
        }

    if ((p203 = prim2seq (pe)) == NULLPE) {
        advise (NULLCP, "AliasList %s%s", PEPY_ERR_BAD_SEQ,
                pe_error (pe -> pe_errno));
        return NOTOK;
    }
    pe = p203;

    for (p203 = first_member (pe); p203; p203 = next_member (pe, p203)) {
        {

                if ((*(parm) = (AliasList *)
                        calloc (1, sizeof **(parm))) == ((AliasList *) 0)) {
                    advise (NULLCP, "out of memory");
                    return NOTOK;
                }
            
        }
        {
#ifdef DEBUG
            (void) testdebug (p203, "element");
#endif

            if (parse_AF_AliasListMember (p203, 1, NULLIP, NULLVP, *parm) == NOTOK)
                return NOTOK;
            {
 parm = &((*parm) -> next); 
            }
        }
    }

    return OK;
}


#else


/* automatically generated by pepy 8.0 #11 (tiber), do not edit! */

#include "psap.h"

#ifndef lint
static char *pepyid = "pepy 8.0 #11 (tiber) of Tue Jun  1 11:43:07 MET DST 1993";
#endif

#ifdef MAC
void	advise (...);
#else
void    advise();
#endif

/* Generated from module AF */
# line 13 "AF.py.COSINE"
	/* surrounding global definitions	*/
#include        "af.h"

static PE            build_revlist_tbs(), build_revcert_tbs(), build_tbs();
static PE 	     build_pemcrl_tbs();
PE                   aux_OctetString2PE();
struct type_IF_Name *aux_Name2DName();
char                *aux_DName2Name();
OctetString         *aux_PE2OctetString();

#ifndef PEPYPARM
#define PEPYPARM char *
#endif /* PEPYPARM */
extern PEPYPARM NullParm;

/* ARGSUSED */

int	build_AF_Validity (pe, explicit, len, buffer, parm)
register PE     *pe;
int	explicit;
int	len;
char   *buffer;
ToBeSigned *  parm;
{
    PE	p0_z = NULLPE;
    register PE *p0 = &p0_z;

    if (((*pe) = pe_alloc (PE_CLASS_UNIV, PE_FORM_CONS, PE_CONS_SEQ)) == NULLPE) {
        advise (NULLCP, "Validity: %s", PEPY_ERR_NOMEM);
        return NOTOK;
    }
    (*p0) = NULLPE;

    {	/* notBefore */
        if (build_UNIV_UTCTime (p0, 0, NULL, parm -> notbefore , NullParm) == NOTOK)
            return NOTOK;

#ifdef DEBUG
        (void) testdebug ((*p0), "notBefore");
#endif

    }

    if ((*p0) != NULLPE)
        if (seq_add ((*pe), (*p0), -1) == NOTOK) {
            advise (NULLCP, "Validity %s%s", PEPY_ERR_BAD_SEQ,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }
    (*p0) = NULLPE;

    {	/* notAfter */
        if (build_UNIV_UTCTime (p0, 0, NULL, parm -> notafter , NullParm) == NOTOK)
            return NOTOK;

#ifdef DEBUG
        (void) testdebug ((*p0), "notAfter");
#endif

    }

    if ((*p0) != NULLPE)
        if (seq_add ((*pe), (*p0), -1) == NOTOK) {
            advise (NULLCP, "Validity %s%s", PEPY_ERR_BAD_SEQ,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }

#ifdef DEBUG
    (void) testdebug ((*pe), "AF.Validity");
#endif


    return OK;
}

/* ARGSUSED */

int	parse_AF_Validity (pe, explicit, len, buffer, parm)
register PE	pe;
int	explicit;
int    *len;
char  **buffer;
ToBeSigned *  parm;
{
    register PE p1;

#ifdef DEBUG
    (void) testdebug (pe, "AF.Validity");
#endif

    if (explicit) {
        if (pe -> pe_class != PE_CLASS_UNIV
                || pe -> pe_form != PE_FORM_CONS
                || pe -> pe_id != PE_CONS_SEQ) {
            advise (NULLCP, "Validity bad class/form/id: %s/%d/0x%x",
                    pe_classlist[pe -> pe_class], pe -> pe_form, pe -> pe_id);
            return NOTOK;
        }
    }
    else
        if (pe -> pe_form != PE_FORM_CONS) {
            advise (NULLCP, "Validity bad form: %d", pe -> pe_form);
            return NOTOK;
        }

    if ((p1 = prim2seq (pe)) == NULLPE) {
        advise (NULLCP, "Validity %s%s", PEPY_ERR_BAD_SEQ,
                pe_error (pe -> pe_errno));
        return NOTOK;
    }
    pe = p1;

    {
        register PE p2;

        if ((p2 = first_member (pe)) != NULLPE) {
            p1 = p2;

            {	/* notBefore */
#ifdef DEBUG
                (void) testdebug (p2, "notBefore");
#endif

                if (parse_UNIV_UTCTime (p2, 1, NULLIP, &(parm -> notbefore ), NullParm) == NOTOK)
                    return NOTOK;
            }
        }
        else {
            advise (NULLCP, "Validity %snotBefore element", PEPY_ERR_MISSING);
            return NOTOK;
        }

    }

    {
        register PE p3;

        if ((p3 = (pe != p1 ? next_member (pe, p1) : first_member (pe))) != NULLPE) {
            p1 = p3;

            {	/* notAfter */
#ifdef DEBUG
                (void) testdebug (p3, "notAfter");
#endif

                if (parse_UNIV_UTCTime (p3, 1, NULLIP, &(parm -> notafter ), NullParm) == NOTOK)
                    return NOTOK;
            }
        }
        else {
            advise (NULLCP, "Validity %snotAfter element", PEPY_ERR_MISSING);
            return NOTOK;
        }

    }


    if (pe -> pe_cardinal > 2) {
        advise (NULLCP, "Validity %s(2): %d", PEPY_ERR_TOO_MANY_ELEMENTS,
                pe -> pe_cardinal);
        return NOTOK;
    }

    return OK;
}

/* ARGSUSED */

int	build_AF_PKRootValidity (pe, explicit, len, buffer, parm)
register PE     *pe;
int	explicit;
int	len;
char   *buffer;
Serial *  parm;
{
    PE	p4_z = NULLPE;
    register PE *p4 = &p4_z;

    if (((*pe) = pe_alloc (PE_CLASS_UNIV, PE_FORM_CONS, PE_CONS_SEQ)) == NULLPE) {
        advise (NULLCP, "PKRootValidity: %s", PEPY_ERR_NOMEM);
        return NOTOK;
    }
    (*p4) = NULLPE;

    {	/* notBefore */
        if (build_UNIV_UTCTime (p4, 0, NULL, parm -> notbefore , NullParm) == NOTOK)
            return NOTOK;

#ifdef DEBUG
        (void) testdebug ((*p4), "notBefore");
#endif

    }

    if ((*p4) != NULLPE)
        if (seq_add ((*pe), (*p4), -1) == NOTOK) {
            advise (NULLCP, "PKRootValidity %s%s", PEPY_ERR_BAD_SEQ,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }
    (*p4) = NULLPE;

    {	/* notAfter */
        if (build_UNIV_UTCTime (p4, 0, NULL, parm -> notafter , NullParm) == NOTOK)
            return NOTOK;

#ifdef DEBUG
        (void) testdebug ((*p4), "notAfter");
#endif

    }

    if ((*p4) != NULLPE)
        if (seq_add ((*pe), (*p4), -1) == NOTOK) {
            advise (NULLCP, "PKRootValidity %s%s", PEPY_ERR_BAD_SEQ,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }

#ifdef DEBUG
    (void) testdebug ((*pe), "AF.PKRootValidity");
#endif


    return OK;
}

/* ARGSUSED */

int	parse_AF_PKRootValidity (pe, explicit, len, buffer, parm)
register PE	pe;
int	explicit;
int    *len;
char  **buffer;
Serial *  parm;
{
    register PE p5;

#ifdef DEBUG
    (void) testdebug (pe, "AF.PKRootValidity");
#endif

    if (explicit) {
        if (pe -> pe_class != PE_CLASS_UNIV
                || pe -> pe_form != PE_FORM_CONS
                || pe -> pe_id != PE_CONS_SEQ) {
            advise (NULLCP, "PKRootValidity bad class/form/id: %s/%d/0x%x",
                    pe_classlist[pe -> pe_class], pe -> pe_form, pe -> pe_id);
            return NOTOK;
        }
    }
    else
        if (pe -> pe_form != PE_FORM_CONS) {
            advise (NULLCP, "PKRootValidity bad form: %d", pe -> pe_form);
            return NOTOK;
        }

    if ((p5 = prim2seq (pe)) == NULLPE) {
        advise (NULLCP, "PKRootValidity %s%s", PEPY_ERR_BAD_SEQ,
                pe_error (pe -> pe_errno));
        return NOTOK;
    }
    pe = p5;

    {
        register PE p6;

        if ((p6 = first_member (pe)) != NULLPE) {
            p5 = p6;

            {	/* notBefore */
#ifdef DEBUG
                (void) testdebug (p6, "notBefore");
#endif

                if (parse_UNIV_UTCTime (p6, 1, NULLIP, &(parm -> notbefore ), NullParm) == NOTOK)
                    return NOTOK;
            }
        }
        else {
            advise (NULLCP, "PKRootValidity %snotBefore element", PEPY_ERR_MISSING);
            return NOTOK;
        }

    }

    {
        register PE p7;

        if ((p7 = (pe != p5 ? next_member (pe, p5) : first_member (pe))) != NULLPE) {
            p5 = p7;

            {	/* notAfter */
#ifdef DEBUG
                (void) testdebug (p7, "notAfter");
#endif

                if (parse_UNIV_UTCTime (p7, 1, NULLIP, &(parm -> notafter ), NullParm) == NOTOK)
                    return NOTOK;
            }
        }
        else {
            advise (NULLCP, "PKRootValidity %snotAfter element", PEPY_ERR_MISSING);
            return NOTOK;
        }

    }


    if (pe -> pe_cardinal > 2) {
        advise (NULLCP, "PKRootValidity %s(2): %d", PEPY_ERR_TOO_MANY_ELEMENTS,
                pe -> pe_cardinal);
        return NOTOK;
    }

    return OK;
}

/* ARGSUSED */

int	build_AF_SerialNumbers (pe, explicit, len, buffer, parm)
register PE     *pe;
int	explicit;
int	len;
char   *buffer;
SerialNumbers * parm;
{
    PE	p8_z = NULLPE;
    register PE *p8 = &p8_z;

    if (((*pe) = pe_alloc (PE_CLASS_UNIV, PE_FORM_CONS, PE_CONS_SEQ)) == NULLPE) {
        advise (NULLCP, "SerialNumbers: %s", PEPY_ERR_NOMEM);
        return NOTOK;
    }
    (*p8) = NULLPE;

    if (parm->initial != 0) {
        register integer p9 = parm->initial ;

        if (((*p8) = num2prim (p9, PE_CLASS_UNIV, PE_PRIM_INT)) == NULLPE) {
            advise (NULLCP, "element: %s", PEPY_ERR_NOMEM);
            return NOTOK;
        }
        {	/* element TAG PUSHDOWN */
            PE p10_z;
            register PE *p10 = &p10_z;

            if ((*p10 = pe_alloc (PE_CLASS_CONT, PE_FORM_CONS, 0)) == NULLPE) {
                advise (NULLCP, "element: %s", PEPY_ERR_NOMEM);
                return NOTOK;
            }
            (*p10) -> pe_cons = (*p8);
            (*p8) = *p10;
        }

#ifdef DEBUG
        (void) testdebug ((*p8), "element");
#endif

    }

    if ((*p8) != NULLPE)
        if (seq_add ((*pe), (*p8), -1) == NOTOK) {
            advise (NULLCP, "SerialNumbers %s%s", PEPY_ERR_BAD_SEQ,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }
    (*p8) = NULLPE;

    {
        register integer p11 = parm->actual ;

        if (((*p8) = num2prim (p11, PE_CLASS_UNIV, PE_PRIM_INT)) == NULLPE) {
            advise (NULLCP, "element: %s", PEPY_ERR_NOMEM);
            return NOTOK;
        }
        {	/* element TAG PUSHDOWN */
            PE p12_z;
            register PE *p12 = &p12_z;

            if ((*p12 = pe_alloc (PE_CLASS_CONT, PE_FORM_CONS, 1)) == NULLPE) {
                advise (NULLCP, "element: %s", PEPY_ERR_NOMEM);
                return NOTOK;
            }
            (*p12) -> pe_cons = (*p8);
            (*p8) = *p12;
        }

#ifdef DEBUG
        (void) testdebug ((*p8), "element");
#endif

    }

    if ((*p8) != NULLPE)
        if (seq_add ((*pe), (*p8), -1) == NOTOK) {
            advise (NULLCP, "SerialNumbers %s%s", PEPY_ERR_BAD_SEQ,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }

#ifdef DEBUG
    (void) testdebug ((*pe), "AF.SerialNumbers");
#endif


    return OK;
}

/* ARGSUSED */

int	build_AF_PKRoot (pe, explicit, len, buffer, parm)
register PE     *pe;
int	explicit;
int	len;
char   *buffer;
PKRoot * parm;
{
    PE	p13_z = NULLPE;
    register PE *p13 = &p13_z;

    if (((*pe) = pe_alloc (PE_CLASS_UNIV, PE_FORM_CONS, PE_CONS_SEQ)) == NULLPE) {
        advise (NULLCP, "PKRoot: %s", PEPY_ERR_NOMEM);
        return NOTOK;
    }
    (*p13) = NULLPE;

    {	/* cA */
        if (build_IF_Name (p13, 0, NULL, NULLCP, parm -> ca ) == NOTOK)
            return NOTOK;

#ifdef DEBUG
        (void) testdebug ((*p13), "cA");
#endif

    }

    if ((*p13) != NULLPE)
        if (seq_add ((*pe), (*p13), -1) == NOTOK) {
            advise (NULLCP, "PKRoot %s%s", PEPY_ERR_BAD_SEQ,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }
    (*p13) = NULLPE;

    {	/* newkey */
        if (build_AF_RootKey (p13, 0, NULL, NULLCP, parm -> newkey ) == NOTOK)
            return NOTOK;

#ifdef DEBUG
        (void) testdebug ((*p13), "newkey");
#endif

    }

    if ((*p13) != NULLPE)
        if (seq_add ((*pe), (*p13), -1) == NOTOK) {
            advise (NULLCP, "PKRoot %s%s", PEPY_ERR_BAD_SEQ,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }
    (*p13) = NULLPE;

    if (parm -> oldkey) {	/* oldkey */
        if (build_AF_RootKey (p13, 0, NULL, NULLCP, parm -> oldkey ) == NOTOK)
            return NOTOK;

#ifdef DEBUG
        (void) testdebug ((*p13), "oldkey");
#endif

    }

    if ((*p13) != NULLPE)
        if (seq_add ((*pe), (*p13), -1) == NOTOK) {
            advise (NULLCP, "PKRoot %s%s", PEPY_ERR_BAD_SEQ,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }

#ifdef DEBUG
    (void) testdebug ((*pe), "AF.PKRoot");
#endif


    return OK;
}

/* ARGSUSED */

int	build_AF_RootKey (pe, explicit, len, buffer, parm)
register PE     *pe;
int	explicit;
int	len;
char   *buffer;
struct Serial * parm;
{
    PE	p14_z = NULLPE;
    register PE *p14 = &p14_z;

    if (((*pe) = pe_alloc (PE_CLASS_UNIV, PE_FORM_CONS, PE_CONS_SEQ)) == NULLPE) {
        advise (NULLCP, "RootKey: %s", PEPY_ERR_NOMEM);
        return NOTOK;
    }
    (*p14) = NULLPE;

    if (parm->version != 0) {	/* version */
        register integer p15 = parm->version ;

        if (((*p14) = num2prim (p15, PE_CLASS_UNIV, PE_PRIM_INT)) == NULLPE) {
            advise (NULLCP, "version: %s", PEPY_ERR_NOMEM);
            return NOTOK;
        }
        switch (p15) {
            case 0:	/* v1988 */
                break;
        }
        {	/* version TAG PUSHDOWN */
            PE p16_z;
            register PE *p16 = &p16_z;

            if ((*p16 = pe_alloc (PE_CLASS_CONT, PE_FORM_CONS, 0)) == NULLPE) {
                advise (NULLCP, "version: %s", PEPY_ERR_NOMEM);
                return NOTOK;
            }
            (*p16) -> pe_cons = (*p14);
            (*p14) = *p16;
        }

#ifdef DEBUG
        (void) testdebug ((*p14), "version");
#endif

    }

    if ((*p14) != NULLPE)
        if (seq_add ((*pe), (*p14), -1) == NOTOK) {
            advise (NULLCP, "RootKey %s%s", PEPY_ERR_BAD_SEQ,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }
    (*p14) = NULLPE;

    {	/* serial */
        register integer p17 = parm->serial ;

        if (((*p14) = num2prim (p17, PE_CLASS_UNIV, PE_PRIM_INT)) == NULLPE) {
            advise (NULLCP, "serial: %s", PEPY_ERR_NOMEM);
            return NOTOK;
        }

#ifdef DEBUG
        (void) testdebug ((*p14), "serial");
#endif

    }

    if ((*p14) != NULLPE)
        if (seq_add ((*pe), (*p14), -1) == NOTOK) {
            advise (NULLCP, "RootKey %s%s", PEPY_ERR_BAD_SEQ,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }
    (*p14) = NULLPE;

    {	/* key */
        if (build_SEC_KeyInfo (p14, 0, NULL, NULLCP, parm->key ) == NOTOK)
            return NOTOK;

#ifdef DEBUG
        (void) testdebug ((*p14), "key");
#endif

    }

    if ((*p14) != NULLPE)
        if (seq_add ((*pe), (*p14), -1) == NOTOK) {
            advise (NULLCP, "RootKey %s%s", PEPY_ERR_BAD_SEQ,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }
    (*p14) = NULLPE;

    if (parm->notbefore) {	/* validity */
        if (build_AF_PKRootValidity (p14, 0, NULL, NULLCP, parm ) == NOTOK)
            return NOTOK;
        {	/* validity TAG PUSHDOWN */
            PE p18_z;
            register PE *p18 = &p18_z;

            if ((*p18 = pe_alloc (PE_CLASS_CONT, PE_FORM_CONS, 1)) == NULLPE) {
                advise (NULLCP, "validity: %s", PEPY_ERR_NOMEM);
                return NOTOK;
            }
            (*p18) -> pe_cons = (*p14);
            (*p14) = *p18;
        }

#ifdef DEBUG
        (void) testdebug ((*p14), "validity");
#endif

    }

    if ((*p14) != NULLPE)
        if (seq_add ((*pe), (*p14), -1) == NOTOK) {
            advise (NULLCP, "RootKey %s%s", PEPY_ERR_BAD_SEQ,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }
    (*p14) = NULLPE;

    if (parm->sig) {	/* signAlgID */
        if (build_SEC_AlgorithmIdentifier (p14, 0, NULL, NULLCP, parm->sig->signAI ) == NOTOK)
            return NOTOK;
        {	/* signAlgID TAG PUSHDOWN */
            PE p19_z;
            register PE *p19 = &p19_z;

            if ((*p19 = pe_alloc (PE_CLASS_CONT, PE_FORM_CONS, 2)) == NULLPE) {
                advise (NULLCP, "signAlgID: %s", PEPY_ERR_NOMEM);
                return NOTOK;
            }
            (*p19) -> pe_cons = (*p14);
            (*p14) = *p19;
        }

#ifdef DEBUG
        (void) testdebug ((*p14), "signAlgID");
#endif

    }

    if ((*p14) != NULLPE)
        if (seq_add ((*pe), (*p14), -1) == NOTOK) {
            advise (NULLCP, "RootKey %s%s", PEPY_ERR_BAD_SEQ,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }
    (*p14) = NULLPE;

    if (parm -> sig) {	/* signBitString */
        PE	p20_z = NULLPE;
        register PE *p20 = &p20_z;

        char *p21;
        int p22;
        p21 = parm->sig->signature.bits ;
        p22 = 
		     parm->sig->signature.nbits ;
        (*p20) = p21 ? strb2bitstr (p21, p22, PE_CLASS_UNIV, PE_PRIM_BITS) : NULLPE;
        if ((*p20) == NULLPE) {
            advise (NULLCP, "signBitString %s", PEPY_ERR_INIT_FAILED);
            return NOTOK;
        }
        if (((*p14) = bit2prim ((*p20))) == NULLPE) {
            advise (NULLCP, "signBitString: %s", PEPY_ERR_NOMEM);
            return NOTOK;
        }

#ifdef DEBUG
        (void) testdebug ((*p14), "signBitString");
#endif

    }

    if ((*p14) != NULLPE)
        if (seq_add ((*pe), (*p14), -1) == NOTOK) {
            advise (NULLCP, "RootKey %s%s", PEPY_ERR_BAD_SEQ,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }

#ifdef DEBUG
    (void) testdebug ((*pe), "AF.RootKey");
#endif


    return OK;
}

/* ARGSUSED */

int	build_AF_TBSCertificate (pe, explicit, len, buffer, parm)
register PE     *pe;
int	explicit;
int	len;
char   *buffer;
ToBeSigned * parm;
{
    PE	p23_z = NULLPE;
    register PE *p23 = &p23_z;

    if (((*pe) = pe_alloc (PE_CLASS_UNIV, PE_FORM_CONS, PE_CONS_SEQ)) == NULLPE) {
        advise (NULLCP, "TBSCertificate: %s", PEPY_ERR_NOMEM);
        return NOTOK;
    }
    (*p23) = NULLPE;

    if (parm -> version != 0) {	/* version */
        register integer p24 = parm -> version ;

        if (((*p23) = num2prim (p24, PE_CLASS_UNIV, PE_PRIM_INT)) == NULLPE) {
            advise (NULLCP, "version: %s", PEPY_ERR_NOMEM);
            return NOTOK;
        }
        switch (p24) {
            case 0:	/* v1988 */
                break;
        }
        {	/* version TAG PUSHDOWN */
            PE p25_z;
            register PE *p25 = &p25_z;

            if ((*p25 = pe_alloc (PE_CLASS_CONT, PE_FORM_CONS, 0)) == NULLPE) {
                advise (NULLCP, "version: %s", PEPY_ERR_NOMEM);
                return NOTOK;
            }
            (*p25) -> pe_cons = (*p23);
            (*p23) = *p25;
        }

#ifdef DEBUG
        (void) testdebug ((*p23), "version");
#endif

    }

    if ((*p23) != NULLPE)
        if (seq_add ((*pe), (*p23), -1) == NOTOK) {
            advise (NULLCP, "TBSCertificate %s%s", PEPY_ERR_BAD_SEQ,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }
    (*p23) = NULLPE;

    {	/* serialNumber */
        register integer p26 = parm -> serialnumber ;

        if (((*p23) = num2prim (p26, PE_CLASS_UNIV, PE_PRIM_INT)) == NULLPE) {
            advise (NULLCP, "serialNumber: %s", PEPY_ERR_NOMEM);
            return NOTOK;
        }

#ifdef DEBUG
        (void) testdebug ((*p23), "serialNumber");
#endif

    }

    if ((*p23) != NULLPE)
        if (seq_add ((*pe), (*p23), -1) == NOTOK) {
            advise (NULLCP, "TBSCertificate %s%s", PEPY_ERR_BAD_SEQ,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }
    (*p23) = NULLPE;

    {	/* signature */
        if (build_SEC_AlgorithmIdentifier (p23, 0, NULL, NULLCP, parm -> signatureAI ) == NOTOK)
            return NOTOK;

#ifdef DEBUG
        (void) testdebug ((*p23), "signature");
#endif

    }

    if ((*p23) != NULLPE)
        if (seq_add ((*pe), (*p23), -1) == NOTOK) {
            advise (NULLCP, "TBSCertificate %s%s", PEPY_ERR_BAD_SEQ,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }
    (*p23) = NULLPE;

    {	/* issuer */
        if (build_IF_Name (p23, 0, NULL, NULLCP, parm -> issuer ) == NOTOK)
            return NOTOK;

#ifdef DEBUG
        (void) testdebug ((*p23), "issuer");
#endif

    }

    if ((*p23) != NULLPE)
        if (seq_add ((*pe), (*p23), -1) == NOTOK) {
            advise (NULLCP, "TBSCertificate %s%s", PEPY_ERR_BAD_SEQ,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }
    (*p23) = NULLPE;

    {	/* validity */
        if (build_AF_Validity (p23, 0, NULL, NULLCP, parm ) == NOTOK)
            return NOTOK;

#ifdef DEBUG
        (void) testdebug ((*p23), "validity");
#endif

    }

    if ((*p23) != NULLPE)
        if (seq_add ((*pe), (*p23), -1) == NOTOK) {
            advise (NULLCP, "TBSCertificate %s%s", PEPY_ERR_BAD_SEQ,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }
    (*p23) = NULLPE;

    {	/* subject */
        if (build_IF_Name (p23, 0, NULL, NULLCP, parm -> subject ) == NOTOK)
            return NOTOK;

#ifdef DEBUG
        (void) testdebug ((*p23), "subject");
#endif

    }

    if ((*p23) != NULLPE)
        if (seq_add ((*pe), (*p23), -1) == NOTOK) {
            advise (NULLCP, "TBSCertificate %s%s", PEPY_ERR_BAD_SEQ,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }
    (*p23) = NULLPE;

    {	/* subjectPublickeyInfo */
        if (build_SEC_KeyInfo (p23, 0, NULL, NULLCP, parm -> subjectPK ) == NOTOK)
            return NOTOK;

#ifdef DEBUG
        (void) testdebug ((*p23), "subjectPublickeyInfo");
#endif

    }

    if ((*p23) != NULLPE)
        if (seq_add ((*pe), (*p23), -1) == NOTOK) {
            advise (NULLCP, "TBSCertificate %s%s", PEPY_ERR_BAD_SEQ,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }
    (*p23) = NULLPE;

    if (parm -> authatts) {	/* authatts */
        if (build_AF_AuthorisationAttributes (p23, 0, NULL, NULLCP, parm -> authatts ) == NOTOK)
            return NOTOK;

#ifdef DEBUG
        (void) testdebug ((*p23), "authatts");
#endif

    }

    if ((*p23) != NULLPE)
        if (seq_add ((*pe), (*p23), -1) == NOTOK) {
            advise (NULLCP, "TBSCertificate %s%s", PEPY_ERR_BAD_SEQ,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }

#ifdef DEBUG
    (void) testdebug ((*pe), "AF.TBSCertificate");
#endif


    return OK;
}

/* ARGSUSED */

int	build_AF_AuthorisationAttributes (pe, explicit, len, buffer, parm)
register PE     *pe;
int	explicit;
int	len;
char   *buffer;
AuthorisationAttributes * parm;
{
    PE	p27_z = NULLPE;
    register PE *p27 = &p27_z;

    if (((*pe) = pe_alloc (PE_CLASS_UNIV, PE_FORM_CONS, PE_CONS_SEQ)) == NULLPE) {
        advise (NULLCP, "AuthorisationAttributes: %s", PEPY_ERR_NOMEM);
        return NOTOK;
    }
    (*p27) = NULLPE;

    {	/* country */
        if (build_UNIV_PrintableString (p27, 0, NULL, parm -> country, NullParm) == NOTOK)
            return NOTOK;

#ifdef DEBUG
        (void) testdebug ((*p27), "country");
#endif

    }

    if ((*p27) != NULLPE)
        if (seq_add ((*pe), (*p27), -1) == NOTOK) {
            advise (NULLCP, "AuthorisationAttributes %s%s", PEPY_ERR_BAD_SEQ,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }
    (*p27) = NULLPE;

    {	/* group */
        if (build_UNIV_PrintableString (p27, 0, NULL, parm -> group, NullParm) == NOTOK)
            return NOTOK;

#ifdef DEBUG
        (void) testdebug ((*p27), "group");
#endif

    }

    if ((*p27) != NULLPE)
        if (seq_add ((*pe), (*p27), -1) == NOTOK) {
            advise (NULLCP, "AuthorisationAttributes %s%s", PEPY_ERR_BAD_SEQ,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }
    (*p27) = NULLPE;

    {	/* class */
        register integer p28 = parm -> class;

        if (((*p27) = num2prim (p28, PE_CLASS_UNIV, PE_PRIM_INT)) == NULLPE) {
            advise (NULLCP, "class: %s", PEPY_ERR_NOMEM);
            return NOTOK;
        }
        switch (p28) {
            case 0:	/* normal */
                break;
            case 1:	/* privileged */
                break;
        }

#ifdef DEBUG
        (void) testdebug ((*p27), "class");
#endif

    }

    if ((*p27) != NULLPE)
        if (seq_add ((*pe), (*p27), -1) == NOTOK) {
            advise (NULLCP, "AuthorisationAttributes %s%s", PEPY_ERR_BAD_SEQ,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }

#ifdef DEBUG
    (void) testdebug ((*pe), "AF.AuthorisationAttributes");
#endif


    return OK;
}

/* ARGSUSED */

int	build_AF_Certificate (pe, explicit, len, buffer, parm)
register PE     *pe;
int	explicit;
int	len;
char   *buffer;
Certificate * parm;
{
# line 199 "AF.py.COSINE"
    	PE	tbs;

    PE	p29_z = NULLPE;
    register PE *p29 = &p29_z;

    if (((*pe) = pe_alloc (PE_CLASS_UNIV, PE_FORM_CONS, PE_CONS_SEQ)) == NULLPE) {
        advise (NULLCP, "Certificate: %s", PEPY_ERR_NOMEM);
        return NOTOK;
    }
    (*p29) = NULLPE;

    {
        PE	p30 = (build_tbs(parm,&tbs)) ;

        if (p30 == NULLPE) {
            advise (NULLCP, "element %s", PEPY_ERR_INIT_FAILED);
            return NOTOK;
        }
        ((*p29) = p30) -> pe_refcnt++;

#ifdef DEBUG
        (void) testdebug ((*p29), "element");
#endif

        {
# line 205 "AF.py.COSINE"
    pe_free(tbs);
		
        }
    }

    if ((*p29) != NULLPE)
        if (seq_add ((*pe), (*p29), -1) == NOTOK) {
            advise (NULLCP, "Certificate %s%s", PEPY_ERR_BAD_SEQ,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }
    (*p29) = NULLPE;

    {
        if (build_SEC_AlgorithmIdentifier (p29, 0, NULL, NULLCP, parm -> sig ->signAI ) == NOTOK)
            return NOTOK;

#ifdef DEBUG
        (void) testdebug ((*p29), "element");
#endif

    }

    if ((*p29) != NULLPE)
        if (seq_add ((*pe), (*p29), -1) == NOTOK) {
            advise (NULLCP, "Certificate %s%s", PEPY_ERR_BAD_SEQ,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }
    (*p29) = NULLPE;

    {
        PE	p31_z = NULLPE;
        register PE *p31 = &p31_z;

        char *p32;
        int p33;
        p32 = parm->sig->signature.bits ;
        p33 = 
		     parm->sig->signature.nbits ;
        (*p31) = p32 ? strb2bitstr (p32, p33, PE_CLASS_UNIV, PE_PRIM_BITS) : NULLPE;
        if ((*p31) == NULLPE) {
            advise (NULLCP, "element %s", PEPY_ERR_INIT_FAILED);
            return NOTOK;
        }
        if (((*p29) = bit2prim ((*p31))) == NULLPE) {
            advise (NULLCP, "element: %s", PEPY_ERR_NOMEM);
            return NOTOK;
        }

#ifdef DEBUG
        (void) testdebug ((*p29), "element");
#endif

    }

    if ((*p29) != NULLPE)
        if (seq_add ((*pe), (*p29), -1) == NOTOK) {
            advise (NULLCP, "Certificate %s%s", PEPY_ERR_BAD_SEQ,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }

#ifdef DEBUG
    (void) testdebug ((*pe), "AF.Certificate");
#endif


    return OK;
}

/* ARGSUSED */

int	build_AF_Certificates (pe, explicit, len, buffer, parm)
register PE     *pe;
int	explicit;
int	len;
char   *buffer;
Certificates * parm;
{
    PE	p34_z = NULLPE;
    register PE *p34 = &p34_z;

    if (((*pe) = pe_alloc (PE_CLASS_UNIV, PE_FORM_CONS, PE_CONS_SEQ)) == NULLPE) {
        advise (NULLCP, "Certificates: %s", PEPY_ERR_NOMEM);
        return NOTOK;
    }
    (*p34) = NULLPE;

    {	/* certificate */
        if (build_AF_Certificate (p34, 0, NULL, NULLCP, parm -> usercertificate ) == NOTOK)
            return NOTOK;

#ifdef DEBUG
        (void) testdebug ((*p34), "certificate");
#endif

    }

    if ((*p34) != NULLPE)
        if (seq_add ((*pe), (*p34), -1) == NOTOK) {
            advise (NULLCP, "Certificates %s%s", PEPY_ERR_BAD_SEQ,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }
    (*p34) = NULLPE;

    if (parm -> forwardpath) {	/* certificationPath */
        if (build_AF_ForwardCertificationPath (p34, 0, NULL, NULLCP, parm -> forwardpath ) == NOTOK)
            return NOTOK;

#ifdef DEBUG
        (void) testdebug ((*p34), "certificationPath");
#endif

    }

    if ((*p34) != NULLPE)
        if (seq_add ((*pe), (*p34), -1) == NOTOK) {
            advise (NULLCP, "Certificates %s%s", PEPY_ERR_BAD_SEQ,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }

#ifdef DEBUG
    (void) testdebug ((*pe), "AF.Certificates");
#endif


    return OK;
}

/* ARGSUSED */

int	build_AF_ForwardCertificationPath (pe, explicit, len, buffer, parm)
register PE     *pe;
int	explicit;
int	len;
char   *buffer;
FCPath * parm;
{
    PE	p35 = NULLPE;
    PE	p36_z = NULLPE;
    register PE *p36 = &p36_z;

    if (((*pe) = pe_alloc (PE_CLASS_UNIV, PE_FORM_CONS, PE_CONS_SEQ)) == NULLPE) {
        advise (NULLCP, "ForwardCertificationPath: %s", PEPY_ERR_NOMEM);
        return NOTOK;
    }
    for (; parm; parm = parm -> next_forwardpath) {
        if (build_AF_CertificateSet (p36, 0, NULL, NULLCP, parm -> liste ) == NOTOK)
            return NOTOK;

#ifdef DEBUG
        (void) testdebug ((*p36), "element");
#endif

        (void) seq_addon ((*pe), p35, (*p36));
        p35 = (*p36);
    }

#ifdef DEBUG
    (void) testdebug ((*pe), "AF.ForwardCertificationPath");
#endif


    return OK;
}

/* ARGSUSED */

int	build_AF_CertificateSet (pe, explicit, len, buffer, parm)
register PE     *pe;
int	explicit;
int	len;
char   *buffer;
SET_OF_Certificate * parm;
{
    PE	p37 = NULLPE;
    PE	p38_z = NULLPE;
    register PE *p38 = &p38_z;

    if (((*pe) = pe_alloc (PE_CLASS_UNIV, PE_FORM_CONS, PE_CONS_SET)) == NULLPE) {
        advise (NULLCP, "CertificateSet: %s", PEPY_ERR_NOMEM);
        return NOTOK;
    }
    for (; parm; parm = parm -> next) {
        if (build_AF_Certificate (p38, 0, NULL, NULLCP, parm -> element ) == NOTOK)
            return NOTOK;

#ifdef DEBUG
        (void) testdebug ((*p38), "member");
#endif

        (void) set_addon ((*pe), p37, (*p38));
        p37 = (*p38);
    }

#ifdef DEBUG
    (void) testdebug ((*pe), "AF.CertificateSet");
#endif


    return OK;
}

/* ARGSUSED */

int	build_AF_CertificatePair (pe, explicit, len, buffer, parm)
register PE     *pe;
int	explicit;
int	len;
char   *buffer;
CertificatePair * parm;
{
    PE	p39_z = NULLPE;
    register PE *p39 = &p39_z;

    if (((*pe) = pe_alloc (PE_CLASS_UNIV, PE_FORM_CONS, PE_CONS_SEQ)) == NULLPE) {
        advise (NULLCP, "CertificatePair: %s", PEPY_ERR_NOMEM);
        return NOTOK;
    }
    (*p39) = NULLPE;

    if (parm -> forward) {	/* forward */
        if (build_AF_Certificate (p39, 0, NULL, NULLCP, parm -> forward ) == NOTOK)
            return NOTOK;
        {	/* forward TAG PUSHDOWN */
            PE p40_z;
            register PE *p40 = &p40_z;

            if ((*p40 = pe_alloc (PE_CLASS_CONT, PE_FORM_CONS, 0)) == NULLPE) {
                advise (NULLCP, "forward: %s", PEPY_ERR_NOMEM);
                return NOTOK;
            }
            (*p40) -> pe_cons = (*p39);
            (*p39) = *p40;
        }

#ifdef DEBUG
        (void) testdebug ((*p39), "forward");
#endif

    }

    if ((*p39) != NULLPE)
        if (seq_add ((*pe), (*p39), -1) == NOTOK) {
            advise (NULLCP, "CertificatePair %s%s", PEPY_ERR_BAD_SEQ,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }
    (*p39) = NULLPE;

    if (parm -> reverse) {	/* reverse */
        if (build_AF_Certificate (p39, 0, NULL, NULLCP, parm -> reverse ) == NOTOK)
            return NOTOK;
        {	/* reverse TAG PUSHDOWN */
            PE p41_z;
            register PE *p41 = &p41_z;

            if ((*p41 = pe_alloc (PE_CLASS_CONT, PE_FORM_CONS, 1)) == NULLPE) {
                advise (NULLCP, "reverse: %s", PEPY_ERR_NOMEM);
                return NOTOK;
            }
            (*p41) -> pe_cons = (*p39);
            (*p39) = *p41;
        }

#ifdef DEBUG
        (void) testdebug ((*p39), "reverse");
#endif

    }

    if ((*p39) != NULLPE)
        if (seq_add ((*pe), (*p39), -1) == NOTOK) {
            advise (NULLCP, "CertificatePair %s%s", PEPY_ERR_BAD_SEQ,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }

#ifdef DEBUG
    (void) testdebug ((*pe), "AF.CertificatePair");
#endif


    return OK;
}

/* ARGSUSED */

int	build_AF_CrossCertificatePair (pe, explicit, len, buffer, parm)
register PE     *pe;
int	explicit;
int	len;
char   *buffer;
SET_OF_CertificatePair * parm;
{
    PE	p42 = NULLPE;
    PE	p43_z = NULLPE;
    register PE *p43 = &p43_z;

    if (((*pe) = pe_alloc (PE_CLASS_UNIV, PE_FORM_CONS, PE_CONS_SET)) == NULLPE) {
        advise (NULLCP, "CrossCertificatePair: %s", PEPY_ERR_NOMEM);
        return NOTOK;
    }
    for (; parm; parm = parm -> next) {
        if (build_AF_CertificatePair (p43, 0, NULL, NULLCP, parm -> element ) == NOTOK)
            return NOTOK;

#ifdef DEBUG
        (void) testdebug ((*p43), "member");
#endif

        (void) set_addon ((*pe), p42, (*p43));
        p42 = (*p43);
    }

#ifdef DEBUG
    (void) testdebug ((*pe), "AF.CrossCertificatePair");
#endif


    return OK;
}

/* ARGSUSED */

int	build_AF_PKList (pe, explicit, len, buffer, parm)
register PE     *pe;
int	explicit;
int	len;
char   *buffer;
PKList * parm;
{
    PE	p44 = NULLPE;
    PE	p45_z = NULLPE;
    register PE *p45 = &p45_z;

    if (((*pe) = pe_alloc (PE_CLASS_UNIV, PE_FORM_CONS, PE_CONS_SET)) == NULLPE) {
        advise (NULLCP, "PKList: %s", PEPY_ERR_NOMEM);
        return NOTOK;
    }
    for (; parm; parm = parm -> next) {
        if (build_AF_TBSCertificate (p45, 0, NULL, NULLCP, parm -> element ) == NOTOK)
            return NOTOK;

#ifdef DEBUG
        (void) testdebug ((*p45), "member");
#endif

        (void) set_addon ((*pe), p44, (*p45));
        p44 = (*p45);
    }

#ifdef DEBUG
    (void) testdebug ((*pe), "AF.PKList");
#endif


    return OK;
}

/* ARGSUSED */

int	build_AF_TBSCrl (pe, explicit, len, buffer, parm)
register PE     *pe;
int	explicit;
int	len;
char   *buffer;
CrlTBS * parm;
{
    PE	p46_z = NULLPE;
    register PE *p46 = &p46_z;

    if (((*pe) = pe_alloc (PE_CLASS_UNIV, PE_FORM_CONS, PE_CONS_SEQ)) == NULLPE) {
        advise (NULLCP, "TBSCrl: %s", PEPY_ERR_NOMEM);
        return NOTOK;
    }
    (*p46) = NULLPE;

    {	/* signature */
        if (build_SEC_AlgorithmIdentifier (p46, 0, NULL, NULLCP, parm->signatureAI ) == NOTOK)
            return NOTOK;

#ifdef DEBUG
        (void) testdebug ((*p46), "signature");
#endif

    }

    if ((*p46) != NULLPE)
        if (seq_add ((*pe), (*p46), -1) == NOTOK) {
            advise (NULLCP, "TBSCrl %s%s", PEPY_ERR_BAD_SEQ,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }
    (*p46) = NULLPE;

    {	/* issuer */
        if (build_IF_Name (p46, 0, NULL, NULLCP, parm->issuer ) == NOTOK)
            return NOTOK;

#ifdef DEBUG
        (void) testdebug ((*p46), "issuer");
#endif

    }

    if ((*p46) != NULLPE)
        if (seq_add ((*pe), (*p46), -1) == NOTOK) {
            advise (NULLCP, "TBSCrl %s%s", PEPY_ERR_BAD_SEQ,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }
    (*p46) = NULLPE;

    {	/* lastUpdate */
        if (build_UNIV_UTCTime (p46, 0, NULL, parm->lastupdate , NullParm) == NOTOK)
            return NOTOK;

#ifdef DEBUG
        (void) testdebug ((*p46), "lastUpdate");
#endif

    }

    if ((*p46) != NULLPE)
        if (seq_add ((*pe), (*p46), -1) == NOTOK) {
            advise (NULLCP, "TBSCrl %s%s", PEPY_ERR_BAD_SEQ,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }
    (*p46) = NULLPE;

    if (parm->revokedcertificates) {	/* revokedCertificates */
        if (build_AF_RevCertSequence (p46, 0, NULL, NULLCP, parm->revokedcertificates ) == NOTOK)
            return NOTOK;

#ifdef DEBUG
        (void) testdebug ((*p46), "revokedCertificates");
#endif

    }

    if ((*p46) != NULLPE)
        if (seq_add ((*pe), (*p46), -1) == NOTOK) {
            advise (NULLCP, "TBSCrl %s%s", PEPY_ERR_BAD_SEQ,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }

#ifdef DEBUG
    (void) testdebug ((*pe), "AF.TBSCrl");
#endif


    return OK;
}

/* ARGSUSED */

int	build_AF_Crl (pe, explicit, len, buffer, parm)
register PE     *pe;
int	explicit;
int	len;
char   *buffer;
Crl * parm;
{
# line 297 "AF.py.COSINE"
    
	PE tbs;
    
    PE	p47_z = NULLPE;
    register PE *p47 = &p47_z;

    if (((*pe) = pe_alloc (PE_CLASS_UNIV, PE_FORM_CONS, PE_CONS_SEQ)) == NULLPE) {
        advise (NULLCP, "Crl: %s", PEPY_ERR_NOMEM);
        return NOTOK;
    }
    (*p47) = NULLPE;

    {
        PE	p48 = (build_revlist_tbs(parm,&tbs)) ;

        if (p48 == NULLPE) {
            advise (NULLCP, "element %s", PEPY_ERR_INIT_FAILED);
            return NOTOK;
        }
        ((*p47) = p48) -> pe_refcnt++;

#ifdef DEBUG
        (void) testdebug ((*p47), "element");
#endif

        {
# line 305 "AF.py.COSINE"
   pe_free(tbs);
		
        }
    }

    if ((*p47) != NULLPE)
        if (seq_add ((*pe), (*p47), -1) == NOTOK) {
            advise (NULLCP, "Crl %s%s", PEPY_ERR_BAD_SEQ,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }
    (*p47) = NULLPE;

    {
        if (build_SEC_AlgorithmIdentifier (p47, 0, NULL, NULLCP, parm->sig->signAI ) == NOTOK)
            return NOTOK;

#ifdef DEBUG
        (void) testdebug ((*p47), "element");
#endif

    }

    if ((*p47) != NULLPE)
        if (seq_add ((*pe), (*p47), -1) == NOTOK) {
            advise (NULLCP, "Crl %s%s", PEPY_ERR_BAD_SEQ,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }
    (*p47) = NULLPE;

    {
        PE	p49_z = NULLPE;
        register PE *p49 = &p49_z;

        char *p50;
        int p51;
        p50 = parm->sig->signature.bits ;
        p51 = 
		     parm->sig->signature.nbits ;
        (*p49) = p50 ? strb2bitstr (p50, p51, PE_CLASS_UNIV, PE_PRIM_BITS) : NULLPE;
        if ((*p49) == NULLPE) {
            advise (NULLCP, "element %s", PEPY_ERR_INIT_FAILED);
            return NOTOK;
        }
        if (((*p47) = bit2prim ((*p49))) == NULLPE) {
            advise (NULLCP, "element: %s", PEPY_ERR_NOMEM);
            return NOTOK;
        }

#ifdef DEBUG
        (void) testdebug ((*p47), "element");
#endif

    }

    if ((*p47) != NULLPE)
        if (seq_add ((*pe), (*p47), -1) == NOTOK) {
            advise (NULLCP, "Crl %s%s", PEPY_ERR_BAD_SEQ,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }

#ifdef DEBUG
    (void) testdebug ((*pe), "AF.Crl");
#endif


    return OK;
}

/* ARGSUSED */

int	build_AF_TBSRevCert (pe, explicit, len, buffer, parm)
register PE     *pe;
int	explicit;
int	len;
char   *buffer;
RevCertTBS * parm;
{
    PE	p52_z = NULLPE;
    register PE *p52 = &p52_z;

    if (((*pe) = pe_alloc (PE_CLASS_UNIV, PE_FORM_CONS, PE_CONS_SEQ)) == NULLPE) {
        advise (NULLCP, "TBSRevCert: %s", PEPY_ERR_NOMEM);
        return NOTOK;
    }
    (*p52) = NULLPE;

    {	/* signature */
        if (build_SEC_AlgorithmIdentifier (p52, 0, NULL, NULLCP, parm->signatureAI ) == NOTOK)
            return NOTOK;

#ifdef DEBUG
        (void) testdebug ((*p52), "signature");
#endif

    }

    if ((*p52) != NULLPE)
        if (seq_add ((*pe), (*p52), -1) == NOTOK) {
            advise (NULLCP, "TBSRevCert %s%s", PEPY_ERR_BAD_SEQ,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }
    (*p52) = NULLPE;

    {	/* issuer */
        if (build_IF_Name (p52, 0, NULL, NULLCP, parm->issuer ) == NOTOK)
            return NOTOK;

#ifdef DEBUG
        (void) testdebug ((*p52), "issuer");
#endif

    }

    if ((*p52) != NULLPE)
        if (seq_add ((*pe), (*p52), -1) == NOTOK) {
            advise (NULLCP, "TBSRevCert %s%s", PEPY_ERR_BAD_SEQ,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }
    (*p52) = NULLPE;

    {	/* subject */
        register integer p53 = parm->subject ;

        if (((*p52) = num2prim (p53, PE_CLASS_UNIV, PE_PRIM_INT)) == NULLPE) {
            advise (NULLCP, "subject: %s", PEPY_ERR_NOMEM);
            return NOTOK;
        }

#ifdef DEBUG
        (void) testdebug ((*p52), "subject");
#endif

    }

    if ((*p52) != NULLPE)
        if (seq_add ((*pe), (*p52), -1) == NOTOK) {
            advise (NULLCP, "TBSRevCert %s%s", PEPY_ERR_BAD_SEQ,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }
    (*p52) = NULLPE;

    {	/* revocationDate */
        if (build_UNIV_UTCTime (p52, 0, NULL, parm->revocationdate , NullParm) == NOTOK)
            return NOTOK;

#ifdef DEBUG
        (void) testdebug ((*p52), "revocationDate");
#endif

    }

    if ((*p52) != NULLPE)
        if (seq_add ((*pe), (*p52), -1) == NOTOK) {
            advise (NULLCP, "TBSRevCert %s%s", PEPY_ERR_BAD_SEQ,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }

#ifdef DEBUG
    (void) testdebug ((*pe), "AF.TBSRevCert");
#endif


    return OK;
}

/* ARGSUSED */

int	build_AF_RevCert (pe, explicit, len, buffer, parm)
register PE     *pe;
int	explicit;
int	len;
char   *buffer;
RevCert * parm;
{
# line 339 "AF.py.COSINE"
    
	PE tbs;
    
    PE	p54_z = NULLPE;
    register PE *p54 = &p54_z;

    if (((*pe) = pe_alloc (PE_CLASS_UNIV, PE_FORM_CONS, PE_CONS_SEQ)) == NULLPE) {
        advise (NULLCP, "RevCert: %s", PEPY_ERR_NOMEM);
        return NOTOK;
    }
    (*p54) = NULLPE;

    {
        PE	p55 = (build_revcert_tbs(parm,&tbs)) ;

        if (p55 == NULLPE) {
            advise (NULLCP, "element %s", PEPY_ERR_INIT_FAILED);
            return NOTOK;
        }
        ((*p54) = p55) -> pe_refcnt++;

#ifdef DEBUG
        (void) testdebug ((*p54), "element");
#endif

        {
# line 347 "AF.py.COSINE"
   pe_free(tbs);
		
        }
    }

    if ((*p54) != NULLPE)
        if (seq_add ((*pe), (*p54), -1) == NOTOK) {
            advise (NULLCP, "RevCert %s%s", PEPY_ERR_BAD_SEQ,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }
    (*p54) = NULLPE;

    {
        if (build_SEC_AlgorithmIdentifier (p54, 0, NULL, NULLCP, parm->sig->signAI ) == NOTOK)
            return NOTOK;

#ifdef DEBUG
        (void) testdebug ((*p54), "element");
#endif

    }

    if ((*p54) != NULLPE)
        if (seq_add ((*pe), (*p54), -1) == NOTOK) {
            advise (NULLCP, "RevCert %s%s", PEPY_ERR_BAD_SEQ,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }
    (*p54) = NULLPE;

    {
        PE	p56_z = NULLPE;
        register PE *p56 = &p56_z;

        char *p57;
        int p58;
        p57 = parm->sig->signature.bits ;
        p58 = 
		     parm->sig->signature.nbits ;
        (*p56) = p57 ? strb2bitstr (p57, p58, PE_CLASS_UNIV, PE_PRIM_BITS) : NULLPE;
        if ((*p56) == NULLPE) {
            advise (NULLCP, "element %s", PEPY_ERR_INIT_FAILED);
            return NOTOK;
        }
        if (((*p54) = bit2prim ((*p56))) == NULLPE) {
            advise (NULLCP, "element: %s", PEPY_ERR_NOMEM);
            return NOTOK;
        }

#ifdef DEBUG
        (void) testdebug ((*p54), "element");
#endif

    }

    if ((*p54) != NULLPE)
        if (seq_add ((*pe), (*p54), -1) == NOTOK) {
            advise (NULLCP, "RevCert %s%s", PEPY_ERR_BAD_SEQ,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }

#ifdef DEBUG
    (void) testdebug ((*pe), "AF.RevCert");
#endif


    return OK;
}

/* ARGSUSED */

int	build_AF_RevCertSequence (pe, explicit, len, buffer, parm)
register PE     *pe;
int	explicit;
int	len;
char   *buffer;
SEQUENCE_OF_RevCert * parm;
{
    PE	p59 = NULLPE;
    PE	p60_z = NULLPE;
    register PE *p60 = &p60_z;

    if (((*pe) = pe_alloc (PE_CLASS_UNIV, PE_FORM_CONS, PE_CONS_SEQ)) == NULLPE) {
        advise (NULLCP, "RevCertSequence: %s", PEPY_ERR_NOMEM);
        return NOTOK;
    }
    for (; parm; parm = parm->next) {
        if (build_AF_RevCert (p60, 0, NULL, NULLCP, (parm->element) ) == NOTOK)
            return NOTOK;

#ifdef DEBUG
        (void) testdebug ((*p60), "element");
#endif

        (void) seq_addon ((*pe), p59, (*p60));
        p59 = (*p60);
    }

#ifdef DEBUG
    (void) testdebug ((*pe), "AF.RevCertSequence");
#endif


    return OK;
}

/* ARGSUSED */

int	build_AF_TBSPemCrl (pe, explicit, len, buffer, parm)
register PE     *pe;
int	explicit;
int	len;
char   *buffer;
PemCrlTBS * parm;
{
    PE	p61_z = NULLPE;
    register PE *p61 = &p61_z;

    if (((*pe) = pe_alloc (PE_CLASS_UNIV, PE_FORM_CONS, PE_CONS_SEQ)) == NULLPE) {
        advise (NULLCP, "TBSPemCrl: %s", PEPY_ERR_NOMEM);
        return NOTOK;
    }
    (*p61) = NULLPE;

    {	/* signature */
        if (build_SEC_AlgorithmIdentifier (p61, 0, NULL, NULLCP, parm->signatureAI ) == NOTOK)
            return NOTOK;

#ifdef DEBUG
        (void) testdebug ((*p61), "signature");
#endif

    }

    if ((*p61) != NULLPE)
        if (seq_add ((*pe), (*p61), -1) == NOTOK) {
            advise (NULLCP, "TBSPemCrl %s%s", PEPY_ERR_BAD_SEQ,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }
    (*p61) = NULLPE;

    {	/* issuer */
        if (build_IF_Name (p61, 0, NULL, NULLCP, parm->issuer ) == NOTOK)
            return NOTOK;

#ifdef DEBUG
        (void) testdebug ((*p61), "issuer");
#endif

    }

    if ((*p61) != NULLPE)
        if (seq_add ((*pe), (*p61), -1) == NOTOK) {
            advise (NULLCP, "TBSPemCrl %s%s", PEPY_ERR_BAD_SEQ,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }
    (*p61) = NULLPE;

    {	/* lastUpdate */
        if (build_UNIV_UTCTime (p61, 0, NULL, parm->lastUpdate , NullParm) == NOTOK)
            return NOTOK;

#ifdef DEBUG
        (void) testdebug ((*p61), "lastUpdate");
#endif

    }

    if ((*p61) != NULLPE)
        if (seq_add ((*pe), (*p61), -1) == NOTOK) {
            advise (NULLCP, "TBSPemCrl %s%s", PEPY_ERR_BAD_SEQ,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }
    (*p61) = NULLPE;

    {	/* nextUpdate */
        if (build_UNIV_UTCTime (p61, 0, NULL, parm->nextUpdate , NullParm) == NOTOK)
            return NOTOK;

#ifdef DEBUG
        (void) testdebug ((*p61), "nextUpdate");
#endif

    }

    if ((*p61) != NULLPE)
        if (seq_add ((*pe), (*p61), -1) == NOTOK) {
            advise (NULLCP, "TBSPemCrl %s%s", PEPY_ERR_BAD_SEQ,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }
    (*p61) = NULLPE;

    if (parm->revokedCertificates) {	/* revokedCertificates */
        if (build_AF_RevCertPemSequence (p61, 0, NULL, NULLCP, parm->revokedCertificates ) == NOTOK)
            return NOTOK;

#ifdef DEBUG
        (void) testdebug ((*p61), "revokedCertificates");
#endif

    }

    if ((*p61) != NULLPE)
        if (seq_add ((*pe), (*p61), -1) == NOTOK) {
            advise (NULLCP, "TBSPemCrl %s%s", PEPY_ERR_BAD_SEQ,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }

#ifdef DEBUG
    (void) testdebug ((*pe), "AF.TBSPemCrl");
#endif


    return OK;
}

/* ARGSUSED */

int	build_AF_PemCrl (pe, explicit, len, buffer, parm)
register PE     *pe;
int	explicit;
int	len;
char   *buffer;
PemCrl * parm;
{
# line 395 "AF.py.COSINE"
    
	PE tbs;
    
    PE	p62_z = NULLPE;
    register PE *p62 = &p62_z;

    if (((*pe) = pe_alloc (PE_CLASS_UNIV, PE_FORM_CONS, PE_CONS_SEQ)) == NULLPE) {
        advise (NULLCP, "PemCrl: %s", PEPY_ERR_NOMEM);
        return NOTOK;
    }
    (*p62) = NULLPE;

    {
        PE	p63 = (build_pemcrl_tbs(parm,&tbs)) ;

        if (p63 == NULLPE) {
            advise (NULLCP, "element %s", PEPY_ERR_INIT_FAILED);
            return NOTOK;
        }
        ((*p62) = p63) -> pe_refcnt++;

#ifdef DEBUG
        (void) testdebug ((*p62), "element");
#endif

        {
# line 403 "AF.py.COSINE"
   pe_free(tbs);
		
        }
    }

    if ((*p62) != NULLPE)
        if (seq_add ((*pe), (*p62), -1) == NOTOK) {
            advise (NULLCP, "PemCrl %s%s", PEPY_ERR_BAD_SEQ,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }
    (*p62) = NULLPE;

    {
        if (build_SEC_AlgorithmIdentifier (p62, 0, NULL, NULLCP, parm->sig->signAI ) == NOTOK)
            return NOTOK;

#ifdef DEBUG
        (void) testdebug ((*p62), "element");
#endif

    }

    if ((*p62) != NULLPE)
        if (seq_add ((*pe), (*p62), -1) == NOTOK) {
            advise (NULLCP, "PemCrl %s%s", PEPY_ERR_BAD_SEQ,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }
    (*p62) = NULLPE;

    {
        PE	p64_z = NULLPE;
        register PE *p64 = &p64_z;

        char *p65;
        int p66;
        p65 = parm->sig->signature.bits ;
        p66 = 
		     parm->sig->signature.nbits ;
        (*p64) = p65 ? strb2bitstr (p65, p66, PE_CLASS_UNIV, PE_PRIM_BITS) : NULLPE;
        if ((*p64) == NULLPE) {
            advise (NULLCP, "element %s", PEPY_ERR_INIT_FAILED);
            return NOTOK;
        }
        if (((*p62) = bit2prim ((*p64))) == NULLPE) {
            advise (NULLCP, "element: %s", PEPY_ERR_NOMEM);
            return NOTOK;
        }

#ifdef DEBUG
        (void) testdebug ((*p62), "element");
#endif

    }

    if ((*p62) != NULLPE)
        if (seq_add ((*pe), (*p62), -1) == NOTOK) {
            advise (NULLCP, "PemCrl %s%s", PEPY_ERR_BAD_SEQ,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }

#ifdef DEBUG
    (void) testdebug ((*pe), "AF.PemCrl");
#endif


    return OK;
}

/* ARGSUSED */

int	build_AF_RevCertPem (pe, explicit, len, buffer, parm)
register PE     *pe;
int	explicit;
int	len;
char   *buffer;
RevCertPem * parm;
{
    PE	p67_z = NULLPE;
    register PE *p67 = &p67_z;

    if (((*pe) = pe_alloc (PE_CLASS_UNIV, PE_FORM_CONS, PE_CONS_SEQ)) == NULLPE) {
        advise (NULLCP, "RevCertPem: %s", PEPY_ERR_NOMEM);
        return NOTOK;
    }
    (*p67) = NULLPE;

    {	/* serialNumber */
        register integer p68 = parm->serialnumber ;

        if (((*p67) = num2prim (p68, PE_CLASS_UNIV, PE_PRIM_INT)) == NULLPE) {
            advise (NULLCP, "serialNumber: %s", PEPY_ERR_NOMEM);
            return NOTOK;
        }

#ifdef DEBUG
        (void) testdebug ((*p67), "serialNumber");
#endif

    }

    if ((*p67) != NULLPE)
        if (seq_add ((*pe), (*p67), -1) == NOTOK) {
            advise (NULLCP, "RevCertPem %s%s", PEPY_ERR_BAD_SEQ,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }
    (*p67) = NULLPE;

    {	/* revocationDate */
        if (build_UNIV_UTCTime (p67, 0, NULL, parm->revocationDate , NullParm) == NOTOK)
            return NOTOK;

#ifdef DEBUG
        (void) testdebug ((*p67), "revocationDate");
#endif

    }

    if ((*p67) != NULLPE)
        if (seq_add ((*pe), (*p67), -1) == NOTOK) {
            advise (NULLCP, "RevCertPem %s%s", PEPY_ERR_BAD_SEQ,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }

#ifdef DEBUG
    (void) testdebug ((*pe), "AF.RevCertPem");
#endif


    return OK;
}

/* ARGSUSED */

int	build_AF_RevCertPemSequence (pe, explicit, len, buffer, parm)
register PE     *pe;
int	explicit;
int	len;
char   *buffer;
SEQUENCE_OF_RevCertPem * parm;
{
    PE	p69 = NULLPE;
    PE	p70_z = NULLPE;
    register PE *p70 = &p70_z;

    if (((*pe) = pe_alloc (PE_CLASS_UNIV, PE_FORM_CONS, PE_CONS_SEQ)) == NULLPE) {
        advise (NULLCP, "RevCertPemSequence: %s", PEPY_ERR_NOMEM);
        return NOTOK;
    }
    for (; parm; parm = parm->next) {
        if (build_AF_RevCertPem (p70, 0, NULL, NULLCP, (parm->element) ) == NOTOK)
            return NOTOK;

#ifdef DEBUG
        (void) testdebug ((*p70), "element");
#endif

        (void) seq_addon ((*pe), p69, (*p70));
        p69 = (*p70);
    }

#ifdef DEBUG
    (void) testdebug ((*pe), "AF.RevCertPemSequence");
#endif


    return OK;
}

/* ARGSUSED */

int	build_AF_SerialSet (pe, explicit, len, buffer, parm)
register PE     *pe;
int	explicit;
int	len;
char   *buffer;
SET_OF_int * parm;
{
    PE	p71 = NULLPE;
    PE	p72_z = NULLPE;
    register PE *p72 = &p72_z;

    if (((*pe) = pe_alloc (PE_CLASS_UNIV, PE_FORM_CONS, PE_CONS_SET)) == NULLPE) {
        advise (NULLCP, "SerialSet: %s", PEPY_ERR_NOMEM);
        return NOTOK;
    }
    for (; parm; parm = parm -> next) {
        register integer p73 = parm -> element ;

        if (((*p72) = num2prim (p73, PE_CLASS_UNIV, PE_PRIM_INT)) == NULLPE) {
            advise (NULLCP, "member: %s", PEPY_ERR_NOMEM);
            return NOTOK;
        }

#ifdef DEBUG
        (void) testdebug ((*p72), "member");
#endif

        (void) set_addon ((*pe), p71, (*p72));
        p71 = (*p72);
    }

#ifdef DEBUG
    (void) testdebug ((*pe), "AF.SerialSet");
#endif


    return OK;
}

/* ARGSUSED */

int	build_AF_CrlPSE (pe, explicit, len, buffer, parm)
register PE     *pe;
int	explicit;
int	len;
char   *buffer;
CrlPSE * parm;
{
    PE	p74_z = NULLPE;
    register PE *p74 = &p74_z;

    if (((*pe) = pe_alloc (PE_CLASS_UNIV, PE_FORM_CONS, PE_CONS_SEQ)) == NULLPE) {
        advise (NULLCP, "CrlPSE: %s", PEPY_ERR_NOMEM);
        return NOTOK;
    }
    (*p74) = NULLPE;

    {	/* issuer */
        if (build_IF_Name (p74, 0, NULL, NULLCP, parm->issuer ) == NOTOK)
            return NOTOK;

#ifdef DEBUG
        (void) testdebug ((*p74), "issuer");
#endif

    }

    if ((*p74) != NULLPE)
        if (seq_add ((*pe), (*p74), -1) == NOTOK) {
            advise (NULLCP, "CrlPSE %s%s", PEPY_ERR_BAD_SEQ,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }
    (*p74) = NULLPE;

    {	/* nextUpdate */
        if (build_UNIV_UTCTime (p74, 0, NULL, parm->nextUpdate , NullParm) == NOTOK)
            return NOTOK;

#ifdef DEBUG
        (void) testdebug ((*p74), "nextUpdate");
#endif

    }

    if ((*p74) != NULLPE)
        if (seq_add ((*pe), (*p74), -1) == NOTOK) {
            advise (NULLCP, "CrlPSE %s%s", PEPY_ERR_BAD_SEQ,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }
    (*p74) = NULLPE;

    if (parm->revcerts) {	/* revcerts */
        if (build_AF_RevCertPemSequence (p74, 0, NULL, NULLCP, parm->revcerts ) == NOTOK)
            return NOTOK;

#ifdef DEBUG
        (void) testdebug ((*p74), "revcerts");
#endif

    }

    if ((*p74) != NULLPE)
        if (seq_add ((*pe), (*p74), -1) == NOTOK) {
            advise (NULLCP, "CrlPSE %s%s", PEPY_ERR_BAD_SEQ,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }

#ifdef DEBUG
    (void) testdebug ((*pe), "AF.CrlPSE");
#endif


    return OK;
}

/* ARGSUSED */

int	build_AF_CrlSet (pe, explicit, len, buffer, parm)
register PE     *pe;
int	explicit;
int	len;
char   *buffer;
CrlSet * parm;
{
    PE	p75 = NULLPE;
    PE	p76_z = NULLPE;
    register PE *p76 = &p76_z;

    if (((*pe) = pe_alloc (PE_CLASS_UNIV, PE_FORM_CONS, PE_CONS_SET)) == NULLPE) {
        advise (NULLCP, "CrlSet: %s", PEPY_ERR_NOMEM);
        return NOTOK;
    }
    for (; parm; parm = parm -> next) {
        if (build_AF_CrlPSE (p76, 0, NULL, NULLCP, parm -> element ) == NOTOK)
            return NOTOK;

#ifdef DEBUG
        (void) testdebug ((*p76), "member");
#endif

        (void) set_addon ((*pe), p75, (*p76));
        p75 = (*p76);
    }

#ifdef DEBUG
    (void) testdebug ((*pe), "AF.CrlSet");
#endif


    return OK;
}

/* ARGSUSED */

int	build_AF_OldCertificateList (pe, explicit, len, buffer, parm)
register PE     *pe;
int	explicit;
int	len;
char   *buffer;
OCList * parm;
{
    PE	p77 = NULLPE;
    PE	p78_z = NULLPE;
    register PE *p78 = &p78_z;

    if (((*pe) = pe_alloc (PE_CLASS_UNIV, PE_FORM_CONS, PE_CONS_SEQ)) == NULLPE) {
        advise (NULLCP, "OldCertificateList: %s", PEPY_ERR_NOMEM);
        return NOTOK;
    }
    for (; parm; parm = parm->next) {
        PE	p79_z = NULLPE;
        register PE *p79 = &p79_z;

        if (((*p78) = pe_alloc (PE_CLASS_UNIV, PE_FORM_CONS, PE_CONS_SEQ)) == NULLPE) {
            advise (NULLCP, "element: %s", PEPY_ERR_NOMEM);
            return NOTOK;
        }
        (*p79) = NULLPE;

        {	/* serialNumber */
            register integer p80 = parm->serialnumber ;

            if (((*p79) = num2prim (p80, PE_CLASS_UNIV, PE_PRIM_INT)) == NULLPE) {
                advise (NULLCP, "serialNumber: %s", PEPY_ERR_NOMEM);
                return NOTOK;
            }

#ifdef DEBUG
            (void) testdebug ((*p79), "serialNumber");
#endif

        }

        if ((*p79) != NULLPE)
            if (seq_add ((*p78), (*p79), -1) == NOTOK) {
                advise (NULLCP, "element %s%s", PEPY_ERR_BAD_SEQ,
                        pe_error ((*p78) -> pe_errno));
                return NOTOK;
            }
        (*p79) = NULLPE;

        {	/* crossCertificate */
            if (build_AF_Certificate (p79, 0, NULL, NULLCP, parm->ccert ) == NOTOK)
                return NOTOK;

#ifdef DEBUG
            (void) testdebug ((*p79), "crossCertificate");
#endif

        }

        if ((*p79) != NULLPE)
            if (seq_add ((*p78), (*p79), -1) == NOTOK) {
                advise (NULLCP, "element %s%s", PEPY_ERR_BAD_SEQ,
                        pe_error ((*p78) -> pe_errno));
                return NOTOK;
            }

#ifdef DEBUG
        (void) testdebug ((*p78), "element");
#endif

        (void) seq_addon ((*pe), p77, (*p78));
        p77 = (*p78);
    }

#ifdef DEBUG
    (void) testdebug ((*pe), "AF.OldCertificateList");
#endif


    return OK;
}

/* ARGSUSED */

int	build_AF_CertificationPath (pe, explicit, len, buffer, parm)
register PE     *pe;
int	explicit;
int	len;
char   *buffer;
CertificationPath * parm;
{
    PE	p81_z = NULLPE;
    register PE *p81 = &p81_z;

    if (((*pe) = pe_alloc (PE_CLASS_UNIV, PE_FORM_CONS, PE_CONS_SEQ)) == NULLPE) {
        advise (NULLCP, "CertificationPath: %s", PEPY_ERR_NOMEM);
        return NOTOK;
    }
    (*p81) = NULLPE;

    {	/* userCertificate */
        if (build_AF_Certificate (p81, 0, NULL, NULLCP, parm->userCertificate ) == NOTOK)
            return NOTOK;

#ifdef DEBUG
        (void) testdebug ((*p81), "userCertificate");
#endif

    }

    if ((*p81) != NULLPE)
        if (seq_add ((*pe), (*p81), -1) == NOTOK) {
            advise (NULLCP, "CertificationPath %s%s", PEPY_ERR_BAD_SEQ,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }
    (*p81) = NULLPE;

    if (parm->theCACertificates) {	/* theCACertificates */
        if (build_AF_CertificatePairs (p81, 0, NULL, NULLCP, parm->theCACertificates ) == NOTOK)
            return NOTOK;

#ifdef DEBUG
        (void) testdebug ((*p81), "theCACertificates");
#endif

    }

    if ((*p81) != NULLPE)
        if (seq_add ((*pe), (*p81), -1) == NOTOK) {
            advise (NULLCP, "CertificationPath %s%s", PEPY_ERR_BAD_SEQ,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }

#ifdef DEBUG
    (void) testdebug ((*pe), "AF.CertificationPath");
#endif


    return OK;
}

/* ARGSUSED */

int	build_AF_CertificatePairs (pe, explicit, len, buffer, parm)
register PE     *pe;
int	explicit;
int	len;
char   *buffer;
CertificatePairs * parm;
{
# line 498 "AF.py.COSINE"
    
SEQUENCE_OF_CertificatePair * level;

    PE	p82 = NULLPE;
    PE	p83_z = NULLPE;
    register PE *p83 = &p83_z;

    if (((*pe) = pe_alloc (PE_CLASS_UNIV, PE_FORM_CONS, PE_CONS_SEQ)) == NULLPE) {
        advise (NULLCP, "CertificatePairs: %s", PEPY_ERR_NOMEM);
        return NOTOK;
    }
    for (level = (parm)? parm->liste:(SEQUENCE_OF_CertificatePair * )0; 
		  level; 
		  level = (level->next)? level->next:((parm = parm->superior)? parm->liste:(SEQUENCE_OF_CertificatePair * )0)) {
        if (build_AF_CertificatePair (p83, 0, NULL, NULLCP, level->element ) == NOTOK)
            return NOTOK;

#ifdef DEBUG
        (void) testdebug ((*p83), "element");
#endif

        (void) seq_addon ((*pe), p82, (*p83));
        p82 = (*p83);
    }

#ifdef DEBUG
    (void) testdebug ((*pe), "AF.CertificatePairs");
#endif


    return OK;
}

/* ARGSUSED */

int	build_AF_PemCrlWithCerts (pe, explicit, len, buffer, parm)
register PE     *pe;
int	explicit;
int	len;
char   *buffer;
PemCrlWithCerts * parm;
{
    PE	p84_z = NULLPE;
    register PE *p84 = &p84_z;

    if (((*pe) = pe_alloc (PE_CLASS_UNIV, PE_FORM_CONS, PE_CONS_SEQ)) == NULLPE) {
        advise (NULLCP, "PemCrlWithCerts: %s", PEPY_ERR_NOMEM);
        return NOTOK;
    }
    (*p84) = NULLPE;

    {	/* pemCRL */
        if (build_AF_PemCrl (p84, 0, NULL, NULLCP, parm->pemcrl ) == NOTOK)
            return NOTOK;

#ifdef DEBUG
        (void) testdebug ((*p84), "pemCRL");
#endif

    }

    if ((*p84) != NULLPE)
        if (seq_add ((*pe), (*p84), -1) == NOTOK) {
            advise (NULLCP, "PemCrlWithCerts %s%s", PEPY_ERR_BAD_SEQ,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }
    (*p84) = NULLPE;

    if (parm->certificates) {	/* certificates */
        if (build_AF_Certificates (p84, 0, NULL, NULLCP, parm->certificates ) == NOTOK)
            return NOTOK;

#ifdef DEBUG
        (void) testdebug ((*p84), "certificates");
#endif

    }

    if ((*p84) != NULLPE)
        if (seq_add ((*pe), (*p84), -1) == NOTOK) {
            advise (NULLCP, "PemCrlWithCerts %s%s", PEPY_ERR_BAD_SEQ,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }

#ifdef DEBUG
    (void) testdebug ((*pe), "AF.PemCrlWithCerts");
#endif


    return OK;
}

/* ARGSUSED */

int	build_AF_AliasesMember (pe, explicit, len, buffer, parm)
register PE     *pe;
int	explicit;
int	len;
char   *buffer;
Aliases * parm;
{
    PE	p85_z = NULLPE;
    register PE *p85 = &p85_z;

    if (((*pe) = pe_alloc (PE_CLASS_UNIV, PE_FORM_CONS, PE_CONS_SEQ)) == NULLPE) {
        advise (NULLCP, "AliasesMember: %s", PEPY_ERR_NOMEM);
        return NOTOK;
    }
    (*p85) = NULLPE;

    {	/* aname */
        if (build_UNIV_IA5String (p85, 0, NULL, parm->aname, NullParm) == NOTOK)
            return NOTOK;

#ifdef DEBUG
        (void) testdebug ((*p85), "aname");
#endif

    }

    if ((*p85) != NULLPE)
        if (seq_add ((*pe), (*p85), -1) == NOTOK) {
            advise (NULLCP, "AliasesMember %s%s", PEPY_ERR_BAD_SEQ,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }
    (*p85) = NULLPE;

    {	/* aliasfile */
        register integer p86 = parm->aliasfile;

        if (((*p85) = enum2prim (p86, PE_CLASS_UNIV, PE_PRIM_ENUM)) == NULLPE) {
            advise (NULLCP, "aliasfile: %s", PEPY_ERR_NOMEM);
            return NOTOK;
        }
        switch (p86) {
            case 0:	/* useralias */
                break;
            case 1:	/* sytemalias */
                break;
            default:
                advise (NULLCP, "aliasfile %s%d", PEPY_ERR_UNK_COMP, p86);
                return NOTOK;
        }

#ifdef DEBUG
        (void) testdebug ((*p85), "aliasfile");
#endif

    }

    if ((*p85) != NULLPE)
        if (seq_add ((*pe), (*p85), -1) == NOTOK) {
            advise (NULLCP, "AliasesMember %s%s", PEPY_ERR_BAD_SEQ,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }

#ifdef DEBUG
    (void) testdebug ((*pe), "AF.AliasesMember");
#endif


    return OK;
}

/* ARGSUSED */

int	build_AF_Aliases (pe, explicit, len, buffer, parm)
register PE     *pe;
int	explicit;
int	len;
char   *buffer;
Aliases * parm;
{
    PE	p87 = NULLPE;
    PE	p88_z = NULLPE;
    register PE *p88 = &p88_z;

    if (((*pe) = pe_alloc (PE_CLASS_UNIV, PE_FORM_CONS, PE_CONS_SEQ)) == NULLPE) {
        advise (NULLCP, "Aliases: %s", PEPY_ERR_NOMEM);
        return NOTOK;
    }
    for (; parm; parm = parm->next) {
        if (build_AF_AliasesMember (p88, 0, NULL, NULLCP, parm) == NOTOK)
            return NOTOK;

#ifdef DEBUG
        (void) testdebug ((*p88), "element");
#endif

        (void) seq_addon ((*pe), p87, (*p88));
        p87 = (*p88);
    }

#ifdef DEBUG
    (void) testdebug ((*pe), "AF.Aliases");
#endif


    return OK;
}

/* ARGSUSED */

int	build_AF_AliasListMember (pe, explicit, len, buffer, parm)
register PE     *pe;
int	explicit;
int	len;
char   *buffer;
AliasList * parm;
{
    PE	p89_z = NULLPE;
    register PE *p89 = &p89_z;

    if (((*pe) = pe_alloc (PE_CLASS_UNIV, PE_FORM_CONS, PE_CONS_SEQ)) == NULLPE) {
        advise (NULLCP, "AliasListMember: %s", PEPY_ERR_NOMEM);
        return NOTOK;
    }
    (*p89) = NULLPE;

    {	/* aliases */
        if (build_AF_Aliases (p89, 0, NULL, NULLCP, parm->a) == NOTOK)
            return NOTOK;

#ifdef DEBUG
        (void) testdebug ((*p89), "aliases");
#endif

    }

    if ((*p89) != NULLPE)
        if (seq_add ((*pe), (*p89), -1) == NOTOK) {
            advise (NULLCP, "AliasListMember %s%s", PEPY_ERR_BAD_SEQ,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }
    (*p89) = NULLPE;

    {	/* dname */
        if (build_UNIV_IA5String (p89, 0, NULL, parm->dname, NullParm) == NOTOK)
            return NOTOK;

#ifdef DEBUG
        (void) testdebug ((*p89), "dname");
#endif

    }

    if ((*p89) != NULLPE)
        if (seq_add ((*pe), (*p89), -1) == NOTOK) {
            advise (NULLCP, "AliasListMember %s%s", PEPY_ERR_BAD_SEQ,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }

#ifdef DEBUG
    (void) testdebug ((*pe), "AF.AliasListMember");
#endif


    return OK;
}

/* ARGSUSED */

int	build_AF_AliasList (pe, explicit, len, buffer, parm)
register PE     *pe;
int	explicit;
int	len;
char   *buffer;
AliasList * parm;
{
    PE	p90 = NULLPE;
    PE	p91_z = NULLPE;
    register PE *p91 = &p91_z;

    if (((*pe) = pe_alloc (PE_CLASS_UNIV, PE_FORM_CONS, PE_CONS_SEQ)) == NULLPE) {
        advise (NULLCP, "AliasList: %s", PEPY_ERR_NOMEM);
        return NOTOK;
    }
    for (; parm; parm = parm->next) {
        if (build_AF_AliasListMember (p91, 0, NULL, NULLCP, parm) == NOTOK)
            return NOTOK;

#ifdef DEBUG
        (void) testdebug ((*p91), "element");
#endif

        (void) seq_addon ((*pe), p90, (*p91));
        p90 = (*p91);
    }

#ifdef DEBUG
    (void) testdebug ((*pe), "AF.AliasList");
#endif


    return OK;
}

/* ARGSUSED */

int	parse_AF_SerialNumbers (pe, explicit, len, buffer, parm)
register PE	pe;
int	explicit;
int    *len;
char  **buffer;
SerialNumbers ** parm;
{
    register PE p92;

#ifdef DEBUG
    (void) testdebug (pe, "AF.SerialNumbers");
#endif

    if (explicit) {
        if (pe -> pe_class != PE_CLASS_UNIV
                || pe -> pe_form != PE_FORM_CONS
                || pe -> pe_id != PE_CONS_SEQ) {
            advise (NULLCP, "SerialNumbers bad class/form/id: %s/%d/0x%x",
                    pe_classlist[pe -> pe_class], pe -> pe_form, pe -> pe_id);
            return NOTOK;
        }
    }
    else
        if (pe -> pe_form != PE_FORM_CONS) {
            advise (NULLCP, "SerialNumbers bad form: %d", pe -> pe_form);
            return NOTOK;
        }

    {
# line 570 "AF.py.COSINE"

        if ((*(parm) = (SerialNumbers *)
                calloc (1, sizeof **(parm))) == ((SerialNumbers *) 0)) {
            advise (NULLCP, "out of memory");
            return NOTOK;
        }
	(*parm)->initial = 0;
    
    }
    if ((p92 = prim2seq (pe)) == NULLPE) {
        advise (NULLCP, "SerialNumbers %s%s", PEPY_ERR_BAD_SEQ,
                pe_error (pe -> pe_errno));
        return NOTOK;
    }
    pe = p92;

    {
        register PE p93;

        if ((p93 = first_member (pe)) != NULLPE
                && PE_ID (p93 -> pe_class, p93 -> pe_id)
                        != PE_ID (PE_CLASS_CONT, 0))
            p93 = NULLPE;
        if (p93 != NULLPE) {
            p92 = p93;

            {	/* element TAG PULLUP */
                register PE p94;

                if ((p94 = prim2set (p93)) == NULLPE) {
                    advise (NULLCP, "member %selement: %s", PEPY_ERR_BAD,
                            pe_error (p93 -> pe_errno));
                    return NOTOK;
                }
                if (p94 -> pe_cardinal != 1) {
                    advise (NULLCP, "member %s element: %d", PEPY_ERR_TOO_MANY_TAGGED,
                            p94 -> pe_cardinal);
                    return NOTOK;
                }
                p93 = first_member (p94);
            }
            {
                register integer p95;

#ifdef DEBUG
                (void) testdebug (p93, "element");
#endif

                if (p93 -> pe_class != PE_CLASS_UNIV
                        || p93 -> pe_form != PE_FORM_PRIM
                        || p93 -> pe_id != PE_PRIM_INT) {
                    advise (NULLCP, "element bad class/form/id: %s/%d/0x%x",
                            pe_classlist[p93 -> pe_class], p93 -> pe_form, p93 -> pe_id);
                    return NOTOK;
                }

                if ((p95 = prim2num (p93)) == NOTOK
                        && p93 -> pe_errno != PE_ERR_NONE) {
                    advise (NULLCP, "element %s%s", PEPY_ERR_BAD_INTEGER,
                            pe_error (p93 -> pe_errno));
                    return NOTOK;
                }
                (* parm)->initial  = p95;
            }
        }
        else {
            /* set default here using yp -> yp_default */
        }

    }

    {
        register PE p96;

        if ((p96 = (pe != p92 ? next_member (pe, p92) : first_member (pe))) != NULLPE) {
            p92 = p96;

            {	/* element TAG PULLUP */
                register PE p97;

                if ((p97 = prim2set (p96)) == NULLPE) {
                    advise (NULLCP, "member %selement: %s", PEPY_ERR_BAD,
                            pe_error (p96 -> pe_errno));
                    return NOTOK;
                }
                if (p97 -> pe_cardinal != 1) {
                    advise (NULLCP, "member %s element: %d", PEPY_ERR_TOO_MANY_TAGGED,
                            p97 -> pe_cardinal);
                    return NOTOK;
                }
                p96 = first_member (p97);
            }
            {
                register integer p98;

#ifdef DEBUG
                (void) testdebug (p96, "element");
#endif

                if (p96 -> pe_class != PE_CLASS_UNIV
                        || p96 -> pe_form != PE_FORM_PRIM
                        || p96 -> pe_id != PE_PRIM_INT) {
                    advise (NULLCP, "element bad class/form/id: %s/%d/0x%x",
                            pe_classlist[p96 -> pe_class], p96 -> pe_form, p96 -> pe_id);
                    return NOTOK;
                }

                if ((p98 = prim2num (p96)) == NOTOK
                        && p96 -> pe_errno != PE_ERR_NONE) {
                    advise (NULLCP, "element %s%s", PEPY_ERR_BAD_INTEGER,
                            pe_error (p96 -> pe_errno));
                    return NOTOK;
                }
                (* parm)->actual  = p98;
            }
        }
        else {
            advise (NULLCP, "SerialNumbers %selement", PEPY_ERR_MISSING);
            return NOTOK;
        }

    }


    if (pe -> pe_cardinal > 2) {
        advise (NULLCP, "SerialNumbers %s(2): %d", PEPY_ERR_TOO_MANY_ELEMENTS,
                pe -> pe_cardinal);
        return NOTOK;
    }

    return OK;
}

/* ARGSUSED */

int	parse_AF_PKRoot (pe, explicit, len, buffer, parm)
register PE	pe;
int	explicit;
int    *len;
char  **buffer;
PKRoot ** parm;
{
    register PE p99;

#ifdef DEBUG
    (void) testdebug (pe, "AF.PKRoot");
#endif

    if (explicit) {
        if (pe -> pe_class != PE_CLASS_UNIV
                || pe -> pe_form != PE_FORM_CONS
                || pe -> pe_id != PE_CONS_SEQ) {
            advise (NULLCP, "PKRoot bad class/form/id: %s/%d/0x%x",
                    pe_classlist[pe -> pe_class], pe -> pe_form, pe -> pe_id);
            return NOTOK;
        }
    }
    else
        if (pe -> pe_form != PE_FORM_CONS) {
            advise (NULLCP, "PKRoot bad form: %d", pe -> pe_form);
            return NOTOK;
        }

    {
# line 589 "AF.py.COSINE"

        if ((*(parm) = (PKRoot *)
                calloc (1, sizeof **(parm))) == ((PKRoot *) 0)) {
            advise (NULLCP, "out of memory");
            return NOTOK;
        }
    
    }
    if ((p99 = prim2seq (pe)) == NULLPE) {
        advise (NULLCP, "PKRoot %s%s", PEPY_ERR_BAD_SEQ,
                pe_error (pe -> pe_errno));
        return NOTOK;
    }
    pe = p99;

    {
        register PE p100;

        if ((p100 = first_member (pe)) != NULLPE) {
            p99 = p100;

            {	/* cA */
#ifdef DEBUG
                (void) testdebug (p100, "cA");
#endif

                if (parse_IF_Name (p100, 1, NULLIP, NULLVP, &((*parm) -> ca)) == NOTOK)
                    return NOTOK;
            }
        }
        else {
            advise (NULLCP, "PKRoot %scA element", PEPY_ERR_MISSING);
            return NOTOK;
        }

    }

    {
        register PE p101;

        if ((p101 = (pe != p99 ? next_member (pe, p99) : first_member (pe))) != NULLPE) {
            p99 = p101;

            {	/* newkey */
#ifdef DEBUG
                (void) testdebug (p101, "newkey");
#endif

                if (parse_AF_RootKey (p101, 1, NULLIP, NULLVP, &((*parm) -> newkey)) == NOTOK)
                    return NOTOK;
            }
        }
        else {
            advise (NULLCP, "PKRoot %snewkey element", PEPY_ERR_MISSING);
            return NOTOK;
        }

    }

    {
        register PE p102;

        if ((p102 = (pe != p99 ? next_member (pe, p99) : first_member (pe))) != NULLPE) {
            p99 = p102;

            {	/* oldkey */
#ifdef DEBUG
                (void) testdebug (p102, "oldkey");
#endif

                if (parse_AF_RootKey (p102, 1, NULLIP, NULLVP, &((*parm) -> oldkey)) == NOTOK)
                    return NOTOK;
            }
        }
    }


    if (pe -> pe_cardinal > 3) {
        advise (NULLCP, "PKRoot %s(3): %d", PEPY_ERR_TOO_MANY_ELEMENTS,
                pe -> pe_cardinal);
        return NOTOK;
    }

    return OK;
}

/* ARGSUSED */

int	parse_AF_RootKey (pe, explicit, len, buffer, parm)
register PE	pe;
int	explicit;
int    *len;
char  **buffer;
struct Serial ** parm;
{
    register PE p103;

#ifdef DEBUG
    (void) testdebug (pe, "AF.RootKey");
#endif

    if (explicit) {
        if (pe -> pe_class != PE_CLASS_UNIV
                || pe -> pe_form != PE_FORM_CONS
                || pe -> pe_id != PE_CONS_SEQ) {
            advise (NULLCP, "RootKey bad class/form/id: %s/%d/0x%x",
                    pe_classlist[pe -> pe_class], pe -> pe_form, pe -> pe_id);
            return NOTOK;
        }
    }
    else
        if (pe -> pe_form != PE_FORM_CONS) {
            advise (NULLCP, "RootKey bad form: %d", pe -> pe_form);
            return NOTOK;
        }

    {
# line 613 "AF.py.COSINE"

        if ((*(parm) = (struct Serial *)
                calloc (1, sizeof **(parm))) == ((struct Serial *) 0)) {
            advise (NULLCP, "out of memory");
            return NOTOK;
        }
        if (((*parm)->key = (KeyInfo *)
                calloc (1, sizeof (KeyInfo))) == ((KeyInfo *) 0)) {
            advise (NULLCP, "out of memory");
            return NOTOK;
        }
        if (((*parm)->sig = (Signature *)
                calloc (1, sizeof (Signature))) == ((Signature *) 0)) {
            advise (NULLCP, "out of memory");
            return NOTOK;
        }
	(*parm)->notbefore = CNULL;
	(*parm)->notafter = CNULL;
	(*parm)->sig->signAI = NULLALGID;
	(*parm)->sig->signature.bits = CNULL;
	(*parm)->sig->signature.nbits = 0;
    
    }
    if ((p103 = prim2seq (pe)) == NULLPE) {
        advise (NULLCP, "RootKey %s%s", PEPY_ERR_BAD_SEQ,
                pe_error (pe -> pe_errno));
        return NOTOK;
    }
    pe = p103;

    {
        register PE p104;

        if ((p104 = first_member (pe)) != NULLPE
                && PE_ID (p104 -> pe_class, p104 -> pe_id)
                        != PE_ID (PE_CLASS_CONT, 0))
            p104 = NULLPE;
        if (p104 != NULLPE) {
            p103 = p104;

            {	/* element TAG PULLUP */
                register PE p105;

                if ((p105 = prim2set (p104)) == NULLPE) {
                    advise (NULLCP, "version %selement: %s", PEPY_ERR_BAD,
                            pe_error (p104 -> pe_errno));
                    return NOTOK;
                }
                if (p105 -> pe_cardinal != 1) {
                    advise (NULLCP, "version %s element: %d", PEPY_ERR_TOO_MANY_TAGGED,
                            p105 -> pe_cardinal);
                    return NOTOK;
                }
                p104 = first_member (p105);
            }
            {	/* version */
                register integer p106;

#ifdef DEBUG
                (void) testdebug (p104, "version");
#endif

                if (p104 -> pe_class != PE_CLASS_UNIV
                        || p104 -> pe_form != PE_FORM_PRIM
                        || p104 -> pe_id != PE_PRIM_INT) {
                    advise (NULLCP, "version bad class/form/id: %s/%d/0x%x",
                            pe_classlist[p104 -> pe_class], p104 -> pe_form, p104 -> pe_id);
                    return NOTOK;
                }

                if ((p106 = prim2num (p104)) == NOTOK
                        && p104 -> pe_errno != PE_ERR_NONE) {
                    advise (NULLCP, "version %s%s", PEPY_ERR_BAD_INTEGER,
                            pe_error (p104 -> pe_errno));
                    return NOTOK;
                }
                (*parm)->version  = p106;
                switch (p106) {
                    case 0:	/* v1988 */
                        break;
                    case 1:	/* v1992 */
                        break;
                }
            }
        }
        else {
            /* set default here using yp -> yp_default */
        }

    }

    {
        register PE p107;

        if ((p107 = (pe != p103 ? next_member (pe, p103) : first_member (pe))) != NULLPE) {
            p103 = p107;

            {	/* serial */
                register integer p108;

#ifdef DEBUG
                (void) testdebug (p107, "serial");
#endif

                if (p107 -> pe_class != PE_CLASS_UNIV
                        || p107 -> pe_form != PE_FORM_PRIM
                        || p107 -> pe_id != PE_PRIM_INT) {
                    advise (NULLCP, "serial bad class/form/id: %s/%d/0x%x",
                            pe_classlist[p107 -> pe_class], p107 -> pe_form, p107 -> pe_id);
                    return NOTOK;
                }

                if ((p108 = prim2num (p107)) == NOTOK
                        && p107 -> pe_errno != PE_ERR_NONE) {
                    advise (NULLCP, "serial %s%s", PEPY_ERR_BAD_INTEGER,
                            pe_error (p107 -> pe_errno));
                    return NOTOK;
                }
                (*parm)->serial  = p108;
            }
        }
        else {
            advise (NULLCP, "RootKey %sserial element", PEPY_ERR_MISSING);
            return NOTOK;
        }

    }

    {
        register PE p109;

        if ((p109 = (pe != p103 ? next_member (pe, p103) : first_member (pe))) != NULLPE) {
            p103 = p109;

            {	/* key */
#ifdef DEBUG
                (void) testdebug (p109, "key");
#endif

                if (parse_SEC_KeyInfo (p109, 1, NULLIP, NULLVP, ((*parm)->key)) == NOTOK)
                    return NOTOK;
            }
        }
        else {
            advise (NULLCP, "RootKey %skey element", PEPY_ERR_MISSING);
            return NOTOK;
        }

    }

    {
        register PE p110;

        if ((p110 = (pe != p103 ? next_member (pe, p103) : first_member (pe))) 
                    != NULLPE
                && PE_ID (p110 -> pe_class, p110 -> pe_id)
                        != PE_ID (PE_CLASS_CONT, 1))
            p110 = NULLPE;
        if (p110 != NULLPE) {
            p103 = p110;

            {	/* element TAG PULLUP */
                register PE p111;

                if ((p111 = prim2set (p110)) == NULLPE) {
                    advise (NULLCP, "validity %selement: %s", PEPY_ERR_BAD,
                            pe_error (p110 -> pe_errno));
                    return NOTOK;
                }
                if (p111 -> pe_cardinal != 1) {
                    advise (NULLCP, "validity %s element: %d", PEPY_ERR_TOO_MANY_TAGGED,
                            p111 -> pe_cardinal);
                    return NOTOK;
                }
                p110 = first_member (p111);
            }
            {	/* validity */
#ifdef DEBUG
                (void) testdebug (p110, "validity");
#endif

                if (parse_AF_PKRootValidity (p110, 1, NULLIP, NULLVP, (*parm) ) == NOTOK)
                    return NOTOK;
            }
        }
    }

    {
        register PE p112;

        if ((p112 = (pe != p103 ? next_member (pe, p103) : first_member (pe))) 
                    != NULLPE
                && PE_ID (p112 -> pe_class, p112 -> pe_id)
                        != PE_ID (PE_CLASS_CONT, 2))
            p112 = NULLPE;
        if (p112 != NULLPE) {
            p103 = p112;

            {	/* element TAG PULLUP */
                register PE p113;

                if ((p113 = prim2set (p112)) == NULLPE) {
                    advise (NULLCP, "signAlgID %selement: %s", PEPY_ERR_BAD,
                            pe_error (p112 -> pe_errno));
                    return NOTOK;
                }
                if (p113 -> pe_cardinal != 1) {
                    advise (NULLCP, "signAlgID %s element: %d", PEPY_ERR_TOO_MANY_TAGGED,
                            p113 -> pe_cardinal);
                    return NOTOK;
                }
                p112 = first_member (p113);
            }
            {	/* signAlgID */
#ifdef DEBUG
                (void) testdebug (p112, "signAlgID");
#endif

                if (parse_SEC_AlgorithmIdentifier (p112, 1, NULLIP, NULLVP, &((*parm)->sig->signAI) ) == NOTOK)
                    return NOTOK;
            }
        }
    }

    {
        register PE p114;

        if ((p114 = (pe != p103 ? next_member (pe, p103) : first_member (pe))) != NULLPE) {
            p103 = p114;

            {	/* signBitString */
                register PE p115;

#ifdef DEBUG
                (void) testdebug (p114, "signBitString");
#endif

                if (p114 -> pe_class != PE_CLASS_UNIV || p114 -> pe_id != PE_PRIM_BITS) {
                    advise (NULLCP, "signBitString bad class/form/id: %s/%d/0x%x",
                            pe_classlist[p114 -> pe_class], p114 -> pe_form, p114 -> pe_id);
                    return NOTOK;
                }

                if ((p115 = prim2bit (p114)) == NULLPE) {
                    advise (NULLCP, "signBitString %s%s", PEPY_ERR_BAD_BITS,
                            pe_error (p114 -> pe_errno));
                    return NOTOK;
                }
                (*parm)->sig->signature.bits  = bitstr2strb (p114, &(
		     (*parm)->sig->signature.nbits ));
            }
        }
    }


    if (pe -> pe_cardinal > 6) {
        advise (NULLCP, "RootKey %s(6): %d", PEPY_ERR_TOO_MANY_ELEMENTS,
                pe -> pe_cardinal);
        return NOTOK;
    }
    {
# line 668 "AF.py.COSINE"

	if(! (*parm)->sig->signAI){
		aux_free_KeyInfo( (KeyInfo **) & ((*parm)->sig) );
		(*parm)->sig = (Signature * ) 0;
	}
    
    }

    return OK;
}

/* ARGSUSED */

int	parse_AF_TBSCertificate (pe, explicit, len, buffer, parm)
register PE	pe;
int	explicit;
int    *len;
char  **buffer;
ToBeSigned ** parm;
{
    register PE p116;

#ifdef DEBUG
    (void) testdebug (pe, "AF.TBSCertificate");
#endif

    if (explicit) {
        if (pe -> pe_class != PE_CLASS_UNIV
                || pe -> pe_form != PE_FORM_CONS
                || pe -> pe_id != PE_CONS_SEQ) {
            advise (NULLCP, "TBSCertificate bad class/form/id: %s/%d/0x%x",
                    pe_classlist[pe -> pe_class], pe -> pe_form, pe -> pe_id);
            return NOTOK;
        }
    }
    else
        if (pe -> pe_form != PE_FORM_CONS) {
            advise (NULLCP, "TBSCertificate bad form: %d", pe -> pe_form);
            return NOTOK;
        }

    {
# line 677 "AF.py.COSINE"

        if ((*(parm) = (ToBeSigned *)
                calloc (1, sizeof **(parm))) == ((ToBeSigned *) 0)) {
            advise (NULLCP, "out of memory");
            return NOTOK;
        }
        if (((*parm)->subjectPK = (KeyInfo *)
                calloc (1, sizeof (KeyInfo))) == ((KeyInfo *) 0)) {
            advise (NULLCP, "out of memory");
            return NOTOK;
        }
	(*parm) -> version = 0;
    
    }
    if ((p116 = prim2seq (pe)) == NULLPE) {
        advise (NULLCP, "TBSCertificate %s%s", PEPY_ERR_BAD_SEQ,
                pe_error (pe -> pe_errno));
        return NOTOK;
    }
    pe = p116;

    {
        register PE p117;

        if ((p117 = first_member (pe)) != NULLPE
                && PE_ID (p117 -> pe_class, p117 -> pe_id)
                        != PE_ID (PE_CLASS_CONT, 0))
            p117 = NULLPE;
        if (p117 != NULLPE) {
            p116 = p117;

            {	/* element TAG PULLUP */
                register PE p118;

                if ((p118 = prim2set (p117)) == NULLPE) {
                    advise (NULLCP, "version %selement: %s", PEPY_ERR_BAD,
                            pe_error (p117 -> pe_errno));
                    return NOTOK;
                }
                if (p118 -> pe_cardinal != 1) {
                    advise (NULLCP, "version %s element: %d", PEPY_ERR_TOO_MANY_TAGGED,
                            p118 -> pe_cardinal);
                    return NOTOK;
                }
                p117 = first_member (p118);
            }
            {	/* version */
                register integer p119;

#ifdef DEBUG
                (void) testdebug (p117, "version");
#endif

                if (p117 -> pe_class != PE_CLASS_UNIV
                        || p117 -> pe_form != PE_FORM_PRIM
                        || p117 -> pe_id != PE_PRIM_INT) {
                    advise (NULLCP, "version bad class/form/id: %s/%d/0x%x",
                            pe_classlist[p117 -> pe_class], p117 -> pe_form, p117 -> pe_id);
                    return NOTOK;
                }

                if ((p119 = prim2num (p117)) == NOTOK
                        && p117 -> pe_errno != PE_ERR_NONE) {
                    advise (NULLCP, "version %s%s", PEPY_ERR_BAD_INTEGER,
                            pe_error (p117 -> pe_errno));
                    return NOTOK;
                }
                (*parm) -> version  = p119;
                switch (p119) {
                    case 0:	/* v1988 */
                        break;
                    case 1:	/* v1992 */
                        break;
                }
            }
        }
        else {
            /* set default here using yp -> yp_default */
        }

    }

    {
        register PE p120;

        if ((p120 = (pe != p116 ? next_member (pe, p116) : first_member (pe))) != NULLPE) {
            p116 = p120;

            {	/* serialNumber */
                register integer p121;

#ifdef DEBUG
                (void) testdebug (p120, "serialNumber");
#endif

                if (p120 -> pe_class != PE_CLASS_UNIV
                        || p120 -> pe_form != PE_FORM_PRIM
                        || p120 -> pe_id != PE_PRIM_INT) {
                    advise (NULLCP, "serialNumber bad class/form/id: %s/%d/0x%x",
                            pe_classlist[p120 -> pe_class], p120 -> pe_form, p120 -> pe_id);
                    return NOTOK;
                }

                if ((p121 = prim2num (p120)) == NOTOK
                        && p120 -> pe_errno != PE_ERR_NONE) {
                    advise (NULLCP, "serialNumber %s%s", PEPY_ERR_BAD_INTEGER,
                            pe_error (p120 -> pe_errno));
                    return NOTOK;
                }
                (*parm) -> serialnumber  = p121;
            }
        }
        else {
            advise (NULLCP, "TBSCertificate %sserialNumber element", PEPY_ERR_MISSING);
            return NOTOK;
        }

    }

    {
        register PE p122;

        if ((p122 = (pe != p116 ? next_member (pe, p116) : first_member (pe))) != NULLPE) {
            p116 = p122;

            {	/* signature */
#ifdef DEBUG
                (void) testdebug (p122, "signature");
#endif

                if (parse_SEC_AlgorithmIdentifier (p122, 1, NULLIP, NULLVP, &((*parm) -> signatureAI)) == NOTOK)
                    return NOTOK;
            }
        }
        else {
            advise (NULLCP, "TBSCertificate %ssignature element", PEPY_ERR_MISSING);
            return NOTOK;
        }

    }

    {
        register PE p123;

        if ((p123 = (pe != p116 ? next_member (pe, p116) : first_member (pe))) != NULLPE) {
            p116 = p123;

            {	/* issuer */
#ifdef DEBUG
                (void) testdebug (p123, "issuer");
#endif

                if (parse_IF_Name (p123, 1, NULLIP, NULLVP, &((*parm) -> issuer)) == NOTOK)
                    return NOTOK;
            }
        }
        else {
            advise (NULLCP, "TBSCertificate %sissuer element", PEPY_ERR_MISSING);
            return NOTOK;
        }

    }

    {
        register PE p124;

        if ((p124 = (pe != p116 ? next_member (pe, p116) : first_member (pe))) != NULLPE) {
            p116 = p124;

            {	/* validity */
#ifdef DEBUG
                (void) testdebug (p124, "validity");
#endif

                if (parse_AF_Validity (p124, 1, NULLIP, NULLVP, (*parm) ) == NOTOK)
                    return NOTOK;
            }
        }
        else {
            advise (NULLCP, "TBSCertificate %svalidity element", PEPY_ERR_MISSING);
            return NOTOK;
        }

    }

    {
        register PE p125;

        if ((p125 = (pe != p116 ? next_member (pe, p116) : first_member (pe))) != NULLPE) {
            p116 = p125;

            {	/* subject */
#ifdef DEBUG
                (void) testdebug (p125, "subject");
#endif

                if (parse_IF_Name (p125, 1, NULLIP, NULLVP, &((*parm) -> subject)) == NOTOK)
                    return NOTOK;
            }
        }
        else {
            advise (NULLCP, "TBSCertificate %ssubject element", PEPY_ERR_MISSING);
            return NOTOK;
        }

    }

    {
        register PE p126;

        if ((p126 = (pe != p116 ? next_member (pe, p116) : first_member (pe))) != NULLPE) {
            p116 = p126;

            {	/* subjectPublickeyInfo */
#ifdef DEBUG
                (void) testdebug (p126, "subjectPublickeyInfo");
#endif

                if (parse_SEC_KeyInfo (p126, 1, NULLIP, NULLVP, ((*parm) -> subjectPK)) == NOTOK)
                    return NOTOK;
            }
        }
        else {
            advise (NULLCP, "TBSCertificate %ssubjectPublickeyInfo element", PEPY_ERR_MISSING);
            return NOTOK;
        }

    }

    {
        register PE p127;

        if ((p127 = (pe != p116 ? next_member (pe, p116) : first_member (pe))) != NULLPE) {
            p116 = p127;

            {	/* authatts */
#ifdef DEBUG
                (void) testdebug (p127, "authatts");
#endif

                if (parse_AF_AuthorisationAttributes (p127, 1, NULLIP, NULLVP, &((*parm) -> authatts) ) == NOTOK)
                    return NOTOK;
            }
        }
    }


    if (pe -> pe_cardinal > 8) {
        advise (NULLCP, "TBSCertificate %s(8): %d", PEPY_ERR_TOO_MANY_ELEMENTS,
                pe -> pe_cardinal);
        return NOTOK;
    }

    return OK;
}

/* ARGSUSED */

int	parse_AF_AuthorisationAttributes (pe, explicit, len, buffer, parm)
register PE	pe;
int	explicit;
int    *len;
char  **buffer;
AuthorisationAttributes ** parm;
{
    register PE p128;

#ifdef DEBUG
    (void) testdebug (pe, "AF.AuthorisationAttributes");
#endif

    if (explicit) {
        if (pe -> pe_class != PE_CLASS_UNIV
                || pe -> pe_form != PE_FORM_CONS
                || pe -> pe_id != PE_CONS_SEQ) {
            advise (NULLCP, "AuthorisationAttributes bad class/form/id: %s/%d/0x%x",
                    pe_classlist[pe -> pe_class], pe -> pe_form, pe -> pe_id);
            return NOTOK;
        }
    }
    else
        if (pe -> pe_form != PE_FORM_CONS) {
            advise (NULLCP, "AuthorisationAttributes bad form: %d", pe -> pe_form);
            return NOTOK;
        }

    {
# line 731 "AF.py.COSINE"

        if ((*(parm) = (AuthorisationAttributes *)
                calloc (1, sizeof **(parm))) == ((AuthorisationAttributes *) 0)) {
            advise (NULLCP, "out of memory");
            return NOTOK;
        }
    
    }
    if ((p128 = prim2seq (pe)) == NULLPE) {
        advise (NULLCP, "AuthorisationAttributes %s%s", PEPY_ERR_BAD_SEQ,
                pe_error (pe -> pe_errno));
        return NOTOK;
    }
    pe = p128;

    {
        register PE p129;

        if ((p129 = first_member (pe)) != NULLPE) {
            p128 = p129;

            {	/* country */
#ifdef DEBUG
                (void) testdebug (p129, "country");
#endif

                if (parse_UNIV_PrintableString (p129, 1, NULLIP, &((*parm) -> country), NullParm) == NOTOK)
                    return NOTOK;
            }
        }
        else {
            advise (NULLCP, "AuthorisationAttributes %scountry element", PEPY_ERR_MISSING);
            return NOTOK;
        }

    }

    {
        register PE p130;

        if ((p130 = (pe != p128 ? next_member (pe, p128) : first_member (pe))) != NULLPE) {
            p128 = p130;

            {	/* group */
#ifdef DEBUG
                (void) testdebug (p130, "group");
#endif

                if (parse_UNIV_PrintableString (p130, 1, NULLIP, &((*parm) -> group), NullParm) == NOTOK)
                    return NOTOK;
            }
        }
        else {
            advise (NULLCP, "AuthorisationAttributes %sgroup element", PEPY_ERR_MISSING);
            return NOTOK;
        }

    }

    {
        register PE p131;

        if ((p131 = (pe != p128 ? next_member (pe, p128) : first_member (pe))) != NULLPE) {
            p128 = p131;

            {	/* class */
                register integer p132;

#ifdef DEBUG
                (void) testdebug (p131, "class");
#endif

                if (p131 -> pe_class != PE_CLASS_UNIV
                        || p131 -> pe_form != PE_FORM_PRIM
                        || p131 -> pe_id != PE_PRIM_INT) {
                    advise (NULLCP, "class bad class/form/id: %s/%d/0x%x",
                            pe_classlist[p131 -> pe_class], p131 -> pe_form, p131 -> pe_id);
                    return NOTOK;
                }

                if ((p132 = prim2num (p131)) == NOTOK
                        && p131 -> pe_errno != PE_ERR_NONE) {
                    advise (NULLCP, "class %s%s", PEPY_ERR_BAD_INTEGER,
                            pe_error (p131 -> pe_errno));
                    return NOTOK;
                }
                (*parm) -> class = p132;
                switch (p132) {
                    case 0:	/* normal */
                        break;
                    case 1:	/* privileged */
                        break;
                }
            }
        }
        else {
            advise (NULLCP, "AuthorisationAttributes %sclass element", PEPY_ERR_MISSING);
            return NOTOK;
        }

    }


    if (pe -> pe_cardinal > 3) {
        advise (NULLCP, "AuthorisationAttributes %s(3): %d", PEPY_ERR_TOO_MANY_ELEMENTS,
                pe -> pe_cardinal);
        return NOTOK;
    }

    return OK;
}

/* ARGSUSED */

int	parse_AF_Certificate (pe, explicit, len, buffer, parm)
register PE	pe;
int	explicit;
int    *len;
char  **buffer;
Certificate ** parm;
{
    register PE p133;

#ifdef DEBUG
    (void) testdebug (pe, "AF.Certificate");
#endif

    if (explicit) {
        if (pe -> pe_class != PE_CLASS_UNIV
                || pe -> pe_form != PE_FORM_CONS
                || pe -> pe_id != PE_CONS_SEQ) {
            advise (NULLCP, "Certificate bad class/form/id: %s/%d/0x%x",
                    pe_classlist[pe -> pe_class], pe -> pe_form, pe -> pe_id);
            return NOTOK;
        }
    }
    else
        if (pe -> pe_form != PE_FORM_CONS) {
            advise (NULLCP, "Certificate bad form: %d", pe -> pe_form);
            return NOTOK;
        }

    {
# line 758 "AF.py.COSINE"

        if ((*(parm) = (Certificate *)
                calloc (1, sizeof **(parm))) == ((Certificate *) 0)) {
            advise (NULLCP, "out of memory");
            return NOTOK;
        }
        if (((*parm)->sig = (Signature *)
                calloc (1, sizeof (Signature))) == ((Signature *) 0)) {
            advise (NULLCP, "out of memory");
            return NOTOK;
        }
    
    }
    if ((p133 = prim2seq (pe)) == NULLPE) {
        advise (NULLCP, "Certificate %s%s", PEPY_ERR_BAD_SEQ,
                pe_error (pe -> pe_errno));
        return NOTOK;
    }
    pe = p133;

    {
        register PE p134;

        if ((p134 = first_member (pe)) != NULLPE) {
            p133 = p134;

            {
#ifdef DEBUG
                (void) testdebug (p134, "element");
#endif

                if (parse_AF_TBSCertificate (p134, 1, NULLIP, NULLVP, &((*parm)->tbs) ) == NOTOK)
                    return NOTOK;
                {
# line 773 "AF.py.COSINE"
 /* set x509_tbs */
		(*parm)->tbs_DERcode = aux_PE2OctetString(p134);
		if( (*parm)->tbs_DERcode == (OctetString *)0 ) return NOTOK;
	   
                }
            }
        }
        else {
            advise (NULLCP, "Certificate %selement", PEPY_ERR_MISSING);
            return NOTOK;
        }

    }

    {
        register PE p135;

        if ((p135 = (pe != p133 ? next_member (pe, p133) : first_member (pe))) != NULLPE) {
            p133 = p135;

            {
#ifdef DEBUG
                (void) testdebug (p135, "element");
#endif

                if (parse_SEC_AlgorithmIdentifier (p135, 1, NULLIP, NULLVP, &((*parm) -> sig->signAI)) == NOTOK)
                    return NOTOK;
            }
        }
        else {
            advise (NULLCP, "Certificate %selement", PEPY_ERR_MISSING);
            return NOTOK;
        }

    }

    {
        register PE p136;

        if ((p136 = (pe != p133 ? next_member (pe, p133) : first_member (pe))) != NULLPE) {
            p133 = p136;

            {
                register PE p137;

#ifdef DEBUG
                (void) testdebug (p136, "element");
#endif

                if (p136 -> pe_class != PE_CLASS_UNIV || p136 -> pe_id != PE_PRIM_BITS) {
                    advise (NULLCP, "element bad class/form/id: %s/%d/0x%x",
                            pe_classlist[p136 -> pe_class], p136 -> pe_form, p136 -> pe_id);
                    return NOTOK;
                }

                if ((p137 = prim2bit (p136)) == NULLPE) {
                    advise (NULLCP, "element %s%s", PEPY_ERR_BAD_BITS,
                            pe_error (p136 -> pe_errno));
                    return NOTOK;
                }
                (*parm)->sig->signature.bits  = bitstr2strb (p136, &(
		     (*parm)->sig->signature.nbits ));
            }
        }
        else {
            advise (NULLCP, "Certificate %selement", PEPY_ERR_MISSING);
            return NOTOK;
        }

    }


    if (pe -> pe_cardinal > 3) {
        advise (NULLCP, "Certificate %s(3): %d", PEPY_ERR_TOO_MANY_ELEMENTS,
                pe -> pe_cardinal);
        return NOTOK;
    }

    return OK;
}

/* ARGSUSED */

int	parse_AF_Certificates (pe, explicit, len, buffer, parm)
register PE	pe;
int	explicit;
int    *len;
char  **buffer;
Certificates ** parm;
{
    register PE p138;

#ifdef DEBUG
    (void) testdebug (pe, "AF.Certificates");
#endif

    if (explicit) {
        if (pe -> pe_class != PE_CLASS_UNIV
                || pe -> pe_form != PE_FORM_CONS
                || pe -> pe_id != PE_CONS_SEQ) {
            advise (NULLCP, "Certificates bad class/form/id: %s/%d/0x%x",
                    pe_classlist[pe -> pe_class], pe -> pe_form, pe -> pe_id);
            return NOTOK;
        }
    }
    else
        if (pe -> pe_form != PE_FORM_CONS) {
            advise (NULLCP, "Certificates bad form: %d", pe -> pe_form);
            return NOTOK;
        }

    {
# line 788 "AF.py.COSINE"

        if ((*(parm) = (Certificates *)
                calloc (1, sizeof **(parm))) == ((Certificates *) 0)) {
            advise (NULLCP, "out of memory");
            return NOTOK;
        }
    
    }
    if ((p138 = prim2seq (pe)) == NULLPE) {
        advise (NULLCP, "Certificates %s%s", PEPY_ERR_BAD_SEQ,
                pe_error (pe -> pe_errno));
        return NOTOK;
    }
    pe = p138;

    {
        register PE p139;

        if ((p139 = first_member (pe)) != NULLPE) {
            p138 = p139;

            {	/* certificate */
#ifdef DEBUG
                (void) testdebug (p139, "certificate");
#endif

                if (parse_AF_Certificate (p139, 1, NULLIP, NULLVP, &((*parm) -> usercertificate)) == NOTOK)
                    return NOTOK;
            }
        }
        else {
            advise (NULLCP, "Certificates %scertificate element", PEPY_ERR_MISSING);
            return NOTOK;
        }

    }

    {
        register PE p140;

        if ((p140 = (pe != p138 ? next_member (pe, p138) : first_member (pe))) != NULLPE) {
            p138 = p140;

            {	/* certificationPath */
#ifdef DEBUG
                (void) testdebug (p140, "certificationPath");
#endif

                if (parse_AF_ForwardCertificationPath (p140, 1, NULLIP, NULLVP, &((*parm) -> forwardpath)) == NOTOK)
                    return NOTOK;
            }
        }
    }


    if (pe -> pe_cardinal > 2) {
        advise (NULLCP, "Certificates %s(2): %d", PEPY_ERR_TOO_MANY_ELEMENTS,
                pe -> pe_cardinal);
        return NOTOK;
    }

    return OK;
}

/* ARGSUSED */

int	parse_AF_ForwardCertificationPath (pe, explicit, len, buffer, parm)
register PE	pe;
int	explicit;
int    *len;
char  **buffer;
FCPath ** parm;
{
    register PE p141;

#ifdef DEBUG
    (void) testdebug (pe, "AF.ForwardCertificationPath");
#endif

    if (explicit) {
        if (pe -> pe_class != PE_CLASS_UNIV
                || pe -> pe_form != PE_FORM_CONS
                || pe -> pe_id != PE_CONS_SEQ) {
            advise (NULLCP, "ForwardCertificationPath bad class/form/id: %s/%d/0x%x",
                    pe_classlist[pe -> pe_class], pe -> pe_form, pe -> pe_id);
            return NOTOK;
        }
    }
    else
        if (pe -> pe_form != PE_FORM_CONS) {
            advise (NULLCP, "ForwardCertificationPath bad form: %d", pe -> pe_form);
            return NOTOK;
        }

    if ((p141 = prim2seq (pe)) == NULLPE) {
        advise (NULLCP, "ForwardCertificationPath %s%s", PEPY_ERR_BAD_SEQ,
                pe_error (pe -> pe_errno));
        return NOTOK;
    }
    pe = p141;

    for (p141 = first_member (pe); p141; p141 = next_member (pe, p141)) {
        {
# line 809 "AF.py.COSINE"

                if ((*(parm) = (FCPath *)
                        calloc (1, sizeof **(parm))) == ((FCPath *) 0)) {
                    advise (NULLCP, "out of memory");
                    return NOTOK;
                }
            
        }
        {
#ifdef DEBUG
            (void) testdebug (p141, "element");
#endif

            if (parse_AF_CertificateSet (p141, 1, NULLIP, NULLVP, &((*parm) -> liste)) == NOTOK)
                return NOTOK;
            {
# line 818 "AF.py.COSINE"
 parm = &((*parm) -> next_forwardpath); 
            }
        }
    }

    return OK;
}

/* ARGSUSED */

int	parse_AF_CertificateSet (pe, explicit, len, buffer, parm)
register PE	pe;
int	explicit;
int    *len;
char  **buffer;
SET_OF_Certificate ** parm;
{
    register PE p142;

#ifdef DEBUG
    (void) testdebug (pe, "AF.CertificateSet");
#endif

    if (explicit) {
        if (pe -> pe_class != PE_CLASS_UNIV
                || pe -> pe_form != PE_FORM_CONS
                || pe -> pe_id != PE_CONS_SET) {
            advise (NULLCP, "CertificateSet bad class/form/id: %s/%d/0x%x",
                    pe_classlist[pe -> pe_class], pe -> pe_form, pe -> pe_id);
            return NOTOK;
        }
    }
    else
        if (pe -> pe_form != PE_FORM_CONS) {
            advise (NULLCP, "CertificateSet bad form: %d", pe -> pe_form);
            return NOTOK;
        }

    if ((p142 = prim2set (pe)) == NULLPE) {
        advise (NULLCP, "CertificateSet %s%s", PEPY_ERR_BAD_SET,
                pe_error (pe -> pe_errno));
        return NOTOK;
    }
    pe = p142;

    for (p142 = first_member (pe); p142; p142 = next_member (pe, p142)) {
        {
# line 823 "AF.py.COSINE"

                if ((*(parm) = (SET_OF_Certificate *)
                        calloc (1, sizeof **(parm))) == ((SET_OF_Certificate *) 0)) {
                    advise (NULLCP, "out of memory");
                    return NOTOK;
                }
            
        }
        {
#ifdef DEBUG
            (void) testdebug (p142, "member");
#endif

            if (parse_AF_Certificate (p142, 1, NULLIP, NULLVP, &((*parm) -> element)) == NOTOK)
                return NOTOK;
            {
# line 832 "AF.py.COSINE"
 parm = &((*parm) -> next); 
            }
        }
    }

    return OK;
}

/* ARGSUSED */

int	parse_AF_CertificatePair (pe, explicit, len, buffer, parm)
register PE	pe;
int	explicit;
int    *len;
char  **buffer;
CertificatePair ** parm;
{
    register PE p143;

#ifdef DEBUG
    (void) testdebug (pe, "AF.CertificatePair");
#endif

    if (explicit) {
        if (pe -> pe_class != PE_CLASS_UNIV
                || pe -> pe_form != PE_FORM_CONS
                || pe -> pe_id != PE_CONS_SEQ) {
            advise (NULLCP, "CertificatePair bad class/form/id: %s/%d/0x%x",
                    pe_classlist[pe -> pe_class], pe -> pe_form, pe -> pe_id);
            return NOTOK;
        }
    }
    else
        if (pe -> pe_form != PE_FORM_CONS) {
            advise (NULLCP, "CertificatePair bad form: %d", pe -> pe_form);
            return NOTOK;
        }

    {
# line 836 "AF.py.COSINE"

        if ((*(parm) = (CertificatePair *)
                calloc (1, sizeof **(parm))) == ((CertificatePair *) 0)) {
            advise (NULLCP, "out of memory");
            return NOTOK;
        }
    
    }
    if ((p143 = prim2seq (pe)) == NULLPE) {
        advise (NULLCP, "CertificatePair %s%s", PEPY_ERR_BAD_SEQ,
                pe_error (pe -> pe_errno));
        return NOTOK;
    }
    pe = p143;

    {
        register PE p144;

        if ((p144 = first_member (pe)) != NULLPE
                && PE_ID (p144 -> pe_class, p144 -> pe_id)
                        != PE_ID (PE_CLASS_CONT, 0))
            p144 = NULLPE;
        if (p144 != NULLPE) {
            p143 = p144;

            {	/* element TAG PULLUP */
                register PE p145;

                if ((p145 = prim2set (p144)) == NULLPE) {
                    advise (NULLCP, "forward %selement: %s", PEPY_ERR_BAD,
                            pe_error (p144 -> pe_errno));
                    return NOTOK;
                }
                if (p145 -> pe_cardinal != 1) {
                    advise (NULLCP, "forward %s element: %d", PEPY_ERR_TOO_MANY_TAGGED,
                            p145 -> pe_cardinal);
                    return NOTOK;
                }
                p144 = first_member (p145);
            }
            {	/* forward */
#ifdef DEBUG
                (void) testdebug (p144, "forward");
#endif

                if (parse_AF_Certificate (p144, 1, NULLIP, NULLVP, &((*parm) -> forward)) == NOTOK)
                    return NOTOK;
            }
        }
    }

    {
        register PE p146;

        if ((p146 = (pe != p143 ? next_member (pe, p143) : first_member (pe))) != NULLPE) {
            p143 = p146;

            {	/* element TAG PULLUP */
                register PE p147;

                if ((p147 = prim2set (p146)) == NULLPE) {
                    advise (NULLCP, "reverse %selement: %s", PEPY_ERR_BAD,
                            pe_error (p146 -> pe_errno));
                    return NOTOK;
                }
                if (p147 -> pe_cardinal != 1) {
                    advise (NULLCP, "reverse %s element: %d", PEPY_ERR_TOO_MANY_TAGGED,
                            p147 -> pe_cardinal);
                    return NOTOK;
                }
                p146 = first_member (p147);
            }
            {	/* reverse */
#ifdef DEBUG
                (void) testdebug (p146, "reverse");
#endif

                if (parse_AF_Certificate (p146, 1, NULLIP, NULLVP, &((*parm) -> reverse)) == NOTOK)
                    return NOTOK;
            }
        }
    }


    if (pe -> pe_cardinal > 2) {
        advise (NULLCP, "CertificatePair %s(2): %d", PEPY_ERR_TOO_MANY_ELEMENTS,
                pe -> pe_cardinal);
        return NOTOK;
    }

    return OK;
}

/* ARGSUSED */

int	parse_AF_CrossCertificatePair (pe, explicit, len, buffer, parm)
register PE	pe;
int	explicit;
int    *len;
char  **buffer;
SET_OF_CertificatePair ** parm;
{
    register PE p148;

#ifdef DEBUG
    (void) testdebug (pe, "AF.CrossCertificatePair");
#endif

    if (explicit) {
        if (pe -> pe_class != PE_CLASS_UNIV
                || pe -> pe_form != PE_FORM_CONS
                || pe -> pe_id != PE_CONS_SET) {
            advise (NULLCP, "CrossCertificatePair bad class/form/id: %s/%d/0x%x",
                    pe_classlist[pe -> pe_class], pe -> pe_form, pe -> pe_id);
            return NOTOK;
        }
    }
    else
        if (pe -> pe_form != PE_FORM_CONS) {
            advise (NULLCP, "CrossCertificatePair bad form: %d", pe -> pe_form);
            return NOTOK;
        }

    if ((p148 = prim2set (pe)) == NULLPE) {
        advise (NULLCP, "CrossCertificatePair %s%s", PEPY_ERR_BAD_SET,
                pe_error (pe -> pe_errno));
        return NOTOK;
    }
    pe = p148;

    for (p148 = first_member (pe); p148; p148 = next_member (pe, p148)) {
        {
# line 858 "AF.py.COSINE"

                if ((*(parm) = (SET_OF_CertificatePair *)
                        calloc (1, sizeof **(parm))) == ((SET_OF_CertificatePair *) 0)) {
                    advise (NULLCP, "out of memory");
                    return NOTOK;
                }
            
        }
        {
#ifdef DEBUG
            (void) testdebug (p148, "member");
#endif

            if (parse_AF_CertificatePair (p148, 1, NULLIP, NULLVP, &((*parm) -> element)) == NOTOK)
                return NOTOK;
            {
# line 867 "AF.py.COSINE"
 parm = &((*parm) -> next); 
            }
        }
    }

    return OK;
}

/* ARGSUSED */

int	parse_AF_PKList (pe, explicit, len, buffer, parm)
register PE	pe;
int	explicit;
int    *len;
char  **buffer;
PKList ** parm;
{
    register PE p149;

#ifdef DEBUG
    (void) testdebug (pe, "AF.PKList");
#endif

    if (explicit) {
        if (pe -> pe_class != PE_CLASS_UNIV
                || pe -> pe_form != PE_FORM_CONS
                || pe -> pe_id != PE_CONS_SET) {
            advise (NULLCP, "PKList bad class/form/id: %s/%d/0x%x",
                    pe_classlist[pe -> pe_class], pe -> pe_form, pe -> pe_id);
            return NOTOK;
        }
    }
    else
        if (pe -> pe_form != PE_FORM_CONS) {
            advise (NULLCP, "PKList bad form: %d", pe -> pe_form);
            return NOTOK;
        }

    if ((p149 = prim2set (pe)) == NULLPE) {
        advise (NULLCP, "PKList %s%s", PEPY_ERR_BAD_SET,
                pe_error (pe -> pe_errno));
        return NOTOK;
    }
    pe = p149;

    for (p149 = first_member (pe); p149; p149 = next_member (pe, p149)) {
        {
# line 872 "AF.py.COSINE"

                if ((*(parm) = (PKList *)
                        calloc (1, sizeof **(parm))) == ((PKList *) 0)) {
                    advise (NULLCP, "out of memory");
                    return NOTOK;
                }
            
        }
        {
#ifdef DEBUG
            (void) testdebug (p149, "member");
#endif

            if (parse_AF_TBSCertificate (p149, 1, NULLIP, NULLVP, &((*parm) -> element)) == NOTOK)
                return NOTOK;
            {
# line 881 "AF.py.COSINE"
 parm = &((*parm) -> next); 
            }
        }
    }

    return OK;
}

/* ARGSUSED */

int	parse_AF_TBSCrl (pe, explicit, len, buffer, parm)
register PE	pe;
int	explicit;
int    *len;
char  **buffer;
CrlTBS ** parm;
{
    register PE p150;

#ifdef DEBUG
    (void) testdebug (pe, "AF.TBSCrl");
#endif

    if (explicit) {
        if (pe -> pe_class != PE_CLASS_UNIV
                || pe -> pe_form != PE_FORM_CONS
                || pe -> pe_id != PE_CONS_SEQ) {
            advise (NULLCP, "TBSCrl bad class/form/id: %s/%d/0x%x",
                    pe_classlist[pe -> pe_class], pe -> pe_form, pe -> pe_id);
            return NOTOK;
        }
    }
    else
        if (pe -> pe_form != PE_FORM_CONS) {
            advise (NULLCP, "TBSCrl bad form: %d", pe -> pe_form);
            return NOTOK;
        }

    {
# line 886 "AF.py.COSINE"

            if ((*(parm) = (CrlTBS *)
                    calloc (1, sizeof **(parm))) == ((CrlTBS *) 0)) {
                advise (NULLCP, "out of memory");
                return NOTOK;
            }
	    (*parm)->revokedcertificates = (SEQUENCE_OF_RevCert *)0;
	
    }
    if ((p150 = prim2seq (pe)) == NULLPE) {
        advise (NULLCP, "TBSCrl %s%s", PEPY_ERR_BAD_SEQ,
                pe_error (pe -> pe_errno));
        return NOTOK;
    }
    pe = p150;

    {
        register PE p151;

        if ((p151 = first_member (pe)) != NULLPE) {
            p150 = p151;

            {	/* signature */
#ifdef DEBUG
                (void) testdebug (p151, "signature");
#endif

                if (parse_SEC_AlgorithmIdentifier (p151, 1, NULLIP, NULLVP, &((*parm)->signatureAI) ) == NOTOK)
                    return NOTOK;
            }
        }
        else {
            advise (NULLCP, "TBSCrl %ssignature element", PEPY_ERR_MISSING);
            return NOTOK;
        }

    }

    {
        register PE p152;

        if ((p152 = (pe != p150 ? next_member (pe, p150) : first_member (pe))) != NULLPE) {
            p150 = p152;

            {	/* issuer */
#ifdef DEBUG
                (void) testdebug (p152, "issuer");
#endif

                if (parse_IF_Name (p152, 1, NULLIP, NULLVP, &((*parm)->issuer) ) == NOTOK)
                    return NOTOK;
            }
        }
        else {
            advise (NULLCP, "TBSCrl %sissuer element", PEPY_ERR_MISSING);
            return NOTOK;
        }

    }

    {
        register PE p153;

        if ((p153 = (pe != p150 ? next_member (pe, p150) : first_member (pe))) != NULLPE) {
            p150 = p153;

            {	/* lastUpdate */
#ifdef DEBUG
                (void) testdebug (p153, "lastUpdate");
#endif

                if (parse_UNIV_UTCTime (p153, 1, NULLIP, &(((*parm)->lastupdate) ), NullParm) == NOTOK)
                    return NOTOK;
            }
        }
        else {
            advise (NULLCP, "TBSCrl %slastUpdate element", PEPY_ERR_MISSING);
            return NOTOK;
        }

    }

    {
        register PE p154;

        if ((p154 = (pe != p150 ? next_member (pe, p150) : first_member (pe))) != NULLPE) {
            p150 = p154;

            {	/* revokedCertificates */
#ifdef DEBUG
                (void) testdebug (p154, "revokedCertificates");
#endif

                if (parse_AF_RevCertSequence (p154, 1, NULLIP, NULLVP, &((*parm)->revokedcertificates) ) == NOTOK)
                    return NOTOK;
            }
        }
    }


    if (pe -> pe_cardinal > 4) {
        advise (NULLCP, "TBSCrl %s(4): %d", PEPY_ERR_TOO_MANY_ELEMENTS,
                pe -> pe_cardinal);
        return NOTOK;
    }

    return OK;
}

/* ARGSUSED */

int	parse_AF_Crl (pe, explicit, len, buffer, parm)
register PE	pe;
int	explicit;
int    *len;
char  **buffer;
Crl ** parm;
{
    register PE p155;

#ifdef DEBUG
    (void) testdebug (pe, "AF.Crl");
#endif

    if (explicit) {
        if (pe -> pe_class != PE_CLASS_UNIV
                || pe -> pe_form != PE_FORM_CONS
                || pe -> pe_id != PE_CONS_SEQ) {
            advise (NULLCP, "Crl bad class/form/id: %s/%d/0x%x",
                    pe_classlist[pe -> pe_class], pe -> pe_form, pe -> pe_id);
            return NOTOK;
        }
    }
    else
        if (pe -> pe_form != PE_FORM_CONS) {
            advise (NULLCP, "Crl bad form: %d", pe -> pe_form);
            return NOTOK;
        }

    {
# line 916 "AF.py.COSINE"

            if ((*(parm) = (Crl *)
                    calloc (1, sizeof **(parm))) == ((Crl *) 0)) {
                advise (NULLCP, "out of memory");
                return NOTOK;
            }
            if (((*parm)->sig = (Signature *)
                    calloc (1, sizeof (Signature))) == ((Signature *) 0)) {
                advise (NULLCP, "out of memory");
                return NOTOK;
            }
        
    }
    if ((p155 = prim2seq (pe)) == NULLPE) {
        advise (NULLCP, "Crl %s%s", PEPY_ERR_BAD_SEQ,
                pe_error (pe -> pe_errno));
        return NOTOK;
    }
    pe = p155;

    {
        register PE p156;

        if ((p156 = first_member (pe)) != NULLPE) {
            p155 = p156;

            {
#ifdef DEBUG
                (void) testdebug (p156, "element");
#endif

                if (parse_AF_TBSCrl (p156, 1, NULLIP, NULLVP, &((*parm)->tbs) ) == NOTOK)
                    return NOTOK;
                {
# line 932 "AF.py.COSINE"
 /* set x509_tbs */
		(*parm)->tbs_DERcode = aux_PE2OctetString(p156);
		if ( (*parm)->tbs_DERcode == (OctetString *)0 ) return NOTOK;
	   
                }
            }
        }
        else {
            advise (NULLCP, "Crl %selement", PEPY_ERR_MISSING);
            return NOTOK;
        }

    }

    {
        register PE p157;

        if ((p157 = (pe != p155 ? next_member (pe, p155) : first_member (pe))) != NULLPE) {
            p155 = p157;

            {
#ifdef DEBUG
                (void) testdebug (p157, "element");
#endif

                if (parse_SEC_AlgorithmIdentifier (p157, 1, NULLIP, NULLVP, &((*parm)->sig->signAI) ) == NOTOK)
                    return NOTOK;
            }
        }
        else {
            advise (NULLCP, "Crl %selement", PEPY_ERR_MISSING);
            return NOTOK;
        }

    }

    {
        register PE p158;

        if ((p158 = (pe != p155 ? next_member (pe, p155) : first_member (pe))) != NULLPE) {
            p155 = p158;

            {
                register PE p159;

#ifdef DEBUG
                (void) testdebug (p158, "element");
#endif

                if (p158 -> pe_class != PE_CLASS_UNIV || p158 -> pe_id != PE_PRIM_BITS) {
                    advise (NULLCP, "element bad class/form/id: %s/%d/0x%x",
                            pe_classlist[p158 -> pe_class], p158 -> pe_form, p158 -> pe_id);
                    return NOTOK;
                }

                if ((p159 = prim2bit (p158)) == NULLPE) {
                    advise (NULLCP, "element %s%s", PEPY_ERR_BAD_BITS,
                            pe_error (p158 -> pe_errno));
                    return NOTOK;
                }
                (*parm)->sig->signature.bits  = bitstr2strb (p158, &(
		     (*parm)->sig->signature.nbits ));
            }
        }
        else {
            advise (NULLCP, "Crl %selement", PEPY_ERR_MISSING);
            return NOTOK;
        }

    }


    if (pe -> pe_cardinal > 3) {
        advise (NULLCP, "Crl %s(3): %d", PEPY_ERR_TOO_MANY_ELEMENTS,
                pe -> pe_cardinal);
        return NOTOK;
    }

    return OK;
}

/* ARGSUSED */

int	parse_AF_TBSRevCert (pe, explicit, len, buffer, parm)
register PE	pe;
int	explicit;
int    *len;
char  **buffer;
RevCertTBS ** parm;
{
    register PE p160;

#ifdef DEBUG
    (void) testdebug (pe, "AF.TBSRevCert");
#endif

    if (explicit) {
        if (pe -> pe_class != PE_CLASS_UNIV
                || pe -> pe_form != PE_FORM_CONS
                || pe -> pe_id != PE_CONS_SEQ) {
            advise (NULLCP, "TBSRevCert bad class/form/id: %s/%d/0x%x",
                    pe_classlist[pe -> pe_class], pe -> pe_form, pe -> pe_id);
            return NOTOK;
        }
    }
    else
        if (pe -> pe_form != PE_FORM_CONS) {
            advise (NULLCP, "TBSRevCert bad form: %d", pe -> pe_form);
            return NOTOK;
        }

    {
# line 948 "AF.py.COSINE"

            if ((*(parm) = (RevCertTBS *)
                    calloc (1, sizeof **(parm))) == ((RevCertTBS *) 0)) {
                advise (NULLCP, "out of memory");
                return NOTOK;
            }
	
    }
    if ((p160 = prim2seq (pe)) == NULLPE) {
        advise (NULLCP, "TBSRevCert %s%s", PEPY_ERR_BAD_SEQ,
                pe_error (pe -> pe_errno));
        return NOTOK;
    }
    pe = p160;

    {
        register PE p161;

        if ((p161 = first_member (pe)) != NULLPE) {
            p160 = p161;

            {	/* signature */
#ifdef DEBUG
                (void) testdebug (p161, "signature");
#endif

                if (parse_SEC_AlgorithmIdentifier (p161, 1, NULLIP, NULLVP, &((*parm)->signatureAI) ) == NOTOK)
                    return NOTOK;
            }
        }
        else {
            advise (NULLCP, "TBSRevCert %ssignature element", PEPY_ERR_MISSING);
            return NOTOK;
        }

    }

    {
        register PE p162;

        if ((p162 = (pe != p160 ? next_member (pe, p160) : first_member (pe))) != NULLPE) {
            p160 = p162;

            {	/* issuer */
#ifdef DEBUG
                (void) testdebug (p162, "issuer");
#endif

                if (parse_IF_Name (p162, 1, NULLIP, NULLVP, &((*parm)->issuer) ) == NOTOK)
                    return NOTOK;
            }
        }
        else {
            advise (NULLCP, "TBSRevCert %sissuer element", PEPY_ERR_MISSING);
            return NOTOK;
        }

    }

    {
        register PE p163;

        if ((p163 = (pe != p160 ? next_member (pe, p160) : first_member (pe))) != NULLPE) {
            p160 = p163;

            {	/* subject */
                register integer p164;

#ifdef DEBUG
                (void) testdebug (p163, "subject");
#endif

                if (p163 -> pe_class != PE_CLASS_UNIV
                        || p163 -> pe_form != PE_FORM_PRIM
                        || p163 -> pe_id != PE_PRIM_INT) {
                    advise (NULLCP, "subject bad class/form/id: %s/%d/0x%x",
                            pe_classlist[p163 -> pe_class], p163 -> pe_form, p163 -> pe_id);
                    return NOTOK;
                }

                if ((p164 = prim2num (p163)) == NOTOK
                        && p163 -> pe_errno != PE_ERR_NONE) {
                    advise (NULLCP, "subject %s%s", PEPY_ERR_BAD_INTEGER,
                            pe_error (p163 -> pe_errno));
                    return NOTOK;
                }
                (*parm)->subject  = p164;
            }
        }
        else {
            advise (NULLCP, "TBSRevCert %ssubject element", PEPY_ERR_MISSING);
            return NOTOK;
        }

    }

    {
        register PE p165;

        if ((p165 = (pe != p160 ? next_member (pe, p160) : first_member (pe))) != NULLPE) {
            p160 = p165;

            {	/* revocationDate */
#ifdef DEBUG
                (void) testdebug (p165, "revocationDate");
#endif

                if (parse_UNIV_UTCTime (p165, 1, NULLIP, &(((*parm)->revocationdate) ), NullParm) == NOTOK)
                    return NOTOK;
            }
        }
        else {
            advise (NULLCP, "TBSRevCert %srevocationDate element", PEPY_ERR_MISSING);
            return NOTOK;
        }

    }


    if (pe -> pe_cardinal > 4) {
        advise (NULLCP, "TBSRevCert %s(4): %d", PEPY_ERR_TOO_MANY_ELEMENTS,
                pe -> pe_cardinal);
        return NOTOK;
    }

    return OK;
}

/* ARGSUSED */

int	parse_AF_RevCert (pe, explicit, len, buffer, parm)
register PE	pe;
int	explicit;
int    *len;
char  **buffer;
RevCert ** parm;
{
    register PE p166;

#ifdef DEBUG
    (void) testdebug (pe, "AF.RevCert");
#endif

    if (explicit) {
        if (pe -> pe_class != PE_CLASS_UNIV
                || pe -> pe_form != PE_FORM_CONS
                || pe -> pe_id != PE_CONS_SEQ) {
            advise (NULLCP, "RevCert bad class/form/id: %s/%d/0x%x",
                    pe_classlist[pe -> pe_class], pe -> pe_form, pe -> pe_id);
            return NOTOK;
        }
    }
    else
        if (pe -> pe_form != PE_FORM_CONS) {
            advise (NULLCP, "RevCert bad form: %d", pe -> pe_form);
            return NOTOK;
        }

    {
# line 976 "AF.py.COSINE"

            if ((*(parm) = (RevCert *)
                    calloc (1, sizeof **(parm))) == ((RevCert *) 0)) {
                advise (NULLCP, "out of memory");
                return NOTOK;
            }
            if (((*parm)->sig = (Signature *)
                    calloc (1, sizeof (Signature))) == ((Signature *) 0)) {
                advise (NULLCP, "out of memory");
                return NOTOK;
            }
        
    }
    if ((p166 = prim2seq (pe)) == NULLPE) {
        advise (NULLCP, "RevCert %s%s", PEPY_ERR_BAD_SEQ,
                pe_error (pe -> pe_errno));
        return NOTOK;
    }
    pe = p166;

    {
        register PE p167;

        if ((p167 = first_member (pe)) != NULLPE) {
            p166 = p167;

            {
#ifdef DEBUG
                (void) testdebug (p167, "element");
#endif

                if (parse_AF_TBSRevCert (p167, 1, NULLIP, NULLVP, &((*parm)->tbs) ) == NOTOK)
                    return NOTOK;
                {
# line 992 "AF.py.COSINE"
 /* set x509_tbs */
		(*parm)->tbs_DERcode = aux_PE2OctetString(p167);
		if ( (*parm)->tbs_DERcode == (OctetString *)0 ) return NOTOK;
	   
                }
            }
        }
        else {
            advise (NULLCP, "RevCert %selement", PEPY_ERR_MISSING);
            return NOTOK;
        }

    }

    {
        register PE p168;

        if ((p168 = (pe != p166 ? next_member (pe, p166) : first_member (pe))) != NULLPE) {
            p166 = p168;

            {
#ifdef DEBUG
                (void) testdebug (p168, "element");
#endif

                if (parse_SEC_AlgorithmIdentifier (p168, 1, NULLIP, NULLVP, &((*parm)->sig->signAI) ) == NOTOK)
                    return NOTOK;
            }
        }
        else {
            advise (NULLCP, "RevCert %selement", PEPY_ERR_MISSING);
            return NOTOK;
        }

    }

    {
        register PE p169;

        if ((p169 = (pe != p166 ? next_member (pe, p166) : first_member (pe))) != NULLPE) {
            p166 = p169;

            {
                register PE p170;

#ifdef DEBUG
                (void) testdebug (p169, "element");
#endif

                if (p169 -> pe_class != PE_CLASS_UNIV || p169 -> pe_id != PE_PRIM_BITS) {
                    advise (NULLCP, "element bad class/form/id: %s/%d/0x%x",
                            pe_classlist[p169 -> pe_class], p169 -> pe_form, p169 -> pe_id);
                    return NOTOK;
                }

                if ((p170 = prim2bit (p169)) == NULLPE) {
                    advise (NULLCP, "element %s%s", PEPY_ERR_BAD_BITS,
                            pe_error (p169 -> pe_errno));
                    return NOTOK;
                }
                (*parm)->sig->signature.bits  = bitstr2strb (p169, &(
		     (*parm)->sig->signature.nbits ));
            }
        }
        else {
            advise (NULLCP, "RevCert %selement", PEPY_ERR_MISSING);
            return NOTOK;
        }

    }


    if (pe -> pe_cardinal > 3) {
        advise (NULLCP, "RevCert %s(3): %d", PEPY_ERR_TOO_MANY_ELEMENTS,
                pe -> pe_cardinal);
        return NOTOK;
    }

    return OK;
}

/* ARGSUSED */

int	parse_AF_RevCertSequence (pe, explicit, len, buffer, parm)
register PE	pe;
int	explicit;
int    *len;
char  **buffer;
SEQUENCE_OF_RevCert ** parm;
{
    register PE p171;

#ifdef DEBUG
    (void) testdebug (pe, "AF.RevCertSequence");
#endif

    if (explicit) {
        if (pe -> pe_class != PE_CLASS_UNIV
                || pe -> pe_form != PE_FORM_CONS
                || pe -> pe_id != PE_CONS_SEQ) {
            advise (NULLCP, "RevCertSequence bad class/form/id: %s/%d/0x%x",
                    pe_classlist[pe -> pe_class], pe -> pe_form, pe -> pe_id);
            return NOTOK;
        }
    }
    else
        if (pe -> pe_form != PE_FORM_CONS) {
            advise (NULLCP, "RevCertSequence bad form: %d", pe -> pe_form);
            return NOTOK;
        }

    if ((p171 = prim2seq (pe)) == NULLPE) {
        advise (NULLCP, "RevCertSequence %s%s", PEPY_ERR_BAD_SEQ,
                pe_error (pe -> pe_errno));
        return NOTOK;
    }
    pe = p171;

    for (p171 = first_member (pe); p171; p171 = next_member (pe, p171)) {
        {
# line 1009 "AF.py.COSINE"

		if ((*(parm) = (SEQUENCE_OF_RevCert *)
			calloc (1, sizeof **(parm))) == (SEQUENCE_OF_RevCert *) 0) {
                    advise (NULLCP, "out of memory");
                    return NOTOK;
                }
		(*parm) -> next = (SEQUENCE_OF_RevCert *)0;
            
        }
        {
#ifdef DEBUG
            (void) testdebug (p171, "element");
#endif

            if (parse_AF_RevCert (p171, 1, NULLIP, NULLVP, &((*parm) -> element) ) == NOTOK)
                return NOTOK;
            {
# line 1019 "AF.py.COSINE"
 parm = &((*parm) -> next); 
            }
        }
    }

    return OK;
}

/* ARGSUSED */

int	parse_AF_TBSPemCrl (pe, explicit, len, buffer, parm)
register PE	pe;
int	explicit;
int    *len;
char  **buffer;
PemCrlTBS ** parm;
{
    register PE p172;

#ifdef DEBUG
    (void) testdebug (pe, "AF.TBSPemCrl");
#endif

    if (explicit) {
        if (pe -> pe_class != PE_CLASS_UNIV
                || pe -> pe_form != PE_FORM_CONS
                || pe -> pe_id != PE_CONS_SEQ) {
            advise (NULLCP, "TBSPemCrl bad class/form/id: %s/%d/0x%x",
                    pe_classlist[pe -> pe_class], pe -> pe_form, pe -> pe_id);
            return NOTOK;
        }
    }
    else
        if (pe -> pe_form != PE_FORM_CONS) {
            advise (NULLCP, "TBSPemCrl bad form: %d", pe -> pe_form);
            return NOTOK;
        }

    {
# line 1024 "AF.py.COSINE"

            if ((*(parm) = (PemCrlTBS *)
                    calloc (1, sizeof **(parm))) == ((PemCrlTBS *) 0)) {
                advise (NULLCP, "out of memory");
                return NOTOK;
            }
	    (*parm)->revokedCertificates = (SEQUENCE_OF_RevCertPem *)0;
	
    }
    if ((p172 = prim2seq (pe)) == NULLPE) {
        advise (NULLCP, "TBSPemCrl %s%s", PEPY_ERR_BAD_SEQ,
                pe_error (pe -> pe_errno));
        return NOTOK;
    }
    pe = p172;

    {
        register PE p173;

        if ((p173 = first_member (pe)) != NULLPE) {
            p172 = p173;

            {	/* signature */
#ifdef DEBUG
                (void) testdebug (p173, "signature");
#endif

                if (parse_SEC_AlgorithmIdentifier (p173, 1, NULLIP, NULLVP, &((*parm)->signatureAI) ) == NOTOK)
                    return NOTOK;
            }
        }
        else {
            advise (NULLCP, "TBSPemCrl %ssignature element", PEPY_ERR_MISSING);
            return NOTOK;
        }

    }

    {
        register PE p174;

        if ((p174 = (pe != p172 ? next_member (pe, p172) : first_member (pe))) != NULLPE) {
            p172 = p174;

            {	/* issuer */
#ifdef DEBUG
                (void) testdebug (p174, "issuer");
#endif

                if (parse_IF_Name (p174, 1, NULLIP, NULLVP, &((*parm)->issuer) ) == NOTOK)
                    return NOTOK;
            }
        }
        else {
            advise (NULLCP, "TBSPemCrl %sissuer element", PEPY_ERR_MISSING);
            return NOTOK;
        }

    }

    {
        register PE p175;

        if ((p175 = (pe != p172 ? next_member (pe, p172) : first_member (pe))) != NULLPE) {
            p172 = p175;

            {	/* lastUpdate */
#ifdef DEBUG
                (void) testdebug (p175, "lastUpdate");
#endif

                if (parse_UNIV_UTCTime (p175, 1, NULLIP, &(((*parm)->lastUpdate) ), NullParm) == NOTOK)
                    return NOTOK;
            }
        }
        else {
            advise (NULLCP, "TBSPemCrl %slastUpdate element", PEPY_ERR_MISSING);
            return NOTOK;
        }

    }

    {
        register PE p176;

        if ((p176 = (pe != p172 ? next_member (pe, p172) : first_member (pe))) != NULLPE) {
            p172 = p176;

            {	/* nextUpdate */
#ifdef DEBUG
                (void) testdebug (p176, "nextUpdate");
#endif

                if (parse_UNIV_UTCTime (p176, 1, NULLIP, &(((*parm)->nextUpdate) ), NullParm) == NOTOK)
                    return NOTOK;
            }
        }
        else {
            advise (NULLCP, "TBSPemCrl %snextUpdate element", PEPY_ERR_MISSING);
            return NOTOK;
        }

    }

    {
        register PE p177;

        if ((p177 = (pe != p172 ? next_member (pe, p172) : first_member (pe))) != NULLPE) {
            p172 = p177;

            {	/* revokedCertificates */
#ifdef DEBUG
                (void) testdebug (p177, "revokedCertificates");
#endif

                if (parse_AF_RevCertPemSequence (p177, 1, NULLIP, NULLVP, &((*parm)->revokedCertificates) ) == NOTOK)
                    return NOTOK;
            }
        }
    }


    if (pe -> pe_cardinal > 5) {
        advise (NULLCP, "TBSPemCrl %s(5): %d", PEPY_ERR_TOO_MANY_ELEMENTS,
                pe -> pe_cardinal);
        return NOTOK;
    }

    return OK;
}

/* ARGSUSED */

int	parse_AF_PemCrl (pe, explicit, len, buffer, parm)
register PE	pe;
int	explicit;
int    *len;
char  **buffer;
PemCrl ** parm;
{
    register PE p178;

#ifdef DEBUG
    (void) testdebug (pe, "AF.PemCrl");
#endif

    if (explicit) {
        if (pe -> pe_class != PE_CLASS_UNIV
                || pe -> pe_form != PE_FORM_CONS
                || pe -> pe_id != PE_CONS_SEQ) {
            advise (NULLCP, "PemCrl bad class/form/id: %s/%d/0x%x",
                    pe_classlist[pe -> pe_class], pe -> pe_form, pe -> pe_id);
            return NOTOK;
        }
    }
    else
        if (pe -> pe_form != PE_FORM_CONS) {
            advise (NULLCP, "PemCrl bad form: %d", pe -> pe_form);
            return NOTOK;
        }

    {
# line 1058 "AF.py.COSINE"

            if ((*(parm) = (PemCrl *)
                    calloc (1, sizeof **(parm))) == ((PemCrl *) 0)) {
                advise (NULLCP, "out of memory");
                return NOTOK;
            }
            if (((*parm)->sig = (Signature *)
                    calloc (1, sizeof (Signature))) == ((Signature *) 0)) {
                advise (NULLCP, "out of memory");
                return NOTOK;
            }
        
    }
    if ((p178 = prim2seq (pe)) == NULLPE) {
        advise (NULLCP, "PemCrl %s%s", PEPY_ERR_BAD_SEQ,
                pe_error (pe -> pe_errno));
        return NOTOK;
    }
    pe = p178;

    {
        register PE p179;

        if ((p179 = first_member (pe)) != NULLPE) {
            p178 = p179;

            {
#ifdef DEBUG
                (void) testdebug (p179, "element");
#endif

                if (parse_AF_TBSPemCrl (p179, 1, NULLIP, NULLVP, &((*parm)->tbs) ) == NOTOK)
                    return NOTOK;
                {
# line 1074 "AF.py.COSINE"
 /* set x509_tbs */
		(*parm)->tbs_DERcode = aux_PE2OctetString(p179);
		if ( (*parm)->tbs_DERcode == (OctetString *)0 ) return NOTOK;
	   
                }
            }
        }
        else {
            advise (NULLCP, "PemCrl %selement", PEPY_ERR_MISSING);
            return NOTOK;
        }

    }

    {
        register PE p180;

        if ((p180 = (pe != p178 ? next_member (pe, p178) : first_member (pe))) != NULLPE) {
            p178 = p180;

            {
#ifdef DEBUG
                (void) testdebug (p180, "element");
#endif

                if (parse_SEC_AlgorithmIdentifier (p180, 1, NULLIP, NULLVP, &((*parm)->sig->signAI) ) == NOTOK)
                    return NOTOK;
            }
        }
        else {
            advise (NULLCP, "PemCrl %selement", PEPY_ERR_MISSING);
            return NOTOK;
        }

    }

    {
        register PE p181;

        if ((p181 = (pe != p178 ? next_member (pe, p178) : first_member (pe))) != NULLPE) {
            p178 = p181;

            {
                register PE p182;

#ifdef DEBUG
                (void) testdebug (p181, "element");
#endif

                if (p181 -> pe_class != PE_CLASS_UNIV || p181 -> pe_id != PE_PRIM_BITS) {
                    advise (NULLCP, "element bad class/form/id: %s/%d/0x%x",
                            pe_classlist[p181 -> pe_class], p181 -> pe_form, p181 -> pe_id);
                    return NOTOK;
                }

                if ((p182 = prim2bit (p181)) == NULLPE) {
                    advise (NULLCP, "element %s%s", PEPY_ERR_BAD_BITS,
                            pe_error (p181 -> pe_errno));
                    return NOTOK;
                }
                (*parm)->sig->signature.bits  = bitstr2strb (p181, &(
		     (*parm)->sig->signature.nbits ));
            }
        }
        else {
            advise (NULLCP, "PemCrl %selement", PEPY_ERR_MISSING);
            return NOTOK;
        }

    }


    if (pe -> pe_cardinal > 3) {
        advise (NULLCP, "PemCrl %s(3): %d", PEPY_ERR_TOO_MANY_ELEMENTS,
                pe -> pe_cardinal);
        return NOTOK;
    }

    return OK;
}

/* ARGSUSED */

int	parse_AF_RevCertPemSequence (pe, explicit, len, buffer, parm)
register PE	pe;
int	explicit;
int    *len;
char  **buffer;
SEQUENCE_OF_RevCertPem ** parm;
{
    register PE p183;

#ifdef DEBUG
    (void) testdebug (pe, "AF.RevCertPemSequence");
#endif

    if (explicit) {
        if (pe -> pe_class != PE_CLASS_UNIV
                || pe -> pe_form != PE_FORM_CONS
                || pe -> pe_id != PE_CONS_SEQ) {
            advise (NULLCP, "RevCertPemSequence bad class/form/id: %s/%d/0x%x",
                    pe_classlist[pe -> pe_class], pe -> pe_form, pe -> pe_id);
            return NOTOK;
        }
    }
    else
        if (pe -> pe_form != PE_FORM_CONS) {
            advise (NULLCP, "RevCertPemSequence bad form: %d", pe -> pe_form);
            return NOTOK;
        }

    if ((p183 = prim2seq (pe)) == NULLPE) {
        advise (NULLCP, "RevCertPemSequence %s%s", PEPY_ERR_BAD_SEQ,
                pe_error (pe -> pe_errno));
        return NOTOK;
    }
    pe = p183;

    for (p183 = first_member (pe); p183; p183 = next_member (pe, p183)) {
        {
# line 1091 "AF.py.COSINE"

		if ((*(parm) = (SEQUENCE_OF_RevCertPem *)
			calloc (1, sizeof **(parm))) == (SEQUENCE_OF_RevCertPem *) 0) {
                    advise (NULLCP, "out of memory");
                    return NOTOK;
                }
		(*parm) -> next = (SEQUENCE_OF_RevCertPem *)0;
            
        }
        {
#ifdef DEBUG
            (void) testdebug (p183, "element");
#endif

            if (parse_AF_RevCertPem (p183, 1, NULLIP, NULLVP, &((*parm) -> element) ) == NOTOK)
                return NOTOK;
            {
# line 1101 "AF.py.COSINE"
 parm = &((*parm) -> next); 
            }
        }
    }

    return OK;
}

/* ARGSUSED */

int	parse_AF_RevCertPem (pe, explicit, len, buffer, parm)
register PE	pe;
int	explicit;
int    *len;
char  **buffer;
RevCertPem ** parm;
{
    register PE p184;

#ifdef DEBUG
    (void) testdebug (pe, "AF.RevCertPem");
#endif

    if (explicit) {
        if (pe -> pe_class != PE_CLASS_UNIV
                || pe -> pe_form != PE_FORM_CONS
                || pe -> pe_id != PE_CONS_SEQ) {
            advise (NULLCP, "RevCertPem bad class/form/id: %s/%d/0x%x",
                    pe_classlist[pe -> pe_class], pe -> pe_form, pe -> pe_id);
            return NOTOK;
        }
    }
    else
        if (pe -> pe_form != PE_FORM_CONS) {
            advise (NULLCP, "RevCertPem bad form: %d", pe -> pe_form);
            return NOTOK;
        }

    {
# line 1106 "AF.py.COSINE"

            if ((*(parm) = (RevCertPem *)
                    calloc (1, sizeof **(parm))) == ((RevCertPem *) 0)) {
                advise (NULLCP, "out of memory");
                return NOTOK;
            }
        
    }
    if ((p184 = prim2seq (pe)) == NULLPE) {
        advise (NULLCP, "RevCertPem %s%s", PEPY_ERR_BAD_SEQ,
                pe_error (pe -> pe_errno));
        return NOTOK;
    }
    pe = p184;

    {
        register PE p185;

        if ((p185 = first_member (pe)) != NULLPE) {
            p184 = p185;

            {	/* serialNumber */
                register integer p186;

#ifdef DEBUG
                (void) testdebug (p185, "serialNumber");
#endif

                if (p185 -> pe_class != PE_CLASS_UNIV
                        || p185 -> pe_form != PE_FORM_PRIM
                        || p185 -> pe_id != PE_PRIM_INT) {
                    advise (NULLCP, "serialNumber bad class/form/id: %s/%d/0x%x",
                            pe_classlist[p185 -> pe_class], p185 -> pe_form, p185 -> pe_id);
                    return NOTOK;
                }

                if ((p186 = prim2num (p185)) == NOTOK
                        && p185 -> pe_errno != PE_ERR_NONE) {
                    advise (NULLCP, "serialNumber %s%s", PEPY_ERR_BAD_INTEGER,
                            pe_error (p185 -> pe_errno));
                    return NOTOK;
                }
                (*parm)->serialnumber  = p186;
            }
        }
        else {
            advise (NULLCP, "RevCertPem %sserialNumber element", PEPY_ERR_MISSING);
            return NOTOK;
        }

    }

    {
        register PE p187;

        if ((p187 = (pe != p184 ? next_member (pe, p184) : first_member (pe))) != NULLPE) {
            p184 = p187;

            {	/* revocationDate */
#ifdef DEBUG
                (void) testdebug (p187, "revocationDate");
#endif

                if (parse_UNIV_UTCTime (p187, 1, NULLIP, &((*parm)->revocationDate ), NullParm) == NOTOK)
                    return NOTOK;
            }
        }
        else {
            advise (NULLCP, "RevCertPem %srevocationDate element", PEPY_ERR_MISSING);
            return NOTOK;
        }

    }


    if (pe -> pe_cardinal > 2) {
        advise (NULLCP, "RevCertPem %s(2): %d", PEPY_ERR_TOO_MANY_ELEMENTS,
                pe -> pe_cardinal);
        return NOTOK;
    }

    return OK;
}

/* ARGSUSED */

int	parse_AF_SerialSet (pe, explicit, len, buffer, parm)
register PE	pe;
int	explicit;
int    *len;
char  **buffer;
SET_OF_int ** parm;
{
    register PE p188;

#ifdef DEBUG
    (void) testdebug (pe, "AF.SerialSet");
#endif

    if (explicit) {
        if (pe -> pe_class != PE_CLASS_UNIV
                || pe -> pe_form != PE_FORM_CONS
                || pe -> pe_id != PE_CONS_SET) {
            advise (NULLCP, "SerialSet bad class/form/id: %s/%d/0x%x",
                    pe_classlist[pe -> pe_class], pe -> pe_form, pe -> pe_id);
            return NOTOK;
        }
    }
    else
        if (pe -> pe_form != PE_FORM_CONS) {
            advise (NULLCP, "SerialSet bad form: %d", pe -> pe_form);
            return NOTOK;
        }

    if ((p188 = prim2set (pe)) == NULLPE) {
        advise (NULLCP, "SerialSet %s%s", PEPY_ERR_BAD_SET,
                pe_error (pe -> pe_errno));
        return NOTOK;
    }
    pe = p188;

    for (p188 = first_member (pe); p188; p188 = next_member (pe, p188)) {
        {
# line 1127 "AF.py.COSINE"

                if ((*(parm) = (SET_OF_int *)
                        calloc (1, sizeof **(parm))) == ((SET_OF_int *) 0)) {
                    advise (NULLCP, "out of memory");
                    return NOTOK;
                }
            
        }
        {
            register integer p189;

#ifdef DEBUG
            (void) testdebug (p188, "member");
#endif

            if (p188 -> pe_class != PE_CLASS_UNIV
                    || p188 -> pe_form != PE_FORM_PRIM
                    || p188 -> pe_id != PE_PRIM_INT) {
                advise (NULLCP, "member bad class/form/id: %s/%d/0x%x",
                        pe_classlist[p188 -> pe_class], p188 -> pe_form, p188 -> pe_id);
                return NOTOK;
            }

            if ((p189 = prim2num (p188)) == NOTOK
                    && p188 -> pe_errno != PE_ERR_NONE) {
                advise (NULLCP, "member %s%s", PEPY_ERR_BAD_INTEGER,
                        pe_error (p188 -> pe_errno));
                return NOTOK;
            }
            (*parm) -> element  = p189;
            {
# line 1136 "AF.py.COSINE"
 parm = &((*parm) -> next); 
            }
        }
    }

    return OK;
}

/* ARGSUSED */

int	parse_AF_CrlPSE (pe, explicit, len, buffer, parm)
register PE	pe;
int	explicit;
int    *len;
char  **buffer;
CrlPSE ** parm;
{
    register PE p190;

#ifdef DEBUG
    (void) testdebug (pe, "AF.CrlPSE");
#endif

    if (explicit) {
        if (pe -> pe_class != PE_CLASS_UNIV
                || pe -> pe_form != PE_FORM_CONS
                || pe -> pe_id != PE_CONS_SEQ) {
            advise (NULLCP, "CrlPSE bad class/form/id: %s/%d/0x%x",
                    pe_classlist[pe -> pe_class], pe -> pe_form, pe -> pe_id);
            return NOTOK;
        }
    }
    else
        if (pe -> pe_form != PE_FORM_CONS) {
            advise (NULLCP, "CrlPSE bad form: %d", pe -> pe_form);
            return NOTOK;
        }

    {
# line 1141 "AF.py.COSINE"

            if ((*(parm) = (CrlPSE *)
                    calloc (1, sizeof **(parm))) == ((CrlPSE *) 0)) {
                advise (NULLCP, "out of memory");
                return NOTOK;
            }
        
    }
    if ((p190 = prim2seq (pe)) == NULLPE) {
        advise (NULLCP, "CrlPSE %s%s", PEPY_ERR_BAD_SEQ,
                pe_error (pe -> pe_errno));
        return NOTOK;
    }
    pe = p190;

    {
        register PE p191;

        if ((p191 = first_member (pe)) != NULLPE) {
            p190 = p191;

            {	/* issuer */
#ifdef DEBUG
                (void) testdebug (p191, "issuer");
#endif

                if (parse_IF_Name (p191, 1, NULLIP, NULLVP, &((*parm)->issuer) ) == NOTOK)
                    return NOTOK;
            }
        }
        else {
            advise (NULLCP, "CrlPSE %sissuer element", PEPY_ERR_MISSING);
            return NOTOK;
        }

    }

    {
        register PE p192;

        if ((p192 = (pe != p190 ? next_member (pe, p190) : first_member (pe))) != NULLPE) {
            p190 = p192;

            {	/* nextUpdate */
#ifdef DEBUG
                (void) testdebug (p192, "nextUpdate");
#endif

                if (parse_UNIV_UTCTime (p192, 1, NULLIP, &(((*parm)->nextUpdate) ), NullParm) == NOTOK)
                    return NOTOK;
            }
        }
        else {
            advise (NULLCP, "CrlPSE %snextUpdate element", PEPY_ERR_MISSING);
            return NOTOK;
        }

    }

    {
        register PE p193;

        if ((p193 = (pe != p190 ? next_member (pe, p190) : first_member (pe))) != NULLPE) {
            p190 = p193;

            {	/* revcerts */
#ifdef DEBUG
                (void) testdebug (p193, "revcerts");
#endif

                if (parse_AF_RevCertPemSequence (p193, 1, NULLIP, NULLVP, &((*parm)->revcerts) ) == NOTOK)
                    return NOTOK;
            }
        }
    }


    if (pe -> pe_cardinal > 3) {
        advise (NULLCP, "CrlPSE %s(3): %d", PEPY_ERR_TOO_MANY_ELEMENTS,
                pe -> pe_cardinal);
        return NOTOK;
    }

    return OK;
}

/* ARGSUSED */

int	parse_AF_CrlSet (pe, explicit, len, buffer, parm)
register PE	pe;
int	explicit;
int    *len;
char  **buffer;
CrlSet ** parm;
{
    register PE p194;

#ifdef DEBUG
    (void) testdebug (pe, "AF.CrlSet");
#endif

    if (explicit) {
        if (pe -> pe_class != PE_CLASS_UNIV
                || pe -> pe_form != PE_FORM_CONS
                || pe -> pe_id != PE_CONS_SET) {
            advise (NULLCP, "CrlSet bad class/form/id: %s/%d/0x%x",
                    pe_classlist[pe -> pe_class], pe -> pe_form, pe -> pe_id);
            return NOTOK;
        }
    }
    else
        if (pe -> pe_form != PE_FORM_CONS) {
            advise (NULLCP, "CrlSet bad form: %d", pe -> pe_form);
            return NOTOK;
        }

    if ((p194 = prim2set (pe)) == NULLPE) {
        advise (NULLCP, "CrlSet %s%s", PEPY_ERR_BAD_SET,
                pe_error (pe -> pe_errno));
        return NOTOK;
    }
    pe = p194;

    for (p194 = first_member (pe); p194; p194 = next_member (pe, p194)) {
        {
# line 1167 "AF.py.COSINE"

                if ((*(parm) = (CrlSet *)
                        calloc (1, sizeof **(parm))) == ((CrlSet *) 0)) {
                    advise (NULLCP, "out of memory");
                    return NOTOK;
                }
            
        }
        {
#ifdef DEBUG
            (void) testdebug (p194, "member");
#endif

            if (parse_AF_CrlPSE (p194, 1, NULLIP, NULLVP, &((*parm) -> element)) == NOTOK)
                return NOTOK;
            {
# line 1176 "AF.py.COSINE"
 parm = &((*parm) -> next); 
            }
        }
    }

    return OK;
}

/* ARGSUSED */

int	parse_AF_OldCertificateList (pe, explicit, len, buffer, parm)
register PE	pe;
int	explicit;
int    *len;
char  **buffer;
OCList ** parm;
{
    register PE p195;

#ifdef DEBUG
    (void) testdebug (pe, "AF.OldCertificateList");
#endif

    if (explicit) {
        if (pe -> pe_class != PE_CLASS_UNIV
                || pe -> pe_form != PE_FORM_CONS
                || pe -> pe_id != PE_CONS_SEQ) {
            advise (NULLCP, "OldCertificateList bad class/form/id: %s/%d/0x%x",
                    pe_classlist[pe -> pe_class], pe -> pe_form, pe -> pe_id);
            return NOTOK;
        }
    }
    else
        if (pe -> pe_form != PE_FORM_CONS) {
            advise (NULLCP, "OldCertificateList bad form: %d", pe -> pe_form);
            return NOTOK;
        }

    if ((p195 = prim2seq (pe)) == NULLPE) {
        advise (NULLCP, "OldCertificateList %s%s", PEPY_ERR_BAD_SEQ,
                pe_error (pe -> pe_errno));
        return NOTOK;
    }
    pe = p195;

    for (p195 = first_member (pe); p195; p195 = next_member (pe, p195)) {
        {
# line 1182 "AF.py.COSINE"

		if ((*(parm) = (OCList *)
			calloc (1, sizeof **(parm))) == (OCList *) 0) {
                    advise (NULLCP, "out of memory");
                    return NOTOK;
                }
		(*parm) -> next = (OCList *)0;
            
        }
        {
            register PE p196;

#ifdef DEBUG
            (void) testdebug (p195, "element");
#endif

            if (p195 -> pe_class != PE_CLASS_UNIV
                    || p195 -> pe_form != PE_FORM_CONS
                    || p195 -> pe_id != PE_CONS_SEQ) {
                advise (NULLCP, "element bad class/form/id: %s/%d/0x%x",
                        pe_classlist[p195 -> pe_class], p195 -> pe_form, p195 -> pe_id);
                return NOTOK;
            }

            if ((p196 = prim2seq (p195)) == NULLPE) {
                advise (NULLCP, "element %s%s", PEPY_ERR_BAD_SEQ,
                        pe_error (p195 -> pe_errno));
                return NOTOK;
            }
            p195 = p196;

            {
                register PE p197;

                if ((p197 = first_member (p195)) != NULLPE) {
                    p196 = p197;

                    {	/* serialNumber */
                        register integer p198;

#ifdef DEBUG
                        (void) testdebug (p197, "serialNumber");
#endif

                        if (p197 -> pe_class != PE_CLASS_UNIV
                                || p197 -> pe_form != PE_FORM_PRIM
                                || p197 -> pe_id != PE_PRIM_INT) {
                            advise (NULLCP, "serialNumber bad class/form/id: %s/%d/0x%x",
                                    pe_classlist[p197 -> pe_class], p197 -> pe_form, p197 -> pe_id);
                            return NOTOK;
                        }

                        if ((p198 = prim2num (p197)) == NOTOK
                                && p197 -> pe_errno != PE_ERR_NONE) {
                            advise (NULLCP, "serialNumber %s%s", PEPY_ERR_BAD_INTEGER,
                                    pe_error (p197 -> pe_errno));
                            return NOTOK;
                        }
                        (*parm) -> serialnumber  = p198;
                    }
                }
                else {
                    advise (NULLCP, "element %sserialNumber element", PEPY_ERR_MISSING);
                    return NOTOK;
                }

            }

            {
                register PE p199;

                if ((p199 = (p195 != p196 ? next_member (p195, p196) : first_member (p195))) != NULLPE) {
                    p196 = p199;

                    {	/* crossCertificate */
#ifdef DEBUG
                        (void) testdebug (p199, "crossCertificate");
#endif

                        if (parse_AF_Certificate (p199, 1, NULLIP, NULLVP, &((*parm) -> ccert) ) == NOTOK)
                            return NOTOK;
                    }
                }
                else {
                    advise (NULLCP, "element %scrossCertificate element", PEPY_ERR_MISSING);
                    return NOTOK;
                }

            }


            if (p195 -> pe_cardinal > 2) {
                advise (NULLCP, "element %s(2): %d", PEPY_ERR_TOO_MANY_ELEMENTS,
                        p195 -> pe_cardinal);
                return NOTOK;
            }
            {
# line 1200 "AF.py.COSINE"
 parm = &((*parm) -> next); 
            }
        }
    }

    return OK;
}

/* ARGSUSED */

int	parse_AF_PemCrlWithCerts (pe, explicit, len, buffer, parm)
register PE	pe;
int	explicit;
int    *len;
char  **buffer;
PemCrlWithCerts ** parm;
{
    register PE p200;

#ifdef DEBUG
    (void) testdebug (pe, "AF.PemCrlWithCerts");
#endif

    if (explicit) {
        if (pe -> pe_class != PE_CLASS_UNIV
                || pe -> pe_form != PE_FORM_CONS
                || pe -> pe_id != PE_CONS_SEQ) {
            advise (NULLCP, "PemCrlWithCerts bad class/form/id: %s/%d/0x%x",
                    pe_classlist[pe -> pe_class], pe -> pe_form, pe -> pe_id);
            return NOTOK;
        }
    }
    else
        if (pe -> pe_form != PE_FORM_CONS) {
            advise (NULLCP, "PemCrlWithCerts bad form: %d", pe -> pe_form);
            return NOTOK;
        }

    {
# line 1204 "AF.py.COSINE"

        if ((*(parm) = (PemCrlWithCerts *)
                calloc (1, sizeof **(parm))) == ((PemCrlWithCerts *) 0)) {
            advise (NULLCP, "out of memory");
            return NOTOK;
        }
	(*parm)->certificates = (Certificates * )0;
    
    }
    if ((p200 = prim2seq (pe)) == NULLPE) {
        advise (NULLCP, "PemCrlWithCerts %s%s", PEPY_ERR_BAD_SEQ,
                pe_error (pe -> pe_errno));
        return NOTOK;
    }
    pe = p200;

    {
        register PE p201;

        if ((p201 = first_member (pe)) != NULLPE) {
            p200 = p201;

            {	/* pemCRL */
#ifdef DEBUG
                (void) testdebug (p201, "pemCRL");
#endif

                if (parse_AF_PemCrl (p201, 1, NULLIP, NULLVP, &((*parm) -> pemcrl)) == NOTOK)
                    return NOTOK;
            }
        }
        else {
            advise (NULLCP, "PemCrlWithCerts %spemCRL element", PEPY_ERR_MISSING);
            return NOTOK;
        }

    }

    {
        register PE p202;

        if ((p202 = (pe != p200 ? next_member (pe, p200) : first_member (pe))) != NULLPE) {
            p200 = p202;

            {	/* certificates */
#ifdef DEBUG
                (void) testdebug (p202, "certificates");
#endif

                if (parse_AF_Certificates (p202, 1, NULLIP, NULLVP, &((*parm) -> certificates)) == NOTOK)
                    return NOTOK;
            }
        }
    }


    if (pe -> pe_cardinal > 2) {
        advise (NULLCP, "PemCrlWithCerts %s(2): %d", PEPY_ERR_TOO_MANY_ELEMENTS,
                pe -> pe_cardinal);
        return NOTOK;
    }

    return OK;
}

/* ARGSUSED */

int	parse_AF_AliasesMember (pe, explicit, len, buffer, parm)
register PE	pe;
int	explicit;
int    *len;
char  **buffer;
Aliases * parm;
{
    register PE p203;

#ifdef DEBUG
    (void) testdebug (pe, "AF.AliasesMember");
#endif

    if (explicit) {
        if (pe -> pe_class != PE_CLASS_UNIV
                || pe -> pe_form != PE_FORM_CONS
                || pe -> pe_id != PE_CONS_SEQ) {
            advise (NULLCP, "AliasesMember bad class/form/id: %s/%d/0x%x",
                    pe_classlist[pe -> pe_class], pe -> pe_form, pe -> pe_id);
            return NOTOK;
        }
    }
    else
        if (pe -> pe_form != PE_FORM_CONS) {
            advise (NULLCP, "AliasesMember bad form: %d", pe -> pe_form);
            return NOTOK;
        }

    if ((p203 = prim2seq (pe)) == NULLPE) {
        advise (NULLCP, "AliasesMember %s%s", PEPY_ERR_BAD_SEQ,
                pe_error (pe -> pe_errno));
        return NOTOK;
    }
    pe = p203;

    {
        register PE p204;

        if ((p204 = first_member (pe)) != NULLPE) {
            p203 = p204;

            {	/* aname */
#ifdef DEBUG
                (void) testdebug (p204, "aname");
#endif

                if (parse_UNIV_IA5String (p204, 1, NULLIP, &(parm->aname), NullParm) == NOTOK)
                    return NOTOK;
            }
        }
        else {
            advise (NULLCP, "AliasesMember %saname element", PEPY_ERR_MISSING);
            return NOTOK;
        }

    }

    {
        register PE p205;

        if ((p205 = (pe != p203 ? next_member (pe, p203) : first_member (pe))) != NULLPE) {
            p203 = p205;

            {	/* aliasfile */
                register integer p206;

#ifdef DEBUG
                (void) testdebug (p205, "aliasfile");
#endif

                if (p205 -> pe_class != PE_CLASS_UNIV
                        || p205 -> pe_form != PE_FORM_PRIM
                        || p205 -> pe_id != PE_PRIM_ENUM) {
                    advise (NULLCP, "aliasfile bad class/form/id: %s/%d/0x%x",
                            pe_classlist[p205 -> pe_class], p205 -> pe_form, p205 -> pe_id);
                    return NOTOK;
                }

                if ((p206 = prim2enum (p205)) == NOTOK
                        && p205 -> pe_errno != PE_ERR_NONE) {
                    advise (NULLCP, "aliasfile %s%s", PEPY_ERR_BAD_INTEGER,
                            pe_error (p205 -> pe_errno));
                    return NOTOK;
                }
                parm->aliasfile = p206;
                switch (p206) {
                    case 0:	/* useralias */
                        break;
                    case 1:	/* systemalias */
                        break;
                    default:
                        advise (NULLCP, "aliasfile %s%d", PEPY_ERR_UNK_COMP, p206);
                        return NOTOK;
                }
            }
        }
        else {
            advise (NULLCP, "AliasesMember %saliasfile element", PEPY_ERR_MISSING);
            return NOTOK;
        }

    }


    if (pe -> pe_cardinal > 2) {
        advise (NULLCP, "AliasesMember %s(2): %d", PEPY_ERR_TOO_MANY_ELEMENTS,
                pe -> pe_cardinal);
        return NOTOK;
    }

    return OK;
}

/* ARGSUSED */

int	parse_AF_Aliases (pe, explicit, len, buffer, parm)
register PE	pe;
int	explicit;
int    *len;
char  **buffer;
Aliases ** parm;
{
    register PE p207;

#ifdef DEBUG
    (void) testdebug (pe, "AF.Aliases");
#endif

    if (explicit) {
        if (pe -> pe_class != PE_CLASS_UNIV
                || pe -> pe_form != PE_FORM_CONS
                || pe -> pe_id != PE_CONS_SEQ) {
            advise (NULLCP, "Aliases bad class/form/id: %s/%d/0x%x",
                    pe_classlist[pe -> pe_class], pe -> pe_form, pe -> pe_id);
            return NOTOK;
        }
    }
    else
        if (pe -> pe_form != PE_FORM_CONS) {
            advise (NULLCP, "Aliases bad form: %d", pe -> pe_form);
            return NOTOK;
        }

    if ((p207 = prim2seq (pe)) == NULLPE) {
        advise (NULLCP, "Aliases %s%s", PEPY_ERR_BAD_SEQ,
                pe_error (pe -> pe_errno));
        return NOTOK;
    }
    pe = p207;

    for (p207 = first_member (pe); p207; p207 = next_member (pe, p207)) {
        {
# line 1242 "AF.py.COSINE"

                if ((*(parm) = (Aliases *)
                        calloc (1, sizeof **(parm))) == ((Aliases *) 0)) {
                    advise (NULLCP, "out of memory");
                    return NOTOK;
                }
            
        }
        {
#ifdef DEBUG
            (void) testdebug (p207, "element");
#endif

            if (parse_AF_AliasesMember (p207, 1, NULLIP, NULLVP, *parm) == NOTOK)
                return NOTOK;
            {
# line 1251 "AF.py.COSINE"
 parm = &((*parm) -> next); 
            }
        }
    }

    return OK;
}

/* ARGSUSED */

int	parse_AF_AliasListMember (pe, explicit, len, buffer, parm)
register PE	pe;
int	explicit;
int    *len;
char  **buffer;
AliasList * parm;
{
    register PE p208;

#ifdef DEBUG
    (void) testdebug (pe, "AF.AliasListMember");
#endif

    if (explicit) {
        if (pe -> pe_class != PE_CLASS_UNIV
                || pe -> pe_form != PE_FORM_CONS
                || pe -> pe_id != PE_CONS_SEQ) {
            advise (NULLCP, "AliasListMember bad class/form/id: %s/%d/0x%x",
                    pe_classlist[pe -> pe_class], pe -> pe_form, pe -> pe_id);
            return NOTOK;
        }
    }
    else
        if (pe -> pe_form != PE_FORM_CONS) {
            advise (NULLCP, "AliasListMember bad form: %d", pe -> pe_form);
            return NOTOK;
        }

    if ((p208 = prim2seq (pe)) == NULLPE) {
        advise (NULLCP, "AliasListMember %s%s", PEPY_ERR_BAD_SEQ,
                pe_error (pe -> pe_errno));
        return NOTOK;
    }
    pe = p208;

    {
        register PE p209;

        if ((p209 = first_member (pe)) != NULLPE) {
            p208 = p209;

            {	/* aliases */
#ifdef DEBUG
                (void) testdebug (p209, "aliases");
#endif

                if (parse_AF_Aliases (p209, 1, NULLIP, NULLVP, &(parm->a)) == NOTOK)
                    return NOTOK;
            }
        }
        else {
            advise (NULLCP, "AliasListMember %saliases element", PEPY_ERR_MISSING);
            return NOTOK;
        }

    }

    {
        register PE p210;

        if ((p210 = (pe != p208 ? next_member (pe, p208) : first_member (pe))) != NULLPE) {
            p208 = p210;

            {	/* dname */
#ifdef DEBUG
                (void) testdebug (p210, "dname");
#endif

                if (parse_UNIV_IA5String (p210, 1, NULLIP, &(parm->dname), NullParm) == NOTOK)
                    return NOTOK;
            }
        }
        else {
            advise (NULLCP, "AliasListMember %sdname element", PEPY_ERR_MISSING);
            return NOTOK;
        }

    }


    if (pe -> pe_cardinal > 2) {
        advise (NULLCP, "AliasListMember %s(2): %d", PEPY_ERR_TOO_MANY_ELEMENTS,
                pe -> pe_cardinal);
        return NOTOK;
    }

    return OK;
}

/* ARGSUSED */

int	parse_AF_AliasList (pe, explicit, len, buffer, parm)
register PE	pe;
int	explicit;
int    *len;
char  **buffer;
AliasList ** parm;
{
    register PE p211;

#ifdef DEBUG
    (void) testdebug (pe, "AF.AliasList");
#endif

    if (explicit) {
        if (pe -> pe_class != PE_CLASS_UNIV
                || pe -> pe_form != PE_FORM_CONS
                || pe -> pe_id != PE_CONS_SEQ) {
            advise (NULLCP, "AliasList bad class/form/id: %s/%d/0x%x",
                    pe_classlist[pe -> pe_class], pe -> pe_form, pe -> pe_id);
            return NOTOK;
        }
    }
    else
        if (pe -> pe_form != PE_FORM_CONS) {
            advise (NULLCP, "AliasList bad form: %d", pe -> pe_form);
            return NOTOK;
        }

    if ((p211 = prim2seq (pe)) == NULLPE) {
        advise (NULLCP, "AliasList %s%s", PEPY_ERR_BAD_SEQ,
                pe_error (pe -> pe_errno));
        return NOTOK;
    }
    pe = p211;

    for (p211 = first_member (pe); p211; p211 = next_member (pe, p211)) {
        {
# line 1268 "AF.py.COSINE"

                if ((*(parm) = (AliasList *)
                        calloc (1, sizeof **(parm))) == ((AliasList *) 0)) {
                    advise (NULLCP, "out of memory");
                    return NOTOK;
                }
            
        }
        {
#ifdef DEBUG
            (void) testdebug (p211, "element");
#endif

            if (parse_AF_AliasListMember (p211, 1, NULLIP, NULLVP, *parm) == NOTOK)
                return NOTOK;
            {
# line 1277 "AF.py.COSINE"
 parm = &((*parm) -> next); 
            }
        }
    }

    return OK;
}
# line 1283 "AF.py.COSINE"

#endif

/************************ local functions: ****/

static
PE	build_tbs(cert,save)
Certificate      *cert;
PE               *save;
{
	(*save) = NULLPE;

	if( cert->tbs_DERcode == (OctetString *)0 )
	{
	    if (build_AF_TBSCertificate(save,1,0,NULLCP, cert->tbs) == NOTOK)
		return NULLPE;
	    cert->tbs_DERcode = aux_PE2OctetString(*save);
	}
	else   (*save) = aux_OctetString2PE(cert->tbs_DERcode);

	return(*save);
}

static
PE      build_revlist_tbs(revlist,save)
Crl   *revlist;
PE        *save;
{
	(*save) = NULLPE;

	if( revlist->tbs_DERcode == (OctetString *)0 )
	{
	    if (build_AF_TBSCrl(save,1,0,NULLCP,revlist->tbs) == NOTOK)
		return (NULLPE);
	    revlist->tbs_DERcode = aux_PE2OctetString(*save);
	}
	else   (*save) = aux_OctetString2PE(revlist->tbs_DERcode);

	return(*save);
}

static
PE      build_revcert_tbs(revcert,save)
RevCert      *revcert;
PE           *save;
{
	(*save) = NULLPE;

	if( revcert->tbs_DERcode == (OctetString *)0 )
	{
	    if (build_AF_TBSRevCert(save,1,0,NULLCP,revcert->tbs) == NOTOK)
		return (NULLPE);
	    revcert->tbs_DERcode = aux_PE2OctetString(*save);
	}
	else   (*save) = aux_OctetString2PE(revcert->tbs_DERcode);

	return(*save);
}

static
PE	build_pemcrl_tbs(pemcrl, save)
PemCrl	 *pemcrl;
PE		 *save;
{
	(*save) = NULLPE;

	if( pemcrl->tbs_DERcode == (OctetString *)0 )
	{
	    if (build_AF_TBSPemCrl(save,1,0,NULLCP,pemcrl->tbs) == NOTOK)
		return (NULLPE);
	    pemcrl->tbs_DERcode = aux_PE2OctetString(*save);
	}
	else   (*save) = aux_OctetString2PE(pemcrl->tbs_DERcode);

	return(*save);
}

