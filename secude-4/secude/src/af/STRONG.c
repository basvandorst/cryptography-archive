#ifdef X500
#ifdef STRONG

/* automatically generated by pepy 8.0 #11 (tiber), do not edit! */

#include <isode/psap.h>

#ifndef lint
static char *pepyid = "pepy 8.0 #11 (tiber) of Tue Jun  1 11:43:07 MET DST 1993";
#endif

void	advise ();

/* Generated from module STRONG */
# line 3 "STRONG.py"
	/* surrounding global definitions	*/
#include        "secude-stub.h"

static PE             build_token_tbs();
static PE	      build_addarg_tbs();
static PE	      build_comparearg_tbs();
static PE	      build_compareres_tbs();
static PE	      build_listarg_tbs();
static PE	      build_listres_tbs();
static PE	      build_modifyentryarg_tbs();
static PE	      build_modifyrdnarg_tbs();
static PE	      build_readarg_tbs();
static PE	      build_readres_tbs();
static PE	      build_removearg_tbs();
static PE	      build_searcharg_tbs();
static PE	      build_searchres_tbs();
static char 	    * aux_int2strb_alloc();
static PE 	      encode_STRONG_DER_SET_OF();

extern void           encode_DO_AccessPoint ();  /* from ISODE */

PE 	              aux_OctetString2PE();
OctetString         * aux_PE2OctetString();

#ifndef PEPYPARM
#define PEPYPARM char *
#endif /* PEPYPARM */
extern PEPYPARM NullParm;

/* ARGSUSED */

int	build_STRONG_TokenTBS (pe, explicit, len, buffer, parm)
register PE     *pe;
int	explicit;
int	len;
char   *buffer;
TokenTBS * parm;
{
    PE	p0_z = NULLPE;
    register PE *p0 = &p0_z;

    if (((*pe) = pe_alloc (PE_CLASS_UNIV, PE_FORM_CONS, PE_CONS_SEQ)) == NULLPE) {
        advise (NULLCP, "TokenTBS: %s", PEPY_ERR_NOMEM);
        return NOTOK;
    }
    (*p0) = NULLPE;

    {	/* signature */
        if (build_SEC_AlgorithmIdentifier (p0, 0, NULL, NULLCP, parm->signatureAI ) == NOTOK)
            return NOTOK;
        {	/* signature TAG PUSHDOWN */
            PE p1_z;
            register PE *p1 = &p1_z;

            if ((*p1 = pe_alloc (PE_CLASS_CONT, PE_FORM_CONS, 0)) == NULLPE) {
                advise (NULLCP, "signature: %s", PEPY_ERR_NOMEM);
                return NOTOK;
            }
            (*p1) -> pe_cons = (*p0);
            (*p0) = *p1;
        }

#ifdef DEBUG
        (void) testdebug ((*p0), "signature");
#endif

    }

    if ((*p0) != NULLPE)
        if (seq_add ((*pe), (*p0), -1) == NOTOK) {
            advise (NULLCP, "TokenTBS %s%s", PEPY_ERR_BAD_SEQ,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }
    (*p0) = NULLPE;

    {	/* name */
        if (build_IF_Name (p0, 0, NULL, NULLCP, parm->dname ) == NOTOK)
            return NOTOK;
        {	/* name TAG PUSHDOWN */
            PE p2_z;
            register PE *p2 = &p2_z;

            if ((*p2 = pe_alloc (PE_CLASS_CONT, PE_FORM_CONS, 1)) == NULLPE) {
                advise (NULLCP, "name: %s", PEPY_ERR_NOMEM);
                return NOTOK;
            }
            (*p2) -> pe_cons = (*p0);
            (*p0) = *p2;
        }

#ifdef DEBUG
        (void) testdebug ((*p0), "name");
#endif

    }

    if ((*p0) != NULLPE)
        if (seq_add ((*pe), (*p0), -1) == NOTOK) {
            advise (NULLCP, "TokenTBS %s%s", PEPY_ERR_BAD_SEQ,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }
    (*p0) = NULLPE;

    {	/* time */
        if (build_UNIV_UTCTime (p0, 0, NULL, parm->time , NullParm) == NOTOK)
            return NOTOK;
        {	/* time TAG PUSHDOWN */
            PE p3_z;
            register PE *p3 = &p3_z;

            if ((*p3 = pe_alloc (PE_CLASS_CONT, PE_FORM_CONS, 2)) == NULLPE) {
                advise (NULLCP, "time: %s", PEPY_ERR_NOMEM);
                return NOTOK;
            }
            (*p3) -> pe_cons = (*p0);
            (*p0) = *p3;
        }

#ifdef DEBUG
        (void) testdebug ((*p0), "time");
#endif

    }

    if ((*p0) != NULLPE)
        if (seq_add ((*pe), (*p0), -1) == NOTOK) {
            advise (NULLCP, "TokenTBS %s%s", PEPY_ERR_BAD_SEQ,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }
    (*p0) = NULLPE;

    {	/* random */
        PE	p4_z = NULLPE;
        register PE *p4 = &p4_z;

        char *p5;
        int p6;
        p5 = parm->random->bits ;
        p6 =  parm->random->nbits ;
        (*p4) = p5 ? strb2bitstr (p5, p6, PE_CLASS_UNIV, PE_PRIM_BITS) : NULLPE;
        if ((*p4) == NULLPE) {
            advise (NULLCP, "random %s", PEPY_ERR_INIT_FAILED);
            return NOTOK;
        }
        if (((*p0) = bit2prim ((*p4))) == NULLPE) {
            advise (NULLCP, "random: %s", PEPY_ERR_NOMEM);
            return NOTOK;
        }
        {	/* random TAG PUSHDOWN */
            PE p7_z;
            register PE *p7 = &p7_z;

            if ((*p7 = pe_alloc (PE_CLASS_CONT, PE_FORM_CONS, 3)) == NULLPE) {
                advise (NULLCP, "random: %s", PEPY_ERR_NOMEM);
                return NOTOK;
            }
            (*p7) -> pe_cons = (*p0);
            (*p0) = *p7;
        }

#ifdef DEBUG
        (void) testdebug ((*p0), "random");
#endif

    }

    if ((*p0) != NULLPE)
        if (seq_add ((*pe), (*p0), -1) == NOTOK) {
            advise (NULLCP, "TokenTBS %s%s", PEPY_ERR_BAD_SEQ,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }

#ifdef DEBUG
    (void) testdebug ((*pe), "STRONG.TokenTBS");
#endif


    return OK;
}

/* ARGSUSED */

int	build_STRONG_Token (pe, explicit, len, buffer, parm)
register PE     *pe;
int	explicit;
int	len;
char   *buffer;
Token * parm;
{
# line 68 "STRONG.py"
    	PE	tbs;

    PE	p8_z = NULLPE;
    register PE *p8 = &p8_z;

    if (((*pe) = pe_alloc (PE_CLASS_UNIV, PE_FORM_CONS, PE_CONS_SEQ)) == NULLPE) {
        advise (NULLCP, "Token: %s", PEPY_ERR_NOMEM);
        return NOTOK;
    }
    (*p8) = NULLPE;

    {
        PE	p9 = (build_token_tbs(parm,&tbs)) ;

        if (p9 == NULLPE) {
            advise (NULLCP, "element %s", PEPY_ERR_INIT_FAILED);
            return NOTOK;
        }
        ((*p8) = p9) -> pe_refcnt++;

#ifdef DEBUG
        (void) testdebug ((*p8), "element");
#endif

        {
# line 74 "STRONG.py"
    pe_free(tbs);
		
        }
    }

    if ((*p8) != NULLPE)
        if (seq_add ((*pe), (*p8), -1) == NOTOK) {
            advise (NULLCP, "Token %s%s", PEPY_ERR_BAD_SEQ,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }
    (*p8) = NULLPE;

    {
        if (build_SEC_AlgorithmIdentifier (p8, 0, NULL, NULLCP, parm->sig->signAI ) == NOTOK)
            return NOTOK;

#ifdef DEBUG
        (void) testdebug ((*p8), "element");
#endif

    }

    if ((*p8) != NULLPE)
        if (seq_add ((*pe), (*p8), -1) == NOTOK) {
            advise (NULLCP, "Token %s%s", PEPY_ERR_BAD_SEQ,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }
    (*p8) = NULLPE;

    {
        PE	p10_z = NULLPE;
        register PE *p10 = &p10_z;

        char *p11;
        int p12;
        p11 = parm->sig->signature.bits ;
        p12 = 
		     parm->sig->signature.nbits ;
        (*p10) = p11 ? strb2bitstr (p11, p12, PE_CLASS_UNIV, PE_PRIM_BITS) : NULLPE;
        if ((*p10) == NULLPE) {
            advise (NULLCP, "element %s", PEPY_ERR_INIT_FAILED);
            return NOTOK;
        }
        if (((*p8) = bit2prim ((*p10))) == NULLPE) {
            advise (NULLCP, "element: %s", PEPY_ERR_NOMEM);
            return NOTOK;
        }

#ifdef DEBUG
        (void) testdebug ((*p8), "element");
#endif

    }

    if ((*p8) != NULLPE)
        if (seq_add ((*pe), (*p8), -1) == NOTOK) {
            advise (NULLCP, "Token %s%s", PEPY_ERR_BAD_SEQ,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }

#ifdef DEBUG
    (void) testdebug ((*pe), "STRONG.Token");
#endif


    return OK;
}

/* ARGSUSED */

int	build_STRONG_AddArgumentTBS (pe, explicit, len, buffer, parm)
register PE     *pe;
int	explicit;
int	len;
char   *buffer;
AddArgumentTBS * parm;
{
    PE	p13_z = NULLPE;
    register PE *p13 = &p13_z;

    if (((*pe) = pe_alloc (PE_CLASS_UNIV, PE_FORM_CONS, PE_CONS_SET)) == NULLPE) {
        advise (NULLCP, "AddArgumentTBS: %s", PEPY_ERR_NOMEM);
        return NOTOK;
    }
    (*p13) = NULLPE;

    {
        if (build_IF_Name (p13, 0, NULL, NULLCP, parm->ada_object ) == NOTOK)
            return NOTOK;

#ifdef DEBUG
        (void) testdebug ((*p13), "object");
#endif

        {	/* object TAG PUSHDOWN */
            PE p14_z;
            register PE *p14 = &p14_z;

            if ((*p14 = pe_alloc (PE_CLASS_CONT, PE_FORM_CONS, 0)) == NULLPE) {
                advise (NULLCP, "object: %s", PEPY_ERR_NOMEM);
                return NOTOK;
            }
            (*p14) -> pe_cons = (*p13);
            (*p13) = *p14;
        }
    }
    if ((*p13) != NULLPE)
        if (set_add ((*pe), (*p13)) == NOTOK) {
            advise (NULLCP, "AddArgumentTBS %s%s", PEPY_ERR_BAD_SET,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }
    (*p13) = NULLPE;

    {
        if (build_STRONG_SETOFAttribute (p13, 0, NULL, NULLCP, parm->ada_entry ) == NOTOK)
            return NOTOK;

#ifdef DEBUG
        (void) testdebug ((*p13), "entry");
#endif

        {	/* entry TAG PUSHDOWN */
            PE p15_z;
            register PE *p15 = &p15_z;

            if ((*p15 = pe_alloc (PE_CLASS_CONT, PE_FORM_CONS, 1)) == NULLPE) {
                advise (NULLCP, "entry: %s", PEPY_ERR_NOMEM);
                return NOTOK;
            }
            (*p15) -> pe_cons = (*p13);
            (*p13) = *p15;
        }
    }
    if ((*p13) != NULLPE)
        if (set_add ((*pe), (*p13)) == NOTOK) {
            advise (NULLCP, "AddArgumentTBS %s%s", PEPY_ERR_BAD_SET,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }
    (*p13) = NULLPE;

    if (parm->ada_common->ext) {
        if (build_STRONG_SECExtensionSet (p13, 0, NULL, NULLCP, parm->ada_common->ext ) == NOTOK)
            return NOTOK;

#ifdef DEBUG
        (void) testdebug ((*p13), "extensions");
#endif

        {	/* extensions TAG PUSHDOWN */
            PE p16_z;
            register PE *p16 = &p16_z;

            if ((*p16 = pe_alloc (PE_CLASS_CONT, PE_FORM_CONS, 25)) == NULLPE) {
                advise (NULLCP, "extensions: %s", PEPY_ERR_NOMEM);
                return NOTOK;
            }
            (*p16) -> pe_cons = (*p13);
            (*p13) = *p16;
        }
    }
    if ((*p13) != NULLPE)
        if (set_add ((*pe), (*p13)) == NOTOK) {
            advise (NULLCP, "AddArgumentTBS %s%s", PEPY_ERR_BAD_SET,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }
    (*p13) = NULLPE;

    if (parm->ada_common->aliasedRDNs != CA_NO_ALIASDEREFERENCED) {
        register integer p17 = parm->ada_common->aliasedRDNs ;

        if (((*p13) = num2prim (p17, PE_CLASS_UNIV, PE_PRIM_INT)) == NULLPE) {
            advise (NULLCP, "aliasedRDNs: %s", PEPY_ERR_NOMEM);
            return NOTOK;
        }

#ifdef DEBUG
        (void) testdebug ((*p13), "aliasedRDNs");
#endif

        {	/* aliasedRDNs TAG PUSHDOWN */
            PE p18_z;
            register PE *p18 = &p18_z;

            if ((*p18 = pe_alloc (PE_CLASS_CONT, PE_FORM_CONS, 26)) == NULLPE) {
                advise (NULLCP, "aliasedRDNs: %s", PEPY_ERR_NOMEM);
                return NOTOK;
            }
            (*p18) -> pe_cons = (*p13);
            (*p13) = *p18;
        }
    }
    if ((*p13) != NULLPE)
        if (set_add ((*pe), (*p13)) == NOTOK) {
            advise (NULLCP, "AddArgumentTBS %s%s", PEPY_ERR_BAD_SET,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }
    (*p13) = NULLPE;

    if (parm->ada_common->progress) {
        if (build_STRONG_OperationProgress (p13, 0, NULL, NULLCP, parm->ada_common->progress ) == NOTOK)
            return NOTOK;

#ifdef DEBUG
        (void) testdebug ((*p13), "progress");
#endif

        {	/* progress TAG PUSHDOWN */
            PE p19_z;
            register PE *p19 = &p19_z;

            if ((*p19 = pe_alloc (PE_CLASS_CONT, PE_FORM_CONS, 27)) == NULLPE) {
                advise (NULLCP, "progress: %s", PEPY_ERR_NOMEM);
                return NOTOK;
            }
            (*p19) -> pe_cons = (*p13);
            (*p13) = *p19;
        }
    }
    if ((*p13) != NULLPE)
        if (set_add ((*pe), (*p13)) == NOTOK) {
            advise (NULLCP, "AddArgumentTBS %s%s", PEPY_ERR_BAD_SET,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }
    (*p13) = NULLPE;

    if (parm->ada_common->requestor) {
        if (build_IF_Name (p13, 0, NULL, NULLCP, parm->ada_common->requestor ) == NOTOK)
            return NOTOK;

#ifdef DEBUG
        (void) testdebug ((*p13), "requestor");
#endif

        {	/* requestor TAG PUSHDOWN */
            PE p20_z;
            register PE *p20 = &p20_z;

            if ((*p20 = pe_alloc (PE_CLASS_CONT, PE_FORM_CONS, 28)) == NULLPE) {
                advise (NULLCP, "requestor: %s", PEPY_ERR_NOMEM);
                return NOTOK;
            }
            (*p20) -> pe_cons = (*p13);
            (*p13) = *p20;
        }
    }
    if ((*p13) != NULLPE)
        if (set_add ((*pe), (*p13)) == NOTOK) {
            advise (NULLCP, "AddArgumentTBS %s%s", PEPY_ERR_BAD_SET,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }
    (*p13) = NULLPE;

    if (parm->ada_common->sec_parm) {
        if (build_STRONG_SecurityParameters (p13, 0, NULL, NULLCP, parm->ada_common->sec_parm ) == NOTOK)
            return NOTOK;

#ifdef DEBUG
        (void) testdebug ((*p13), "secparm");
#endif

        {	/* secparm TAG PUSHDOWN */
            PE p21_z;
            register PE *p21 = &p21_z;

            if ((*p21 = pe_alloc (PE_CLASS_CONT, PE_FORM_CONS, 29)) == NULLPE) {
                advise (NULLCP, "secparm: %s", PEPY_ERR_NOMEM);
                return NOTOK;
            }
            (*p21) -> pe_cons = (*p13);
            (*p13) = *p21;
        }
    }
    if ((*p13) != NULLPE)
        if (set_add ((*pe), (*p13)) == NOTOK) {
            advise (NULLCP, "AddArgumentTBS %s%s", PEPY_ERR_BAD_SET,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }
    (*p13) = NULLPE;

    if (parm->ada_common->svc) {
        if (build_STRONG_ServiceControls (p13, 0, NULL, NULLCP, parm->ada_common->svc ) == NOTOK)
            return NOTOK;

#ifdef DEBUG
        (void) testdebug ((*p13), "servcontr");
#endif

        {	/* servcontr TAG PUSHDOWN */
            PE p22_z;
            register PE *p22 = &p22_z;

            if ((*p22 = pe_alloc (PE_CLASS_CONT, PE_FORM_CONS, 30)) == NULLPE) {
                advise (NULLCP, "servcontr: %s", PEPY_ERR_NOMEM);
                return NOTOK;
            }
            (*p22) -> pe_cons = (*p13);
            (*p13) = *p22;
        }
    }
    if ((*p13) != NULLPE)
        if (set_add ((*pe), (*p13)) == NOTOK) {
            advise (NULLCP, "AddArgumentTBS %s%s", PEPY_ERR_BAD_SET,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }

#ifdef DEBUG
    (void) testdebug ((*pe), "STRONG.AddArgumentTBS");
#endif


    return OK;
}

/* ARGSUSED */

int	build_STRONG_AddArgument (pe, explicit, len, buffer, parm)
register PE     *pe;
int	explicit;
int	len;
char   *buffer;
AddArgument * parm;
{
# line 132 "STRONG.py"
    	PE	tbs;

    int	p23;

    switch (p23 = (parm->sig? 2:1)) {
        case 1:
            {
                PE	p24 = (build_addarg_tbs(parm,&tbs)) ;

                if (p24 == NULLPE) {
                    advise (NULLCP, "member %s", PEPY_ERR_INIT_FAILED);
                    return NOTOK;
                }
                ((*pe) = p24) -> pe_refcnt++;

#ifdef DEBUG
                (void) testdebug ((*pe), "member");
#endif

                {
# line 138 "STRONG.py"
    pe_free(tbs);
		
                }
            }
            break;
        case 2:
            {
                PE	p25_z = NULLPE;
                register PE *p25 = &p25_z;

                if (((*pe) = pe_alloc (PE_CLASS_UNIV, PE_FORM_CONS, PE_CONS_SEQ)) == NULLPE) {
                    advise (NULLCP, "member: %s", PEPY_ERR_NOMEM);
                    return NOTOK;
                }
                (*p25) = NULLPE;

                {
                    PE	p26 = (build_addarg_tbs(parm,&tbs)) ;

                    if (p26 == NULLPE) {
                        advise (NULLCP, "element %s", PEPY_ERR_INIT_FAILED);
                        return NOTOK;
                    }
                    ((*p25) = p26) -> pe_refcnt++;

#ifdef DEBUG
                    (void) testdebug ((*p25), "element");
#endif

                    {
# line 145 "STRONG.py"
    pe_free(tbs);
			
                    }
                }

                if ((*p25) != NULLPE)
                    if (seq_add ((*pe), (*p25), -1) == NOTOK) {
                        advise (NULLCP, "member %s%s", PEPY_ERR_BAD_SEQ,
                                pe_error ((*pe) -> pe_errno));
                        return NOTOK;
                    }
                (*p25) = NULLPE;

                {
                    if (build_SEC_AlgorithmIdentifier (p25, 0, NULL, NULLCP, parm->sig->signAI ) == NOTOK)
                        return NOTOK;

#ifdef DEBUG
                    (void) testdebug ((*p25), "element");
#endif

                }

                if ((*p25) != NULLPE)
                    if (seq_add ((*pe), (*p25), -1) == NOTOK) {
                        advise (NULLCP, "member %s%s", PEPY_ERR_BAD_SEQ,
                                pe_error ((*pe) -> pe_errno));
                        return NOTOK;
                    }
                (*p25) = NULLPE;

                {
                    PE	p27_z = NULLPE;
                    register PE *p27 = &p27_z;

                    char *p28;
                    int p29;
                    p28 = parm->sig->signature.bits ;
                    p29 = 
		     	parm->sig->signature.nbits ;
                    (*p27) = p28 ? strb2bitstr (p28, p29, PE_CLASS_UNIV, PE_PRIM_BITS) : NULLPE;
                    if ((*p27) == NULLPE) {
                        advise (NULLCP, "element %s", PEPY_ERR_INIT_FAILED);
                        return NOTOK;
                    }
                    if (((*p25) = bit2prim ((*p27))) == NULLPE) {
                        advise (NULLCP, "element: %s", PEPY_ERR_NOMEM);
                        return NOTOK;
                    }

#ifdef DEBUG
                    (void) testdebug ((*p25), "element");
#endif

                }

                if ((*p25) != NULLPE)
                    if (seq_add ((*pe), (*p25), -1) == NOTOK) {
                        advise (NULLCP, "member %s%s", PEPY_ERR_BAD_SEQ,
                                pe_error ((*pe) -> pe_errno));
                        return NOTOK;
                    }

#ifdef DEBUG
                (void) testdebug ((*pe), "member");
#endif

            }
            break;

        default:
            advise (NULLCP, "AddArgument %s%d", PEPY_ERR_INVALID_CHOICE, 
                    p23);
            return NOTOK;
    }

#ifdef DEBUG
    (void) testdebug ((*pe), "STRONG.AddArgument");
#endif


    return OK;
}

/* ARGSUSED */

int	build_STRONG_CompareArgumentTBS (pe, explicit, len, buffer, parm)
register PE     *pe;
int	explicit;
int	len;
char   *buffer;
CompareArgumentTBS * parm;
{
    PE	p30_z = NULLPE;
    register PE *p30 = &p30_z;

    if (((*pe) = pe_alloc (PE_CLASS_UNIV, PE_FORM_CONS, PE_CONS_SET)) == NULLPE) {
        advise (NULLCP, "CompareArgumentTBS: %s", PEPY_ERR_NOMEM);
        return NOTOK;
    }
    (*p30) = NULLPE;

    {
        if (build_IF_Name (p30, 0, NULL, NULLCP, parm->cma_object ) == NOTOK)
            return NOTOK;

#ifdef DEBUG
        (void) testdebug ((*p30), "object");
#endif

        {	/* object TAG PUSHDOWN */
            PE p31_z;
            register PE *p31 = &p31_z;

            if ((*p31 = pe_alloc (PE_CLASS_CONT, PE_FORM_CONS, 0)) == NULLPE) {
                advise (NULLCP, "object: %s", PEPY_ERR_NOMEM);
                return NOTOK;
            }
            (*p31) -> pe_cons = (*p30);
            (*p30) = *p31;
        }
    }
    if ((*p30) != NULLPE)
        if (set_add ((*pe), (*p30)) == NOTOK) {
            advise (NULLCP, "CompareArgumentTBS %s%s", PEPY_ERR_BAD_SET,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }
    (*p30) = NULLPE;

    {
        if (build_IF_AttributeValueAssertion (p30, 0, NULL, NULLCP, parm->cma_purported ) == NOTOK)
            return NOTOK;

#ifdef DEBUG
        (void) testdebug ((*p30), "purported");
#endif

        {	/* purported TAG PUSHDOWN */
            PE p32_z;
            register PE *p32 = &p32_z;

            if ((*p32 = pe_alloc (PE_CLASS_CONT, PE_FORM_CONS, 1)) == NULLPE) {
                advise (NULLCP, "purported: %s", PEPY_ERR_NOMEM);
                return NOTOK;
            }
            (*p32) -> pe_cons = (*p30);
            (*p30) = *p32;
        }
    }
    if ((*p30) != NULLPE)
        if (set_add ((*pe), (*p30)) == NOTOK) {
            advise (NULLCP, "CompareArgumentTBS %s%s", PEPY_ERR_BAD_SET,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }
    (*p30) = NULLPE;

    if (parm->cma_common->ext) {
        if (build_STRONG_SECExtensionSet (p30, 0, NULL, NULLCP, parm->cma_common->ext ) == NOTOK)
            return NOTOK;

#ifdef DEBUG
        (void) testdebug ((*p30), "extensions");
#endif

        {	/* extensions TAG PUSHDOWN */
            PE p33_z;
            register PE *p33 = &p33_z;

            if ((*p33 = pe_alloc (PE_CLASS_CONT, PE_FORM_CONS, 25)) == NULLPE) {
                advise (NULLCP, "extensions: %s", PEPY_ERR_NOMEM);
                return NOTOK;
            }
            (*p33) -> pe_cons = (*p30);
            (*p30) = *p33;
        }
    }
    if ((*p30) != NULLPE)
        if (set_add ((*pe), (*p30)) == NOTOK) {
            advise (NULLCP, "CompareArgumentTBS %s%s", PEPY_ERR_BAD_SET,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }
    (*p30) = NULLPE;

    if (parm->cma_common->aliasedRDNs != CA_NO_ALIASDEREFERENCED) {
        register integer p34 = parm->cma_common->aliasedRDNs ;

        if (((*p30) = num2prim (p34, PE_CLASS_UNIV, PE_PRIM_INT)) == NULLPE) {
            advise (NULLCP, "aliasedRDNs: %s", PEPY_ERR_NOMEM);
            return NOTOK;
        }

#ifdef DEBUG
        (void) testdebug ((*p30), "aliasedRDNs");
#endif

        {	/* aliasedRDNs TAG PUSHDOWN */
            PE p35_z;
            register PE *p35 = &p35_z;

            if ((*p35 = pe_alloc (PE_CLASS_CONT, PE_FORM_CONS, 26)) == NULLPE) {
                advise (NULLCP, "aliasedRDNs: %s", PEPY_ERR_NOMEM);
                return NOTOK;
            }
            (*p35) -> pe_cons = (*p30);
            (*p30) = *p35;
        }
    }
    if ((*p30) != NULLPE)
        if (set_add ((*pe), (*p30)) == NOTOK) {
            advise (NULLCP, "CompareArgumentTBS %s%s", PEPY_ERR_BAD_SET,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }
    (*p30) = NULLPE;

    if (parm->cma_common->progress) {
        if (build_STRONG_OperationProgress (p30, 0, NULL, NULLCP, parm->cma_common->progress ) == NOTOK)
            return NOTOK;

#ifdef DEBUG
        (void) testdebug ((*p30), "progress");
#endif

        {	/* progress TAG PUSHDOWN */
            PE p36_z;
            register PE *p36 = &p36_z;

            if ((*p36 = pe_alloc (PE_CLASS_CONT, PE_FORM_CONS, 27)) == NULLPE) {
                advise (NULLCP, "progress: %s", PEPY_ERR_NOMEM);
                return NOTOK;
            }
            (*p36) -> pe_cons = (*p30);
            (*p30) = *p36;
        }
    }
    if ((*p30) != NULLPE)
        if (set_add ((*pe), (*p30)) == NOTOK) {
            advise (NULLCP, "CompareArgumentTBS %s%s", PEPY_ERR_BAD_SET,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }
    (*p30) = NULLPE;

    if (parm->cma_common->requestor) {
        if (build_IF_Name (p30, 0, NULL, NULLCP, parm->cma_common->requestor ) == NOTOK)
            return NOTOK;

#ifdef DEBUG
        (void) testdebug ((*p30), "requestor");
#endif

        {	/* requestor TAG PUSHDOWN */
            PE p37_z;
            register PE *p37 = &p37_z;

            if ((*p37 = pe_alloc (PE_CLASS_CONT, PE_FORM_CONS, 28)) == NULLPE) {
                advise (NULLCP, "requestor: %s", PEPY_ERR_NOMEM);
                return NOTOK;
            }
            (*p37) -> pe_cons = (*p30);
            (*p30) = *p37;
        }
    }
    if ((*p30) != NULLPE)
        if (set_add ((*pe), (*p30)) == NOTOK) {
            advise (NULLCP, "CompareArgumentTBS %s%s", PEPY_ERR_BAD_SET,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }
    (*p30) = NULLPE;

    if (parm->cma_common->sec_parm) {
        if (build_STRONG_SecurityParameters (p30, 0, NULL, NULLCP, parm->cma_common->sec_parm ) == NOTOK)
            return NOTOK;

#ifdef DEBUG
        (void) testdebug ((*p30), "secparm");
#endif

        {	/* secparm TAG PUSHDOWN */
            PE p38_z;
            register PE *p38 = &p38_z;

            if ((*p38 = pe_alloc (PE_CLASS_CONT, PE_FORM_CONS, 29)) == NULLPE) {
                advise (NULLCP, "secparm: %s", PEPY_ERR_NOMEM);
                return NOTOK;
            }
            (*p38) -> pe_cons = (*p30);
            (*p30) = *p38;
        }
    }
    if ((*p30) != NULLPE)
        if (set_add ((*pe), (*p30)) == NOTOK) {
            advise (NULLCP, "CompareArgumentTBS %s%s", PEPY_ERR_BAD_SET,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }
    (*p30) = NULLPE;

    if (parm->cma_common->svc) {
        if (build_STRONG_ServiceControls (p30, 0, NULL, NULLCP, parm->cma_common->svc ) == NOTOK)
            return NOTOK;

#ifdef DEBUG
        (void) testdebug ((*p30), "servcontr");
#endif

        {	/* servcontr TAG PUSHDOWN */
            PE p39_z;
            register PE *p39 = &p39_z;

            if ((*p39 = pe_alloc (PE_CLASS_CONT, PE_FORM_CONS, 30)) == NULLPE) {
                advise (NULLCP, "servcontr: %s", PEPY_ERR_NOMEM);
                return NOTOK;
            }
            (*p39) -> pe_cons = (*p30);
            (*p30) = *p39;
        }
    }
    if ((*p30) != NULLPE)
        if (set_add ((*pe), (*p30)) == NOTOK) {
            advise (NULLCP, "CompareArgumentTBS %s%s", PEPY_ERR_BAD_SET,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }

#ifdef DEBUG
    (void) testdebug ((*pe), "STRONG.CompareArgumentTBS");
#endif


    return OK;
}

/* ARGSUSED */

int	build_STRONG_CompareArgument (pe, explicit, len, buffer, parm)
register PE     *pe;
int	explicit;
int	len;
char   *buffer;
CompareArgument * parm;
{
# line 203 "STRONG.py"
    	PE	tbs;

    int	p40;

    switch (p40 = (parm->sig? 2:1)) {
        case 1:
            {
                PE	p41 = (build_comparearg_tbs(parm,&tbs)) ;

                if (p41 == NULLPE) {
                    advise (NULLCP, "member %s", PEPY_ERR_INIT_FAILED);
                    return NOTOK;
                }
                ((*pe) = p41) -> pe_refcnt++;

#ifdef DEBUG
                (void) testdebug ((*pe), "member");
#endif

                {
# line 209 "STRONG.py"
    pe_free(tbs);
		
                }
            }
            break;
        case 2:
            {
                PE	p42_z = NULLPE;
                register PE *p42 = &p42_z;

                if (((*pe) = pe_alloc (PE_CLASS_UNIV, PE_FORM_CONS, PE_CONS_SEQ)) == NULLPE) {
                    advise (NULLCP, "member: %s", PEPY_ERR_NOMEM);
                    return NOTOK;
                }
                (*p42) = NULLPE;

                {
                    PE	p43 = (build_comparearg_tbs(parm,&tbs)) ;

                    if (p43 == NULLPE) {
                        advise (NULLCP, "element %s", PEPY_ERR_INIT_FAILED);
                        return NOTOK;
                    }
                    ((*p42) = p43) -> pe_refcnt++;

#ifdef DEBUG
                    (void) testdebug ((*p42), "element");
#endif

                    {
# line 216 "STRONG.py"
    pe_free(tbs);
			
                    }
                }

                if ((*p42) != NULLPE)
                    if (seq_add ((*pe), (*p42), -1) == NOTOK) {
                        advise (NULLCP, "member %s%s", PEPY_ERR_BAD_SEQ,
                                pe_error ((*pe) -> pe_errno));
                        return NOTOK;
                    }
                (*p42) = NULLPE;

                {
                    if (build_SEC_AlgorithmIdentifier (p42, 0, NULL, NULLCP, parm->sig->signAI ) == NOTOK)
                        return NOTOK;

#ifdef DEBUG
                    (void) testdebug ((*p42), "element");
#endif

                }

                if ((*p42) != NULLPE)
                    if (seq_add ((*pe), (*p42), -1) == NOTOK) {
                        advise (NULLCP, "member %s%s", PEPY_ERR_BAD_SEQ,
                                pe_error ((*pe) -> pe_errno));
                        return NOTOK;
                    }
                (*p42) = NULLPE;

                {
                    PE	p44_z = NULLPE;
                    register PE *p44 = &p44_z;

                    char *p45;
                    int p46;
                    p45 = parm->sig->signature.bits ;
                    p46 = 
		     	parm->sig->signature.nbits ;
                    (*p44) = p45 ? strb2bitstr (p45, p46, PE_CLASS_UNIV, PE_PRIM_BITS) : NULLPE;
                    if ((*p44) == NULLPE) {
                        advise (NULLCP, "element %s", PEPY_ERR_INIT_FAILED);
                        return NOTOK;
                    }
                    if (((*p42) = bit2prim ((*p44))) == NULLPE) {
                        advise (NULLCP, "element: %s", PEPY_ERR_NOMEM);
                        return NOTOK;
                    }

#ifdef DEBUG
                    (void) testdebug ((*p42), "element");
#endif

                }

                if ((*p42) != NULLPE)
                    if (seq_add ((*pe), (*p42), -1) == NOTOK) {
                        advise (NULLCP, "member %s%s", PEPY_ERR_BAD_SEQ,
                                pe_error ((*pe) -> pe_errno));
                        return NOTOK;
                    }

#ifdef DEBUG
                (void) testdebug ((*pe), "member");
#endif

            }
            break;

        default:
            advise (NULLCP, "CompareArgument %s%d", PEPY_ERR_INVALID_CHOICE, 
                    p40);
            return NOTOK;
    }

#ifdef DEBUG
    (void) testdebug ((*pe), "STRONG.CompareArgument");
#endif


    return OK;
}

/* ARGSUSED */

int	build_STRONG_CompareResultTBS (pe, explicit, len, buffer, parm)
register PE     *pe;
int	explicit;
int	len;
char   *buffer;
CompareResultTBS * parm;
{
    PE	p47_z = NULLPE;
    register PE *p47 = &p47_z;

    if (((*pe) = pe_alloc (PE_CLASS_UNIV, PE_FORM_CONS, PE_CONS_SET)) == NULLPE) {
        advise (NULLCP, "CompareResultTBS: %s", PEPY_ERR_NOMEM);
        return NOTOK;
    }
    (*p47) = NULLPE;

    if (parm->cmr_object) {
        if (build_IF_Name (p47, 0, NULL, NULLCP, parm->cmr_object ) == NOTOK)
            return NOTOK;
        (*p47) -> pe_class = PE_CLASS_UNIV;
        (*p47) -> pe_id = 16;

#ifdef DEBUG
        (void) testdebug ((*p47), "member");
#endif

    }
    if ((*p47) != NULLPE)
        if (set_add ((*pe), (*p47)) == NOTOK) {
            advise (NULLCP, "CompareResultTBS %s%s", PEPY_ERR_BAD_SET,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }
    (*p47) = NULLPE;

    {
        register int p48 = parm->cmr_matched ;

        if (((*p47) = flag2prim (p48, PE_CLASS_UNIV, PE_PRIM_BOOL)) == NULLPE) {
            advise (NULLCP, "matched: %s", PEPY_ERR_NOMEM);
            return NOTOK;
        }

#ifdef DEBUG
        (void) testdebug ((*p47), "matched");
#endif

        {	/* matched TAG PUSHDOWN */
            PE p49_z;
            register PE *p49 = &p49_z;

            if ((*p49 = pe_alloc (PE_CLASS_CONT, PE_FORM_CONS, 0)) == NULLPE) {
                advise (NULLCP, "matched: %s", PEPY_ERR_NOMEM);
                return NOTOK;
            }
            (*p49) -> pe_cons = (*p47);
            (*p47) = *p49;
        }
    }
    if ((*p47) != NULLPE)
        if (set_add ((*pe), (*p47)) == NOTOK) {
            advise (NULLCP, "CompareResultTBS %s%s", PEPY_ERR_BAD_SET,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }
    (*p47) = NULLPE;

    if (parm->cmr_fromEntry != TRUE) {
        register int p50 = parm->cmr_fromEntry ;

        if (((*p47) = flag2prim (p50, PE_CLASS_UNIV, PE_PRIM_BOOL)) == NULLPE) {
            advise (NULLCP, "fromEntry: %s", PEPY_ERR_NOMEM);
            return NOTOK;
        }

#ifdef DEBUG
        (void) testdebug ((*p47), "fromEntry");
#endif

        {	/* fromEntry TAG PUSHDOWN */
            PE p51_z;
            register PE *p51 = &p51_z;

            if ((*p51 = pe_alloc (PE_CLASS_CONT, PE_FORM_CONS, 1)) == NULLPE) {
                advise (NULLCP, "fromEntry: %s", PEPY_ERR_NOMEM);
                return NOTOK;
            }
            (*p51) -> pe_cons = (*p47);
            (*p47) = *p51;
        }
    }
    if ((*p47) != NULLPE)
        if (set_add ((*pe), (*p47)) == NOTOK) {
            advise (NULLCP, "CompareResultTBS %s%s", PEPY_ERR_BAD_SET,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }
    (*p47) = NULLPE;

    if (parm->cmr_common->aliasDereferenced) {
        register int p52 = parm->cmr_common->aliasDereferenced;

        if (((*p47) = flag2prim (p52, PE_CLASS_UNIV, PE_PRIM_BOOL)) == NULLPE) {
            advise (NULLCP, "aliasDereferenced: %s", PEPY_ERR_NOMEM);
            return NOTOK;
        }

#ifdef DEBUG
        (void) testdebug ((*p47), "aliasDereferenced");
#endif

        {	/* aliasDereferenced TAG PUSHDOWN */
            PE p53_z;
            register PE *p53 = &p53_z;

            if ((*p53 = pe_alloc (PE_CLASS_CONT, PE_FORM_CONS, 28)) == NULLPE) {
                advise (NULLCP, "aliasDereferenced: %s", PEPY_ERR_NOMEM);
                return NOTOK;
            }
            (*p53) -> pe_cons = (*p47);
            (*p47) = *p53;
        }
    }
    if ((*p47) != NULLPE)
        if (set_add ((*pe), (*p47)) == NOTOK) {
            advise (NULLCP, "CompareResultTBS %s%s", PEPY_ERR_BAD_SET,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }
    (*p47) = NULLPE;

    if (parm->cmr_common->performer) {
        if (build_IF_Name (p47, 0, NULL, NULLCP, parm->cmr_common->performer ) == NOTOK)
            return NOTOK;

#ifdef DEBUG
        (void) testdebug ((*p47), "performer");
#endif

        {	/* performer TAG PUSHDOWN */
            PE p54_z;
            register PE *p54 = &p54_z;

            if ((*p54 = pe_alloc (PE_CLASS_CONT, PE_FORM_CONS, 29)) == NULLPE) {
                advise (NULLCP, "performer: %s", PEPY_ERR_NOMEM);
                return NOTOK;
            }
            (*p54) -> pe_cons = (*p47);
            (*p47) = *p54;
        }
    }
    if ((*p47) != NULLPE)
        if (set_add ((*pe), (*p47)) == NOTOK) {
            advise (NULLCP, "CompareResultTBS %s%s", PEPY_ERR_BAD_SET,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }
    (*p47) = NULLPE;

    if (parm->cmr_common->sec_parm) {
        if (build_STRONG_SecurityParameters (p47, 0, NULL, NULLCP, parm->cmr_common->sec_parm ) == NOTOK)
            return NOTOK;

#ifdef DEBUG
        (void) testdebug ((*p47), "secparm");
#endif

        {	/* secparm TAG PUSHDOWN */
            PE p55_z;
            register PE *p55 = &p55_z;

            if ((*p55 = pe_alloc (PE_CLASS_CONT, PE_FORM_CONS, 30)) == NULLPE) {
                advise (NULLCP, "secparm: %s", PEPY_ERR_NOMEM);
                return NOTOK;
            }
            (*p55) -> pe_cons = (*p47);
            (*p47) = *p55;
        }
    }
    if ((*p47) != NULLPE)
        if (set_add ((*pe), (*p47)) == NOTOK) {
            advise (NULLCP, "CompareResultTBS %s%s", PEPY_ERR_BAD_SET,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }

#ifdef DEBUG
    (void) testdebug ((*pe), "STRONG.CompareResultTBS");
#endif


    return OK;
}

/* ARGSUSED */

int	build_STRONG_CompareResult (pe, explicit, len, buffer, parm)
register PE     *pe;
int	explicit;
int	len;
char   *buffer;
CompareResult * parm;
{
# line 262 "STRONG.py"
    	PE	tbs;

    int	p56;

    switch (p56 = (parm->sig? 2:1)) {
        case 1:
            {
                PE	p57 = (build_compareres_tbs(parm,&tbs)) ;

                if (p57 == NULLPE) {
                    advise (NULLCP, "member %s", PEPY_ERR_INIT_FAILED);
                    return NOTOK;
                }
                ((*pe) = p57) -> pe_refcnt++;

#ifdef DEBUG
                (void) testdebug ((*pe), "member");
#endif

                {
# line 268 "STRONG.py"
    pe_free(tbs);
		
                }
            }
            break;
        case 2:
            {
                PE	p58_z = NULLPE;
                register PE *p58 = &p58_z;

                if (((*pe) = pe_alloc (PE_CLASS_UNIV, PE_FORM_CONS, PE_CONS_SEQ)) == NULLPE) {
                    advise (NULLCP, "member: %s", PEPY_ERR_NOMEM);
                    return NOTOK;
                }
                (*p58) = NULLPE;

                {
                    PE	p59 = (build_compareres_tbs(parm,&tbs)) ;

                    if (p59 == NULLPE) {
                        advise (NULLCP, "element %s", PEPY_ERR_INIT_FAILED);
                        return NOTOK;
                    }
                    ((*p58) = p59) -> pe_refcnt++;

#ifdef DEBUG
                    (void) testdebug ((*p58), "element");
#endif

                    {
# line 275 "STRONG.py"
    pe_free(tbs);
			
                    }
                }

                if ((*p58) != NULLPE)
                    if (seq_add ((*pe), (*p58), -1) == NOTOK) {
                        advise (NULLCP, "member %s%s", PEPY_ERR_BAD_SEQ,
                                pe_error ((*pe) -> pe_errno));
                        return NOTOK;
                    }
                (*p58) = NULLPE;

                {
                    if (build_SEC_AlgorithmIdentifier (p58, 0, NULL, NULLCP, parm->sig->signAI ) == NOTOK)
                        return NOTOK;

#ifdef DEBUG
                    (void) testdebug ((*p58), "element");
#endif

                }

                if ((*p58) != NULLPE)
                    if (seq_add ((*pe), (*p58), -1) == NOTOK) {
                        advise (NULLCP, "member %s%s", PEPY_ERR_BAD_SEQ,
                                pe_error ((*pe) -> pe_errno));
                        return NOTOK;
                    }
                (*p58) = NULLPE;

                {
                    PE	p60_z = NULLPE;
                    register PE *p60 = &p60_z;

                    char *p61;
                    int p62;
                    p61 = parm->sig->signature.bits ;
                    p62 = 
		     	parm->sig->signature.nbits ;
                    (*p60) = p61 ? strb2bitstr (p61, p62, PE_CLASS_UNIV, PE_PRIM_BITS) : NULLPE;
                    if ((*p60) == NULLPE) {
                        advise (NULLCP, "element %s", PEPY_ERR_INIT_FAILED);
                        return NOTOK;
                    }
                    if (((*p58) = bit2prim ((*p60))) == NULLPE) {
                        advise (NULLCP, "element: %s", PEPY_ERR_NOMEM);
                        return NOTOK;
                    }

#ifdef DEBUG
                    (void) testdebug ((*p58), "element");
#endif

                }

                if ((*p58) != NULLPE)
                    if (seq_add ((*pe), (*p58), -1) == NOTOK) {
                        advise (NULLCP, "member %s%s", PEPY_ERR_BAD_SEQ,
                                pe_error ((*pe) -> pe_errno));
                        return NOTOK;
                    }

#ifdef DEBUG
                (void) testdebug ((*pe), "member");
#endif

            }
            break;

        default:
            advise (NULLCP, "CompareResult %s%d", PEPY_ERR_INVALID_CHOICE, 
                    p56);
            return NOTOK;
    }

#ifdef DEBUG
    (void) testdebug ((*pe), "STRONG.CompareResult");
#endif


    return OK;
}

/* ARGSUSED */

int	build_STRONG_ListArgumentTBS (pe, explicit, len, buffer, parm)
register PE     *pe;
int	explicit;
int	len;
char   *buffer;
ListArgumentTBS * parm;
{
    PE	p63_z = NULLPE;
    register PE *p63 = &p63_z;

    if (((*pe) = pe_alloc (PE_CLASS_UNIV, PE_FORM_CONS, PE_CONS_SET)) == NULLPE) {
        advise (NULLCP, "ListArgumentTBS: %s", PEPY_ERR_NOMEM);
        return NOTOK;
    }
    (*p63) = NULLPE;

    {
        if (build_IF_Name (p63, 0, NULL, NULLCP, parm->object ) == NOTOK)
            return NOTOK;

#ifdef DEBUG
        (void) testdebug ((*p63), "object");
#endif

        {	/* object TAG PUSHDOWN */
            PE p64_z;
            register PE *p64 = &p64_z;

            if ((*p64 = pe_alloc (PE_CLASS_CONT, PE_FORM_CONS, 0)) == NULLPE) {
                advise (NULLCP, "object: %s", PEPY_ERR_NOMEM);
                return NOTOK;
            }
            (*p64) -> pe_cons = (*p63);
            (*p63) = *p64;
        }
    }
    if ((*p63) != NULLPE)
        if (set_add ((*pe), (*p63)) == NOTOK) {
            advise (NULLCP, "ListArgumentTBS %s%s", PEPY_ERR_BAD_SET,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }
    (*p63) = NULLPE;

    if (parm->lsa_common->ext) {
        if (build_STRONG_SECExtensionSet (p63, 0, NULL, NULLCP, parm->lsa_common->ext ) == NOTOK)
            return NOTOK;

#ifdef DEBUG
        (void) testdebug ((*p63), "extensions");
#endif

        {	/* extensions TAG PUSHDOWN */
            PE p65_z;
            register PE *p65 = &p65_z;

            if ((*p65 = pe_alloc (PE_CLASS_CONT, PE_FORM_CONS, 25)) == NULLPE) {
                advise (NULLCP, "extensions: %s", PEPY_ERR_NOMEM);
                return NOTOK;
            }
            (*p65) -> pe_cons = (*p63);
            (*p63) = *p65;
        }
    }
    if ((*p63) != NULLPE)
        if (set_add ((*pe), (*p63)) == NOTOK) {
            advise (NULLCP, "ListArgumentTBS %s%s", PEPY_ERR_BAD_SET,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }
    (*p63) = NULLPE;

    if (parm->lsa_common->aliasedRDNs != CA_NO_ALIASDEREFERENCED) {
        register integer p66 = parm->lsa_common->aliasedRDNs ;

        if (((*p63) = num2prim (p66, PE_CLASS_UNIV, PE_PRIM_INT)) == NULLPE) {
            advise (NULLCP, "aliasedRDNs: %s", PEPY_ERR_NOMEM);
            return NOTOK;
        }

#ifdef DEBUG
        (void) testdebug ((*p63), "aliasedRDNs");
#endif

        {	/* aliasedRDNs TAG PUSHDOWN */
            PE p67_z;
            register PE *p67 = &p67_z;

            if ((*p67 = pe_alloc (PE_CLASS_CONT, PE_FORM_CONS, 26)) == NULLPE) {
                advise (NULLCP, "aliasedRDNs: %s", PEPY_ERR_NOMEM);
                return NOTOK;
            }
            (*p67) -> pe_cons = (*p63);
            (*p63) = *p67;
        }
    }
    if ((*p63) != NULLPE)
        if (set_add ((*pe), (*p63)) == NOTOK) {
            advise (NULLCP, "ListArgumentTBS %s%s", PEPY_ERR_BAD_SET,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }
    (*p63) = NULLPE;

    if (parm->lsa_common->progress) {
        if (build_STRONG_OperationProgress (p63, 0, NULL, NULLCP, parm->lsa_common->progress ) == NOTOK)
            return NOTOK;

#ifdef DEBUG
        (void) testdebug ((*p63), "progress");
#endif

        {	/* progress TAG PUSHDOWN */
            PE p68_z;
            register PE *p68 = &p68_z;

            if ((*p68 = pe_alloc (PE_CLASS_CONT, PE_FORM_CONS, 27)) == NULLPE) {
                advise (NULLCP, "progress: %s", PEPY_ERR_NOMEM);
                return NOTOK;
            }
            (*p68) -> pe_cons = (*p63);
            (*p63) = *p68;
        }
    }
    if ((*p63) != NULLPE)
        if (set_add ((*pe), (*p63)) == NOTOK) {
            advise (NULLCP, "ListArgumentTBS %s%s", PEPY_ERR_BAD_SET,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }
    (*p63) = NULLPE;

    if (parm->lsa_common->requestor) {
        if (build_IF_Name (p63, 0, NULL, NULLCP, parm->lsa_common->requestor ) == NOTOK)
            return NOTOK;

#ifdef DEBUG
        (void) testdebug ((*p63), "requestor");
#endif

        {	/* requestor TAG PUSHDOWN */
            PE p69_z;
            register PE *p69 = &p69_z;

            if ((*p69 = pe_alloc (PE_CLASS_CONT, PE_FORM_CONS, 28)) == NULLPE) {
                advise (NULLCP, "requestor: %s", PEPY_ERR_NOMEM);
                return NOTOK;
            }
            (*p69) -> pe_cons = (*p63);
            (*p63) = *p69;
        }
    }
    if ((*p63) != NULLPE)
        if (set_add ((*pe), (*p63)) == NOTOK) {
            advise (NULLCP, "ListArgumentTBS %s%s", PEPY_ERR_BAD_SET,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }
    (*p63) = NULLPE;

    if (parm->lsa_common->sec_parm) {
        if (build_STRONG_SecurityParameters (p63, 0, NULL, NULLCP, parm->lsa_common->sec_parm ) == NOTOK)
            return NOTOK;

#ifdef DEBUG
        (void) testdebug ((*p63), "secparm");
#endif

        {	/* secparm TAG PUSHDOWN */
            PE p70_z;
            register PE *p70 = &p70_z;

            if ((*p70 = pe_alloc (PE_CLASS_CONT, PE_FORM_CONS, 29)) == NULLPE) {
                advise (NULLCP, "secparm: %s", PEPY_ERR_NOMEM);
                return NOTOK;
            }
            (*p70) -> pe_cons = (*p63);
            (*p63) = *p70;
        }
    }
    if ((*p63) != NULLPE)
        if (set_add ((*pe), (*p63)) == NOTOK) {
            advise (NULLCP, "ListArgumentTBS %s%s", PEPY_ERR_BAD_SET,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }
    (*p63) = NULLPE;

    if (parm->lsa_common->svc) {
        if (build_STRONG_ServiceControls (p63, 0, NULL, NULLCP, parm->lsa_common->svc ) == NOTOK)
            return NOTOK;

#ifdef DEBUG
        (void) testdebug ((*p63), "servcontr");
#endif

        {	/* servcontr TAG PUSHDOWN */
            PE p71_z;
            register PE *p71 = &p71_z;

            if ((*p71 = pe_alloc (PE_CLASS_CONT, PE_FORM_CONS, 30)) == NULLPE) {
                advise (NULLCP, "servcontr: %s", PEPY_ERR_NOMEM);
                return NOTOK;
            }
            (*p71) -> pe_cons = (*p63);
            (*p63) = *p71;
        }
    }
    if ((*p63) != NULLPE)
        if (set_add ((*pe), (*p63)) == NOTOK) {
            advise (NULLCP, "ListArgumentTBS %s%s", PEPY_ERR_BAD_SET,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }

#ifdef DEBUG
    (void) testdebug ((*pe), "STRONG.ListArgumentTBS");
#endif


    return OK;
}

/* ARGSUSED */

int	build_STRONG_ListArgument (pe, explicit, len, buffer, parm)
register PE     *pe;
int	explicit;
int	len;
char   *buffer;
ListArgument * parm;
{
# line 329 "STRONG.py"
    	PE	tbs;

    int	p72;

    switch (p72 = (parm->sig? 2:1)) {
        case 1:
            {
                PE	p73 = (build_listarg_tbs(parm,&tbs)) ;

                if (p73 == NULLPE) {
                    advise (NULLCP, "member %s", PEPY_ERR_INIT_FAILED);
                    return NOTOK;
                }
                ((*pe) = p73) -> pe_refcnt++;

#ifdef DEBUG
                (void) testdebug ((*pe), "member");
#endif

                {
# line 335 "STRONG.py"
    pe_free(tbs);
		
                }
            }
            break;
        case 2:
            {
                PE	p74_z = NULLPE;
                register PE *p74 = &p74_z;

                if (((*pe) = pe_alloc (PE_CLASS_UNIV, PE_FORM_CONS, PE_CONS_SEQ)) == NULLPE) {
                    advise (NULLCP, "member: %s", PEPY_ERR_NOMEM);
                    return NOTOK;
                }
                (*p74) = NULLPE;

                {
                    PE	p75 = (build_listarg_tbs(parm,&tbs)) ;

                    if (p75 == NULLPE) {
                        advise (NULLCP, "element %s", PEPY_ERR_INIT_FAILED);
                        return NOTOK;
                    }
                    ((*p74) = p75) -> pe_refcnt++;

#ifdef DEBUG
                    (void) testdebug ((*p74), "element");
#endif

                    {
# line 342 "STRONG.py"
    pe_free(tbs);
			
                    }
                }

                if ((*p74) != NULLPE)
                    if (seq_add ((*pe), (*p74), -1) == NOTOK) {
                        advise (NULLCP, "member %s%s", PEPY_ERR_BAD_SEQ,
                                pe_error ((*pe) -> pe_errno));
                        return NOTOK;
                    }
                (*p74) = NULLPE;

                {
                    if (build_SEC_AlgorithmIdentifier (p74, 0, NULL, NULLCP, parm->sig->signAI ) == NOTOK)
                        return NOTOK;

#ifdef DEBUG
                    (void) testdebug ((*p74), "element");
#endif

                }

                if ((*p74) != NULLPE)
                    if (seq_add ((*pe), (*p74), -1) == NOTOK) {
                        advise (NULLCP, "member %s%s", PEPY_ERR_BAD_SEQ,
                                pe_error ((*pe) -> pe_errno));
                        return NOTOK;
                    }
                (*p74) = NULLPE;

                {
                    PE	p76_z = NULLPE;
                    register PE *p76 = &p76_z;

                    char *p77;
                    int p78;
                    p77 = parm->sig->signature.bits ;
                    p78 = 
		     	parm->sig->signature.nbits ;
                    (*p76) = p77 ? strb2bitstr (p77, p78, PE_CLASS_UNIV, PE_PRIM_BITS) : NULLPE;
                    if ((*p76) == NULLPE) {
                        advise (NULLCP, "element %s", PEPY_ERR_INIT_FAILED);
                        return NOTOK;
                    }
                    if (((*p74) = bit2prim ((*p76))) == NULLPE) {
                        advise (NULLCP, "element: %s", PEPY_ERR_NOMEM);
                        return NOTOK;
                    }

#ifdef DEBUG
                    (void) testdebug ((*p74), "element");
#endif

                }

                if ((*p74) != NULLPE)
                    if (seq_add ((*pe), (*p74), -1) == NOTOK) {
                        advise (NULLCP, "member %s%s", PEPY_ERR_BAD_SEQ,
                                pe_error ((*pe) -> pe_errno));
                        return NOTOK;
                    }

#ifdef DEBUG
                (void) testdebug ((*pe), "member");
#endif

            }
            break;

        default:
            advise (NULLCP, "ListArgument %s%d", PEPY_ERR_INVALID_CHOICE, 
                    p72);
            return NOTOK;
    }

#ifdef DEBUG
    (void) testdebug ((*pe), "STRONG.ListArgument");
#endif


    return OK;
}

/* ARGSUSED */

int	build_STRONG_ListResultTBS (pe, explicit, len, buffer, parm)
register PE     *pe;
int	explicit;
int	len;
char   *buffer;
ListResultTBS * parm;
{
    int	p79;

    switch (p79 = (parm->lsr_type)) {
        case 1:	/* listInfo */
            {
                if (build_STRONG_ListInfo (pe, 0, NULL, NULLCP, parm->lsrtbs_un.listinfo) == NOTOK)
                    return NOTOK;

#ifdef DEBUG
                (void) testdebug ((*pe), "listInfo");
#endif

            }
            break;
        case 2:	/* uncorrelatedListInfo */
            {
                if (build_STRONG_SETOFListResult (pe, 0, NULL, NULLCP, parm->lsrtbs_un.uncorrel_listinfo) == NOTOK)
                    return NOTOK;

#ifdef DEBUG
                (void) testdebug ((*pe), "uncorrelatedListInfo");
#endif

                {	/* uncorrelatedListInfo TAG PUSHDOWN */
                    PE p80_z;
                    register PE *p80 = &p80_z;

                    if ((*p80 = pe_alloc (PE_CLASS_CONT, PE_FORM_CONS, 0)) == NULLPE) {
                        advise (NULLCP, "uncorrelatedListInfo: %s", PEPY_ERR_NOMEM);
                        return NOTOK;
                    }
                    (*p80) -> pe_cons = (*pe);
                    (*pe) = *p80;
                }
            }
            break;

        default:
            advise (NULLCP, "ListResultTBS %s%d", PEPY_ERR_INVALID_CHOICE, 
                    p79);
            return NOTOK;
    }

#ifdef DEBUG
    (void) testdebug ((*pe), "STRONG.ListResultTBS");
#endif


    return OK;
}

/* ARGSUSED */

int	build_STRONG_ListResult (pe, explicit, len, buffer, parm)
register PE     *pe;
int	explicit;
int	len;
char   *buffer;
ListResult * parm;
{
# line 369 "STRONG.py"
    	PE	tbs;

    int	p81;

    switch (p81 = (parm->sig? 2:1)) {
        case 1:
            {
                PE	p82 = (build_listres_tbs(parm,&tbs)) ;

                if (p82 == NULLPE) {
                    advise (NULLCP, "member %s", PEPY_ERR_INIT_FAILED);
                    return NOTOK;
                }
                ((*pe) = p82) -> pe_refcnt++;

#ifdef DEBUG
                (void) testdebug ((*pe), "member");
#endif

                {
# line 375 "STRONG.py"
    pe_free(tbs);
		
                }
            }
            break;
        case 2:
            {
                PE	p83_z = NULLPE;
                register PE *p83 = &p83_z;

                if (((*pe) = pe_alloc (PE_CLASS_UNIV, PE_FORM_CONS, PE_CONS_SEQ)) == NULLPE) {
                    advise (NULLCP, "member: %s", PEPY_ERR_NOMEM);
                    return NOTOK;
                }
                (*p83) = NULLPE;

                {
                    PE	p84 = (build_listres_tbs(parm,&tbs)) ;

                    if (p84 == NULLPE) {
                        advise (NULLCP, "element %s", PEPY_ERR_INIT_FAILED);
                        return NOTOK;
                    }
                    ((*p83) = p84) -> pe_refcnt++;

#ifdef DEBUG
                    (void) testdebug ((*p83), "element");
#endif

                    {
# line 382 "STRONG.py"
    pe_free(tbs);
			
                    }
                }

                if ((*p83) != NULLPE)
                    if (seq_add ((*pe), (*p83), -1) == NOTOK) {
                        advise (NULLCP, "member %s%s", PEPY_ERR_BAD_SEQ,
                                pe_error ((*pe) -> pe_errno));
                        return NOTOK;
                    }
                (*p83) = NULLPE;

                {
                    if (build_SEC_AlgorithmIdentifier (p83, 0, NULL, NULLCP, parm->sig->signAI ) == NOTOK)
                        return NOTOK;

#ifdef DEBUG
                    (void) testdebug ((*p83), "element");
#endif

                }

                if ((*p83) != NULLPE)
                    if (seq_add ((*pe), (*p83), -1) == NOTOK) {
                        advise (NULLCP, "member %s%s", PEPY_ERR_BAD_SEQ,
                                pe_error ((*pe) -> pe_errno));
                        return NOTOK;
                    }
                (*p83) = NULLPE;

                {
                    PE	p85_z = NULLPE;
                    register PE *p85 = &p85_z;

                    char *p86;
                    int p87;
                    p86 = parm->sig->signature.bits ;
                    p87 = 
		     	parm->sig->signature.nbits ;
                    (*p85) = p86 ? strb2bitstr (p86, p87, PE_CLASS_UNIV, PE_PRIM_BITS) : NULLPE;
                    if ((*p85) == NULLPE) {
                        advise (NULLCP, "element %s", PEPY_ERR_INIT_FAILED);
                        return NOTOK;
                    }
                    if (((*p83) = bit2prim ((*p85))) == NULLPE) {
                        advise (NULLCP, "element: %s", PEPY_ERR_NOMEM);
                        return NOTOK;
                    }

#ifdef DEBUG
                    (void) testdebug ((*p83), "element");
#endif

                }

                if ((*p83) != NULLPE)
                    if (seq_add ((*pe), (*p83), -1) == NOTOK) {
                        advise (NULLCP, "member %s%s", PEPY_ERR_BAD_SEQ,
                                pe_error ((*pe) -> pe_errno));
                        return NOTOK;
                    }

#ifdef DEBUG
                (void) testdebug ((*pe), "member");
#endif

            }
            break;

        default:
            advise (NULLCP, "ListResult %s%d", PEPY_ERR_INVALID_CHOICE, 
                    p81);
            return NOTOK;
    }

#ifdef DEBUG
    (void) testdebug ((*pe), "STRONG.ListResult");
#endif


    return OK;
}

/* ARGSUSED */

int	build_STRONG_SETOFListResult (pe, explicit, len, buffer, parm)
PE     *pe;
int	explicit;
int	len;
char   *buffer;
SET_OF_ListResult * parm;
{
# line 403 "STRONG.py"
    
	PE pe_enc = encode_STRONG_DER_SET_OF(parm, LISTRESULTSET);
	
    PE	p88 = pe_enc ;

    if (p88 == NULLPE) {
        advise (NULLCP, "SETOFListResult %s", PEPY_ERR_INIT_FAILED);
        return NOTOK;
    }
    ((*pe) = p88) -> pe_refcnt++;

#ifdef DEBUG
    (void) testdebug ((*pe), "STRONG.SETOFListResult");
#endif

    {
# line 408 "STRONG.py"

	pe_free(pe_enc);
	
    }

    return OK;
}

/* ARGSUSED */

int	build_STRONG_ModifyEntryArgumentTBS (pe, explicit, len, buffer, parm)
register PE     *pe;
int	explicit;
int	len;
char   *buffer;
ModifyEntryArgumentTBS * parm;
{
    PE	p89_z = NULLPE;
    register PE *p89 = &p89_z;

    if (((*pe) = pe_alloc (PE_CLASS_UNIV, PE_FORM_CONS, PE_CONS_SET)) == NULLPE) {
        advise (NULLCP, "ModifyEntryArgumentTBS: %s", PEPY_ERR_NOMEM);
        return NOTOK;
    }
    (*p89) = NULLPE;

    {
        if (build_IF_Name (p89, 0, NULL, NULLCP, parm->mea_object ) == NOTOK)
            return NOTOK;

#ifdef DEBUG
        (void) testdebug ((*p89), "object");
#endif

        {	/* object TAG PUSHDOWN */
            PE p90_z;
            register PE *p90 = &p90_z;

            if ((*p90 = pe_alloc (PE_CLASS_CONT, PE_FORM_CONS, 0)) == NULLPE) {
                advise (NULLCP, "object: %s", PEPY_ERR_NOMEM);
                return NOTOK;
            }
            (*p90) -> pe_cons = (*p89);
            (*p89) = *p90;
        }
    }
    if ((*p89) != NULLPE)
        if (set_add ((*pe), (*p89)) == NOTOK) {
            advise (NULLCP, "ModifyEntryArgumentTBS %s%s", PEPY_ERR_BAD_SET,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }
    (*p89) = NULLPE;

    {
        if (build_STRONG_EntryModificationSequence (p89, 0, NULL, NULLCP, parm->mea_changes ) == NOTOK)
            return NOTOK;

#ifdef DEBUG
        (void) testdebug ((*p89), "changes");
#endif

        {	/* changes TAG PUSHDOWN */
            PE p91_z;
            register PE *p91 = &p91_z;

            if ((*p91 = pe_alloc (PE_CLASS_CONT, PE_FORM_CONS, 1)) == NULLPE) {
                advise (NULLCP, "changes: %s", PEPY_ERR_NOMEM);
                return NOTOK;
            }
            (*p91) -> pe_cons = (*p89);
            (*p89) = *p91;
        }
    }
    if ((*p89) != NULLPE)
        if (set_add ((*pe), (*p89)) == NOTOK) {
            advise (NULLCP, "ModifyEntryArgumentTBS %s%s", PEPY_ERR_BAD_SET,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }
    (*p89) = NULLPE;

    if (parm->mea_common->ext) {
        if (build_STRONG_SECExtensionSet (p89, 0, NULL, NULLCP, parm->mea_common->ext ) == NOTOK)
            return NOTOK;

#ifdef DEBUG
        (void) testdebug ((*p89), "extensions");
#endif

        {	/* extensions TAG PUSHDOWN */
            PE p92_z;
            register PE *p92 = &p92_z;

            if ((*p92 = pe_alloc (PE_CLASS_CONT, PE_FORM_CONS, 25)) == NULLPE) {
                advise (NULLCP, "extensions: %s", PEPY_ERR_NOMEM);
                return NOTOK;
            }
            (*p92) -> pe_cons = (*p89);
            (*p89) = *p92;
        }
    }
    if ((*p89) != NULLPE)
        if (set_add ((*pe), (*p89)) == NOTOK) {
            advise (NULLCP, "ModifyEntryArgumentTBS %s%s", PEPY_ERR_BAD_SET,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }
    (*p89) = NULLPE;

    if (parm->mea_common->aliasedRDNs != CA_NO_ALIASDEREFERENCED) {
        register integer p93 = parm->mea_common->aliasedRDNs ;

        if (((*p89) = num2prim (p93, PE_CLASS_UNIV, PE_PRIM_INT)) == NULLPE) {
            advise (NULLCP, "aliasedRDNs: %s", PEPY_ERR_NOMEM);
            return NOTOK;
        }

#ifdef DEBUG
        (void) testdebug ((*p89), "aliasedRDNs");
#endif

        {	/* aliasedRDNs TAG PUSHDOWN */
            PE p94_z;
            register PE *p94 = &p94_z;

            if ((*p94 = pe_alloc (PE_CLASS_CONT, PE_FORM_CONS, 26)) == NULLPE) {
                advise (NULLCP, "aliasedRDNs: %s", PEPY_ERR_NOMEM);
                return NOTOK;
            }
            (*p94) -> pe_cons = (*p89);
            (*p89) = *p94;
        }
    }
    if ((*p89) != NULLPE)
        if (set_add ((*pe), (*p89)) == NOTOK) {
            advise (NULLCP, "ModifyEntryArgumentTBS %s%s", PEPY_ERR_BAD_SET,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }
    (*p89) = NULLPE;

    if (parm->mea_common->progress) {
        if (build_STRONG_OperationProgress (p89, 0, NULL, NULLCP, parm->mea_common->progress ) == NOTOK)
            return NOTOK;

#ifdef DEBUG
        (void) testdebug ((*p89), "progress");
#endif

        {	/* progress TAG PUSHDOWN */
            PE p95_z;
            register PE *p95 = &p95_z;

            if ((*p95 = pe_alloc (PE_CLASS_CONT, PE_FORM_CONS, 27)) == NULLPE) {
                advise (NULLCP, "progress: %s", PEPY_ERR_NOMEM);
                return NOTOK;
            }
            (*p95) -> pe_cons = (*p89);
            (*p89) = *p95;
        }
    }
    if ((*p89) != NULLPE)
        if (set_add ((*pe), (*p89)) == NOTOK) {
            advise (NULLCP, "ModifyEntryArgumentTBS %s%s", PEPY_ERR_BAD_SET,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }
    (*p89) = NULLPE;

    if (parm->mea_common->requestor) {
        if (build_IF_Name (p89, 0, NULL, NULLCP, parm->mea_common->requestor ) == NOTOK)
            return NOTOK;

#ifdef DEBUG
        (void) testdebug ((*p89), "requestor");
#endif

        {	/* requestor TAG PUSHDOWN */
            PE p96_z;
            register PE *p96 = &p96_z;

            if ((*p96 = pe_alloc (PE_CLASS_CONT, PE_FORM_CONS, 28)) == NULLPE) {
                advise (NULLCP, "requestor: %s", PEPY_ERR_NOMEM);
                return NOTOK;
            }
            (*p96) -> pe_cons = (*p89);
            (*p89) = *p96;
        }
    }
    if ((*p89) != NULLPE)
        if (set_add ((*pe), (*p89)) == NOTOK) {
            advise (NULLCP, "ModifyEntryArgumentTBS %s%s", PEPY_ERR_BAD_SET,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }
    (*p89) = NULLPE;

    if (parm->mea_common->sec_parm) {
        if (build_STRONG_SecurityParameters (p89, 0, NULL, NULLCP, parm->mea_common->sec_parm ) == NOTOK)
            return NOTOK;

#ifdef DEBUG
        (void) testdebug ((*p89), "secparm");
#endif

        {	/* secparm TAG PUSHDOWN */
            PE p97_z;
            register PE *p97 = &p97_z;

            if ((*p97 = pe_alloc (PE_CLASS_CONT, PE_FORM_CONS, 29)) == NULLPE) {
                advise (NULLCP, "secparm: %s", PEPY_ERR_NOMEM);
                return NOTOK;
            }
            (*p97) -> pe_cons = (*p89);
            (*p89) = *p97;
        }
    }
    if ((*p89) != NULLPE)
        if (set_add ((*pe), (*p89)) == NOTOK) {
            advise (NULLCP, "ModifyEntryArgumentTBS %s%s", PEPY_ERR_BAD_SET,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }
    (*p89) = NULLPE;

    if (parm->mea_common->svc) {
        if (build_STRONG_ServiceControls (p89, 0, NULL, NULLCP, parm->mea_common->svc ) == NOTOK)
            return NOTOK;

#ifdef DEBUG
        (void) testdebug ((*p89), "servcontr");
#endif

        {	/* servcontr TAG PUSHDOWN */
            PE p98_z;
            register PE *p98 = &p98_z;

            if ((*p98 = pe_alloc (PE_CLASS_CONT, PE_FORM_CONS, 30)) == NULLPE) {
                advise (NULLCP, "servcontr: %s", PEPY_ERR_NOMEM);
                return NOTOK;
            }
            (*p98) -> pe_cons = (*p89);
            (*p89) = *p98;
        }
    }
    if ((*p89) != NULLPE)
        if (set_add ((*pe), (*p89)) == NOTOK) {
            advise (NULLCP, "ModifyEntryArgumentTBS %s%s", PEPY_ERR_BAD_SET,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }

#ifdef DEBUG
    (void) testdebug ((*pe), "STRONG.ModifyEntryArgumentTBS");
#endif


    return OK;
}

/* ARGSUSED */

int	build_STRONG_ModifyEntryArgument (pe, explicit, len, buffer, parm)
register PE     *pe;
int	explicit;
int	len;
char   *buffer;
ModifyEntryArgument * parm;
{
# line 458 "STRONG.py"
    	PE	tbs;

    int	p99;

    switch (p99 = (parm->sig? 2:1)) {
        case 1:
            {
                PE	p100 = (build_modifyentryarg_tbs(parm,&tbs)) ;

                if (p100 == NULLPE) {
                    advise (NULLCP, "member %s", PEPY_ERR_INIT_FAILED);
                    return NOTOK;
                }
                ((*pe) = p100) -> pe_refcnt++;

#ifdef DEBUG
                (void) testdebug ((*pe), "member");
#endif

                {
# line 464 "STRONG.py"
    pe_free(tbs);
		
                }
            }
            break;
        case 2:
            {
                PE	p101_z = NULLPE;
                register PE *p101 = &p101_z;

                if (((*pe) = pe_alloc (PE_CLASS_UNIV, PE_FORM_CONS, PE_CONS_SEQ)) == NULLPE) {
                    advise (NULLCP, "member: %s", PEPY_ERR_NOMEM);
                    return NOTOK;
                }
                (*p101) = NULLPE;

                {
                    PE	p102 = (build_modifyentryarg_tbs(parm,&tbs)) ;

                    if (p102 == NULLPE) {
                        advise (NULLCP, "element %s", PEPY_ERR_INIT_FAILED);
                        return NOTOK;
                    }
                    ((*p101) = p102) -> pe_refcnt++;

#ifdef DEBUG
                    (void) testdebug ((*p101), "element");
#endif

                    {
# line 471 "STRONG.py"
    pe_free(tbs);
			
                    }
                }

                if ((*p101) != NULLPE)
                    if (seq_add ((*pe), (*p101), -1) == NOTOK) {
                        advise (NULLCP, "member %s%s", PEPY_ERR_BAD_SEQ,
                                pe_error ((*pe) -> pe_errno));
                        return NOTOK;
                    }
                (*p101) = NULLPE;

                {
                    if (build_SEC_AlgorithmIdentifier (p101, 0, NULL, NULLCP, parm->sig->signAI ) == NOTOK)
                        return NOTOK;

#ifdef DEBUG
                    (void) testdebug ((*p101), "element");
#endif

                }

                if ((*p101) != NULLPE)
                    if (seq_add ((*pe), (*p101), -1) == NOTOK) {
                        advise (NULLCP, "member %s%s", PEPY_ERR_BAD_SEQ,
                                pe_error ((*pe) -> pe_errno));
                        return NOTOK;
                    }
                (*p101) = NULLPE;

                {
                    PE	p103_z = NULLPE;
                    register PE *p103 = &p103_z;

                    char *p104;
                    int p105;
                    p104 = parm->sig->signature.bits ;
                    p105 = 
		     	parm->sig->signature.nbits ;
                    (*p103) = p104 ? strb2bitstr (p104, p105, PE_CLASS_UNIV, PE_PRIM_BITS) : NULLPE;
                    if ((*p103) == NULLPE) {
                        advise (NULLCP, "element %s", PEPY_ERR_INIT_FAILED);
                        return NOTOK;
                    }
                    if (((*p101) = bit2prim ((*p103))) == NULLPE) {
                        advise (NULLCP, "element: %s", PEPY_ERR_NOMEM);
                        return NOTOK;
                    }

#ifdef DEBUG
                    (void) testdebug ((*p101), "element");
#endif

                }

                if ((*p101) != NULLPE)
                    if (seq_add ((*pe), (*p101), -1) == NOTOK) {
                        advise (NULLCP, "member %s%s", PEPY_ERR_BAD_SEQ,
                                pe_error ((*pe) -> pe_errno));
                        return NOTOK;
                    }

#ifdef DEBUG
                (void) testdebug ((*pe), "member");
#endif

            }
            break;

        default:
            advise (NULLCP, "ModifyEntryArgument %s%d", PEPY_ERR_INVALID_CHOICE, 
                    p99);
            return NOTOK;
    }

#ifdef DEBUG
    (void) testdebug ((*pe), "STRONG.ModifyEntryArgument");
#endif


    return OK;
}

/* ARGSUSED */

int	build_STRONG_ModifyRDNArgumentTBS (pe, explicit, len, buffer, parm)
register PE     *pe;
int	explicit;
int	len;
char   *buffer;
ModifyRDNArgumentTBS * parm;
{
    PE	p106_z = NULLPE;
    register PE *p106 = &p106_z;

    if (((*pe) = pe_alloc (PE_CLASS_UNIV, PE_FORM_CONS, PE_CONS_SET)) == NULLPE) {
        advise (NULLCP, "ModifyRDNArgumentTBS: %s", PEPY_ERR_NOMEM);
        return NOTOK;
    }
    (*p106) = NULLPE;

    {
        if (build_IF_Name (p106, 0, NULL, NULLCP, parm->mra_object ) == NOTOK)
            return NOTOK;

#ifdef DEBUG
        (void) testdebug ((*p106), "object");
#endif

        {	/* object TAG PUSHDOWN */
            PE p107_z;
            register PE *p107 = &p107_z;

            if ((*p107 = pe_alloc (PE_CLASS_CONT, PE_FORM_CONS, 0)) == NULLPE) {
                advise (NULLCP, "object: %s", PEPY_ERR_NOMEM);
                return NOTOK;
            }
            (*p107) -> pe_cons = (*p106);
            (*p106) = *p107;
        }
    }
    if ((*p106) != NULLPE)
        if (set_add ((*pe), (*p106)) == NOTOK) {
            advise (NULLCP, "ModifyRDNArgumentTBS %s%s", PEPY_ERR_BAD_SET,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }
    (*p106) = NULLPE;

    {
        if (build_IF_RelativeDistinguishedName (p106, 0, NULL, NULLCP, parm->mra_newrdn ) == NOTOK)
            return NOTOK;

#ifdef DEBUG
        (void) testdebug ((*p106), "newRDN");
#endif

        {	/* newRDN TAG PUSHDOWN */
            PE p108_z;
            register PE *p108 = &p108_z;

            if ((*p108 = pe_alloc (PE_CLASS_CONT, PE_FORM_CONS, 1)) == NULLPE) {
                advise (NULLCP, "newRDN: %s", PEPY_ERR_NOMEM);
                return NOTOK;
            }
            (*p108) -> pe_cons = (*p106);
            (*p106) = *p108;
        }
    }
    if ((*p106) != NULLPE)
        if (set_add ((*pe), (*p106)) == NOTOK) {
            advise (NULLCP, "ModifyRDNArgumentTBS %s%s", PEPY_ERR_BAD_SET,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }
    (*p106) = NULLPE;

    if (parm->deleterdn) {
        register int p109 = parm->deleterdn ;

        if (((*p106) = flag2prim (p109, PE_CLASS_UNIV, PE_PRIM_BOOL)) == NULLPE) {
            advise (NULLCP, "deleteOldRDN: %s", PEPY_ERR_NOMEM);
            return NOTOK;
        }

#ifdef DEBUG
        (void) testdebug ((*p106), "deleteOldRDN");
#endif

        {	/* deleteOldRDN TAG PUSHDOWN */
            PE p110_z;
            register PE *p110 = &p110_z;

            if ((*p110 = pe_alloc (PE_CLASS_CONT, PE_FORM_CONS, 2)) == NULLPE) {
                advise (NULLCP, "deleteOldRDN: %s", PEPY_ERR_NOMEM);
                return NOTOK;
            }
            (*p110) -> pe_cons = (*p106);
            (*p106) = *p110;
        }
    }
    if ((*p106) != NULLPE)
        if (set_add ((*pe), (*p106)) == NOTOK) {
            advise (NULLCP, "ModifyRDNArgumentTBS %s%s", PEPY_ERR_BAD_SET,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }
    (*p106) = NULLPE;

    if (parm->mra_common->ext) {
        if (build_STRONG_SECExtensionSet (p106, 0, NULL, NULLCP, parm->mra_common->ext ) == NOTOK)
            return NOTOK;

#ifdef DEBUG
        (void) testdebug ((*p106), "extensions");
#endif

        {	/* extensions TAG PUSHDOWN */
            PE p111_z;
            register PE *p111 = &p111_z;

            if ((*p111 = pe_alloc (PE_CLASS_CONT, PE_FORM_CONS, 25)) == NULLPE) {
                advise (NULLCP, "extensions: %s", PEPY_ERR_NOMEM);
                return NOTOK;
            }
            (*p111) -> pe_cons = (*p106);
            (*p106) = *p111;
        }
    }
    if ((*p106) != NULLPE)
        if (set_add ((*pe), (*p106)) == NOTOK) {
            advise (NULLCP, "ModifyRDNArgumentTBS %s%s", PEPY_ERR_BAD_SET,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }
    (*p106) = NULLPE;

    if (parm->mra_common->aliasedRDNs != CA_NO_ALIASDEREFERENCED) {
        register integer p112 = parm->mra_common->aliasedRDNs ;

        if (((*p106) = num2prim (p112, PE_CLASS_UNIV, PE_PRIM_INT)) == NULLPE) {
            advise (NULLCP, "aliasedRDNs: %s", PEPY_ERR_NOMEM);
            return NOTOK;
        }

#ifdef DEBUG
        (void) testdebug ((*p106), "aliasedRDNs");
#endif

        {	/* aliasedRDNs TAG PUSHDOWN */
            PE p113_z;
            register PE *p113 = &p113_z;

            if ((*p113 = pe_alloc (PE_CLASS_CONT, PE_FORM_CONS, 26)) == NULLPE) {
                advise (NULLCP, "aliasedRDNs: %s", PEPY_ERR_NOMEM);
                return NOTOK;
            }
            (*p113) -> pe_cons = (*p106);
            (*p106) = *p113;
        }
    }
    if ((*p106) != NULLPE)
        if (set_add ((*pe), (*p106)) == NOTOK) {
            advise (NULLCP, "ModifyRDNArgumentTBS %s%s", PEPY_ERR_BAD_SET,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }
    (*p106) = NULLPE;

    if (parm->mra_common->progress) {
        if (build_STRONG_OperationProgress (p106, 0, NULL, NULLCP, parm->mra_common->progress ) == NOTOK)
            return NOTOK;

#ifdef DEBUG
        (void) testdebug ((*p106), "progress");
#endif

        {	/* progress TAG PUSHDOWN */
            PE p114_z;
            register PE *p114 = &p114_z;

            if ((*p114 = pe_alloc (PE_CLASS_CONT, PE_FORM_CONS, 27)) == NULLPE) {
                advise (NULLCP, "progress: %s", PEPY_ERR_NOMEM);
                return NOTOK;
            }
            (*p114) -> pe_cons = (*p106);
            (*p106) = *p114;
        }
    }
    if ((*p106) != NULLPE)
        if (set_add ((*pe), (*p106)) == NOTOK) {
            advise (NULLCP, "ModifyRDNArgumentTBS %s%s", PEPY_ERR_BAD_SET,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }
    (*p106) = NULLPE;

    if (parm->mra_common->requestor) {
        if (build_IF_Name (p106, 0, NULL, NULLCP, parm->mra_common->requestor ) == NOTOK)
            return NOTOK;

#ifdef DEBUG
        (void) testdebug ((*p106), "requestor");
#endif

        {	/* requestor TAG PUSHDOWN */
            PE p115_z;
            register PE *p115 = &p115_z;

            if ((*p115 = pe_alloc (PE_CLASS_CONT, PE_FORM_CONS, 28)) == NULLPE) {
                advise (NULLCP, "requestor: %s", PEPY_ERR_NOMEM);
                return NOTOK;
            }
            (*p115) -> pe_cons = (*p106);
            (*p106) = *p115;
        }
    }
    if ((*p106) != NULLPE)
        if (set_add ((*pe), (*p106)) == NOTOK) {
            advise (NULLCP, "ModifyRDNArgumentTBS %s%s", PEPY_ERR_BAD_SET,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }
    (*p106) = NULLPE;

    if (parm->mra_common->sec_parm) {
        if (build_STRONG_SecurityParameters (p106, 0, NULL, NULLCP, parm->mra_common->sec_parm ) == NOTOK)
            return NOTOK;

#ifdef DEBUG
        (void) testdebug ((*p106), "secparm");
#endif

        {	/* secparm TAG PUSHDOWN */
            PE p116_z;
            register PE *p116 = &p116_z;

            if ((*p116 = pe_alloc (PE_CLASS_CONT, PE_FORM_CONS, 29)) == NULLPE) {
                advise (NULLCP, "secparm: %s", PEPY_ERR_NOMEM);
                return NOTOK;
            }
            (*p116) -> pe_cons = (*p106);
            (*p106) = *p116;
        }
    }
    if ((*p106) != NULLPE)
        if (set_add ((*pe), (*p106)) == NOTOK) {
            advise (NULLCP, "ModifyRDNArgumentTBS %s%s", PEPY_ERR_BAD_SET,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }
    (*p106) = NULLPE;

    if (parm->mra_common->svc) {
        if (build_STRONG_ServiceControls (p106, 0, NULL, NULLCP, parm->mra_common->svc ) == NOTOK)
            return NOTOK;

#ifdef DEBUG
        (void) testdebug ((*p106), "servcontr");
#endif

        {	/* servcontr TAG PUSHDOWN */
            PE p117_z;
            register PE *p117 = &p117_z;

            if ((*p117 = pe_alloc (PE_CLASS_CONT, PE_FORM_CONS, 30)) == NULLPE) {
                advise (NULLCP, "servcontr: %s", PEPY_ERR_NOMEM);
                return NOTOK;
            }
            (*p117) -> pe_cons = (*p106);
            (*p106) = *p117;
        }
    }
    if ((*p106) != NULLPE)
        if (set_add ((*pe), (*p106)) == NOTOK) {
            advise (NULLCP, "ModifyRDNArgumentTBS %s%s", PEPY_ERR_BAD_SET,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }

#ifdef DEBUG
    (void) testdebug ((*pe), "STRONG.ModifyRDNArgumentTBS");
#endif


    return OK;
}

/* ARGSUSED */

int	build_STRONG_ModifyRDNArgument (pe, explicit, len, buffer, parm)
register PE     *pe;
int	explicit;
int	len;
char   *buffer;
ModifyRDNArgument * parm;
{
# line 534 "STRONG.py"
    	PE	tbs;

    int	p118;

    switch (p118 = (parm->sig? 2:1)) {
        case 1:
            {
                PE	p119 = (build_modifyrdnarg_tbs(parm,&tbs)) ;

                if (p119 == NULLPE) {
                    advise (NULLCP, "member %s", PEPY_ERR_INIT_FAILED);
                    return NOTOK;
                }
                ((*pe) = p119) -> pe_refcnt++;

#ifdef DEBUG
                (void) testdebug ((*pe), "member");
#endif

                {
# line 540 "STRONG.py"
    pe_free(tbs);
		
                }
            }
            break;
        case 2:
            {
                PE	p120_z = NULLPE;
                register PE *p120 = &p120_z;

                if (((*pe) = pe_alloc (PE_CLASS_UNIV, PE_FORM_CONS, PE_CONS_SEQ)) == NULLPE) {
                    advise (NULLCP, "member: %s", PEPY_ERR_NOMEM);
                    return NOTOK;
                }
                (*p120) = NULLPE;

                {
                    PE	p121 = (build_modifyrdnarg_tbs(parm,&tbs)) ;

                    if (p121 == NULLPE) {
                        advise (NULLCP, "element %s", PEPY_ERR_INIT_FAILED);
                        return NOTOK;
                    }
                    ((*p120) = p121) -> pe_refcnt++;

#ifdef DEBUG
                    (void) testdebug ((*p120), "element");
#endif

                    {
# line 547 "STRONG.py"
    pe_free(tbs);
			
                    }
                }

                if ((*p120) != NULLPE)
                    if (seq_add ((*pe), (*p120), -1) == NOTOK) {
                        advise (NULLCP, "member %s%s", PEPY_ERR_BAD_SEQ,
                                pe_error ((*pe) -> pe_errno));
                        return NOTOK;
                    }
                (*p120) = NULLPE;

                {
                    if (build_SEC_AlgorithmIdentifier (p120, 0, NULL, NULLCP, parm->sig->signAI ) == NOTOK)
                        return NOTOK;

#ifdef DEBUG
                    (void) testdebug ((*p120), "element");
#endif

                }

                if ((*p120) != NULLPE)
                    if (seq_add ((*pe), (*p120), -1) == NOTOK) {
                        advise (NULLCP, "member %s%s", PEPY_ERR_BAD_SEQ,
                                pe_error ((*pe) -> pe_errno));
                        return NOTOK;
                    }
                (*p120) = NULLPE;

                {
                    PE	p122_z = NULLPE;
                    register PE *p122 = &p122_z;

                    char *p123;
                    int p124;
                    p123 = parm->sig->signature.bits ;
                    p124 = 
		     	parm->sig->signature.nbits ;
                    (*p122) = p123 ? strb2bitstr (p123, p124, PE_CLASS_UNIV, PE_PRIM_BITS) : NULLPE;
                    if ((*p122) == NULLPE) {
                        advise (NULLCP, "element %s", PEPY_ERR_INIT_FAILED);
                        return NOTOK;
                    }
                    if (((*p120) = bit2prim ((*p122))) == NULLPE) {
                        advise (NULLCP, "element: %s", PEPY_ERR_NOMEM);
                        return NOTOK;
                    }

#ifdef DEBUG
                    (void) testdebug ((*p120), "element");
#endif

                }

                if ((*p120) != NULLPE)
                    if (seq_add ((*pe), (*p120), -1) == NOTOK) {
                        advise (NULLCP, "member %s%s", PEPY_ERR_BAD_SEQ,
                                pe_error ((*pe) -> pe_errno));
                        return NOTOK;
                    }

#ifdef DEBUG
                (void) testdebug ((*pe), "member");
#endif

            }
            break;

        default:
            advise (NULLCP, "ModifyRDNArgument %s%d", PEPY_ERR_INVALID_CHOICE, 
                    p118);
            return NOTOK;
    }

#ifdef DEBUG
    (void) testdebug ((*pe), "STRONG.ModifyRDNArgument");
#endif


    return OK;
}

/* ARGSUSED */

int	build_STRONG_ReadArgumentTBS (pe, explicit, len, buffer, parm)
register PE     *pe;
int	explicit;
int	len;
char   *buffer;
ReadArgumentTBS * parm;
{
    PE	p125_z = NULLPE;
    register PE *p125 = &p125_z;

    if (((*pe) = pe_alloc (PE_CLASS_UNIV, PE_FORM_CONS, PE_CONS_SET)) == NULLPE) {
        advise (NULLCP, "ReadArgumentTBS: %s", PEPY_ERR_NOMEM);
        return NOTOK;
    }
    (*p125) = NULLPE;

    {
        if (build_IF_Name (p125, 0, NULL, NULLCP, parm->object ) == NOTOK)
            return NOTOK;

#ifdef DEBUG
        (void) testdebug ((*p125), "object");
#endif

        {	/* object TAG PUSHDOWN */
            PE p126_z;
            register PE *p126 = &p126_z;

            if ((*p126 = pe_alloc (PE_CLASS_CONT, PE_FORM_CONS, 0)) == NULLPE) {
                advise (NULLCP, "object: %s", PEPY_ERR_NOMEM);
                return NOTOK;
            }
            (*p126) -> pe_cons = (*p125);
            (*p125) = *p126;
        }
    }
    if ((*p125) != NULLPE)
        if (set_add ((*pe), (*p125)) == NOTOK) {
            advise (NULLCP, "ReadArgumentTBS %s%s", PEPY_ERR_BAD_SET,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }
    (*p125) = NULLPE;

    if (parm->rda_eis) {
        if (build_STRONG_EntryInfoSEL (p125, 0, NULL, NULLCP, parm->rda_eis ) == NOTOK)
            return NOTOK;

#ifdef DEBUG
        (void) testdebug ((*p125), "selection");
#endif

        {	/* selection TAG PUSHDOWN */
            PE p127_z;
            register PE *p127 = &p127_z;

            if ((*p127 = pe_alloc (PE_CLASS_CONT, PE_FORM_CONS, 1)) == NULLPE) {
                advise (NULLCP, "selection: %s", PEPY_ERR_NOMEM);
                return NOTOK;
            }
            (*p127) -> pe_cons = (*p125);
            (*p125) = *p127;
        }
    }
    if ((*p125) != NULLPE)
        if (set_add ((*pe), (*p125)) == NOTOK) {
            advise (NULLCP, "ReadArgumentTBS %s%s", PEPY_ERR_BAD_SET,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }
    (*p125) = NULLPE;

    if (parm->rda_common->ext) {
        if (build_STRONG_SECExtensionSet (p125, 0, NULL, NULLCP, parm->rda_common->ext ) == NOTOK)
            return NOTOK;

#ifdef DEBUG
        (void) testdebug ((*p125), "extensions");
#endif

        {	/* extensions TAG PUSHDOWN */
            PE p128_z;
            register PE *p128 = &p128_z;

            if ((*p128 = pe_alloc (PE_CLASS_CONT, PE_FORM_CONS, 25)) == NULLPE) {
                advise (NULLCP, "extensions: %s", PEPY_ERR_NOMEM);
                return NOTOK;
            }
            (*p128) -> pe_cons = (*p125);
            (*p125) = *p128;
        }
    }
    if ((*p125) != NULLPE)
        if (set_add ((*pe), (*p125)) == NOTOK) {
            advise (NULLCP, "ReadArgumentTBS %s%s", PEPY_ERR_BAD_SET,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }
    (*p125) = NULLPE;

    if (parm->rda_common->aliasedRDNs != CA_NO_ALIASDEREFERENCED) {
        register integer p129 = parm->rda_common->aliasedRDNs ;

        if (((*p125) = num2prim (p129, PE_CLASS_UNIV, PE_PRIM_INT)) == NULLPE) {
            advise (NULLCP, "aliasedRDNs: %s", PEPY_ERR_NOMEM);
            return NOTOK;
        }

#ifdef DEBUG
        (void) testdebug ((*p125), "aliasedRDNs");
#endif

        {	/* aliasedRDNs TAG PUSHDOWN */
            PE p130_z;
            register PE *p130 = &p130_z;

            if ((*p130 = pe_alloc (PE_CLASS_CONT, PE_FORM_CONS, 26)) == NULLPE) {
                advise (NULLCP, "aliasedRDNs: %s", PEPY_ERR_NOMEM);
                return NOTOK;
            }
            (*p130) -> pe_cons = (*p125);
            (*p125) = *p130;
        }
    }
    if ((*p125) != NULLPE)
        if (set_add ((*pe), (*p125)) == NOTOK) {
            advise (NULLCP, "ReadArgumentTBS %s%s", PEPY_ERR_BAD_SET,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }
    (*p125) = NULLPE;

    if (parm->rda_common->progress) {
        if (build_STRONG_OperationProgress (p125, 0, NULL, NULLCP, parm->rda_common->progress ) == NOTOK)
            return NOTOK;

#ifdef DEBUG
        (void) testdebug ((*p125), "progress");
#endif

        {	/* progress TAG PUSHDOWN */
            PE p131_z;
            register PE *p131 = &p131_z;

            if ((*p131 = pe_alloc (PE_CLASS_CONT, PE_FORM_CONS, 27)) == NULLPE) {
                advise (NULLCP, "progress: %s", PEPY_ERR_NOMEM);
                return NOTOK;
            }
            (*p131) -> pe_cons = (*p125);
            (*p125) = *p131;
        }
    }
    if ((*p125) != NULLPE)
        if (set_add ((*pe), (*p125)) == NOTOK) {
            advise (NULLCP, "ReadArgumentTBS %s%s", PEPY_ERR_BAD_SET,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }
    (*p125) = NULLPE;

    if (parm->rda_common->requestor) {
        if (build_IF_Name (p125, 0, NULL, NULLCP, parm->rda_common->requestor ) == NOTOK)
            return NOTOK;

#ifdef DEBUG
        (void) testdebug ((*p125), "requestor");
#endif

        {	/* requestor TAG PUSHDOWN */
            PE p132_z;
            register PE *p132 = &p132_z;

            if ((*p132 = pe_alloc (PE_CLASS_CONT, PE_FORM_CONS, 28)) == NULLPE) {
                advise (NULLCP, "requestor: %s", PEPY_ERR_NOMEM);
                return NOTOK;
            }
            (*p132) -> pe_cons = (*p125);
            (*p125) = *p132;
        }
    }
    if ((*p125) != NULLPE)
        if (set_add ((*pe), (*p125)) == NOTOK) {
            advise (NULLCP, "ReadArgumentTBS %s%s", PEPY_ERR_BAD_SET,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }
    (*p125) = NULLPE;

    if (parm->rda_common->sec_parm) {
        if (build_STRONG_SecurityParameters (p125, 0, NULL, NULLCP, parm->rda_common->sec_parm ) == NOTOK)
            return NOTOK;

#ifdef DEBUG
        (void) testdebug ((*p125), "secparm");
#endif

        {	/* secparm TAG PUSHDOWN */
            PE p133_z;
            register PE *p133 = &p133_z;

            if ((*p133 = pe_alloc (PE_CLASS_CONT, PE_FORM_CONS, 29)) == NULLPE) {
                advise (NULLCP, "secparm: %s", PEPY_ERR_NOMEM);
                return NOTOK;
            }
            (*p133) -> pe_cons = (*p125);
            (*p125) = *p133;
        }
    }
    if ((*p125) != NULLPE)
        if (set_add ((*pe), (*p125)) == NOTOK) {
            advise (NULLCP, "ReadArgumentTBS %s%s", PEPY_ERR_BAD_SET,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }
    (*p125) = NULLPE;

    if (parm->rda_common->svc) {
        if (build_STRONG_ServiceControls (p125, 0, NULL, NULLCP, parm->rda_common->svc ) == NOTOK)
            return NOTOK;

#ifdef DEBUG
        (void) testdebug ((*p125), "servcontr");
#endif

        {	/* servcontr TAG PUSHDOWN */
            PE p134_z;
            register PE *p134 = &p134_z;

            if ((*p134 = pe_alloc (PE_CLASS_CONT, PE_FORM_CONS, 30)) == NULLPE) {
                advise (NULLCP, "servcontr: %s", PEPY_ERR_NOMEM);
                return NOTOK;
            }
            (*p134) -> pe_cons = (*p125);
            (*p125) = *p134;
        }
    }
    if ((*p125) != NULLPE)
        if (set_add ((*pe), (*p125)) == NOTOK) {
            advise (NULLCP, "ReadArgumentTBS %s%s", PEPY_ERR_BAD_SET,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }

#ifdef DEBUG
    (void) testdebug ((*pe), "STRONG.ReadArgumentTBS");
#endif


    return OK;
}

/* ARGSUSED */

int	build_STRONG_ReadArgument (pe, explicit, len, buffer, parm)
register PE     *pe;
int	explicit;
int	len;
char   *buffer;
ReadArgument * parm;
{
# line 607 "STRONG.py"
    	PE	tbs;

    int	p135;

    switch (p135 = (parm->sig? 2:1)) {
        case 1:
            {
                PE	p136 = (build_readarg_tbs(parm,&tbs)) ;

                if (p136 == NULLPE) {
                    advise (NULLCP, "member %s", PEPY_ERR_INIT_FAILED);
                    return NOTOK;
                }
                ((*pe) = p136) -> pe_refcnt++;

#ifdef DEBUG
                (void) testdebug ((*pe), "member");
#endif

                {
# line 613 "STRONG.py"
    pe_free(tbs);
		
                }
            }
            break;
        case 2:
            {
                PE	p137_z = NULLPE;
                register PE *p137 = &p137_z;

                if (((*pe) = pe_alloc (PE_CLASS_UNIV, PE_FORM_CONS, PE_CONS_SEQ)) == NULLPE) {
                    advise (NULLCP, "member: %s", PEPY_ERR_NOMEM);
                    return NOTOK;
                }
                (*p137) = NULLPE;

                {
                    PE	p138 = (build_readarg_tbs(parm,&tbs)) ;

                    if (p138 == NULLPE) {
                        advise (NULLCP, "element %s", PEPY_ERR_INIT_FAILED);
                        return NOTOK;
                    }
                    ((*p137) = p138) -> pe_refcnt++;

#ifdef DEBUG
                    (void) testdebug ((*p137), "element");
#endif

                    {
# line 620 "STRONG.py"
    pe_free(tbs);
			
                    }
                }

                if ((*p137) != NULLPE)
                    if (seq_add ((*pe), (*p137), -1) == NOTOK) {
                        advise (NULLCP, "member %s%s", PEPY_ERR_BAD_SEQ,
                                pe_error ((*pe) -> pe_errno));
                        return NOTOK;
                    }
                (*p137) = NULLPE;

                {
                    if (build_SEC_AlgorithmIdentifier (p137, 0, NULL, NULLCP, parm->sig->signAI ) == NOTOK)
                        return NOTOK;

#ifdef DEBUG
                    (void) testdebug ((*p137), "element");
#endif

                }

                if ((*p137) != NULLPE)
                    if (seq_add ((*pe), (*p137), -1) == NOTOK) {
                        advise (NULLCP, "member %s%s", PEPY_ERR_BAD_SEQ,
                                pe_error ((*pe) -> pe_errno));
                        return NOTOK;
                    }
                (*p137) = NULLPE;

                {
                    PE	p139_z = NULLPE;
                    register PE *p139 = &p139_z;

                    char *p140;
                    int p141;
                    p140 = parm->sig->signature.bits ;
                    p141 = 
		     	parm->sig->signature.nbits ;
                    (*p139) = p140 ? strb2bitstr (p140, p141, PE_CLASS_UNIV, PE_PRIM_BITS) : NULLPE;
                    if ((*p139) == NULLPE) {
                        advise (NULLCP, "element %s", PEPY_ERR_INIT_FAILED);
                        return NOTOK;
                    }
                    if (((*p137) = bit2prim ((*p139))) == NULLPE) {
                        advise (NULLCP, "element: %s", PEPY_ERR_NOMEM);
                        return NOTOK;
                    }

#ifdef DEBUG
                    (void) testdebug ((*p137), "element");
#endif

                }

                if ((*p137) != NULLPE)
                    if (seq_add ((*pe), (*p137), -1) == NOTOK) {
                        advise (NULLCP, "member %s%s", PEPY_ERR_BAD_SEQ,
                                pe_error ((*pe) -> pe_errno));
                        return NOTOK;
                    }

#ifdef DEBUG
                (void) testdebug ((*pe), "member");
#endif

            }
            break;

        default:
            advise (NULLCP, "ReadArgument %s%d", PEPY_ERR_INVALID_CHOICE, 
                    p135);
            return NOTOK;
    }

#ifdef DEBUG
    (void) testdebug ((*pe), "STRONG.ReadArgument");
#endif


    return OK;
}

/* ARGSUSED */

int	build_STRONG_ReadResultTBS (pe, explicit, len, buffer, parm)
register PE     *pe;
int	explicit;
int	len;
char   *buffer;
ReadResultTBS * parm;
{
    PE	p142_z = NULLPE;
    register PE *p142 = &p142_z;

    if (((*pe) = pe_alloc (PE_CLASS_UNIV, PE_FORM_CONS, PE_CONS_SET)) == NULLPE) {
        advise (NULLCP, "ReadResultTBS: %s", PEPY_ERR_NOMEM);
        return NOTOK;
    }
    (*p142) = NULLPE;

    {
        if (build_STRONG_EntryINFO (p142, 0, NULL, NULLCP, parm->rdr_entry ) == NOTOK)
            return NOTOK;

#ifdef DEBUG
        (void) testdebug ((*p142), "entry");
#endif

        {	/* entry TAG PUSHDOWN */
            PE p143_z;
            register PE *p143 = &p143_z;

            if ((*p143 = pe_alloc (PE_CLASS_CONT, PE_FORM_CONS, 0)) == NULLPE) {
                advise (NULLCP, "entry: %s", PEPY_ERR_NOMEM);
                return NOTOK;
            }
            (*p143) -> pe_cons = (*p142);
            (*p142) = *p143;
        }
    }
    if ((*p142) != NULLPE)
        if (set_add ((*pe), (*p142)) == NOTOK) {
            advise (NULLCP, "ReadResultTBS %s%s", PEPY_ERR_BAD_SET,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }
    (*p142) = NULLPE;

    if (parm->rdr_common->aliasDereferenced) {
        register int p144 = parm->rdr_common->aliasDereferenced;

        if (((*p142) = flag2prim (p144, PE_CLASS_UNIV, PE_PRIM_BOOL)) == NULLPE) {
            advise (NULLCP, "aliasDereferenced: %s", PEPY_ERR_NOMEM);
            return NOTOK;
        }

#ifdef DEBUG
        (void) testdebug ((*p142), "aliasDereferenced");
#endif

        {	/* aliasDereferenced TAG PUSHDOWN */
            PE p145_z;
            register PE *p145 = &p145_z;

            if ((*p145 = pe_alloc (PE_CLASS_CONT, PE_FORM_CONS, 28)) == NULLPE) {
                advise (NULLCP, "aliasDereferenced: %s", PEPY_ERR_NOMEM);
                return NOTOK;
            }
            (*p145) -> pe_cons = (*p142);
            (*p142) = *p145;
        }
    }
    if ((*p142) != NULLPE)
        if (set_add ((*pe), (*p142)) == NOTOK) {
            advise (NULLCP, "ReadResultTBS %s%s", PEPY_ERR_BAD_SET,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }
    (*p142) = NULLPE;

    if (parm->rdr_common->performer) {
        if (build_IF_Name (p142, 0, NULL, NULLCP, parm->rdr_common->performer ) == NOTOK)
            return NOTOK;

#ifdef DEBUG
        (void) testdebug ((*p142), "performer");
#endif

        {	/* performer TAG PUSHDOWN */
            PE p146_z;
            register PE *p146 = &p146_z;

            if ((*p146 = pe_alloc (PE_CLASS_CONT, PE_FORM_CONS, 29)) == NULLPE) {
                advise (NULLCP, "performer: %s", PEPY_ERR_NOMEM);
                return NOTOK;
            }
            (*p146) -> pe_cons = (*p142);
            (*p142) = *p146;
        }
    }
    if ((*p142) != NULLPE)
        if (set_add ((*pe), (*p142)) == NOTOK) {
            advise (NULLCP, "ReadResultTBS %s%s", PEPY_ERR_BAD_SET,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }
    (*p142) = NULLPE;

    if (parm->rdr_common->sec_parm) {
        if (build_STRONG_SecurityParameters (p142, 0, NULL, NULLCP, parm->rdr_common->sec_parm ) == NOTOK)
            return NOTOK;

#ifdef DEBUG
        (void) testdebug ((*p142), "secparm");
#endif

        {	/* secparm TAG PUSHDOWN */
            PE p147_z;
            register PE *p147 = &p147_z;

            if ((*p147 = pe_alloc (PE_CLASS_CONT, PE_FORM_CONS, 30)) == NULLPE) {
                advise (NULLCP, "secparm: %s", PEPY_ERR_NOMEM);
                return NOTOK;
            }
            (*p147) -> pe_cons = (*p142);
            (*p142) = *p147;
        }
    }
    if ((*p142) != NULLPE)
        if (set_add ((*pe), (*p142)) == NOTOK) {
            advise (NULLCP, "ReadResultTBS %s%s", PEPY_ERR_BAD_SET,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }

#ifdef DEBUG
    (void) testdebug ((*pe), "STRONG.ReadResultTBS");
#endif


    return OK;
}

/* ARGSUSED */

int	build_STRONG_ReadResult (pe, explicit, len, buffer, parm)
register PE     *pe;
int	explicit;
int	len;
char   *buffer;
ReadResult * parm;
{
# line 657 "STRONG.py"
    	PE	tbs;

    int	p148;

    switch (p148 = (parm->sig? 2:1)) {
        case 1:
            {
                PE	p149 = (build_readres_tbs(parm,&tbs)) ;

                if (p149 == NULLPE) {
                    advise (NULLCP, "member %s", PEPY_ERR_INIT_FAILED);
                    return NOTOK;
                }
                ((*pe) = p149) -> pe_refcnt++;

#ifdef DEBUG
                (void) testdebug ((*pe), "member");
#endif

                {
# line 663 "STRONG.py"
    pe_free(tbs);
		
                }
            }
            break;
        case 2:
            {
                PE	p150_z = NULLPE;
                register PE *p150 = &p150_z;

                if (((*pe) = pe_alloc (PE_CLASS_UNIV, PE_FORM_CONS, PE_CONS_SEQ)) == NULLPE) {
                    advise (NULLCP, "member: %s", PEPY_ERR_NOMEM);
                    return NOTOK;
                }
                (*p150) = NULLPE;

                {
                    PE	p151 = (build_readres_tbs(parm,&tbs)) ;

                    if (p151 == NULLPE) {
                        advise (NULLCP, "element %s", PEPY_ERR_INIT_FAILED);
                        return NOTOK;
                    }
                    ((*p150) = p151) -> pe_refcnt++;

#ifdef DEBUG
                    (void) testdebug ((*p150), "element");
#endif

                    {
# line 670 "STRONG.py"
    pe_free(tbs);
			
                    }
                }

                if ((*p150) != NULLPE)
                    if (seq_add ((*pe), (*p150), -1) == NOTOK) {
                        advise (NULLCP, "member %s%s", PEPY_ERR_BAD_SEQ,
                                pe_error ((*pe) -> pe_errno));
                        return NOTOK;
                    }
                (*p150) = NULLPE;

                {
                    if (build_SEC_AlgorithmIdentifier (p150, 0, NULL, NULLCP, parm->sig->signAI ) == NOTOK)
                        return NOTOK;

#ifdef DEBUG
                    (void) testdebug ((*p150), "element");
#endif

                }

                if ((*p150) != NULLPE)
                    if (seq_add ((*pe), (*p150), -1) == NOTOK) {
                        advise (NULLCP, "member %s%s", PEPY_ERR_BAD_SEQ,
                                pe_error ((*pe) -> pe_errno));
                        return NOTOK;
                    }
                (*p150) = NULLPE;

                {
                    PE	p152_z = NULLPE;
                    register PE *p152 = &p152_z;

                    char *p153;
                    int p154;
                    p153 = parm->sig->signature.bits ;
                    p154 = 
		     	parm->sig->signature.nbits ;
                    (*p152) = p153 ? strb2bitstr (p153, p154, PE_CLASS_UNIV, PE_PRIM_BITS) : NULLPE;
                    if ((*p152) == NULLPE) {
                        advise (NULLCP, "element %s", PEPY_ERR_INIT_FAILED);
                        return NOTOK;
                    }
                    if (((*p150) = bit2prim ((*p152))) == NULLPE) {
                        advise (NULLCP, "element: %s", PEPY_ERR_NOMEM);
                        return NOTOK;
                    }

#ifdef DEBUG
                    (void) testdebug ((*p150), "element");
#endif

                }

                if ((*p150) != NULLPE)
                    if (seq_add ((*pe), (*p150), -1) == NOTOK) {
                        advise (NULLCP, "member %s%s", PEPY_ERR_BAD_SEQ,
                                pe_error ((*pe) -> pe_errno));
                        return NOTOK;
                    }

#ifdef DEBUG
                (void) testdebug ((*pe), "member");
#endif

            }
            break;

        default:
            advise (NULLCP, "ReadResult %s%d", PEPY_ERR_INVALID_CHOICE, 
                    p148);
            return NOTOK;
    }

#ifdef DEBUG
    (void) testdebug ((*pe), "STRONG.ReadResult");
#endif


    return OK;
}

/* ARGSUSED */

int	build_STRONG_RemoveArgumentTBS (pe, explicit, len, buffer, parm)
register PE     *pe;
int	explicit;
int	len;
char   *buffer;
RemoveArgumentTBS * parm;
{
    PE	p155_z = NULLPE;
    register PE *p155 = &p155_z;

    if (((*pe) = pe_alloc (PE_CLASS_UNIV, PE_FORM_CONS, PE_CONS_SET)) == NULLPE) {
        advise (NULLCP, "RemoveArgumentTBS: %s", PEPY_ERR_NOMEM);
        return NOTOK;
    }
    (*p155) = NULLPE;

    {
        if (build_IF_Name (p155, 0, NULL, NULLCP, parm->rma_object ) == NOTOK)
            return NOTOK;

#ifdef DEBUG
        (void) testdebug ((*p155), "object");
#endif

        {	/* object TAG PUSHDOWN */
            PE p156_z;
            register PE *p156 = &p156_z;

            if ((*p156 = pe_alloc (PE_CLASS_CONT, PE_FORM_CONS, 0)) == NULLPE) {
                advise (NULLCP, "object: %s", PEPY_ERR_NOMEM);
                return NOTOK;
            }
            (*p156) -> pe_cons = (*p155);
            (*p155) = *p156;
        }
    }
    if ((*p155) != NULLPE)
        if (set_add ((*pe), (*p155)) == NOTOK) {
            advise (NULLCP, "RemoveArgumentTBS %s%s", PEPY_ERR_BAD_SET,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }
    (*p155) = NULLPE;

    if (parm->rma_common->ext) {
        if (build_STRONG_SECExtensionSet (p155, 0, NULL, NULLCP, parm->rma_common->ext ) == NOTOK)
            return NOTOK;

#ifdef DEBUG
        (void) testdebug ((*p155), "extensions");
#endif

        {	/* extensions TAG PUSHDOWN */
            PE p157_z;
            register PE *p157 = &p157_z;

            if ((*p157 = pe_alloc (PE_CLASS_CONT, PE_FORM_CONS, 25)) == NULLPE) {
                advise (NULLCP, "extensions: %s", PEPY_ERR_NOMEM);
                return NOTOK;
            }
            (*p157) -> pe_cons = (*p155);
            (*p155) = *p157;
        }
    }
    if ((*p155) != NULLPE)
        if (set_add ((*pe), (*p155)) == NOTOK) {
            advise (NULLCP, "RemoveArgumentTBS %s%s", PEPY_ERR_BAD_SET,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }
    (*p155) = NULLPE;

    if (parm->rma_common->aliasedRDNs != CA_NO_ALIASDEREFERENCED) {
        register integer p158 = parm->rma_common->aliasedRDNs ;

        if (((*p155) = num2prim (p158, PE_CLASS_UNIV, PE_PRIM_INT)) == NULLPE) {
            advise (NULLCP, "aliasedRDNs: %s", PEPY_ERR_NOMEM);
            return NOTOK;
        }

#ifdef DEBUG
        (void) testdebug ((*p155), "aliasedRDNs");
#endif

        {	/* aliasedRDNs TAG PUSHDOWN */
            PE p159_z;
            register PE *p159 = &p159_z;

            if ((*p159 = pe_alloc (PE_CLASS_CONT, PE_FORM_CONS, 26)) == NULLPE) {
                advise (NULLCP, "aliasedRDNs: %s", PEPY_ERR_NOMEM);
                return NOTOK;
            }
            (*p159) -> pe_cons = (*p155);
            (*p155) = *p159;
        }
    }
    if ((*p155) != NULLPE)
        if (set_add ((*pe), (*p155)) == NOTOK) {
            advise (NULLCP, "RemoveArgumentTBS %s%s", PEPY_ERR_BAD_SET,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }
    (*p155) = NULLPE;

    if (parm->rma_common->progress) {
        if (build_STRONG_OperationProgress (p155, 0, NULL, NULLCP, parm->rma_common->progress ) == NOTOK)
            return NOTOK;

#ifdef DEBUG
        (void) testdebug ((*p155), "progress");
#endif

        {	/* progress TAG PUSHDOWN */
            PE p160_z;
            register PE *p160 = &p160_z;

            if ((*p160 = pe_alloc (PE_CLASS_CONT, PE_FORM_CONS, 27)) == NULLPE) {
                advise (NULLCP, "progress: %s", PEPY_ERR_NOMEM);
                return NOTOK;
            }
            (*p160) -> pe_cons = (*p155);
            (*p155) = *p160;
        }
    }
    if ((*p155) != NULLPE)
        if (set_add ((*pe), (*p155)) == NOTOK) {
            advise (NULLCP, "RemoveArgumentTBS %s%s", PEPY_ERR_BAD_SET,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }
    (*p155) = NULLPE;

    if (parm->rma_common->requestor) {
        if (build_IF_Name (p155, 0, NULL, NULLCP, parm->rma_common->requestor ) == NOTOK)
            return NOTOK;

#ifdef DEBUG
        (void) testdebug ((*p155), "requestor");
#endif

        {	/* requestor TAG PUSHDOWN */
            PE p161_z;
            register PE *p161 = &p161_z;

            if ((*p161 = pe_alloc (PE_CLASS_CONT, PE_FORM_CONS, 28)) == NULLPE) {
                advise (NULLCP, "requestor: %s", PEPY_ERR_NOMEM);
                return NOTOK;
            }
            (*p161) -> pe_cons = (*p155);
            (*p155) = *p161;
        }
    }
    if ((*p155) != NULLPE)
        if (set_add ((*pe), (*p155)) == NOTOK) {
            advise (NULLCP, "RemoveArgumentTBS %s%s", PEPY_ERR_BAD_SET,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }
    (*p155) = NULLPE;

    if (parm->rma_common->sec_parm) {
        if (build_STRONG_SecurityParameters (p155, 0, NULL, NULLCP, parm->rma_common->sec_parm ) == NOTOK)
            return NOTOK;

#ifdef DEBUG
        (void) testdebug ((*p155), "secparm");
#endif

        {	/* secparm TAG PUSHDOWN */
            PE p162_z;
            register PE *p162 = &p162_z;

            if ((*p162 = pe_alloc (PE_CLASS_CONT, PE_FORM_CONS, 29)) == NULLPE) {
                advise (NULLCP, "secparm: %s", PEPY_ERR_NOMEM);
                return NOTOK;
            }
            (*p162) -> pe_cons = (*p155);
            (*p155) = *p162;
        }
    }
    if ((*p155) != NULLPE)
        if (set_add ((*pe), (*p155)) == NOTOK) {
            advise (NULLCP, "RemoveArgumentTBS %s%s", PEPY_ERR_BAD_SET,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }
    (*p155) = NULLPE;

    if (parm->rma_common->svc) {
        if (build_STRONG_ServiceControls (p155, 0, NULL, NULLCP, parm->rma_common->svc ) == NOTOK)
            return NOTOK;

#ifdef DEBUG
        (void) testdebug ((*p155), "servcontr");
#endif

        {	/* servcontr TAG PUSHDOWN */
            PE p163_z;
            register PE *p163 = &p163_z;

            if ((*p163 = pe_alloc (PE_CLASS_CONT, PE_FORM_CONS, 30)) == NULLPE) {
                advise (NULLCP, "servcontr: %s", PEPY_ERR_NOMEM);
                return NOTOK;
            }
            (*p163) -> pe_cons = (*p155);
            (*p155) = *p163;
        }
    }
    if ((*p155) != NULLPE)
        if (set_add ((*pe), (*p155)) == NOTOK) {
            advise (NULLCP, "RemoveArgumentTBS %s%s", PEPY_ERR_BAD_SET,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }

#ifdef DEBUG
    (void) testdebug ((*pe), "STRONG.RemoveArgumentTBS");
#endif


    return OK;
}

/* ARGSUSED */

int	build_STRONG_RemoveArgument (pe, explicit, len, buffer, parm)
register PE     *pe;
int	explicit;
int	len;
char   *buffer;
RemoveArgument * parm;
{
# line 724 "STRONG.py"
    	PE	tbs;

    int	p164;

    switch (p164 = (parm->sig? 2:1)) {
        case 1:
            {
                PE	p165 = (build_removearg_tbs(parm,&tbs)) ;

                if (p165 == NULLPE) {
                    advise (NULLCP, "member %s", PEPY_ERR_INIT_FAILED);
                    return NOTOK;
                }
                ((*pe) = p165) -> pe_refcnt++;

#ifdef DEBUG
                (void) testdebug ((*pe), "member");
#endif

                {
# line 730 "STRONG.py"
    pe_free(tbs);
		
                }
            }
            break;
        case 2:
            {
                PE	p166_z = NULLPE;
                register PE *p166 = &p166_z;

                if (((*pe) = pe_alloc (PE_CLASS_UNIV, PE_FORM_CONS, PE_CONS_SEQ)) == NULLPE) {
                    advise (NULLCP, "member: %s", PEPY_ERR_NOMEM);
                    return NOTOK;
                }
                (*p166) = NULLPE;

                {
                    PE	p167 = (build_removearg_tbs(parm,&tbs)) ;

                    if (p167 == NULLPE) {
                        advise (NULLCP, "element %s", PEPY_ERR_INIT_FAILED);
                        return NOTOK;
                    }
                    ((*p166) = p167) -> pe_refcnt++;

#ifdef DEBUG
                    (void) testdebug ((*p166), "element");
#endif

                    {
# line 737 "STRONG.py"
    pe_free(tbs);
			
                    }
                }

                if ((*p166) != NULLPE)
                    if (seq_add ((*pe), (*p166), -1) == NOTOK) {
                        advise (NULLCP, "member %s%s", PEPY_ERR_BAD_SEQ,
                                pe_error ((*pe) -> pe_errno));
                        return NOTOK;
                    }
                (*p166) = NULLPE;

                {
                    if (build_SEC_AlgorithmIdentifier (p166, 0, NULL, NULLCP, parm->sig->signAI ) == NOTOK)
                        return NOTOK;

#ifdef DEBUG
                    (void) testdebug ((*p166), "element");
#endif

                }

                if ((*p166) != NULLPE)
                    if (seq_add ((*pe), (*p166), -1) == NOTOK) {
                        advise (NULLCP, "member %s%s", PEPY_ERR_BAD_SEQ,
                                pe_error ((*pe) -> pe_errno));
                        return NOTOK;
                    }
                (*p166) = NULLPE;

                {
                    PE	p168_z = NULLPE;
                    register PE *p168 = &p168_z;

                    char *p169;
                    int p170;
                    p169 = parm->sig->signature.bits ;
                    p170 = 
		     	parm->sig->signature.nbits ;
                    (*p168) = p169 ? strb2bitstr (p169, p170, PE_CLASS_UNIV, PE_PRIM_BITS) : NULLPE;
                    if ((*p168) == NULLPE) {
                        advise (NULLCP, "element %s", PEPY_ERR_INIT_FAILED);
                        return NOTOK;
                    }
                    if (((*p166) = bit2prim ((*p168))) == NULLPE) {
                        advise (NULLCP, "element: %s", PEPY_ERR_NOMEM);
                        return NOTOK;
                    }

#ifdef DEBUG
                    (void) testdebug ((*p166), "element");
#endif

                }

                if ((*p166) != NULLPE)
                    if (seq_add ((*pe), (*p166), -1) == NOTOK) {
                        advise (NULLCP, "member %s%s", PEPY_ERR_BAD_SEQ,
                                pe_error ((*pe) -> pe_errno));
                        return NOTOK;
                    }

#ifdef DEBUG
                (void) testdebug ((*pe), "member");
#endif

            }
            break;

        default:
            advise (NULLCP, "RemoveArgument %s%d", PEPY_ERR_INVALID_CHOICE, 
                    p164);
            return NOTOK;
    }

#ifdef DEBUG
    (void) testdebug ((*pe), "STRONG.RemoveArgument");
#endif


    return OK;
}

/* ARGSUSED */

int	build_STRONG_SearchArgumentTBS (pe, explicit, len, buffer, parm)
register PE     *pe;
int	explicit;
int	len;
char   *buffer;
SearchArgumentTBS * parm;
{
    PE	p171_z = NULLPE;
    register PE *p171 = &p171_z;

    if (((*pe) = pe_alloc (PE_CLASS_UNIV, PE_FORM_CONS, PE_CONS_SET)) == NULLPE) {
        advise (NULLCP, "SearchArgumentTBS: %s", PEPY_ERR_NOMEM);
        return NOTOK;
    }
    (*p171) = NULLPE;

    {
        if (build_IF_Name (p171, 0, NULL, NULLCP, parm->baseobject) == NOTOK)
            return NOTOK;

#ifdef DEBUG
        (void) testdebug ((*p171), "baseObject");
#endif

        {	/* baseObject TAG PUSHDOWN */
            PE p172_z;
            register PE *p172 = &p172_z;

            if ((*p172 = pe_alloc (PE_CLASS_CONT, PE_FORM_CONS, 0)) == NULLPE) {
                advise (NULLCP, "baseObject: %s", PEPY_ERR_NOMEM);
                return NOTOK;
            }
            (*p172) -> pe_cons = (*p171);
            (*p171) = *p172;
        }
    }
    if ((*p171) != NULLPE)
        if (set_add ((*pe), (*p171)) == NOTOK) {
            advise (NULLCP, "SearchArgumentTBS %s%s", PEPY_ERR_BAD_SET,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }
    (*p171) = NULLPE;

    if (parm->subset != 0) {
        register integer p173 = parm->subset;

        if (((*p171) = num2prim (p173, PE_CLASS_UNIV, PE_PRIM_INT)) == NULLPE) {
            advise (NULLCP, "subset: %s", PEPY_ERR_NOMEM);
            return NOTOK;
        }
        switch (p173) {
            case 0:	/* baseObject */
                break;
            case 1:	/* oneLevel */
                break;
            case 2:	/* wholeSubtree */
                break;
        }

#ifdef DEBUG
        (void) testdebug ((*p171), "subset");
#endif

        {	/* subset TAG PUSHDOWN */
            PE p174_z;
            register PE *p174 = &p174_z;

            if ((*p174 = pe_alloc (PE_CLASS_CONT, PE_FORM_CONS, 1)) == NULLPE) {
                advise (NULLCP, "subset: %s", PEPY_ERR_NOMEM);
                return NOTOK;
            }
            (*p174) -> pe_cons = (*p171);
            (*p171) = *p174;
        }
    }
    if ((*p171) != NULLPE)
        if (set_add ((*pe), (*p171)) == NOTOK) {
            advise (NULLCP, "SearchArgumentTBS %s%s", PEPY_ERR_BAD_SET,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }
    (*p171) = NULLPE;

    if (parm->filter) {
        if (build_STRONG_Filter (p171, 0, NULL, NULLCP, parm->filter) == NOTOK)
            return NOTOK;

#ifdef DEBUG
        (void) testdebug ((*p171), "filter");
#endif

        {	/* filter TAG PUSHDOWN */
            PE p175_z;
            register PE *p175 = &p175_z;

            if ((*p175 = pe_alloc (PE_CLASS_CONT, PE_FORM_CONS, 2)) == NULLPE) {
                advise (NULLCP, "filter: %s", PEPY_ERR_NOMEM);
                return NOTOK;
            }
            (*p175) -> pe_cons = (*p171);
            (*p171) = *p175;
        }
    }
    if ((*p171) != NULLPE)
        if (set_add ((*pe), (*p171)) == NOTOK) {
            advise (NULLCP, "SearchArgumentTBS %s%s", PEPY_ERR_BAD_SET,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }
    (*p171) = NULLPE;

    if (parm->searchaliases != TRUE) {
        register int p176 = parm->searchaliases;

        if (((*p171) = flag2prim (p176, PE_CLASS_UNIV, PE_PRIM_BOOL)) == NULLPE) {
            advise (NULLCP, "searchAliases: %s", PEPY_ERR_NOMEM);
            return NOTOK;
        }

#ifdef DEBUG
        (void) testdebug ((*p171), "searchAliases");
#endif

        {	/* searchAliases TAG PUSHDOWN */
            PE p177_z;
            register PE *p177 = &p177_z;

            if ((*p177 = pe_alloc (PE_CLASS_CONT, PE_FORM_CONS, 3)) == NULLPE) {
                advise (NULLCP, "searchAliases: %s", PEPY_ERR_NOMEM);
                return NOTOK;
            }
            (*p177) -> pe_cons = (*p171);
            (*p171) = *p177;
        }
    }
    if ((*p171) != NULLPE)
        if (set_add ((*pe), (*p171)) == NOTOK) {
            advise (NULLCP, "SearchArgumentTBS %s%s", PEPY_ERR_BAD_SET,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }
    (*p171) = NULLPE;

    if (parm->sra_eis) {
        if (build_STRONG_EntryInfoSEL (p171, 0, NULL, NULLCP, parm->sra_eis ) == NOTOK)
            return NOTOK;

#ifdef DEBUG
        (void) testdebug ((*p171), "selection");
#endif

        {	/* selection TAG PUSHDOWN */
            PE p178_z;
            register PE *p178 = &p178_z;

            if ((*p178 = pe_alloc (PE_CLASS_CONT, PE_FORM_CONS, 4)) == NULLPE) {
                advise (NULLCP, "selection: %s", PEPY_ERR_NOMEM);
                return NOTOK;
            }
            (*p178) -> pe_cons = (*p171);
            (*p171) = *p178;
        }
    }
    if ((*p171) != NULLPE)
        if (set_add ((*pe), (*p171)) == NOTOK) {
            advise (NULLCP, "SearchArgumentTBS %s%s", PEPY_ERR_BAD_SET,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }
    (*p171) = NULLPE;

    if (parm->sra_common->ext) {
        if (build_STRONG_SECExtensionSet (p171, 0, NULL, NULLCP, parm->sra_common->ext ) == NOTOK)
            return NOTOK;

#ifdef DEBUG
        (void) testdebug ((*p171), "extensions");
#endif

        {	/* extensions TAG PUSHDOWN */
            PE p179_z;
            register PE *p179 = &p179_z;

            if ((*p179 = pe_alloc (PE_CLASS_CONT, PE_FORM_CONS, 25)) == NULLPE) {
                advise (NULLCP, "extensions: %s", PEPY_ERR_NOMEM);
                return NOTOK;
            }
            (*p179) -> pe_cons = (*p171);
            (*p171) = *p179;
        }
    }
    if ((*p171) != NULLPE)
        if (set_add ((*pe), (*p171)) == NOTOK) {
            advise (NULLCP, "SearchArgumentTBS %s%s", PEPY_ERR_BAD_SET,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }
    (*p171) = NULLPE;

    if (parm->sra_common->aliasedRDNs != CA_NO_ALIASDEREFERENCED) {
        register integer p180 = parm->sra_common->aliasedRDNs ;

        if (((*p171) = num2prim (p180, PE_CLASS_UNIV, PE_PRIM_INT)) == NULLPE) {
            advise (NULLCP, "aliasedRDNs: %s", PEPY_ERR_NOMEM);
            return NOTOK;
        }

#ifdef DEBUG
        (void) testdebug ((*p171), "aliasedRDNs");
#endif

        {	/* aliasedRDNs TAG PUSHDOWN */
            PE p181_z;
            register PE *p181 = &p181_z;

            if ((*p181 = pe_alloc (PE_CLASS_CONT, PE_FORM_CONS, 26)) == NULLPE) {
                advise (NULLCP, "aliasedRDNs: %s", PEPY_ERR_NOMEM);
                return NOTOK;
            }
            (*p181) -> pe_cons = (*p171);
            (*p171) = *p181;
        }
    }
    if ((*p171) != NULLPE)
        if (set_add ((*pe), (*p171)) == NOTOK) {
            advise (NULLCP, "SearchArgumentTBS %s%s", PEPY_ERR_BAD_SET,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }
    (*p171) = NULLPE;

    if (parm->sra_common->progress) {
        if (build_STRONG_OperationProgress (p171, 0, NULL, NULLCP, parm->sra_common->progress ) == NOTOK)
            return NOTOK;

#ifdef DEBUG
        (void) testdebug ((*p171), "progress");
#endif

        {	/* progress TAG PUSHDOWN */
            PE p182_z;
            register PE *p182 = &p182_z;

            if ((*p182 = pe_alloc (PE_CLASS_CONT, PE_FORM_CONS, 27)) == NULLPE) {
                advise (NULLCP, "progress: %s", PEPY_ERR_NOMEM);
                return NOTOK;
            }
            (*p182) -> pe_cons = (*p171);
            (*p171) = *p182;
        }
    }
    if ((*p171) != NULLPE)
        if (set_add ((*pe), (*p171)) == NOTOK) {
            advise (NULLCP, "SearchArgumentTBS %s%s", PEPY_ERR_BAD_SET,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }
    (*p171) = NULLPE;

    if (parm->sra_common->requestor) {
        if (build_IF_Name (p171, 0, NULL, NULLCP, parm->sra_common->requestor ) == NOTOK)
            return NOTOK;

#ifdef DEBUG
        (void) testdebug ((*p171), "requestor");
#endif

        {	/* requestor TAG PUSHDOWN */
            PE p183_z;
            register PE *p183 = &p183_z;

            if ((*p183 = pe_alloc (PE_CLASS_CONT, PE_FORM_CONS, 28)) == NULLPE) {
                advise (NULLCP, "requestor: %s", PEPY_ERR_NOMEM);
                return NOTOK;
            }
            (*p183) -> pe_cons = (*p171);
            (*p171) = *p183;
        }
    }
    if ((*p171) != NULLPE)
        if (set_add ((*pe), (*p171)) == NOTOK) {
            advise (NULLCP, "SearchArgumentTBS %s%s", PEPY_ERR_BAD_SET,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }
    (*p171) = NULLPE;

    if (parm->sra_common->sec_parm) {
        if (build_STRONG_SecurityParameters (p171, 0, NULL, NULLCP, parm->sra_common->sec_parm ) == NOTOK)
            return NOTOK;

#ifdef DEBUG
        (void) testdebug ((*p171), "secparm");
#endif

        {	/* secparm TAG PUSHDOWN */
            PE p184_z;
            register PE *p184 = &p184_z;

            if ((*p184 = pe_alloc (PE_CLASS_CONT, PE_FORM_CONS, 29)) == NULLPE) {
                advise (NULLCP, "secparm: %s", PEPY_ERR_NOMEM);
                return NOTOK;
            }
            (*p184) -> pe_cons = (*p171);
            (*p171) = *p184;
        }
    }
    if ((*p171) != NULLPE)
        if (set_add ((*pe), (*p171)) == NOTOK) {
            advise (NULLCP, "SearchArgumentTBS %s%s", PEPY_ERR_BAD_SET,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }
    (*p171) = NULLPE;

    if (parm->sra_common->svc) {
        if (build_STRONG_ServiceControls (p171, 0, NULL, NULLCP, parm->sra_common->svc ) == NOTOK)
            return NOTOK;

#ifdef DEBUG
        (void) testdebug ((*p171), "servcontr");
#endif

        {	/* servcontr TAG PUSHDOWN */
            PE p185_z;
            register PE *p185 = &p185_z;

            if ((*p185 = pe_alloc (PE_CLASS_CONT, PE_FORM_CONS, 30)) == NULLPE) {
                advise (NULLCP, "servcontr: %s", PEPY_ERR_NOMEM);
                return NOTOK;
            }
            (*p185) -> pe_cons = (*p171);
            (*p171) = *p185;
        }
    }
    if ((*p171) != NULLPE)
        if (set_add ((*pe), (*p171)) == NOTOK) {
            advise (NULLCP, "SearchArgumentTBS %s%s", PEPY_ERR_BAD_SET,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }

#ifdef DEBUG
    (void) testdebug ((*pe), "STRONG.SearchArgumentTBS");
#endif


    return OK;
}

/* ARGSUSED */

int	build_STRONG_SearchArgument (pe, explicit, len, buffer, parm)
register PE     *pe;
int	explicit;
int	len;
char   *buffer;
SearchArgument * parm;
{
# line 817 "STRONG.py"
    	PE	tbs;

    int	p186;

    switch (p186 = (parm->sig? 2:1)) {
        case 1:
            {
                PE	p187 = (build_searcharg_tbs(parm,&tbs)) ;

                if (p187 == NULLPE) {
                    advise (NULLCP, "member %s", PEPY_ERR_INIT_FAILED);
                    return NOTOK;
                }
                ((*pe) = p187) -> pe_refcnt++;

#ifdef DEBUG
                (void) testdebug ((*pe), "member");
#endif

                {
# line 823 "STRONG.py"
    pe_free(tbs);
		
                }
            }
            break;
        case 2:
            {
                PE	p188_z = NULLPE;
                register PE *p188 = &p188_z;

                if (((*pe) = pe_alloc (PE_CLASS_UNIV, PE_FORM_CONS, PE_CONS_SEQ)) == NULLPE) {
                    advise (NULLCP, "member: %s", PEPY_ERR_NOMEM);
                    return NOTOK;
                }
                (*p188) = NULLPE;

                {
                    PE	p189 = (build_searcharg_tbs(parm,&tbs)) ;

                    if (p189 == NULLPE) {
                        advise (NULLCP, "element %s", PEPY_ERR_INIT_FAILED);
                        return NOTOK;
                    }
                    ((*p188) = p189) -> pe_refcnt++;

#ifdef DEBUG
                    (void) testdebug ((*p188), "element");
#endif

                    {
# line 830 "STRONG.py"
    pe_free(tbs);
			
                    }
                }

                if ((*p188) != NULLPE)
                    if (seq_add ((*pe), (*p188), -1) == NOTOK) {
                        advise (NULLCP, "member %s%s", PEPY_ERR_BAD_SEQ,
                                pe_error ((*pe) -> pe_errno));
                        return NOTOK;
                    }
                (*p188) = NULLPE;

                {
                    if (build_SEC_AlgorithmIdentifier (p188, 0, NULL, NULLCP, parm->sig->signAI ) == NOTOK)
                        return NOTOK;

#ifdef DEBUG
                    (void) testdebug ((*p188), "element");
#endif

                }

                if ((*p188) != NULLPE)
                    if (seq_add ((*pe), (*p188), -1) == NOTOK) {
                        advise (NULLCP, "member %s%s", PEPY_ERR_BAD_SEQ,
                                pe_error ((*pe) -> pe_errno));
                        return NOTOK;
                    }
                (*p188) = NULLPE;

                {
                    PE	p190_z = NULLPE;
                    register PE *p190 = &p190_z;

                    char *p191;
                    int p192;
                    p191 = parm->sig->signature.bits ;
                    p192 = 
		     	parm->sig->signature.nbits ;
                    (*p190) = p191 ? strb2bitstr (p191, p192, PE_CLASS_UNIV, PE_PRIM_BITS) : NULLPE;
                    if ((*p190) == NULLPE) {
                        advise (NULLCP, "element %s", PEPY_ERR_INIT_FAILED);
                        return NOTOK;
                    }
                    if (((*p188) = bit2prim ((*p190))) == NULLPE) {
                        advise (NULLCP, "element: %s", PEPY_ERR_NOMEM);
                        return NOTOK;
                    }

#ifdef DEBUG
                    (void) testdebug ((*p188), "element");
#endif

                }

                if ((*p188) != NULLPE)
                    if (seq_add ((*pe), (*p188), -1) == NOTOK) {
                        advise (NULLCP, "member %s%s", PEPY_ERR_BAD_SEQ,
                                pe_error ((*pe) -> pe_errno));
                        return NOTOK;
                    }

#ifdef DEBUG
                (void) testdebug ((*pe), "member");
#endif

            }
            break;

        default:
            advise (NULLCP, "SearchArgument %s%d", PEPY_ERR_INVALID_CHOICE, 
                    p186);
            return NOTOK;
    }

#ifdef DEBUG
    (void) testdebug ((*pe), "STRONG.SearchArgument");
#endif


    return OK;
}

/* ARGSUSED */

int	build_STRONG_SearchResultTBS (pe, explicit, len, buffer, parm)
register PE     *pe;
int	explicit;
int	len;
char   *buffer;
SearchResultTBS * parm;
{
    int	p193;

    switch (p193 = (((parm->srr_correlated == FALSE) ? 2 : 1))) {
        case 1:	/* searchInfo */
            {
                if (build_STRONG_SearchInfo (pe, 0, NULL, NULLCP, parm->srrtbs_un.searchinfo) == NOTOK)
                    return NOTOK;

#ifdef DEBUG
                (void) testdebug ((*pe), "searchInfo");
#endif

            }
            break;
        case 2:	/* uncorrelatedSearchInfo */
            {
                if (build_STRONG_SETOFSearchResult (pe, 0, NULL, NULLCP, parm->srrtbs_un.uncorrel_searchinfo) == NOTOK)
                    return NOTOK;

#ifdef DEBUG
                (void) testdebug ((*pe), "uncorrelatedSearchInfo");
#endif

                {	/* uncorrelatedSearchInfo TAG PUSHDOWN */
                    PE p194_z;
                    register PE *p194 = &p194_z;

                    if ((*p194 = pe_alloc (PE_CLASS_CONT, PE_FORM_CONS, 0)) == NULLPE) {
                        advise (NULLCP, "uncorrelatedSearchInfo: %s", PEPY_ERR_NOMEM);
                        return NOTOK;
                    }
                    (*p194) -> pe_cons = (*pe);
                    (*pe) = *p194;
                }
            }
            break;

        default:
            advise (NULLCP, "SearchResultTBS %s%d", PEPY_ERR_INVALID_CHOICE, 
                    p193);
            return NOTOK;
    }

#ifdef DEBUG
    (void) testdebug ((*pe), "STRONG.SearchResultTBS");
#endif


    return OK;
}

/* ARGSUSED */

int	build_STRONG_SearchResult (pe, explicit, len, buffer, parm)
register PE     *pe;
int	explicit;
int	len;
char   *buffer;
SearchResult * parm;
{
# line 857 "STRONG.py"
    	PE	tbs;

    int	p195;

    switch (p195 = (parm->sig? 2:1)) {
        case 1:
            {
                PE	p196 = (build_searchres_tbs(parm,&tbs)) ;

                if (p196 == NULLPE) {
                    advise (NULLCP, "member %s", PEPY_ERR_INIT_FAILED);
                    return NOTOK;
                }
                ((*pe) = p196) -> pe_refcnt++;

#ifdef DEBUG
                (void) testdebug ((*pe), "member");
#endif

                {
# line 863 "STRONG.py"
    pe_free(tbs);
		
                }
            }
            break;
        case 2:
            {
                PE	p197_z = NULLPE;
                register PE *p197 = &p197_z;

                if (((*pe) = pe_alloc (PE_CLASS_UNIV, PE_FORM_CONS, PE_CONS_SEQ)) == NULLPE) {
                    advise (NULLCP, "member: %s", PEPY_ERR_NOMEM);
                    return NOTOK;
                }
                (*p197) = NULLPE;

                {
                    PE	p198 = (build_searchres_tbs(parm,&tbs)) ;

                    if (p198 == NULLPE) {
                        advise (NULLCP, "element %s", PEPY_ERR_INIT_FAILED);
                        return NOTOK;
                    }
                    ((*p197) = p198) -> pe_refcnt++;

#ifdef DEBUG
                    (void) testdebug ((*p197), "element");
#endif

                    {
# line 870 "STRONG.py"
    pe_free(tbs);
			
                    }
                }

                if ((*p197) != NULLPE)
                    if (seq_add ((*pe), (*p197), -1) == NOTOK) {
                        advise (NULLCP, "member %s%s", PEPY_ERR_BAD_SEQ,
                                pe_error ((*pe) -> pe_errno));
                        return NOTOK;
                    }
                (*p197) = NULLPE;

                {
                    if (build_SEC_AlgorithmIdentifier (p197, 0, NULL, NULLCP, parm->sig->signAI ) == NOTOK)
                        return NOTOK;

#ifdef DEBUG
                    (void) testdebug ((*p197), "element");
#endif

                }

                if ((*p197) != NULLPE)
                    if (seq_add ((*pe), (*p197), -1) == NOTOK) {
                        advise (NULLCP, "member %s%s", PEPY_ERR_BAD_SEQ,
                                pe_error ((*pe) -> pe_errno));
                        return NOTOK;
                    }
                (*p197) = NULLPE;

                {
                    PE	p199_z = NULLPE;
                    register PE *p199 = &p199_z;

                    char *p200;
                    int p201;
                    p200 = parm->sig->signature.bits ;
                    p201 = 
		     	parm->sig->signature.nbits ;
                    (*p199) = p200 ? strb2bitstr (p200, p201, PE_CLASS_UNIV, PE_PRIM_BITS) : NULLPE;
                    if ((*p199) == NULLPE) {
                        advise (NULLCP, "element %s", PEPY_ERR_INIT_FAILED);
                        return NOTOK;
                    }
                    if (((*p197) = bit2prim ((*p199))) == NULLPE) {
                        advise (NULLCP, "element: %s", PEPY_ERR_NOMEM);
                        return NOTOK;
                    }

#ifdef DEBUG
                    (void) testdebug ((*p197), "element");
#endif

                }

                if ((*p197) != NULLPE)
                    if (seq_add ((*pe), (*p197), -1) == NOTOK) {
                        advise (NULLCP, "member %s%s", PEPY_ERR_BAD_SEQ,
                                pe_error ((*pe) -> pe_errno));
                        return NOTOK;
                    }

#ifdef DEBUG
                (void) testdebug ((*pe), "member");
#endif

            }
            break;

        default:
            advise (NULLCP, "SearchResult %s%d", PEPY_ERR_INVALID_CHOICE, 
                    p195);
            return NOTOK;
    }

#ifdef DEBUG
    (void) testdebug ((*pe), "STRONG.SearchResult");
#endif


    return OK;
}

/* ARGSUSED */

int	build_STRONG_SETOFSearchResult (pe, explicit, len, buffer, parm)
PE     *pe;
int	explicit;
int	len;
char   *buffer;
SET_OF_SearchResult * parm;
{
# line 891 "STRONG.py"
    
	PE pe_enc = encode_STRONG_DER_SET_OF(parm, SEARCHRESULTSET);
	
    PE	p202 = pe_enc ;

    if (p202 == NULLPE) {
        advise (NULLCP, "SETOFSearchResult %s", PEPY_ERR_INIT_FAILED);
        return NOTOK;
    }
    ((*pe) = p202) -> pe_refcnt++;

#ifdef DEBUG
    (void) testdebug ((*pe), "STRONG.SETOFSearchResult");
#endif

    {
# line 896 "STRONG.py"

	pe_free(pe_enc);
	
    }

    return OK;
}

/* ARGSUSED */

int	build_STRONG_EntryModification (pe, explicit, len, buffer, parm)
register PE     *pe;
int	explicit;
int	len;
char   *buffer;
EntryModification * parm;
{
    int	p203;

    switch (p203 = ( parm->em_type )) {
        case 1:	/* addAttribute */
            {
                if (build_IF_Attribute (pe, 0, NULL, NULLCP, parm->em_un.em_un_attr ) == NOTOK)
                    return NOTOK;

#ifdef DEBUG
                (void) testdebug ((*pe), "addAttribute");
#endif

                {	/* addAttribute TAG PUSHDOWN */
                    PE p204_z;
                    register PE *p204 = &p204_z;

                    if ((*p204 = pe_alloc (PE_CLASS_CONT, PE_FORM_CONS, 0)) == NULLPE) {
                        advise (NULLCP, "addAttribute: %s", PEPY_ERR_NOMEM);
                        return NOTOK;
                    }
                    (*p204) -> pe_cons = (*pe);
                    (*pe) = *p204;
                }
            }
            break;
        case 2:	/* removeAttribute */
            {
                register OID p205;

                p205 = parm->em_un.em_un_attrtype ;
                if (p205 == NULLOID) {
                    advise (NULLCP, "removeAttribute %s", PEPY_ERR_INIT_FAILED);
                    return NOTOK;
                }
                if (((*pe) = obj2prim (p205, PE_CLASS_UNIV, PE_PRIM_OID)) == NULLPE) {
                    advise (NULLCP, "removeAttribute: %s", PEPY_ERR_NOMEM);
                    return NOTOK;
                }

#ifdef DEBUG
                (void) testdebug ((*pe), "removeAttribute");
#endif

                {	/* removeAttribute TAG PUSHDOWN */
                    PE p206_z;
                    register PE *p206 = &p206_z;

                    if ((*p206 = pe_alloc (PE_CLASS_CONT, PE_FORM_CONS, 1)) == NULLPE) {
                        advise (NULLCP, "removeAttribute: %s", PEPY_ERR_NOMEM);
                        return NOTOK;
                    }
                    (*p206) -> pe_cons = (*pe);
                    (*pe) = *p206;
                }
            }
            break;
        case 3:	/* addValues */
            {
                if (build_IF_Attribute (pe, 0, NULL, NULLCP, parm->em_un.em_un_attr ) == NOTOK)
                    return NOTOK;

#ifdef DEBUG
                (void) testdebug ((*pe), "addValues");
#endif

                {	/* addValues TAG PUSHDOWN */
                    PE p207_z;
                    register PE *p207 = &p207_z;

                    if ((*p207 = pe_alloc (PE_CLASS_CONT, PE_FORM_CONS, 2)) == NULLPE) {
                        advise (NULLCP, "addValues: %s", PEPY_ERR_NOMEM);
                        return NOTOK;
                    }
                    (*p207) -> pe_cons = (*pe);
                    (*pe) = *p207;
                }
            }
            break;
        case 4:	/* removeValues */
            {
                if (build_IF_Attribute (pe, 0, NULL, NULLCP, parm->em_un.em_un_attr ) == NOTOK)
                    return NOTOK;

#ifdef DEBUG
                (void) testdebug ((*pe), "removeValues");
#endif

                {	/* removeValues TAG PUSHDOWN */
                    PE p208_z;
                    register PE *p208 = &p208_z;

                    if ((*p208 = pe_alloc (PE_CLASS_CONT, PE_FORM_CONS, 3)) == NULLPE) {
                        advise (NULLCP, "removeValues: %s", PEPY_ERR_NOMEM);
                        return NOTOK;
                    }
                    (*p208) -> pe_cons = (*pe);
                    (*pe) = *p208;
                }
            }
            break;

        default:
            advise (NULLCP, "EntryModification %s%d", PEPY_ERR_INVALID_CHOICE, 
                    p203);
            return NOTOK;
    }

#ifdef DEBUG
    (void) testdebug ((*pe), "STRONG.EntryModification");
#endif


    return OK;
}

/* ARGSUSED */

int	build_STRONG_EntryModificationSequence (pe, explicit, len, buffer, parm)
register PE     *pe;
int	explicit;
int	len;
char   *buffer;
SEQUENCE_OF_EntryModification * parm;
{
    PE	p209 = NULLPE;
    PE	p210_z = NULLPE;
    register PE *p210 = &p210_z;

    if (((*pe) = pe_alloc (PE_CLASS_UNIV, PE_FORM_CONS, PE_CONS_SEQ)) == NULLPE) {
        advise (NULLCP, "EntryModificationSequence: %s", PEPY_ERR_NOMEM);
        return NOTOK;
    }
    for (; parm; parm = parm->next) {
        if (build_STRONG_EntryModification (p210, 0, NULL, NULLCP, parm->element ) == NOTOK)
            return NOTOK;

#ifdef DEBUG
        (void) testdebug ((*p210), "element");
#endif

        (void) seq_addon ((*pe), p209, (*p210));
        p209 = (*p210);
    }

#ifdef DEBUG
    (void) testdebug ((*pe), "STRONG.EntryModificationSequence");
#endif


    return OK;
}

/* ARGSUSED */

int	build_STRONG_ServiceControls (pe, explicit, len, buffer, parm)
register PE     *pe;
int	explicit;
int	len;
char   *buffer;
ServiceControls * parm;
{
    PE	p211_z = NULLPE;
    register PE *p211 = &p211_z;

    if (((*pe) = pe_alloc (PE_CLASS_UNIV, PE_FORM_CONS, PE_CONS_SET)) == NULLPE) {
        advise (NULLCP, "ServiceControls: %s", PEPY_ERR_NOMEM);
        return NOTOK;
    }
    {
# line 930 "STRONG.py"

	if (parm->svc_options != 0) {
		parm->svc_len = 5;
		parm->svc_tmp = aux_int2strb_alloc (parm->svc_options,parm->svc_len);
	}
	
    }
    (*p211) = NULLPE;

    if (parm->svc_options != 0) {
        PE	p212_z = NULLPE;
        register PE *p212 = &p212_z;

        char *p213;
        int p214;
        p213 = parm->svc_tmp ;
        p214 =  parm->svc_len ;
        (*p212) = p213 ? strb2bitstr (p213, p214, PE_CLASS_UNIV, PE_PRIM_BITS) : NULLPE;
        if ((*p212) == NULLPE) {
            advise (NULLCP, "options %s", PEPY_ERR_INIT_FAILED);
            return NOTOK;
        }
        if (bit_test ((*p212), 4) == NOTOK)
            (void) bit_off ((*p212), 4);
        if (((*p211) = bit2prim ((*p212))) == NULLPE) {
            advise (NULLCP, "options: %s", PEPY_ERR_NOMEM);
            return NOTOK;
        }
#define	BITS	"\020\01preferChaining\02chainingProhibited\03localScope\04dontUseCopy\05dontDereferenceAliases"

#ifdef DEBUG
        (void) testdebug ((*p211), "options");
#endif

        {
# line 947 "STRONG.py"

		if (parm->svc_tmp){
			free (parm->svc_tmp);
			parm->svc_tmp = CNULL;
		}
		
        }
#undef	BITS
        {	/* options TAG PUSHDOWN */
            PE p215_z;
            register PE *p215 = &p215_z;

            if ((*p215 = pe_alloc (PE_CLASS_CONT, PE_FORM_CONS, 0)) == NULLPE) {
                advise (NULLCP, "options: %s", PEPY_ERR_NOMEM);
                return NOTOK;
            }
            (*p215) -> pe_cons = (*p211);
            (*p211) = *p215;
        }
    }
    if ((*p211) != NULLPE)
        if (set_add ((*pe), (*p211)) == NOTOK) {
            advise (NULLCP, "ServiceControls %s%s", PEPY_ERR_BAD_SET,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }
    (*p211) = NULLPE;

    if (parm->svc_prio != 1) {
        register integer p216 = parm->svc_prio ;

        if (((*p211) = num2prim (p216, PE_CLASS_UNIV, PE_PRIM_INT)) == NULLPE) {
            advise (NULLCP, "priority: %s", PEPY_ERR_NOMEM);
            return NOTOK;
        }
        switch (p216) {
            case 0:	/* low */
                break;
            case 1:	/* medium */
                break;
            case 2:	/* high */
                break;
        }

#ifdef DEBUG
        (void) testdebug ((*p211), "priority");
#endif

        {	/* priority TAG PUSHDOWN */
            PE p217_z;
            register PE *p217 = &p217_z;

            if ((*p217 = pe_alloc (PE_CLASS_CONT, PE_FORM_CONS, 1)) == NULLPE) {
                advise (NULLCP, "priority: %s", PEPY_ERR_NOMEM);
                return NOTOK;
            }
            (*p217) -> pe_cons = (*p211);
            (*p211) = *p217;
        }
    }
    if ((*p211) != NULLPE)
        if (set_add ((*pe), (*p211)) == NOTOK) {
            advise (NULLCP, "ServiceControls %s%s", PEPY_ERR_BAD_SET,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }
    (*p211) = NULLPE;

    if (parm->svc_timelimit != SVC_NOTIMELIMIT) {
        register integer p218 = parm->svc_timelimit ;

        if (((*p211) = num2prim (p218, PE_CLASS_UNIV, PE_PRIM_INT)) == NULLPE) {
            advise (NULLCP, "timeLimit: %s", PEPY_ERR_NOMEM);
            return NOTOK;
        }

#ifdef DEBUG
        (void) testdebug ((*p211), "timeLimit");
#endif

        {	/* timeLimit TAG PUSHDOWN */
            PE p219_z;
            register PE *p219 = &p219_z;

            if ((*p219 = pe_alloc (PE_CLASS_CONT, PE_FORM_CONS, 2)) == NULLPE) {
                advise (NULLCP, "timeLimit: %s", PEPY_ERR_NOMEM);
                return NOTOK;
            }
            (*p219) -> pe_cons = (*p211);
            (*p211) = *p219;
        }
    }
    if ((*p211) != NULLPE)
        if (set_add ((*pe), (*p211)) == NOTOK) {
            advise (NULLCP, "ServiceControls %s%s", PEPY_ERR_BAD_SET,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }
    (*p211) = NULLPE;

    if (parm->svc_sizelimit != SVC_NOSIZELIMIT) {
        register integer p220 = parm->svc_sizelimit ;

        if (((*p211) = num2prim (p220, PE_CLASS_UNIV, PE_PRIM_INT)) == NULLPE) {
            advise (NULLCP, "sizeLimit: %s", PEPY_ERR_NOMEM);
            return NOTOK;
        }

#ifdef DEBUG
        (void) testdebug ((*p211), "sizeLimit");
#endif

        {	/* sizeLimit TAG PUSHDOWN */
            PE p221_z;
            register PE *p221 = &p221_z;

            if ((*p221 = pe_alloc (PE_CLASS_CONT, PE_FORM_CONS, 3)) == NULLPE) {
                advise (NULLCP, "sizeLimit: %s", PEPY_ERR_NOMEM);
                return NOTOK;
            }
            (*p221) -> pe_cons = (*p211);
            (*p211) = *p221;
        }
    }
    if ((*p211) != NULLPE)
        if (set_add ((*pe), (*p211)) == NOTOK) {
            advise (NULLCP, "ServiceControls %s%s", PEPY_ERR_BAD_SET,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }
    (*p211) = NULLPE;

    if (parm->svc_scopeofreferral != SVC_REFSCOPE_NONE) {
        register integer p222 = parm->svc_scopeofreferral ;

        if (((*p211) = num2prim (p222, PE_CLASS_UNIV, PE_PRIM_INT)) == NULLPE) {
            advise (NULLCP, "scopeOfReferral: %s", PEPY_ERR_NOMEM);
            return NOTOK;
        }
        switch (p222) {
            case 0:	/* dmd */
                break;
            case 1:	/* country */
                break;
        }

#ifdef DEBUG
        (void) testdebug ((*p211), "scopeOfReferral");
#endif

        {	/* scopeOfReferral TAG PUSHDOWN */
            PE p223_z;
            register PE *p223 = &p223_z;

            if ((*p223 = pe_alloc (PE_CLASS_CONT, PE_FORM_CONS, 4)) == NULLPE) {
                advise (NULLCP, "scopeOfReferral: %s", PEPY_ERR_NOMEM);
                return NOTOK;
            }
            (*p223) -> pe_cons = (*p211);
            (*p211) = *p223;
        }
    }
    if ((*p211) != NULLPE)
        if (set_add ((*pe), (*p211)) == NOTOK) {
            advise (NULLCP, "ServiceControls %s%s", PEPY_ERR_BAD_SET,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }

#ifdef DEBUG
    (void) testdebug ((*pe), "STRONG.ServiceControls");
#endif


    return OK;
}

/* ARGSUSED */

int	build_STRONG_SecurityParameters (pe, explicit, len, buffer, parm)
register PE     *pe;
int	explicit;
int	len;
char   *buffer;
SecurityParameters * parm;
{
    PE	p224_z = NULLPE;
    register PE *p224 = &p224_z;

    if (((*pe) = pe_alloc (PE_CLASS_UNIV, PE_FORM_CONS, PE_CONS_SET)) == NULLPE) {
        advise (NULLCP, "SecurityParameters: %s", PEPY_ERR_NOMEM);
        return NOTOK;
    }
    (*p224) = NULLPE;

    if (parm->certPath) {
        if (build_AF_CertificationPath (p224, 0, NULL, NULLCP, parm->certPath ) == NOTOK)
            return NOTOK;

#ifdef DEBUG
        (void) testdebug ((*p224), "certificationPath");
#endif

        {	/* certificationPath TAG PUSHDOWN */
            PE p225_z;
            register PE *p225 = &p225_z;

            if ((*p225 = pe_alloc (PE_CLASS_CONT, PE_FORM_CONS, 0)) == NULLPE) {
                advise (NULLCP, "certificationPath: %s", PEPY_ERR_NOMEM);
                return NOTOK;
            }
            (*p225) -> pe_cons = (*p224);
            (*p224) = *p225;
        }
    }
    if ((*p224) != NULLPE)
        if (set_add ((*pe), (*p224)) == NOTOK) {
            advise (NULLCP, "SecurityParameters %s%s", PEPY_ERR_BAD_SET,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }
    (*p224) = NULLPE;

    if (parm->name) {
        if (build_IF_Name (p224, 0, NULL, NULLCP, parm->name ) == NOTOK)
            return NOTOK;

#ifdef DEBUG
        (void) testdebug ((*p224), "name");
#endif

        {	/* name TAG PUSHDOWN */
            PE p226_z;
            register PE *p226 = &p226_z;

            if ((*p226 = pe_alloc (PE_CLASS_CONT, PE_FORM_CONS, 1)) == NULLPE) {
                advise (NULLCP, "name: %s", PEPY_ERR_NOMEM);
                return NOTOK;
            }
            (*p226) -> pe_cons = (*p224);
            (*p224) = *p226;
        }
    }
    if ((*p224) != NULLPE)
        if (set_add ((*pe), (*p224)) == NOTOK) {
            advise (NULLCP, "SecurityParameters %s%s", PEPY_ERR_BAD_SET,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }
    (*p224) = NULLPE;

    if (parm->time) {
        if (build_UNIV_UTCTime (p224, 0, NULL, parm->time , NullParm) == NOTOK)
            return NOTOK;

#ifdef DEBUG
        (void) testdebug ((*p224), "time");
#endif

        {	/* time TAG PUSHDOWN */
            PE p227_z;
            register PE *p227 = &p227_z;

            if ((*p227 = pe_alloc (PE_CLASS_CONT, PE_FORM_CONS, 2)) == NULLPE) {
                advise (NULLCP, "time: %s", PEPY_ERR_NOMEM);
                return NOTOK;
            }
            (*p227) -> pe_cons = (*p224);
            (*p224) = *p227;
        }
    }
    if ((*p224) != NULLPE)
        if (set_add ((*pe), (*p224)) == NOTOK) {
            advise (NULLCP, "SecurityParameters %s%s", PEPY_ERR_BAD_SET,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }
    (*p224) = NULLPE;

    if (parm->random) {
        PE	p228_z = NULLPE;
        register PE *p228 = &p228_z;

        char *p229;
        int p230;
        p229 = parm->random->bits ;
        p230 =  parm->random->nbits ;
        (*p228) = p229 ? strb2bitstr (p229, p230, PE_CLASS_UNIV, PE_PRIM_BITS) : NULLPE;
        if ((*p228) == NULLPE) {
            advise (NULLCP, "random %s", PEPY_ERR_INIT_FAILED);
            return NOTOK;
        }
        if (((*p224) = bit2prim ((*p228))) == NULLPE) {
            advise (NULLCP, "random: %s", PEPY_ERR_NOMEM);
            return NOTOK;
        }

#ifdef DEBUG
        (void) testdebug ((*p224), "random");
#endif

        {	/* random TAG PUSHDOWN */
            PE p231_z;
            register PE *p231 = &p231_z;

            if ((*p231 = pe_alloc (PE_CLASS_CONT, PE_FORM_CONS, 3)) == NULLPE) {
                advise (NULLCP, "random: %s", PEPY_ERR_NOMEM);
                return NOTOK;
            }
            (*p231) -> pe_cons = (*p224);
            (*p224) = *p231;
        }
    }
    if ((*p224) != NULLPE)
        if (set_add ((*pe), (*p224)) == NOTOK) {
            advise (NULLCP, "SecurityParameters %s%s", PEPY_ERR_BAD_SET,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }
    (*p224) = NULLPE;

    if (parm->target != 0) {
        register integer p232 = parm->target ;

        if (((*p224) = num2prim (p232, PE_CLASS_UNIV, PE_PRIM_INT)) == NULLPE) {
            advise (NULLCP, "target: %s", PEPY_ERR_NOMEM);
            return NOTOK;
        }
        switch (p232) {
            case 0:	/* none */
                break;
            case 1:	/* signed */
                break;
        }

#ifdef DEBUG
        (void) testdebug ((*p224), "target");
#endif

        {	/* target TAG PUSHDOWN */
            PE p233_z;
            register PE *p233 = &p233_z;

            if ((*p233 = pe_alloc (PE_CLASS_CONT, PE_FORM_CONS, 4)) == NULLPE) {
                advise (NULLCP, "target: %s", PEPY_ERR_NOMEM);
                return NOTOK;
            }
            (*p233) -> pe_cons = (*p224);
            (*p224) = *p233;
        }
    }
    if ((*p224) != NULLPE)
        if (set_add ((*pe), (*p224)) == NOTOK) {
            advise (NULLCP, "SecurityParameters %s%s", PEPY_ERR_BAD_SET,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }

#ifdef DEBUG
    (void) testdebug ((*pe), "STRONG.SecurityParameters");
#endif


    return OK;
}

/* ARGSUSED */

int	build_STRONG_OperationProgress (pe, explicit, len, buffer, parm)
register PE     *pe;
int	explicit;
int	len;
char   *buffer;
OperationProgress * parm;
{
    PE	p234_z = NULLPE;
    register PE *p234 = &p234_z;

    if (((*pe) = pe_alloc (PE_CLASS_UNIV, PE_FORM_CONS, PE_CONS_SET)) == NULLPE) {
        advise (NULLCP, "OperationProgress: %s", PEPY_ERR_NOMEM);
        return NOTOK;
    }
    {
# line 1021 "STRONG.py"

	if (parm->opResolutionPhase < 0)
		parm->opResolutionPhase = 1;
	else if (parm->opResolutionPhase > 3)
		parm->opResolutionPhase = 3;
	
    }
    (*p234) = NULLPE;

    {
        register integer p235 = parm->opResolutionPhase ;

        if (((*p234) = enum2prim (p235, PE_CLASS_UNIV, PE_PRIM_ENUM)) == NULLPE) {
            advise (NULLCP, "opResolutionPhase: %s", PEPY_ERR_NOMEM);
            return NOTOK;
        }
        switch (p235) {
            case 1:	/* notStarted */
                break;
            case 2:	/* proceeding */
                break;
            case 3:	/* completed */
                break;
            default:
                advise (NULLCP, "opResolutionPhase %s%d", PEPY_ERR_UNK_COMP, p235);
                return NOTOK;
        }

#ifdef DEBUG
        (void) testdebug ((*p234), "opResolutionPhase");
#endif

        {	/* opResolutionPhase TAG PUSHDOWN */
            PE p236_z;
            register PE *p236 = &p236_z;

            if ((*p236 = pe_alloc (PE_CLASS_CONT, PE_FORM_CONS, 0)) == NULLPE) {
                advise (NULLCP, "opResolutionPhase: %s", PEPY_ERR_NOMEM);
                return NOTOK;
            }
            (*p236) -> pe_cons = (*p234);
            (*p234) = *p236;
        }
    }
    if ((*p234) != NULLPE)
        if (set_add ((*pe), (*p234)) == NOTOK) {
            advise (NULLCP, "OperationProgress %s%s", PEPY_ERR_BAD_SET,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }
    (*p234) = NULLPE;

    if (parm->opNextRDNToBeResolved != -1) {
        register integer p237 = parm->opNextRDNToBeResolved ;

        if (((*p234) = num2prim (p237, PE_CLASS_UNIV, PE_PRIM_INT)) == NULLPE) {
            advise (NULLCP, "opNextRDNToBeResolved: %s", PEPY_ERR_NOMEM);
            return NOTOK;
        }

#ifdef DEBUG
        (void) testdebug ((*p234), "opNextRDNToBeResolved");
#endif

        {	/* opNextRDNToBeResolved TAG PUSHDOWN */
            PE p238_z;
            register PE *p238 = &p238_z;

            if ((*p238 = pe_alloc (PE_CLASS_CONT, PE_FORM_CONS, 1)) == NULLPE) {
                advise (NULLCP, "opNextRDNToBeResolved: %s", PEPY_ERR_NOMEM);
                return NOTOK;
            }
            (*p238) -> pe_cons = (*p234);
            (*p234) = *p238;
        }
    }
    if ((*p234) != NULLPE)
        if (set_add ((*pe), (*p234)) == NOTOK) {
            advise (NULLCP, "OperationProgress %s%s", PEPY_ERR_BAD_SET,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }

#ifdef DEBUG
    (void) testdebug ((*pe), "STRONG.OperationProgress");
#endif


    return OK;
}

/* ARGSUSED */

int	build_STRONG_SECExtensionSet (pe, explicit, len, buffer, parm)
PE     *pe;
int	explicit;
int	len;
char   *buffer;
SET_OF_SECExtension * parm;
{
# line 1052 "STRONG.py"
    
	PE pe_enc = encode_STRONG_DER_SET_OF(parm, SECEXTENSIONSET);
	
    PE	p239 = pe_enc ;

    if (p239 == NULLPE) {
        advise (NULLCP, "SECExtensionSet %s", PEPY_ERR_INIT_FAILED);
        return NOTOK;
    }
    ((*pe) = p239) -> pe_refcnt++;

#ifdef DEBUG
    (void) testdebug ((*pe), "STRONG.SECExtensionSet");
#endif

    {
# line 1057 "STRONG.py"

	pe_free(pe_enc);
	
    }

    return OK;
}

/* ARGSUSED */

int	build_STRONG_SECExtension (pe, explicit, len, buffer, parm)
register PE     *pe;
int	explicit;
int	len;
char   *buffer;
SECExtension * parm;
{
    PE	p240_z = NULLPE;
    register PE *p240 = &p240_z;

    if (((*pe) = pe_alloc (PE_CLASS_UNIV, PE_FORM_CONS, PE_CONS_SET)) == NULLPE) {
        advise (NULLCP, "SECExtension: %s", PEPY_ERR_NOMEM);
        return NOTOK;
    }
    (*p240) = NULLPE;

    {
        register integer p241 = parm->ext_id ;

        if (((*p240) = num2prim (p241, PE_CLASS_UNIV, PE_PRIM_INT)) == NULLPE) {
            advise (NULLCP, "identifier: %s", PEPY_ERR_NOMEM);
            return NOTOK;
        }

#ifdef DEBUG
        (void) testdebug ((*p240), "identifier");
#endif

        {	/* identifier TAG PUSHDOWN */
            PE p242_z;
            register PE *p242 = &p242_z;

            if ((*p242 = pe_alloc (PE_CLASS_CONT, PE_FORM_CONS, 0)) == NULLPE) {
                advise (NULLCP, "identifier: %s", PEPY_ERR_NOMEM);
                return NOTOK;
            }
            (*p242) -> pe_cons = (*p240);
            (*p240) = *p242;
        }
    }
    if ((*p240) != NULLPE)
        if (set_add ((*pe), (*p240)) == NOTOK) {
            advise (NULLCP, "SECExtension %s%s", PEPY_ERR_BAD_SET,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }
    (*p240) = NULLPE;

    if (parm->ext_critical) {
        register int p243 = parm->ext_critical ;

        if (((*p240) = flag2prim (p243, PE_CLASS_UNIV, PE_PRIM_BOOL)) == NULLPE) {
            advise (NULLCP, "critical: %s", PEPY_ERR_NOMEM);
            return NOTOK;
        }

#ifdef DEBUG
        (void) testdebug ((*p240), "critical");
#endif

        {	/* critical TAG PUSHDOWN */
            PE p244_z;
            register PE *p244 = &p244_z;

            if ((*p244 = pe_alloc (PE_CLASS_CONT, PE_FORM_CONS, 1)) == NULLPE) {
                advise (NULLCP, "critical: %s", PEPY_ERR_NOMEM);
                return NOTOK;
            }
            (*p244) -> pe_cons = (*p240);
            (*p240) = *p244;
        }
    }
    if ((*p240) != NULLPE)
        if (set_add ((*pe), (*p240)) == NOTOK) {
            advise (NULLCP, "SECExtension %s%s", PEPY_ERR_BAD_SET,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }
    (*p240) = NULLPE;

    {
        PE	p245 = parm->ext_item ;

        if (p245 == NULLPE) {
            advise (NULLCP, "item %s", PEPY_ERR_INIT_FAILED);
            return NOTOK;
        }
        ((*p240) = p245) -> pe_refcnt++;

#ifdef DEBUG
        (void) testdebug ((*p240), "item");
#endif

        {	/* item TAG PUSHDOWN */
            PE p246_z;
            register PE *p246 = &p246_z;

            if ((*p246 = pe_alloc (PE_CLASS_CONT, PE_FORM_CONS, 2)) == NULLPE) {
                advise (NULLCP, "item: %s", PEPY_ERR_NOMEM);
                return NOTOK;
            }
            (*p246) -> pe_cons = (*p240);
            (*p240) = *p246;
        }
    }
    if ((*p240) != NULLPE)
        if (set_add ((*pe), (*p240)) == NOTOK) {
            advise (NULLCP, "SECExtension %s%s", PEPY_ERR_BAD_SET,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }

#ifdef DEBUG
    (void) testdebug ((*pe), "STRONG.SECExtension");
#endif


    return OK;
}

/* ARGSUSED */

int	build_STRONG_SETOFAttributeType (pe, explicit, len, buffer, parm)
PE     *pe;
int	explicit;
int	len;
char   *buffer;
SET_OF_AttrType * parm;
{
# line 1087 "STRONG.py"
    
	PE pe_enc = encode_STRONG_DER_SET_OF(parm, ATTRTYPESET);
	
    PE	p247 = pe_enc ;

    if (p247 == NULLPE) {
        advise (NULLCP, "SETOFAttributeType %s", PEPY_ERR_INIT_FAILED);
        return NOTOK;
    }
    ((*pe) = p247) -> pe_refcnt++;

#ifdef DEBUG
    (void) testdebug ((*pe), "STRONG.SETOFAttributeType");
#endif

    {
# line 1092 "STRONG.py"

	pe_free(pe_enc);
	
    }

    return OK;
}

/* ARGSUSED */

int	build_STRONG_SETOFAttribute (pe, explicit, len, buffer, parm)
PE     *pe;
int	explicit;
int	len;
char   *buffer;
SET_OF_Attr * parm;
{
# line 1108 "STRONG.py"
    
	PE pe_enc = encode_STRONG_DER_SET_OF(parm, ATTRSET);
	
    PE	p248 = pe_enc ;

    if (p248 == NULLPE) {
        advise (NULLCP, "SETOFAttribute %s", PEPY_ERR_INIT_FAILED);
        return NOTOK;
    }
    ((*pe) = p248) -> pe_refcnt++;

#ifdef DEBUG
    (void) testdebug ((*pe), "STRONG.SETOFAttribute");
#endif

    {
# line 1113 "STRONG.py"

	pe_free(pe_enc);
	
    }

    return OK;
}

/* ARGSUSED */

int	build_STRONG_SETOFAttrAttrTypeCHOICE (pe, explicit, len, buffer, parm)
PE     *pe;
int	explicit;
int	len;
char   *buffer;
SET_OF_AttrAttrTypeCHOICE * parm;
{
# line 1126 "STRONG.py"
    
	PE pe_enc = encode_STRONG_DER_SET_OF(parm, ATTRATTRTYPECHOICESET);
	
    PE	p249 = pe_enc ;

    if (p249 == NULLPE) {
        advise (NULLCP, "SETOFAttrAttrTypeCHOICE %s", PEPY_ERR_INIT_FAILED);
        return NOTOK;
    }
    ((*pe) = p249) -> pe_refcnt++;

#ifdef DEBUG
    (void) testdebug ((*pe), "STRONG.SETOFAttrAttrTypeCHOICE");
#endif

    {
# line 1131 "STRONG.py"

	pe_free(pe_enc);
	
    }

    return OK;
}

/* ARGSUSED */

int	build_STRONG_AttrAttrTypeCHOICE (pe, explicit, len, buffer, parm)
register PE     *pe;
int	explicit;
int	len;
char   *buffer;
AttrAttrTypeCHOICE * parm;
{
    int	p250;

    switch (p250 = (parm->offset)) {
        case 1:
            {
                register OID p251;

                p251 = parm->choice_un.choice_un_attrtype ;
                if (p251 == NULLOID) {
                    advise (NULLCP, "member %s", PEPY_ERR_INIT_FAILED);
                    return NOTOK;
                }
                if (((*pe) = obj2prim (p251, PE_CLASS_UNIV, PE_PRIM_OID)) == NULLPE) {
                    advise (NULLCP, "member: %s", PEPY_ERR_NOMEM);
                    return NOTOK;
                }

#ifdef DEBUG
                (void) testdebug ((*pe), "member");
#endif

            }
            break;
        case 2:
            {
                if (build_IF_Attribute (pe, 0, NULL, NULLCP, parm->choice_un.choice_un_attr->element ) == NOTOK)
                    return NOTOK;

#ifdef DEBUG
                (void) testdebug ((*pe), "member");
#endif

            }
            break;

        default:
            advise (NULLCP, "AttrAttrTypeCHOICE %s%d", PEPY_ERR_INVALID_CHOICE, 
                    p250);
            return NOTOK;
    }

#ifdef DEBUG
    (void) testdebug ((*pe), "STRONG.AttrAttrTypeCHOICE");
#endif


    return OK;
}

/* ARGSUSED */

int	build_STRONG_EntryInfoSEL (pe, explicit, len, buffer, parm)
register PE     *pe;
int	explicit;
int	len;
char   *buffer;
EntryInfoSEL * parm;
{
    PE	p252_z = NULLPE;
    register PE *p252 = &p252_z;

    if (((*pe) = pe_alloc (PE_CLASS_UNIV, PE_FORM_CONS, PE_CONS_SET)) == NULLPE) {
        advise (NULLCP, "EntryInfoSEL: %s", PEPY_ERR_NOMEM);
        return NOTOK;
    }
    (*p252) = NULLPE;

    if (parm->eis_allattributes != TRUE) {
        int	p253;

        switch (p253 = ( parm->eis_allattributes ? 1 : 2 )) {
            case 1:	/* allAttributes */
                {
                    if (((*p252) = pe_alloc (PE_CLASS_UNIV, PE_FORM_PRIM, PE_PRIM_NULL)) == NULLPE) {
                        advise (NULLCP, "allAttributes: %s", PEPY_ERR_NOMEM);
                        return NOTOK;
                    }

#ifdef DEBUG
                    (void) testdebug ((*p252), "allAttributes");
#endif

                    {	/* allAttributes TAG PUSHDOWN */
                        PE p254_z;
                        register PE *p254 = &p254_z;

                        if ((*p254 = pe_alloc (PE_CLASS_CONT, PE_FORM_CONS, 0)) == NULLPE) {
                            advise (NULLCP, "allAttributes: %s", PEPY_ERR_NOMEM);
                            return NOTOK;
                        }
                        (*p254) -> pe_cons = (*p252);
                        (*p252) = *p254;
                    }
                }
                break;
            case 2:	/* select */
                {
                    if (build_STRONG_SETOFAttributeType (p252, 0, NULL, NULLCP, parm->eis_select) == NOTOK)
                        return NOTOK;

#ifdef DEBUG
                    (void) testdebug ((*p252), "select");
#endif

                    {	/* select TAG PUSHDOWN */
                        PE p255_z;
                        register PE *p255 = &p255_z;

                        if ((*p255 = pe_alloc (PE_CLASS_CONT, PE_FORM_CONS, 1)) == NULLPE) {
                            advise (NULLCP, "select: %s", PEPY_ERR_NOMEM);
                            return NOTOK;
                        }
                        (*p255) -> pe_cons = (*p252);
                        (*p252) = *p255;
                    }
                }
                break;

            default:
                advise (NULLCP, "attributeTypes %s%d", PEPY_ERR_INVALID_CHOICE, 
                        p253);
                return NOTOK;
        }

#ifdef DEBUG
        (void) testdebug ((*p252), "attributeTypes");
#endif

    }
    if ((*p252) != NULLPE)
        if (set_add ((*pe), (*p252)) == NOTOK) {
            advise (NULLCP, "EntryInfoSEL %s%s", PEPY_ERR_BAD_SET,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }
    (*p252) = NULLPE;

    if (parm->eis_infotypes != 1) {
        register integer p256 = parm->eis_infotypes;

        if (((*p252) = num2prim (p256, PE_CLASS_UNIV, PE_PRIM_INT)) == NULLPE) {
            advise (NULLCP, "infoTypes: %s", PEPY_ERR_NOMEM);
            return NOTOK;
        }
        switch (p256) {
            case 0:	/* attributeTypesOnly */
                break;
            case 1:	/* attributeTypesAndValues */
                break;
        }

#ifdef DEBUG
        (void) testdebug ((*p252), "infoTypes");
#endif

        {	/* infoTypes TAG PUSHDOWN */
            PE p257_z;
            register PE *p257 = &p257_z;

            if ((*p257 = pe_alloc (PE_CLASS_CONT, PE_FORM_CONS, 2)) == NULLPE) {
                advise (NULLCP, "infoTypes: %s", PEPY_ERR_NOMEM);
                return NOTOK;
            }
            (*p257) -> pe_cons = (*p252);
            (*p252) = *p257;
        }
    }
    if ((*p252) != NULLPE)
        if (set_add ((*pe), (*p252)) == NOTOK) {
            advise (NULLCP, "EntryInfoSEL %s%s", PEPY_ERR_BAD_SET,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }

#ifdef DEBUG
    (void) testdebug ((*pe), "STRONG.EntryInfoSEL");
#endif


    return OK;
}

/* ARGSUSED */

int	build_STRONG_SETOFEntryINFO (pe, explicit, len, buffer, parm)
PE     *pe;
int	explicit;
int	len;
char   *buffer;
SET_OF_EntryINFO * parm;
{
# line 1181 "STRONG.py"
    
	PE pe_enc = encode_STRONG_DER_SET_OF(parm, ENTRYINFOSET);
	
    PE	p258 = pe_enc ;

    if (p258 == NULLPE) {
        advise (NULLCP, "SETOFEntryINFO %s", PEPY_ERR_INIT_FAILED);
        return NOTOK;
    }
    ((*pe) = p258) -> pe_refcnt++;

#ifdef DEBUG
    (void) testdebug ((*pe), "STRONG.SETOFEntryINFO");
#endif

    {
# line 1186 "STRONG.py"

	pe_free(pe_enc);
	
    }

    return OK;
}

/* ARGSUSED */

int	build_STRONG_EntryINFO (pe, explicit, len, buffer, parm)
register PE     *pe;
int	explicit;
int	len;
char   *buffer;
EntryINFO * parm;
{
    PE	p259_z = NULLPE;
    register PE *p259 = &p259_z;

    if (((*pe) = pe_alloc (PE_CLASS_UNIV, PE_FORM_CONS, PE_CONS_SEQ)) == NULLPE) {
        advise (NULLCP, "EntryINFO: %s", PEPY_ERR_NOMEM);
        return NOTOK;
    }
    (*p259) = NULLPE;

    {	/* name */
        if (build_IF_Name (p259, 0, NULL, NULLCP, parm->ent_dn ) == NOTOK)
            return NOTOK;

#ifdef DEBUG
        (void) testdebug ((*p259), "name");
#endif

    }

    if ((*p259) != NULLPE)
        if (seq_add ((*pe), (*p259), -1) == NOTOK) {
            advise (NULLCP, "EntryINFO %s%s", PEPY_ERR_BAD_SEQ,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }
    (*p259) = NULLPE;

    if (parm->ent_fromentry != TRUE) {	/* fromEntry */
        register int p260 = parm->ent_fromentry;

        if (((*p259) = flag2prim (p260, PE_CLASS_UNIV, PE_PRIM_BOOL)) == NULLPE) {
            advise (NULLCP, "fromEntry: %s", PEPY_ERR_NOMEM);
            return NOTOK;
        }

#ifdef DEBUG
        (void) testdebug ((*p259), "fromEntry");
#endif

    }

    if ((*p259) != NULLPE)
        if (seq_add ((*pe), (*p259), -1) == NOTOK) {
            advise (NULLCP, "EntryINFO %s%s", PEPY_ERR_BAD_SEQ,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }
    (*p259) = NULLPE;

    if (parm->ent_attr) {
        if (build_STRONG_SETOFAttrAttrTypeCHOICE (p259, 0, NULL, NULLCP, parm->ent_attr) == NOTOK)
            return NOTOK;

#ifdef DEBUG
        (void) testdebug ((*p259), "element");
#endif

    }

    if ((*p259) != NULLPE)
        if (seq_add ((*pe), (*p259), -1) == NOTOK) {
            advise (NULLCP, "EntryINFO %s%s", PEPY_ERR_BAD_SEQ,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }

#ifdef DEBUG
    (void) testdebug ((*pe), "STRONG.EntryINFO");
#endif


    return OK;
}

/* ARGSUSED */

int	build_STRONG_StringsCHOICE (pe, explicit, len, buffer, parm)
register PE     *pe;
int	explicit;
int	len;
char   *buffer;
StringsCHOICE * parm;
{
    int	p261;

    switch (p261 = ( parm->strings_type )) {
        case 1:	/* initial */
            {
                PE	p262 = parm->strings_un.initial ;

                if (p262 == NULLPE) {
                    advise (NULLCP, "initial %s", PEPY_ERR_INIT_FAILED);
                    return NOTOK;
                }
                ((*pe) = p262) -> pe_refcnt++;

#ifdef DEBUG
                (void) testdebug ((*pe), "initial");
#endif

                {	/* initial TAG PUSHDOWN */
                    PE p263_z;
                    register PE *p263 = &p263_z;

                    if ((*p263 = pe_alloc (PE_CLASS_CONT, PE_FORM_CONS, 0)) == NULLPE) {
                        advise (NULLCP, "initial: %s", PEPY_ERR_NOMEM);
                        return NOTOK;
                    }
                    (*p263) -> pe_cons = (*pe);
                    (*pe) = *p263;
                }
            }
            break;
        case 2:	/* any */
            {
                PE	p264 = parm->strings_un.any ;

                if (p264 == NULLPE) {
                    advise (NULLCP, "any %s", PEPY_ERR_INIT_FAILED);
                    return NOTOK;
                }
                ((*pe) = p264) -> pe_refcnt++;

#ifdef DEBUG
                (void) testdebug ((*pe), "any");
#endif

                {	/* any TAG PUSHDOWN */
                    PE p265_z;
                    register PE *p265 = &p265_z;

                    if ((*p265 = pe_alloc (PE_CLASS_CONT, PE_FORM_CONS, 1)) == NULLPE) {
                        advise (NULLCP, "any: %s", PEPY_ERR_NOMEM);
                        return NOTOK;
                    }
                    (*p265) -> pe_cons = (*pe);
                    (*pe) = *p265;
                }
            }
            break;
        case 3:	/* final */
            {
                PE	p266 = parm->strings_un.final ;

                if (p266 == NULLPE) {
                    advise (NULLCP, "final %s", PEPY_ERR_INIT_FAILED);
                    return NOTOK;
                }
                ((*pe) = p266) -> pe_refcnt++;

#ifdef DEBUG
                (void) testdebug ((*pe), "final");
#endif

                {	/* final TAG PUSHDOWN */
                    PE p267_z;
                    register PE *p267 = &p267_z;

                    if ((*p267 = pe_alloc (PE_CLASS_CONT, PE_FORM_CONS, 2)) == NULLPE) {
                        advise (NULLCP, "final: %s", PEPY_ERR_NOMEM);
                        return NOTOK;
                    }
                    (*p267) -> pe_cons = (*pe);
                    (*pe) = *p267;
                }
            }
            break;

        default:
            advise (NULLCP, "StringsCHOICE %s%d", PEPY_ERR_INVALID_CHOICE, 
                    p261);
            return NOTOK;
    }

#ifdef DEBUG
    (void) testdebug ((*pe), "STRONG.StringsCHOICE");
#endif


    return OK;
}

/* ARGSUSED */

int	build_STRONG_SEQUENCEOFStringsCHOICE (pe, explicit, len, buffer, parm)
register PE     *pe;
int	explicit;
int	len;
char   *buffer;
SEQUENCE_OF_StringsCHOICE * parm;
{
    PE	p268 = NULLPE;
    PE	p269_z = NULLPE;
    register PE *p269 = &p269_z;

    if (((*pe) = pe_alloc (PE_CLASS_UNIV, PE_FORM_CONS, PE_CONS_SEQ)) == NULLPE) {
        advise (NULLCP, "SEQUENCEOFStringsCHOICE: %s", PEPY_ERR_NOMEM);
        return NOTOK;
    }
    for (; parm; parm = parm->next) {
        if (build_STRONG_StringsCHOICE (p269, 0, NULL, NULLCP, parm->element ) == NOTOK)
            return NOTOK;

#ifdef DEBUG
        (void) testdebug ((*p269), "element");
#endif

        (void) seq_addon ((*pe), p268, (*p269));
        p268 = (*p269);
    }

#ifdef DEBUG
    (void) testdebug ((*pe), "STRONG.SEQUENCEOFStringsCHOICE");
#endif


    return OK;
}

/* ARGSUSED */

int	build_STRONG_FilterSubstrings (pe, explicit, len, buffer, parm)
register PE     *pe;
int	explicit;
int	len;
char   *buffer;
SFilterSubstrings * parm;
{
    PE	p270_z = NULLPE;
    register PE *p270 = &p270_z;

    if (((*pe) = pe_alloc (PE_CLASS_UNIV, PE_FORM_CONS, PE_CONS_SEQ)) == NULLPE) {
        advise (NULLCP, "FilterSubstrings: %s", PEPY_ERR_NOMEM);
        return NOTOK;
    }
    (*p270) = NULLPE;

    {	/* type */
        register OID p271;

        p271 = parm->type;
        if (p271 == NULLOID) {
            advise (NULLCP, "type %s", PEPY_ERR_INIT_FAILED);
            return NOTOK;
        }
        if (((*p270) = obj2prim (p271, PE_CLASS_UNIV, PE_PRIM_OID)) == NULLPE) {
            advise (NULLCP, "type: %s", PEPY_ERR_NOMEM);
            return NOTOK;
        }

#ifdef DEBUG
        (void) testdebug ((*p270), "type");
#endif

    }

    if ((*p270) != NULLPE)
        if (seq_add ((*pe), (*p270), -1) == NOTOK) {
            advise (NULLCP, "FilterSubstrings %s%s", PEPY_ERR_BAD_SEQ,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }
    (*p270) = NULLPE;

    {	/* strings */
        if (build_STRONG_SEQUENCEOFStringsCHOICE (p270, 0, NULL, NULLCP, parm->seq ) == NOTOK)
            return NOTOK;

#ifdef DEBUG
        (void) testdebug ((*p270), "strings");
#endif

    }

    if ((*p270) != NULLPE)
        if (seq_add ((*pe), (*p270), -1) == NOTOK) {
            advise (NULLCP, "FilterSubstrings %s%s", PEPY_ERR_BAD_SEQ,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }

#ifdef DEBUG
    (void) testdebug ((*pe), "STRONG.FilterSubstrings");
#endif


    return OK;
}

/* ARGSUSED */

int	build_STRONG_FilterItem (pe, explicit, len, buffer, parm)
register PE     *pe;
int	explicit;
int	len;
char   *buffer;
SFilterItem * parm;
{
    int	p272;

    switch (p272 = ( parm->fi_type )) {
        case 1:	/* equality */
            {
                if (build_IF_AttributeValueAssertion (pe, 0, NULL, NULLCP, parm->fi_un.fi_un_ava) == NOTOK)
                    return NOTOK;

#ifdef DEBUG
                (void) testdebug ((*pe), "equality");
#endif

                {	/* equality TAG PUSHDOWN */
                    PE p273_z;
                    register PE *p273 = &p273_z;

                    if ((*p273 = pe_alloc (PE_CLASS_CONT, PE_FORM_CONS, 0)) == NULLPE) {
                        advise (NULLCP, "equality: %s", PEPY_ERR_NOMEM);
                        return NOTOK;
                    }
                    (*p273) -> pe_cons = (*pe);
                    (*pe) = *p273;
                }
            }
            break;
        case 2:	/* substrings */
            {
                if (build_STRONG_FilterSubstrings (pe, 0, NULL, NULLCP, parm->fi_un.fi_un_substrings) == NOTOK)
                    return NOTOK;

#ifdef DEBUG
                (void) testdebug ((*pe), "substrings");
#endif

                {	/* substrings TAG PUSHDOWN */
                    PE p274_z;
                    register PE *p274 = &p274_z;

                    if ((*p274 = pe_alloc (PE_CLASS_CONT, PE_FORM_CONS, 1)) == NULLPE) {
                        advise (NULLCP, "substrings: %s", PEPY_ERR_NOMEM);
                        return NOTOK;
                    }
                    (*p274) -> pe_cons = (*pe);
                    (*pe) = *p274;
                }
            }
            break;
        case 3:	/* greaterOrEqual */
            {
                if (build_IF_AttributeValueAssertion (pe, 0, NULL, NULLCP, parm->fi_un.fi_un_ava) == NOTOK)
                    return NOTOK;

#ifdef DEBUG
                (void) testdebug ((*pe), "greaterOrEqual");
#endif

                {	/* greaterOrEqual TAG PUSHDOWN */
                    PE p275_z;
                    register PE *p275 = &p275_z;

                    if ((*p275 = pe_alloc (PE_CLASS_CONT, PE_FORM_CONS, 2)) == NULLPE) {
                        advise (NULLCP, "greaterOrEqual: %s", PEPY_ERR_NOMEM);
                        return NOTOK;
                    }
                    (*p275) -> pe_cons = (*pe);
                    (*pe) = *p275;
                }
            }
            break;
        case 4:	/* lessOrEqual */
            {
                if (build_IF_AttributeValueAssertion (pe, 0, NULL, NULLCP, parm->fi_un.fi_un_ava) == NOTOK)
                    return NOTOK;

#ifdef DEBUG
                (void) testdebug ((*pe), "lessOrEqual");
#endif

                {	/* lessOrEqual TAG PUSHDOWN */
                    PE p276_z;
                    register PE *p276 = &p276_z;

                    if ((*p276 = pe_alloc (PE_CLASS_CONT, PE_FORM_CONS, 3)) == NULLPE) {
                        advise (NULLCP, "lessOrEqual: %s", PEPY_ERR_NOMEM);
                        return NOTOK;
                    }
                    (*p276) -> pe_cons = (*pe);
                    (*pe) = *p276;
                }
            }
            break;
        case 5:	/* present */
            {
                register OID p277;

                p277 = parm->fi_un.fi_un_type;
                if (p277 == NULLOID) {
                    advise (NULLCP, "present %s", PEPY_ERR_INIT_FAILED);
                    return NOTOK;
                }
                if (((*pe) = obj2prim (p277, PE_CLASS_UNIV, PE_PRIM_OID)) == NULLPE) {
                    advise (NULLCP, "present: %s", PEPY_ERR_NOMEM);
                    return NOTOK;
                }

#ifdef DEBUG
                (void) testdebug ((*pe), "present");
#endif

                {	/* present TAG PUSHDOWN */
                    PE p278_z;
                    register PE *p278 = &p278_z;

                    if ((*p278 = pe_alloc (PE_CLASS_CONT, PE_FORM_CONS, 4)) == NULLPE) {
                        advise (NULLCP, "present: %s", PEPY_ERR_NOMEM);
                        return NOTOK;
                    }
                    (*p278) -> pe_cons = (*pe);
                    (*pe) = *p278;
                }
            }
            break;
        case 6:	/* approximateMatch */
            {
                if (build_IF_AttributeValueAssertion (pe, 0, NULL, NULLCP, parm->fi_un.fi_un_ava) == NOTOK)
                    return NOTOK;

#ifdef DEBUG
                (void) testdebug ((*pe), "approximateMatch");
#endif

                {	/* approximateMatch TAG PUSHDOWN */
                    PE p279_z;
                    register PE *p279 = &p279_z;

                    if ((*p279 = pe_alloc (PE_CLASS_CONT, PE_FORM_CONS, 5)) == NULLPE) {
                        advise (NULLCP, "approximateMatch: %s", PEPY_ERR_NOMEM);
                        return NOTOK;
                    }
                    (*p279) -> pe_cons = (*pe);
                    (*pe) = *p279;
                }
            }
            break;

        default:
            advise (NULLCP, "FilterItem %s%d", PEPY_ERR_INVALID_CHOICE, 
                    p272);
            return NOTOK;
    }

#ifdef DEBUG
    (void) testdebug ((*pe), "STRONG.FilterItem");
#endif


    return OK;
}

/* ARGSUSED */

int	build_STRONG_SETOFFilter (pe, explicit, len, buffer, parm)
PE     *pe;
int	explicit;
int	len;
char   *buffer;
SET_OF_SFilter * parm;
{
# line 1278 "STRONG.py"
    
	PE pe_enc = encode_STRONG_DER_SET_OF(parm, FILTERSET);
	
    PE	p280 = pe_enc ;

    if (p280 == NULLPE) {
        advise (NULLCP, "SETOFFilter %s", PEPY_ERR_INIT_FAILED);
        return NOTOK;
    }
    ((*pe) = p280) -> pe_refcnt++;

#ifdef DEBUG
    (void) testdebug ((*pe), "STRONG.SETOFFilter");
#endif

    {
# line 1283 "STRONG.py"

	pe_free(pe_enc);
	
    }

    return OK;
}

/* ARGSUSED */

int	build_STRONG_Filter (pe, explicit, len, buffer, parm)
register PE     *pe;
int	explicit;
int	len;
char   *buffer;
SFilter * parm;
{
    int	p281;

    switch (p281 = ( parm->flt_type )) {
        case 1:	/* item */
            {
                if (build_STRONG_FilterItem (pe, 0, NULL, NULLCP, parm->flt_un.flt_un_item) == NOTOK)
                    return NOTOK;

#ifdef DEBUG
                (void) testdebug ((*pe), "item");
#endif

                {	/* item TAG PUSHDOWN */
                    PE p282_z;
                    register PE *p282 = &p282_z;

                    if ((*p282 = pe_alloc (PE_CLASS_CONT, PE_FORM_CONS, 0)) == NULLPE) {
                        advise (NULLCP, "item: %s", PEPY_ERR_NOMEM);
                        return NOTOK;
                    }
                    (*p282) -> pe_cons = (*pe);
                    (*pe) = *p282;
                }
            }
            break;
        case 2:	/* and */
            {
                if (build_STRONG_SETOFFilter (pe, 0, NULL, NULLCP, parm->flt_un.flt_un_filter ) == NOTOK)
                    return NOTOK;

#ifdef DEBUG
                (void) testdebug ((*pe), "and");
#endif

                {	/* and TAG PUSHDOWN */
                    PE p283_z;
                    register PE *p283 = &p283_z;

                    if ((*p283 = pe_alloc (PE_CLASS_CONT, PE_FORM_CONS, 1)) == NULLPE) {
                        advise (NULLCP, "and: %s", PEPY_ERR_NOMEM);
                        return NOTOK;
                    }
                    (*p283) -> pe_cons = (*pe);
                    (*pe) = *p283;
                }
            }
            break;
        case 3:	/* or */
            {
                if (build_STRONG_SETOFFilter (pe, 0, NULL, NULLCP, parm->flt_un.flt_un_filter ) == NOTOK)
                    return NOTOK;

#ifdef DEBUG
                (void) testdebug ((*pe), "or");
#endif

                {	/* or TAG PUSHDOWN */
                    PE p284_z;
                    register PE *p284 = &p284_z;

                    if ((*p284 = pe_alloc (PE_CLASS_CONT, PE_FORM_CONS, 2)) == NULLPE) {
                        advise (NULLCP, "or: %s", PEPY_ERR_NOMEM);
                        return NOTOK;
                    }
                    (*p284) -> pe_cons = (*pe);
                    (*pe) = *p284;
                }
            }
            break;
        case 4:	/* not */
            {
                if (build_STRONG_Filter (pe, 0, NULL, NULLCP, parm->flt_un.flt_un_filter) == NOTOK)
                    return NOTOK;

#ifdef DEBUG
                (void) testdebug ((*pe), "not");
#endif

                {	/* not TAG PUSHDOWN */
                    PE p285_z;
                    register PE *p285 = &p285_z;

                    if ((*p285 = pe_alloc (PE_CLASS_CONT, PE_FORM_CONS, 3)) == NULLPE) {
                        advise (NULLCP, "not: %s", PEPY_ERR_NOMEM);
                        return NOTOK;
                    }
                    (*p285) -> pe_cons = (*pe);
                    (*pe) = *p285;
                }
            }
            break;

        default:
            advise (NULLCP, "Filter %s%d", PEPY_ERR_INVALID_CHOICE, 
                    p281);
            return NOTOK;
    }

#ifdef DEBUG
    (void) testdebug ((*pe), "STRONG.Filter");
#endif


    return OK;
}

/* ARGSUSED */

int	build_STRONG_SETOFSubordEntry (pe, explicit, len, buffer, parm)
PE     *pe;
int	explicit;
int	len;
char   *buffer;
SET_OF_SubordEntry * parm;
{
# line 1315 "STRONG.py"
    
	PE pe_enc = encode_STRONG_DER_SET_OF(parm, SUBORDENTRYSET);
	
    PE	p286 = pe_enc ;

    if (p286 == NULLPE) {
        advise (NULLCP, "SETOFSubordEntry %s", PEPY_ERR_INIT_FAILED);
        return NOTOK;
    }
    ((*pe) = p286) -> pe_refcnt++;

#ifdef DEBUG
    (void) testdebug ((*pe), "STRONG.SETOFSubordEntry");
#endif

    {
# line 1320 "STRONG.py"

	pe_free(pe_enc);
	
    }

    return OK;
}

/* ARGSUSED */

int	build_STRONG_SubordEntry (pe, explicit, len, buffer, parm)
register PE     *pe;
int	explicit;
int	len;
char   *buffer;
SubordEntry * parm;
{
    PE	p287_z = NULLPE;
    register PE *p287 = &p287_z;

    if (((*pe) = pe_alloc (PE_CLASS_UNIV, PE_FORM_CONS, PE_CONS_SEQ)) == NULLPE) {
        advise (NULLCP, "SubordEntry: %s", PEPY_ERR_NOMEM);
        return NOTOK;
    }
    (*p287) = NULLPE;

    {
        if (build_IF_RelativeDistinguishedName (p287, 0, NULL, NULLCP, parm->sub_rdn) == NOTOK)
            return NOTOK;

#ifdef DEBUG
        (void) testdebug ((*p287), "element");
#endif

    }

    if ((*p287) != NULLPE)
        if (seq_add ((*pe), (*p287), -1) == NOTOK) {
            advise (NULLCP, "SubordEntry %s%s", PEPY_ERR_BAD_SEQ,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }
    (*p287) = NULLPE;

    if (parm->sub_aliasentry) {	/* aliasEntry */
        register int p288 = parm->sub_aliasentry;

        if (((*p287) = flag2prim (p288, PE_CLASS_UNIV, PE_PRIM_BOOL)) == NULLPE) {
            advise (NULLCP, "aliasEntry: %s", PEPY_ERR_NOMEM);
            return NOTOK;
        }
        {	/* aliasEntry TAG PUSHDOWN */
            PE p289_z;
            register PE *p289 = &p289_z;

            if ((*p289 = pe_alloc (PE_CLASS_CONT, PE_FORM_CONS, 0)) == NULLPE) {
                advise (NULLCP, "aliasEntry: %s", PEPY_ERR_NOMEM);
                return NOTOK;
            }
            (*p289) -> pe_cons = (*p287);
            (*p287) = *p289;
        }

#ifdef DEBUG
        (void) testdebug ((*p287), "aliasEntry");
#endif

    }

    if ((*p287) != NULLPE)
        if (seq_add ((*pe), (*p287), -1) == NOTOK) {
            advise (NULLCP, "SubordEntry %s%s", PEPY_ERR_BAD_SEQ,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }
    (*p287) = NULLPE;

    if (parm->sub_copy != TRUE) {	/* fromEntry */
        register int p290 = parm->sub_copy;

        if (((*p287) = flag2prim (p290, PE_CLASS_UNIV, PE_PRIM_BOOL)) == NULLPE) {
            advise (NULLCP, "fromEntry: %s", PEPY_ERR_NOMEM);
            return NOTOK;
        }
        {	/* fromEntry TAG PUSHDOWN */
            PE p291_z;
            register PE *p291 = &p291_z;

            if ((*p291 = pe_alloc (PE_CLASS_CONT, PE_FORM_CONS, 1)) == NULLPE) {
                advise (NULLCP, "fromEntry: %s", PEPY_ERR_NOMEM);
                return NOTOK;
            }
            (*p291) -> pe_cons = (*p287);
            (*p287) = *p291;
        }

#ifdef DEBUG
        (void) testdebug ((*p287), "fromEntry");
#endif

    }

    if ((*p287) != NULLPE)
        if (seq_add ((*pe), (*p287), -1) == NOTOK) {
            advise (NULLCP, "SubordEntry %s%s", PEPY_ERR_BAD_SEQ,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }

#ifdef DEBUG
    (void) testdebug ((*pe), "STRONG.SubordEntry");
#endif


    return OK;
}

/* ARGSUSED */

int	build_STRONG_ListInfo (pe, explicit, len, buffer, parm)
register PE     *pe;
int	explicit;
int	len;
char   *buffer;
ListInfo * parm;
{
    PE	p292_z = NULLPE;
    register PE *p292 = &p292_z;

    if (((*pe) = pe_alloc (PE_CLASS_UNIV, PE_FORM_CONS, PE_CONS_SET)) == NULLPE) {
        advise (NULLCP, "ListInfo: %s", PEPY_ERR_NOMEM);
        return NOTOK;
    }
    (*p292) = NULLPE;

    if (parm->lsr_object) {
        if (build_IF_Name (p292, 0, NULL, NULLCP, parm->lsr_object) == NOTOK)
            return NOTOK;
        (*p292) -> pe_class = PE_CLASS_UNIV;
        (*p292) -> pe_id = 16;

#ifdef DEBUG
        (void) testdebug ((*p292), "member");
#endif

    }
    if ((*p292) != NULLPE)
        if (set_add ((*pe), (*p292)) == NOTOK) {
            advise (NULLCP, "ListInfo %s%s", PEPY_ERR_BAD_SET,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }
    (*p292) = NULLPE;

    {
        if (build_STRONG_SETOFSubordEntry (p292, 0, NULL, NULLCP, parm->lsr_subordinates) == NOTOK)
            return NOTOK;

#ifdef DEBUG
        (void) testdebug ((*p292), "subordinates");
#endif

        {	/* subordinates TAG PUSHDOWN */
            PE p293_z;
            register PE *p293 = &p293_z;

            if ((*p293 = pe_alloc (PE_CLASS_CONT, PE_FORM_CONS, 1)) == NULLPE) {
                advise (NULLCP, "subordinates: %s", PEPY_ERR_NOMEM);
                return NOTOK;
            }
            (*p293) -> pe_cons = (*p292);
            (*p292) = *p293;
        }
    }
    if ((*p292) != NULLPE)
        if (set_add ((*pe), (*p292)) == NOTOK) {
            advise (NULLCP, "ListInfo %s%s", PEPY_ERR_BAD_SET,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }
    (*p292) = NULLPE;

    if (
			  (parm->lsr_poq &&
			   ( ((parm->lsr_poq->poq_limitproblem != LSR_NOLIMITPROBLEM) || 
			      (parm->lsr_poq->poq_cref != (SET_OF_ContReference * )0)) ) )
			 ) {
        if (build_STRONG_PartialOutcomeQualifier (p292, 0, NULL, NULLCP, parm->lsr_poq) == NOTOK)
            return NOTOK;

#ifdef DEBUG
        (void) testdebug ((*p292), "partialOutcomeQualifier");
#endif

        {	/* partialOutcomeQualifier TAG PUSHDOWN */
            PE p294_z;
            register PE *p294 = &p294_z;

            if ((*p294 = pe_alloc (PE_CLASS_CONT, PE_FORM_CONS, 2)) == NULLPE) {
                advise (NULLCP, "partialOutcomeQualifier: %s", PEPY_ERR_NOMEM);
                return NOTOK;
            }
            (*p294) -> pe_cons = (*p292);
            (*p292) = *p294;
        }
    }
    if ((*p292) != NULLPE)
        if (set_add ((*pe), (*p292)) == NOTOK) {
            advise (NULLCP, "ListInfo %s%s", PEPY_ERR_BAD_SET,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }
    (*p292) = NULLPE;

    if (parm->lsr_common->aliasDereferenced) {
        register int p295 = parm->lsr_common->aliasDereferenced;

        if (((*p292) = flag2prim (p295, PE_CLASS_UNIV, PE_PRIM_BOOL)) == NULLPE) {
            advise (NULLCP, "aliasDereferenced: %s", PEPY_ERR_NOMEM);
            return NOTOK;
        }

#ifdef DEBUG
        (void) testdebug ((*p292), "aliasDereferenced");
#endif

        {	/* aliasDereferenced TAG PUSHDOWN */
            PE p296_z;
            register PE *p296 = &p296_z;

            if ((*p296 = pe_alloc (PE_CLASS_CONT, PE_FORM_CONS, 28)) == NULLPE) {
                advise (NULLCP, "aliasDereferenced: %s", PEPY_ERR_NOMEM);
                return NOTOK;
            }
            (*p296) -> pe_cons = (*p292);
            (*p292) = *p296;
        }
    }
    if ((*p292) != NULLPE)
        if (set_add ((*pe), (*p292)) == NOTOK) {
            advise (NULLCP, "ListInfo %s%s", PEPY_ERR_BAD_SET,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }
    (*p292) = NULLPE;

    if (parm->lsr_common->performer) {
        if (build_IF_Name (p292, 0, NULL, NULLCP, parm->lsr_common->performer ) == NOTOK)
            return NOTOK;

#ifdef DEBUG
        (void) testdebug ((*p292), "performer");
#endif

        {	/* performer TAG PUSHDOWN */
            PE p297_z;
            register PE *p297 = &p297_z;

            if ((*p297 = pe_alloc (PE_CLASS_CONT, PE_FORM_CONS, 29)) == NULLPE) {
                advise (NULLCP, "performer: %s", PEPY_ERR_NOMEM);
                return NOTOK;
            }
            (*p297) -> pe_cons = (*p292);
            (*p292) = *p297;
        }
    }
    if ((*p292) != NULLPE)
        if (set_add ((*pe), (*p292)) == NOTOK) {
            advise (NULLCP, "ListInfo %s%s", PEPY_ERR_BAD_SET,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }
    (*p292) = NULLPE;

    if (parm->lsr_common->sec_parm) {
        if (build_STRONG_SecurityParameters (p292, 0, NULL, NULLCP, parm->lsr_common->sec_parm ) == NOTOK)
            return NOTOK;

#ifdef DEBUG
        (void) testdebug ((*p292), "secparm");
#endif

        {	/* secparm TAG PUSHDOWN */
            PE p298_z;
            register PE *p298 = &p298_z;

            if ((*p298 = pe_alloc (PE_CLASS_CONT, PE_FORM_CONS, 30)) == NULLPE) {
                advise (NULLCP, "secparm: %s", PEPY_ERR_NOMEM);
                return NOTOK;
            }
            (*p298) -> pe_cons = (*p292);
            (*p292) = *p298;
        }
    }
    if ((*p292) != NULLPE)
        if (set_add ((*pe), (*p292)) == NOTOK) {
            advise (NULLCP, "ListInfo %s%s", PEPY_ERR_BAD_SET,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }

#ifdef DEBUG
    (void) testdebug ((*pe), "STRONG.ListInfo");
#endif


    return OK;
}

/* ARGSUSED */

int	build_STRONG_SearchInfo (pe, explicit, len, buffer, parm)
register PE     *pe;
int	explicit;
int	len;
char   *buffer;
SearchInfo * parm;
{
    PE	p299_z = NULLPE;
    register PE *p299 = &p299_z;

    if (((*pe) = pe_alloc (PE_CLASS_UNIV, PE_FORM_CONS, PE_CONS_SET)) == NULLPE) {
        advise (NULLCP, "SearchInfo: %s", PEPY_ERR_NOMEM);
        return NOTOK;
    }
    (*p299) = NULLPE;

    if (parm->srr_object) {
        if (build_IF_Name (p299, 0, NULL, NULLCP, parm->srr_object) == NOTOK)
            return NOTOK;
        (*p299) -> pe_class = PE_CLASS_UNIV;
        (*p299) -> pe_id = 16;

#ifdef DEBUG
        (void) testdebug ((*p299), "member");
#endif

    }
    if ((*p299) != NULLPE)
        if (set_add ((*pe), (*p299)) == NOTOK) {
            advise (NULLCP, "SearchInfo %s%s", PEPY_ERR_BAD_SET,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }
    (*p299) = NULLPE;

    {
        if (build_STRONG_SETOFEntryINFO (p299, 0, NULL, NULLCP, parm->srr_entries) == NOTOK)
            return NOTOK;

#ifdef DEBUG
        (void) testdebug ((*p299), "entries");
#endif

        {	/* entries TAG PUSHDOWN */
            PE p300_z;
            register PE *p300 = &p300_z;

            if ((*p300 = pe_alloc (PE_CLASS_CONT, PE_FORM_CONS, 0)) == NULLPE) {
                advise (NULLCP, "entries: %s", PEPY_ERR_NOMEM);
                return NOTOK;
            }
            (*p300) -> pe_cons = (*p299);
            (*p299) = *p300;
        }
    }
    if ((*p299) != NULLPE)
        if (set_add ((*pe), (*p299)) == NOTOK) {
            advise (NULLCP, "SearchInfo %s%s", PEPY_ERR_BAD_SET,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }
    (*p299) = NULLPE;

    if (
			  (parm->srr_poq &&
			   ( ((parm->srr_poq->poq_limitproblem != LSR_NOLIMITPROBLEM) || 
			   (parm->srr_poq->poq_cref != (SET_OF_ContReference * )0)) ) )
			 ) {
        if (build_STRONG_PartialOutcomeQualifier (p299, 0, NULL, NULLCP, parm->srr_poq) == NOTOK)
            return NOTOK;

#ifdef DEBUG
        (void) testdebug ((*p299), "partialOutcomeQualifier");
#endif

        {	/* partialOutcomeQualifier TAG PUSHDOWN */
            PE p301_z;
            register PE *p301 = &p301_z;

            if ((*p301 = pe_alloc (PE_CLASS_CONT, PE_FORM_CONS, 2)) == NULLPE) {
                advise (NULLCP, "partialOutcomeQualifier: %s", PEPY_ERR_NOMEM);
                return NOTOK;
            }
            (*p301) -> pe_cons = (*p299);
            (*p299) = *p301;
        }
    }
    if ((*p299) != NULLPE)
        if (set_add ((*pe), (*p299)) == NOTOK) {
            advise (NULLCP, "SearchInfo %s%s", PEPY_ERR_BAD_SET,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }
    (*p299) = NULLPE;

    if (parm->srr_common->aliasDereferenced) {
        register int p302 = parm->srr_common->aliasDereferenced;

        if (((*p299) = flag2prim (p302, PE_CLASS_UNIV, PE_PRIM_BOOL)) == NULLPE) {
            advise (NULLCP, "aliasDereferenced: %s", PEPY_ERR_NOMEM);
            return NOTOK;
        }

#ifdef DEBUG
        (void) testdebug ((*p299), "aliasDereferenced");
#endif

        {	/* aliasDereferenced TAG PUSHDOWN */
            PE p303_z;
            register PE *p303 = &p303_z;

            if ((*p303 = pe_alloc (PE_CLASS_CONT, PE_FORM_CONS, 28)) == NULLPE) {
                advise (NULLCP, "aliasDereferenced: %s", PEPY_ERR_NOMEM);
                return NOTOK;
            }
            (*p303) -> pe_cons = (*p299);
            (*p299) = *p303;
        }
    }
    if ((*p299) != NULLPE)
        if (set_add ((*pe), (*p299)) == NOTOK) {
            advise (NULLCP, "SearchInfo %s%s", PEPY_ERR_BAD_SET,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }
    (*p299) = NULLPE;

    if (parm->srr_common->performer) {
        if (build_IF_Name (p299, 0, NULL, NULLCP, parm->srr_common->performer ) == NOTOK)
            return NOTOK;

#ifdef DEBUG
        (void) testdebug ((*p299), "performer");
#endif

        {	/* performer TAG PUSHDOWN */
            PE p304_z;
            register PE *p304 = &p304_z;

            if ((*p304 = pe_alloc (PE_CLASS_CONT, PE_FORM_CONS, 29)) == NULLPE) {
                advise (NULLCP, "performer: %s", PEPY_ERR_NOMEM);
                return NOTOK;
            }
            (*p304) -> pe_cons = (*p299);
            (*p299) = *p304;
        }
    }
    if ((*p299) != NULLPE)
        if (set_add ((*pe), (*p299)) == NOTOK) {
            advise (NULLCP, "SearchInfo %s%s", PEPY_ERR_BAD_SET,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }
    (*p299) = NULLPE;

    if (parm->srr_common->sec_parm) {
        if (build_STRONG_SecurityParameters (p299, 0, NULL, NULLCP, parm->srr_common->sec_parm ) == NOTOK)
            return NOTOK;

#ifdef DEBUG
        (void) testdebug ((*p299), "secparm");
#endif

        {	/* secparm TAG PUSHDOWN */
            PE p305_z;
            register PE *p305 = &p305_z;

            if ((*p305 = pe_alloc (PE_CLASS_CONT, PE_FORM_CONS, 30)) == NULLPE) {
                advise (NULLCP, "secparm: %s", PEPY_ERR_NOMEM);
                return NOTOK;
            }
            (*p305) -> pe_cons = (*p299);
            (*p299) = *p305;
        }
    }
    if ((*p299) != NULLPE)
        if (set_add ((*pe), (*p299)) == NOTOK) {
            advise (NULLCP, "SearchInfo %s%s", PEPY_ERR_BAD_SET,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }

#ifdef DEBUG
    (void) testdebug ((*pe), "STRONG.SearchInfo");
#endif


    return OK;
}

/* ARGSUSED */

int	build_STRONG_SETOFObjId (pe, explicit, len, buffer, parm)
PE     *pe;
int	explicit;
int	len;
char   *buffer;
SET_OF_ObjId * parm;
{
# line 1422 "STRONG.py"
    
	PE pe_enc = encode_STRONG_DER_SET_OF(parm, OBJIDSET);
	
    PE	p306 = pe_enc ;

    if (p306 == NULLPE) {
        advise (NULLCP, "SETOFObjId %s", PEPY_ERR_INIT_FAILED);
        return NOTOK;
    }
    ((*pe) = p306) -> pe_refcnt++;

#ifdef DEBUG
    (void) testdebug ((*pe), "STRONG.SETOFObjId");
#endif

    {
# line 1427 "STRONG.py"

	pe_free(pe_enc);
	
    }

    return OK;
}

/* ARGSUSED */

int	build_STRONG_SETOFDName (pe, explicit, len, buffer, parm)
PE     *pe;
int	explicit;
int	len;
char   *buffer;
SET_OF_DName * parm;
{
# line 1440 "STRONG.py"
    
	PE pe_enc = encode_STRONG_DER_SET_OF(parm, DNAMESET);
	
    PE	p307 = pe_enc ;

    if (p307 == NULLPE) {
        advise (NULLCP, "SETOFDName %s", PEPY_ERR_INIT_FAILED);
        return NOTOK;
    }
    ((*pe) = p307) -> pe_refcnt++;

#ifdef DEBUG
    (void) testdebug ((*pe), "STRONG.SETOFDName");
#endif

    {
# line 1445 "STRONG.py"

	pe_free(pe_enc);
	
    }

    return OK;
}

/* ARGSUSED */

int	build_STRONG_AccessSelector (pe, explicit, len, buffer, parm)
register PE     *pe;
int	explicit;
int	len;
char   *buffer;
aclInfo * parm;
{
    int	p308;

    switch (p308 = (parm->acl_selector_type)) {
        case 1:	/* entry */
            {
                if (((*pe) = pe_alloc (PE_CLASS_UNIV, PE_FORM_PRIM, PE_PRIM_NULL)) == NULLPE) {
                    advise (NULLCP, "entry: %s", PEPY_ERR_NOMEM);
                    return NOTOK;
                }

#ifdef DEBUG
                (void) testdebug ((*pe), "entry");
#endif

                {	/* entry TAG PUSHDOWN */
                    PE p309_z;
                    register PE *p309 = &p309_z;

                    if ((*p309 = pe_alloc (PE_CLASS_CONT, PE_FORM_CONS, 0)) == NULLPE) {
                        advise (NULLCP, "entry: %s", PEPY_ERR_NOMEM);
                        return NOTOK;
                    }
                    (*p309) -> pe_cons = (*pe);
                    (*pe) = *p309;
                }
            }
            break;
        case 2:	/* other */
            {
                if (((*pe) = pe_alloc (PE_CLASS_UNIV, PE_FORM_PRIM, PE_PRIM_NULL)) == NULLPE) {
                    advise (NULLCP, "other: %s", PEPY_ERR_NOMEM);
                    return NOTOK;
                }

#ifdef DEBUG
                (void) testdebug ((*pe), "other");
#endif

                {	/* other TAG PUSHDOWN */
                    PE p310_z;
                    register PE *p310 = &p310_z;

                    if ((*p310 = pe_alloc (PE_CLASS_CONT, PE_FORM_CONS, 2)) == NULLPE) {
                        advise (NULLCP, "other: %s", PEPY_ERR_NOMEM);
                        return NOTOK;
                    }
                    (*p310) -> pe_cons = (*pe);
                    (*pe) = *p310;
                }
            }
            break;
        case 3:	/* prefix */
            {
                if (build_STRONG_SETOFDName (pe, 0, NULL, NULLCP, parm->acl_name) == NOTOK)
                    return NOTOK;

#ifdef DEBUG
                (void) testdebug ((*pe), "prefix");
#endif

                {	/* prefix TAG PUSHDOWN */
                    PE p311_z;
                    register PE *p311 = &p311_z;

                    if ((*p311 = pe_alloc (PE_CLASS_CONT, PE_FORM_CONS, 3)) == NULLPE) {
                        advise (NULLCP, "prefix: %s", PEPY_ERR_NOMEM);
                        return NOTOK;
                    }
                    (*p311) -> pe_cons = (*pe);
                    (*pe) = *p311;
                }
            }
            break;
        case 4:	/* group */
            {
                if (build_STRONG_SETOFDName (pe, 0, NULL, NULLCP, parm->acl_name) == NOTOK)
                    return NOTOK;

#ifdef DEBUG
                (void) testdebug ((*pe), "group");
#endif

                {	/* group TAG PUSHDOWN */
                    PE p312_z;
                    register PE *p312 = &p312_z;

                    if ((*p312 = pe_alloc (PE_CLASS_CONT, PE_FORM_CONS, 4)) == NULLPE) {
                        advise (NULLCP, "group: %s", PEPY_ERR_NOMEM);
                        return NOTOK;
                    }
                    (*p312) -> pe_cons = (*pe);
                    (*pe) = *p312;
                }
            }
            break;

        default:
            advise (NULLCP, "AccessSelector %s%d", PEPY_ERR_INVALID_CHOICE, 
                    p308);
            return NOTOK;
    }

#ifdef DEBUG
    (void) testdebug ((*pe), "STRONG.AccessSelector");
#endif


    return OK;
}

/* ARGSUSED */

int	build_STRONG_AccessCategories (pe, explicit, len, buffer, parm)
register PE     *pe;
int	explicit;
int	len;
char   *buffer;
aclInfo * parm;
{
    register integer p313 = parm->acl_categories;

    if (((*pe) = enum2prim (p313, PE_CLASS_UNIV, PE_PRIM_ENUM)) == NULLPE) {
        advise (NULLCP, "AccessCategories: %s", PEPY_ERR_NOMEM);
        return NOTOK;
    }
    switch (p313) {
        case 0:	/* none */
            break;
        case 1:	/* detect */
            break;
        case 2:	/* compare */
            break;
        case 3:	/* read */
            break;
        case 4:	/* add */
            break;
        case 5:	/* write */
            break;
        default:
            advise (NULLCP, "AccessCategories %s%d", PEPY_ERR_UNK_COMP, p313);
            return NOTOK;
    }

#ifdef DEBUG
    (void) testdebug ((*pe), "STRONG.AccessCategories");
#endif


    return OK;
}

/* ARGSUSED */

int	build_STRONG_ACLInfo (pe, explicit, len, buffer, parm)
register PE     *pe;
int	explicit;
int	len;
char   *buffer;
aclInfo * parm;
{
    PE	p314_z = NULLPE;
    register PE *p314 = &p314_z;

    if (((*pe) = pe_alloc (PE_CLASS_UNIV, PE_FORM_CONS, PE_CONS_SEQ)) == NULLPE) {
        advise (NULLCP, "ACLInfo: %s", PEPY_ERR_NOMEM);
        return NOTOK;
    }
    (*p314) = NULLPE;

    {
        if (build_STRONG_AccessSelector (p314, 0, NULL, NULLCP, parm) == NOTOK)
            return NOTOK;

#ifdef DEBUG
        (void) testdebug ((*p314), "element");
#endif

    }

    if ((*p314) != NULLPE)
        if (seq_add ((*pe), (*p314), -1) == NOTOK) {
            advise (NULLCP, "ACLInfo %s%s", PEPY_ERR_BAD_SEQ,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }
    (*p314) = NULLPE;

    {
        if (build_STRONG_AccessCategories (p314, 0, NULL, NULLCP, parm) == NOTOK)
            return NOTOK;

#ifdef DEBUG
        (void) testdebug ((*p314), "element");
#endif

    }

    if ((*p314) != NULLPE)
        if (seq_add ((*pe), (*p314), -1) == NOTOK) {
            advise (NULLCP, "ACLInfo %s%s", PEPY_ERR_BAD_SEQ,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }

#ifdef DEBUG
    (void) testdebug ((*pe), "STRONG.ACLInfo");
#endif


    return OK;
}

/* ARGSUSED */

int	build_STRONG_SETOFACLInfo (pe, explicit, len, buffer, parm)
PE     *pe;
int	explicit;
int	len;
char   *buffer;
SET_OF_aclInfo * parm;
{
# line 1496 "STRONG.py"
    
	PE pe_enc = encode_STRONG_DER_SET_OF(parm, ACLINFOSET);
	
    PE	p315 = pe_enc ;

    if (p315 == NULLPE) {
        advise (NULLCP, "SETOFACLInfo %s", PEPY_ERR_INIT_FAILED);
        return NOTOK;
    }
    ((*pe) = p315) -> pe_refcnt++;

#ifdef DEBUG
    (void) testdebug ((*pe), "STRONG.SETOFACLInfo");
#endif

    {
# line 1501 "STRONG.py"

	pe_free(pe_enc);
	
    }

    return OK;
}

/* ARGSUSED */

int	build_STRONG_AttributeACL (pe, explicit, len, buffer, parm)
register PE     *pe;
int	explicit;
int	len;
char   *buffer;
aclAttr * parm;
{
    PE	p316_z = NULLPE;
    register PE *p316 = &p316_z;

    if (((*pe) = pe_alloc (PE_CLASS_UNIV, PE_FORM_CONS, PE_CONS_SEQ)) == NULLPE) {
        advise (NULLCP, "AttributeACL: %s", PEPY_ERR_NOMEM);
        return NOTOK;
    }
    (*p316) = NULLPE;

    {
        if (build_STRONG_SETOFObjId (p316, 0, NULL, NULLCP, parm->aa_types) == NOTOK)
            return NOTOK;

#ifdef DEBUG
        (void) testdebug ((*p316), "element");
#endif

    }

    if ((*p316) != NULLPE)
        if (seq_add ((*pe), (*p316), -1) == NOTOK) {
            advise (NULLCP, "AttributeACL %s%s", PEPY_ERR_BAD_SEQ,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }
    (*p316) = NULLPE;

    if (parm->aa_acl) {
        if (build_STRONG_SETOFACLInfo (p316, 0, NULL, NULLCP, parm->aa_acl) == NOTOK)
            return NOTOK;

#ifdef DEBUG
        (void) testdebug ((*p316), "element");
#endif

    }

    if ((*p316) != NULLPE)
        if (seq_add ((*pe), (*p316), -1) == NOTOK) {
            advise (NULLCP, "AttributeACL %s%s", PEPY_ERR_BAD_SEQ,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }

#ifdef DEBUG
    (void) testdebug ((*pe), "STRONG.AttributeACL");
#endif


    return OK;
}

/* ARGSUSED */

int	build_STRONG_SETOFAttributeACL (pe, explicit, len, buffer, parm)
PE     *pe;
int	explicit;
int	len;
char   *buffer;
SET_OF_aclAttr * parm;
{
# line 1528 "STRONG.py"
    
	PE pe_enc = encode_STRONG_DER_SET_OF(parm, ATTRACLSET);
	
    PE	p317 = pe_enc ;

    if (p317 == NULLPE) {
        advise (NULLCP, "SETOFAttributeACL %s", PEPY_ERR_INIT_FAILED);
        return NOTOK;
    }
    ((*pe) = p317) -> pe_refcnt++;

#ifdef DEBUG
    (void) testdebug ((*pe), "STRONG.SETOFAttributeACL");
#endif

    {
# line 1533 "STRONG.py"

	pe_free(pe_enc);
	
    }

    return OK;
}

/* ARGSUSED */

int	build_STRONG_ACL (pe, explicit, len, buffer, parm)
register PE     *pe;
int	explicit;
int	len;
char   *buffer;
AccessControlList * parm;
{
    PE	p318_z = NULLPE;
    register PE *p318 = &p318_z;

    if (((*pe) = pe_alloc (PE_CLASS_UNIV, PE_FORM_CONS, PE_CONS_SEQ)) == NULLPE) {
        advise (NULLCP, "ACL: %s", PEPY_ERR_NOMEM);
        return NOTOK;
    }
    (*p318) = NULLPE;

    if (parm->ac_child) {	/* childACL */
        if (build_STRONG_SETOFACLInfo (p318, 0, NULL, NULLCP, parm->ac_child) == NOTOK)
            return NOTOK;
        {	/* childACL TAG PUSHDOWN */
            PE p319_z;
            register PE *p319 = &p319_z;

            if ((*p319 = pe_alloc (PE_CLASS_CONT, PE_FORM_CONS, 0)) == NULLPE) {
                advise (NULLCP, "childACL: %s", PEPY_ERR_NOMEM);
                return NOTOK;
            }
            (*p319) -> pe_cons = (*p318);
            (*p318) = *p319;
        }

#ifdef DEBUG
        (void) testdebug ((*p318), "childACL");
#endif

    }

    if ((*p318) != NULLPE)
        if (seq_add ((*pe), (*p318), -1) == NOTOK) {
            advise (NULLCP, "ACL %s%s", PEPY_ERR_BAD_SEQ,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }
    (*p318) = NULLPE;

    if (parm->ac_entry) {	/* entryACL */
        if (build_STRONG_SETOFACLInfo (p318, 0, NULL, NULLCP, parm->ac_entry) == NOTOK)
            return NOTOK;
        {	/* entryACL TAG PUSHDOWN */
            PE p320_z;
            register PE *p320 = &p320_z;

            if ((*p320 = pe_alloc (PE_CLASS_CONT, PE_FORM_CONS, 1)) == NULLPE) {
                advise (NULLCP, "entryACL: %s", PEPY_ERR_NOMEM);
                return NOTOK;
            }
            (*p320) -> pe_cons = (*p318);
            (*p318) = *p320;
        }

#ifdef DEBUG
        (void) testdebug ((*p318), "entryACL");
#endif

    }

    if ((*p318) != NULLPE)
        if (seq_add ((*pe), (*p318), -1) == NOTOK) {
            advise (NULLCP, "ACL %s%s", PEPY_ERR_BAD_SEQ,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }
    (*p318) = NULLPE;

    if (parm->ac_default) {	/* defaultAttributeACL */
        if (build_STRONG_SETOFACLInfo (p318, 0, NULL, NULLCP, parm->ac_default) == NOTOK)
            return NOTOK;
        {	/* defaultAttributeACL TAG PUSHDOWN */
            PE p321_z;
            register PE *p321 = &p321_z;

            if ((*p321 = pe_alloc (PE_CLASS_CONT, PE_FORM_CONS, 2)) == NULLPE) {
                advise (NULLCP, "defaultAttributeACL: %s", PEPY_ERR_NOMEM);
                return NOTOK;
            }
            (*p321) -> pe_cons = (*p318);
            (*p318) = *p321;
        }

#ifdef DEBUG
        (void) testdebug ((*p318), "defaultAttributeACL");
#endif

    }

    if ((*p318) != NULLPE)
        if (seq_add ((*pe), (*p318), -1) == NOTOK) {
            advise (NULLCP, "ACL %s%s", PEPY_ERR_BAD_SEQ,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }
    (*p318) = NULLPE;

    {
        if (build_STRONG_SETOFAttributeACL (p318, 0, NULL, NULLCP, parm->ac_attributes) == NOTOK)
            return NOTOK;
        {	/* element TAG PUSHDOWN */
            PE p322_z;
            register PE *p322 = &p322_z;

            if ((*p322 = pe_alloc (PE_CLASS_CONT, PE_FORM_CONS, 3)) == NULLPE) {
                advise (NULLCP, "element: %s", PEPY_ERR_NOMEM);
                return NOTOK;
            }
            (*p322) -> pe_cons = (*p318);
            (*p318) = *p322;
        }

#ifdef DEBUG
        (void) testdebug ((*p318), "element");
#endif

    }

    if ((*p318) != NULLPE)
        if (seq_add ((*pe), (*p318), -1) == NOTOK) {
            advise (NULLCP, "ACL %s%s", PEPY_ERR_BAD_SEQ,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }

#ifdef DEBUG
    (void) testdebug ((*pe), "STRONG.ACL");
#endif


    return OK;
}

/* ARGSUSED */

int	build_STRONG_PartialOutcomeQualifier (pe, explicit, len, buffer, parm)
register PE     *pe;
int	explicit;
int	len;
char   *buffer;
PartialOutQual * parm;
{
    PE	p323_z = NULLPE;
    register PE *p323 = &p323_z;

    if (((*pe) = pe_alloc (PE_CLASS_UNIV, PE_FORM_CONS, PE_CONS_SET)) == NULLPE) {
        advise (NULLCP, "PartialOutcomeQualifier: %s", PEPY_ERR_NOMEM);
        return NOTOK;
    }
    (*p323) = NULLPE;

    if (parm->poq_limitproblem != LSR_NOLIMITPROBLEM) {
        if (build_STRONG_LimitProblem (p323, 0, parm->poq_limitproblem, NULLCP, NullParm) == NOTOK)
            return NOTOK;

#ifdef DEBUG
        (void) testdebug ((*p323), "limitProblem");
#endif

        {	/* limitProblem TAG PUSHDOWN */
            PE p324_z;
            register PE *p324 = &p324_z;

            if ((*p324 = pe_alloc (PE_CLASS_CONT, PE_FORM_CONS, 0)) == NULLPE) {
                advise (NULLCP, "limitProblem: %s", PEPY_ERR_NOMEM);
                return NOTOK;
            }
            (*p324) -> pe_cons = (*p323);
            (*p323) = *p324;
        }
    }
    if ((*p323) != NULLPE)
        if (set_add ((*pe), (*p323)) == NOTOK) {
            advise (NULLCP, "PartialOutcomeQualifier %s%s", PEPY_ERR_BAD_SET,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }
    (*p323) = NULLPE;

    if (parm->poq_cref) {
        if (build_STRONG_SETOFContinuationReference (p323, 0, NULL, NULLCP, parm->poq_cref) == NOTOK)
            return NOTOK;

#ifdef DEBUG
        (void) testdebug ((*p323), "unexplored");
#endif

        {	/* unexplored TAG PUSHDOWN */
            PE p325_z;
            register PE *p325 = &p325_z;

            if ((*p325 = pe_alloc (PE_CLASS_CONT, PE_FORM_CONS, 1)) == NULLPE) {
                advise (NULLCP, "unexplored: %s", PEPY_ERR_NOMEM);
                return NOTOK;
            }
            (*p325) -> pe_cons = (*p323);
            (*p323) = *p325;
        }
    }
    if ((*p323) != NULLPE)
        if (set_add ((*pe), (*p323)) == NOTOK) {
            advise (NULLCP, "PartialOutcomeQualifier %s%s", PEPY_ERR_BAD_SET,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }
    (*p323) = NULLPE;

    if ((*p323) != NULLPE)
        if (set_add ((*pe), (*p323)) == NOTOK) {
            advise (NULLCP, "PartialOutcomeQualifier %s%s", PEPY_ERR_BAD_SET,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }

#ifdef DEBUG
    (void) testdebug ((*pe), "STRONG.PartialOutcomeQualifier");
#endif


    return OK;
}

/* ARGSUSED */

int	build_STRONG_ReferenceType (pe, explicit, len, buffer, parm)
register PE     *pe;
int	explicit;
int	len;
char   *buffer;
PEPYPARM parm;
{
    register integer p326 = len;

    if (((*pe) = enum2prim (p326, PE_CLASS_UNIV, PE_PRIM_ENUM)) == NULLPE) {
        advise (NULLCP, "ReferenceType: %s", PEPY_ERR_NOMEM);
        return NOTOK;
    }
    switch (p326) {
        case 1:	/* superior */
            break;
        case 2:	/* subordinate */
            break;
        case 3:	/* cross */
            break;
        case 4:	/* nonSpecificSubordinate */
            break;
        default:
            advise (NULLCP, "ReferenceType %s%d", PEPY_ERR_UNK_COMP, p326);
            return NOTOK;
    }

#ifdef DEBUG
    (void) testdebug ((*pe), "STRONG.ReferenceType");
#endif


    return OK;
}

/* ARGSUSED */

int	build_STRONG_LimitProblem (pe, explicit, len, buffer, parm)
register PE     *pe;
int	explicit;
int	len;
char   *buffer;
PEPYPARM parm;
{
    register integer p327 = len;

    if (((*pe) = num2prim (p327, PE_CLASS_UNIV, PE_PRIM_INT)) == NULLPE) {
        advise (NULLCP, "LimitProblem: %s", PEPY_ERR_NOMEM);
        return NOTOK;
    }
    switch (p327) {
        case 0:	/* timeLimitExceeded */
            break;
        case 1:	/* sizeLimitExceeded */
            break;
        case 2:	/* administrativeLimitExceeded */
            break;
    }

#ifdef DEBUG
    (void) testdebug ((*pe), "STRONG.LimitProblem");
#endif


    return OK;
}

/* ARGSUSED */

int	build_STRONG_SETOFContinuationReference (pe, explicit, len, buffer, parm)
PE     *pe;
int	explicit;
int	len;
char   *buffer;
SET_OF_ContReference * parm;
{
# line 1616 "STRONG.py"
    
	PE pe_enc = encode_STRONG_DER_SET_OF(parm, CONTREFSET);
	
    PE	p328 = pe_enc ;

    if (p328 == NULLPE) {
        advise (NULLCP, "SETOFContinuationReference %s", PEPY_ERR_INIT_FAILED);
        return NOTOK;
    }
    ((*pe) = p328) -> pe_refcnt++;

#ifdef DEBUG
    (void) testdebug ((*pe), "STRONG.SETOFContinuationReference");
#endif

    {
# line 1621 "STRONG.py"

	pe_free(pe_enc);
	
    }

    return OK;
}

/* ARGSUSED */

int	build_STRONG_ContinuationReference (pe, explicit, len, buffer, parm)
register PE     *pe;
int	explicit;
int	len;
char   *buffer;
ContReference *  parm;
{
    PE	p329_z = NULLPE;
    register PE *p329 = &p329_z;

    if (((*pe) = pe_alloc (PE_CLASS_UNIV, PE_FORM_CONS, PE_CONS_SET)) == NULLPE) {
        advise (NULLCP, "ContinuationReference: %s", PEPY_ERR_NOMEM);
        return NOTOK;
    }
    (*p329) = NULLPE;

    {
        if (build_IF_Name (p329, 0, NULL, NULLCP, parm->cr_name) == NOTOK)
            return NOTOK;

#ifdef DEBUG
        (void) testdebug ((*p329), "targetObject");
#endif

        {	/* targetObject TAG PUSHDOWN */
            PE p330_z;
            register PE *p330 = &p330_z;

            if ((*p330 = pe_alloc (PE_CLASS_CONT, PE_FORM_CONS, 0)) == NULLPE) {
                advise (NULLCP, "targetObject: %s", PEPY_ERR_NOMEM);
                return NOTOK;
            }
            (*p330) -> pe_cons = (*p329);
            (*p329) = *p330;
        }
    }
    if ((*p329) != NULLPE)
        if (set_add ((*pe), (*p329)) == NOTOK) {
            advise (NULLCP, "ContinuationReference %s%s", PEPY_ERR_BAD_SET,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }
    (*p329) = NULLPE;

    if ( parm->cr_aliasedRDNs != CR_NOALIASEDRDNS) {
        register integer p331 = parm->cr_aliasedRDNs;

        if (((*p329) = num2prim (p331, PE_CLASS_UNIV, PE_PRIM_INT)) == NULLPE) {
            advise (NULLCP, "aliasedRDNs: %s", PEPY_ERR_NOMEM);
            return NOTOK;
        }

#ifdef DEBUG
        (void) testdebug ((*p329), "aliasedRDNs");
#endif

        {	/* aliasedRDNs TAG PUSHDOWN */
            PE p332_z;
            register PE *p332 = &p332_z;

            if ((*p332 = pe_alloc (PE_CLASS_CONT, PE_FORM_CONS, 1)) == NULLPE) {
                advise (NULLCP, "aliasedRDNs: %s", PEPY_ERR_NOMEM);
                return NOTOK;
            }
            (*p332) -> pe_cons = (*p329);
            (*p329) = *p332;
        }
    }
    if ((*p329) != NULLPE)
        if (set_add ((*pe), (*p329)) == NOTOK) {
            advise (NULLCP, "ContinuationReference %s%s", PEPY_ERR_BAD_SET,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }
    (*p329) = NULLPE;

    {
        if (build_STRONG_OperationProgress (p329, 0, NULL, NULLCP, parm->cr_progress) == NOTOK)
            return NOTOK;

#ifdef DEBUG
        (void) testdebug ((*p329), "operationProgress");
#endif

        {	/* operationProgress TAG PUSHDOWN */
            PE p333_z;
            register PE *p333 = &p333_z;

            if ((*p333 = pe_alloc (PE_CLASS_CONT, PE_FORM_CONS, 2)) == NULLPE) {
                advise (NULLCP, "operationProgress: %s", PEPY_ERR_NOMEM);
                return NOTOK;
            }
            (*p333) -> pe_cons = (*p329);
            (*p329) = *p333;
        }
    }
    if ((*p329) != NULLPE)
        if (set_add ((*pe), (*p329)) == NOTOK) {
            advise (NULLCP, "ContinuationReference %s%s", PEPY_ERR_BAD_SET,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }
    (*p329) = NULLPE;

    if ( parm->cr_rdn_resolved != CR_RDNRESOLVED_NOTDEFINED) {
        register integer p334 = parm->cr_rdn_resolved;

        if (((*p329) = num2prim (p334, PE_CLASS_UNIV, PE_PRIM_INT)) == NULLPE) {
            advise (NULLCP, "rdnsResolved: %s", PEPY_ERR_NOMEM);
            return NOTOK;
        }

#ifdef DEBUG
        (void) testdebug ((*p329), "rdnsResolved");
#endif

        {	/* rdnsResolved TAG PUSHDOWN */
            PE p335_z;
            register PE *p335 = &p335_z;

            if ((*p335 = pe_alloc (PE_CLASS_CONT, PE_FORM_CONS, 3)) == NULLPE) {
                advise (NULLCP, "rdnsResolved: %s", PEPY_ERR_NOMEM);
                return NOTOK;
            }
            (*p335) -> pe_cons = (*p329);
            (*p329) = *p335;
        }
    }
    if ((*p329) != NULLPE)
        if (set_add ((*pe), (*p329)) == NOTOK) {
            advise (NULLCP, "ContinuationReference %s%s", PEPY_ERR_BAD_SET,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }
    (*p329) = NULLPE;

    if ( parm->cr_reftype != RT_UNDEFINED) {
        if (build_STRONG_ReferenceType (p329, 0, parm->cr_reftype, NULLCP, NullParm) == NOTOK)
            return NOTOK;

#ifdef DEBUG
        (void) testdebug ((*p329), "referenceType");
#endif

        {	/* referenceType TAG PUSHDOWN */
            PE p336_z;
            register PE *p336 = &p336_z;

            if ((*p336 = pe_alloc (PE_CLASS_CONT, PE_FORM_CONS, 4)) == NULLPE) {
                advise (NULLCP, "referenceType: %s", PEPY_ERR_NOMEM);
                return NOTOK;
            }
            (*p336) -> pe_cons = (*p329);
            (*p329) = *p336;
        }
    }
    if ((*p329) != NULLPE)
        if (set_add ((*pe), (*p329)) == NOTOK) {
            advise (NULLCP, "ContinuationReference %s%s", PEPY_ERR_BAD_SET,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }
    (*p329) = NULLPE;

    {
        if (build_STRONG_SETOFAccessPoint (p329, 0, NULL, NULLCP, parm->cr_accesspoints) == NOTOK)
            return NOTOK;

#ifdef DEBUG
        (void) testdebug ((*p329), "accessPoints");
#endif

        {	/* accessPoints TAG PUSHDOWN */
            PE p337_z;
            register PE *p337 = &p337_z;

            if ((*p337 = pe_alloc (PE_CLASS_CONT, PE_FORM_CONS, 5)) == NULLPE) {
                advise (NULLCP, "accessPoints: %s", PEPY_ERR_NOMEM);
                return NOTOK;
            }
            (*p337) -> pe_cons = (*p329);
            (*p329) = *p337;
        }
    }
    if ((*p329) != NULLPE)
        if (set_add ((*pe), (*p329)) == NOTOK) {
            advise (NULLCP, "ContinuationReference %s%s", PEPY_ERR_BAD_SET,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }

#ifdef DEBUG
    (void) testdebug ((*pe), "STRONG.ContinuationReference");
#endif


    return OK;
}

/* ARGSUSED */

int	build_STRONG_SETOFAccessPoint (pe, explicit, len, buffer, parm)
PE     *pe;
int	explicit;
int	len;
char   *buffer;
SET_OF_AccessPoint * parm;
{
# line 1667 "STRONG.py"
    
	PE pe_enc = encode_STRONG_DER_SET_OF(parm, ACCESSPOINTSET);
	
    PE	p338 = pe_enc ;

    if (p338 == NULLPE) {
        advise (NULLCP, "SETOFAccessPoint %s", PEPY_ERR_INIT_FAILED);
        return NOTOK;
    }
    ((*pe) = p338) -> pe_refcnt++;

#ifdef DEBUG
    (void) testdebug ((*pe), "STRONG.SETOFAccessPoint");
#endif

    {
# line 1672 "STRONG.py"

	pe_free(pe_enc);
	
    }

    return OK;
}

/* ARGSUSED */

int	build_STRONG_AccessPoint (pe, explicit, len, buffer, parm)
register PE     *pe;
int	explicit;
int	len;
char   *buffer;
AccessPoint * parm;
{
    PE	p339_z = NULLPE;
    register PE *p339 = &p339_z;

    if (((*pe) = pe_alloc (PE_CLASS_UNIV, PE_FORM_CONS, PE_CONS_SET)) == NULLPE) {
        advise (NULLCP, "AccessPoint: %s", PEPY_ERR_NOMEM);
        return NOTOK;
    }
    (*p339) = NULLPE;

    {
        if (build_IF_Name (p339, 0, NULL, NULLCP, parm->ap_name) == NOTOK)
            return NOTOK;

#ifdef DEBUG
        (void) testdebug ((*p339), "member");
#endif

        {	/* member TAG PUSHDOWN */
            PE p340_z;
            register PE *p340 = &p340_z;

            if ((*p340 = pe_alloc (PE_CLASS_CONT, PE_FORM_CONS, 0)) == NULLPE) {
                advise (NULLCP, "member: %s", PEPY_ERR_NOMEM);
                return NOTOK;
            }
            (*p340) -> pe_cons = (*p339);
            (*p339) = *p340;
        }
    }
    if ((*p339) != NULLPE)
        if (set_add ((*pe), (*p339)) == NOTOK) {
            advise (NULLCP, "AccessPoint %s%s", PEPY_ERR_BAD_SET,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }
    (*p339) = NULLPE;

    {
        if (build_STRONG_PSAPaddr (p339, 0, NULL, NULLCP, parm->ap_address ) == NOTOK)
            return NOTOK;

#ifdef DEBUG
        (void) testdebug ((*p339), "member");
#endif

        {	/* member TAG PUSHDOWN */
            PE p341_z;
            register PE *p341 = &p341_z;

            if ((*p341 = pe_alloc (PE_CLASS_CONT, PE_FORM_CONS, 1)) == NULLPE) {
                advise (NULLCP, "member: %s", PEPY_ERR_NOMEM);
                return NOTOK;
            }
            (*p341) -> pe_cons = (*p339);
            (*p339) = *p341;
        }
    }
    if ((*p339) != NULLPE)
        if (set_add ((*pe), (*p339)) == NOTOK) {
            advise (NULLCP, "AccessPoint %s%s", PEPY_ERR_BAD_SET,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }

#ifdef DEBUG
    (void) testdebug ((*pe), "STRONG.AccessPoint");
#endif


    return OK;
}

/* ARGSUSED */

int	build_STRONG_SETOFOctetString (pe, explicit, len, buffer, parm)
PE     *pe;
int	explicit;
int	len;
char   *buffer;
SET_OF_OctetString * parm;
{
# line 1697 "STRONG.py"
    
	PE pe_enc = encode_STRONG_DER_SET_OF(parm, OSTRSET);
	
    PE	p342 = pe_enc ;

    if (p342 == NULLPE) {
        advise (NULLCP, "SETOFOctetString %s", PEPY_ERR_INIT_FAILED);
        return NOTOK;
    }
    ((*pe) = p342) -> pe_refcnt++;

#ifdef DEBUG
    (void) testdebug ((*pe), "STRONG.SETOFOctetString");
#endif

    {
# line 1702 "STRONG.py"

	pe_free(pe_enc);
	
    }

    return OK;
}

/* ARGSUSED */

int	build_STRONG_PSAPaddr (pe, explicit, len, buffer, parm)
register PE     *pe;
int	explicit;
int	len;
char   *buffer;
typeDSE_PSAPaddr * parm;
{
    PE	p343_z = NULLPE;
    register PE *p343 = &p343_z;

    if (((*pe) = pe_alloc (PE_CLASS_UNIV, PE_FORM_CONS, PE_CONS_SEQ)) == NULLPE) {
        advise (NULLCP, "PSAPaddr: %s", PEPY_ERR_NOMEM);
        return NOTOK;
    }
    (*p343) = NULLPE;

    if (parm->pSelector.noctets > 0) {	/* pSelector */
        register char *p344;
        int p344_len;

        p344 = parm->pSelector.octets ;
        p344_len = 
		     parm->pSelector.noctets   ;
        if (p344 == NULLCP) {
            advise (NULLCP, "pSelector %s", PEPY_ERR_INIT_FAILED);
            return NOTOK;
        }
        if (((*p343) = str2prim (p344, p344_len, PE_CLASS_UNIV, PE_PRIM_OCTS)) == NULLPE) {
            advise (NULLCP, "pSelector: %s", PEPY_ERR_NOMEM);
            return NOTOK;
        }
        {	/* pSelector TAG PUSHDOWN */
            PE p345_z;
            register PE *p345 = &p345_z;

            if ((*p345 = pe_alloc (PE_CLASS_CONT, PE_FORM_CONS, 0)) == NULLPE) {
                advise (NULLCP, "pSelector: %s", PEPY_ERR_NOMEM);
                return NOTOK;
            }
            (*p345) -> pe_cons = (*p343);
            (*p343) = *p345;
        }

#ifdef DEBUG
        (void) testdebug ((*p343), "pSelector");
#endif

    }

    if ((*p343) != NULLPE)
        if (seq_add ((*pe), (*p343), -1) == NOTOK) {
            advise (NULLCP, "PSAPaddr %s%s", PEPY_ERR_BAD_SEQ,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }
    (*p343) = NULLPE;

    if (parm->sSelector.noctets > 0) {	/* sSelector */
        register char *p346;
        int p346_len;

        p346 = parm->sSelector.octets ;
        p346_len = 
		     parm->sSelector.noctets   ;
        if (p346 == NULLCP) {
            advise (NULLCP, "sSelector %s", PEPY_ERR_INIT_FAILED);
            return NOTOK;
        }
        if (((*p343) = str2prim (p346, p346_len, PE_CLASS_UNIV, PE_PRIM_OCTS)) == NULLPE) {
            advise (NULLCP, "sSelector: %s", PEPY_ERR_NOMEM);
            return NOTOK;
        }
        {	/* sSelector TAG PUSHDOWN */
            PE p347_z;
            register PE *p347 = &p347_z;

            if ((*p347 = pe_alloc (PE_CLASS_CONT, PE_FORM_CONS, 1)) == NULLPE) {
                advise (NULLCP, "sSelector: %s", PEPY_ERR_NOMEM);
                return NOTOK;
            }
            (*p347) -> pe_cons = (*p343);
            (*p343) = *p347;
        }

#ifdef DEBUG
        (void) testdebug ((*p343), "sSelector");
#endif

    }

    if ((*p343) != NULLPE)
        if (seq_add ((*pe), (*p343), -1) == NOTOK) {
            advise (NULLCP, "PSAPaddr %s%s", PEPY_ERR_BAD_SEQ,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }
    (*p343) = NULLPE;

    if (parm->tSelector.noctets > 0) {	/* tSelector */
        register char *p348;
        int p348_len;

        p348 = parm->tSelector.octets ;
        p348_len = 
	             parm->tSelector.noctets   ;
        if (p348 == NULLCP) {
            advise (NULLCP, "tSelector %s", PEPY_ERR_INIT_FAILED);
            return NOTOK;
        }
        if (((*p343) = str2prim (p348, p348_len, PE_CLASS_UNIV, PE_PRIM_OCTS)) == NULLPE) {
            advise (NULLCP, "tSelector: %s", PEPY_ERR_NOMEM);
            return NOTOK;
        }
        {	/* tSelector TAG PUSHDOWN */
            PE p349_z;
            register PE *p349 = &p349_z;

            if ((*p349 = pe_alloc (PE_CLASS_CONT, PE_FORM_CONS, 2)) == NULLPE) {
                advise (NULLCP, "tSelector: %s", PEPY_ERR_NOMEM);
                return NOTOK;
            }
            (*p349) -> pe_cons = (*p343);
            (*p343) = *p349;
        }

#ifdef DEBUG
        (void) testdebug ((*p343), "tSelector");
#endif

    }

    if ((*p343) != NULLPE)
        if (seq_add ((*pe), (*p343), -1) == NOTOK) {
            advise (NULLCP, "PSAPaddr %s%s", PEPY_ERR_BAD_SEQ,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }
    (*p343) = NULLPE;

    {	/* nAddress */
        if (build_STRONG_SETOFOctetString (p343, 0, NULL, NULLCP, parm->nAddress) == NOTOK)
            return NOTOK;
        {	/* nAddress TAG PUSHDOWN */
            PE p350_z;
            register PE *p350 = &p350_z;

            if ((*p350 = pe_alloc (PE_CLASS_CONT, PE_FORM_CONS, 3)) == NULLPE) {
                advise (NULLCP, "nAddress: %s", PEPY_ERR_NOMEM);
                return NOTOK;
            }
            (*p350) -> pe_cons = (*p343);
            (*p343) = *p350;
        }

#ifdef DEBUG
        (void) testdebug ((*p343), "nAddress");
#endif

    }

    if ((*p343) != NULLPE)
        if (seq_add ((*pe), (*p343), -1) == NOTOK) {
            advise (NULLCP, "PSAPaddr %s%s", PEPY_ERR_BAD_SEQ,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }

#ifdef DEBUG
    (void) testdebug ((*pe), "STRONG.PSAPaddr");
#endif


    return OK;
}

/* ARGSUSED */

int	parse_STRONG_PSAPaddr (pe, explicit, len, buffer, parm)
register PE	pe;
int	explicit;
int    *len;
char  **buffer;
typeDSE_PSAPaddr ** parm;
{
    register PE p351;

#ifdef DEBUG
    (void) testdebug (pe, "STRONG.PSAPaddr");
#endif

    if (explicit) {
        if (pe -> pe_class != PE_CLASS_UNIV
                || pe -> pe_form != PE_FORM_CONS
                || pe -> pe_id != PE_CONS_SEQ) {
            advise (NULLCP, "PSAPaddr bad class/form/id: %s/%d/0x%x",
                    pe_classlist[pe -> pe_class], pe -> pe_form, pe -> pe_id);
            return NOTOK;
        }
    }
    else
        if (pe -> pe_form != PE_FORM_CONS) {
            advise (NULLCP, "PSAPaddr bad form: %d", pe -> pe_form);
            return NOTOK;
        }

    {
# line 1740 "STRONG.py"

            if ((*(parm) = (typeDSE_PSAPaddr *)
                    calloc (1, sizeof **(parm))) == ((typeDSE_PSAPaddr *) 0)) {
                advise (NULLCP, "out of memory");
                return NOTOK;
            }
	    (*parm)->nAddress = (SET_OF_OctetString *)0;
	    (*parm)->pSelector.octets = CNULL;
	    (*parm)->pSelector.noctets = 0;
	    (*parm)->sSelector.octets = CNULL;
	    (*parm)->sSelector.noctets = 0;
	    (*parm)->tSelector.octets = CNULL;
	    (*parm)->tSelector.noctets = 0;
	
    }
    if ((p351 = prim2seq (pe)) == NULLPE) {
        advise (NULLCP, "PSAPaddr %s%s", PEPY_ERR_BAD_SEQ,
                pe_error (pe -> pe_errno));
        return NOTOK;
    }
    pe = p351;

    {
        register PE p352;

        if ((p352 = first_member (pe)) != NULLPE
                && PE_ID (p352 -> pe_class, p352 -> pe_id)
                        != PE_ID (PE_CLASS_CONT, 0))
            p352 = NULLPE;
        if (p352 != NULLPE) {
            p351 = p352;

            {	/* element TAG PULLUP */
                register PE p353;

                if ((p353 = prim2set (p352)) == NULLPE) {
                    advise (NULLCP, "pSelector %selement: %s", PEPY_ERR_BAD,
                            pe_error (p352 -> pe_errno));
                    return NOTOK;
                }
                if (p353 -> pe_cardinal != 1) {
                    advise (NULLCP, "pSelector %s element: %d", PEPY_ERR_TOO_MANY_TAGGED,
                            p353 -> pe_cardinal);
                    return NOTOK;
                }
                p352 = first_member (p353);
            }
            {	/* pSelector */
                register char *p354;
                int p354_len;

#ifdef DEBUG
                (void) testdebug (p352, "pSelector");
#endif

                if (p352 -> pe_class != PE_CLASS_UNIV || p352 -> pe_id != PE_PRIM_OCTS) {
                    advise (NULLCP, "pSelector bad class/form/id: %s/%d/0x%x",
                            pe_classlist[p352 -> pe_class], p352 -> pe_form, p352 -> pe_id);
                    return NOTOK;
                }

                if ((p354 = prim2str (p352, &p354_len)) == NULLCP) {
                    advise (NULLCP, "pSelector %s%s", PEPY_ERR_BAD_OCTET,
                            pe_error (p352 -> pe_errno));
                    return NOTOK;
                }
                (*parm)->pSelector.octets  = p354;
                
		     (*parm)->pSelector.noctets    = p354_len;
            }
        }
    }

    {
        register PE p355;

        if ((p355 = (pe != p351 ? next_member (pe, p351) : first_member (pe))) 
                    != NULLPE
                && PE_ID (p355 -> pe_class, p355 -> pe_id)
                        != PE_ID (PE_CLASS_CONT, 1))
            p355 = NULLPE;
        if (p355 != NULLPE) {
            p351 = p355;

            {	/* element TAG PULLUP */
                register PE p356;

                if ((p356 = prim2set (p355)) == NULLPE) {
                    advise (NULLCP, "sSelector %selement: %s", PEPY_ERR_BAD,
                            pe_error (p355 -> pe_errno));
                    return NOTOK;
                }
                if (p356 -> pe_cardinal != 1) {
                    advise (NULLCP, "sSelector %s element: %d", PEPY_ERR_TOO_MANY_TAGGED,
                            p356 -> pe_cardinal);
                    return NOTOK;
                }
                p355 = first_member (p356);
            }
            {	/* sSelector */
                register char *p357;
                int p357_len;

#ifdef DEBUG
                (void) testdebug (p355, "sSelector");
#endif

                if (p355 -> pe_class != PE_CLASS_UNIV || p355 -> pe_id != PE_PRIM_OCTS) {
                    advise (NULLCP, "sSelector bad class/form/id: %s/%d/0x%x",
                            pe_classlist[p355 -> pe_class], p355 -> pe_form, p355 -> pe_id);
                    return NOTOK;
                }

                if ((p357 = prim2str (p355, &p357_len)) == NULLCP) {
                    advise (NULLCP, "sSelector %s%s", PEPY_ERR_BAD_OCTET,
                            pe_error (p355 -> pe_errno));
                    return NOTOK;
                }
                (*parm)->sSelector.octets  = p357;
                
		     (*parm)->sSelector.noctets    = p357_len;
            }
        }
    }

    {
        register PE p358;

        if ((p358 = (pe != p351 ? next_member (pe, p351) : first_member (pe))) 
                    != NULLPE
                && PE_ID (p358 -> pe_class, p358 -> pe_id)
                        != PE_ID (PE_CLASS_CONT, 2))
            p358 = NULLPE;
        if (p358 != NULLPE) {
            p351 = p358;

            {	/* element TAG PULLUP */
                register PE p359;

                if ((p359 = prim2set (p358)) == NULLPE) {
                    advise (NULLCP, "tSelector %selement: %s", PEPY_ERR_BAD,
                            pe_error (p358 -> pe_errno));
                    return NOTOK;
                }
                if (p359 -> pe_cardinal != 1) {
                    advise (NULLCP, "tSelector %s element: %d", PEPY_ERR_TOO_MANY_TAGGED,
                            p359 -> pe_cardinal);
                    return NOTOK;
                }
                p358 = first_member (p359);
            }
            {	/* tSelector */
                register char *p360;
                int p360_len;

#ifdef DEBUG
                (void) testdebug (p358, "tSelector");
#endif

                if (p358 -> pe_class != PE_CLASS_UNIV || p358 -> pe_id != PE_PRIM_OCTS) {
                    advise (NULLCP, "tSelector bad class/form/id: %s/%d/0x%x",
                            pe_classlist[p358 -> pe_class], p358 -> pe_form, p358 -> pe_id);
                    return NOTOK;
                }

                if ((p360 = prim2str (p358, &p360_len)) == NULLCP) {
                    advise (NULLCP, "tSelector %s%s", PEPY_ERR_BAD_OCTET,
                            pe_error (p358 -> pe_errno));
                    return NOTOK;
                }
                (*parm)->tSelector.octets  = p360;
                
	             (*parm)->tSelector.noctets    = p360_len;
            }
        }
    }

    {
        register PE p361;

        if ((p361 = (pe != p351 ? next_member (pe, p351) : first_member (pe))) != NULLPE) {
            p351 = p361;

            {	/* element TAG PULLUP */
                register PE p362;

                if ((p362 = prim2set (p361)) == NULLPE) {
                    advise (NULLCP, "nAddress %selement: %s", PEPY_ERR_BAD,
                            pe_error (p361 -> pe_errno));
                    return NOTOK;
                }
                if (p362 -> pe_cardinal != 1) {
                    advise (NULLCP, "nAddress %s element: %d", PEPY_ERR_TOO_MANY_TAGGED,
                            p362 -> pe_cardinal);
                    return NOTOK;
                }
                p361 = first_member (p362);
            }
            {	/* nAddress */
#ifdef DEBUG
                (void) testdebug (p361, "nAddress");
#endif

                if (parse_STRONG_SETOFOctetString (p361, 1, NULLIP, NULLVP, &((*parm)->nAddress) ) == NOTOK)
                    return NOTOK;
            }
        }
    }


    if (pe -> pe_cardinal > 4) {
        advise (NULLCP, "PSAPaddr %s(4): %d", PEPY_ERR_TOO_MANY_ELEMENTS,
                pe -> pe_cardinal);
        return NOTOK;
    }

    return OK;
}

/* ARGSUSED */

int	parse_STRONG_OctetString (pe, explicit, len, buffer, parm)
register PE	pe;
int	explicit;
int    *len;
char  **buffer;
OctetString ** parm;
{
    register char *p363;
    int p363_len;

#ifdef DEBUG
    (void) testdebug (pe, "STRONG.OctetString");
#endif

    if (explicit) {
        if (pe -> pe_class != PE_CLASS_UNIV || pe -> pe_id != PE_PRIM_OCTS) {
            advise (NULLCP, "OctetString bad class/form/id: %s/%d/0x%x",
                    pe_classlist[pe -> pe_class], pe -> pe_form, pe -> pe_id);
            return NOTOK;
        }
    }

    {
# line 1782 "STRONG.py"

            if ((*(parm) = (OctetString *)
                    calloc (1, sizeof **(parm))) == ((OctetString *) 0)) {
                advise (NULLCP, "out of memory");
                return NOTOK;
            }
	
    }
    if ((p363 = prim2str (pe, &p363_len)) == NULLCP) {
        advise (NULLCP, "OctetString %s%s", PEPY_ERR_BAD_OCTET,
                pe_error (pe -> pe_errno));
        return NOTOK;
    }
    (*parm)->octets  = p363;
    
	     (*parm)->noctets    = p363_len;
    if (len)
        *len = p363_len;
    if (buffer)
        *buffer = p363;
    else
        /* do nothing */;

    return OK;
}

/* ARGSUSED */

int	parse_STRONG_SETOFOctetString (pe, explicit, len, buffer, parm)
register PE	pe;
int	explicit;
int    *len;
char  **buffer;
SET_OF_OctetString ** parm;
{
    register PE p364;

#ifdef DEBUG
    (void) testdebug (pe, "STRONG.SETOFOctetString");
#endif

    if (explicit) {
        if (pe -> pe_class != PE_CLASS_UNIV
                || pe -> pe_form != PE_FORM_CONS
                || pe -> pe_id != PE_CONS_SET) {
            advise (NULLCP, "SETOFOctetString bad class/form/id: %s/%d/0x%x",
                    pe_classlist[pe -> pe_class], pe -> pe_form, pe -> pe_id);
            return NOTOK;
        }
    }
    else
        if (pe -> pe_form != PE_FORM_CONS) {
            advise (NULLCP, "SETOFOctetString bad form: %d", pe -> pe_form);
            return NOTOK;
        }

    if ((p364 = prim2set (pe)) == NULLPE) {
        advise (NULLCP, "SETOFOctetString %s%s", PEPY_ERR_BAD_SET,
                pe_error (pe -> pe_errno));
        return NOTOK;
    }
    pe = p364;

    for (p364 = first_member (pe); p364; p364 = next_member (pe, p364)) {
        {
# line 1796 "STRONG.py"

                if ((*(parm) = (SET_OF_OctetString *)
                        calloc (1, sizeof **(parm))) == ((SET_OF_OctetString *) 0)) {
                    advise (NULLCP, "out of memory");
                    return NOTOK;
                }
            
        }
        {
#ifdef DEBUG
            (void) testdebug (p364, "member");
#endif

            if (parse_STRONG_OctetString (p364, 1, NULLIP, NULLVP, &((*parm) -> element)) == NOTOK)
                return NOTOK;
            {
# line 1805 "STRONG.py"
 parm = &((*parm) -> next); 
            }
        }
    }

    return OK;
}
# line 1811 "STRONG.py"

/************************ local functions: ************************/


static
PE	build_token_tbs(token,save)
Token   * token;
PE      * save;
{
	(* save) = NULLPE;

	if( token->tbs_DERcode == (OctetString * )0 ) {
	    if (build_STRONG_TokenTBS(save,1,0,NULLCP,token->tbs) == NOTOK)
		return NULLPE;
	    token->tbs_DERcode = aux_PE2OctetString(* save);
	}
	else   (* save) = aux_OctetString2PE(token->tbs_DERcode);

	return (* save);
}


static
PE	build_addarg_tbs(addarg,save)
AddArgument   * addarg;
PE            * save;
{
	(* save) = NULLPE;

	if( addarg->tbs_DERcode == (OctetString * )0 ) {
	    if (build_STRONG_AddArgumentTBS(save,1,0,NULLCP,addarg->tbs) == NOTOK)
		return NULLPE;
	    addarg->tbs_DERcode = aux_PE2OctetString(* save);
	}
	else   (* save) = aux_OctetString2PE(addarg->tbs_DERcode);

	return (* save);
}


static
PE	build_comparearg_tbs(comparearg,save)
CompareArgument   * comparearg;
PE                * save;
{
	(* save) = NULLPE;

	if( comparearg->tbs_DERcode == (OctetString * )0 ) {
	    if (build_STRONG_CompareArgumentTBS(save,1,0,NULLCP,comparearg->tbs) == NOTOK)
		return NULLPE;
	    comparearg->tbs_DERcode = aux_PE2OctetString(* save);
	}
	else   (* save) = aux_OctetString2PE(comparearg->tbs_DERcode);

	return (* save);
}


static
PE	build_compareres_tbs(compareres,save)
CompareResult   * compareres;
PE              * save;
{
	(* save) = NULLPE;

	if( compareres->tbs_DERcode == (OctetString * )0 ) {
	    if (build_STRONG_CompareResultTBS(save,1,0,NULLCP,compareres->tbs) == NOTOK)
		return NULLPE;
	    compareres->tbs_DERcode = aux_PE2OctetString(* save);
	}
	else   (* save) = aux_OctetString2PE(compareres->tbs_DERcode);

	return (* save);
}


static
PE	build_listarg_tbs(listarg,save)
ListArgument   * listarg;
PE             * save;
{
	(* save) = NULLPE;

	if( listarg->tbs_DERcode == (OctetString * )0 ) {
	    if (build_STRONG_ListArgumentTBS(save,1,0,NULLCP,listarg->tbs) == NOTOK)
		return NULLPE;
	    listarg->tbs_DERcode = aux_PE2OctetString(* save);
	}
	else   (* save) = aux_OctetString2PE(listarg->tbs_DERcode);

	return (* save);
}


static
PE	build_listres_tbs(listres,save)
ListResult   * listres;
PE           * save;
{
	(* save) = NULLPE;

	if( listres->tbs_DERcode == (OctetString * )0 ) {
	    if (build_STRONG_ListResultTBS(save,1,0,NULLCP,listres->tbs) == NOTOK)
		return NULLPE;
	    listres->tbs_DERcode = aux_PE2OctetString(* save);
	}
	else   (* save) = aux_OctetString2PE(listres->tbs_DERcode);

	return (* save);
}


static
PE	build_modifyentryarg_tbs(modifyentryarg,save)
ModifyEntryArgument * modifyentryarg;
PE                  * save;
{
	(* save) = NULLPE;

	if( modifyentryarg->tbs_DERcode == (OctetString * )0 ) {
	    if (build_STRONG_ModifyEntryArgumentTBS(save,1,0,NULLCP,modifyentryarg->tbs) == NOTOK)
		return NULLPE;
	    modifyentryarg->tbs_DERcode = aux_PE2OctetString(* save);
	}
	else   (* save) = aux_OctetString2PE(modifyentryarg->tbs_DERcode);

	return (* save);
}


static
PE	build_modifyrdnarg_tbs(modifyrdnarg,save)
ModifyRDNArgument * modifyrdnarg;
PE                * save;
{
	(* save) = NULLPE;

	if( modifyrdnarg->tbs_DERcode == (OctetString * )0 ) {
	    if (build_STRONG_ModifyRDNArgumentTBS(save,1,0,NULLCP,modifyrdnarg->tbs) == NOTOK)
		return NULLPE;
	    modifyrdnarg->tbs_DERcode = aux_PE2OctetString(* save);
	}
	else   (* save) = aux_OctetString2PE(modifyrdnarg->tbs_DERcode);

	return (* save);
}


static
PE	build_readarg_tbs(readarg,save)
ReadArgument   * readarg;
PE             * save;
{
	(* save) = NULLPE;

	if( readarg->tbs_DERcode == (OctetString * )0 ) {
	    if (build_STRONG_ReadArgumentTBS(save,1,0,NULLCP,readarg->tbs) == NOTOK)
		return NULLPE;
	    readarg->tbs_DERcode = aux_PE2OctetString(* save);
	}
	else   (* save) = aux_OctetString2PE(readarg->tbs_DERcode);

	return (* save);
}


static
PE	build_readres_tbs(readres,save)
ReadResult   * readres;
PE           * save;
{
	(* save) = NULLPE;

	if( readres->tbs_DERcode == (OctetString * )0 ) {
	    if (build_STRONG_ReadResultTBS(save,1,0,NULLCP,readres->tbs) == NOTOK)
		return NULLPE;
	    readres->tbs_DERcode = aux_PE2OctetString(* save);
	}
	else   (* save) = aux_OctetString2PE(readres->tbs_DERcode);

	return (* save);
}


static
PE	build_removearg_tbs(removearg,save)
RemoveArgument   * removearg;
PE               * save;
{
	(* save) = NULLPE;

	if( removearg->tbs_DERcode == (OctetString * )0 ) {
	    if (build_STRONG_RemoveArgumentTBS(save,1,0,NULLCP,removearg->tbs) == NOTOK)
		return NULLPE;
	    removearg->tbs_DERcode = aux_PE2OctetString(* save);
	}
	else   (* save) = aux_OctetString2PE(removearg->tbs_DERcode);

	return (* save);
}


static
PE	build_searcharg_tbs(searcharg,save)
SearchArgument * searcharg;
PE             * save;
{
	(* save) = NULLPE;

	if( searcharg->tbs_DERcode == (OctetString * )0 ) {
	    if (build_STRONG_SearchArgumentTBS(save,1,0,NULLCP,searcharg->tbs) == NOTOK)
		return NULLPE;
	    searcharg->tbs_DERcode = aux_PE2OctetString(* save);
	}
	else   (* save) = aux_OctetString2PE(searcharg->tbs_DERcode);

	return (* save);
}


static
PE	build_searchres_tbs(searchres,save)
SearchResult * searchres;
PE             * save;
{
	(* save) = NULLPE;

	if( searchres->tbs_DERcode == (OctetString * )0 ) {
	    if (build_STRONG_SearchResultTBS(save,1,0,NULLCP,searchres->tbs) == NOTOK)
		return NULLPE;
	    searchres->tbs_DERcode = aux_PE2OctetString(* save);
	}
	else   (* save) = aux_OctetString2PE(searchres->tbs_DERcode);

	return (* save);
}




/* from ISODEDIR/dsap/x500as/DAS_tables.c */
static
char   * aux_int2strb_alloc (n, len)
register int    n;
int     len;
{
	register int    i;
	static char *buffer;

	buffer = calloc (1,sizeof (int) + 1);

	for (i = 0; i < len; i++)
		if (n & (1 << i))
			buffer[i / 8] |= (1 << (7 - (i % 8)));

	return buffer;
}



static
PE encode_STRONG_DER_SET_OF(arg, type)
caddr_t    arg;
int 	   type;
{
	SET_OF_ListResult 	  * setof_listres, * tmp_setof_listres;
	SET_OF_SearchResult 	  * setof_searchres, * tmp_setof_searchres;
	SET_OF_SECExtension 	  * setof_secext, * tmp_setof_secext;
	SET_OF_AttrType 	  * setof_attrtype, * tmp_setof_attrtype;
	SET_OF_Attr  		  * setof_attr, * tmp_setof_attr;
	SET_OF_AttrAttrTypeCHOICE * setof_attrattrtypechoice, * tmp_setof_attrattrtypechoice;
	SET_OF_EntryINFO 	  * setof_einfo, * tmp_setof_einfo;
	SET_OF_SFilter 		  * setof_sfilter, * tmp_setof_sfilter;
	SET_OF_SubordEntry 	  * setof_subord, * tmp_setof_subord;
	SET_OF_DName  		  * setof_dname, * tmp_setof_dname;
	SET_OF_ObjId		  * setof_objid, * tmp_setof_objid;
	SET_OF_aclInfo		  * setof_aclinfo, * tmp_setof_aclinfo;
	SET_OF_aclAttr		  * setof_aclattr, * tmp_setof_aclattr;
	SET_OF_AccessPoint	  * setof_accpoint, * tmp_setof_accpoint;
	SET_OF_ContReference	  * setof_cref, * tmp_setof_cref;
	SET_OF_OctetString	  * setof_ostr, * tmp_setof_ostr;
	OctetString 		 ** oSTK, * tmp_ostr;
	PE			    p24 = NULLPE, p25 = NULLPE, pe;
	unsigned char  		    a, b;
	int 	       		    n, i, k, j, s, cnt;


	if (! arg){
		if (type == CONTREFSET)
			/* pe_enc is OPTIONAL */
			return(NULLPE);
		else {
			/* Force an empty set to be coded */
			pe = pe_alloc (PE_CLASS_UNIV, PE_FORM_CONS, PE_CONS_SET);
			return(pe);
		}
	}


	/* Individual encoding of components of Set-of type */

	switch(type) {

	case ACCESSPOINTSET:
		setof_accpoint = (SET_OF_AccessPoint * )arg;

		for (tmp_setof_accpoint = setof_accpoint, cnt = 0; tmp_setof_accpoint; 
			tmp_setof_accpoint = tmp_setof_accpoint->next, cnt++)
			/* count */;
	
		oSTK = (OctetString ** )calloc(cnt, sizeof(OctetString * ));
		if(! oSTK)
			return(NULLPE);
	
		i = 0;
		tmp_setof_accpoint = setof_accpoint;

		while (tmp_setof_accpoint){
			tmp_ostr = e_AccessPoint(tmp_setof_accpoint->element);		
			oSTK[i] = aux_cpy_OctetString(tmp_ostr);
			aux_free_OctetString(&tmp_ostr);
			if(! oSTK[i++])
				return(NULLPE);
			tmp_setof_accpoint = tmp_setof_accpoint->next;
		}
		break;

	case ACLINFOSET:
		setof_aclinfo = (SET_OF_aclInfo * )arg;

		for (tmp_setof_aclinfo = setof_aclinfo, cnt = 0; tmp_setof_aclinfo; 
			tmp_setof_aclinfo = tmp_setof_aclinfo->next, cnt++)
			/* count */;
	
		oSTK = (OctetString ** )calloc(cnt, sizeof(OctetString * ));
		if(! oSTK)
			return(NULLPE);
	
		i = 0;
		tmp_setof_aclinfo = setof_aclinfo;

		while (tmp_setof_aclinfo){
			tmp_ostr = e_ACLInfo(tmp_setof_aclinfo->element);		
			oSTK[i] = aux_cpy_OctetString(tmp_ostr);
			aux_free_OctetString(&tmp_ostr);
			if(! oSTK[i++])
				return(NULLPE);
			tmp_setof_aclinfo = tmp_setof_aclinfo->next;
		}
		break;

	case ATTRACLSET:
		setof_aclattr = (SET_OF_aclAttr * )arg;

		for (tmp_setof_aclattr = setof_aclattr, cnt = 0; tmp_setof_aclattr; 
			tmp_setof_aclattr = tmp_setof_aclattr->next, cnt++)
			/* count */;
	
		oSTK = (OctetString ** )calloc(cnt, sizeof(OctetString * ));
		if(! oSTK)
			return(NULLPE);
	
		i = 0;
		tmp_setof_aclattr = setof_aclattr;

		while (tmp_setof_aclattr){
			tmp_ostr = e_ACLAttr(tmp_setof_aclattr->element);		
			oSTK[i] = aux_cpy_OctetString(tmp_ostr);
			aux_free_OctetString(&tmp_ostr);
			if(! oSTK[i++])
				return(NULLPE);
			tmp_setof_aclattr = tmp_setof_aclattr->next;
		}
		break;

	case ATTRATTRTYPECHOICESET:
		setof_attrattrtypechoice = (SET_OF_AttrAttrTypeCHOICE * )arg;

		for (tmp_setof_attrattrtypechoice = setof_attrattrtypechoice, cnt = 0; 
			tmp_setof_attrattrtypechoice; tmp_setof_attrattrtypechoice = tmp_setof_attrattrtypechoice->next, cnt++)
			/* count */;
	
		oSTK = (OctetString ** )calloc(cnt, sizeof(OctetString * ));
		if(! oSTK)
			return(NULLPE);
	
		i = 0;
		tmp_setof_attrattrtypechoice = setof_attrattrtypechoice;

		while (tmp_setof_attrattrtypechoice){
			tmp_ostr = e_AttrAttrTypeCHOICE(tmp_setof_attrattrtypechoice->element);		
			oSTK[i] = aux_cpy_OctetString(tmp_ostr);
			aux_free_OctetString(&tmp_ostr);
			if(! oSTK[i++])
				return(NULLPE);
			tmp_setof_attrattrtypechoice = tmp_setof_attrattrtypechoice->next;
		}
		break;

	case ATTRSET:
		setof_attr = (SET_OF_Attr * )arg;

		for (tmp_setof_attr = setof_attr, cnt = 0; tmp_setof_attr; 
			tmp_setof_attr = tmp_setof_attr->next, cnt++)
			/* count */;
	
		oSTK = (OctetString ** )calloc(cnt, sizeof(OctetString * ));
		if(! oSTK)
			return(NULLPE);
	
		i = 0;
		tmp_setof_attr = setof_attr;

		while (tmp_setof_attr){
			tmp_ostr = e_Attribute(tmp_setof_attr->element);		
			oSTK[i] = aux_cpy_OctetString(tmp_ostr);
			aux_free_OctetString(&tmp_ostr);
			if(! oSTK[i++])
				return(NULLPE);
			tmp_setof_attr = tmp_setof_attr->next;
		}
		break;

	case ATTRTYPESET:
		setof_attrtype = (SET_OF_AttrType * )arg;

		for (tmp_setof_attrtype = setof_attrtype, cnt = 0; 
			tmp_setof_attrtype; tmp_setof_attrtype = tmp_setof_attrtype->next, cnt++)
			/* count */;
	
		oSTK = (OctetString ** )calloc(cnt, sizeof(OctetString * ));
		if(! oSTK)
			return(NULLPE);
	
		i = 0;
		tmp_setof_attrtype = setof_attrtype;

		while (tmp_setof_attrtype){
			tmp_ostr = e_AttributeType(tmp_setof_attrtype->element);		
			oSTK[i] = aux_cpy_OctetString(tmp_ostr);
			aux_free_OctetString(&tmp_ostr);
			if(! oSTK[i++])
				return(NULLPE);
			tmp_setof_attrtype = tmp_setof_attrtype->next;
		}
		break;

	case CONTREFSET:
		setof_cref = (SET_OF_ContReference * )arg;

		for (tmp_setof_cref = setof_cref, cnt = 0; tmp_setof_cref; 
			tmp_setof_cref = tmp_setof_cref->next, cnt++)
			/* count */;
	
		oSTK = (OctetString ** )calloc(cnt, sizeof(OctetString * ));
		if(! oSTK)
			return(NULLPE);
	
		i = 0;
		tmp_setof_cref = setof_cref;

		while (tmp_setof_cref){
			tmp_ostr = e_ContReference(tmp_setof_cref->element);		
			oSTK[i] = aux_cpy_OctetString(tmp_ostr);
			aux_free_OctetString(&tmp_ostr);
			if(! oSTK[i++])
				return(NULLPE);
			tmp_setof_cref = tmp_setof_cref->next;
		}
		break;

	case DNAMESET:
		setof_dname = (SET_OF_DName * )arg;

		for (tmp_setof_dname = setof_dname, cnt = 0; tmp_setof_dname; 
			tmp_setof_dname = tmp_setof_dname->next, cnt++)
			/* count */;
	
		oSTK = (OctetString ** )calloc(cnt, sizeof(OctetString * ));
		if(! oSTK)
			return(NULLPE);
	
		i = 0;
		tmp_setof_dname = setof_dname;

		while (tmp_setof_dname){
			tmp_ostr = e_DName(tmp_setof_dname->element);		
			oSTK[i] = aux_cpy_OctetString(tmp_ostr);
			aux_free_OctetString(&tmp_ostr);
			if(! oSTK[i++])
				return(NULLPE);
			tmp_setof_dname = tmp_setof_dname->next;
		}
		break;

	case ENTRYINFOSET:
		setof_einfo = (SET_OF_EntryINFO * )arg;

		for (tmp_setof_einfo = setof_einfo, cnt = 0; tmp_setof_einfo; 
			tmp_setof_einfo = tmp_setof_einfo->next, cnt++)
			/* count */;
	
		oSTK = (OctetString ** )calloc(cnt, sizeof(OctetString * ));
		if(! oSTK)
			return(NULLPE);
	
		i = 0;
		tmp_setof_einfo = setof_einfo;

		while (tmp_setof_einfo){
			tmp_ostr = e_EntryINFO(tmp_setof_einfo->element);		
			oSTK[i] = aux_cpy_OctetString(tmp_ostr);
			aux_free_OctetString(&tmp_ostr);
			if(! oSTK[i++])
				return(NULLPE);
			tmp_setof_einfo = tmp_setof_einfo->next;
		}
		break;

	case FILTERSET:
		setof_sfilter = (SET_OF_SFilter * )arg;

		for (tmp_setof_sfilter = setof_sfilter, cnt = 0; 
			tmp_setof_sfilter; tmp_setof_sfilter = tmp_setof_sfilter->next, cnt++)
			/* count */;
	
		oSTK = (OctetString ** )calloc(cnt, sizeof(OctetString * ));
		if(! oSTK)
			return(NULLPE);
	
		i = 0;
		tmp_setof_sfilter = setof_sfilter;

		while (tmp_setof_sfilter){
			tmp_ostr = e_Filter(tmp_setof_sfilter->element);		
			oSTK[i] = aux_cpy_OctetString(tmp_ostr);
			aux_free_OctetString(&tmp_ostr);
			if(! oSTK[i++])
				return(NULLPE);
			tmp_setof_sfilter = tmp_setof_sfilter->next;
		}
		break;

	case LISTRESULTSET:
		setof_listres = (SET_OF_ListResult * )arg;

		for (tmp_setof_listres = setof_listres, cnt = 0; 
			tmp_setof_listres; tmp_setof_listres = tmp_setof_listres->next, cnt++)
			/* count */;
	
		oSTK = (OctetString ** )calloc(cnt, sizeof(OctetString * ));
		if(! oSTK)
			return(NULLPE);
	
		i = 0;
		tmp_setof_listres = setof_listres;

		while (tmp_setof_listres){
			tmp_ostr = e_ListResult(tmp_setof_listres->element);		
			oSTK[i] = aux_cpy_OctetString(tmp_ostr);
			aux_free_OctetString(&tmp_ostr);
			if(! oSTK[i++])
				return(NULLPE);
			tmp_setof_listres = tmp_setof_listres->next;
		}
		break;

	case OSTRSET:
		setof_ostr = (SET_OF_OctetString * )arg;

		for (tmp_setof_ostr = setof_ostr, cnt = 0; tmp_setof_ostr; 
			tmp_setof_ostr = tmp_setof_ostr->next, cnt++)
			/* count */;
	
		oSTK = (OctetString ** )calloc(cnt, sizeof(OctetString * ));
		if(! oSTK)
			return(NULLPE);
	
		i = 0;
		tmp_setof_ostr = setof_ostr;

		while (tmp_setof_ostr){
			tmp_ostr = e_OctetString(tmp_setof_ostr->element);		
			oSTK[i] = aux_cpy_OctetString(tmp_ostr);
			aux_free_OctetString(&tmp_ostr);
			if(! oSTK[i++])
				return(NULLPE);
			tmp_setof_ostr = tmp_setof_ostr->next;
		}
		break;

	case OBJIDSET:
		setof_objid = (SET_OF_ObjId * )arg;

		for (tmp_setof_objid = setof_objid, cnt = 0; tmp_setof_objid; 
			tmp_setof_objid = tmp_setof_objid->next, cnt++)
			/* count */;
	
		oSTK = (OctetString ** )calloc(cnt, sizeof(OctetString * ));
		if(! oSTK)
			return(NULLPE);
	
		i = 0;
		tmp_setof_objid = setof_objid;

		while (tmp_setof_objid){
			tmp_ostr = e_AttributeType(tmp_setof_objid->element);		
			oSTK[i] = aux_cpy_OctetString(tmp_ostr);
			aux_free_OctetString(&tmp_ostr);
			if(! oSTK[i++])
				return(NULLPE);
			tmp_setof_objid = tmp_setof_objid->next;
		}
		break;

	case SEARCHRESULTSET:
		setof_searchres = (SET_OF_SearchResult * )arg;

		for (tmp_setof_searchres = setof_searchres, cnt = 0; 
			tmp_setof_searchres; tmp_setof_searchres = tmp_setof_searchres->next, cnt++)
			/* count */;
	
		oSTK = (OctetString ** )calloc(cnt, sizeof(OctetString * ));
		if(! oSTK)
			return(NULLPE);
	
		i = 0;
		tmp_setof_searchres = setof_searchres;

		while (tmp_setof_searchres){
			tmp_ostr = e_SearchResult(tmp_setof_searchres->element);		
			oSTK[i] = aux_cpy_OctetString(tmp_ostr);
			aux_free_OctetString(&tmp_ostr);
			if(! oSTK[i++])
				return(NULLPE);
			tmp_setof_searchres = tmp_setof_searchres->next;
		}
		break;

	case SECEXTENSIONSET:
		setof_secext = (SET_OF_SECExtension * )arg;

		for (tmp_setof_secext = setof_secext, cnt = 0; tmp_setof_secext; 
			tmp_setof_secext = tmp_setof_secext->next, cnt++)
			/* count */;
	
		oSTK = (OctetString ** )calloc(cnt, sizeof(OctetString * ));
		if(! oSTK)
			return(NULLPE);
	
		i = 0;
		tmp_setof_secext = setof_secext;

		while (tmp_setof_secext){
			tmp_ostr = e_SECExtension(tmp_setof_secext->element);		
			oSTK[i] = aux_cpy_OctetString(tmp_ostr);
			aux_free_OctetString(&tmp_ostr);
			if(! oSTK[i++])
				return(NULLPE);
			tmp_setof_secext = tmp_setof_secext->next;
		}
		break;

	case SUBORDENTRYSET:
		setof_subord = (SET_OF_SubordEntry * )arg;

		for (tmp_setof_subord = setof_subord, cnt = 0; tmp_setof_subord; 
			tmp_setof_subord = tmp_setof_subord->next, cnt++)
			/* count */;
	
		oSTK = (OctetString ** )calloc(cnt, sizeof(OctetString * ));
		if(! oSTK)
			return(NULLPE);
	
		i = 0;
		tmp_setof_subord = setof_subord;

		while (tmp_setof_subord){
			tmp_ostr = e_SubordEntry(tmp_setof_subord->element);		
			oSTK[i] = aux_cpy_OctetString(tmp_ostr);
			aux_free_OctetString(&tmp_ostr);
			if(! oSTK[i++])
				return(NULLPE);
			tmp_setof_subord = tmp_setof_subord->next;
		}
		break;

	default:
		return(NULLPE);

	} /* switch */


	
	/* sort elements of oSTK in ascending order */

	for (i = 0; i < cnt - 1; i++) {
		k = i;
		tmp_ostr = oSTK[i];
		for (j = i + 1; j < cnt; j++) {

			/* n = min(tmp_ostr->noctets, oSTK[j]->noctets) */
			n = tmp_ostr->noctets;
			if(oSTK[j]->noctets < tmp_ostr->noctets)
				n = oSTK[j]->noctets;

			s = 0;
			while (oSTK[j]->octets[s] == tmp_ostr->octets[s] && s < n)
				s++;
			if(s < n && (a = oSTK[j]->octets[s]) < (b = tmp_ostr->octets[s])){
				k = j;
				tmp_ostr = oSTK[j];
			} /* if */

		}  /* for */
		oSTK[k] = oSTK[i];
		oSTK[i] = tmp_ostr;
	}  /* for */


    	if ((pe = pe_alloc (PE_CLASS_UNIV, PE_FORM_CONS, PE_CONS_SET)) == NULLPE)
        	return NULLPE;

    	for(i = 0; i < cnt; i++) {
		p25 = aux_OctetString2PE(oSTK[i]);

        	(void) set_addon (pe, p24, p25);
        	p24 = p25;
    	}


	for(i = 0; i < cnt; i++)
		aux_free_OctetString(&oSTK[i]);

	free (oSTK);

	return(pe);
}


#endif


#else
/* dummy */
strong_dummy() 
{
	return(0);
}

#endif
