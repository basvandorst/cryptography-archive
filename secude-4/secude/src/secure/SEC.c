/* automatically generated by pepy 8.0 #11 (tiber), do not edit! */

#include <isode/psap.h>

#ifndef lint
static char *pepyid = "pepy 8.0 #11 (tiber) of Tue Jun  1 11:43:07 MET DST 1993";
#endif

void	advise ();

/* Generated from module SEC */
# line 11 "SEC.py"
      /* surrounding global definitions       */
#include        "secure.h"


PE              aux_OctetString2PE();
OctetString    *aux_PE2OctetString();

RC 		dec_RSAAlgorithm();
RC 		dec_DSAAlgorithm();

#ifndef PEPYPARM
#define PEPYPARM char *
#endif /* PEPYPARM */
extern PEPYPARM NullParm;

/* ARGSUSED */

int	build_SEC_OctetString (pe, explicit, len, buffer, parm)
register PE     *pe;
int	explicit;
int	len;
char   *buffer;
struct OctetString *  parm;
{
    register char *p0;
    int p0_len;

    p0 = parm->octets ;
    p0_len =  parm->noctets ;
    if (p0 == NULLCP) {
        advise (NULLCP, "OctetString %s", PEPY_ERR_INIT_FAILED);
        return NOTOK;
    }
    if (((*pe) = str2prim (p0, p0_len, PE_CLASS_UNIV, PE_PRIM_OCTS)) == NULLPE) {
        advise (NULLCP, "OctetString: %s", PEPY_ERR_NOMEM);
        return NOTOK;
    }

#ifdef DEBUG
    (void) testdebug ((*pe), "SEC.OctetString");
#endif


    return OK;
}

/* ARGSUSED */

int	parse_SEC_OctetString (pe, explicit, len, buffer, parm)
register PE	pe;
int	explicit;
int    *len;
char  **buffer;
struct OctetString *  parm;
{
    register char *p1;
    int p1_len;

#ifdef DEBUG
    (void) testdebug (pe, "SEC.OctetString");
#endif

    if (explicit) {
        if (pe -> pe_class != PE_CLASS_UNIV || pe -> pe_id != PE_PRIM_OCTS) {
            advise (NULLCP, "OctetString bad class/form/id: %s/%d/0x%x",
                    pe_classlist[pe -> pe_class], pe -> pe_form, pe -> pe_id);
            return NOTOK;
        }
    }

    if ((p1 = prim2str (pe, &p1_len)) == NULLCP) {
        advise (NULLCP, "OctetString %s%s", PEPY_ERR_BAD_OCTET,
                pe_error (pe -> pe_errno));
        return NOTOK;
    }
    parm->octets  = p1;
     parm->noctets  = p1_len;
    if (len)
        *len = p1_len;
    if (buffer)
        *buffer = p1;
    else
        /* do nothing */;

    return OK;
}

/* ARGSUSED */

int	build_SEC_OURINTEGER (pe, explicit, len, buffer, parm)
register PE     *pe;
int	explicit;
int	len;
char   *buffer;
OctetString *  parm;
{
    register char *p2;
    int p2_len;

    p2 = parm->octets ;
    p2_len = 
	     parm->noctets   ;
    if (p2 == NULLCP) {
        advise (NULLCP, "OURINTEGER %s", PEPY_ERR_INIT_FAILED);
        return NOTOK;
    }
    if (((*pe) = str2prim (p2, p2_len, PE_CLASS_UNIV, 2)) == NULLPE) {
        advise (NULLCP, "OURINTEGER: %s", PEPY_ERR_NOMEM);
        return NOTOK;
    }

#ifdef DEBUG
    (void) testdebug ((*pe), "SEC.OURINTEGER");
#endif


    return OK;
}

/* ARGSUSED */

int	parse_SEC_OURINTEGER (pe, explicit, len, buffer, parm)
register PE	pe;
int	explicit;
int    *len;
char  **buffer;
OctetString *  parm;
{
    register char *p3;
    int p3_len;

#ifdef DEBUG
    (void) testdebug (pe, "SEC.OURINTEGER");
#endif

    if (explicit
            && PE_ID (pe -> pe_class, pe -> pe_id)
                    != PE_ID (PE_CLASS_UNIV, 2)) {
        advise (NULLCP, "OURINTEGER %s%s/0x%x", PEPY_ERR_BAD_CLASS,
                pe_classlist[pe -> pe_class], pe -> pe_id);
        return NOTOK;
    }
    if ((p3 = prim2str (pe, &p3_len)) == NULLCP) {
        advise (NULLCP, "OURINTEGER %s%s", PEPY_ERR_BAD_OCTET,
                pe_error (pe -> pe_errno));
        return NOTOK;
    }
    parm->octets  = p3;
    
	     parm->noctets    = p3_len;
    if (len)
        *len = p3_len;
    if (buffer)
        *buffer = p3;
    else
        /* do nothing */;

    return OK;
}

/* ARGSUSED */

int	build_SEC_GRAPHICString (pe, explicit, len, buffer, parm)
register PE     *pe;
int	explicit;
int	len;
char   *buffer;
char *  parm;
{
    if (build_UNIV_GraphicString (pe, 0, len, parm, NullParm) == NOTOK)
        return NOTOK;

#ifdef DEBUG
    (void) testdebug ((*pe), "SEC.GRAPHICString");
#endif


    return OK;
}

/* ARGSUSED */

int	build_SEC_KeyBits (pe, explicit, len, buffer, parm)
register PE     *pe;
int	explicit;
int	len;
char   *buffer;
KeyBits *  parm;
{
# line 59 "SEC.py"
    
	OctetString * tmp_ostr1, * tmp_ostr2 = NULLOCTETSTRING, * tmp_ostr3 = NULLOCTETSTRING, * tmp_ostr4 = NULLOCTETSTRING;
	int           i, j;
	int	      choice = 1;
	
    PE	p4_z = NULLPE;
    register PE *p4 = &p4_z;

    if (((*pe) = pe_alloc (PE_CLASS_UNIV, PE_FORM_CONS, PE_CONS_SEQ)) == NULLPE) {
        advise (NULLCP, "KeyBits: %s", PEPY_ERR_NOMEM);
        return NOTOK;
    }
    {
# line 65 "SEC.py"


	/* valid constellation:

	   (parm->part2.noctets = 0 && parm->part3.noctets = 0 && parm->part4.noctets = 0) ||
	   (parm->part2.noctets > 0 && parm->part3.noctets = 0 && parm->part4.noctets = 0) ||
	   (parm->part2.noctets > 0 && parm->part3.noctets > 0 && parm->part4.noctets > 0)
	*/

	if ((parm->part1.noctets == 0) ||
	    ((parm->part2.noctets > 0 || parm->part3.noctets > 0 || parm->part4.noctets > 0) &&
	     (parm->part2.noctets == 0 || parm->part3.noctets > 0 || parm->part4.noctets > 0) &&
	     (parm->part2.noctets == 0 || parm->part3.noctets == 0 || parm->part4.noctets == 0)))
		return(NOTOK);

	if (parm->part2.noctets == 0 && parm->part3.noctets == 0 && parm->part4.noctets == 0)
		choice = 3;

	if (parm->part2.noctets > 0 && parm->part3.noctets > 0 && parm->part4.noctets > 0)
		choice = 2;

	tmp_ostr1 = (OctetString * )malloc(sizeof(OctetString));

	if(parm->part1.octets[0] & MSBITINBYTE){

	        /* Most significant bit in most significant byte is 1. */
		/* Therefore, leading 0 byte is required to conform to ASN-1 integer encoding */

		tmp_ostr1->noctets = parm->part1.noctets + 1;
		tmp_ostr1->octets = (char * ) calloc( 1 , tmp_ostr1->noctets );
		tmp_ostr1->octets[0] = 0x00;
		for ( i = 0, j = 1; i < parm->part1.noctets; i++, j++)
			tmp_ostr1->octets[j] = parm->part1.octets[i];
	}
	else{
		tmp_ostr1->noctets = parm->part1.noctets;
		tmp_ostr1->octets = (char * ) calloc( 1 , tmp_ostr1->noctets );
		for ( i = 0; i < parm->part1.noctets; i++)
			tmp_ostr1->octets[i] = parm->part1.octets[i];
	}

	if (parm->part2.noctets > 0) {
		tmp_ostr2 = (OctetString * )malloc(sizeof(OctetString));

		if(parm->part2.octets[0] & MSBITINBYTE){
	
			/* Most significant bit in most significant byte is 1. */
			/* Therefore, leading 0 byte is required to conform to ASN-1 integer encoding */
	
			tmp_ostr2->noctets = parm->part2.noctets + 1;
			tmp_ostr2->octets = (char * ) calloc( 1 , tmp_ostr2->noctets );
			tmp_ostr2->octets[0] = 0x00;
			for ( i = 0, j = 1; i < parm->part2.noctets; i++, j++)
				tmp_ostr2->octets[j] = parm->part2.octets[i];
		}
		else{
			tmp_ostr2->noctets = parm->part2.noctets;
			tmp_ostr2->octets = (char * ) calloc( 1 , tmp_ostr2->noctets );
			for ( i = 0; i < parm->part2.noctets; i++)
				tmp_ostr2->octets[i] = parm->part2.octets[i];
		}
	}

	if (parm->part3.noctets > 0) {
		tmp_ostr3 = (OctetString * )malloc(sizeof(OctetString));

		if(parm->part3.octets[0] & MSBITINBYTE){
	
			/* Most significant bit in most significant byte is 1. */
			/* Therefore, leading 0 byte is required to conform to ASN-1 integer encoding */
	
			tmp_ostr3->noctets = parm->part3.noctets + 1;
			tmp_ostr3->octets = (char * ) calloc( 1 , tmp_ostr3->noctets );
			tmp_ostr3->octets[0] = 0x00;
			for ( i = 0, j = 1; i < parm->part3.noctets; i++, j++)
				tmp_ostr3->octets[j] = parm->part3.octets[i];
		}
		else{
			tmp_ostr3->noctets = parm->part3.noctets;
			tmp_ostr3->octets = (char * ) calloc( 1 , tmp_ostr3->noctets );
			for ( i = 0; i < parm->part3.noctets; i++)
				tmp_ostr3->octets[i] = parm->part3.octets[i];
		}
	}

	if (parm->part4.noctets > 0) {
		tmp_ostr4 = (OctetString * )malloc(sizeof(OctetString));

		if(parm->part4.octets[0] & MSBITINBYTE){
	
			/* Most significant bit in most significant byte is 1. */
			/* Therefore, leading 0 byte is required to conform to ASN-1 integer encoding */
	
			tmp_ostr4->noctets = parm->part4.noctets + 1;
			tmp_ostr4->octets = (char * ) calloc( 1 , tmp_ostr4->noctets );
			tmp_ostr4->octets[0] = 0x00;
			for ( i = 0, j = 1; i < parm->part4.noctets; i++, j++)
				tmp_ostr4->octets[j] = parm->part4.octets[i];
		}
		else{
			tmp_ostr4->noctets = parm->part4.noctets;
			tmp_ostr4->octets = (char * ) calloc( 1 , tmp_ostr4->noctets );
			for ( i = 0; i < parm->part4.noctets; i++)
				tmp_ostr4->octets[i] = parm->part4.octets[i];
		}
	}
	
    }
    (*p4) = NULLPE;

    {	/* part1 */
        if (build_SEC_OURINTEGER (p4, 0, NULL, NULLCP, tmp_ostr1 ) == NOTOK)
            return NOTOK;

#ifdef DEBUG
        (void) testdebug ((*p4), "part1");
#endif

    }

    if ((*p4) != NULLPE)
        if (seq_add ((*pe), (*p4), -1) == NOTOK) {
            advise (NULLCP, "KeyBits %s%s", PEPY_ERR_BAD_SEQ,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }
    (*p4) = NULLPE;

    if (choice == 1 || choice == 2) {
        int	p5;

        switch (p5 = (choice)) {
            case 1:	/* part2 */
                {
                    if (build_SEC_OURINTEGER (p4, 0, NULL, NULLCP, tmp_ostr2 ) == NOTOK)
                        return NOTOK;

#ifdef DEBUG
                    (void) testdebug ((*p4), "part2");
#endif

                }
                break;
            case 2:
                {
                    PE	p6_z = NULLPE;
                    register PE *p6 = &p6_z;

                    if (((*p4) = pe_alloc (PE_CLASS_UNIV, PE_FORM_CONS, PE_CONS_SEQ)) == NULLPE) {
                        advise (NULLCP, "member: %s", PEPY_ERR_NOMEM);
                        return NOTOK;
                    }
                    (*p6) = NULLPE;

                    {	/* prime1 */
                        if (build_SEC_OURINTEGER (p6, 0, NULL, NULLCP, tmp_ostr2 ) == NOTOK)
                            return NOTOK;
                        {	/* prime1 TAG PUSHDOWN */
                            PE p7_z;
                            register PE *p7 = &p7_z;

                            if ((*p7 = pe_alloc (PE_CLASS_CONT, PE_FORM_CONS, 0)) == NULLPE) {
                                advise (NULLCP, "prime1: %s", PEPY_ERR_NOMEM);
                                return NOTOK;
                            }
                            (*p7) -> pe_cons = (*p6);
                            (*p6) = *p7;
                        }

#ifdef DEBUG
                        (void) testdebug ((*p6), "prime1");
#endif

                    }

                    if ((*p6) != NULLPE)
                        if (seq_add ((*p4), (*p6), -1) == NOTOK) {
                            advise (NULLCP, "member %s%s", PEPY_ERR_BAD_SEQ,
                                    pe_error ((*p4) -> pe_errno));
                            return NOTOK;
                        }
                    (*p6) = NULLPE;

                    {	/* prime2 */
                        if (build_SEC_OURINTEGER (p6, 0, NULL, NULLCP, tmp_ostr3 ) == NOTOK)
                            return NOTOK;
                        {	/* prime2 TAG PUSHDOWN */
                            PE p8_z;
                            register PE *p8 = &p8_z;

                            if ((*p8 = pe_alloc (PE_CLASS_CONT, PE_FORM_CONS, 1)) == NULLPE) {
                                advise (NULLCP, "prime2: %s", PEPY_ERR_NOMEM);
                                return NOTOK;
                            }
                            (*p8) -> pe_cons = (*p6);
                            (*p6) = *p8;
                        }

#ifdef DEBUG
                        (void) testdebug ((*p6), "prime2");
#endif

                    }

                    if ((*p6) != NULLPE)
                        if (seq_add ((*p4), (*p6), -1) == NOTOK) {
                            advise (NULLCP, "member %s%s", PEPY_ERR_BAD_SEQ,
                                    pe_error ((*p4) -> pe_errno));
                            return NOTOK;
                        }
                    (*p6) = NULLPE;

                    {	/* base */
                        if (build_SEC_OURINTEGER (p6, 0, NULL, NULLCP, tmp_ostr4 ) == NOTOK)
                            return NOTOK;
                        {	/* base TAG PUSHDOWN */
                            PE p9_z;
                            register PE *p9 = &p9_z;

                            if ((*p9 = pe_alloc (PE_CLASS_CONT, PE_FORM_CONS, 2)) == NULLPE) {
                                advise (NULLCP, "base: %s", PEPY_ERR_NOMEM);
                                return NOTOK;
                            }
                            (*p9) -> pe_cons = (*p6);
                            (*p6) = *p9;
                        }

#ifdef DEBUG
                        (void) testdebug ((*p6), "base");
#endif

                    }

                    if ((*p6) != NULLPE)
                        if (seq_add ((*p4), (*p6), -1) == NOTOK) {
                            advise (NULLCP, "member %s%s", PEPY_ERR_BAD_SEQ,
                                    pe_error ((*p4) -> pe_errno));
                            return NOTOK;
                        }

#ifdef DEBUG
                    (void) testdebug ((*p4), "member");
#endif

                }
                break;

            default:
                advise (NULLCP, "element %s%d", PEPY_ERR_INVALID_CHOICE, 
                        p5);
                return NOTOK;
        }

#ifdef DEBUG
        (void) testdebug ((*p4), "element");
#endif

    }

    if ((*p4) != NULLPE)
        if (seq_add ((*pe), (*p4), -1) == NOTOK) {
            advise (NULLCP, "KeyBits %s%s", PEPY_ERR_BAD_SEQ,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }

#ifdef DEBUG
    (void) testdebug ((*pe), "SEC.KeyBits");
#endif

    {
# line 197 "SEC.py"

	if(tmp_ostr1) aux_free_OctetString(&tmp_ostr1);
	if(tmp_ostr2) aux_free_OctetString(&tmp_ostr2);
	if(tmp_ostr3) aux_free_OctetString(&tmp_ostr3);
	if(tmp_ostr4) aux_free_OctetString(&tmp_ostr4);
	
    }

    return OK;
}

/* ARGSUSED */

int	build_SEC_KeyInfo (pe, explicit, len, buffer, parm)
register PE     *pe;
int	explicit;
int	len;
char   *buffer;
KeyInfo *  parm;
{
    PE	p10_z = NULLPE;
    register PE *p10 = &p10_z;

    if (((*pe) = pe_alloc (PE_CLASS_UNIV, PE_FORM_CONS, PE_CONS_SEQ)) == NULLPE) {
        advise (NULLCP, "KeyInfo: %s", PEPY_ERR_NOMEM);
        return NOTOK;
    }
    (*p10) = NULLPE;

    {	/* algorithm */
        if (build_SEC_AlgorithmIdentifier (p10, 0, NULL, NULLCP, parm->subjectAI ) == NOTOK)
            return NOTOK;

#ifdef DEBUG
        (void) testdebug ((*p10), "algorithm");
#endif

    }

    if ((*p10) != NULLPE)
        if (seq_add ((*pe), (*p10), -1) == NOTOK) {
            advise (NULLCP, "KeyInfo %s%s", PEPY_ERR_BAD_SEQ,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }
    (*p10) = NULLPE;

    {	/* key */
        PE	p11_z = NULLPE;
        register PE *p11 = &p11_z;

        char *p12;
        int p13;
        p12 = parm->subjectkey.bits ;
        p13 = 
			     parm->subjectkey.nbits ;
        (*p11) = p12 ? strb2bitstr (p12, p13, PE_CLASS_UNIV, PE_PRIM_BITS) : NULLPE;
        if ((*p11) == NULLPE) {
            advise (NULLCP, "key %s", PEPY_ERR_INIT_FAILED);
            return NOTOK;
        }
        if (((*p10) = bit2prim ((*p11))) == NULLPE) {
            advise (NULLCP, "key: %s", PEPY_ERR_NOMEM);
            return NOTOK;
        }

#ifdef DEBUG
        (void) testdebug ((*p10), "key");
#endif

    }

    if ((*p10) != NULLPE)
        if (seq_add ((*pe), (*p10), -1) == NOTOK) {
            advise (NULLCP, "KeyInfo %s%s", PEPY_ERR_BAD_SEQ,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }

#ifdef DEBUG
    (void) testdebug ((*pe), "SEC.KeyInfo");
#endif


    return OK;
}

/* ARGSUSED */

int	build_SEC_DigestInfo (pe, explicit, len, buffer, parm)
register PE     *pe;
int	explicit;
int	len;
char   *buffer;
DigestInfo *  parm;
{
    PE	p14_z = NULLPE;
    register PE *p14 = &p14_z;

    if (((*pe) = pe_alloc (PE_CLASS_UNIV, PE_FORM_CONS, PE_CONS_SEQ)) == NULLPE) {
        advise (NULLCP, "DigestInfo: %s", PEPY_ERR_NOMEM);
        return NOTOK;
    }
    (*p14) = NULLPE;

    {	/* digestai */
        if (build_SEC_AlgorithmIdentifier (p14, 0, NULL, NULLCP, parm->digestAI ) == NOTOK)
            return NOTOK;

#ifdef DEBUG
        (void) testdebug ((*p14), "digestai");
#endif

    }

    if ((*p14) != NULLPE)
        if (seq_add ((*pe), (*p14), -1) == NOTOK) {
            advise (NULLCP, "DigestInfo %s%s", PEPY_ERR_BAD_SEQ,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }
    (*p14) = NULLPE;

    {	/* digest */
        register char *p15;
        int p15_len;

        p15 = parm->digest.octets ;
        p15_len = 
			     parm->digest.noctets ;
        if (p15 == NULLCP) {
            advise (NULLCP, "digest %s", PEPY_ERR_INIT_FAILED);
            return NOTOK;
        }
        if (((*p14) = str2prim (p15, p15_len, PE_CLASS_UNIV, PE_PRIM_OCTS)) == NULLPE) {
            advise (NULLCP, "digest: %s", PEPY_ERR_NOMEM);
            return NOTOK;
        }

#ifdef DEBUG
        (void) testdebug ((*p14), "digest");
#endif

    }

    if ((*p14) != NULLPE)
        if (seq_add ((*pe), (*p14), -1) == NOTOK) {
            advise (NULLCP, "DigestInfo %s%s", PEPY_ERR_BAD_SEQ,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }

#ifdef DEBUG
    (void) testdebug ((*pe), "SEC.DigestInfo");
#endif


    return OK;
}

/* ARGSUSED */

int	build_SEC_EncryptedKey (pe, explicit, len, buffer, parm)
register PE     *pe;
int	explicit;
int	len;
char   *buffer;
EncryptedKey *  parm;
{
    PE	p16_z = NULLPE;
    register PE *p16 = &p16_z;

    if (((*pe) = pe_alloc (PE_CLASS_UNIV, PE_FORM_CONS, PE_CONS_SEQ)) == NULLPE) {
        advise (NULLCP, "EncryptedKey: %s", PEPY_ERR_NOMEM);
        return NOTOK;
    }
    (*p16) = NULLPE;

    {	/* algorithm */
        if (build_SEC_AlgorithmIdentifier (p16, 0, NULL, NULLCP, parm->encryptionAI ) == NOTOK)
            return NOTOK;

#ifdef DEBUG
        (void) testdebug ((*p16), "algorithm");
#endif

    }

    if ((*p16) != NULLPE)
        if (seq_add ((*pe), (*p16), -1) == NOTOK) {
            advise (NULLCP, "EncryptedKey %s%s", PEPY_ERR_BAD_SEQ,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }
    (*p16) = NULLPE;

    {	/* algorithm */
        if (build_SEC_AlgorithmIdentifier (p16, 0, NULL, NULLCP, parm->subjectAI ) == NOTOK)
            return NOTOK;

#ifdef DEBUG
        (void) testdebug ((*p16), "algorithm");
#endif

    }

    if ((*p16) != NULLPE)
        if (seq_add ((*pe), (*p16), -1) == NOTOK) {
            advise (NULLCP, "EncryptedKey %s%s", PEPY_ERR_BAD_SEQ,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }
    (*p16) = NULLPE;

    {	/* key */
        PE	p17_z = NULLPE;
        register PE *p17 = &p17_z;

        char *p18;
        int p19;
        p18 = parm->subjectkey.bits ;
        p19 = 
			     parm->subjectkey.nbits ;
        (*p17) = p18 ? strb2bitstr (p18, p19, PE_CLASS_UNIV, PE_PRIM_BITS) : NULLPE;
        if ((*p17) == NULLPE) {
            advise (NULLCP, "key %s", PEPY_ERR_INIT_FAILED);
            return NOTOK;
        }
        if (((*p16) = bit2prim ((*p17))) == NULLPE) {
            advise (NULLCP, "key: %s", PEPY_ERR_NOMEM);
            return NOTOK;
        }

#ifdef DEBUG
        (void) testdebug ((*p16), "key");
#endif

    }

    if ((*p16) != NULLPE)
        if (seq_add ((*pe), (*p16), -1) == NOTOK) {
            advise (NULLCP, "EncryptedKey %s%s", PEPY_ERR_BAD_SEQ,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }

#ifdef DEBUG
    (void) testdebug ((*pe), "SEC.EncryptedKey");
#endif


    return OK;
}

/* ARGSUSED */

int	build_SEC_AlgorithmIdentifier (pe, explicit, len, buffer, parm)
register PE     *pe;
int	explicit;
int	len;
char   *buffer;
AlgId *  parm;
{
# line 243 "SEC.py"
    
	int paramchoice;
    
    PE	p20_z = NULLPE;
    register PE *p20 = &p20_z;

    if (((*pe) = pe_alloc (PE_CLASS_UNIV, PE_FORM_CONS, PE_CONS_SEQ)) == NULLPE) {
        advise (NULLCP, "AlgorithmIdentifier: %s", PEPY_ERR_NOMEM);
        return NOTOK;
    }
    (*p20) = NULLPE;

    {	/* objectid */
        register OID p21;

        p21 = parm->objid ;
        if (p21 == NULLOID) {
            advise (NULLCP, "objectid %s", PEPY_ERR_INIT_FAILED);
            return NOTOK;
        }
        if (((*p20) = obj2prim (p21, PE_CLASS_UNIV, PE_PRIM_OID)) == NULLPE) {
            advise (NULLCP, "objectid: %s", PEPY_ERR_NOMEM);
            return NOTOK;
        }

#ifdef DEBUG
        (void) testdebug ((*p20), "objectid");
#endif

        {
# line 250 "SEC.py"

	    paramchoice=aux_ObjId2ParmType( parm->objid );
	    if( !(parm->parm) || (paramchoice < 0) ) paramchoice=4;
     
        }
    }

    if ((*p20) != NULLPE)
        if (seq_add ((*pe), (*p20), -1) == NOTOK) {
            advise (NULLCP, "AlgorithmIdentifier %s%s", PEPY_ERR_BAD_SEQ,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }
    (*p20) = NULLPE;

    {	/* parameters */
        int	p22;

        switch (p22 = ( paramchoice )) {
            case 1:	/* keysize */
                {
                    register integer p23 = *(rsa_parm_type *)(parm->parm) ;

                    if (((*p20) = num2prim (p23, PE_CLASS_UNIV, PE_PRIM_INT)) == NULLPE) {
                        advise (NULLCP, "keysize: %s", PEPY_ERR_NOMEM);
                        return NOTOK;
                    }

#ifdef DEBUG
                    (void) testdebug ((*p20), "keysize");
#endif

                }
                break;
            case 2:	/* desIv */
                {
                    register char *p24;
                    int p24_len;

                    p24 = ((desCBC_parm_type *)(parm->parm))->octets ;
                    p24_len = 
		       ((desCBC_parm_type *)(parm->parm))->noctets   ;
                    if (p24 == NULLCP) {
                        advise (NULLCP, "desIv %s", PEPY_ERR_INIT_FAILED);
                        return NOTOK;
                    }
                    if (((*p20) = str2prim (p24, p24_len, PE_CLASS_UNIV, PE_PRIM_OCTS)) == NULLPE) {
                        advise (NULLCP, "desIv: %s", PEPY_ERR_NOMEM);
                        return NOTOK;
                    }

#ifdef DEBUG
                    (void) testdebug ((*p20), "desIv");
#endif

                }
                break;
            case 3:	/* blocksize */
                {
                    register integer p25 = *(rsa_parm_type *)(parm->parm) ;

                    if (((*p20) = num2prim (p25, PE_CLASS_UNIV, PE_PRIM_INT)) == NULLPE) {
                        advise (NULLCP, "blocksize: %s", PEPY_ERR_NOMEM);
                        return NOTOK;
                    }

#ifdef DEBUG
                    (void) testdebug ((*p20), "blocksize");
#endif

                }
                break;
            case 4:
                {
                    if (((*p20) = pe_alloc (PE_CLASS_UNIV, PE_FORM_PRIM, PE_PRIM_NULL)) == NULLPE) {
                        advise (NULLCP, "member: %s", PEPY_ERR_NOMEM);
                        return NOTOK;
                    }

#ifdef DEBUG
                    (void) testdebug ((*p20), "member");
#endif

                }
                break;

            default:
                advise (NULLCP, "parameters %s%d", PEPY_ERR_INVALID_CHOICE, 
                        p22);
                return NOTOK;
        }

#ifdef DEBUG
        (void) testdebug ((*p20), "parameters");
#endif

    }

    if ((*p20) != NULLPE)
        if (seq_add ((*pe), (*p20), -1) == NOTOK) {
            advise (NULLCP, "AlgorithmIdentifier %s%s", PEPY_ERR_BAD_SEQ,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }

#ifdef DEBUG
    (void) testdebug ((*pe), "SEC.AlgorithmIdentifier");
#endif


    return OK;
}

/* ARGSUSED */

int	build_SEC_PSEToc (pe, explicit, len, buffer, parm)
register PE     *pe;
int	explicit;
int	len;
char   *buffer;
PSEToc * parm;
{
    PE	p26_z = NULLPE;
    register PE *p26 = &p26_z;

    if (((*pe) = pe_alloc (PE_CLASS_UNIV, PE_FORM_CONS, PE_CONS_SEQ)) == NULLPE) {
        advise (NULLCP, "PSEToc: %s", PEPY_ERR_NOMEM);
        return NOTOK;
    }
    (*p26) = NULLPE;

    {	/* owner */
        if (build_UNIV_PrintableString (p26, 0, NULL, parm->owner , NullParm) == NOTOK)
            return NOTOK;

#ifdef DEBUG
        (void) testdebug ((*p26), "owner");
#endif

    }

    if ((*p26) != NULLPE)
        if (seq_add ((*pe), (*p26), -1) == NOTOK) {
            advise (NULLCP, "PSEToc %s%s", PEPY_ERR_BAD_SEQ,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }
    (*p26) = NULLPE;

    {	/* create */
        if (build_UNIV_UTCTime (p26, 0, NULL, parm->create , NullParm) == NOTOK)
            return NOTOK;

#ifdef DEBUG
        (void) testdebug ((*p26), "create");
#endif

    }

    if ((*p26) != NULLPE)
        if (seq_add ((*pe), (*p26), -1) == NOTOK) {
            advise (NULLCP, "PSEToc %s%s", PEPY_ERR_BAD_SEQ,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }
    (*p26) = NULLPE;

    {	/* update */
        if (build_UNIV_UTCTime (p26, 0, NULL, parm->update , NullParm) == NOTOK)
            return NOTOK;

#ifdef DEBUG
        (void) testdebug ((*p26), "update");
#endif

    }

    if ((*p26) != NULLPE)
        if (seq_add ((*pe), (*p26), -1) == NOTOK) {
            advise (NULLCP, "PSEToc %s%s", PEPY_ERR_BAD_SEQ,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }
    (*p26) = NULLPE;

    if (parm -> status != 0) {	/* status */
        register integer p27 = parm->status ;

        if (((*p26) = num2prim (p27, PE_CLASS_UNIV, PE_PRIM_INT)) == NULLPE) {
            advise (NULLCP, "status: %s", PEPY_ERR_NOMEM);
            return NOTOK;
        }

#ifdef DEBUG
        (void) testdebug ((*p26), "status");
#endif

    }

    if ((*p26) != NULLPE)
        if (seq_add ((*pe), (*p26), -1) == NOTOK) {
            advise (NULLCP, "PSEToc %s%s", PEPY_ERR_BAD_SEQ,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }
    (*p26) = NULLPE;

    if ( parm->obj ) {	/* sCObjects */
        if (build_SEC_PSEObjects (p26, 0, NULL, NULLCP, parm->obj   ) == NOTOK)
            return NOTOK;

#ifdef DEBUG
        (void) testdebug ((*p26), "sCObjects");
#endif

    }

    if ((*p26) != NULLPE)
        if (seq_add ((*pe), (*p26), -1) == NOTOK) {
            advise (NULLCP, "PSEToc %s%s", PEPY_ERR_BAD_SEQ,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }

#ifdef DEBUG
    (void) testdebug ((*pe), "SEC.PSEToc");
#endif


    return OK;
}

/* ARGSUSED */

int	build_SEC_PSEObjects (pe, explicit, len, buffer, parm)
register PE     *pe;
int	explicit;
int	len;
char   *buffer;
struct PSE_Objects *  parm;
{
    PE	p28 = NULLPE;
    PE	p29_z = NULLPE;
    register PE *p29 = &p29_z;

    if (((*pe) = pe_alloc (PE_CLASS_UNIV, PE_FORM_CONS, PE_CONS_SET)) == NULLPE) {
        advise (NULLCP, "PSEObjects: %s", PEPY_ERR_NOMEM);
        return NOTOK;
    }
    for ( ; parm ; parm=parm->next ) {
        PE	p30_z = NULLPE;
        register PE *p30 = &p30_z;

        if (((*p29) = pe_alloc (PE_CLASS_UNIV, PE_FORM_CONS, PE_CONS_SEQ)) == NULLPE) {
            advise (NULLCP, "member: %s", PEPY_ERR_NOMEM);
            return NOTOK;
        }
        (*p30) = NULLPE;

        {	/* name */
            if (build_UNIV_PrintableString (p30, 0, NULL, parm->name , NullParm) == NOTOK)
                return NOTOK;

#ifdef DEBUG
            (void) testdebug ((*p30), "name");
#endif

        }

        if ((*p30) != NULLPE)
            if (seq_add ((*p29), (*p30), -1) == NOTOK) {
                advise (NULLCP, "member %s%s", PEPY_ERR_BAD_SEQ,
                        pe_error ((*p29) -> pe_errno));
                return NOTOK;
            }
        (*p30) = NULLPE;

        {	/* create */
            if (build_UNIV_UTCTime (p30, 0, NULL, parm->create , NullParm) == NOTOK)
                return NOTOK;

#ifdef DEBUG
            (void) testdebug ((*p30), "create");
#endif

        }

        if ((*p30) != NULLPE)
            if (seq_add ((*p29), (*p30), -1) == NOTOK) {
                advise (NULLCP, "member %s%s", PEPY_ERR_BAD_SEQ,
                        pe_error ((*p29) -> pe_errno));
                return NOTOK;
            }
        (*p30) = NULLPE;

        {	/* update */
            if (build_UNIV_UTCTime (p30, 0, NULL, parm->update , NullParm) == NOTOK)
                return NOTOK;

#ifdef DEBUG
            (void) testdebug ((*p30), "update");
#endif

        }

        if ((*p30) != NULLPE)
            if (seq_add ((*p29), (*p30), -1) == NOTOK) {
                advise (NULLCP, "member %s%s", PEPY_ERR_BAD_SEQ,
                        pe_error ((*p29) -> pe_errno));
                return NOTOK;
            }
        (*p30) = NULLPE;

        {	/* noOctets */
            register integer p31 = parm->noOctets ;

            if (((*p30) = num2prim (p31, PE_CLASS_UNIV, PE_PRIM_INT)) == NULLPE) {
                advise (NULLCP, "noOctets: %s", PEPY_ERR_NOMEM);
                return NOTOK;
            }
            {	/* noOctets TAG PUSHDOWN */
                PE p32_z;
                register PE *p32 = &p32_z;

                if ((*p32 = pe_alloc (PE_CLASS_CONT, PE_FORM_CONS, 0)) == NULLPE) {
                    advise (NULLCP, "noOctets: %s", PEPY_ERR_NOMEM);
                    return NOTOK;
                }
                (*p32) -> pe_cons = (*p30);
                (*p30) = *p32;
            }

#ifdef DEBUG
            (void) testdebug ((*p30), "noOctets");
#endif

        }

        if ((*p30) != NULLPE)
            if (seq_add ((*p29), (*p30), -1) == NOTOK) {
                advise (NULLCP, "member %s%s", PEPY_ERR_BAD_SEQ,
                        pe_error ((*p29) -> pe_errno));
                return NOTOK;
            }
        (*p30) = NULLPE;

        if (parm -> status != 0) {	/* status */
            register integer p33 = parm->status ;

            if (((*p30) = num2prim (p33, PE_CLASS_UNIV, PE_PRIM_INT)) == NULLPE) {
                advise (NULLCP, "status: %s", PEPY_ERR_NOMEM);
                return NOTOK;
            }
            {	/* status TAG PUSHDOWN */
                PE p34_z;
                register PE *p34 = &p34_z;

                if ((*p34 = pe_alloc (PE_CLASS_CONT, PE_FORM_CONS, 1)) == NULLPE) {
                    advise (NULLCP, "status: %s", PEPY_ERR_NOMEM);
                    return NOTOK;
                }
                (*p34) -> pe_cons = (*p30);
                (*p30) = *p34;
            }

#ifdef DEBUG
            (void) testdebug ((*p30), "status");
#endif

        }

        if ((*p30) != NULLPE)
            if (seq_add ((*p29), (*p30), -1) == NOTOK) {
                advise (NULLCP, "member %s%s", PEPY_ERR_BAD_SEQ,
                        pe_error ((*p29) -> pe_errno));
                return NOTOK;
            }

#ifdef DEBUG
        (void) testdebug ((*p29), "member");
#endif

        (void) set_addon ((*pe), p28, (*p29));
        p28 = (*p29);
    }

#ifdef DEBUG
    (void) testdebug ((*pe), "SEC.PSEObjects");
#endif


    return OK;
}

/* ARGSUSED */

int	build_SEC_PSEObject (pe, explicit, len, buffer, parm)
register PE     *pe;
int	explicit;
int	len;
char   *buffer;
PSEObject *  parm;
{
# line 295 "SEC.py"
    
	PE new_pe;
     
    PE	p35_z = NULLPE;
    register PE *p35 = &p35_z;

    if (((*pe) = pe_alloc (PE_CLASS_UNIV, PE_FORM_CONS, PE_CONS_SEQ)) == NULLPE) {
        advise (NULLCP, "PSEObject: %s", PEPY_ERR_NOMEM);
        return NOTOK;
    }
    (*p35) = NULLPE;

    {	/* type */
        register OID p36;

        p36 = parm->objectType ;
        if (p36 == NULLOID) {
            advise (NULLCP, "type %s", PEPY_ERR_INIT_FAILED);
            return NOTOK;
        }
        if (((*p35) = obj2prim (p36, PE_CLASS_UNIV, PE_PRIM_OID)) == NULLPE) {
            advise (NULLCP, "type: %s", PEPY_ERR_NOMEM);
            return NOTOK;
        }

#ifdef DEBUG
        (void) testdebug ((*p35), "type");
#endif

        {
# line 302 "SEC.py"

	    new_pe = aux_OctetString2PE(parm->objectValue);
     
        }
    }

    if ((*p35) != NULLPE)
        if (seq_add ((*pe), (*p35), -1) == NOTOK) {
            advise (NULLCP, "PSEObject %s%s", PEPY_ERR_BAD_SEQ,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }
    (*p35) = NULLPE;

    {	/* value */
        PE	p37 = new_pe ;

        if (p37 == NULLPE) {
            advise (NULLCP, "value %s", PEPY_ERR_INIT_FAILED);
            return NOTOK;
        }
        ((*p35) = p37) -> pe_refcnt++;

#ifdef DEBUG
        (void) testdebug ((*p35), "value");
#endif

        {
# line 308 "SEC.py"

			  pe_free(new_pe);
			
        }
    }

    if ((*p35) != NULLPE)
        if (seq_add ((*pe), (*p35), -1) == NOTOK) {
            advise (NULLCP, "PSEObject %s%s", PEPY_ERR_BAD_SEQ,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }

#ifdef DEBUG
    (void) testdebug ((*pe), "SEC.PSEObject");
#endif


    return OK;
}

/* ARGSUSED */

int	parse_SEC_GRAPHICString (pe, explicit, len, buffer, parm)
register PE	pe;
int	explicit;
int    *len;
char  **buffer;
char **  parm;
{
#ifdef DEBUG
    (void) testdebug (pe, "SEC.GRAPHICString");
#endif

    if (parse_UNIV_GraphicString (pe, explicit, len, &(*parm), NullParm) == NOTOK)
        return NOTOK;

    return OK;
}

/* ARGSUSED */

int	parse_SEC_RSAAlgorithm (pe, explicit, len, buffer, parm)
register PE	pe;
int	explicit;
int    *len;
char  **buffer;
KeyBits *  parm;
{
#ifdef DEBUG
    (void) testdebug (pe, "SEC.RSAAlgorithm");
#endif

    if (parse_SEC_OURINTEGER (pe, explicit, len, buffer, &parm->part2) == NOTOK)
        return NOTOK;

    return OK;
}

/* ARGSUSED */

int	parse_SEC_DSAAlgorithm (pe, explicit, len, buffer, parm)
register PE	pe;
int	explicit;
int    *len;
char  **buffer;
KeyBits *  parm;
{
    register PE p38;

#ifdef DEBUG
    (void) testdebug (pe, "SEC.DSAAlgorithm");
#endif

    if (explicit) {
        if (pe -> pe_class != PE_CLASS_UNIV
                || pe -> pe_form != PE_FORM_CONS
                || pe -> pe_id != PE_CONS_SEQ) {
            advise (NULLCP, "DSAAlgorithm bad class/form/id: %s/%d/0x%x",
                    pe_classlist[pe -> pe_class], pe -> pe_form, pe -> pe_id);
            return NOTOK;
        }
    }
    else
        if (pe -> pe_form != PE_FORM_CONS) {
            advise (NULLCP, "DSAAlgorithm bad form: %d", pe -> pe_form);
            return NOTOK;
        }

    if ((p38 = prim2seq (pe)) == NULLPE) {
        advise (NULLCP, "DSAAlgorithm %s%s", PEPY_ERR_BAD_SEQ,
                pe_error (pe -> pe_errno));
        return NOTOK;
    }
    pe = p38;

    {
        register PE p39;

        if ((p39 = first_member (pe)) != NULLPE) {
            p38 = p39;

            {	/* element TAG PULLUP */
                register PE p40;

                if ((p40 = prim2set (p39)) == NULLPE) {
                    advise (NULLCP, "prime1 %selement: %s", PEPY_ERR_BAD,
                            pe_error (p39 -> pe_errno));
                    return NOTOK;
                }
                if (p40 -> pe_cardinal != 1) {
                    advise (NULLCP, "prime1 %s element: %d", PEPY_ERR_TOO_MANY_TAGGED,
                            p40 -> pe_cardinal);
                    return NOTOK;
                }
                p39 = first_member (p40);
            }
            {	/* prime1 */
#ifdef DEBUG
                (void) testdebug (p39, "prime1");
#endif

                if (parse_SEC_OURINTEGER (p39, 1, NULLIP, NULLVP, &parm->part2) == NOTOK)
                    return NOTOK;
            }
        }
        else {
            advise (NULLCP, "DSAAlgorithm %sprime1 element", PEPY_ERR_MISSING);
            return NOTOK;
        }

    }

    {
        register PE p41;

        if ((p41 = (pe != p38 ? next_member (pe, p38) : first_member (pe))) != NULLPE) {
            p38 = p41;

            {	/* element TAG PULLUP */
                register PE p42;

                if ((p42 = prim2set (p41)) == NULLPE) {
                    advise (NULLCP, "prime2 %selement: %s", PEPY_ERR_BAD,
                            pe_error (p41 -> pe_errno));
                    return NOTOK;
                }
                if (p42 -> pe_cardinal != 1) {
                    advise (NULLCP, "prime2 %s element: %d", PEPY_ERR_TOO_MANY_TAGGED,
                            p42 -> pe_cardinal);
                    return NOTOK;
                }
                p41 = first_member (p42);
            }
            {	/* prime2 */
#ifdef DEBUG
                (void) testdebug (p41, "prime2");
#endif

                if (parse_SEC_OURINTEGER (p41, 1, NULLIP, NULLVP, &parm->part3) == NOTOK)
                    return NOTOK;
            }
        }
        else {
            advise (NULLCP, "DSAAlgorithm %sprime2 element", PEPY_ERR_MISSING);
            return NOTOK;
        }

    }

    {
        register PE p43;

        if ((p43 = (pe != p38 ? next_member (pe, p38) : first_member (pe))) != NULLPE) {
            p38 = p43;

            {	/* element TAG PULLUP */
                register PE p44;

                if ((p44 = prim2set (p43)) == NULLPE) {
                    advise (NULLCP, "base %selement: %s", PEPY_ERR_BAD,
                            pe_error (p43 -> pe_errno));
                    return NOTOK;
                }
                if (p44 -> pe_cardinal != 1) {
                    advise (NULLCP, "base %s element: %d", PEPY_ERR_TOO_MANY_TAGGED,
                            p44 -> pe_cardinal);
                    return NOTOK;
                }
                p43 = first_member (p44);
            }
            {	/* base */
#ifdef DEBUG
                (void) testdebug (p43, "base");
#endif

                if (parse_SEC_OURINTEGER (p43, 1, NULLIP, NULLVP, &parm->part4) == NOTOK)
                    return NOTOK;
            }
        }
        else {
            advise (NULLCP, "DSAAlgorithm %sbase element", PEPY_ERR_MISSING);
            return NOTOK;
        }

    }


    if (pe -> pe_cardinal > 3) {
        advise (NULLCP, "DSAAlgorithm %s(3): %d", PEPY_ERR_TOO_MANY_ELEMENTS,
                pe -> pe_cardinal);
        return NOTOK;
    }

    return OK;
}

/* ARGSUSED */

int	parse_SEC_KeyBits (pe, explicit, len, buffer, parm)
register PE	pe;
int	explicit;
int    *len;
char  **buffer;
KeyBits *  parm;
{
# line 344 "SEC.py"
    
	int i, rc;
	OctetString * ostr;
	PE parts = NULLPE;
        
    register PE p45;

#ifdef DEBUG
    (void) testdebug (pe, "SEC.KeyBits");
#endif

    if (explicit) {
        if (pe -> pe_class != PE_CLASS_UNIV
                || pe -> pe_form != PE_FORM_CONS
                || pe -> pe_id != PE_CONS_SEQ) {
            advise (NULLCP, "KeyBits bad class/form/id: %s/%d/0x%x",
                    pe_classlist[pe -> pe_class], pe -> pe_form, pe -> pe_id);
            return NOTOK;
        }
    }
    else
        if (pe -> pe_form != PE_FORM_CONS) {
            advise (NULLCP, "KeyBits bad form: %d", pe -> pe_form);
            return NOTOK;
        }

    {
# line 350 "SEC.py"

	parm->part2.noctets = 0;
	parm->part2.octets = CNULL;
	parm->part3.noctets = 0;
	parm->part3.octets = CNULL;
	parm->part4.noctets = 0;
	parm->part4.octets = CNULL;
        
    }
    if ((p45 = prim2seq (pe)) == NULLPE) {
        advise (NULLCP, "KeyBits %s%s", PEPY_ERR_BAD_SEQ,
                pe_error (pe -> pe_errno));
        return NOTOK;
    }
    pe = p45;

    {
        register PE p46;

        if ((p46 = first_member (pe)) != NULLPE) {
            p45 = p46;

            {	/* part1 */
#ifdef DEBUG
                (void) testdebug (p46, "part1");
#endif

                if (parse_SEC_OURINTEGER (p46, 1, NULLIP, NULLVP, &parm->part1) == NOTOK)
                    return NOTOK;
            }
        }
        else {
            advise (NULLCP, "KeyBits %spart1 element", PEPY_ERR_MISSING);
            return NOTOK;
        }

    }

    {
        register PE p47;

        if ((p47 = (pe != p45 ? next_member (pe, p45) : first_member (pe))) != NULLPE) {
            p45 = p47;

            {
#ifdef DEBUG
                (void) testdebug (p47, "element");
#endif

                (parts  = p47) -> pe_refcnt++;
            }
        }
    }


    if (pe -> pe_cardinal > 2) {
        advise (NULLCP, "KeyBits %s(2): %d", PEPY_ERR_TOO_MANY_ELEMENTS,
                pe -> pe_cardinal);
        return NOTOK;
    }
    {
# line 368 "SEC.py"


	if (parts) {
		ostr = aux_PE2OctetString(parts);
		if (! ostr)
			return (NOTOK);
		if (! (ostr->octets[0] & 0xCF))
			/* ostr->octets[0] = '30' */
			rc = dec_DSAAlgorithm(parts, parm);
		else
			rc = dec_RSAAlgorithm(parts, parm);
	}

	if(! (parm->part1.octets[0] | 0x00) ){    

		/* The bits of the most significant byte are all 0, so delete them */

		for ( i = 0; i < parm->part1.noctets - 1; i++)
		    parm->part1.octets[i] = parm->part1.octets[i + 1];
		parm->part1.noctets -= 1;
		parm->part1.octets = (char *)realloc(parm->part1.octets, parm->part1.noctets);
	}

	if (parm->part2.noctets > 0) {
		if (! (parm->part2.octets[0] | 0x00) ){

		    /* The bits of the most significant byte are all 0, so delete them */

		    for ( i = 0; i < parm->part2.noctets - 1; i++)
			    parm->part2.octets[i] = parm->part2.octets[i + 1];
		    parm->part2.noctets -= 1;
		    parm->part2.octets = (char *)realloc(parm->part2.octets, parm->part2.noctets);
		}
	}

	if (parm->part3.noctets > 0) {
		if (! (parm->part3.octets[0] | 0x00) ){

		    /* The bits of the most significant byte are all 0, so delete them */

		    for ( i = 0; i < parm->part3.noctets - 1; i++)
			    parm->part3.octets[i] = parm->part3.octets[i + 1];
		    parm->part3.noctets -= 1;
		    parm->part3.octets = (char *)realloc(parm->part3.octets, parm->part3.noctets);
		}
	}

	if (parm->part4.noctets > 0) {
		if (! (parm->part4.octets[0] | 0x00) ){
	
		    /* The bits of the most significant byte are all 0, so delete them */
    
		    for ( i = 0; i < parm->part4.noctets - 1; i++)
			    parm->part4.octets[i] = parm->part4.octets[i + 1];
		    parm->part4.noctets -= 1;
		    parm->part4.octets = (char *)realloc(parm->part4.octets, parm->part4.noctets);
		}
	}
	
    }

    return OK;
}

/* ARGSUSED */

int	parse_SEC_KeyInfo (pe, explicit, len, buffer, parm)
register PE	pe;
int	explicit;
int    *len;
char  **buffer;
KeyInfo *  parm;
{
    register PE p48;

#ifdef DEBUG
    (void) testdebug (pe, "SEC.KeyInfo");
#endif

    if (explicit) {
        if (pe -> pe_class != PE_CLASS_UNIV
                || pe -> pe_form != PE_FORM_CONS
                || pe -> pe_id != PE_CONS_SEQ) {
            advise (NULLCP, "KeyInfo bad class/form/id: %s/%d/0x%x",
                    pe_classlist[pe -> pe_class], pe -> pe_form, pe -> pe_id);
            return NOTOK;
        }
    }
    else
        if (pe -> pe_form != PE_FORM_CONS) {
            advise (NULLCP, "KeyInfo bad form: %d", pe -> pe_form);
            return NOTOK;
        }

    if ((p48 = prim2seq (pe)) == NULLPE) {
        advise (NULLCP, "KeyInfo %s%s", PEPY_ERR_BAD_SEQ,
                pe_error (pe -> pe_errno));
        return NOTOK;
    }
    pe = p48;

    {
        register PE p49;

        if ((p49 = first_member (pe)) != NULLPE) {
            p48 = p49;

            {	/* algorithm */
#ifdef DEBUG
                (void) testdebug (p49, "algorithm");
#endif

                if (parse_SEC_AlgorithmIdentifier (p49, 1, NULLIP, NULLVP, &parm->subjectAI ) == NOTOK)
                    return NOTOK;
            }
        }
        else {
            advise (NULLCP, "KeyInfo %salgorithm element", PEPY_ERR_MISSING);
            return NOTOK;
        }

    }

    {
        register PE p50;

        if ((p50 = (pe != p48 ? next_member (pe, p48) : first_member (pe))) != NULLPE) {
            p48 = p50;

            {	/* key */
                register PE p51;

#ifdef DEBUG
                (void) testdebug (p50, "key");
#endif

                if (p50 -> pe_class != PE_CLASS_UNIV || p50 -> pe_id != PE_PRIM_BITS) {
                    advise (NULLCP, "key bad class/form/id: %s/%d/0x%x",
                            pe_classlist[p50 -> pe_class], p50 -> pe_form, p50 -> pe_id);
                    return NOTOK;
                }

                if ((p51 = prim2bit (p50)) == NULLPE) {
                    advise (NULLCP, "key %s%s", PEPY_ERR_BAD_BITS,
                            pe_error (p50 -> pe_errno));
                    return NOTOK;
                }
                parm->subjectkey.bits  = bitstr2strb (p50, &(
			     parm->subjectkey.nbits ));
            }
        }
        else {
            advise (NULLCP, "KeyInfo %skey element", PEPY_ERR_MISSING);
            return NOTOK;
        }

    }


    if (pe -> pe_cardinal > 2) {
        advise (NULLCP, "KeyInfo %s(2): %d", PEPY_ERR_TOO_MANY_ELEMENTS,
                pe -> pe_cardinal);
        return NOTOK;
    }

    return OK;
}

/* ARGSUSED */

int	parse_SEC_DigestInfo (pe, explicit, len, buffer, parm)
register PE	pe;
int	explicit;
int    *len;
char  **buffer;
DigestInfo *  parm;
{
    register PE p52;

#ifdef DEBUG
    (void) testdebug (pe, "SEC.DigestInfo");
#endif

    if (explicit) {
        if (pe -> pe_class != PE_CLASS_UNIV
                || pe -> pe_form != PE_FORM_CONS
                || pe -> pe_id != PE_CONS_SEQ) {
            advise (NULLCP, "DigestInfo bad class/form/id: %s/%d/0x%x",
                    pe_classlist[pe -> pe_class], pe -> pe_form, pe -> pe_id);
            return NOTOK;
        }
    }
    else
        if (pe -> pe_form != PE_FORM_CONS) {
            advise (NULLCP, "DigestInfo bad form: %d", pe -> pe_form);
            return NOTOK;
        }

    if ((p52 = prim2seq (pe)) == NULLPE) {
        advise (NULLCP, "DigestInfo %s%s", PEPY_ERR_BAD_SEQ,
                pe_error (pe -> pe_errno));
        return NOTOK;
    }
    pe = p52;

    {
        register PE p53;

        if ((p53 = first_member (pe)) != NULLPE) {
            p52 = p53;

            {	/* digestai */
#ifdef DEBUG
                (void) testdebug (p53, "digestai");
#endif

                if (parse_SEC_AlgorithmIdentifier (p53, 1, NULLIP, NULLVP, &parm->digestAI ) == NOTOK)
                    return NOTOK;
            }
        }
        else {
            advise (NULLCP, "DigestInfo %sdigestai element", PEPY_ERR_MISSING);
            return NOTOK;
        }

    }

    {
        register PE p54;

        if ((p54 = (pe != p52 ? next_member (pe, p52) : first_member (pe))) != NULLPE) {
            p52 = p54;

            {	/* digest */
                register char *p55;
                int p55_len;

#ifdef DEBUG
                (void) testdebug (p54, "digest");
#endif

                if (p54 -> pe_class != PE_CLASS_UNIV || p54 -> pe_id != PE_PRIM_OCTS) {
                    advise (NULLCP, "digest bad class/form/id: %s/%d/0x%x",
                            pe_classlist[p54 -> pe_class], p54 -> pe_form, p54 -> pe_id);
                    return NOTOK;
                }

                if ((p55 = prim2str (p54, &p55_len)) == NULLCP) {
                    advise (NULLCP, "digest %s%s", PEPY_ERR_BAD_OCTET,
                            pe_error (p54 -> pe_errno));
                    return NOTOK;
                }
                parm->digest.octets  = p55;
                
			     parm->digest.noctets  = p55_len;
            }
        }
        else {
            advise (NULLCP, "DigestInfo %sdigest element", PEPY_ERR_MISSING);
            return NOTOK;
        }

    }


    if (pe -> pe_cardinal > 2) {
        advise (NULLCP, "DigestInfo %s(2): %d", PEPY_ERR_TOO_MANY_ELEMENTS,
                pe -> pe_cardinal);
        return NOTOK;
    }

    return OK;
}

/* ARGSUSED */

int	parse_SEC_EncryptedKey (pe, explicit, len, buffer, parm)
register PE	pe;
int	explicit;
int    *len;
char  **buffer;
EncryptedKey *  parm;
{
    register PE p56;

#ifdef DEBUG
    (void) testdebug (pe, "SEC.EncryptedKey");
#endif

    if (explicit) {
        if (pe -> pe_class != PE_CLASS_UNIV
                || pe -> pe_form != PE_FORM_CONS
                || pe -> pe_id != PE_CONS_SEQ) {
            advise (NULLCP, "EncryptedKey bad class/form/id: %s/%d/0x%x",
                    pe_classlist[pe -> pe_class], pe -> pe_form, pe -> pe_id);
            return NOTOK;
        }
    }
    else
        if (pe -> pe_form != PE_FORM_CONS) {
            advise (NULLCP, "EncryptedKey bad form: %d", pe -> pe_form);
            return NOTOK;
        }

    if ((p56 = prim2seq (pe)) == NULLPE) {
        advise (NULLCP, "EncryptedKey %s%s", PEPY_ERR_BAD_SEQ,
                pe_error (pe -> pe_errno));
        return NOTOK;
    }
    pe = p56;

    {
        register PE p57;

        if ((p57 = first_member (pe)) != NULLPE) {
            p56 = p57;

            {	/* algorithm */
#ifdef DEBUG
                (void) testdebug (p57, "algorithm");
#endif

                if (parse_SEC_AlgorithmIdentifier (p57, 1, NULLIP, NULLVP, &parm->encryptionAI ) == NOTOK)
                    return NOTOK;
            }
        }
        else {
            advise (NULLCP, "EncryptedKey %salgorithm element", PEPY_ERR_MISSING);
            return NOTOK;
        }

    }

    {
        register PE p58;

        if ((p58 = (pe != p56 ? next_member (pe, p56) : first_member (pe))) != NULLPE) {
            p56 = p58;

            {	/* algorithm */
#ifdef DEBUG
                (void) testdebug (p58, "algorithm");
#endif

                if (parse_SEC_AlgorithmIdentifier (p58, 1, NULLIP, NULLVP, &parm->subjectAI ) == NOTOK)
                    return NOTOK;
            }
        }
        else {
            advise (NULLCP, "EncryptedKey %salgorithm element", PEPY_ERR_MISSING);
            return NOTOK;
        }

    }

    {
        register PE p59;

        if ((p59 = (pe != p56 ? next_member (pe, p56) : first_member (pe))) != NULLPE) {
            p56 = p59;

            {	/* key */
                register PE p60;

#ifdef DEBUG
                (void) testdebug (p59, "key");
#endif

                if (p59 -> pe_class != PE_CLASS_UNIV || p59 -> pe_id != PE_PRIM_BITS) {
                    advise (NULLCP, "key bad class/form/id: %s/%d/0x%x",
                            pe_classlist[p59 -> pe_class], p59 -> pe_form, p59 -> pe_id);
                    return NOTOK;
                }

                if ((p60 = prim2bit (p59)) == NULLPE) {
                    advise (NULLCP, "key %s%s", PEPY_ERR_BAD_BITS,
                            pe_error (p59 -> pe_errno));
                    return NOTOK;
                }
                parm->subjectkey.bits  = bitstr2strb (p59, &(
			     parm->subjectkey.nbits ));
            }
        }
        else {
            advise (NULLCP, "EncryptedKey %skey element", PEPY_ERR_MISSING);
            return NOTOK;
        }

    }


    if (pe -> pe_cardinal > 3) {
        advise (NULLCP, "EncryptedKey %s(3): %d", PEPY_ERR_TOO_MANY_ELEMENTS,
                pe -> pe_cardinal);
        return NOTOK;
    }

    return OK;
}

/* ARGSUSED */

int	parse_SEC_AlgorithmIdentifier (pe, explicit, len, buffer, parm)
register PE	pe;
int	explicit;
int    *len;
char  **buffer;
AlgId **  parm;
{
# line 466 "SEC.py"
    
	int paramchoice, keyorblocksize;
	PE  errorparm;
	rsa_parm_type     *rsa_parm;
	desCBC_parm_type *des_parm;
    
    register PE p61;

#ifdef DEBUG
    (void) testdebug (pe, "SEC.AlgorithmIdentifier");
#endif

    if (explicit) {
        if (pe -> pe_class != PE_CLASS_UNIV
                || pe -> pe_form != PE_FORM_CONS
                || pe -> pe_id != PE_CONS_SEQ) {
            advise (NULLCP, "AlgorithmIdentifier bad class/form/id: %s/%d/0x%x",
                    pe_classlist[pe -> pe_class], pe -> pe_form, pe -> pe_id);
            return NOTOK;
        }
    }
    else
        if (pe -> pe_form != PE_FORM_CONS) {
            advise (NULLCP, "AlgorithmIdentifier bad form: %d", pe -> pe_form);
            return NOTOK;
        }

    {
# line 473 "SEC.py"

        if ((*(parm) = (AlgId *)
                calloc (1, sizeof **(parm))) == ((AlgId *) 0)) {
            advise (NULLCP, "out of memory");
            return NOTOK;
        }
    
    }
    if ((p61 = prim2seq (pe)) == NULLPE) {
        advise (NULLCP, "AlgorithmIdentifier %s%s", PEPY_ERR_BAD_SEQ,
                pe_error (pe -> pe_errno));
        return NOTOK;
    }
    pe = p61;

    {
        register PE p62;

        if ((p62 = first_member (pe)) != NULLPE) {
            p61 = p62;

            {	/* objectid */
                register OID p63;

#ifdef DEBUG
                (void) testdebug (p62, "objectid");
#endif

                if (p62 -> pe_class != PE_CLASS_UNIV
                        || p62 -> pe_form != PE_FORM_PRIM
                        || p62 -> pe_id != PE_PRIM_OID) {
                    advise (NULLCP, "objectid bad class/form/id: %s/%d/0x%x",
                            pe_classlist[p62 -> pe_class], p62 -> pe_form, p62 -> pe_id);
                    return NOTOK;
                }

                if ((p63 = prim2oid (p62)) == NULLOID) {
                    advise (NULLCP, "objectid %s%s", PEPY_ERR_BAD_OID,
                            pe_error (p62 -> pe_errno));
                    return NOTOK;
                }
                (*parm)->objid  = oid_cpy (p63);
                {
# line 484 "SEC.py"

	    (*parm)->parm = (char *)0;
	    paramchoice=aux_ObjId2ParmType( (*parm)->objid );
	    if( paramchoice<0 ) paramchoice=4;
	    errorparm=int2prim(0); /*set errorparm to 0-INTEGER*/
	    des_parm=(desCBC_parm_type *)malloc(sizeof(desCBC_parm_type));
     
                }
            }
        }
        else {
            advise (NULLCP, "AlgorithmIdentifier %sobjectid element", PEPY_ERR_MISSING);
            return NOTOK;
        }

    }

    {
        register PE p64;

        if ((p64 = (pe != p61 ? next_member (pe, p61) : first_member (pe))) != NULLPE) {
            p61 = p64;

            {	/* parameters */
#ifdef DEBUG
                (void) testdebug (p64, "parameters");
#endif

                switch (PE_ID (p64 -> pe_class, p64 -> pe_id)) {
                    case PE_ID (PE_CLASS_UNIV, 2):	/* keysize */
                        {
                            register integer p65;

#ifdef DEBUG
                            (void) testdebug (p64, "keysize");
#endif

                            if ((p65 = prim2num (p64)) == NOTOK
                                    && p64 -> pe_errno != PE_ERR_NONE) {
                                advise (NULLCP, "keysize %s%s", PEPY_ERR_BAD_INTEGER,
                                        pe_error (p64 -> pe_errno));
                                return NOTOK;
                            }
                            keyorblocksize  = p65;
                            {
# line 496 "SEC.py"

		  free( des_parm );
		  if( paramchoice == 1) { /*RSA:*/
		     rsa_parm=(rsa_parm_type *)malloc(sizeof(rsa_parm_type));
		     *rsa_parm=keyorblocksize;
		     (*parm)->parm=(char *)rsa_parm;
		     }
		  else if( paramchoice == 3) { /*Hash:*/
		     rsa_parm=(rsa_parm_type *)malloc(sizeof(rsa_parm_type));
		     *rsa_parm=keyorblocksize;
		     (*parm)->parm=(char *)rsa_parm;
		     }
		   else { /*erraneous parameter:*/
		     (*parm)->parm = (char *)0;
		     }
     
                            }
                        }
                        break;
                    case PE_ID (PE_CLASS_UNIV, 4):
                        {
                            register char *p66;
                            int p66_len;

#ifdef DEBUG
                            (void) testdebug (p64, "member");
#endif

                            if ((p66 = prim2str (p64, &p66_len)) == NULLCP) {
                                advise (NULLCP, "member %s%s", PEPY_ERR_BAD_OCTET,
                                        pe_error (p64 -> pe_errno));
                                return NOTOK;
                            }
                            des_parm->octets  = p66;
                             des_parm->noctets  = p66_len;
                            {
# line 515 "SEC.py"

		  (*parm)->parm=(char *)des_parm;
     
                            }
                                /* do nothing */;
                        }
                        break;
                    default:
                        {
#ifdef DEBUG
                            (void) testdebug (p64, "member");
#endif

                            (errorparm  = p64) -> pe_refcnt++;
                            {
# line 521 "SEC.py"

		  (*parm)->parm = (char *)0;
		  free( des_parm );
     
                            }
                        }
                        break;
                }
            }
        }
    }


    if (pe -> pe_cardinal > 2) {
        advise (NULLCP, "AlgorithmIdentifier %s(2): %d", PEPY_ERR_TOO_MANY_ELEMENTS,
                pe -> pe_cardinal);
        return NOTOK;
    }

    return OK;
}

/* ARGSUSED */

int	parse_SEC_PSEToc (pe, explicit, len, buffer, parm)
register PE	pe;
int	explicit;
int    *len;
char  **buffer;
PSEToc * parm;
{
    register PE p67;

#ifdef DEBUG
    (void) testdebug (pe, "SEC.PSEToc");
#endif

    if (explicit) {
        if (pe -> pe_class != PE_CLASS_UNIV
                || pe -> pe_form != PE_FORM_CONS
                || pe -> pe_id != PE_CONS_SEQ) {
            advise (NULLCP, "PSEToc bad class/form/id: %s/%d/0x%x",
                    pe_classlist[pe -> pe_class], pe -> pe_form, pe -> pe_id);
            return NOTOK;
        }
    }
    else
        if (pe -> pe_form != PE_FORM_CONS) {
            advise (NULLCP, "PSEToc bad form: %d", pe -> pe_form);
            return NOTOK;
        }

    {
# line 531 "SEC.py"

	      parm->obj=(struct PSE_Objects *)0;
	      parm->status = 0;
	    
    }
    if ((p67 = prim2seq (pe)) == NULLPE) {
        advise (NULLCP, "PSEToc %s%s", PEPY_ERR_BAD_SEQ,
                pe_error (pe -> pe_errno));
        return NOTOK;
    }
    pe = p67;

    {
        register PE p68;

        if ((p68 = first_member (pe)) != NULLPE) {
            p67 = p68;

            {	/* owner */
#ifdef DEBUG
                (void) testdebug (p68, "owner");
#endif

                if (parse_UNIV_PrintableString (p68, 1, NULLIP, &(parm->owner ), NullParm) == NOTOK)
                    return NOTOK;
            }
        }
        else {
            advise (NULLCP, "PSEToc %sowner element", PEPY_ERR_MISSING);
            return NOTOK;
        }

    }

    {
        register PE p69;

        if ((p69 = (pe != p67 ? next_member (pe, p67) : first_member (pe))) != NULLPE) {
            p67 = p69;

            {	/* create */
#ifdef DEBUG
                (void) testdebug (p69, "create");
#endif

                if (parse_UNIV_UTCTime (p69, 1, NULLIP, &(parm->create ), NullParm) == NOTOK)
                    return NOTOK;
            }
        }
        else {
            advise (NULLCP, "PSEToc %screate element", PEPY_ERR_MISSING);
            return NOTOK;
        }

    }

    {
        register PE p70;

        if ((p70 = (pe != p67 ? next_member (pe, p67) : first_member (pe))) != NULLPE) {
            p67 = p70;

            {	/* update */
#ifdef DEBUG
                (void) testdebug (p70, "update");
#endif

                if (parse_UNIV_UTCTime (p70, 1, NULLIP, &(parm->update ), NullParm) == NOTOK)
                    return NOTOK;
            }
        }
        else {
            advise (NULLCP, "PSEToc %supdate element", PEPY_ERR_MISSING);
            return NOTOK;
        }

    }

    {
        register PE p71;

        if ((p71 = (pe != p67 ? next_member (pe, p67) : first_member (pe))) 
                    != NULLPE
                && PE_ID (p71 -> pe_class, p71 -> pe_id)
                        != PE_ID (PE_CLASS_UNIV, 2))
            p71 = NULLPE;
        if (p71 != NULLPE) {
            p67 = p71;

            {	/* status */
                register integer p72;

#ifdef DEBUG
                (void) testdebug (p71, "status");
#endif

                if (p71 -> pe_class != PE_CLASS_UNIV
                        || p71 -> pe_form != PE_FORM_PRIM
                        || p71 -> pe_id != PE_PRIM_INT) {
                    advise (NULLCP, "status bad class/form/id: %s/%d/0x%x",
                            pe_classlist[p71 -> pe_class], p71 -> pe_form, p71 -> pe_id);
                    return NOTOK;
                }

                if ((p72 = prim2num (p71)) == NOTOK
                        && p71 -> pe_errno != PE_ERR_NONE) {
                    advise (NULLCP, "status %s%s", PEPY_ERR_BAD_INTEGER,
                            pe_error (p71 -> pe_errno));
                    return NOTOK;
                }
                parm->status  = p72;
            }
        }
    }

    {
        register PE p73;

        if ((p73 = (pe != p67 ? next_member (pe, p67) : first_member (pe))) != NULLPE) {
            p67 = p73;

            {	/* sCObjects */
#ifdef DEBUG
                (void) testdebug (p73, "sCObjects");
#endif

                if (parse_SEC_PSEObjects (p73, 1, NULLIP, NULLVP, &(parm->obj) ) == NOTOK)
                    return NOTOK;
            }
        }
    }


    if (pe -> pe_cardinal > 5) {
        advise (NULLCP, "PSEToc %s(5): %d", PEPY_ERR_TOO_MANY_ELEMENTS,
                pe -> pe_cardinal);
        return NOTOK;
    }

    return OK;
}

/* ARGSUSED */

int	parse_SEC_PSEObjects (pe, explicit, len, buffer, parm)
register PE	pe;
int	explicit;
int    *len;
char  **buffer;
struct PSE_Objects **  parm;
{
    register PE p74;

#ifdef DEBUG
    (void) testdebug (pe, "SEC.PSEObjects");
#endif

    if (explicit) {
        if (pe -> pe_class != PE_CLASS_UNIV
                || pe -> pe_form != PE_FORM_CONS
                || pe -> pe_id != PE_CONS_SET) {
            advise (NULLCP, "PSEObjects bad class/form/id: %s/%d/0x%x",
                    pe_classlist[pe -> pe_class], pe -> pe_form, pe -> pe_id);
            return NOTOK;
        }
    }
    else
        if (pe -> pe_form != PE_FORM_CONS) {
            advise (NULLCP, "PSEObjects bad form: %d", pe -> pe_form);
            return NOTOK;
        }

    if ((p74 = prim2set (pe)) == NULLPE) {
        advise (NULLCP, "PSEObjects %s%s", PEPY_ERR_BAD_SET,
                pe_error (pe -> pe_errno));
        return NOTOK;
    }
    pe = p74;

    for (p74 = first_member (pe); p74; p74 = next_member (pe, p74)) {
        {
# line 546 "SEC.py"

	      if( (*parm=(struct PSE_Objects *)malloc(sizeof(struct PSE_Objects)))
		  == (struct PSE_Objects *)0 ){
		    advise (NULLCP, "out of memory");
		    return( NOTOK );
		    }
	      (*parm)->noOctets = 0;
	      (*parm)->status = 0;
	      (*parm)->next=(struct PSE_Objects *)0;
	    
        }
        {
            register PE p75;

#ifdef DEBUG
            (void) testdebug (p74, "member");
#endif

            if (p74 -> pe_class != PE_CLASS_UNIV
                    || p74 -> pe_form != PE_FORM_CONS
                    || p74 -> pe_id != PE_CONS_SEQ) {
                advise (NULLCP, "member bad class/form/id: %s/%d/0x%x",
                        pe_classlist[p74 -> pe_class], p74 -> pe_form, p74 -> pe_id);
                return NOTOK;
            }

            if ((p75 = prim2seq (p74)) == NULLPE) {
                advise (NULLCP, "member %s%s", PEPY_ERR_BAD_SEQ,
                        pe_error (p74 -> pe_errno));
                return NOTOK;
            }
            p74 = p75;

            {
                register PE p76;

                if ((p76 = first_member (p74)) != NULLPE) {
                    p75 = p76;

                    {	/* name */
#ifdef DEBUG
                        (void) testdebug (p76, "name");
#endif

                        if (parse_UNIV_PrintableString (p76, 1, NULLIP, &((*parm)->name ), NullParm) == NOTOK)
                            return NOTOK;
                    }
                }
                else {
                    advise (NULLCP, "member %sname element", PEPY_ERR_MISSING);
                    return NOTOK;
                }

            }

            {
                register PE p77;

                if ((p77 = (p74 != p75 ? next_member (p74, p75) : first_member (p74))) != NULLPE) {
                    p75 = p77;

                    {	/* create */
#ifdef DEBUG
                        (void) testdebug (p77, "create");
#endif

                        if (parse_UNIV_UTCTime (p77, 1, NULLIP, &((*parm)->create ), NullParm) == NOTOK)
                            return NOTOK;
                    }
                }
                else {
                    advise (NULLCP, "member %screate element", PEPY_ERR_MISSING);
                    return NOTOK;
                }

            }

            {
                register PE p78;

                if ((p78 = (p74 != p75 ? next_member (p74, p75) : first_member (p74))) != NULLPE) {
                    p75 = p78;

                    {	/* update */
#ifdef DEBUG
                        (void) testdebug (p78, "update");
#endif

                        if (parse_UNIV_UTCTime (p78, 1, NULLIP, &((*parm)->update ), NullParm) == NOTOK)
                            return NOTOK;
                    }
                }
                else {
                    advise (NULLCP, "member %supdate element", PEPY_ERR_MISSING);
                    return NOTOK;
                }

            }

            {
                register PE p79;

                if ((p79 = (p74 != p75 ? next_member (p74, p75) : first_member (p74))) 
                            != NULLPE
                        && PE_ID (p79 -> pe_class, p79 -> pe_id)
                                != PE_ID (PE_CLASS_CONT, 0))
                    p79 = NULLPE;
                if (p79 != NULLPE) {
                    p75 = p79;

                    {	/* element TAG PULLUP */
                        register PE p80;

                        if ((p80 = prim2set (p79)) == NULLPE) {
                            advise (NULLCP, "noOctets %selement: %s", PEPY_ERR_BAD,
                                    pe_error (p79 -> pe_errno));
                            return NOTOK;
                        }
                        if (p80 -> pe_cardinal != 1) {
                            advise (NULLCP, "noOctets %s element: %d", PEPY_ERR_TOO_MANY_TAGGED,
                                    p80 -> pe_cardinal);
                            return NOTOK;
                        }
                        p79 = first_member (p80);
                    }
                    {	/* noOctets */
                        register integer p81;

#ifdef DEBUG
                        (void) testdebug (p79, "noOctets");
#endif

                        if (p79 -> pe_class != PE_CLASS_UNIV
                                || p79 -> pe_form != PE_FORM_PRIM
                                || p79 -> pe_id != PE_PRIM_INT) {
                            advise (NULLCP, "noOctets bad class/form/id: %s/%d/0x%x",
                                    pe_classlist[p79 -> pe_class], p79 -> pe_form, p79 -> pe_id);
                            return NOTOK;
                        }

                        if ((p81 = prim2num (p79)) == NOTOK
                                && p79 -> pe_errno != PE_ERR_NONE) {
                            advise (NULLCP, "noOctets %s%s", PEPY_ERR_BAD_INTEGER,
                                    pe_error (p79 -> pe_errno));
                            return NOTOK;
                        }
                        (*parm)->noOctets  = p81;
                    }
                }
            }

            {
                register PE p82;

                if ((p82 = (p74 != p75 ? next_member (p74, p75) : first_member (p74))) != NULLPE) {
                    p75 = p82;

                    {	/* element TAG PULLUP */
                        register PE p83;

                        if ((p83 = prim2set (p82)) == NULLPE) {
                            advise (NULLCP, "status %selement: %s", PEPY_ERR_BAD,
                                    pe_error (p82 -> pe_errno));
                            return NOTOK;
                        }
                        if (p83 -> pe_cardinal != 1) {
                            advise (NULLCP, "status %s element: %d", PEPY_ERR_TOO_MANY_TAGGED,
                                    p83 -> pe_cardinal);
                            return NOTOK;
                        }
                        p82 = first_member (p83);
                    }
                    {	/* status */
                        register integer p84;

#ifdef DEBUG
                        (void) testdebug (p82, "status");
#endif

                        if (p82 -> pe_class != PE_CLASS_UNIV
                                || p82 -> pe_form != PE_FORM_PRIM
                                || p82 -> pe_id != PE_PRIM_INT) {
                            advise (NULLCP, "status bad class/form/id: %s/%d/0x%x",
                                    pe_classlist[p82 -> pe_class], p82 -> pe_form, p82 -> pe_id);
                            return NOTOK;
                        }

                        if ((p84 = prim2num (p82)) == NOTOK
                                && p82 -> pe_errno != PE_ERR_NONE) {
                            advise (NULLCP, "status %s%s", PEPY_ERR_BAD_INTEGER,
                                    pe_error (p82 -> pe_errno));
                            return NOTOK;
                        }
                        (*parm)->status  = p84;
                    }
                }
            }


            if (p74 -> pe_cardinal > 5) {
                advise (NULLCP, "member %s(5): %d", PEPY_ERR_TOO_MANY_ELEMENTS,
                        p74 -> pe_cardinal);
                return NOTOK;
            }
            {
# line 565 "SEC.py"

	      parm = &((*parm)->next);
	    
            }
        }
    }

    return OK;
}

/* ARGSUSED */

int	parse_SEC_PSEObject (pe, explicit, len, buffer, parm)
register PE	pe;
int	explicit;
int    *len;
char  **buffer;
PSEObject *  parm;
{
# line 570 "SEC.py"
    
PE any = NULLPE;

    register PE p85;

#ifdef DEBUG
    (void) testdebug (pe, "SEC.PSEObject");
#endif

    if (explicit) {
        if (pe -> pe_class != PE_CLASS_UNIV
                || pe -> pe_form != PE_FORM_CONS
                || pe -> pe_id != PE_CONS_SEQ) {
            advise (NULLCP, "PSEObject bad class/form/id: %s/%d/0x%x",
                    pe_classlist[pe -> pe_class], pe -> pe_form, pe -> pe_id);
            return NOTOK;
        }
    }
    else
        if (pe -> pe_form != PE_FORM_CONS) {
            advise (NULLCP, "PSEObject bad form: %d", pe -> pe_form);
            return NOTOK;
        }

    if ((p85 = prim2seq (pe)) == NULLPE) {
        advise (NULLCP, "PSEObject %s%s", PEPY_ERR_BAD_SEQ,
                pe_error (pe -> pe_errno));
        return NOTOK;
    }
    pe = p85;

    {
        register PE p86;

        if ((p86 = first_member (pe)) != NULLPE) {
            p85 = p86;

            {	/* type */
                register OID p87;

#ifdef DEBUG
                (void) testdebug (p86, "type");
#endif

                if (p86 -> pe_class != PE_CLASS_UNIV
                        || p86 -> pe_form != PE_FORM_PRIM
                        || p86 -> pe_id != PE_PRIM_OID) {
                    advise (NULLCP, "type bad class/form/id: %s/%d/0x%x",
                            pe_classlist[p86 -> pe_class], p86 -> pe_form, p86 -> pe_id);
                    return NOTOK;
                }

                if ((p87 = prim2oid (p86)) == NULLOID) {
                    advise (NULLCP, "type %s%s", PEPY_ERR_BAD_OID,
                            pe_error (p86 -> pe_errno));
                    return NOTOK;
                }
                parm->objectType  = oid_cpy (p87);
            }
        }
        else {
            advise (NULLCP, "PSEObject %stype element", PEPY_ERR_MISSING);
            return NOTOK;
        }

    }

    {
        register PE p88;

        if ((p88 = (pe != p85 ? next_member (pe, p85) : first_member (pe))) != NULLPE) {
            p85 = p88;

            {	/* value */
#ifdef DEBUG
                (void) testdebug (p88, "value");
#endif

                (any  = p88) -> pe_refcnt++;
                {
# line 580 "SEC.py"

			  parm->objectValue = aux_PE2OctetString(any);
			  pe_free(any);
			
                }
            }
        }
        else {
            advise (NULLCP, "PSEObject %svalue element", PEPY_ERR_MISSING);
            return NOTOK;
        }

    }


    if (pe -> pe_cardinal > 2) {
        advise (NULLCP, "PSEObject %s(2): %d", PEPY_ERR_TOO_MANY_ELEMENTS,
                pe -> pe_cardinal);
        return NOTOK;
    }

    return OK;
}
