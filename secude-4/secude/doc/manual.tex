\nm{1}{INTRO}{Introduction to SecuDE}
\label{intro1}
\hl{Description}
{\bf General Introduction}
\\ [1em]
The contribution of SecuDE to public domain is part of our effort to 
facilitate the open, authentic and privacy-protected electronic 
telecooperation between people through using public key cryptography and openly 
available security technology. Providing authenticity and protecting the 
privacy is an increasing concern of everyone as electronic information 
storage and exchange is rapidly growing. This can be done only with publicly known
security technology of which the effectiveness is understandable and 
comprehensible through public control. Security must only rely on the secrecy
of keys, not on the secrecy of methods. 
\\ [1em]
SecuDE (Security Development Environment) is a security toolkit for
Unix systems. It comprises a library of security functions and a
number of utilities with the following functionality:
\bi
\m basic cryptographic functions like RSA, DSA, DES, various hash functions, 
   including the RFC 1423 defined algorithm suite, 
   OIW defined algorithms, and DSS,

\m security functions for {\em data confidentiality}, {\em data integrity}, 
   {\em origin authentication} and {\em non-repudation of origin} purposes 
   on the basis of digital signatures and symmetric encryption,

\m X.509 key certification functions, handling of certification pathes, 
   cross-certification, certificate revocation,

\m utilities and functions for the operation of certification authorities 
   (CA) and interaction between certifying CAs and certified users,

\m utilities to sign, verify, encrypt, decrypt and hash files,

\m Internet PEM processing according to RFC 1421 - 1424 (see~\ref{pem})

\m processing of RFC 1422-defined certificate revocation lists,

\m secure access to public X.500 security attributes for the storage 
   and retrieval of certificates, cross-certificates and revocation 
   lists (integrated secured DUA, based on QUIPU 8.0, using strong 
   authentication and signed DAP operations, see~\ref{x500}),

\m all necessary ASN.1 encoding/decoding (based on Isode-8.0)

\m integrity-protected and confidentiality-protected storage of all security 
   relevant information of a user (secret keys, verification keys, certifiactes
   etc.) in a so called {\em Personal Security Environment} (PSE).
\ei
 
SecuDE provides two different PSE realizations,
\bi 
\m a smartcard environment (SC-PSE), 
\m a DES-encrypted Unix directory (laxly called software-PSE or SW-PSE),
\ei 
both only accessible through the usage of PINs (Personal Identification Numbers).
Smartcards require the purchase of a particular smartcard environment where 
RSA and DES cryptography is done in the smartcard reader (information available 
on request).
The PSE typically contains the user's secret and public key (the latter
contained in an X.509 certificate), the public root key which the user
trusts, the user's distinguished name, the user's login name, and the 
forward certification path to the user's root CA. In addition, the PSE 
allows to securely store other public keys after their validation 
(allowing henceforth to trust them like the root key without verifying 
them again), and certificate revocation lists (CRLs) from any other CA.
\\ [1em]
{\bf SecuDE PEM}

A PEM implementation is part of SecuDE. It provides a PEM filter
which transforms any input stream into a PEM formatted output stream 
and vice versa, and which should be capable of being  easily 
integrated into Mail-UAs or CA tools.SecuDE-PEM realizes all formats 
and procedures defined in the Internet Specifications RFC 1421-1424 
except that it only supports asymmetric key management. It is
possible to securely cache other's certificates and CRLs as this 
is part of the general SecuDE functionality.

SecuDE-PEM supports the certification and CRL procedures defined in RFC 
1424 and is integrated into the SecuDE CA functionality. As an additional 
functionality which goes beyond RFC 1421 - 1424, SecuDE-PEM may be 
configured with an integrated X.500 DUA which allows, for instance, 
automatic retrieval of certificates and CRLs during the PEM de-enhancement 
process.  
\\ [1em]
{\bf X.500 Package}

Secured X.500 DUA

Concerning X.500 Directory access, SecuDE can be configured in three 
alternatives:
\be
\m Without X.500 DUA functionality. In this case, the SecuDE package
   is self-contained and needs no additional software.

\m With integrated X.500 DUA, which operates on the basis of simple
   authentication (i.e. with passwords) and unprotected DAP operations.
   SecuDE uses QUIPU-8.0 library functions for this DUA functionality.
   These library functions are not included in the SecuDE package, and
   a standard QUIPU-8.0 installation is additionally required (the 
   Isode/QUIPU libraries libisode.a and libdsap.a are needed to be able 
   to bind the application programs).

\m With integrated secured X.500 DUA, which operates on the basis of
   strong authentication (i.e. with digital signatures) and signed DAP
   operations.
   SecuDE uses modified (i.e. security-enhanced) QUIPU-8.0 library 
   functions for this DUA functionality. These library functions are not 
   included in the SecuDE package, and a security-enhanced QUIPU-8.0 
   installation is additionally required (the security-enhanced 
   Isode/QUIPU libraries libisode.a and libdsap.a are needed to be able 
   to bind the application programs).
\ee

Alternative 3 requires a security-enhanced version of Quipu which can
be obtained as a separate distribution from GMD. 
\\ [1em]
Secured X.500 DSA

The security-enhanced version of Quipu also contains software for a secured 
X.500 DSA. ``Secured'' means the ability to perform strong authentication 
during association setup between DUA and DSA, and subsequent signed 
operations at the DAP level. The DAP operations into which we have 
incorporated strong authentication are those assigned by the standard 
(X.511) for that purpose, i.e. Bind, Read, Compare, Search, List, AddEntry,
RemoveEntry, ModifyEntry, and ModifyRDN. We have provided both SIGNED 
arguments and SIGNED results.

This DSA can securely interwork with the secured DUA component of SecuDE 
(alternative 3 above).
\\ [1em]

{\large\bf SecuDE Utilities Summary}
\addtotocsmall{SecuDE Utilities Summary}
\\[1em]
{\bf User Utilities}

SecuDE provides a number 
of utilities to maintain the user's PSE, to hash, sign, verify, 
encrypt and decrypt files, to perform PEM transformations, to
operate certification authorities, and to perform key and certificate
management and distribution functions. All utilities require that
a user has a PSE which is the user's security database (a user may have
several PSEs; all utilities allow to specify a particular PSE using
parameter {\bf -p} {\em psename}). Sectool(1) is the window-oriented
interactive tool to maintain a PSE, access X.500 Directories, and
exchange information between the Directory and the PSE.
Psemaint(1) is the line-oriented equivalent of sectool(1).   
\\ [1em]
{\bf Utilities for Certification Authorities (CA)}
 
For the generation of certificates and CRLs certification authorities 
(CAs) are needed.
SecuDE basicly provides two methods for the exchange of security
information between SecuDE users and external CAs.
\be
\m A file interface of ASN.1 encoded objects is provided. These
   files can be exchanged by any means.
\m Procedures and formats according to PEM RFC 1424 are provided.
\ee
Key generation and certification can be done with
\be
\m User-generated keys, whereby the pubic component is
   subsequently transmitted to the CA for certification and
   retransmitted as certificate to the user (PEM
   procedures allow this method only),
\m CA-generated keys, whereby subsequently a whole PSE
   containing all keys and certificates is transmitted from
   the CA to the user (this requires that also the CA operates
   with SecuDE tools).
\ee
In addition, tools for setting up a CA hierarchy with SecuDE means 
only, and for the operation of CAs are provided.
This tool set is described in KM(1).
\\ [1em]
{\large\bf Access to Public Directories}
\addtotocsmall{Access to Public Directories}

SecuDE provides a set of functions to retrieve and update security 
attributes in Directories, like UserCertificate, CaCertificate, 
CrossCertificatePair, CertificateRevocationList etc.
\\ [1em]
{\bf Global X.500 Directory and Local afdb Directory}
\addtotocsmall{Global X.500 Directory and Local afdb Directory}
 
DUA functionality for the access to the X.500 Directory is based on
QUIPU-8 software and requires a full ISODE-8 installation on the system. 
X.500 DUA functionality is integrated into many SecuDE utilities
and functions. For instance, it is part of sectool(1) and psemaint(1)
which allows the transfer of security information between the user's
PSE and public Directories and vice versa.

As it stands at the moment the use of the global X.500 Directory is not
very widespread. Participants of the X.500 Directory are often
academic and research organizations. Also, in larger organizations 
the nature of publicly needed security information is not global
but local. To securely communicate with people from the same organization,
access to the X.500 Directory is not needed. It would be sufficient
to retrieve the necessary security information from a local database.

In order to support such a kind of functionality, SecuDE provides a
local Directory which is called the afdb Directory (afdb: authentication
framework data base). It resides in the Unix directory \$TOP/.af-db.
he afdb Directory stores, like the X.500 Directory, certificates, 
cross certificate pairs and certificate revocation lists on the basis 
of X.501 distinguished names. Each entry in the afdb Directory is a 
subdirectory of \$TOP/.af-db with the printable DName as (Unix) directory 
name (see below on distinguished names).

Note that in order to use the word ``directory'' unambiguously the word
Directory (with capital D) means an X.500 or afdb Directory and the word
directory (with small d) means a Unix directory throughout the whole
SecuDE documentation. 
\\ [1em]
{\bf Local Names and Distinguished Names}
\addtotocsmall{Local Names and Distinguished Names}

This section provides a brief introduction to the concept of the global
unique name scheme introduced through X.500 Distinguished Names,
and its realization and application in SecuDE.
  
SecuDE uses the X.501 defined name scheme in order to identify subjects who
process or own keys and certificates, e.g. human users, organizations like 
CAs and
particular system components like X.500 DSAs. Each subject is uniquely
identified by a Distinguished Name. 
{\em DistinguishedName} is defined in correspondence to CCITT X.501, Annex 
B, as
a sequence of relative distinguished names which in turn are sets
of \{attribute type / attribute value\} pairs:
{\small
\bvtab
DistinguishedName ::= \6 {\bf SEQUENCE OF} RelativeDistinguishedName                  
\\ [1ex]
RelativeDistinguishedName ::= \6 {\bf SET OF} AttributeValueAssertion                 
\\ [1ex]
AttributeValueAssertion ::= \6 {\bf SEQUENCE} \{                                      
\\
                               \7 attributeType \3 OBJECT IDENTIFIER,                 
\\
                               \7 attributeValue \3 ANY DEFINED BY 
attributeType      \\
                            \6 \} \\
\evtab                             
}
SecuDE handles two representations of distinguished names. One is the {\em 
DName}
data type which is a C-structure corresponding to the above ASN.1 notation 
(see INTRO(3X)). 
The second which is used at the SecuDE utility interface is the {\em Name} 
data type.
This is a printable character string representation
of a distinguished name in the form
\bc
{\small keyword=value \% keyword=value ... ; keyword=value \% keyword = 
value ...; ...}
\ec
keyword is a SecuDE-defined name for an attribute type. 
The ';' delimiter separates the RDN members of the DN, i. e. each 
keyword=value \% keyword=value ... expression denotes one relative 
distinguished name.
The '\%' delimiter separates the attribute value assertions within one RDN
(note that within a single RDN a particular attribute type must not
appear more than once).
The following keywords, representing X.520 defined attributes,  are 
possible:
{\small
\bvtab
C   \2 countryName \\
O   \2 organizationName  \\
OU  \2 organizationalUnitName \\
S   \2 surname \\
CN  \2 commonName \\
L   \2 localityName \\
SP  \2 stateOrProvinceName \\
ST  \2 streetAddress \\
T   \2 title \\
SN  \2 serialNumber \\
BC  \2 businessCategory \\
D   \2 description
\evtab
}
RDNs must be ordered top down. Letter cases are not significant for names 
(except in case of the country code which must be a sequence of two capital
 letters), as well as spaces may be used inside and outside the names.

Example: 

{\small
C=DE; O=gmd; OU=I2 \% CN=Institut fuer TeleKooperationsTechnik; CN=Wolfgang 
Schneider}

is a possible printable character string representation of a DName as it might
be used at the utility interface of SecuDE. 
\\ [1em]
{\bf Local Name Aliasing}
\addtotocsmall{Name Aliasing}

Since Distinguished Names are pretty unhandy to deal with in the
day-to-day work, SecuDE provides aliasing functionality. Alias names
can be defined on a per-installation or on a per-user basis. Alias
files are integrity-protected, i.e. alias files are signed when they are
generated or changed, and they ar validated when they are read for
alias name transformations. Per-installation alias files must be signed
by a system administrator; per-user alias files are signed by the
user himself. 

In addition it is possible to store the user aliases on a per PSE basis
in the PSE-object AliasList (where they are integrity-protected through
PSE means). This is necessary if the user is connected to different
certification trees with more than one PSE.

The installation alias file is in \$TOP/.af-alias. \$TOP
is the top level directory of the SecuDE installation. The alias file
has the system administrator's signature in \$(TOP)/.af-alias.sig and his user
certificate and forward certification path in \$(TOP)/.af-alias.ctf.
In order to enable a user to verify the system administrator's signature
it is necessary that all users and the system administrator share the
same public root key.

The user alias file is either in \$HOME/.af-alias or in the PSE-object
AliasList. The alias transforming routines check for the existence of
the PSE-object AliasList first.
 
SecuDE distinguishes three types of alias names: local names (i.e.
login names), Internet mail addresses, and X.400 OR-Names. Each 
X.500 Distinguished Name may have several aliases of the above types.

Each utility which requires a {\em Name} parameter (i.e. the printable
character string representation of a Distinguished Name) maps the given 
parameter through the alias mechanism, i.e. each utility allows to
use alias names instead of X.500 Distinguished Names.
\\ [1em]
{\bf Cryptographic Algorithms}
\addtotocsmall{Cryptographic Algorithms}

SecuDE has a number of cryptographic algorithms implemented for different
purposes, for instance symmetric and asymmetric encryption algorithms
for the purpose of confidentiality and privacy, signature algorithms
for the purpose of authentication and non-repudiation, and hash
algorithms which are used for integrity purposes.
In SecuDE, cryptographic algorithms are identified through names or
through X.509 algorithm identifiers. An implemented algorithm may
have more than one Name. It is, however, uniquely identified through its
algorithm identifier. 

If a utilities allows to specify a cryptographic algorithm, an algorithm
name is required. See a more detailled description in the introduction 
of section 3 (subroutines) about the use of cryptographic algorithms
and their properties and parameters.
\\ [1em]
{\bf Common Parameters}
\addtotocsmall{Common Parameters}

There is set of parameters which are common to many SecuDE utilities:
\\ [1em]
\parname{{\bf -h}}
\pardescript{Print a helptext about the command to stderr.}

\parname{{\bf -p} {\em psename}}
\pardescript{{\em psename} denotes the name of the PSE which is in effect
for the utility. Each user may have more than one PSE. The use of a
particular PSE establishes the security context of the requested action.
For instance, a particular PSE may link the user to a particular
certification tree (and to a particular root key)}

\parname{{\bf -c} {\em cadir}}
\pardescript{This parameter does two things. It indicates that the utility
is called by a CA, and it denotes the name of the PSE which is in effect
for the utility (Per default a CA has the PSE {\em cadir}/.capse). If
both parameters {\bf -c} {\em cadir} and {\bf -p} {\em psename} are used,
it denotes the PSE {\em cadir}/{\em psename}.}

\parname{{\bf -k} {\em keysize}}
\pardescript{Keysize of asymmetric keys to be generated.}

\parname{{\bf -vVW}}
\pardescript{Options {\bf -v}, {\bf -V} and {\bf -W} set three
verbose levels, -v being the least and -W being the most verbose. Not
more than -v is necessary for normal operations. In general -v
causes that in case of signature verifications the structure
VerificationResult is printed, and that in case of errors the error
stack is printed.}

\parname{{\bf -t}}
\pardescript{Enable checking of malloc/free behaviour. Each address obtained
through malloc(3), calloc(3) or realloc(3) is stored in an internal list
which is examined whenn addresses are freed. Inconsistancies are reported
to stderr.} 

\parname{{\bf -i} {\em inputfile}}
\pardescript{Inputfile}

\parname{{\bf -o} {\em outputfile}}
\pardescript{Outputfile}

In case that Directories are being accessed:

\parname{{\bf -D}}
\pardescript{Enter the generated information (certificates or CRLs) into
the Directory}

In case that X.500 Directories are being accessed:

\parname{{\bf -d} {\em dsaname}}
\pardescript{{\em dsaname} denotes the name of the DSA (Directory System Agent) 
to be contacted for this purpose. {\em dsaname} is a name which must be contained in the 
{\em dsaptailor} file of the system as {\em dsa\_address} parameter. If {\bf -d} {\em dsaname} is
not given, the default DSA, which is the first {\em dsa\_address} parameter in the {\em dsaptailor} 
file, is accessed.}

\parname{{\bf -A} {\em authlevel}}
\pardescript{{\em authlevel} determines the level of authentication used when binding to the DSA. 
{\em authlevel} may have the values STRONG, SIMPLE or NOAUTH.
If {\bf -A} {\em authlevel} is omitted, the requested 
level of authentication is taken from the environment variable AUTHLEVEL, and is set to {\em no 
authentication}, if no such variable exists.
In case of simple authentication being used, the caller's distinguished name and
X.500 password are retrieved from the PSE objects Name and QuipuPWD, respectively.
In case of strong authentication being used, subsequent DAP operations are also signed.
STRONG requires that SecuDE is installed with the STRONG option.}

\hl{Getting Started}
\addtotocsmall{Getting Started}
Though SecuDE is basically a library of security functions for C-programmers, it
provides some utilities which allow users to encrypt and decrypt files (ENCRYPT(1), DECRYPT(1)),
sign and verify files (SIGN(1), VERIFY(1)), create and interpret PEM messages (PEM(1)).
After installation of SecuDE, it is necessary to provide each user with a PSE containing 
his personal secret keys for encryption and signatures, the corresponding certified public keys,
the public key of the root certification authority, and the forward certification path, i.e.
a PSE containing the AF-PSE-objects described in AF\_PSE\_OBJECTS(4).

Type

\begin{center}
secude -h
\end{center}
 
to get a list of available SecuDE utilities. Type

\begin{center}
secude -q
\end{center}

to get a quick reference guide of the available utilities to stderr. 

It is not necessary that a user gets certificates and the like from external or
third parties before he is able to do anything. He just has to create a PSE
with
\begin{center}
psecreate {\em distinguished-name}
\end{center} 
and can start signing and encrypting files and exchanging keys with others. The user's
distinguished name and the name of his default PSE can be defined in .cshrc
in the environment variable MYDNAME and PSE.

On a larger scale, however, it is advisable to connect to an existing certification
tree or to create an own one. To do the latter, a tree of certification authorities, at least consisting of one root 
certification authority, must be created, where a user gets his certificates from. 
This can be done using cacreate(1) and the commands described in KM(1), or using
the command pem(1) to perform PEM certification procedures instead.
After the creation of at least
a root certification authority and the user PSEs, the users are able to
use the utilities mentioned above.
 
A typical sequence of actions to get an own certification tree is described in KM(1).
An alternative could be the following (In this example all 
is done under a single Unix user ID. Normally, the different roles (CAs and users) are
played under different Unix user IDs or even on different systems):
\be
\m Create a root certification authority using {\em cacreate -c RootCA Name}.
\m If an additional level of CAs is needed below the root CA, create one or more 
   certification authorities below the root
   using {\em gen\_ca -c RootCA} at the root CA site and {\em inst\_ca CAFile} at the site
   of the CA to be created. CAFile is the name of a file which contains the CA-directory
   (of the CA to be created) as compressed tar-file. {\em gen\_ca} asks for the name of 
   CAFile and for the name of the CA-directory intercatively.
\m Repeat step 2. for each CA if additional levels of CAs are needed.
\m Create one ore more user PSEs under a CA using {\em gen\_pse -c CADir} at the CA site
   and {\em inst\_pse PSEFile} at the user site. CADir is the CA directory of the issueing
   CA of the user. PSEFile is the name of the file which contains the PSE (of the user)
   as compressed tar-file. 
\ee
See KM(1) for the detailled parameterization of those KM utilities.
 
Readers are also advised, in order to get an example of how to use KM(1), to examine the shell 
script {\em create\_TestTree} which is contained in SecuDE's bin directory. 
{\em create\_TestTree} creates a tree of one root CA, two second level CAs and two
user PSEs under each second level CA for test purposes. Furthermore, it can enter
the signature and encryption certificates of each CA and each user into a directory, which 
may either be a X.500 directory or the local substitute provided by SecuDE. The test 
tree can be deleted with {\em delete\_TestTree}.

\qr{1}{Quick Reference Guide}
{\small
\begin{verbatim}
SecuDE-4.1                                                         (c)1993 GMD Darmstadt


General User Utilities:
=======================


sign:  Sign Files


Description:

'sign' signs the given <files>. It uses algorithms and keys according
to the parameter -k and -a (default: SKnew/SignSK). For each
file in <files> it produces file.sig (containing the signature) and, if
-C is given, file.ctf (containing the user certificate and the forward
certification path).


usage:

sign [-CvVWUth] [-p <pse>] [-c <cadir>] [-k <key>] [-a <alg>] [-H <hashinput>] [<files>]

with:

-C               Produce .ctf files containing user certificate and forward certification
                 path for each file to be signed. Otherwise, produce only .sig files
-v               verbose
-V               Verbose
-W               Grand Verbose (for tests only)
-U               Show time used for cryptographic algorithms
-t               Control malloc/free behaviour
-h               Write this help text
-p <psename>     PSE name (default: Environment variable PSE or .pse)
-c <cadir>       name of CA-directory (default: Environment variable CADIR or .ca)
-k <key>         PSE-object or key reference of signature key. Default: SKnew/SignSK
-a <signalg>     Signature algorithm. Default: md5WithRsaTimedate (RSA) or dsaWithSHA
                 (DSS), depending on the signature key
-H <hashinput>   PSE-object or key reference of hash input (sqmodn only)
<files>          Filenames

****************************************************************************************


verify: Verify Signatures of Files


Description:

'verify' verifies the given <files>. It uses algorithms and keys according
to the parameter -k and -a (default: Cert/SignCert). For each
file in <files> it expects file.sig (containing the signature) and
optionally file.ctf (containing the user certificate and the forward
certification path). If file.ctf does not exist, the verification will
only succeed if the file was signed by oneself.


usage:

verify [-DRvFVWtTUh] [-p <pse>] [-c <cadir>] [-d <dsa>] [-A <authlevel>] [-k <key>] 
       [-f <fcpath>] [<files>]

with:

-D               Retrieve missing certificates from the Directory (X.500 or .af-db)
-F               Consider own FCPath as trusted
-R               Consult certificate revocation lists for all cerificates which
                 are in the certification path
-v               verbose
-V               Verbose
-W               Grand Verbose (for tests only)
-t               Control malloc/free behaviour
-T               Perform each public key RSA operation in the smartcard  terminal
                 instead with the software in the workstation (the latter is default)
-U               Show time used for cryptographic algorithms
-h               Write this help text
-p <psename>     PSE name (default: Environment variable PSE or .pse)
-c <cadir>       name of CA-directory (default: Environment variable CADIR or .ca)
-d <dsa>         name of the DSA to be accessed for retrieving certificates
                 and certificate revocation lists
-A <authlevel>   Level of authentication used for binding to the X.500 Directory
                 It may be SIMPLE or STRONG (default: environment variable AUTHLEVEL, or 
                 NONE, if this does not exist). STRONG implies the use of signed DAP 
	         operations.
-k <key>         PSE-object (containing either a certificate or a key) or key reference 
                 of verification key. Default: Cert/SignCert
-f <fcpath>      name of PSE-object which contains the Forward Certification Path
<files>          Filenames

****************************************************************************************


encrypt:  Encrypt Files


Description:

'encrypt' encrypts the given <files>. It uses algorithms and keys according
to the parameter -k or -w or -r or -w. Not more than one of these parameters
must be given (default: key and alg from PSE-object Cert/EncCert). For each
file in <files> it encrypts from file to file.enc and removes file.
'encrypt' also works as a filter from stdin to stdout.


usage:

encrypt [-DnxvVWtTU] [-k <key>] [-r <recipient>] [-w <pw>] [-e <deskey>] 
        [-E <encalg>] [-p <pse>] [-c <cadir>] [-d <dsa>] [-A <auth-level>]
        [<files>]

with:

(not more than one of the parameters -k, -e, -w and -r must be given. If none of these 
 four parameters is given, the file is symmetrically (default: desCBC) encrypted with a  
 newly generated DES key, and the DES key is asymmetrically encrypted with the own 
 encryption key (Cert/EncCert). This is called the hybrid method.)

-k <object/ref>  PSE-object (containing either a certificate or a key) or key reference 
                 of encryption key. Default: Cert/EncCert. If this key is an asymmetric
                 key, the hybrid method is used.
-e <key>         DES key for desCBC encryption.
-x               If given, <key> of parameter -e must be a 16 character string
                 denoting the key in a [0-9, A-F] notation. Otherwise it must be
                 an 8 character string comprising the key itself.
-w               8 character password which is transformed into a DES key with a
                 one-way function, for desCBC encryption.
-r               Intended recipient (alias allowed). Search encryption key of this 
                 recipient in EKList/PKList. If not given, encrypt with own encryption 
                 key. This implies the hybrid method
-n               Don't use the hybrid method in case of an asymmetric key. Do asymmetric
                 encryption of the whole file (not recommendable for larger files)
-D               Search public encryption key in the Directory if it cannot
                 be found in EKList/PKList of the PSE
-d <dsa>         Name of the DSA to be accessed for retrieving the public encryption key
-A <auth_level>  Level of authentication in case of X.500 Directory access. <auth-level>
                 may be SIMPLE or STRONG (default: environment variable AUTHLEVEL, or NONE,
                 if this does not exist). STRONG implies the use of signed DAP operations
-E <encalg>      Use algorithm encalg instead of desCBC for the file encryption. <encalg>
                 must be a symmetric algorithm
-v               verbose
-V               Verbose
-W               Grand Verbose (for tests only)
-t               Control malloc/free behaviour
-T               Perform each public key RSA operation in the smartcard  terminal
                 instead of employing the software in the workstation (the latter is the 
                 default)
-U               Show time used for cryptographic algorithms
-h               Write this help text
-p <psename>     PSE name (default: Environment variable PSE or .pse)
-c <cadir>       name of CA-directory (default: Environment variable CADIR or .ca)
<files>          Filenames

****************************************************************************************


decrypt:  Decrypt Files


Description:

'decrypt' decrypts the given <files>. It uses algorithms and keys according
to the parameter -k or -w or -r or -w. Not more than one of these parameters
must be given (default: key and alg from PSE-object SKnew/DecSKnew). For each
file in <files> it decrypts from file.enc to file and removes file.enc.
'decrypt' also works as a filter from stdin to stdout.


usage:

decrypt [-nxvVWtU] [-k <key>] [-w <pw>] [-e <deskey>] 
        [-E <encalg>] [-p <pse>] [-c <cadir>] [<files>]

with:

(not more than one of the parameters -k, -e and -w must be given. If none of these three
 parameters is given, the file is symmetrically (default: desCBC) decrypted with the key 
 from <file>.sig which will be asymmetrically decrypted before with the own decryption 
 key (SKnew/DecSKnew). This is called the hybrid method.)

-k <object/ref>  PSE-object (containing a KeyInfo) or key reference 
                 of decryption key. Default: SKnew/DecSKnew. If this key is an asymmetric
                 key, the hybrid method is used.
-e <key>         DES key for desCBC decryption.
-x               If given, <key> of parameter -e must be a 16 character string
                 denoting the key in a [0-9, A-F] notation. Otherwise it must be
                 an 8 character string comprising the key itself.
-w               8 character password which is transformed into a DES key with a
                 one-way function, for desCBC decryption.
-n               Don't use the hybrid method in case of an asymmetric key. Do asymmetric
                 decryption of the whole file
-E <decalg>      Use algorithm decalg instead of desCBC for the file decryption. <decalg>
                 must be a symmetric algorithm
-v               verbose
-V               Verbose
-W               Grand Verbose (for tests only)
-t               Control malloc/free behaviour
-U               Show time used for cryptographic algorithms
-h               Write this help text
-p <psename>     PSE name (default: Environment variable PSE or .pse)
-c <cadir>       name of CA-directory (default: Environment variable CADIR or .ca)
<files>          Filenames

****************************************************************************************


pem  Privacy Enhancement for Internet Electronic Mail

usage:

pem [ scan | mic-clear | mic-only | encrypted | crl | clr-rr | certify ]
    [-i <inputfile>] [-o <outputfile>] [-p <psename>] [-c <cadir>] [-m|M 1..200]
    [-u <update>] [-r <name1 ...> ] [-y <name1 ...> ] [-CnFNOhvVWRDTt] [-d <dsaname>]
    [-H <mic-alg>] [-S <micenc-alg>] [-E <msgenc-alg>] [-K <dekenc-alg>]

with:

scan             read PEM any Proc-Type, write clear body and/or update
                 PSE and/or CA-database according to -u (default)
mic-clear        read text file, write PEM Proc-Type MIC-CLEAR
mic-only         read text file, write PEM Proc-Type MIC-ONLY
encrypted        read text file, write PEM Proc Type ENCRYPTED according to -r
crl              write PEM Proc-Type CRL according to -y
crl-rr           write PEM Proc-Type CRL-RETRIEVAL-REQUEST according to -y
certify          read PEM Proc-Type MIC-CLEAR or MIC-ONLY, check whether it is certifi-
                 cation request, sign Prototype-certificate, write certification reply
-i <inputfile>   inputfile (default: stdin)
-o <outputfile>  outputfile (default: stdout)
-p <psename>     PSE name (default: .pse)
-c <cadir>       name of CA-directory (default: .ca)
-m <level>       depth of multi PEM body, which is to be de-enhanced (only if pem scan)
-M <level>       depth of multi PEM body, up to which is to be de-enhanced (only if 
                 pem scan)
-u <update>      mode for updating the PSE or CA-database after scanning a PEM-msg
                 (ask, yes, no, cadb, pse (default: ask))
-r <recipients>  DNames or alias-names of recipients (only if pem encrypted)
-y <issuers>     DNames or alias-names of issuers of CRLs or CRL-RRs (only if pem crl 
                 or pem clr-rr)
-C               generate PEM-header with Originator-Certificate and all Issuer-Certifi-
                 cates (default: generate PEM-header with Originator-ID-Asymmetric)
-n               don't insert Key-Info header field for originator (only if pem encrypted)
-N               use of non-PEM conformant algorithms allowed
-O               RFC 1422 DName subordination not required
-h               write this help text
-v               verbose
-V               Verbose
-W               Grand Verbose (for tests only)
-F               consider own FCPath as trusted
-R               consult CRLs during validation process
-D               retrieve missing certificates or CRLs from the Directory 
                 (X.500 or .af-db)
-d <dsaname>     name of the DSA to be initially accessed (default: locally configured 
                 DSA)
-A <authlevel>   level of authentication used for binding to the X.500 Directory
-H <mic-alg>     MIC algorithm (default: RSA-MD5)
-S <micenc-alg>  MIC encryption algorithm (default: RSA)
-E <msgenc-alg>  Message encryption algorithm (default: DES-CBC) (only if pem encrypted)
-K <dekenc-alg>  DEK encryption algorithm (default: RSA) (only if pem encrypted)
-t               enable memory checking
-T               verification of signature is to be done by the smartcard terminal

****************************************************************************************


hsh:  Hash Filter


Description:

'hsh' reads <file> and writes its hash value to <hash>. It uses the algorithm
given with parameter -a <alg>. <alg> is the name of an algorithm of type HASH.


usage:

hsh [-vh] [-a <alg>] [-H <hashinput>] [-p <pse>] [-c <cadir>] [<file> [<hash>] ]

with:

-a <alg>         Name of a hash algorithm (default: md5)
-H <hashinput>   PSE-object or key reference of hash input (sqmodn only)
-p <psename>     PSE name, if <hashinput> is PSE-object (sqmodn only)
-c <cadir>       CA directory, if <hashinput> is PSE-object (sqmodn only)
-v               verbose
-h               Write this help text
<file>           Filename of file to be hashed. Stdin, if omitted
<hash>           File where hash value shall be written. Stdout, if omitted

****************************************************************************************


encode  Encode File to RFC 1421 or [0-9,A-F] ASCII Represenation

usage:

encode [-rxhv] [ -i <n> ] [ file [encodedfile] ]

with:

-r               RFC 1421 encoding style (default)
-x               [0-9,A-F] encoding style
-i <n>           insert newlines after n characters (default 64)
-h               write this help text
-v               verbose

****************************************************************************************


decode  decode RFC 1421 or [0-9,A-F] encoded ASCII file to file

usage:

decode [-rxhv] [ encodedfile [file] ]

with:

-r               RFC 1421 encoding style (default)
-x               [0-9,A-F] encoding style
-h               write this help text
-v               verbose

****************************************************************************************


algs  Information about algorithms

usage:

algs [-UGvVth] [-a <name>] [-s <keyword>] [-k <k1> <k2> ... ] [-l <quantity>]

with:

-a <name>        Selects a single algorithm with name <name>
-s <keyword>     Selects groups of algorithms. Either one of the AlgTypes (SYM_ENC, 
                 ASYM_ENC, HASH, SIG) which selects all algorithms of the given type, or
                 a string which is contained in an algorithm name.
-U               Show performance times of algorithms for sign, verify, encrypt, decrypt
                 and hash, depending on the algorithm type:
                 Signature algorithms: Total, asymmetric encryption and hash time for
                           signing and verifying a given quantity with different
                           keysizes (parameter -k). Asymmetric keys are generated
                           and stored in PSE $(TOP)/lib/.testkeys afterwards if not 
                           available
                 Asymetric Encryption algorithms: Encryption and decryption of a block
                           with different keysizes (parameter -k). Asymmetric keys are 
                           generated and stored in PSE $(TOP)/lib/.testkeys afterwards 
                           if not available
                 Symmetric Encryption algorithms: Encryption of a 100 K quantity
                 Hash algorithms: Hashing of a given quantity
-G               Show key generation times of asymmetric algorithms with
                 different keysizes (parameter -k). Needs time!
-k <k1> <k2> ... Use keysizes k1, k2, ... (default: 512, 640, 756, 1024)
-l <quantity>    Quantity to be signed or hashed in K bytes (default: 100)
-v               verbose
-V               Verbose
-t               Control malloc/free behaviour
-h               Write this help text

****************************************************************************************


secxlock  Locks the local X display using strong authentication with your PSE

usage:

secxlock [-h] [-p <pse>] [-c <cadir>]

with:

-p <psename>     PSE name (default: Environment variable PSE or .pse)
-c <cadir>       name of CA-directory (default: Environment variable CADIR or .ca)
-h               Write this help text

****************************************************************************************


Utilities to Create and Maintain your Personal Security Environment (PSE)
=========================================================================


psecreate: Create User PSE


Description:

'psecreate'  creates a User PSE with one or two asymmetric keypairs on it,
whose public keys are held within self-signed prototype certificates.


usage:

psecreate [-hqtvVW] [-p <pse>] [-s <signalg>] [-k <keysize>] [-e <encalg>] [-k <keysize>] 
          [Name]

with:

-p <pse>         PSE name (default: Environment variable PSE or .pse)
-s <signalg>     Signature algorithm (default: rsa)
-k <keysize>     Keysize of RSA signature key
-e <encalg>      Encryption algorithm (default: rsa)
-k <keysize>     Keysize of RSA encryption key
-q               create PSE that contains two RSA keypairs (default: one RSA keypair only)
-h               write this help text
-t               control malloc/free behaviour
-v               verbose
-V               Verbose
-W               Grand Verbose (for testing only)
<Name>           Intended owner of the generated User PSE

****************************************************************************************


sectool: Maintain your PSE
aliastool: Maintain your aliases (Alias sub-tool of sectool)
directorytool: Access Directory (Directory sub-tool of sectool)


Description:

'sectool' is, like psemaint,  a maintenance program which can be used by both
certification authority administrators and users for the purpose
of maintaining their PSEs. This includes moving information (e.g. keys,
certificates, revocation lists etc.) from Unix files or a X.500 Directory
into the PSE and vice versa, generating keys, changing PINs, displaying
the content of the PSE, and maintaining the user's aliases. In contrast
to psemaint, which is line-oriented, sectool is an OpenWindows tool.


usage:

sectool [-tDvVWh] [-p <pse>] [-c <cadir>] [-d <dsa name>] [-A <authlevel>]
aliastool [-tDvVWh] [-p <pse>] [-c <cadir>] [-d <dsa name>]
directorytool [-tDvVWh] [-p <pse>] [-c <cadir>] [-d <dsa name>] [-A <authlevel>]
with:

-p <psename>        PSE name (default: environment variable PSE or .pse)
-c <cadir>          Name of CA-directory (default: environment variable CADIR or .ca)
-t                  control malloc/free behaviour
-v                  verbose
-V                  Verbose
-W                  Grand Verbose (for testing only)
-d <dsa name>       Name of the DSA to be initially accessed (default: locally 
                    configured DSA)
-A <authlevel>      Level of authentication used for X.500 Directory access
                    <authlevel> may have one of the values 'SIMPLE' or 'STRONG'
                    (default: environment variable AUTHLEVEL or 'No authentication')
                    STRONG implies the use of signed DAP operations

****************************************************************************************


psemaint: Maintain PSE


Description:

'psemaint' is a maintenance program which can be used by both
certification authority administrators and users for the purpose
of maintaining their PSEs. This includes moving information (e.g. keys,
certificates, revocation lists etc.) from Unix files or a X.500 Directory
into the PSE and vice versa, generating keys, changing PINs and displaying
the content of the PSE.


usage:

psemaint [-htvACFRDTVW] [-p <pse>] [-c <cadir>] [-a <issueralg>] [-f <notbefore>] 
         [-l <notafter>] [-i <inputfile>] [-d <dsa name>] [-A <authlevel>] [cmd]
with:

-p <psename>        PSE name (default: environment variable PSE or .pse)
-c <cadir>          Name of CA-directory (default: environment variable CADIR or .ca)
-i <inputfile>      Scriptfile containing the commands to be executed by 'psemaint'
-a <issueralg>      CA's signature algorithm (default: md2WithRsaEncryption)
-f <notbefore>      First date on which the certificate is valid
                    (evaluated by 'certify' command within 'psemaint')
-l <notafter>       Last date on which the certificate is valid
                    (evaluated by 'certify' command within 'psemaint')
-F                  consider own FCPath as trusted
-R                  consult PEM revocation lists during verification
-C                  show list of commands available with 'psemaint'
-D                  access Directory (X.500 or .af-db)
-T                  perform each public key RSA operation in the smartcard  terminal
                    instead of employing the software in the workstation (the latter is 
                    the default)
-h                  write this help text
-t                  control malloc/free behaviour
-v                  verbose
-V                  Verbose
-W                  Grand Verbose (for testing only)
-d <dsa name>       Name of the DSA to be initially accessed (default: locally 
                    configured DSA)
-A <authlevel>      Level of authentication used for X.500 Directory access
                    <authlevel> may have one of the values 'SIMPLE' or 'STRONG'
                    (default: environment variable AUTHLEVEL or 'No authentication')
                    STRONG implies the use of signed DAP operations
<cmd>               Single command that shall be executed by 'psemaint'
                    (otherwise, commands can be provided interactively
                    or are read from file <inputfile> (see option -i))

****************************************************************************************


instpkroot: Install Public Root Information on PSE


Description:

'instpkroot' reads file <pkroot> or stdin, if <pkroot> is omitted,
and installs its content as PSE object PKRoot on the indicated PSE.
A PKRoot information that already exists on the target PSE will be overwritten.


usage:

instpkroot [-htvVW] [-p <pse>] [-c <cadir>] [pkroot]

with:

-p <psename>     PSE name (default: environment variable PSE or .pse)
-c <cadir>       Name of CA-directory (default: environment variable CADIR or .ca)
-t               control malloc/free behaviour
-h               write this help text
-v               verbose
-V               Verbose
-W               Grand Verbose (for testing only)
<pkroot>         File containing public root information (or stdin, if omitted)

****************************************************************************************


instfcpath: Install Forward Certification Path on PSE


Description:

'instfcpath' reads file <fcpath> or stdin, if <fcpath> is omitted,
and installs its content as PSE object FCPath on the indicated PSE.
A FCPath information that already exists on the target PSE will be overwritten.


usage:

instfcpath [-htvVW] [-p <pse>] [-c <cadir>] [fcpath]

with:

-p <psename>     PSE name (default: environment variable PSE or .pse)
-c <cadir>       Name of CA-directory (default: environment variable CADIR or .ca)
-t               control malloc/free behaviour
-h               write this help text
-v               verbose
-V               Verbose
-W               Grand Verbose (for testing only)
<fcpath>         File containing FCPath (or stdin, if omitted)

****************************************************************************************


instcert: Install Certificate on PSE


Description:

'instcert' reads file <cert> or stdin, if <cert> is omitted, and installs its
content on the PSE.


usage:

instcert [-aehrtvVWHD] [-p <pse>] [-c <cadir>] [-d <dsa name>] [-A <authlevel>] [cert]

with:

-p <psename>     PSE name (default: environment variable PSE or .pse)
-c <cadir>       Name of CA-directory (default: environment variable CADIR or .ca)
-t               control malloc/free behaviour
-e               consider certificate as ENCRYPTION certificate (default: SIGNATURE 
                 certificate)
-h               write this help text
-v               verbose
-V               Verbose
-W               Grand Verbose (for testing only)
-D               store certificate in Directory (X.500 or .af-db)
-r               replace existing certificate in .af-db Directory
-H               install certificate as hierarchy certificate
                 (default: add certificate to set of cross certificates)
-d <dsa name>    Name of the DSA to be initially accessed (default: locally 
                 configured DSA)
-a               store certificate as cACertificate attribute value (default: 
                 userCertificate)
-A <authlevel>   Level of authentication used for X.500 Directory access
                 <authlevel> may have one of the values 'SIMPLE' or 'STRONG'
                 (default: environment variable AUTHLEVEL or 'No authentication')
                 STRONG implies the use of signed DAP operations
<cert>           File containing the certificate (or stdin, if omitted)

****************************************************************************************


genkey: Generate Key and Prototype Certificate


Description:

'genkey' generates an asymmetric keypair and installs the secret component on the PSE.
The public component of the keypair is wrapped into a self-signed prototype certificate
which is stored on the PSE and written to the file <proto> or stdout, if <proto> is 
omitted.


usage:

genkey [-hrtvVW] [-p <pse>] [-c <cadir>] [-a <issueralg>] [-s <signalg>] [-k <keysize>]
       [-e <encalg>] [-k <keysize>] [proto]

with:

-p <pse>           PSE name (default: environment variable PSE or .pse)
-c <cadir>         Name of CA-directory (default: environment variable CADIR or .ca)
-a <issueralg>     Issuer algorithm associated with the signature of the prototype 
                   certificate (default: md2WithRsaEncryption)
-s <signalg>       Signature algorithm (default: rsa)
-k <keysize>       Keysize of RSA signature key
-e <encalg>        Encryption algorithm (default: rsa)
-k <keysize>       Keysize of RSA encryption key
-r                 replace a previously generated secret key
-h                 write this help text
-t                 control malloc/free behaviour
-v                 verbose
-V                 Verbose
-W                 Grand Verbose (for testing only)
<proto>            File containing the resulting prototype certificate (or stdout, if 
                   omitted)

****************************************************************************************


getkey: Build Prototype Certificate


Description:

'getkey' creates a prototype certificate from a public key previously
stored on the PSE, and writes its content to file <proto> or stdout,
if <proto> is omitted.


usage:

getkey [-ehstvVW] [-p <pse>] [-c <cadir>] [proto]

with:

-p <pse>           PSE name (default: Environment variable PSE or .pse)
-c <cadir>         Name of CA-directory (default: Environment variable CADIR or .ca)
-s                 build prototype certificate from public signature key (default)
-e                 build prototype certificate from public encryption key
-h                 write this help text
-t                 control malloc/free behaviour
-v                 verbose
-V                 Verbose
-W                 Grand Verbose (for testing only)
<proto>            File containing the resulting prototype certificate (or stdout, if 
                   omitted)

****************************************************************************************


pkadd: Download Public Key into Cache


Description:

'pkadd' retrieves the certificates of owner 'Name' from the Directory
and downloads the requested public key information into the cache of
trusted public keys (PKList or EKList) in the indicated PSE.


usage:

pkadd [-aehitvVW] [-p <pse>] [-c <cadir>] [-d <dsa name>] [-A <authlevel>] [Name]

with:

-p <psename>     PSE name (default: environment variable PSE or .pse)
-c <cadir>       Name of CA-directory (default: environment variable CADIR or .ca)
-e               consider ENCRYPTION certificates only
                 (default: consider SIGNATURE certificates only)
-h               write this help text
-i               let user specify certificate whose public key is to be downloaded
-t               control malloc/free behaviour
-v               verbose
-V               Verbose
-W               Grand Verbose (for testing only)
-d <dsa name>    Name of the DSA to be initially accessed (default: locally 
                 configured DSA)
-a               read cACertificate attribute (default: userCertificate)
-A <authlevel>   Level of authentication used for X.500 Directory access
                 <authlevel> may have one of the values 'SIMPLE' or 'STRONG'
                 (default: environment variable AUTHLEVEL or 'No authentication')
                 STRONG implies the use of signed DAP operations
<Name>           Owner of the certificate whose public key is downloaded into the cache

****************************************************************************************


pkdel  Remove Public Key from Cache


Description:

'pkdel' deletes entries from the cache of trusted public keys (PKList or
EKList). It either deletes all entries of the given <owner>, or the one entry
that is uniquely identified by its <issuer> and <serial> combination.


usage:

pkdel [-ehtvVW] [-p <pse>] [-c <cadir>] [-o <owner>] [-i <issuer>] [-n <serial>]

with:

-p <psename>     PSE name (default: Environment variable PSE or .pse)
-c <cadir>       Name of CA-directory (default: Environment variable CADIR or .ca)
-o <owner>       Owner of public key
-i <issuer>      Issuer of public key
-n <serial>      Serial number of public key
-e               remove public key from cache of public ENCRYPTION keys (EKList)
-t               control malloc/free behaviour
-h               write this help text
-v               verbose
-V               Verbose
-W               Grand Verbose (for testing only)

****************************************************************************************


pklist: Print Cache of Trusted Public Keys


Description:

'pklist' prints out the content of the cache of trusted public keys
(PKList or EKList) of the indicated PSE.


usage:

pklist [-ehtvVW] [-p <pse>] [-c <cadir>]

with:

-p <psename>     PSE name (default: environment variable PSE or .pse)
-c <cadir>       Name of CA-directory (default: environment variable CADIR or .ca)
-e               print cache of trusted public ENCRYPTION keys (EKList)
                 (default: PKList)
-t               control malloc/free behaviour
-h               write this help text
-v               verbose
-V               Verbose
-W               Grand Verbose (for testing only)

****************************************************************************************


showdir: Retrieve and Show Security Attributes from Directory


Description:

'showdir' reads a security attribute from the directory entry of 'Name'
and prints its contents in an appropriate format.


usage:

showdir [-aehtvVW] [-p <pse>] [-c <cadir>] [-o <attributeType>] [-d <dsa name>] 
        [-A <authlevel>] [Owner's Name].

with:

-p <psename>        PSE name (default: environment variable PSE or .pse)
-c <cadir>          Name of CA-directory (default: environment variable CADIR or .ca)
-e                  consider ENCRYPTION certificates only
-o <attributeType>  Attribute whose value is requested (default: certificate)
                    supported attribute types:
                    'cert' (certificate),
                    'cross' (cross certificate pair), and
                    'rev' (PEM revocation list)
-h                  write this help text
-t                  control malloc/free behaviour
-v                  verbose
-V                  Verbose
-W                  Grand Verbose (for testing only)
-d <dsa name>       Name of the DSA to be initially accessed (default: locally
                    configured DSA)
-a                  read cACertificate attribute (default: userCertificate)
-A <authlevel>      Level of authentication used for X.500 Directory access
                    <authlevel> may have one of the values 'SIMPLE' or 'STRONG'
                    (default: environment variable AUTHLEVEL or 'No authentication')
                    STRONG implies the use of signed DAP operations
<Name>              Name of directory entry to be accessed

****************************************************************************************


show  Show ASN.1-coded SecuDE Object in Suitable Form

usage:

show [-hvVW] [file (containing ASN.1 code)]

with:

-h               write this help text
-v               verbose
-V               Verbose
-W               Grand Verbose (for testing only)

****************************************************************************************


Utilities for the Operation of Certification Authorities (X.509)
================================================================


cacreate: Create CA PSE (CA command)


Description:

'cacreate' creates a CA PSE with one or two asymmetric keypairs on it,
whose public keys are held within self-signed prototype certificates.
In addition, an empty PEM revocation list is created.


usage:

cacreate [-hqtvDVW] [-p <pse>] [-c <cadir>] [-a <issueralg>] [-s <signalg>] [-k <keysize>]
         [-e <encalg>] [-k <keysize>] [-n <serial>] [-u <nextupdate>]
         [-f <notbefore>] [-l <notafter>] [-d <dsa name>] [-A <authlevel>] [CA-Name]

with:

-p <psename>       PSE name (default: environment variable CAPSE or .capse)
-c <cadir>         Name of CA-directory (default: environment variable CADIR or .ca)
-a <issueralg>     Issuer algorithm associated with the signature of the prototype 
                   certificate(s) (default: md2WithRsaEncryption)
-s <signalg>       Signature algorithm (default: rsa)
-k <keysize>       Keysize of RSA signature key
-e <encalg>        Encryption algorithm (default: rsa)
-k <keysize>       Keysize of RSA encryption key
-n <serial>        Initial value of the serial number to be used by the CA
-D                 store self-signed certificate(s) in Directory (X.500 or .af-db)
-u <nextupdate>    Time and date of next scheduled update of PEM revocation list
-f <notbefore>     First date on which self-signed certificate is valid
                   (is only evaluated if option -r was supplied)
-l <notafter>      Last date on which self-signed certificate is valid
                   (is only evaluated if option -r was supplied)
-q                 create PSE that contains two RSA keypairs (default: one RSA keypair 
                   only)
-t                 control malloc/free behaviour
-h                 write this help text
-v                 verbose
-V                 Verbose
-W                 Grand Verbose (for testing only)
-d <dsa name>      Name of the DSA to be initially accessed (default: locally 
                   configured DSA)
-A <authlevel>     Level of authentication used for X.500 Directory access
                   <authlevel> may have one of the values 'SIMPLE' or 'STRONG'
                   (default: environment variable AUTHLEVEL or 'No authentication')
                   STRONG implies the use of signed DAP operations
<CA-Name>          Intended owner of the generated CA PSE

****************************************************************************************


certify: Certify Public Key (CA command)


Description:

'certify' reads a prototype certificate from file <proto> or stdin, if
<proto> is omitted, and transforms it into a 'valid' certificate.
It replaces the 'issuer' and 'serialnumber' fields of the prototype
certificate by its CA values (taken from its CA PSE), and replaces
the signature appended to the prototype certificate by its own signature.
The resulting certificate is written to file <cert> or stdout, if <cert>
is omitted.


usage:

certify [-htvVW] [-p <pse>] [-c <cadir>] [-a <issueralg>] [-f <notbefore>] 
        [-l <notafter>] [proto [cert]]

with:

-p <psename>       PSE name (default: environment variable CAPSE or .capse)
-c <cadir>         Name of CA-directory (default: environment variable CADIR or .ca)
-a <issueralg>     CA's signature algorithm (default: md2WithRsaEncryption)
-f <notbefore>     First date on which the certificate is valid
-l <notafter>      Last date on which the certificate is valid
-t                 control malloc/free behaviour
-h                 write this help text
-v                 verbose
-V                 Verbose
-W                 Grand Verbose (for testing only)
<proto>            File containing the prototype certificate (or stdin, if omitted)
<cert>             File containing the resulting certificate (or stdout, if omitted)

****************************************************************************************


revoke: Revoke Certificate (CA command)


usage:

revoke [-htvVWD] [-p <pse>] [-c <cadir>] [-d <dsa name>] [-A <authlevel>]

with:

-p <psename>     PSE name (default: .capse)
-c <cadir>       name of CA-directory (default: .ca)
-t               enable memory checking
-h               write this help text
-v               verbose
-V               Verbose
-W               Grand Verbose (for testing only)
-D               store updated revocation list in Directory (X.500 or .af-db)
-d <dsa name>    name of the DSA to be initially accessed (default: locally configured 
                 DSA)
-A <authlevel>   level of authentication used for binding to the X.500 Directory

****************************************************************************************


getpkroot  Extract Public Root Information from CA PSE (CA command)


Description:

'getpkroot' extracts the the PSE object PKRoot from the CA's PSE
and writes its content to the file <pkroot> or stdout, if <pkroot>
is omitted.


usage:

getpkroot [-htvVW] [-p <pse>] [-c <cadir>] [pkroot]

with:

-p <psename>     PSE name (default: environment variable CAPSE or .capse)
-c <cadir>       Name of CA-directory (default: environment variable CADIR or .ca)
-t               control malloc/free behaviour
-h               write this help text
-v               verbose
-V               Verbose
-W               Grand Verbose (for testing only)
<pkroot>         File containing public root information (or stdout, if omitted)

****************************************************************************************


getfcpath: Extract Forward Certification Path from CA PSE (CA command)


Description:

'getfcpath' adds the CA's hierarchy and cross certificates to the CA's
own forward certification path (FCPath), and writes the extended FCPath
to the file <fcpath> or stdout, if <fcpath> is omitted.


usage:

getfcpath [-htvVW] [-p <pse>] [-c <cadir>] [fcpath]

with:

-p <psename>     PSE name (default: environment variable CAPSE or .capse)
-c <cadir>       Name of CA-directory (default: environment variable CADIR or .ca)
-t               control malloc/free behaviour
-h               write this help text
-v               verbose
-V               Verbose
-W               Grand Verbose (for testing only)
<fcpath>         File containing the extended FCPath (or stdout, if omitted)

****************************************************************************************


gen_pse  Create and Update entire PSE's at CA Sites (Key Generation at CA Site)

usage:

gen_pse            [-i script][-c cadir][-p capse][-H home][-u userunixname]
                   [-a issueralg][-s signalg][-e encalg][-k keysize]
                   [-f notbefore][-l notafter][-x nameprefix]
                   [-P subjectpse][-C caname][-g serialnumber]
                   [-d dsaname] [-n][-vrDqth][namesuffix]
                   
-i <script>        Name of a script file which allows to specify a list of subjects and 
                   their specific parameters
-c <cadir>         Name of CA-directory (default: environment variable CADIR or .ca)
-p <capse>         CA's PSE name (default: environment variable CAPSE or .capse)
-H <home>          Path of all home-directories
-u <userunixname>  Unixname of the owner of a PSE to create/update
-a <issueralg>     Algorithm to sign certificates with
-s <signalg>       Algorithm of signature key to create/update
-e <encalg>        Algorithm of encryption key to create/update
-k <keysize>       Keysize of key to generate
-f <notbefore>     First date on which the certificate is valid
-l <notafter>      Last date on which the certificate is valid
-x <nameprefix>    First part of the name associated to the PSE
-P <subjectpse>    Name of PSE to create/update (default: environment variable PSE 
                   or .pse)
-C <caname>        Create a CA with CA-directory name <caname>
-g <serialnumber>  If a CA is created a serialnumber to start with can be specified
-d <dsaname>       The name of the dsa
-n                 Read the name of the dsa from PSE
-v                 Verbose
-r                 Replace an existing PSE in case of creation
-D                 Store generated certificates in X500 directory
-q                 Create two different key pairs for signature and encryption
-t                 Check malloc/free behaviour
-h                 Write this help text
                   
<namesuffix>      Second part of the name associated to the PSE

****************************************************************************************


Test
====

create_TestTree          Create a Test Certification Tree and Test Users 
 
usage: 
 
create_TestTree [-v] [-p] [-D] [-t] [-q] 
 
with: 
 
-v       verbose 
-p       use PEM RFC 1424 certification procedures, 
         otherwise use KM utilities for certification 
-D       enter certificates into Directory (X.500 or .af-db), 
-t       Enable checking of malloc/free behaviour 
-q       create PSEs with separate key pairs for SIGNATURE/ENCRYPTION purposes, 
         otherwise create 'one key pair' PSEs
 
This shell-script creates, for test purposes, the following tree of 
certification authorities and users: 
 
                         Root-CA 
                 /                       \ 
         ORG-1-CA                        ORG-2-CA 
         /       \                       /       \ 
 ORG-1-User-1 ORG-1-User-2       ORG-2-User-1 ORG-2-User-2 
 
 
It creates the directory TestTree under the home directory and the following directories 
under TestTree: 
 
Root-CA          CA directory of the root ca, CA-PSE is .capse
ORG-1-CA         CA directory of the ca ORG-1-CA under Root-CA, CA-PSE is .capse
ORG-2-CA         CA directory of the ca ORG-2-CA under Root-CA, CA-PSE is .capse
ORG-1-User-1     PSE of user ORG-1-User-1 under ca ORG-1-CA
ORG-1-User-2     PSE of user ORG-1-User-2 under ca ORG-1-CA
ORG-2-User-1     PSE of user ORG-2-User-1 under ca ORG-2-CA
ORG-2-User-2     PSE of user ORG-2-User-2 under ca ORG-2-CA

Each PSE (CA and User) has the PIN "test".
 
create_TestTree needs about 100 sec on a Sun SPARC10-41

****************************************************************************************
\end{verbatim}
}

\nm{1}{algs}{show available cryptographic algorithms}
\label{algs}
\hl{Synopsis}
{\bf algs} [ {\bf -UGvVth} ] [ {\bf -a} {\em name} ] [ {\bf -s} {\em keyword} ] [ {\bf -k} {\em k1 k2 k3 ...} ] [ {\em quantity} ]
\hl{Description}
{\em algs} prints information about all available cryptographic algorithms, or about all algorithms 
which correspond to the given {\em keyword}, or about the algorithm with the given {\em name}.
{\em keyword} can be a pattern which is contained in the algorithm name (e.g. rsa or md2), or one of the 
following algorithm types:
\bvtab
ASYM\_ENC \4 asymmetric encryption algorithms \\
SYM\_ENC  \4 symmetric encryption algorithms  \\
HASH      \4 hash (message digest) algorithms \\
SIG       \4 signature algorithms  
\evtab
{\em keyword} is not case-sensitive.

If option {\bf -a} is omitted, only the algorithm names are printed. 
Otherwise, the object identifiers and default parameter values are additionally printed. 

With option {\bf -U} online time measurements are performed with precomputed or newly generated keys. 
In case of asymmetric algorithms, keys with the keysizes {\em k1, k2, k3, ..} are used to 
encrypt/decrypt a corresponding block. If {\bf -k} {\em k1 k2 k3 ...} is omitted, keysizes
512, 640, 768 and 1024 are used.

In case of symmetric algorithms and message digest algorithms, an octetstring of {\em quantity} K
octets is encrypted/decrypted or hashed. If {\em quantity} is omitted, 100 K octets are
encrypted/decrypted or hashed.

In case of signature algorithms, an octetstring of {\em quantity} K octets is signed
and verified with keys of keysizes {\em k1, k2, k3, ...}. If {\em quantity} is omitted, 100 K octets are 
signed/verified. If {\bf -k} {\em k1 k2 k3 ...} is omitted, keysizes 512, 640, 768 and 1024 are used.

algs uses the PSE \$TOP/lib/.testkeys. If this PSE does not exist, it is created. If through
parameter {\bf -k} {\em k1 k2 k3 ...} keysizes are requested for which no keys exist,
they are generated and stored afterwards in \$TOP/lib/.testkeys.

With option {\bf -G} additional time measurements will be made for the key generation (asymmetric 
algorithms only) even if the requested keys exist already.

The figures presented here provide a rough impression about the performance of the algorithms on the 
installation platform. Note that the asymmetric algorithms can be installed on the
basis of C-programs or assembler programs. Time measurements are only possible for the software 
implementations of the algorithms. The performance of the smartcard terminal algorithm
implementation cannot be measured.

An example output of algs produced on a Sun Sparc10-41 workstation is shown below:
{\small
\begin{verbatim}

SYM_ENC Algorithms
==================
-------------------------------------------------------------------------------------
DES-ECB              OID { 1 3 14 3 2 6 } NULL parameter
                     Encr (100 Kbytes):   0.891  
                     Decr (100 Kbytes):   0.875  
-------------------------------------------------------------------------------------
DES-CBC              OID { 1 3 14 3 2 7 } Parameter DES-IV (default zeros)
                     Encr (100 Kbytes):   0.928  
                     Decr (100 Kbytes):   0.925  
-------------------------------------------------------------------------------------
DES-EDE              OID { 1 3 14 3 2 17 } NULL parameter
                     Encr (100 Kbytes):   2.634  
                     Decr (100 Kbytes):   2.630  
-------------------------------------------------------------------------------------
desECB               Same algorithm as DES-ECB
-------------------------------------------------------------------------------------
desCBC               Same algorithm as DES-CBC
-------------------------------------------------------------------------------------
desEDE               Same algorithm as DES-EDE
-------------------------------------------------------------------------------------
desCBC_pad           OID { 1 3 36 3 1 5 } Parameter DES-IV (default zeros)
                     Encr (100 Kbytes):   0.911  
                     Decr (100 Kbytes):   0.942  
-------------------------------------------------------------------------------------
desECB3              Same algorithm as DES-EDE
-------------------------------------------------------------------------------------
desCBC3              OID { 1 3 36 3 1 11 } Parameter DES-IV (default zeros)
                     Encr (100 Kbytes):   2.652  
                     Decr (100 Kbytes):   2.673  
-------------------------------------------------------------------------------------
desCBC3_pad          OID { 1 3 36 3 1 13 } Parameter DES-IV (default zeros)
                     Encr (100 Kbytes):   2.771  
                     Decr (100 Kbytes):   2.666  

ASYM_ENC Algorithms
===================
-------------------------------------------------------------------------------------
RSA                  OID { 1 2 840 113549 1 1 1 } NULL parameter
                     Encr ( 512 bits):   0.014  
                     Decr ( 512 bits):   0.172  
                     KGen ( 512 bits):  13.839  
                     Encr ( 640 bits):   0.020  
                     Decr ( 640 bits):   0.333  
                     KGen ( 640 bits):  27.564  
                     Encr ( 768 bits):   0.028  
                     Decr ( 768 bits):   0.495  
                     KGen ( 768 bits):  25.495  
                     Encr (1024 bits):   0.048  
                     Decr (1024 bits):   1.103  
                     KGen (1024 bits):  86.174  
-------------------------------------------------------------------------------------
NIST-DSA             OID { 1 3 14 3 2 12 } NULL parameter
                     Irreversible (can't encrypt/decrypt, see SIG for time)
-------------------------------------------------------------------------------------
rsa                  OID { 2 5 8 1 1 } Parameter Keysize (default 512)
                     Encr ( 512 bits):   0.013  
                     Decr ( 512 bits):   0.177  
                     KGen ( 512 bits):   9.889  
                     Encr ( 640 bits):   0.027  
                     Decr ( 640 bits):   0.328  
                     KGen ( 640 bits):  22.967  
                     Encr ( 768 bits):   0.028  
                     Decr ( 768 bits):   0.497  
                     KGen ( 768 bits):  39.718  
                     Encr (1024 bits):   0.048  
                     Decr (1024 bits):   1.093  
                     KGen (1024 bits): 146.979  
-------------------------------------------------------------------------------------
dsa                  Same algorithm as NIST-DSA
-------------------------------------------------------------------------------------
dsaSK                OID { 1 3 36 3 1 20 } Parameter Keysize (default 512)
                     Irreversible (can't encrypt/decrypt, see SIG for time)

HASH Algorithms
===============
-------------------------------------------------------------------------------------
RSA-MD2              OID { 1 2 840 113549 2 2 } NULL parameter
                     Hash (100 Kbytes):   1.076  
-------------------------------------------------------------------------------------
RSA-MD5              OID { 1 2 840 113549 2 5 } NULL parameter
                     Hash (100 Kbytes):   0.035  
-------------------------------------------------------------------------------------
NIST-SHA             OID { 1 3 14 3 2 18 } NULL parameter
                     Hash (100 Kbytes):   0.045  
-------------------------------------------------------------------------------------
sqmodn               OID { 2 5 8 2 1 } Parameter Keysize (default 512)
                     Hash (100 Kbytes):   2.663  
-------------------------------------------------------------------------------------
md2                  Same algorithm as RSA-MD2
-------------------------------------------------------------------------------------
md4                  OID { 1 2 840 113549 2 4 } NULL parameter
                     Hash (100 Kbytes):   0.068  
-------------------------------------------------------------------------------------
md5                  Same algorithm as RSA-MD5
-------------------------------------------------------------------------------------
sha                  Same algorithm as NIST-SHA

SIG Algorithms (100 K message signed)
=====================================
-------------------------------------------------------------------------------------
sqmodnWithRsa        OID { 2 5 8 3 1 } Parameter Keysize (default 512)
                     Sign ( 512 bits):   2.993 (total),  0.184 (RSA),  2.735 (SQMODN)  
                     Veri ( 512 bits):   2.752 (total),  0.013 (RSA),  2.737 (SQMODN)  
                     Sign ( 640 bits):   3.592 (total),  0.334 (RSA),  3.256 (SQMODN)  
                     Veri ( 640 bits):   3.273 (total),  0.021 (RSA),  3.250 (SQMODN)  
                     Sign ( 768 bits):   4.232 (total),  0.495 (RSA),  3.736 (SQMODN)  
                     Veri ( 768 bits):   3.745 (total),  0.028 (RSA),  3.716 (SQMODN)  
                     Sign (1024 bits):   6.079 (total),  1.123 (RSA),  4.955 (SQMODN)  
                     Veri (1024 bits):   4.901 (total),  0.048 (RSA),  4.850 (SQMODN)  
-------------------------------------------------------------------------------------
md2WithRsa           OID { 1 3 14 7 2 3 1 } NULL parameter
                     Sign ( 512 bits):   1.310 (total),  0.166 (RSA),  1.142 (MD2)  
                     Veri ( 512 bits):   1.115 (total),  0.013 (RSA),  1.101 (MD2)  
                     Sign ( 640 bits):   1.444 (total),  0.323 (RSA),  1.119 (MD2)  
                     Veri ( 640 bits):   1.149 (total),  0.020 (RSA),  1.127 (MD2)  
                     Sign ( 768 bits):   1.572 (total),  0.474 (RSA),  1.097 (MD2)  
                     Veri ( 768 bits):   1.135 (total),  0.028 (RSA),  1.106 (MD2)  
                     Sign (1024 bits):   2.186 (total),  1.093 (RSA),  1.092 (MD2)  
                     Veri (1024 bits):   1.147 (total),  0.052 (RSA),  1.094 (MD2)  
-------------------------------------------------------------------------------------
md4WithRsa           OID { 1 3 14 3 2 2 } NULL parameter
                     Sign ( 512 bits):   0.212 (total),  0.168 (RSA),  0.043 (MD4)  
                     Veri ( 512 bits):   0.042 (total),  0.013 (RSA),  0.027 (MD4)  
                     Sign ( 640 bits):   0.353 (total),  0.317 (RSA),  0.034 (MD4)  
                     Veri ( 640 bits):   0.048 (total),  0.020 (RSA),  0.027 (MD4)  
                     Sign ( 768 bits):   0.526 (total),  0.497 (RSA),  0.028 (MD4)  
                     Veri ( 768 bits):   0.056 (total),  0.028 (RSA),  0.027 (MD4)  
                     Sign (1024 bits):   1.186 (total),  1.158 (RSA),  0.027 (MD4)  
                     Veri (1024 bits):   0.078 (total),  0.049 (RSA),  0.027 (MD4)  
-------------------------------------------------------------------------------------
md5WithRsa           OID { 1 3 14 3 2 3 } NULL parameter
                     Sign ( 512 bits):   0.218 (total),  0.182 (RSA),  0.035 (MD5)  
                     Veri ( 512 bits):   0.050 (total),  0.013 (RSA),  0.035 (MD5)  
                     Sign ( 640 bits):   0.354 (total),  0.318 (RSA),  0.035 (MD5)  
                     Veri ( 640 bits):   0.056 (total),  0.020 (RSA),  0.035 (MD5)  
                     Sign ( 768 bits):   0.527 (total),  0.492 (RSA),  0.035 (MD5)  
                     Veri ( 768 bits):   0.064 (total),  0.028 (RSA),  0.035 (MD5)  
                     Sign (1024 bits):   1.109 (total),  1.071 (RSA),  0.037 (MD5)  
                     Veri (1024 bits):   0.085 (total),  0.048 (RSA),  0.035 (MD5)  
-------------------------------------------------------------------------------------
dsaWithSHA           OID { 1 3 14 3 2 13 } NULL parameter
                     Sign ( 512 bits):   0.235 (total),  0.197 (DSA),  0.037 (SHA)  
                     Veri ( 512 bits):   0.393 (total),  0.347 (DSA),  0.044 (SHA)  
                     Sign ( 640 bits):   0.293 (total),  0.255 (DSA),  0.037 (SHA)  
                     Veri ( 640 bits):   0.536 (total),  0.498 (DSA),  0.037 (SHA)  
                     Sign ( 768 bits):   0.367 (total),  0.329 (DSA),  0.037 (SHA)  
                     Veri ( 768 bits):   0.747 (total),  0.708 (DSA),  0.037 (SHA)  
                     Sign (1024 bits):   0.622 (total),  0.584 (DSA),  0.037 (SHA)  
                     Veri (1024 bits):   1.235 (total),  1.197 (DSA),  0.037 (SHA)  
-------------------------------------------------------------------------------------
md2WithRsaEncryption OID { 1 2 840 113549 1 1 2 } NULL parameter
                     Sign ( 512 bits):   1.368 (total),  0.186 (RSA),  1.181 (MD2)  
                     Veri ( 512 bits):   1.116 (total),  0.015 (RSA),  1.100 (MD2)  
                     Sign ( 640 bits):   1.431 (total),  0.341 (RSA),  1.089 (MD2)  
                     Veri ( 640 bits):   1.108 (total),  0.021 (RSA),  1.086 (MD2)  
                     Sign ( 768 bits):   1.580 (total),  0.488 (RSA),  1.090 (MD2)  
                     Veri ( 768 bits):   1.128 (total),  0.028 (RSA),  1.099 (MD2)  
                     Sign (1024 bits):   2.195 (total),  1.110 (RSA),  1.084 (MD2)  
                     Veri (1024 bits):   1.136 (total),  0.049 (RSA),  1.086 (MD2)  
-------------------------------------------------------------------------------------
md4WithRsaEncryption OID { 1 3 14 3 2 4 } NULL parameter
                     Sign ( 512 bits):   0.201 (total),  0.172 (RSA),  0.028 (MD4)  
                     Veri ( 512 bits):   0.044 (total),  0.014 (RSA),  0.029 (MD4)  
                     Sign ( 640 bits):   0.376 (total),  0.342 (RSA),  0.033 (MD4)  
                     Veri ( 640 bits):   0.049 (total),  0.020 (RSA),  0.027 (MD4)  
                     Sign ( 768 bits):   0.524 (total),  0.496 (RSA),  0.027 (MD4)  
                     Veri ( 768 bits):   0.057 (total),  0.028 (RSA),  0.028 (MD4)  
                     Sign (1024 bits):   1.149 (total),  1.121 (RSA),  0.027 (MD4)  
                     Veri (1024 bits):   0.077 (total),  0.049 (RSA),  0.027 (MD4)  
-------------------------------------------------------------------------------------
md5WithRsaEncryption OID { 1 2 840 113549 1 1 4 } NULL parameter
                     Sign ( 512 bits):   0.216 (total),  0.181 (RSA),  0.035 (MD5)  
                     Veri ( 512 bits):   0.050 (total),  0.014 (RSA),  0.035 (MD5)  
                     Sign ( 640 bits):   0.363 (total),  0.327 (RSA),  0.035 (MD5)  
                     Veri ( 640 bits):   0.056 (total),  0.020 (RSA),  0.035 (MD5)  
                     Sign ( 768 bits):   0.537 (total),  0.501 (RSA),  0.035 (MD5)  
                     Veri ( 768 bits):   0.064 (total),  0.028 (RSA),  0.035 (MD5)  
                     Sign (1024 bits):   1.152 (total),  1.116 (RSA),  0.035 (MD5)  
                     Veri (1024 bits):   0.086 (total),  0.049 (RSA),  0.035 (MD5)  
-------------------------------------------------------------------------------------
md2WithRsaTimeDate   OID { 1 3 36 3 1 22 } NULL parameter
                     Sign ( 512 bits):   1.277 (total),  0.189 (RSA),  1.087 (MD2)  
                     Veri ( 512 bits):   1.119 (total),  0.029 (RSA),  1.087 (MD2)  
                     Sign ( 640 bits):   1.423 (total),  0.327 (RSA),  1.095 (MD2)  
                     Veri ( 640 bits):   1.136 (total),  0.041 (RSA),  1.094 (MD2)  
                     Sign ( 768 bits):   1.594 (total),  0.503 (RSA),  1.089 (MD2)  
                     Veri ( 768 bits):   1.150 (total),  0.056 (RSA),  1.092 (MD2)  
                     Sign (1024 bits):   2.196 (total),  1.109 (RSA),  1.086 (MD2)  
                     Veri (1024 bits):   1.206 (total),  0.116 (RSA),  1.089 (MD2)  
-------------------------------------------------------------------------------------
md4WithRsaTimeDate   OID { 1 3 36 3 1 24 } NULL parameter
                     Sign ( 512 bits):   0.208 (total),  0.180 (RSA),  0.027 (MD4)  
                     Veri ( 512 bits):   0.057 (total),  0.028 (RSA),  0.027 (MD4)  
                     Sign ( 640 bits):   0.356 (total),  0.328 (RSA),  0.027 (MD4)  
                     Veri ( 640 bits):   0.069 (total),  0.041 (RSA),  0.027 (MD4)  
                     Sign ( 768 bits):   0.534 (total),  0.505 (RSA),  0.027 (MD4)  
                     Veri ( 768 bits):   0.085 (total),  0.056 (RSA),  0.027 (MD4)  
                     Sign (1024 bits):   1.248 (total),  1.219 (RSA),  0.027 (MD4)  
                     Veri (1024 bits):   0.129 (total),  0.100 (RSA),  0.027 (MD4)  
-------------------------------------------------------------------------------------
md5WithRsaTimeDate   OID { 1 3 36 3 1 25 } NULL parameter
                     Sign ( 512 bits):   0.209 (total),  0.173 (RSA),  0.035 (MD5)  
                     Veri ( 512 bits):   0.063 (total),  0.027 (RSA),  0.035 (MD5)  
                     Sign ( 640 bits):   0.372 (total),  0.336 (RSA),  0.035 (MD5)  
                     Veri ( 640 bits):   0.077 (total),  0.041 (RSA),  0.035 (MD5)  
                     Sign ( 768 bits):   0.545 (total),  0.509 (RSA),  0.035 (MD5)  
                     Veri ( 768 bits):   0.093 (total),  0.056 (RSA),  0.035 (MD5)  
                     Sign (1024 bits):   1.145 (total),  1.109 (RSA),  0.035 (MD5)  
                     Veri (1024 bits):   0.134 (total),  0.098 (RSA),  0.035 (MD5)  
\end{verbatim}
}

\nm{1}{encode}{encode/decode files}
\addtotoc{decode}
\label{encode}
\hl{Synopsis}
{\bf encode} [ {\bf -r} ] [ {\bf -x} ] [ {\bf -a} ] [ {\bf -i} {\em number} ] [ {\em sourcefile} ] [ {\em destinationfile} ]

{\bf decode} [ {\bf -r} ] [ {\bf -x} ] [ {\bf -a} ] [ {\em sourcefile} ] [ {\em destinationfile} ]
\hl{Description}
{\bf Encode} encodes {\em sourcefile} into {\em destinationfile} according to the encoding scheme
specified by options {\bf -r}, {\bf -x} or {\bf -a}. Only one of those three option may be given.
Encoding means transforming the content of the file (which might be arbitrary binary information)
into a printable ASCII representation.
If {\em destinationfile} is omitted, the program encodes to {\bf stdout}. 
If {\em sourcefile} is also omitted, it encodes from {\bf stdin} to {\bf stdout}.

{\bf Decode} does the reverse process.
 
\hl{Options}
\parname {{\bf -r}}
\pardescript {Encode/decode according to the PEM encoding scheme specified in RFC 1421 (see below).
The encoded file is about one third larger than the source file. This option is the
default value.}

\parname {{\bf -x}}
\pardescript {This encoding/decoding uses a [0 - 9, A - F] ASCII representation for each half-octet
(4 bits). The size of the encoded file is double the size of the source file plus inserted extra NEWLINEs 
(see option -i).}

\parname {{\bf -a}}
\pardescript {Like option -x except that a [ A - P ] ASCII representation is used.}

\parname {{\bf -i} {\em number}} 
\pardescript {NEWLINE characters are inserted into the encoded text every {\em number} characters in 
order to allow
the encoded text to be handled by editors and mail systems. The default {\em number} is 64. A {\em 
number}
of zero avoids NEWLINE insertion. This option applies only for {\em encode}. {\em Decode}
ignores all NEWLINEs.}
\newpage
The PEM encoding scheme maps each 24 bit (three octet) binary group into four octets
printable ASCII in that it maps each 6 bit binary input to one octet ASCII output
according to the following mapping table:
\begin{center}
\begin{tabular} {|cc|cc|cc|cc|} \hline
Value & Encoding & Value & Encoding & Value & Encoding & Value & Encoding \\ \hline
 0 & A & 17 & R & 34 & i & 51 & z \\
 1 & B & 18 & S & 35 & j & 52 & 0 \\
 2 & C & 19 & T & 36 & k & 53 & 1 \\
 3 & D & 20 & U & 37 & l & 54 & 2 \\
 4 & E & 21 & V & 38 & m & 55 & 3 \\
 5 & F & 22 & W & 39 & n & 56 & 4 \\
 6 & G & 23 & X & 40 & o & 57 & 5 \\
 7 & H & 24 & Y & 41 & p & 58 & 6 \\
 8 & I & 25 & Z & 42 & q & 59 & 7 \\
 9 & J & 26 & a & 43 & r & 60 & 8 \\
10 & K & 27 & b & 44 & s & 61 & 9 \\
11 & L & 28 & c & 45 & t & 62 & + \\
12 & M & 29 & d & 46 & u & 63 & / \\
13 & N & 30 & e & 47 & v &    &   \\
14 & O & 31 & f & 48 & w & (pad) & = \\
15 & P & 32 & g & 49 & x &    &   \\
16 & Q & 33 & h & 50 & y &    &   \\ \hline
\end{tabular}
\\ [1em]
Printable Encoding Characters \\
\end{center}
Input quantities less than 24 bits are padded with zeros and mapped
to the padding character '='. \\ [1em]

\hl{See Also}
aux\_enchex(3X)

\nm{1}{encrypt}{encrypt/decrypt files}
\addtotoc{decrypt}
\label{encrypt}
\hl{Synopsis}
{\bf encrypt} [ {\bf -DnxvVWtU} ] [ {\bf -k} {\em key} ] [ {\bf -r} {\em recipient} ] [ {\bf -w} {\em pw} ] [ {\bf -e} {\em deskey} ] [ {\bf 
-E} {\em encalg} ] 
\\ \hspace*{1.59cm} [ {\bf -p} {\em psename} ] [ {\bf -c} {\em cadir} ] [ {\bf -d} {\em dsaname} ] [ {\bf -A} {\em authlevel} ] [ {\em files} ]

{\bf decrypt} [ {\bf -nxvVWtU} ] [ {\bf -k} {\em key} ] [ {\bf -w} {\em pw} ] [ {\bf -e} {\em deskey} ] [ {\bf -E} {\em decalg} ] \\
\hspace*{1.59cm} [ {\bf -p} {\em psename} ] [ {\bf -c} {\em cadir} ] [ {\em files} ]
\hl{Description}

{\large\bf Encrypt} encrypts all files listed in {\em files}. It transforms each
file from {\em files} into a corresponding file {\em file}.enc, using 
an algorithm and key which are indicated by one of the options 
{\bf -k}, {\bf -r}, {\bf -w}, or {\bf -e}. Not more than one of those options 
must be given.
The plainfiles are removed after the encryption.

If the use of an asymmetric algorithm is indicated through
these parameters, the so called hybrid method will be applied; i.e. encrypt
generates a DES key, encrypts the file with DES-CBC using this DES-KEY,
and asymmetrically encrypts the DES key. The encrypted DES key is stored as
ASN.1 encoded data type EncryptedKey
in file {\em plainfile}.key which is created if it does not exists. Decrypt
does the reverse process using the given keys if it finds the file {\em plainfile}.key
It is not possible in the hybrid case to use encrypt and decrypt as a filter
which transforms stdin to stdout. Option {\bf -n} causes that in the asymmetric case
the hybrid method is not used, and that straight asymmetric encryption is
used instead (which is time consuming).
 
If none of the parameters {\bf -k}, {\bf -r}, {\bf -w}, or {\bf -e} is given, the own public
encryption key and algorithm which is contained in PSE object {\em Cert} or {\em EncCert} is used
for encryption. 
 
Parameter {\bf -k} {\em key} either denotes a PSE object of type KeyInfo or Certificate, 
or a key reference of type KeyInfo, which contains the encryption key.

The location of the PSE is determined by {\bf -p} {\em psename} and/or {\bf -c} {\em cadir}. 
The default for {\em 
psename} is either provided by the environment variable PSE, or is .pse under the HOME directory, 
if no such variable exists.
 
The default for {\em cadir} is NULL. 

If {\em cadir} is specified,
however, the PSE identified by {\em psename} resides under {\em cadir}; in this case, the default
for {\em psename} is either provided by the environment variable CAPSE, or is .capse, if no such variable
exists. 
 
If option {\bf -r} is given, encryption is done with the public encryption key
of the intended recipient {\em recipient}. {\em recipient} is either a Name (see INTRO(1) on Names)
for which an entry exists in PSE object PKList or EKList, or an alias name. If option {\bf -D}
is provided, the public encryption key is searched for in the X.500 Directory, after it could
neither be found in the PSE nor in the local .af-db Directory.
 
If the X.500 Directory is accessed, parameter {\em dsaname} (option {\bf -d}) allows to specify the name of the DSA (Directory System Agent) which
will initially be contacted. {\em dsaname} is a name which must be provided in the 
{\em dsaptailor} file of the system as {\em dsa\_address} parameter. If {\bf -d} {\em dsaname} is
not given, the default DSA, which is the first {\em dsa\_address} parameter in the {\em dsaptailor} 
file, is contacted.
Parameter {\em authlevel} (option {\bf -A}) may be provided to determine the level of authentication used when binding. If {\bf -A} {\em authlevel} is omitted, the requested 
level of authentication is taken from the environment variable AUTHLEVEL, and is set to {\em no 
authentication}, if no such variable exists.
In case of simple authentication being used, the caller's distinguished name and
X.500 password are retrieved from the PSE objects Name and QuipuPWD, respectively.
 
Parameter {\bf -w} {\em pw} denotes DES-CBC encryption with {\em pw} being a password from which the 
DES key 
is derived through a one-way function.
 
Parameter {\bf -e} {\em deskey} denotes DES-CBC encryption with {\em deskey} comprising the key itself.
If option {bf -x} is given in that case, the DES key is a 16 character string comprising
the key in the [ 0 - 9, A - F ] notation. Otherwise, the key is the bitstring given through
an 8 character long string.

Parameter {\bf -E} {\em encalg} allows to specify an alternative symmetric encryption algorithm.
DES-CBC is the default.

Option {\bf -v} renders the encrypt command verbose, and options {\bf -V} and {\bf -W} provide
some further logging information.

Option {\bf -t} may be provided for testing purposes; it requests to control the malloc/free behaviour.
Option {\bf -U} requests to measure the time used for the cryptographic computations. 
In case that a smartcard terminal is used, option {\bf -T} requests to perform each public key 
RSA operation in the smartcard terminal, and not with the software in the workstation 
(the latter is the default). 
\\ [1em]

{\large\bf Decrypt} decrypts all files which are listed in {\em files} to the corresponding
plainfiles. The filenames in {\em files} should have the .enc suffix (this can be omitted;
however when shell metacharacters are used, the suffixes must not be omitted since
otherwise the shell wouldn't be able to expand the filenames). The .enc files are
removed after the decryption. If decrypt
finds a corresponding {\em file}.key file, it assumes that this contains an asymmetrically
encrypted DES key and applies the hybrid method.
 
Algorithm and key are indicated by one of the options 
{\bf -k}, {\bf -w}, or {\bf -e}. Not more than one of those options 
must be given. If none of the options {\bf -k}, {\bf -w}, or {\bf -d} is given, the own
secret decryption key which is contained in PSE object {\em SKnew} or
{\em DecSKnew} is used for decryption. 

If none of the parameters {\bf -k}, {\bf -w}, or {\bf -e} is given, the own secret
decryption key and algorithm which is contained in PSE object {\em SKnew/SKold} or {\em 
DecSKnew/DecSKold}
is used for the decryption.
 
Parameter {\bf -k} {\em key} denotes a PSE object or a key reference of type KeyInfo
which contains the decryption key.
 
The PSE is indicated through parameter {\bf -p} {\em psename} or {\bf -c} {\em cadir}. If none of them
is given, the default PSE .pse is used.

Parameter {\bf -w} {\em pw} denotes DES-CBC encryption with {\em pw} being a password from which the 
DES key 
is derived through a one-way function.
 
Parameter {\bf -e} {\em deskey} denotes DES CBC decryption with {\em deskey} comprising the key itself.
If option {bf -x} is given in that case, the DES key is a 16 character string comprising
the key in the [ 0 - 9, A - F ] notation. Otherwise, the key is the bitstring given through
an 8 character long string.

Parameter {\bf -E} {\em decalg} allows to specify an alternative symmetric encryption algorithm.
DES-CBC is the default.

Option {\bf -v} renders decrypt verbose, and options {\bf -V} and {\bf -W} provide some further logging
information. For test purposes, option {\bf -t} requests
to control the malloc/free behaviour, and option {\bf -U} requests to measure the time used for the 
cryptographic
algorithms.
\\ [1em]

{\bf Original file length encoding}

Since the encrypted file has always a multiple of {\em blocksize} or {\em keysize} octets,
additional encoding of the original file length must be added to the plain file prior
to encryption in order to be able to restore the original file during decryption.
 
Several algorithm identifier already imply a method of additional padding (see INTRO(3X)
about algorithms). If an algorithm is used which does not imply padding, the
following padding methods are applied:
 
In case of DES ({\em blocksize} eight octets), the last octet of the last block of the
decrypted file contains the number of valid octets of that block (between 0 and 7), i.e.
if the original file consists of a multiple of eight octets, one extra block is added
with the last octet set to zero.

In case of RSA, the plain file is blocked into portions of {\em blocksize} octets which
are encrypted into portions of {\em keysize} bits each. The parameter {\em keysize}
belongs to the algorithm while {\em blocksize} is derived from {\em keysize} as
$blocksize = (keysize - 1)/8$. The last octet of the last block of the
decrypted file contains the number of valid octets of that block (between 0 and 255), i.e.
if the original file consists of a multiple of {\em blocksize} octets, one extra block is added
with the last octet set to zero. For this reason the maximum RSA keysize for {\em encrypt}
is 2048.

\hl{Options}

\parname {{\bf -k} {\em key}}
\pardescript {If {\em key} is numeric, it denotes a key reference under which key and 
corresponding algorithm identifier was previously installed. If {\em key} contains 
also non-numeric characters, it denotes the name of a PSE object which contains 
the key and corresponding algorithm identifier. This PSE object must be of type KeyInfo.}  
 
\parname {{\bf -r} {\em recipient}}
\pardescript {{\em user} is the Name of an intended recipient whose public encryption key is used
for encryption. This option applies only for {\em encrypt}. {\em recipient} may be a distinguished
name (in the Name form, must be quoted) or an alias. The corresponding public key is searched
in the PSE-object PKList or EKList and after this in the local afdb Directory. In case that
option {\bf -D} is given, the PK is addiotionally searched in the X.500 Directory.}
i  
\parname {{\bf -w} {\em pw}}
\pardescript {Encryption/decryption with desCBC using a password. The arbitrary long {\em pw} is 
transformed into the DES key using a one-way hash function.
If {\em pw} is omitted, the program prompts for a password from /dev/tty.}
 
\parname {{\bf -e} {\em deskey}}
\pardescript {Encryption/decryption with desCBC. {\em deskey} is an eight character 
ASCII string which comprises the key.}

\parname {{\bf -n}}
\pardescript {Don't use the hybrid method in case that the encryption algorithm is asymmetric.}
 
\parname {{\bf -x}} 
\pardescript {This option applies only in conjunction with option {\bf -e}. In this case,
{\em deskey} is the 16-character hexadecimal representation of the key (i.e. ASCII
characters from [0 - 9] and [a - f] or [A - F]).}

\parname {{\bf -E}} 
\pardescript {This option applies only in conjunction with options {\bf -w} or {\bf -d}. 
In this case, desECB is used instead of desCBC.}

\parname {{\bf -p} {\em psename}}
\pardescript {With this parameter 
the PSE {\em psename} is selected instead of the default PSE {\em .pse}.}

\parname {{\bf -c} {\em cadir}}
\pardescript {{\em cadir} is the CA directory whose PSE is used for encrypt/decrypt.}

\parname {{\bf -v}}
\pardescript {Makes sign and verify verbose.}

\parname {{\bf -V}}
\pardescript {Makes sign and verify Verbose.}

\parname {{\bf -t}}
\pardescript {Enables the control of the malloc/free behaviour. For tests only.}

\parname {{\bf -T}}
\pardescript {Enforces that public key RSA operations are performed in the smartcard terminal
instead with software in the workstation, which is the default. Applies only if smartcards
are used.}

\parname {{\bf -U}}
\pardescript {Enables the measurement of time used for the cryptographic algorithms. For tests only.}

\hl{See Also}
af\_encrypt(3), af\_decrypt(3)

\nm{1}{hsh}{hash files}
\label{hsh}
\hl{Synopsis}
{\bf hsh} [ {\bf -a} {\em alg} ] [ {\bf -k} {\em pk} ] [ {\bf -c} {\em cert} ] [ {\bf -p} {\em psename} ] [ {\em file} ] [ 
{\em hashvalue} ] \\
\hl{Description}
{\bf Hsh} generates an hash-value of {\em file}. The hash-value is stored in file {\em hashvalue}.
If {\em hashvalue} is omitted, 
the hash value is stored in the file {\em file}.hsh. If {\em file} and {\em hashvalue} are omitted, stdin is 
hashed and 
the hash value is written to stdout.

{\em alg} must be a name of an available hash algorithm (see INTRO(3X)). If option
{\em -a} is not given, MD4 is used.

If the algorithm Sqmodn is used, {\bf -k} {\em pk} or {\bf -c} {\em cert}
can be aditionally given. {\em pk} is the object name or key reference of a public RSA key.
{\em cert} is the object name of a certificate which contains a public RSA
key. The modulus of this public RSA key is used for the sqmodn function. If neither -k nor -c
is given, the public key of the PSE object SignCert is used. 

\hl{Options}
\parname {{\bf -a} {\em alg}}
\pardescript {Name of the hash algorithm to be used (default MD5).}

\parname {{\bf -h} {\em pk}}
\pardescript {Object name or key reference of a public RSA key. This is for Sqmodn only.}

\parname {{\bf -c} {\em cert}}
\pardescript {Object name of a certificate which contains a public RSA key. This is for Sqmodn only.}
  
\parname {{\bf -p} {\em psename}}
\pardescript {PSE {\em psename} is used instead of the default PSE {\em .pse}. 
This is for Sqmodn only.}
 
\hl{See Also}
sec\_hash(3)

\nm{1}{km}{Key and certification management and CA provision package}
\label{km}
\hl{Synopsis}
Commands for the CA role:

{\bf cacreate} [ {\bf -hqtvDVW} ] [ {\bf -c} {\em cadir} ] [ {\bf -p} {\em capsename} ] [ {\bf -a} {\em issueralg} ]
             \\ \hspace*{1.6cm} [ {\bf -s} {\em signalg} ] [ {\bf -e} {\em encalg} ] [ {\bf -k} {\em keysize} ]
             \\ \hspace*{1.6cm} [ {\bf -n} {\em serial} ] [ {\bf -u} {\em nextupdate} ] [ {\bf -f} {\em notbefore} ]
	     \\ \hspace*{1.6cm} [ {\bf -l} {\em notafter} ] [ {\bf -d} {\em dsaname} ] [ {\bf -A} {\em authlevel} ] [ {\em Name} ] \\
{\bf getpkroot} [ {\bf -htvVW} ] [ {\bf -c} {\em cadir} ] [ {\bf -p} {\em capsename} ] [ {\em pkroot} ] \\
{\bf getfcpath} [ {\bf -htvVW} ] [ {\bf -c} {\em cadir} ] [ {\bf -p} {\em capsename} ] [ {\em fcpath} ] \\
{\bf certify} [ {\bf -htvVW} ] [ {\bf -c} {\em cadir} ] [ {\bf -p} {\em capsename} ] [ {\bf -a} {\em issueralg} ] \\
\hspace*{1.6cm} [ {\bf -f} {\em notbefore} ] [ {\bf -l} {\em notafter} ] [{\em proto} [{\em cert}]] \\
{\bf gen\_pse} [ {\bf -c} {\em cadir} ] [ {\bf -p} {\em capsename} ] [ {\bf -i} {\em scriptfile} ] [ {\bf -h} {\em 
home} ] [ {\bf -u} {\em unixname} ] \\ 
\hspace*{1.6cm} [ {\bf -a} {\em issueralg} ] [ {\bf -s} {\em signalg} ] [ {\bf -e} {\em encalg} ] [ {\bf -k} {\em 
keysize} ] \\ 
\hspace*{1.6cm} [ {\bf -f} {\em notbefore} ] [ {\bf -l} {\em notafter} ] [ {\bf -x} {\em nameprefix} ]  \\ 
\hspace*{1.6cm} [ {\bf -P} {\em subjectpse} ] [ {\bf -C} {\em subjectca} ] [ {\bf -g} {\em serialnumber} ] \\
\hspace*{1.6cm} [ {\bf -d} {\em dsaname} ] [ {\bf -vrDqtnh} ] [ {\em namesuffix} ] \\
{\bf revoke} [ {\bf -htvVWD} ] [ {\bf -c} {\em cadir} ] [ {\bf -p} {\em capsename} ] [ {\bf -a} {\em issueralg} ] 
             \\ \hspace*{1.6cm} [ {\bf -u} {\em nextupdate} ] [ {\bf -d} {\em dsaname} ] [ {\bf -A} {\em authlevel} ] \\
{\bf create\_TestTree} [ {\bf -vPqt} ] \\
{\bf delete\_TestTree}
\\ [1em]
Commands for the user role:

{\bf psecreate} [ {\bf -hqtvVW} ] [ {\bf -p} {\em psename} ] [ {\bf -s} {\em signalg} ] 
             \\ \hspace*{1.5cm} [ {\bf -e} {\em encalg} ] [ {\bf -k} {\em keysize} ] [ {\em Name} ] \\ 
{\bf instpkroot} [ {\bf -htvVW} ] [ {\bf -c} {\em cadir} ] [ {\bf -p} {\em psename} ] [ {\em pkroot} ] \\
{\bf instfcpath} [ {\bf -htvVW} ] [ {\bf -c} {\em cadir} ] [ {\bf -p} {\em psename} ] [ {\em fcpath} ] \\
{\bf genkey} [ {\bf -hrtvVW} ] [ {\bf -c} {\em cadir} ] [ {\bf -p} {\em psename} ] [ {\bf -a} {\em issueralg} ] \\
\hspace*{1.6cm} [ {\bf -s} {\em signalg} ] [ {\bf -e} {\em encalg} ] [ {\bf -k} {\em keysize} ] \\ 
\hspace*{1.6cm} [ {\em proto} ] \\
{\bf getkey} [ {\bf -ehstvVW} ] [ {\bf -c} {\em cadir} ] [ {\bf -p} {\em psename} ] [ {\em proto} ] 
\\
{\bf instcert} [ {\bf -aehrtvVWHD} ] [ {\bf -c} {\em cadir} ] [ {\bf -p} {\em psename} ] [ {\bf -d} {\em dsaname} ] [ {\bf -A} {\em authlevel} ] [ {\em cert} ] \\
{\bf pklist} [ {\bf -ehtvVW} ] [ {\bf -c} {\em cadir} ] [ {\bf -p} {\em psename} ] \\
{\bf pkadd} [ {\bf -aehitvVW} ] [ {\bf -c} {\em cadir} ] [ {\bf -p} {\em psename} ] [ {\bf -d} {\em dsaname} ] \\
\hspace*{1.6cm} [ {\bf -A} {\em authlevel} ] {\em Name} \\
{\bf pkdel} [ {\bf -ehtvVW} ] [ {\bf -c} {\em cadir} ] [ {\bf -p} {\em psename} ] [ {\bf -o} {\em owner} ] \\
\hspace*{1.6cm} [ {\bf -i} {\em issuer} ] [ {\bf -n} {\em serial} ] \\
{\bf showdir} [ {\bf -aehtvVW} ] [ {\bf -c} {\em cadir} ] [ {\bf -p} {\em psename} ] [ {\bf -o} {\em attributeType} ] \\ \hspace*{1.6cm} [ {\bf -d} {\em dsaname} ] [ {\bf -A} {\em authlevel} ] {\em Name} \\
{\bf inst\_pse} {\em file} \\
{\bf inst\_ca} {\em file} \\
\hl{Description}
The KM-package provides commands for the establishment of arbitrary Certification Authority (CA) trees 
and for the key and certificate exchange between CAs and users (who may be CAs again). 
It comprises commands for the creation of both CA PSEs and user PSEs
including the generation and exchange of the necessary PSE objects. Recall that a PSE is
a protected area which holds the necessary secret keys, certificates and other security
information objects and which is only accessible by the subject which the PSE owns. A PSE
can be either a smartcard or a DES-protected Unix-directory, or a combination of both (in
case that the smartcard is not capable of storing all necessary information).

A  SecuDE-CA is characterized by the CA directory (which is indicated through {\bf -c} {\em cadir} 
in the KM-commands).
This is a Unix-directory which contains the CA PSE and the CA database. The CA database
stores all certified users, issued certificates, blacklists and the like. It is realized by means of 
Unix ndbm. A CA can be operated by means of the commands of the KM-package and by means of the 
commands {\em sectool(1)} or {\em psemaint(1)} (see there). Sectool(1) is an OpenLook style 
tool which allows the manipulation of the CA PSE and the examination of the CA database, and 
the communication with the directory.

The KM-package provides commands for the CA role and commands for the user role (which can be 
established 
on different systems or through different User-IDs on the same system, for instance). 
An entity plays both the CA role towards the certified users and the user role towards the certifying
CA, if it is neither the highest CA (Root-CA) nor an end user.

The package basicly provides a file interface for the exchange of keys, certificates, other
PSE objects or entire PSEs between users and CAs. The content of these files is the ASN.1 BER data 
representation in case of PSE objects, or a compressed tar-file in case of entire PSEs. The files
can be exchanged by any communication means like file-transfer or electronic-mail, or                
simply file-copy if the communicating user and CA reside in the same (may be distributed)
file-system. They may be subject to processing through {\em sign(1)}, {\em verify(1)}, {\em encrypt(1)},
{\em decrypt(1)}, {\em encode(1)} or {\em uuencode(1)}, {\em decode(1)} or {\em uudecode(1)}
before and after communication, depending on the integrity/confidentiality needs in the
communication between CA and user, or when using SMTP-mail or similar communication means 
which are only capable of transfering printable ASCII text.

The CAs of a CA tree should be created in descending order, i.e. beginning with
the highest CA, because some PSE objects must propagate from top to bottom through the CA-system 
from the top-level CA to the user at the leaf (the forward certification path, for
instance, grows when going down the certification tree).
\\ [1em]
{\bf One or two RSA Key Pairs for Signature and Encryption Purposes}

Each subject's PSE (of both CAs or users) may contain two RSA key pairs, one for signature
purposes and one for encryption purposes. SecuDE allows the separation of these two
functionalities through maintaining two different RSA key pairs.
The signature keys are stored in the PSE objects
SignSK and SignCert, the latter containing the public key as certificate. The encryption
keys are stored in the PSE objects DecSKnew and EncCert. The use of this type of PSEs
must be indicated through use of option {\bf -q} in the corresponding commands.

Some applications, however, require the use of a single key pair for signature
and encryption processes. In PEM, for instance, the same RSA key pair is being used
for MIC computation and DEK exchange. Therefore, the KM-package allows to create
PSEs with a single RSA key pair for both functionalities. This is the default option
of the KM-package (no use of option {\bf -q} in the corresponding commands). 
In this case, only the PSE objects SKnew and Cert are generated.
\\[1em]
{\bf Top-Level CA (Root CA)}

The top-level CA ( or {\bf Root-CA}) can be created using {\em cacreate} (the detailed 
description of the KM commands follows below). Root-CAs use a public keys which are
not further certified. A Root-CA has self-signed certificates of its own public
signature key and encryption key in its PSE objects Cert or SignCert/EncCert.
\\ [1em]
{\bf User-generated or CA-Generated RSA Keys}

Once a Root-CA is created or exists elsewhere, one has two possibilities
to create the next certification level down:
\be
\m The RSA keys are generated at the user site.
\m The RSA keys are generated at the CA site.
\ee
{\bf In case of 1.}, the KM-packaged provides the commands {\em psecreate} or
{\em cacreate}, {\bf getpkroot}, {\em instpkroot}, {\bf getfcpath}, {\em instfcpath},
{\em genkey} or {\em getkey}, {\bf certify} and {\em instcert}. Commands in bold are
to be performed at the CA site while commands in italic are to be performed at the user site.
These commands generate Unix-files comprising the necessary PSE objects, 
which can be exchanged between CA and user
in order to build the user PSE. The Unix-files contain the ASN.1-code
if the PSE objects. Note that it is not necessary to transmit the secret 
RSA keys of the user between user and CA, but that, however, there is a need for an
authentic and uncompromised transfer of the public security information
between CA and user. The Unix-files can be exchanged by any communication means like 
file-transfer or electronic-mail, or simply file-copy if the communicating user and CA 
reside in the same (may be distributed) file-system. They may be subject to processing 
through {\em sign(1)}, {\em verify(1)}, {\em encrypt(1)},
{\em decrypt(1)}, {\em encode(1)} or {\em uuencode(1)}, {\em decode(1)} or {\em uudecode(1)}
before and after communication, depending on the integrity/confidentiality needs in the
communication between CA and user, or when using SMTP-mail or similar communication means 
which are only capable of transfering printable ASCII text. The out-of-band exchange
of transaction keys (or transport keys) between user and CA which are being used
with encrypt/decrypt is outside the scope of the KM-package.

An alternative solution for key distribution in the case that RSA keys are generated
at user sites is offered by PEM (RFC 1424). See {\em pem (1)} for key and certificate
distribution through PEM. 

{\bf In case of 2.}, a CA may generate entire user PSEs by means of the command
{\em gen\_pse}. This command allows to process a script file which contains
a list of users with their distinguished names, alias names and other control
information. The PSEs may be generated as encoded and compressed tar-files which can
be sent by any communication means to the user who can install it using {\em inst\_pse}. 
Gen\_pse allows also to generate
the user PSEs directly in the HOME directories of the users if CA and users reside
in the same system or share the same file-system in a local area network, e.g. NFS.
A third possibility is to generate smartcards with gen\_pse. PSEs which are generated
by gen\_pse are PIN-protected which allows a confidential transmission between
CA and user. 
\\ [1em]
{\bf Updating an Existing Certification Tree}

The KM-package allows also to 
to update an existing certification tree, e.g. if new RSA key pairs shall be used,
if existing keys shall be recertified, or if the existing certification tree shall be 
restructured, for instance if a new Root-CA shall be superordinated to the 
existing Root-CA.
\\ [1em]
{\bf Use of Directories} 
 
Obtaining public security information, like public keys, certificates,
crosscertificates and certificate revocation lists, from other persons or instances is
done either by direct communication between these persons or instances (as it
is the case with PEM, for instance), or by directory access. SecuDE provides the
necessary means to write security information into the directory when this
information is being generated and installed for use, or to read security
information from the directory from time to time to store it in a local cache.
This local cache is realized by means of PSE objects. 
The command {\em instcert}, for instance, allows to enter a user
certificate into a directory. The commands {\em pkadd} and {\em showdir}
retrieve certificates from a directory. All necessary DUA functions are
also available through the commands {\em sectool(1)} and {\em psemaint(1)}.
Sectool(1) is an OpenLook style command to maintain the PSE and to provide
the information flow between local PSE and directory, while psemaint(1) is the 
command-line oriented equivalent.

The directory access can be provided 
by SecuDE, per decision at run time, either through access to public
X.500 directories via DAP (Directory Access Protocol), or through access
to a local substitute. The local substitute is a (Unix) directory
which must be configured at \$TOP/secude/.af-db where \$TOP
is the installation-dependant parent directory of the secude directory. 
 
The .af-db directory contains one subdirectory per user. The name of this
subdirectory is the printable character string form of the distinguished name of the user (i.e.
the Name format which may contain blanks and shell metacharacters). It
contains the signature and encryption certificates (i.e. the public
keys) of that user in the files SignCert and EncCert, respectively. However, if the user owns a single 
RSA key pair for both signature and encryption purposes, the user's certificate is stored in the file
Cert.
If the user is a CA, additional files are provided for within the CA's .af-db subdirectory: Crosscertificates 
are stored in the
file CrossCSet, while a certificate revocation list is published in the file PemCRL.
 
The .af-db directory may be shared between different machines by means of NFS, but no other 
mechanisms are supplied to propagate the directory objects. 
 
See also {\bf sectool(1)} and {\bf psemaint(1)} for the access of directory located security objects.
 
{\bf Generating and maintaining PSEs}

The basic purpose of a PSE is to protect private information which is used
in security applications involving cryptographic algorithms. For a detailed 
description of the PSE see INTRO(1). The commands described in this
section build up a PSE. The following table shows which AF PSE objects are created or updated
by which commands:
{\small
\begin{tabular}{|l|l|l|} \hline 
PSE object   & Commands            & Comment                                             \\ \hline
Name         & psecreate,cacreate  & initial creation of PSE                             \\
PKRoot       & psecreate,cacreate, & installing public key of top level CA               \\
             & instpkroot,pem      &                                                     \\
FCPath       & instfcpath,pem      & installing own certification path                   \\
SKnew        & psecreate,cacreate  & generating a new secret key (one-keypair PSE only)  \\
Cert         & psecreate,cacreate, & installing certificate of public key as             \\
             & instcert,pem        & hierarchy certificate (one-keypair PSE only)        \\
CSet         & instcert            & installing certificate of public key as             \\
             &                     & crosscertificate (one-keypair PSE only)             \\
SignSK       & psecreate,cacreate  & generating a new secret signature key               \\
             &                     & (two-keypair PSE only)                              \\
DecSKnew     & psecreate,cacreate  & generating a new secret decryption key              \\
             &                     & (two-keypair PSE only)                              \\
SignCert     & psecreate,cacreate, & installing certificate of public signature key as   \\
             & instcert            & hierarchy certificate (two-keypair PSE only)        \\
EncCert      & psecreate,cacreate, & installing certificate of public encryption key as  \\
             & instcert            & hierarchy certificate (two-keypair PSE only)        \\
SignCSet     & instcert            & installing certificate of public signature key as   \\
             &                     & crosscertificate (two-keypair PSE only)             \\
EncCSet      & instcert            & installing certificate of public encryption key as  \\
             &                     & crosscertificate (two-keypair PSE only)             \\
PKList       & pkadd,psemaint,pem  & adding a certificate to the list of trusted         \\
             &                     & public keys (only verification keys in case of      \\
             &                     &  two-keypair PSE)                                   \\
EKList       & pkadd,psemaint      & adding a certificate to the list of trusted         \\
             &                     & public encryption keys (two-keypair PSE only)       \\
CrossCSet    & psemaint            & downloading a crosscertificate pair attribute       \\
             &                     & from CA Directory entry                             \\
CrlSet       & cacreate,revoke,    & creating or updating a CRL set                      \\
             & psemaint,pem        &                                                     \\
AliasList    & psemaint            & store user alias-list on PSE                        \\
QuipuPWD     & cacreate,psemaint,  & store X.500 password for simple authentication      \\
             & pkadd,showdir,      & on PSE                                              \\
             & instcert            &                                                     \\
EDBKey       & psemaint            & Symmetric encryption key for DSA database encryption \\
SerialNumbers & cacreate,certify,  & updating the serial number of the last              \\
             & pem                 & issued certificate (CAs only)                       \\ \hline
\end{tabular}
}

The necessary input data for those commands (except {\em psecreate}, {\em cacreate} and {\em genkey}) 
must be
supplied by the CA (the results of {\em getpkroot}, {\em getfcpath}, or {\em certify}, for instance). 
The commands {\em genkey} and {\em getkey} supply data about the certificate (the so called prototype 
certificate)
which is needed for certification by the CA. 
\\ [1em]
{\bf Commands for the CA role:} 
\\ [1em]
{\bf cacreate} [ {\bf -hqtvDVW} ] [ {\bf -c} {\em cadir} ] [ {\bf -p} {\em capsename} ] [ {\bf -a} {\em issueralg} ]
[ {\bf -s} {\em signalg} ] 
\\ \hspace*{2cm} [ {\bf -k} {\em keysize} ] [ {\bf -e} {\em encalg} ] [ {\bf -k} {\em keysize} ]
[ {\bf -n} {\em serial} ] [ {\bf -u} {\em nextupdate} ] 
\\ \hspace*{2cm} [ {\bf -f} {\em notbefore} ] [ {\bf -l} {\em notafter} ] [ {\bf -d} {\em dsaname} ] [ {\bf -A} {\em authlevel} ] [ {\em Name} ]
\\ [1em]
\addtotoc{cacreate}
{\em cacreate} creates the CA directory {\em cadir} (default: environment variable CADIR or .ca 
under the HOME directory)
which contains:
\bi
\m the prototype PSE of that CA. The PSE name is {\em capsename} (default: environment variable CAPSE or .capse). 
The CA
   PSE contains the PSE object {\em Serial} (this is in contrast to a user PSE). This PSE object 
   is an ASN.1-encoded integer which contains the serial 
   number of the most recently issued certificate.
   This serial number is incremented by each call of {\em certify}.
\m a database of that CA, comprising information about all certificates
   ever issued by that CA, and the CA's PEM revocation list. This database is built with 
ndbm(3).
\ei
The CA directory must not exist. 
The distinguished name of the CA is {\em Name}. 
If {\em Name} is omitted, it is requested from 
stdin. {\em Name} is stored as PSE object Name. 
It must be quoted when containing blanks and shell metacharacters (which is normally the case).
We recommend the use of different Name schemes for users and CAs in order to be 
able to distinguish from the syntax of the Name whether a CA or an end user is denoted.
One possibility is to require at least one surname or common name component
for an end user, while a CA is required not to have any of these components. 
 
If option {\bf -q} is not provided, however, the newly created CA's PSE contains one RSA keypair in the PSE 
objects {\bf SKnew} and {\bf Cert}. This type of CA is required within the PEM context, for instance.

Otherwise, if option {\bf -q} is provided, the PSE contains two keypairs 
in the PSE objects {\bf SignSK}/{\bf SignCert} and {\bf DecSKnew}/{\bf EncCert}. {\bf Cert} or 
{\bf SignCert}/{\bf EncCert} are self-signed prototype certificates.
The associated subject public key algorithm name (see intro(3X) about available 
algorithm names and their types) of {\bf Cert} or {\bf SignCert} is {\em signalg} (option {\bf -s}) or {\em rsa} 
by default, 
if omitted. Only algorithms of type {\em SIG} or {\em ASYM\_ENC} are valid. The optional
parameter {\em keysize} immediately following the {\bf -s} option is used to control
the keysize of the signature key.
The associated subject public key algorithm name of {\bf EncCert} (if requested by option {\bf -q})
is {\em encalg} (option {\bf -e}) or {\em rsa} by default, 
if omitted. Only algorithms of type {\em ASYM\_ENC} are valid. The optional
parameter {\em keysize} immediately following the {\bf -e} option is used to control
the keysize of the encryption key.

The prototype certificate Cert/SignCert is installed as PSE object PKRoot.

In addition, an empty certificate revocation list is created, whose {\em lastUpdate} component is set to the 
current time, whereas the value of the {\em nextUpdate} field may be specified by the {\em nextupdate} parameter (option {\bf -u}).

The empty certificate revocation list is stored in the CA's {\em pemcrlwithcerts} database 
and added to the 
PSE object CrlSet in the CA's PSE.
If option {\bf -D} is given, the empty revocation list is entered into the Directory 
(X.500 or local substitute, respectively).

The algorithm name associated with the signature of the prototype certificates 
(issuer algorithm) can be specified by {\em issueralg} 
(option {\bf -a}). {\em issueralg} must be a
signature algorithm (AlgType SIG, see INTRO(3) on available algorithms) which fits to the associated 
algorithm of the signature key (e.g., the algorithm md5WithRsa cannot be used with an ElGamal key).
The default for {\em issueralg} is md2WithRsaEncryption.
 
The period of validity of the self-signed certificate(s) may be specified by the
{\em notbefore} (option {\bf -f}) and {\em notafter} (option {\bf -l}) times.

If option {\bf -D} is provided, {\em cacreate} enters the prototype certificate(s)
into the Directory. 
The Directory may either be a X.500 directory or the local substitute provided by 
SecuDE ({\em .af-db}) (see also DirectoryType(5)).
If a X.500 Directory is accessed, the prototype certificates are added to the {\em cACertificate} 
attribute in the Root CA's X.500 directory entry.

If a X.500 directory is accessed, parameter {\em dsaname} (option {\bf -d}) allows to specify 
the name of the DSA (Directory System Agent) that
will initially be contacted. {\em dsaname} is a name which must be contained in the 
{\em dsaptailor} file of the system as {\em dsa\_address} parameter. If {\bf -d} {\em dsaname} is
not given, the default DSA, which is the first {\em dsa\_address} parameter in the {\em dsaptailor} 
file, is accessed. 
Parameter {\em authlevel} (option {\bf -A}) may be provided to determine the level of authentication used when binding. If {\bf -A} {\em authlevel} is omitted, the requested 
level of authentication is taken from the environment variable AUTHLEVEL, and is set to {\em no 
authentication}, if no such variable exists.
In case of simple authentication being used, the caller's distinguished name and
X.500 password are retrieved from the PSE objects Name and QuipuPWD, respectively.

Option {\bf -n} is used for specifying the initial value of the serial number to be used by that CA.
 
Option {\bf -t} may be provided for testing purposes; it requests to control the malloc/free behaviour.

Option {\bf -v} renders the cacreate command verbose, and options {\bf -V} and {\bf -W} provide some further logging information.
\\ [1em]
{\bf getpkroot} [ {\bf -htvVW} ] [ {\bf -c} {\em cadir} ] [ {\bf -p} {\em capsename} ] [ {\em pkroot} ]
\addtotoc{getpkroot}

{\em getpkroot} extracts the the PSE object PKRoot from the CA's PSE
and writes it to the file {\em pkroot} or stdout, if {\em pkroot} is omitted. 
This file can be sent to a user of the CA by any means,
who may then install it on his own PSE with the command instpkroot (see below). 
 
The PSE from which the public root information is extracted is identified by {\bf -p} {\em capsename} and/or
{\bf -c} {\em cadir}. 
The default for {\em cadir} is either provided by the environment variable
CADIR or is .ca, if no such variable exists.
The default for {\em capsename} is either provided by the environment variable
CAPSE or is .capse, if no such variable exists.

Option {\bf -t} may be provided for testing purposes; it requests to control the malloc/free behaviour.

Option {\bf -v} renders the getpkroot command verbose, and options {\bf -V} and {\bf -W} provide some further logging information.
\\ [1em]
{\bf getfcpath} [ {\bf -htvVW} ] [ {\bf -c} {\em cadir} ] [ {\bf -p} {\em capsename} ] [ {\em fcpath} ]
\addtotoc{getfcpath}

{\em getfcpath} reads the CA's PSE object FCPath, adds one further level
to it which comprises the CA's certificates Cert/SignCert and CSet/SignCSet (from the same PSE), and writes the 
extended FCPath
to the file {\em fcpath} or stdout, if {\em fcpath} is omitted. This file can be sent to a user 
affiliated to this
CA, who may then install it on his own PSE with the command instfcpath (see below). 
 
The PSE from which the FCPath is extracted is identified by {\bf -p} {\em capsename} and/or
{\bf -c} {\em cadir}. 
The default for {\em cadir} is either provided by the environment variable
CADIR or is .ca, if no such variable exists.
The default for {\em capsename} is either provided by the environment variable
CAPSE or is .capse, if no such variable exists.
 
Option {\bf -t} may be provided for testing purposes; it requests to control the malloc/free behaviour.

Option {\bf -v} renders the getfcpath command verbose, and options {\bf -V} and {\bf -W} 
provide some further logging information.
\\ [1em]
{\bf certify} [ {\bf -htvVW} ] [ {\bf -c} {\em cadir} ] [ {\bf -p} {\em capsename} ] [ {\bf -a} {\em issueralg} ] [ {\bf -f} {\em notbefore} ] \\
\hspace*{2cm} [ {\bf -l} {\em notafter} ] [{\em proto} [{\em cert}]]
\addtotoc{certify}

{\em certify} reads a prototype certificate (see {\em genkey} or {\em getkey}) from {\em proto},
replaces the issuer and serial number fields by CA values (taken from the CA's PSE), increments its 
serial number,
replaces the signature field by the CA's signature, and writes the resulting
certificate to {\em cert}. 

Certify reads the prototype certificate
from the file {\em proto} or stdin, if {\em proto} is omitted, and writes the certificate
to the file {\em cert} or stdout, if {\em cert} is omitted. 

The CA's signature 
algorithm can be specified with {\bf -a} {\em issueralg}. {\em issueralg} must be a
signature algorithm (AlgType SIG, see INTRO(3) on available algorithms) which fits to the associated 
algorithm of the signature key (e.g., the algorithm md5WithRsa cannot be used with an ElGamal key).
The default for {\em issueralg} is md2WithRsaEncryption. 

The file {\em cert} can be sent by any means to a user affiliated to this
CA, who can install it on his own PSE with the command instcert (see below). 
 
Before the prototype certificate is transformed into a valid certificate, the signature appended to the prototype certificate is verified with the public key held within the prototype certificate; in this way, it is 
checked whether the public key in {\em subjectPK} is part of an RSA key pair, and whether the corresponding
secret key is owned by the creator of the prototype certificate.

{\em notbefore} (option {\bf -f}) and {\em notafter} (option {\bf -l}) are dates of validity in the 
form 'YYMMDD'. If they are omitted, the first date on which the certificate is valid is set to the current time, 
and the last date on which the certificate is valid is set to one year hereafter.
 
The CA's PSE is identified by {\em capsename} (default: environment variable CAPSE or .capse), which resides in the CA directory {\em cadir}
(default: environment variable CADIR or .ca in the HOME directory).
 
Option {\bf -t} may be provided for testing purposes; it requests to control the malloc/free behaviour.

Option {\bf -v} renders the certify command verbose, and options {\bf -V} and {\bf -W} provide 
some further logging information.
\\ [1em]
{\bf revoke} [ {\bf -htvVWD} ] [ {\bf -c} {\em cadir} ] [ {\bf -p} {\em capsename} ] [ {\bf -a} {\em issueralg} ] \\
\hspace*{2cm} [ {\bf -u} {\em nextupdate} ] [ {\bf -d} {\em dsaname} ] [ {\bf -A} {\em authlevel} ]
\addtotoc{revoke} 
 
{\em revoke} revokes one or more certificates and enters the resulting revocation list into the 
Directory. \\
 
The certificates which are to be revoked are identified by their serial numbers which are to be
entered interactively (see also {\em caserialnumbers} and {\em cacertificate} commands, available
with psemaint). 
Each serial number is submitted to the same check as described for the command {\em revoke}
available with {\em psemaint}. \\
Only in case of at least one certificate having been revoked and added to the revocation list, the 
{\em lastUpdate} component of the revocation list is set to the current time, whereas the value 
of the {\em nextUpdate} component is individually specified by the revoking CA. 

The extended revocation list is written back to the CA's {\em pemcrlwithcerts} database and
added to the PSE object CrlSet in the CA's PSE.

The algorithm name associated with the signature of the revocation list 
(issuer algorithm) can be specified by {\em issueralg} 
(option {\bf -a}). {\em issueralg} must be a
signature algorithm (AlgType SIG, see INTRO(3) on available algorithms) which fits to the associated 
algorithm of the signature key (e.g., the algorithm md5WithRsa cannot be used with an ElGamal key).
The default for {\em issueralg} is md2WithRsaEncryption.

The {\em lastUpdate} component of the extended revocation list is set to the 
current time, whereas the value of the {\em nextUpdate} field may be specified by the {\em nextupdate} parameter (option {\bf -u}), or is else asked for interactively.
 
Option {\bf -D} causes the revocation list to be entered into the Directory.
The Directory may either be a X.500 directory or the local substitute provided by 
SecuDE ({\em .af-db}) (see also DirectoryType(5)).
If a X.500 directory is accessed, parameters {\em dsaname} (option {\bf -d}) and {\em authlevel} 
(option {\bf -A}) may be provided, with the same meaning as with {\em cacreate}.

Option {\bf -t} may be provided for testing purposes; it requests to control the malloc/free behaviour.

Option {\bf -v} renders the revoke command verbose, and options {\bf -V} and {\bf -W} provide 
some further logging information.
\\ [1em]
{\bf gen\_pse} [ {\bf -c} {\em cadir} ] [ {\bf -p} {\em capsename} ] [ {\bf -i} {\em scriptfile} ] [ {\bf -h} {\em 
home} ] [ {\bf -u} {\em unixname} ] \\ 
\hspace*{2cm} [ {\bf -a} {\em issueralg} ] [ {\bf -s} {\em signalg} ] [ {\bf -e} {\em encalg} ] [ {\bf -k} {\em 
keysize} ] \\ 
\hspace*{2cm} [ {\bf -f} {\em notbefore} ] [ {\bf -l} {\em notafter} ] [ {\bf -x} {\em nameprefix} ]  \\ 
\hspace*{2cm} [ {\bf -P} {\em subjectpse} ] [ {\bf -t} {\em subjectca} ] [ {\bf -g} {\em serialnumber} ] \\
\hspace*{2cm} [ {\bf -d} {\em dsaname} ] [ {\bf -vrDqmn} ] [ {\em namesuffix} ]
\addtotoc{gen\_pse}

{\em gen\_pse} can be used by a CA in order to generate complete PSEs for users or underlying CAs,
called subject in the following, at the CA site. {\em Gen\_pse} is able to work on a scriptfile
(parameter {\bf -i} {\em scriptfile}) where a list of subjects and additional necessary
parameters can be specified in order to generate the PSEs for these subjects through one
call of {\em gen\_pse}. All parameters listed after {\bf -i} {\em scriptfile}, and the
options {\bf -d} and {\bf -r} can be defined or redefined in {\em scriptfile} on a per subject
basis. Normal use of {\em gen\_pse} would require only parameter {\bf -i} {\em scriptfile}
and optionally {\bf -c} {\em cadir} and/or {\bf -p} {\em capsename}.

If {\bf -q} is not given, a PSE is restricted to carry one RSA key pair only (for both signature and encryption 
purposes)
and is marked accordingly. In that case, the generated PSE contains the PSE objects Name, SKnew, Cert, 
PKRoot, and FCPath
(the last one only if the issuing CA is not the root CA). This type of PSE is required within the PEM context, 
for instance.
Otherwise, if {\bf -q} is given, each generated PSE contains the PSE objects Name, SignSK, DecSKnew, 
SignCert,
EncCert, PKRoot and FCPath (the last one only if the issuing CA is not the root CA).

If {\bf -h} {\em dir} is not specified, the PSE is produced in the tar-format, compressed
using {\em compress(1)}, encoded to printable ASCII characters using {\em encode(1)}, and
stored in the subdirectory genpse of the CA directory. This file can be transported
to the subject site by any means, e.g. electronic mail, FTAM, ftp or cp, depending on
the local situation, and can be installed at the subject site with {\em inst\_pse}. 
{\em gen\_pse} creates the subdirectory genpse if it does not exist.

If {\bf -h} {\em dir} is specified, {\em dir} is the directory under which all user's
home directories reside (e.g. /home). In this case, the PSE is installed immediately
in the subject's home directory; it is not necessary to use {\em inst\_pse}.
The PSE name is constructed by concatenating {\em dir/unixname/subjectpse}. The
option {\bf -h} {\em dir} is intended to be used in configurations where the CA and
the subjects reside in the same system or local area network of systems with a common
file system (e.g. NFS), for instance if the CA is the system administrator of such
a configuration. Watch for cases where the home directory of a subject is not constructed
as {\em dir/unixname}.

{\em cadir} is the directory of the issuing CA (default: environment variable CADIR or .ca in the HOME
directory).
{\em gen\_pse} requests the CA PIN from /dev/tty.

{\em capsename} is the name of the CA's PSE under {\em cadir} (default: environment variable CAPSE or .capse).

The subject name associated to the new PSE is divided, for the purpose of {\em gen\_pse}, 
into two parts. A nameprefix (e.g. 'C=DE; O=GMD; OU=I2; CN=') is expected from
{\bf -x} {\em nameprefix} or from the scriptfile. A namesuffix (e.g. the common name
or surname, depending on how the nameprefix was chosen) is expected from parameter
{\em namesuffix} or from the scriptfile. Both are concatenated to form the distinguished
name of the subject. The concatenation of nameprefix and namesuffix must result in a name
of the form {\em Name}, i.e. a printable representation of a {\em DName}.

{\em unixname} is the Unix login name of the subject.

{\em subjectpse} is the name of the generated subject's PSE. default is .pse.

If {\em subjectca} is set a CA is generated instead of a PSE where {\em subjectca}
is the name of the generated subject's CA.
In this case a serialnumber can be set with {\bf -g}.

{\em issueralg} denotes the signature algorithm  which is used by the CA to generate
the certificates. If given this is used instead of the algorithm associated to
the CA's signature key. If the CA's signature key has the associated algorithm {\em rsa},
and {\em issueralg} is not given, {\em md2WithRsaEncryption} is used by default.

{\em signalg} and {\em encalg} denote the algorithms associated to the subject's newly
generated signature key pair and encryption key pair respectively. {\em rsa} is the
default in either case. A {\bf -k} {\em keysize} following {\em signalg} or {\em encalg}
denotes the respective keysize. 512 is the default.

{\em notbefore} and {\em notafter} denote the dates of validity of both the generated
signature certificate and encryption certificate. If they are omitted, {\em notbefore} is
set to the current date, and {\em notafter} is set to one year after {\em notbefore}.
{\em notbefore} and {\em notafter} must be given as UTCTime strings (YYMMDDhhmmssZ
or YYMMDDhhmmss+hhmm or YYMMDDhhmmss-hhmm) or like YY:[MM:[DD:[hh:[mm:[ss:]]]]]. 
Example: 921020163015Z is October 20, 1992,
16:30:15 h GMT. 921020173015+0100 denotes the same time as local time CET.

{\em gen\_pse} requests a transport PIN from either /dev/tty or the scriptfile on a 
per subject basis. The transport PIN is used for the generated subject's PSE. The transport
PIN can be changed to the final PIN when installing the generated PSE at the subject's
site with {\em inst\_pse}, or at any time using {\em psemaint}.

Option {\bf -r} replaces an existing PSE in either the subject's home directory (if {\bf -h}
{\em dir} is used) or in {\em cadir}/genpse  (if {\bf -h} {\em dir} is not used). Without
option {\bf -r} existing PSEs are not overwritten.

Option {\bf -D} causes the generated certificates to be stored in the Directory.
The Directory may either be a X.500 directory or the local substitute provided by 
SecuDE ({\em .af-db}) (see also DirectoryType(5)).

If a X.500 Directory is accessed, parameter {\em dsaname} (option {\bf -d}) 
indicates a non-default DSA name for this operation. 
A default DSA name should have been installed by the system administator.

Option {\bf -t} may be provided for testing purposes; it requests to control the malloc/free behaviour.

Option {\bf -v} renders {\em gen\_pse} verbose.
\\ [0.5cm]
{\large\bf Format of the Scriptfile}

The scriptfile consists of parameter lines and subject lines (one line per subject
for whom a PSE shall be generated).
Like in a shell script, the character '\#' can be used to indicate a comment until EOL.

{\bf Parameter Lines}

Parameter lines are indicated by a '\$' in column 1.
A parameter line has the format

\${\em parametername} [ = {\em first\_value} [ , {\em second\_value} ]].
A parameter defined in this way is valid for all following subjects until it is redefined.
\\ [1em]
{\bf The following parameters are possible:}
\\ [1em]
\begin{tabular}{|l|l|} 
\hline
{\bf \$onekeypair}                                      &  One key-pair or two different key-pairs \cr
{\bf \$twokeypairs}                                     &  for encryption and signature. \cr                          \hline
{\bf \$issuer\_alg} = {\em alg}                         &  Issuer's signature algorithm  (default: \cr
                                                        &  md2WithRsaEncryption or dsaWithSHA). \cr
{\bf \$subject\_encalg} = {\em alg} [, {\em keysize} ]  &  Subject's signature algorithm (default: rsa, 512). \cr
{\bf \$subject\_sigalg} = {\em alg} [, {\em keysize} ]  &  Subject's encryption algorithm (default: rsa, 512). \cr    \hline
{\bf \$notbefore} = {\em date}                          &  The date and valitity value \cr
{\bf \$notafter} = {\em date}                           &  can be given in format 920812080000+0000 \cr
{\bf \$validity} = {\em validity}                       &  or 92:08:12:08:00:00: like described before. \cr
                                                        &  Default validity is one year from now. \cr                 \hline
{\bf \$enter}                                           &  Enter the certificate into the Directory \cr
{\bf \$notenter}                                        &  Do not enter the certificate into the Directory. \cr
{\bf \$dsa} = {\em dsaname}                             &  Name of the dsa initially approached. \cr                  \hline
{\bf \$subject\_pse} = {\em psename}                    &  Name of the generated subject PSE. \cr
{\bf \$home} [ = {\em pathname} ]                       &  Install the generated PSE directly in the user's home \cr
                                                        &  directory {\em pathname}/{\em username}  \cr
                                                        &  (default pathname: /home). Otherwise write compressed \cr
                                                        &  and encoded tar-file to genpse/{\em username}. \cr
{\bf \$userhome} = {\em name}                           &  Name of the subject's home directory if different \cr
                                                        &  from {\em username}. \cr                                  \hline
{\bf \$user}                                            &  Generate of a user PSE. \cr
{\bf \$ca} [= {\em cadir} [, {\em serialnumber} ] ]     &  Generate a CA with the CA directory {\em cadir} \cr
                                                        &  and the initial serialnumber {\em serialnumber}. \cr      \hline
{\bf \$transportpin} = {\em pin}                        &  The PIN of the generated PSE. \cr                         \hline
{\bf \$notreplace}                                      &  Do not overwrite an existing PSE \cr
{\bf \$replace}                                         &  Overwrite an existing PSE. \cr                            \hline
{\bf \$sc\_pse}                                         &  Generate a smartcard-based PSE. \cr
{\bf \$sw\_pse}                                         &  Generate a SW-PSE. \cr                                    \hline
{\bf \$create}                                          &  Generate a new PSE. \cr
{\bf \$update} = {\em list\_of\_objects}                &  Update the given Objects in an existing PSE \cr           \hline
{\bf \$nameprefix} = {\em prefix}                       &  Prefix of subject's DName. \cr                            \hline
\end{tabular}
\\ [1em]
{\bf Subject Lines}

Subject lines do not begin with a '\$' and consist of three words plus optional
parameter definitions in the \${\em parametername} form.

The first word is the unixname of the subject.
This is added to the list of aliases as alias name of the subject's DN.
The second word is a second alias name which can be used to introduce the subject's
mail-address as alias.
The third word is the namesuffix.
A word which contains spaces or commas must be included in " ".

After the namesuffix additional parameter definitions can be given. They are only
valid for this subject.

The subject line ends with the following EOL.
An EOL included in " " is ignored.
\\ [1em]

An {\bf example} of the scriptfile is given in the following template:
{\small
\begin{verbatim}

# Template of script-file for gen_pse

# Global Parameter Definitions:
# -----------------------------

$onekeypair                          # one key pair is used for encryption and signature
#$twokeypairs                        # two key pairs for encryption and signature

$issuer_alg = md5WithRsaEncryption   # signature algorithm of CA
#$subject_encalg = RSA, 520          # algorithm of subject's encryption algorithm
$subject_sigalg = RSA, 520           # algorithm of subject's signature algorithm

$notbefore = 920812080000+0000       # validity not before of generated certificate
$validity = 02:00:00:                # length of validity period from notbefore

$notenter                            # do not enter generated certificate into directory

$subject_pse = .pse                  # subject's PSE name
$home = /home                        # directory containing all home directories

$user                                # user PSE

$transportpin = uakrus               # PIN of PSE

$replace                             # replace an existing PSE ( creation )

$sw_pse                              # only Software PSE

$update = "pkroot oldpkroot newpkroot fcpath signcert newkey encrcert newkey"
                                     # update some objects on an existing PSE

$nameprefix = "C=DE; O=GMD; CN="     # subject's name prefix

# Subject Lines:
# --------------

surkau  Thomas.Surkau@gmd.de      "Thoma Surkau"       $notreplace $create $home $userhome
schneiw Wolfgang.Schneider@gmd.de "Wolfgang Schneider" $notreplace
\end{verbatim}
}
\vspace{1em}
{\bf create\_TestTree} [ {\bf -vPqt} ] 
\addtotoc{create\_TestTree}

This is a test command for a system administrator who installs SecuDE. {\em create\_TestTree}
creates a tree of one root CA (CA-directory {\em Root-CA}), two subordinate CAs (CA-directories
ORG-1-CA and ORG-2-CA), two users of ORG-1-CA (PSE names ORG-1-User-1 and ORG-2-User-2),
and two users of ORG-2-CA (PSE names ORG-2-User-1 and ORG-2-User-2), including all key generation
and certificates. The CA-directories and PSEs are created in the subdirectory TestTree of the 
home directory. 
These PSEs can be used to test the installation. TestTree must not exist when
create\_TestTree is called.

Option {\bf -P} requests that RFC 1424 defined certification procedures are applied
by using pem(1). Otherwise KM(1) utilities are used for certification.

Option {\bf -q} causes the creation of PSEs with two RSA keypairs.

Option {\bf -t} may be provided for testing purposes; it requests to control the malloc/free behaviour.

Option {\bf -v} renders it verbose. \\ [1em]
{\bf delete\_TestTree}
\addtotoc{delete\_TestTree}

{\em delete\_TestTree} deletes the previously created test tree of CAs and users. It removes
the directory TestTree in the user's home directory.
\\ [1em] 
{\bf Commands for the user role:} 
\\ [1em]
{\bf psecreate} [ {\bf -hqtvVW} ] [ {\bf -p} {\em psename} ]
[ {\bf -s} {\em signalg} ] [ {\bf -k} {\em keysize} ] \\ 
\hspace*{2cm} [ {\bf -e} {\em encalg} ] [ {\bf -k} {\em keysize} ] [ '{\em Name}' ]
\addtotoc{psecreate}

{\em psecreate} creates a prototype PSE named {\em psename}. The default for {\em psename} is either
provided by the environment variable PSE, or is .pse under the HOME directory of the user, if there
is no such variable. The PSE directory must not exist.

If option {\bf -q} is not given, the prototype PSE comprises the PSE objects 
\bi
\m Name, containing the distinguished name of the owner;
\m SKnew, containing a newly generated secret asymmetric signature and decryption key;
\m Cert, containing the corresponding public key as self-signed prototype certificate;
\m PKRoot, containing the public key from Cert as root key.
\ei
This is a one keypair PSE.
 
If option {\bf -q} is provided, the prototype PSE comprises the PSE objects 
\bi
\m Name, containing the distinguished name of the owner,
\m SignSK, containing a newly generated secret asymmetric signature key,
\m SignCert, containing the corresponding public verification key as self-signed prototype certificate,
\m DecSKnew, containing a newly generated secret asymmetric decryption key,
\m EncCert, containing the corresponding public encryption key as self-signed prototype certificate,
\m PKRoot, containing the public key from SignCert as root key.
\ei
This is a two keypair PSE.

The distinguished name of the owner of the PSE is {\em Name}. 
If {\em Name} is omitted, its value is taken from the environment variable MYDNAME. If there is no
such variable, the distinguished name is requested from 
stdin. {\em Name} is stored as AF PSE object Name. 
It must be quoted when containing blanks and shell metacharacters (which is normally the case).
It is recommended to use different Name schemes for users and CAs, in order to be 
able to distinguish from the syntax of the Name whether a CA or an end user is denoted.
One solution would be to require at least one common name component
for an end user, while a CA is required not to have such a component. 
 
The subject public key algorithm name (see intro(3X) about available 
algorithm names and their types) associated with {\bf Cert} or {\bf SignCert} is {\em signalg} 
(option {\bf -s}) or {\em rsa} by default, if omitted. Only algorithms of type {\em SIG} or {\em ASYM\_ENC} are valid. 
The optional parameter {\em keysize} immediately following the {\bf -s} option is used to control
the keysize of the RSA signature key.

The subject public key algorithm name associated with {\bf EncCert} (if requested by option {\bf -q})
is {\em encalg} (option {\bf -e}) or {\em rsa} by default, 
if omitted. Only algorithms of type {\em ASYM\_ENC} are valid. The optional
parameter {\em keysize} immediately following the {\bf -e} option is used to control
the keysize of the RSA encryption key.

The algorithm name associated with the signature of the prototype certificates 
(issuer algorithm) is {\em md2WithRsaEncryption}, if the corresponding key is an RSA key,
or {\em dsaWithSHA}, if the corresponding key is a DSA key. 

Option {\bf -t} may be provided for testing purposes; it requests to control the malloc/free behaviour.

Option {\bf -v} renders the psecreate command verbose, and options {\bf -V} and {\bf -W} 
provide some further logging
information.
\\ [1em]
{\bf instpkroot} [ {\bf -htvVW} ] [ {\bf -c} {\em cadir} ] [ {\bf -p} {\em psename} ] [ {\em pkroot} ]
\addtotoc{instpkroot}

{\em instpkroot} reads file {\em pkroot} or stdin, if {\em pkroot} is omitted, and installs it as
PSE object PKRoot on the PSE. A PKRoot information that already exists on the target PSE will
be overwritten.
 
The location of the target PSE is determined by {\em cadir} and {\em psename}. The default for {\em 
psename} is either provided by the environment variable PSE, or is .pse under the HOME directory, 
if no such variable exists.
 
The default for {\em cadir} is NULL. 

If {\em cadir} is specified,
however, the PSE identified by {\em psename} resides under {\em cadir}; in this case, the default
for {\em psename} is either provided by the environment variable CAPSE, or is .capse, if no such variable
exists.
 
Option {\bf -t} may be provided for testing purposes; it requests to control the malloc/free behaviour.

Option {\bf -v} renders the instpkroot command verbose, and options {\bf -V} and {\bf -W} 
provide some further logging
information.
\\ [1em] 
{\bf instfcpath} [ {\bf -htvVW} ] [ {\bf -c} {\em cadir} ] [ {\bf -p} {\em psename} ] [ {\em fcpath} ]
\addtotoc{instfcpath}

{\em instfcpath} reads file {\em fcpath} or stdin, if {\em fcpath} is omitted, and installs it as
PSE object FCPath in the PSE. A FCPath information that already exists on the target PSE will
be overwritten.
 
The location of the target PSE is determined by {\em cadir} and {\em psename}. The default for {\em 
psename} is either provided by the environment variable PSE, or is .pse under the HOME directory, if no such
variable exists. 

The default for {\em cadir} is NULL. 

If {\em cadir} is specified,
however, the PSE identified by {\em psename} resides under {\em cadir}; in this case, the default
for {\em psename} is either provided by the environment variable CAPSE, or is .capse, if no such variable
exists.

Before the forward certification path provided is installed on the target PSE, it is checked
whether it comprises a chain of hierarchy certificates that could be verified up the PKRoot 
information already stored on the PSE.
 
Option {\bf -t} may be provided for testing purposes; it requests to control the malloc/free behaviour.

Option {\bf -v} renders the instfcpath command verbose, and options {\bf -V} and {\bf -W} 
provide some further logging information.
\\ [1em]
{\bf genkey} [{\bf -hrtvVW}] [ {\bf -c} {\em cadir} ] [ {\bf -p} {\em psename} ] [ {\bf -a} {\em issueralg} ]
[ {\bf -s} {\em signalg} ] [ {\bf -k} {\em keysize} ] \\
\hspace*{2cm} [ {\bf -e} {\em encalg} ] [ {\bf -k} {\em keysize} ] [ {\em proto} ]
\addtotoc{genkey}

{\em genkey} generates an asymmetric key pair and installs the secret key as PSE object
SignSK (default or option {\bf -s}) or DecSKnew (option {\bf -e}). The public key is written to file
{\em proto} or stdout, if {\em proto} is omitted, in form of a self-signed prototype certificate 
(i.e., the prototype certificate is signed with the corresponding secret key). 
The self-signed prototype certificate is stored as PSE object
SignCert (default or option {\bf -s}) or EncCert (option {\bf -e}).

The location of the PSE where secret key and prototype certificate are stored, is determined by 
{\em cadir} and {\em psename}. The default for {\em 
psename} is either provided by the environment variable PSE, or is .pse under the HOME directory, if no such
variable exists.
 
The default for {\em cadir} is NULL. 

If {\em cadir} is specified,
however, the PSE identified by {\em psename} resides under {\em cadir}; in this case, the default
for {\em psename} is either provided by the environment variable CAPSE, or is .capse, if no such variable
exists.

If the PSE identified by {\em cadir} and/or {\em psename} is restricted to carry one RSA key pair 
only, the secret
key is installed as PSE object SKnew, while the self-signed prototype certificate is stored as PSE object Cert.

In case of a signature key pair being generated, {\bf -s} {\em signalg}
denotes the algorithm associated with the public key information held within the prototype certificate.
In case of an encryption key pair being generated, {\bf -e} {\em encalg}
denotes the algorithm associated with the public key information held within the prototype certificate
(see intro(3X) about available algorithm names and their types).
Only algorithms of type {\em SIG} or {\em ASYM\_ENC} are valid in case of a signature key pair 
being generated, while the algorithms which may be associated with the encryption key pair 
are restricted to those of type {\em ASYM\_ENC}. 
However, if the key pair being generated is used for both signature and encryption purposes
(i.e., the specified PSE is a one keypair PSE), the algorithms associated with
it are restricted to those of type {\em ASYM\_ENC}.
If both option {\bf -s} and option {\bf -e} are omitted, a signature key pair whose
associated algorithm name is rsa will be generated. 

If the generated key pair is of type {\em ASYM\_ENC}, the algorithm name 
associated with the signature of the prototype certificate can be specified by {\em issueralg} 
(option {\bf -a}), or is md2WithRsaEncryption by default. 

The specification of an algorithm via {\bf -s}, {\bf -e} or {\em -a} may optionally
be followed by a {\em keysize} (option {\bf -k}), which controls the keysize of the RSA keys.

{\em genkey} takes all data required for the prototype certificate from the PSE.
 
Option {\bf -r} replaces a previously generated secret key, which has already been installed in 
the PSE, by the newly generated one.

Option {\bf -t} may be provided for testing purposes; it requests to control the malloc/free behaviour.

Option {\bf -v} renders the genkey command verbose, and options {\bf -V} and {\bf -W} 
provide some further logging
information.
\\ [1em]
{\bf getkey} [ {\bf -ehstvVW} ] [ {\bf -c} {\em cadir} ] [ {\bf -p} {\em psename} ] [ {\em proto} ]
\addtotoc{getkey}

Such as {\em genkey}, {\em getkey} creates a prototype certificate and writes its content to file
{\em proto} or stdout, if {\em proto} is omitted. The prototype certificate may then be
signed by a CA (e.g., by using {\em certify}). 

In contrast to {\em genkey}, {\em getkey} does not
generate keys, it just builds a prototype certificate from the public key stored in SignCert
(option {bf -s}) or EncCert (option {\bf -e}). 

The location of the PSE from which the public key information is extracted, is determined by 
{\em cadir} and {\em psename}. The default for {\em 
psename} is either provided by the environment variable PSE, or is .pse under the HOME directory, if no such
variable exists.
 
The default for {\em cadir} is NULL. 

If {\em cadir} is specified,
however, the PSE identified by {\em psename} resides under {\em cadir}; in this case, the default
for {\em psename} is either provided by the environment variable CAPSE, or is .capse, if no such variable
exists.

If the PSE identified by {\em cadir} and/or {\em psename} is restricted to carry 
one RSA key pair only, however, the prototype certificate is built upon the public key contained 
in PSE object Cert.

{\em getkey} is intended to support the cross certification
of an existing key. It can also be used when superordinating a new top-level CA over
an existing Root-CA. In this case, the existing public keys of the previous
Root-CA can be transformed into prototype certificates, in order to be certified by the
new top-level CA.
 
Option {\bf -t} may be provided for testing purposes; it requests to control the malloc/free behaviour.

Option {\bf -v} renders the getkey command verbose, and options {\bf -V} and {\bf -W} provide 
some further logging
information.
\\ [1em] 
{\bf instcert} [ {\bf -aehrtvVWHD} ] [ {\bf -c} {\em cadir} ] [ {\bf -p} {\em psename} ] [ {\bf -d} {\em dsaname} ] [ {\bf -A} {\em authlevel} ] \\
\hspace*{2cm} [ {\em cert} ]
\addtotoc{instcert}

{\em instcert} reads file {\em cert} or stdin, if {\em cert} is omitted, 
and installs its content in one of the PSE objects SignCert, EncCert, SignCSet, or EncCSet, depending on
the algorithm identifier of the subject key and option {\bf -H}. If {\bf -H} is given, the
certificate is considered a hierarchy certificate and is installed as PSE object SignCert or
EncCert. Otherwise, it is considered a cross certificate and is installed as (or added to) PSE object SignCSet or EncCSet.

If the algorithm identifier of the subject key indicates a signature algorithm (type {\em SIG}).
the certificate is installed in SignCert or SignCSet.
If the algorithm identifier of the subject key is of type {\em ASYM\_ENC}, the certificate
is installed in SignCert or SignCSet by default; if option {\bf -e} is given, however, it is
installed as EncCert or EncCSet.

The location of the target PSE is determined by {\em cadir} and {\em psename}. The default for {\em 
psename} is either provided by the environment variable PSE, or is .pse under the HOME directory, if no such
variable exists.
 
The default for {\em cadir} is NULL. 

If {\em cadir} is specified,
however, the PSE identified by {\em psename} resides under {\em cadir}; in this case, the default
for {\em psename} is either provided by the environment variable CAPSE, or is .capse, if no such variable
exists.

If the PSE identified by {\em cadir} and {\em psename} is restricted to carry one RSA key pair only, 
however, the certificate is installed as PSE object Cert or CSet, depending on whether or not it is considered a hierarchy certificate (option {\bf -H}).

Before a hierarchy certificate (SignCert or EncCert) is installed, an additional check is 
performed:
A random data block is encrypted - using the certified public key of the hierarchy certificate - and then 
decrypted
- using the secret key of the same keytype (signature or encryption), which has already been stored on the 
PSE 
as object SignSK or DecSKnew, respectively. The hierarchy certificate will
be installed only if the decrypted and the original data are identical, i.e., public and private key fit
together.
If a self-signed prototype certificate has already been installed as object SignCert or EncCert
on the PSE (see {\em genkey}), the following check will be performed before installing the hierarchy 
certificate: 
The certified public key of the hierarchy certificate will be compared with the one contained in the prototype 
certificate. If both public keys are identical, the certified public key of the hierarchy certificate is proved to
fit to the secret key already stored on the PSE, and the hierarchy certificate will replace the self-signed
prototype certificate on the PSE.
If the PSE is restricted to carry one RSA key pair only, however, the PSE objects Cert and SKnew are 
considered for the above consistency checks.
 
If option {\bf -D} was provided, {\em instcert} additionally enters the certificate into the Directory. 
The Directory may either be a X.500 directory or the local substitute provided by 
SecuDE ({\em .af-db}) (see also DirectoryType(5)).

If a X.500 directory is accessed, options {\bf -a}, {\bf -A}, and {\bf -d} may be used:
If option {\bf -a} is provided, the certificate is added to the {\em cACertificate} attribute in
the caller's X.500 directory entry; otherwise, it is added to the {\em userCertificate}
attribute.
Parameters {\em dsaname} (option {\bf -d}) and {\em authlevel} (option {\bf -A}) have the same meaning as with {\em cacreate}.
 
If the {\em .af-db} directory is accessed, the certificate is stored as file {\em SignCert}
or {\em EncCert} in the {\em .af-db} subdirectory identified by the caller's distinguished name,
depending on whether or not option {\bf -e} was provided; if the PSE identified by 
{\em cadir} and {\em psename} is restricted to carry one RSA key pair only, 
however, the certificate is stored as file {\em Cert} in the same subdirectory.
Option {\bf -r} can be used to replace an existing 
signature or encryption certificate stored as file {\em SignCert}, {\em EncCert}, or {\em Cert},
in the caller's .af-db subdirectory.

Option {\bf -t} may be provided for testing purposes; it requests to control the malloc/free behaviour.

Option {\bf -v} renders the instcert command verbose, and options {\bf -V} and {\bf -W} 
provide some further logging
information.
\\ [1em] 
{\bf pkadd} [ {\bf -aehitvVW} ] [ {\bf -c} {\em cadir} ] [ {\bf -p} {\em psename} ] [ {\bf -d} {\em dsaname} ] [ {\bf -A} {\em authlevel} ] {\em Name}
\addtotoc{pkadd}

{\em pkadd} retrieves the signature (by default) or encryption (option {\bf -e}) certificate 
of {\em Name} from the Directory
and adds its ToBeSigned part to the PSE object PKList (by default) or EKList 
(option {\bf -e}).
{\em Name} is a distinguished name in printable form or an alias name.
By default, only those certificates are selected from the returned set whose subject PK algorithm 
is of type {\em SIG} or {\em ASYM\_ENC} (SIGNATURE certificates).
With option {\bf -e}, only those certificates are selected from the returned set whose
subject PK algorithm identifier is of type {\em ASYM\_ENC} (ENCRYPTION certificates).

The location of the target PSE is determined by {\em cadir} and {\em psename}. The default for {\em 
psename} is either provided by the environment variable PSE, or is .pse under the HOME directory, if no such
variable exists.
 
The default for {\em cadir} is NULL. 

If {\em cadir} is specified,
however, the PSE identified by {\em psename} resides under {\em cadir}; in this case, the default
for {\em psename} is either provided by the environment variable CAPSE, or is .capse, if no such variable
exists.

If the PSE identified by {\em cadir} and {\em psename} is restricted to carry 
one RSA key pair only, just those certificates are selected from the returned set whose
subject PK algorithm identifier is of type {\em ASYM\_ENC}; in this case, the
ToBeSigned parts of the selected
certificates are added to the PSE object PKList in any case, even if option {\bf -e} was given. 
 
If a X.500 Directory is accessed, options {\bf -i}, {\bf -a}, {\bf -d}, and {\bf -A} may
be provided:
If {\bf -i} is given and more than one certificate is found for {\em Name}, the user is asked
interactively to specify the certificate whose ToBeSigned part shall be added to his
PKList or EKList, respectively; if option {\bf -i} is omitted, however, the ToBeSigned part
of the first certificate among the returned set of certificates is selected by default.
If option {\bf -a} is provided, the certificates are read from the {\em cACertificate} attribute in
the X.500 directory entry of {\em Name}; otherwise, they are retrieved from the {\em userCertificate} attribute. (If the X.500 directory entry of {\em Name} does not contain the requested attribute,
an appropriate error message is reported to the caller.)
Parameters {\em dsaname} (option {\bf -d}) and {\em authlevel} (option {\bf -A}) have the same meaning as with {\em cacreate}.
 
Option {\bf -t} may be provided for testing purposes; it requests to control the malloc/free behaviour.

Option {\bf -v} renders the pkadd command verbose, and options {\bf -V} and {\bf -W} 
provide some further logging
information.
\\ [1em] 
{\bf pkdel} [ {\bf -ehtvVW} ] [ {\bf -c} {\em cadir} ] [ {\bf -p} {\em psename} ] [ {\bf -o} {\em owner} ] [ {\bf -i} {\em issuer} ] [ 
{\bf -n} {\em serial} ] 
\addtotoc{pkdel}

{\em pkdel} deletes entries from PSE object PKList (by default) or EKList (option {\bf -e}). It
either deletes all entries of the given {\em owner}, or the one entry uniquely identified
by its {\em issuer} and {\em serial} combination. {\em owner} and {\em issuer} are distinguished
names in printable form or alias names.
 
The location of the PSE is determined by {\em cadir} and {\em psename}. The default for {\em 
psename} is either provided by the environment variable PSE, or is .pse under the HOME directory, if no such
variable exists.
 
The default for {\em cadir} is NULL. 

If {\em cadir} is specified,
however, the PSE identified by {\em psename} resides under {\em cadir}; in this case, the default
for {\em psename} is either provided by the environment variable CAPSE, or is .capse, if no such variable
exists.
 
Option {\bf -t} may be provided for testing purposes; it requests to control the malloc/free behaviour.

Option {\bf -v} renders the pkdel command verbose, and options {\bf -V} and {\bf -W} 
provide some further logging
information.
\\ [1em] 
{\bf pklist} [ {\bf -ehtvVW} ] [ {\bf -c} {\em cadir} ] [ {\bf -p} {\em psename} ]
\addtotoc{pklist}

{\em pklist} prints to stdout all entries of the PSE object PKList (by default)
or EKList (option {\bf -e}).
 
The location of the PSE is determined by {\em cadir} and {\em psename}. The default for {\em 
psename} is either provided by the environment variable PSE, or is .pse under the HOME directory, if no such
variable exists.
 
The default for {\em cadir} is NULL. 

If {\em cadir} is specified,
however, the PSE identified by {\em psename} resides under {\em cadir}; in this case, the default
for {\em psename} is either provided by the environment variable CAPSE, or is .capse, if no such variable
exists.
 
Option {\bf -t} may be provided for testing purposes; it requests to control the malloc/free behaviour.

Option {\bf -v} renders the pklist command verbose, and options {\bf -V} and {\bf -W} 
provide some further logging information.
\\ [1em]
{\bf showdir} [ {\bf -aehtvVW} ] [ {\bf -c} {\em cadir} ] [ {\bf -p} {\em psename} ] [ {\bf -o} {\em attributeType} ] [ {\bf -d} {\em dsaname} ] \\
\hspace*{2cm} [ {\bf -A} {\em authlevel} ] {\em Name}
\addtotoc{showdir}

{\em showdir} reads the attribute of type {\em attributeType} (option {\bf -o}) from the directory entry
identified by {\em Name} and prints its contents to stdout in a suitable form.
{\em attributeType} is {\em cert} by default; further possible values for {\em attributeType} are
{\em cross} (for Cross Certificate Pairs) and {\em rev} (for PEM revocation lists).
{\em Name} may be a distinguished name in printable form or an alias name.
The directory may either be a X.500 directory or the local substitute provided by 
SecuDE ({\em .af-db}). (see also DirectoryType(5)).
 
If a X.500 directory is accessed and {\em attributeType} is {\em cert},
the set of certificates stored in the {\em userCertificate} (by default) or 
{\em cACertificate} (option {\bf -a}) attribute within {\em Name}'s X.500 directory entry
is returned, from which the signature (by default) or encryption (option {\bf -e}) certificate(s) 
are selected.
If the local substitute {\em .af-db} is used, however, the signature (by default) or encryption 
(option {\bf -e}) certificate (stored in the file SignCert or EncCert, respectively) in the 
.af-db-subdirectory identified by {\em Name} is printed to stdout. \\
If a X.500 directory is used and {\em attributeType} is {\em cross}, the set of cross certificate 
pairs stored in {\em Name}'s directory entry is printed to stdout; the set of 
cross certificate pairs comprises the value(s) of the {\em crossCertificatePair} attribute. 
If the local substitute is used, however, the set of cross certificate pairs is retrieved from the file CrossCSet in the .af-db-subdirectory identified by {\em Name}. \\
If a X.500 directory is used and {\em attributeType} is {\em rev}, the revocation list stored 
in {\em Name}'s directory entry is printed to stdout. 
If the local substitute is used, however, the revocation list is 
retrieved from the file PemCrl in the .af-db-subdirectory identified by {\em Name}.
The format of the revocation list is that defined by PEM (see RFC 1422, Appendix A).
 
If a X.500 directory is accessed, options {\bf -d} and {\bf -A} may additionally be
provided, with the same meaning as with {\em cacreate}.

The transformation of {\em Name} into a DName structure requires that you indicate a PSE
to {\em showdir}, in order to be able to verify your own and/or the system alias databases,
which are both signed. Furthermore, your PSE may be required for authenticating you
to the X.500 Directory during the binding.

The location of your PSE is determined by {\em cadir} and {\em psename}. The default for {\em 
psename} is either provided by the environment variable PSE, or is .pse under the HOME directory, if no such
variable exists.
 
The default for {\em cadir} is NULL. 

If {\em cadir} is specified,
however, the PSE identified by {\em psename} resides under {\em cadir}; in this case, the default
for {\em psename} is either provided by the environment variable CAPSE, or is .capse, if no such variable
exists.

Option {\bf -t} may be provided for testing purposes; it requests to control the malloc/free behaviour.

Option {\bf -v} renders the showdir command verbose, and options {\bf -V} and {\bf -W} 
provide some further logging
information.
\\ [1em]
{\bf inst\_pse} {\em file}
\addtotoc{inst\_pse}

{\em inst\_pse} can be used to install a complete subject's PSE which has been previously
generated by a CA using {\em gen\_pse}. {\em inst\_pse} reads the encoded and compressed 
tar-file which comprises the PSE to be installed from {\em file}.
\\ [1em]
{\bf inst\_ca} {\em file}
\addtotoc{inst\_ca}

{\em inst\_ca} can be used to install a complete CA directory which has been previously
generated by a higher CA using {\em gen\_ca}. {\em inst\_ca} reads the encoded and compressed 
tar-file which comprises the CA directory to be installed from {\em file}.
\newpage
\hl{Examples of Different Methods of Key Distribution}

{\bf 1. Generation of the Subject's RSA Keys at the Subject Sites}
\\ [1em]
{\small
Explanation: If the different roles (root CA, ca1, ca2, user) are established under different 
User-IDs or on different systems, one has to separate the following commands at the 
intermediate pipes and to move the corresponding files from one site (or
HOME directory) to the other, for instance by means of file transfer or e-mail (the
latter requires an addional ASCII-encoding of the transmitted files).
To illustrate this, commands which have to
be done by the CA role are in {\bf bold}, and commands which have to be done
by the user role are in {\em italic}.
}
\\ [1em]
To install a two-level CA hierarchy consisting of a root CA on the top level and ca1, ca2
on the second level on the same system and under the same User-ID, one can say
\bvtab
\1 {\bf cacreate} -c .root-ca 'C=DE; O=organization \\
\1 {\bf cacreate} -c .ca1 'C=DE; O=organization; OU=ou1' \\
\1 {\bf cacreate} -c .ca2 'C=DE; O=organization; OU=ou2'
\evtab
to create the CAs with their CA directories .root-ca, .ca1, and .ca2 under the HOME directory
of that user. The PSEs of the CAs are located in the CA directories respectively.
All CA PSEs are prototype PSEs at this moment, i.e. each of them contains an RSA key pair 
(the public key as self-signed prototype certificate) and a PKRoot which consists
of the own public key and issuer name set to the own subject name. 

Now the PSE object PKRoot has to be taken from the root CA and installed in ca1 and ca2 by saying
\bvtab
\1 {\bf getpkroot} -c .root-ca $|$ {\em instpkroot} -c .ca1 \\
\1 {\bf getpkroot} -c .root-ca $|$ {\em instpkroot} -c .ca2
\evtab
An FCPath does not exist on the first two levels of CAs (the users of ca1 and ca2, however,
have FCPaths which have to be installed in the user PSEs; recall Vol. 1 chapter 2 for this).
 
The next step is to obtain the
respective certificates for the public keys from the root CA, and to install those 
certificates in the ca1 and ca2 PSEs.
\bvtab
\1 {\em getkey} -c .ca1 $|$ {\bf certify} -c .root-ca -q $|$ {\em instcert} -c .ca1 -h \\
\1 {\em getkey} -c .ca2 $|$ {\bf certify} -c .root-ca -q $|$ {\em instcert} -c .ca2 -h \\
\evtab

Now the creation of the CA directories .root-ca, .ca1 and .ca2 is complete.
 
To create a PSE of a user of ca1, one says for instance
\bvtab
\1 {\em psecreate} 'C=DE; O=organization; OU=ou1; CN=username' \\
\1 {\bf getpkroot} -c .ca1 $|$ {\em instpkroot} \\
\1 {\bf getfcpath} -c .ca1 $|$ {\em instfcpath} \\
\1 {\em getkey} $|$ {\bf certify} -c .ca1 -q $|$ {\em instcert} -h \\
\evtab
which generates the user PSE .pse under the HOME directory of the user.
\\ [1em]
{\bf 2. Generation of the Subject's RSA Keys at the CA Sites}
\\ [1em]
Utility {\em gen\_pse (1)} can be used to generate entire user PSEs at the CA
site. This is a reasonable alternative, for instance, in the case that smartcards
are generated and distributed through the CA. Say
\bvtab
\1 {\bf gen\_pse} -c .ca1 -i gen\_script  \\
\evtab
to generate user PSEs at CA ca1. gen\_script is the script-file which contains
the necessary information about the users of ca1 and how their PSEs shall be generated.
All SW-PSEs which are generated this way are stored as encoded and compressed tar-files
in the directory .ca1/genpse. They are protected through the transport PIN which can
be specified in the script-file. These tar-files can be transmitted to the users
who may install them in their environment using inst\_pse(1).
\bvtab
\1 {\bf gen\_pse} -c .ca1 -i gen\_script -h /home \\
\evtab
does the same except that SP-PSEs are written directly into /home/{\em username}
where {\em username} is the Unix name of the user as specified in the scriptfile.
This option may be useful if the CA and the users of the CA share the same
file-system (e.g. in a local area network with NFS). Note that gen\_pse
must have the necessary permissions to do so.
\\ [1em]
{\bf 3. Key Distribution using PEM}
\\ [1em]
See {\em pem (1)}.
\nm{1}{pem}{Privacy Enhanced Mail (PEM) according to RFC 1421 - 1424}
\label{pem}
\hl{Synopsis}
{\bf pem} [ {\bf scan $|$ mic-clear $|$ mic-only $|$ encrypted $|$ crl $|$ crl-rr $|$ certify } ]
\\ \hspace*{0.95cm} 
[ {\bf -i} {\em inputfile} ] [ {\bf -o} {\em outputfile} ] [ {\bf -p} {\em psename} ] [ {\bf -c} {\em cadir} ] [ {\bf 
-m/M}  {\em depth} ] 
\\ \hspace*{0.95cm}
[ {\bf -u} {\em update} ] [ {\bf -r} {\em name1} {\em name2} ... ] [ {\bf -y} {\em name1} {\em name2} ... ] [ {\bf 
-DFRCnhvVNO} ]
\\ \hspace*{0.95cm}
[ {\bf -H} {\em md-alg} ] [ {\bf -S} {\em micenc-alg} ] [ {\bf -E} {\em msgenc-alg} ] [ 
{\bf -K} {\em dekenc-alg} ] [ {\bf -d} {\em dsaname} ]
\\ \hspace*{0.95cm} [ {\bf -A} {\em authlevel} ]

\hl{Description}
This PEM filter transforms any input text file into a PEM formatted output file 
and vice versa. It can be used both by ordinary users or by certification
authorities. It realizes all formats 
and procedures defined in the Internet Specifications RFC 1421-1424 
except that it only supports asymmetric key management. It is
possible to securely cache other's certificates and CRLs as this 
is part of the general SecuDE functionality. In particuar, it is possible
with {\em pem} to
\bi
   \m enhance messages, i.e. create MIC-CLEAR, MIC-ONLY and
      ENCRYPTED message formats,
   \m de-enhance messages, i.e. scan MIC-CLEAR, MIC-ONLY and
      ENCRYPTED message formats, and perform the necessary
      validation steps (including CRL checks),
   \m create Certification Request, Certification Reply, CRL Storage
      Request and CRL Storage Reply message formats,
   \m scan Certification Request, Certification Reply, CRL Storage
      Request and CRL Storage Reply message formats, and perform
      appropriate actions, for instance updating the PSE or
      the CA-database,
   \m support a CRL storage service.
\ei

Pem requires to use a PSE which holds one keypair for signature and encryption purposes since
MIC encryption and DEK encryption is to be performed with the same keypair. 

For the purpose of
MIC encryption, the own secret key contained in PSE-object SKnew is used. If a scanned
privacy enhancement contains an Originator-Certificate header field, MIC decryption
is done with the public key contained there. If a scanned privacy enhancement contains an 
Originator-ID-Asymmetric header field, the given issuer/serialnumber must be found in
the PSE-object PKList which is the list of the user's trusted keys. MIC decryption
is then done with the public key found in the corresponding entry of PKList.

The per-recipient DEK encryption is done with the public key of the recipient which is retrieved
from the PSE-object PKList. If it is not found there, the local afdb Directory is consulted.
If it is not found there either, and if the option -D is given, it is retrieved from
the X.500 Directory. DEK decryption is done with the own secret key contained in PSE-object
SKnew. 

A keyword which must be the first parameter of {\em pem} controls the PEM transformation mode.
Only the {\bf scan} mode transforms from the PEM format to a cleartext format. All other
modes create PEM formats.  

{\large\bf Scan}

Scan is the default mode. The keyword scan can be omitted. In this mode the textfile {\em inputfile}
(or stdin if {\em inputfile} is omitted) is scanned for privacy enhancements. The term input is
subsequently used to denote the data coming either from {\em inputfile} or from stdin. The input
may contain a single privacy enhancement, enclosed in PEM boundary lines, or nested privacy
enhancements, the latter, however, only with Proc-Types MIC-CLEAR, MIC-ONLY or ENCRYPTED.
Multiple consecutive privacy enhancements are not possible. Depending on the type of the scanned
privacy enhancements and the given {\bf -u} {\em update} parameter, {\em pem scan} does one or
more of the following actions:

\bi
\m write a notification about the MIC verification and other status information to stderr,
\m write the PEM transformation result to {\em outputfile} or stdout, if {\em outputfile} is omitted,
   The term output is subsequently used to denote the data which are written either to
   {\em outputfile} or to stdout.
\m update the user's PSE,
\m update the CA-database.
\ei

A notification about the {\bf MIC verification} is given in any case. The MIC validation will be done
according to the procedure described in af\_verify(3). 

If option {\bf -D} is given, missing certificates will automatically be retrieved from the Directory.
The Directory may either be a X.500 directory or the local substitute provided by 
SecuDE ({\em .af-db}) (see also DirectoryType(5)).

If the X.500 Directory is accessed, parameter {\bf -d} {\em dsaname} allows to specify the 
name of the DSA (Directory System Agent) to be contacted for this purpose. 
{\em dsaname} is a name which must be contained in the 
{\em dsaptailor} file of the system as {\em dsa\_address} parameter. If {\bf -d} {\em dsaname} is
not given, the default DSA, which is the first {\em dsa\_address} parameter in the {\em dsaptailor} 
file, is accessed.
Parameter {\em authlevel} (option {\bf -A}) may be provided to determine the level of authentication used when binding. If {\bf -A} {\em authlevel} is omitted, the requested 
level of authentication is taken from the environment variable AUTHLEVEL, and is set to {\em no 
authentication}, if no such variable exists.
In case of simple authentication being used, the caller's distinguished name and
X.500 password are retrieved from the PSE objects Name and QuipuPWD, respectively.

If option {\bf -F} is provided, the own FCPath is considered as being trusted.
This is useful for optimizing the verification process,
if the originator of a PEM message and its recipient have a common point of trust
within their forward certification paths, or if the caller wishes to evaluate PEM messages
generated by himself.

If option {\bf -R} is given, a check of certificate revocation lists is required for all certificates
which are in the certification path. In case that option {\bf -D} is additionally provided, missing CRLs will
automatically be retrieved from the Directory. In addition, whenever a CRL is consulted, the 
nextUpdate field of the CRL is compared with the current time and date, and in case of nextUpdate
being expired, the actual CRL will be retrieved from the Directory. 

If option {\bf -N}
is given, also non standard algorithms (i.e. algorithms which are not defined by RFC 1423,
but which are suitable for PEM purposes and contained in the SecuDE algorithm suite, for instance
NIST-SHA and NIST-DSA) are accepted. Otherwise, only RFC 1423 defined algorithms are accepted.

If option {\em -O} (capital letter O) is given, RFC 1422 defined DName subordination rules
are not applied during MIC verification. Otherwise only RFC 1422 conformant certification
structures are accepted. 

{\bf Status information} may consists of the following notifications:
\bi
\m a Proc-Type ENCRYPTED has been scanned, but that no appropriate 
   issuer/serialnumber was found in the Recipient-ID-Asymmetric header fields,
\m a Proc-Type ENCRYPTED has been scanned and an appropriate 
   issuer/serialnumber was found, but that the decryption of the key from the corresponding 
   Key-Info field failed,
\m a Proc-Type MIC-CLEAR or MIC-ONLY has been scanned and the message appears to be a
   certification request (which is the case if it contains an Originator-Certificate
   header field with the issuer DName and subject DName being identical). 
   issuer/serialnumber was found, but that the decryption of the key from the corresponding 
   Key-Info field failed,
\m a Proc-Type CRL has been scanned, containing the indicated issuers,
\m a Proc-Type CRL-RETRIEVAL-REQUEST has been scanned, containing the indicated issuers,
\m Detected syntax errors.
\ei

The {\bf PEM transformation result} which is written to the output consists of the
following:
\bi
\m If no PEM boundary lines are found, the input is copied to the output.
\m If the scanned Proc-Type is MIC-CLEAR, MIC-ONLY or ENCRYPTED, all input lines which are 
   outside the PEM boundary lines, and the de-enhanced PEM body are written to the output. 
   This is done even in case that the MIC verification and validation failed. If
   syntax errors have been encountered, or an ENCRYPTED message could not be decrypted,
   nothing is written to the output.
\m If the scanned Proc-Type is CRL-RETRIEVAL-REQUEST, a PEM message of Proc-Type CRL is written
   to the output if the request can at least partly be satisfied with the locally stored 
   information. In case that {\em pem scan} was called by a normal user (indicated through the
   absence of parameter {\bf -c} {\em cadir}), the PSE-object CrlSet is consulted to
   satisfy the request. In case that {\em pem} scan was called by a CA (indicated through the
   presence of parameter {\bf -c} {\em cadir}), the CA-database is consulted to
   satisfy the request. If none of the requested CRLs is available, nothing is written
   to the output.
\ei

The user's (or CA's) {\bf PSE} can be potentially {\bf update}d in the following situations:

\bi
\m An Originator-Certificate has been scanned and successfully validated which is not
   contained in the user's list of trusted keys, PKList. The ToBeSigned part of such
   a certificate can be added to PKList in order to consider it being trusted in the future.
   Whenever {\em pem} adds a new entry to PKList, it checks whether the distinguished
   name of the subject has already an alias name. If not, it requests the user to
   supply at least one alias name.  
\m An Originator-Certificate has been scanned and successfully validated which has the
   own distinguished name as subject name. This is supposed to be a certification reply
   if it is different from what is currently stored in the PSE-object Cert, and if it
   is part of a MIC-CLEAR or MIC-ONLY message. This certificate can be stored in the
   PSE-object Cert as own public key certificate.
\m A Proc-Type CRL has been scanned which can either be a CRL-storage request or be a
   CRL-retrieval reply. The CRLs contained in that PEM message can be stored in the CA-database,
   if {\em pem scan} was called by a CA, or can be added to the PSE-object CrlSet which is the
   user's CRL-cache, or it can be stored in both.
\ei

The {\em CA-database} can be potentially {\bf update}d when a Proc-Type CRL has been scanned
which is supposed to be a CRL-storage request.

Parameter {\bf -u} {\em update} controls whether or not {\em pem} scan does these updates automatically. 
{\em update} may have five values:
\bvtab
{\bf ask:}  \2 pem asks interactively via /dev/tty whether it shall do the update or not. \\
{\bf no:}   \2 pem doesn't do any update of the PSE or CA-database. \\
{\bf yes:}  \2 pem automatically updates both PSE and/or CA-database. \\
{\bf cadb:} \2 pem automatically updates the CA-database. \\
{\bf pse:}  \2 pem automatically updates the PSE. \\
\evtab

{\large\bf Mic-clear}

This mode transforms the input to a MIC-CLEAR PEM message. If option {\bf -C} is given, the created
PEM message contains an Originator-Certificate header field and all Issuer-Certificate header fields
up to the root CA. If option {\bf -C} is omitted, it contains an Originator-ID-Asymmetric header
field.

Parameter {\bf -H} {\em md-alg} and {\bf -S} {\em micenc-alg}
allow to use any of the algorithms available in SecuDE and suitable
for the intended purpose. {\em md-alg} and {\em micenc-alg}
are names of algorithms as they are listed in INTRO(3).

{\bf -H} {\em md-alg}: Algorithm which is used to compute the MIC. RSA-MD5 is the default.
To be conformant to RFC 1423, only RSA-MD2 can be choosen as an alternative. If RFC 1423
conformance is not a requirement, any algorithm can be choosen which has AlgType HASH.

{\bf -S} {\em micenc-alg}: Algorithm which is used to encrypt the MIC. RSA is the default.
To be conformant to RFC 1423, no other algorithm can be choosen. If RFC 1423
conformance is not a requirement, any algorithm can be choosen which has AlgType ASYM\_ENC.

{\large\bf Mic-only}

This mode transforms the input to a MIC-ONLY PEM message. All options described under mic-clear
above apply to mic-only, too.

{\large\bf Encrypted}

This mode transforms the input to an ENCRYPTED PEM message. Parameter {\bf -r} {\em name1 name2 
...}
allows to specify the intended recipients. {\em name1 name2 ...} may be alias names or distinguished
names in their printable representation. In the latter case, the names must be quoted since they
contain shell metacharacters.

In addition to the parameters {\bf -C}, {\bf -H} {\em md-alg} and {\bf -S} {\em micenc-alg} 
described under mic-clear, which also apply in the encrypted case, {\bf -E} {\em msgenc-alg} and
{\bf -K} {\em dekenc-alg} allow to use any of the algorithms available in SecuDE and suitable 
for purpose of hybrid message encryption. {\em msgenc-alg} and {\em dekenc-alg}
are names of algorithms as they are listed in INTRO(3).

{\bf -E} {\em msgenc-alg}: Algorithm which is used to encrypt the message body.
DES-CBC is the default.
To be conformant to RFC 1423, no other algorithm can be choosen. If RFC 1423
conformance is not a requirement, any algorithm can be choosen which has AlgType SYM\_ENC.

{\bf -K} {\em dekenc-alg}: Algorithm which is used to encrypt the DEK (data encryption key).
RSA is the default.
To be conformant to RFC 1423, no other algorithm can be choosen. If RFC 1423
conformance is not a requirement, any algorithm can be choosen which has AlgType ASYM\_ENC.

{\large\bf Crl}

This mode creates a CRL PEM message. Parameter {\bf -y} {\em issuer1 issuer2 ...}
allows to specify a list of issuers. {\em issuer1 issuer2 ...} may be alias names or distinguished
names in their printable representation. In the latter case, the names must be quoted since they
contain shell metacharacters. The given issuer's CRLs are searched in the PSE-object CrlSet, or they
are retrieved from the CA-database, depending on whether {\em pem crl} was called from a normal
user (indicated through the absence of parameter {\bf -c} {\em cadir}) or from a CA (indicated through 
the presence of parameter {\bf -c} {\em cadir}).

{\large\bf Crl-rr}

This mode creates a CRL-RETRIEVAL-REQUEST PEM message. Parameter {\bf -y} {\em issuer1 issuer2 
...}
allows to specify a list of issuers. {\em issuer1 issuer2 ...} may be alias names or distinguished
names in their printable representation. In the latter case, the names must be quoted since they
contain shell metacharacters.

{\large\bf Certify}

This mode is used by a CA in order to satisfy an incoming certification request. It scans the input
which is supposed to be a certification request and writes the certification reply to the output.
The output is identical to the input except that the Originator-Certificate from the input which
is a requestor generated prototype certificate is replaced by a certificate signed by the CA.
{\em pem certify} performs all necessary validation and checking. No output is written if the
Originator-Certificate can't be verified or if it is not a prototype certificate. The use
of {\em pem certify} requires additional out-of-band verification of the prototype certificate
and the presented subject name.

\hl{Options}
\parname {{\bf scan}}
\pardescript {Scan PEM message, write clear body of the message ({\bf default}).} \\
\parname {{\bf mic-clear}}
\pardescript {Read clear body, create Proc-Type MIC-CLEAR.} \\
\parname {{\bf mic-only}}
\pardescript {Read clear body, create Proc-Type MIC-ONLY.} \\
\parname {{\bf encrypted}}
\pardescript {Read clear body, create Proc-Type ENCRYPTED} \\
\parname {{\bf crl}}
\pardescript {Create Proc-Type CRL.} \\
\parname {{\bf crl-rr}}
\pardescript {Create Proc-Type CRL-RETRIEVAL-REQUEST.} \\
\parname {{\bf certify}}
\pardescript {Scan PEM message and create certification reply (for CAs only).} \\
\parname {{\bf -i} {\em inputfile}}
\pardescript {Inputfile (default stdin).} \\
\parname {{\bf -o} {\em outputfile}}
\pardescript {Outputfile (default stdout).} \\
\parname {{\bf -p} {\em psename}}
\pardescript {PSE name (default: {\em .pse}).} \\
\parname {{\bf -c} {\em cadir}}
\pardescript {CA-directory name.} \\
\parname {{\bf -m} {\em depth}}
\pardescript {Depth of multi PEM body, which is to be de-enhanced (if {\bf scan} a nested PEM message). A 
{\em depth} of 
zero identifies the outmost body.} \\
\parname {{\bf -M} {\em depth}}
\pardescript {depth of multi PEM body, up to which is to be de-enhanced (if {\bf scan} a nested PEM 
message).} \\
\parname {{\bf -u} {\em update}}
\pardescript {Controls under which circumstances the PSE or the CA-database will be updated.} \\
\parname {{\bf -r} {\em name1 name2 ... }}
\pardescript {List of intended recipients in case of creating a PEM Proc-Type ENCRYPTED.} \\
\parname {{\bf -y} {\em name1 name2 ... }}
\pardescript {Issuers of CRLs, if crl or crl-rr.} \\
\parname {{\bf -C} }
\pardescript {generate PEM-header with Originator-Certificate and all Issuer-Certificates (default: 
generate PEM-header with Originator-ID-Asymmetric).} \\
\parname {{\bf -n} }
\pardescript {don't insert Key-Info header field for originator (only if pem encrypted).} \\
\parname {{\bf -h} }
\pardescript {write help-text to stderr.} \\
\parname {{\bf -v} }
\pardescript {verbose.} \\
\parname {{\bf -V} }
\pardescript {Verbose.} \\
\parname {{\bf -R} }
\pardescript {Consult CRLs during the validation process.} \\
\parname {{\bf -F} }
\pardescript {Consider own FCPath as trusted.} \\
\parname {{\bf -D} }
\pardescript {Retrieve certificates and CRLs needed for the MIC verification from Directory.} \\
\parname {{\bf -d} {\em dsaname}}
\pardescript {Name of the DSA to be initially accessed (default: locally configured DSA).} \\
\parname {{\bf -A} {\em authlevel}}
\pardescript {Authentication level to be used when accessing the X.500 Directory 
(default: environment variable AUTHLEVEL or no authentication).} \\
\parname {{\bf -H} {\em md-alg}}
\pardescript {Message digest algorithm (default: RSA-MD5).} \\
\parname {{\bf -S} {\em micenc-alg}}
\pardescript {MIC encryption algorithm (default: RSA).} \\
\parname {{\bf -E} {\em msgenc-alg}}
\pardescript {Message encryption algorithm (default: DES-CBC) (only if pem encrypted).} \\
\parname {{\bf -K} {\em dekenc-alg}}
\pardescript {DEK encryption algorithm (default: RSA) (only if pem encrypted).} \\
\parname {{\bf -t} }
\pardescript {Enable control of malloc/free behaviour (needs SecuDE compiled with option MFCHECK)} \\
\parname {{\bf -T} }
\pardescript {Perform public key RSA operations in the SCT (per default this is done in the workstation
even if a smartcard terminal is connected)} \\
\hl{Files}
\btab
\$HOME/.af-alias \4 Per user alias names \\
\$TOP/secude/.af-db/.af-alias \4 Per installation alias names 
\etab
\hl{See Also}
pem\_read(3), pem\_write(3)

\nm{1}{psemaint}{maintain PSE}
\label{psemaint}
\hl{Synopsis}
{\bf psemaint} [ {\bf -htvACFRDTVW} ] [ {\bf -c} {\em cadir} ] [ {\bf -p} {\em psename} ] [ {\bf -a} {\em 
issueralg} ] [ {\bf -f} {\em notbefore} ] 
\\ \hspace*{1.59cm} [ {\bf -l} {\em notafter} ] [ {\bf -i} {\em inputfile} ] [ {\bf -d} {\em dsaname} ] [ {\bf -A} {\em authlevel} ] [ {\em command} ]
\hl{Description}
{\bf psemaint} is a maintenance program which can be used by both
certification authority administrators and users for the purpose of maintaining their
PSEs. This includes moving information (e.g. keys, certificates, revocation lists etc.) from Unix files
or public X.500 directories into the PSE and vice versa, generating keys, changing PINs and displaying the 
content
of the PSE. If a CA PSE is addressed, the CA database contained in the CA directory is used, too.
In the basic version of SECUDE the PSE is realized by software.

If {\bf -p} {\em psename} is given, the PSE {\em psename} is selected. The default for
{\em psename} is either provided by the environment variable PSE, or is {\em .pse} under the
HOME directory, if no such variable exists.

If {\bf -c} {\em cadir} is given, the PSE {\em psename} of a CA residing in the CA directory {\em cadir}
is selected; in this case, the default for PSE is either provided by the environment
variable CAPSE or is {\em .capse}, if no such variable exists.

{\em notbefore} (option {\bf -f}) and {\em notafter} (option {\bf -l}) are dates of validity in the 
form 'YYMMDD'. They are evaluated by the {\bf certify} command available with {\bf psemaint}. 
If they are omitted, the first date on which a certificate generated with the {\bf certify} command
is valid, is set to the current time, 
and the last date on which the certificate is valid is set to one year hereafter.

If option {\bf -D} is provided, Directory-based information may be stored on the PSE, or
information stored on the PSE may be entered into the Directory.
The Directory may either be a 
X.500 directory or the local substitute provided by 
SecuDE ({\em .af-db}) (see also DirectoryType(5)).

If a X.500 directory is accessed, option {\bf -d} may be used to specify the DSA (Directory System 
Agent) 
(identified by {\em dsaname}) which shall be contacted for the required directory operation; otherwise, the DSA whose name and network address are defined by the {\em dsa\_address} parameter in the system's 
{\em dsaptailor} file will be accessed. 
Parameter {\em authlevel} (option {\bf -A}) may be provided to determine the level of authentication used when binding. If {\bf -A} {\em authlevel} is omitted, the requested 
level of authentication is taken from the environment variable AUTHLEVEL, and is set to {\em no 
authentication}, if no such variable exists.
In case of simple authentication being used, the caller's distinguished name and
X.500 password are retrieved from the PSE objects Name and QuipuPWD, respectively.

If a command available with {\bf psemaint} requires a signature to be performed (e.g. command {\em 
certify}) and the own
signature key is of type {\em ASYM\_ENC}, the algorithm name associated with the signature can be 
specified by {\em issueralg} (option {\bf -a}). {\em issueralg} must be a
signature algorithm (AlgType SIG, see INTRO(3) on available algorithms) which fits to the associated 
algorithm of the signature key (e.g., the algorithm md5WithRsa cannot be used with an ElGamal key).
The default for {\em issueralg} is md2WithRsaEncryption.

If option {\bf -F} is provided, the own FCPath is considered as being trusted.
This is useful for optimizing the verification process (see psemaint command {\em verify}),
if the originator of a digital signature and the PSE owner have a common point of trust
within their forward certification paths, or if the PSE owner wishes to verify signatures
generated by himself.

If option {\bf -R} is provided, PEM revocation lists will be considered by the verification process
(see psemaint command {\em verify}).

Option {\bf -v} renders the psemaint command verbose, and options {\bf -V} and {\bf -W} provide some further
logging information. 

Option {\bf -t} may be provided for testing purposes; it requests to control 
the malloc/free behaviour.

In case that a smartcard terminal is used, option {\bf -T} requests to perform any public key 
RSA operation in the smartcard terminal, and not with the software in the workstation 
(the latter is the default).

If {\bf -i} {\em inputfile} is given, commands are read from {\em inputfile}, otherwise
commands are read from stdin.

If {\em command} is given, psemaint executes this single command only and then terminates. 
Otherwise, commands can be executed interactively or from {\em inputfile}.make  

If the required PSE does not exist,
and {\em command} is other than {\em create}, psemaint terminates with an appropriate message.
\\ [1em]
{\bf Creation of a PSE}
\\ [1em]
A new PSE can be created by giving the command 
\bc
{\bf psemaint} [ {\bf -p} {\em psename} ] create
\ec
{\bf psemaint} then requires the distinguished name of the owner of the PSE from /dev/tty.
This name is of the type {\em Name} which is the character string representation
of distinguished names described in INTRO(1).
\\ [1em]
After the owner's name was entered, {\bf psemaint} asks for a PIN (which is a password in case
of the PSE) of the entire PSE, the so called PSE-PIN. If a PIN is given here, 
the table of contents (TOC) of the PSE,
and each object for which no object-specific PIN is given on creation time, are encrypted with an 
encryption
key derived from the given PSE-PIN. If no PIN shall be used, CR must be entered. 
\\ [1em]
{\bf Commands} 
\\ [1em]
The following commands are available. They may be abbreviated as indicated by bold letters.
Commands which are marked as CA commands are for CAs only.
\\ [1em]
\begin{tabular}{ll}
{\bf add}alias     & Add Alias entry to Alias Database           		       \\
{\bf add}ek        & Add ToBeSigned part of certificate to EKList    		       \\
{\bf add}pk        & Add ToBeSigned part of certificate to PKList    		       \\
{\bf alg}s         & Show OIDs, names and parameters of algorithm or algorithm type    \\
{\bf ali}as2dname  & Search aliasnames containing given pattern and show corresp. DName\\
{\bf authno}ne     & Access the X.500 directory without using any authentication       \\
{\bf authsi}mple   & Access the X.500 directory using SIMPLE authentication            \\
{\bf authst}rong   & Access the X.500 directory using STRONG authentication            \\
{\bf cac}ertificate & Show certificate with given serial number (CA command)           \\
{\bf cap}emcrl     & List PEM-revocation lists of all CAs known to the CA (CA command) \\
{\bf cas}erialnumbers & Show serialnumbers and dates of issue for given user (CA command) \\
{\bf cau}sers      & List all users of CA (CA command)                                 \\
{\bf certi}fy      & Certify public key contained in Certificate (CA command)          \\
{\bf cert2k}eyinfo & Write object of type KeyInfo with PK from Certificate             \\
{\bf cert2p}kroot  & Write object of type PKRoot with PK from Certificate              \\
{\bf che}ck        & Check PSE consitency                                              \\
{\bf chp}in        & Change PSE-PIN or object-PIN                                      \\
{\bf cl}ose        & Close PSE or PSE object                                           \\
{\bf cr}eate       & Create PSE or object                                              \\
{\bf dela}lias     & Remove Alias name from Alias Database               	       \\
{\bf delek}        & Remove ToBeSigned part of certificate from EKList    	       \\
{\bf delet}e       & Delete PSE object                                                 \\
{\bf delk}ey       & Delete key with given keyref                                      \\
{\bf delpe}mcrl    & Remove locally stored revocation list of a given issuer           \\
{\bf delpk}        & Remove ToBeSigned part of certificate from PKList    	       \\
{\bf dn}ame2alias  & Search DNames containing given pattern and show corresp. aliases  \\
{\bf end}          & Exit program                                                      \\
{\bf ent}er	   & Enter object into Directory				       \\
{\bf ex}it         & Exit program                                                      \\
{\bf g}enkey       & Generate key and store in object or under keyref                  \\
{\bf h}elpcmd or {\bf ?} & Show helptext for cmd                                       \\
{\bf i}nitpemcrl   & Create an empty PemCrl (CA command)                               \\
{\bf k}eytoc       & Show table of contents (TOC) of key-pool                          \\
{\bf o}pen         & Open PSE or PSE object                                            \\
{\bf p}rototype    & Create self-signed prototype certificate of own public signature key \\
{\bf q}uit         & Exit program                                                      \\
{\bf rea}d         & Read PSE object into file                                         \\
{\bf rem}ove       & Remove object from Directory				       \\
{\bf ren}ame       & Rename PSE object                                                 \\
{\bf ret}rieve     & Retrieve object from Directory				       \\
{\bf rev}oke       & Revoke one or more certificates (CA command)                      \\
{\bf set}parm      & Set parameters of given algorithm                                 \\
{\bf sh}ow         & Show PSE object or keyref in suitable form                        \\
{\bf sp}lit        & Split Cross Certificate Pair into its components                  \\
{\bf stri}ng2key   & Generate DES key from string and store in object or under keyref  \\
{\bf t}oc          & Show table of contents (TOC)                                      \\
{\bf v}erify       & Verify digital signatures                                         \\
{\bf w}rite        & Write file into PSE object                                        \\
{\bf x}dump        & xdump object or keyref                                            \\
\end{tabular} \\ [1em]
Most commands require parameters which are interactively asked for when they are missing. 
Parameters are partly keyword-parameters of the form {\em keyword$=$value}, partly positional 
parameters. Keywords
may be abbreviated, either. In case of the PSE, object-names are the names of 
the files on the PSE containing the objects.
\\ [1em]
{\bf Description of the Commands} 
\\ [1em]
{\bf algs} {\em algname} or {\em algtype}
\begin{quote}
Shows names, OIDs and parameters of the given algorithm {\em algname} or of all algorithms
of type {\em algtype}. The algorithm type can be one of
\bvtab
\1 ASYM\_ENC \3 - asymmetric encryption algorithms \\
\1 SYM\_ENC  \3 - symmetric encryption algorithms \\
\1 HASH      \3 - hash algorithms \\
\1 SIG       \3 - signature algorithms \\
\1 ALL       \3 - all algorithms \\
\evtab
See INTRO(3X) for valid algorithm names.
\end{quote}

{\bf addalias} {\em username}
\begin{quote}
Adds an alias entry with distinguished name {\em username} to the USER or SYSTEM alias file.
\end{quote}

{\bf addek} {\em certificate}
\begin{quote}
Extracts the ToBeSigned from PSE object {\em certificate} (which must be of type Certificate)
and adds it to PSE object EKList.
\end{quote}

{\bf addpk} {\em certificate}
\begin{quote}
Extracts the ToBeSigned from PSE object {\em certificate} (which must be of type Certificate)
and adds it to PSE object PKList.
\end{quote}

{\bf alias2dname} {\em pattern}
\begin{quote}
Searches the alias files \$HOME/.af-alias and \$TOP/secude/.af-alias for alias names
containing pattern and prints one line per hit
\bc
{\em aliasname} - - -$>$ $<${\em distinguished name}$>$
\ec
\end{quote}

{\bf authnone}
\begin{quote}
This command is available only if a X.500 Directory is being used.
It determines that the X.500 Directory shall henceforth be accessed without using any authentication.
(Simple authentication is the default level of authentication.) 
\end{quote}

{\bf authsimple}
\begin{quote}
This command is available only if a X.500 Directory is being used.
It determines that the X.500 Directory shall henceforth be accessed using simple authentication.
(Simple authentication is the default level of authentication.) 
\end{quote}

{\bf authstrong}
\begin{quote}
This command is available only if a X.500 Directory is being used.
It determines that the X.500 Directory shall henceforth be accessed using strong authentication. 
\end{quote}


{\bf cacertificate} {\em serial}
\begin{quote}
This command is for CA PSEs only.
It shows the certificate with serial number {\em serial} issued by the PSE-owning CA (see also
{\em caserialnumbers} to obtain a list of all issued serial numbers). The
information is retrieved from the CA database contained in the CA directory (see also {\em cacreate(1)}).
\end{quote}

{\bf capemcrl}
\begin{quote}
This command is for CA PSEs only.
It lists the PEM revocation lists of all CAs known to the CA. Each of the revocation lists is optionally
accompanied by its issuer's certification path. 
The information is retrieved from the CA database contained in the CA directory (see also {\em 
cacreate(1)}).
\end{quote}

{\bf caserialnumbers} {\em name}
\begin{quote}
This command is for CA PSEs only.
It lists serial number and date-of-issue of all certificates which the PSE-owning CA has 
issued for the user identified by {\em name} where {\em name} is a distinguished name in 
printable representation (Name form) or an alias name. If {\em name} is of Name form
(containing '=' characters) it must be quoted. The information is retrieved from the 
CA database contained in the CA
directory (see also {\em cacreate(1)}).
\end{quote}

{\bf causers}
\begin{quote}
This command is for CA PSEs only.
It lists all users for whom the PSE-owning CA has issued a certificate. Each user is represented 
by its distinguished name in printable representation. The information is retrieved from the CA database
contained in the CA directory (see also {\em cacreate(1)}).
\end{quote}

{\bf certify} {\em certificate}
\begin{quote}
This command is for CA PSEs only.
It certifies the public key contained in {\em certificate} (which must be of type Certificate).
This command is useful for a CA which requests to cross-certify another CA's public key.
\end{quote}

{\bf cert2keyinfo} {\em certificate}~ {\em keyinfo}
\begin{quote}
Extracts the KeyInfo containing the public key from PSE object {\em certificate} 
(which must be of type Certificate), and writes it to {\em keyinfo}.
\end{quote}

{\bf cert2pkroot} {\em certificate}~ {\em pkroot}
\begin{quote}
Extracts the KeyInfo containing the public key from PSE object {\em certificate} 
(which must be of type Certificate), builds a new object of type PKRoot (containing
only the {\em newkey} member) and writes it to {\em pkroot}.
\end{quote}

{\bf check}
\begin{quote}
Check the consistency of the PSE. The certification pathes SignCert --> FCPath --> PKRoot
and EncCert --> FCPath --> PKRoot are verified. In addition it is checked whether
the public RSA key in SignCert fits to the secret RSA key in SignSK, and whether the
public RSA key in EncCert fits to the secret RSA key in DecSKnew.
\end{quote}

{\bf chpin} {\em object}
\begin{quote}
Changes the PSE-PIN, if no PSE object is given, or the object-PIN for the PSE object {\em object}. 
If an PSE-PIN is indicated, the PIN's of all objects which have
no object-specific PIN are changed. If only CR is entered as PIN, the PIN-protection is removed.
\end{quote}

{\bf close} {\em psename}
\begin{quote}
Close the previously opened PSE.
\end{quote}

{\bf create} {\em object}
\begin{quote}
Create the PSE object {\em object}
of the PSE which is currently open. Asks for PIN's.
\end{quote}

{\bf delalias} {\em alias}
\begin{quote}
Removes the given {\em alias} from either the USER alias file or the SYSTEM alias file. If the
last alias name of an alias entry is removed, the whole alias entry is deleted from the alias file.
\end{quote}

{\bf delek} {\em subject}~ {\em issuer}~ {\em serialnumber}
\begin{quote}
Removes ToBeSigned entries from PSE object EKList.
{\em delek} deletes either all entries of the given {\em subject} (owner) or exactly the one entry identified by 
the
given {\em issuer} and {\em serialnumber} combination. {\em Owner} and {\em Issuer} are distinguished
names in printable form or alias names.
\end{quote}

{\bf delete} {\em object}
\begin{quote}
Delete the the PSE object {\em object}. 
\end{quote}

{\bf delkey} {\em keyref} 
\begin{quote}
Removes the key {\em keyref} from the key-pool.
\end{quote}

{\bf delpemcrl} {\em issuer}
\begin{quote}
Removes revocation list from PSE object CrlSet.
{\em delpemcrl} deletes the revocation list (PEM syntax) issued by {\em issuer} from the set of 
locally stored revocation lists. {\em Issuer} is a distinguished name in printable form or an alias name.
\end{quote}

{\bf delpk} {\em subject}~ {\em issuer}~ {\em serialnumber}
\begin{quote}
Removes ToBeSigned entries from PSE object PKList.
{\em delpk} deletes either all entries of the given {\em subject} (owner) or exactly the one entry identified by 
the
given {\em issuer} and {\em serialnumber} combination. {\em Owner} and {\em Issuer} are distinguished
names in printable form or alias names.
\end{quote}

{\bf dname2alias} {\em pattern}
\begin{quote}
Searches the alias files \$HOME/.af-alias and \$TOP/secude/.af-alias for distinguished names
containing pattern and prints all corresponding alias names (one line per alias)
\bc
$<${\em distinguished name}$>$ - - -$>$  {\em aliasname}
\ec
\end{quote}

{\bf enter} {\em attrtype}~ {\em keytype} 
\begin{quote}
Enter information of type {\em attrtype} into Directory. \\
The Directory may either be a X.500 Directory or the local substitute provided by 
SecuDE ({\em .af-db}). (see also DirectoryType(5)).
{\em attrtype} is {\em {\bf U}serCertificate} or {\em {\bf Ce}rtificate} by default, depending on whether
or not a X.500 Directory shall be accessed. Further possible values for {\em attrtype} are
{\em {\bf CA}Certificate}, {\em {\bf Cr}ossCertificatePair}, and {\em {\bf P}emCertificateRevocationList}.
{\em keytype} may have one of the values {\bf E} or {\bf S}.
 
If the X.500 Directory is accessed and {\em attrtype} is {\em UserCertificate} ({\em CACertificate}), a certificate stored in the PSE 
is added to the {\em userCertificate} ({\em cACertificate}) attribute in
the caller's X.500 directory entry.
If the .af-db Directory is accessed, however, the certificate is stored in the file {\em SignCert} or 
{\em EncCert}, depending on {\em keytype}, in the .af-db subdirectory identified by the distinguished name 
of the certificate owner. (If the caller's PSE is restricted to carry one RSA keypair only, the
certificate is stored as file {\em Cert}, instead.)
The PSE object containing the certificate is asked for interactively. \\
The following objects (CrossCertificatePairs and Revocation Lists) may be entered into 
the Directory by CAs only: \\
If the X.500 Directory is accessed and {\em attrtype} is {\em CrossCertificatePair}, 
a cross certificate pair 
is added to the {\em crossCertificatePair} attribute in the calling CA's X.500 directory entry. 
If the local .af-db Directory is accessed, however, the cross certificate pair is added to the 
file {\em CrossCSet}
in the .af-db subdirectory identified by the CA's distinguished name.
The PSE objects (which must be of type 
Certificate) containing the components of the cross certificate pair ({\em forward} and {\em reverse}
certificate) are asked for interactively; at least one of the two components (forward 
or reverse certificate) of the cross certificate pair must be indicated. \\
If the X.500 Directory is accessed and {\em attrtype} is {\em PemCertificateRevocationList}, 
the CA's PEM revocation list
is retrieved from the CA's {\em pemcrlwithcerts} database and stored in the calling CA's X.500 
directory entry.
If the local .af-db Directory is accessed, however, the CA's revocation list is stored in
the file {\em PemCrl} in the .af-db subdirectory identified by the CA's distinguished name. 
\end{quote}

{\bf genkey} {\em algname}~ {\em object1/keyref1} {\em object2/keyref2} 
\begin{quote}
Generates a symmetric key or asymmetric key pair and stores it in {\em object1/object2} or 
under {\em keyref1/keyref2}. 
If a PSE object is indicated, the object must not exist, otherwise psemaint will ask for overwriting. 
Parameters associated to the indicated algorithm (i.e. keysize for RSA) may
be changed before using {\bf setparm}. 
 
If {\em algname} indicates a DES algorithm, a 64-bit long BitString is generated as DES key. The
known bad DES keys are avoided. If {\em algname} indicates a DES algorithm in 
Encryption(k1)-Decryption(k2)-Encryption(k1) mode, a 128-bit long BitString is generated with
the first 64 bit comprising k1 and the second 64 bit comprising k2.
 
If {\em algname} indicates an RSA algorithm, two BitStrings are generated, one being
the ASN.1 code of the public key, the other being the ASN.1 code of the secret key.
The public key ist stored in {\em object1} or {\em keyref1}, the secret key is stored in
{\em object2} or {\em keyref2}.
See INTRO(3X) for valid algorithm names.
\end{quote}

{\bf help} or {\bf ?} {\em cmd}
\begin{quote}
Shows helptext for the command {\em cmd}.
\end{quote}

{\bf initpemcrl} 
\begin{quote}
This command is for CA PSEs only.
It creates an empty PEM revocation list which is stored in the CA database and entered into the Directory. \\
The Directory may either be a X.500 directory or the local substitute provided by 
SecuDE ({\em .af-db}). (The decision whether a X.500 directory or the local substitute 
is used is done at compile time through the variable DX500 in the file CONFIG.make
at \$TOP/secude/config.) \\
The {\em lastUpdate} component of the empty revocation list is set to the current time, whereas the value 
of the {\em nextUpdate} component may individually be specified by the calling CA. The empty
revocation list is written to the {\em pemcrlwithcerts} database in the CA's directory, where an already
existing revocation list of the calling CA will be replaced; in addition, 
it is entered into the directory (X.500 or local substitute, respectively), where it replaces
a revocation list that has already been stored there by the calling CA. 
Furthermore, the empty revocation list is added to the PSE object CrlSet in the CA's PSE, where an
already existing revocation list of this CA will be replaced.
\end{quote}

{\bf keytoc}
\begin{quote}
Show table of contents (toc) of the key-pool. The (user-specific) key-pool keeps all
keys which are addressable via keyref's (see INTRO(3X) for further explanation of the key-pool).
\end{quote}

{\bf open} {\em psename}
\begin{quote}
Open a new PSE. The PSE which is currently open is closed. After the invocation 
of psemaint either the PSE .pse or the PSE
given with option {\bf -p} {\em psename} is open. All succeeding commands refer to this
PSE.
\end{quote}

{\bf prototype}
\begin{quote}
Create a self-signed prototype-certificate containing the own public signature key.
\end{quote}

{\bf quit} or {\bf exit} or {\bf end} 
\begin{quote}
Exit program.
\end{quote}

{\bf read} {\em object}~ {\em destination} 
\begin{quote}
Read the content of the given PSE object {\em object}
and write the objectValue into file {\em destination}. Includes all PIN-handling. 
{\em sec\_read\_PSE()} is used to get the objectValue part.
\end{quote}

{\bf remove} {\em attrtype}~ {\em keytype} cert$=${\em serial},{\em issuer}~ for$=${\em serial},{\em 
issuer}~ rev$=${\em serial},{\em issuer}
\begin{quote}
Remove information of type {\em attrtype} from Directory. \\
The Directory may either be a X.500 Directory or the local substitute provided by 
SecuDE ({\em .af-db}). (see also DirectoryType(5)).
{\em attrtype} is {\em {\bf U}serCertificate} or {\em {\bf Ce}rtificate} by default, depending on whether
or not a X.500 Directory is accessed. Further possible values for {\em attrtype} are
{\em {\bf CA}Certificate} and {\em {\bf Cr}ossCertificatePair}.
{\em keytype} may have one of the values {\bf E} or {\bf S}.
 
If the X.500 Directory is accessed and {\em attrtype} is {\em UserCertificate} ({\em CACertificate}), the certificate identified by 
{\em serial} and {\em issuer} is removed from the {\em userCertificate} ({\em cACertificate}) attribute in the caller's X.500 directory entry. \\
If the local substitute is used, however, the file {\em SignCert} or {\em EncCert} 
(depending on {\em keytype}) 
in the .af-db subdirectory identified by the caller's distinguished name is deleted.
(If the caller's PSE is restricted to hold one RSA keypair only, the file {\em Cert} is
removed, instead.)
If {\em attrtype} is {\em CrossCertificatePair}, a cross certificate pair whose components ({\em forward}
and {\em reverse} certificate) are identified by their serial number {\em serial} and issuer
{\em issuer}, is removed from the {\em crossCertificatePair} attribute in the calling CA's 
X.500 directory entry. (A cross certificate pair may be removed from the Directory by CAs only.)
If the local substitute is used, however, the cross certificate pair is removed from the file {\em CrossCSet}
in the .af-db subdirectory defined by the CA's distinguished name.
At least one of the two components ({\em forward} or {\em reverse} certificate) is required for identifying 
the cross certificate pair that is to be removed from the Directory.
\end{quote}

{\bf rename} {\em object}~ {\em newname}
\begin{quote}
Rename the given PSE object {\em object} with {\em newname}. 
\end{quote}

{\bf retrieve} {\em dirname}~ {\em attrtype}~ {\em keytype} {\em update}
\begin{quote}
Retrieve information of type {\em attrtype} from Directory. \\
The Directory may either be a X.500 Directory or the local substitute provided by 
SecuDE ({\em .af-db}). (see also DirectoryType(5)).
{\em attrtype} is {\em {\bf U}serCertificate} or {\em {\bf Ce}rtificate} by default, depending on whether
or not a X.500 Directory shall be accessed. Further possible values for {\em attrtype} are
{\em {\bf CA}Certificate}, {\em {\bf Cr}ossCertificatePair}, and {\em {\bf P}emCertificateRevocationList}.
{\em keytype} may have one of the values {\bf E} or {\bf S}.
 
If the X.500 Directory is accessed and {\em attrtype} is {\em UserCertificate} ({\em CACertificate}), 
the set of certificates 
stored in the X.500 directory entry identified by {\em dirname} is returned; the set of 
certificates comprises the value(s) of the {\em userCertificate} ({\em cACertificate}) attribute. 
If the local .af-db Directory is accessed, however, the returned set of certificates either comprises
the certificate stored in file {\em Cert} (if present), or the certificate stored in file 
{\em SignCert} or {\em EncCert} (depending on {\em keytype}), which is located in 
the .af-db subdirectory identified by {\em dirname}.
If {\em update} is set to TRUE, one certificate among the returned set of certificates may
be selected by the user and stored in its PSE.\\
If the X.500 Directory is accessed and {\em attrtype} is {\em CrossCertificatePair}, 
the set of cross certificate 
pairs stored in the directory entry identified by {\em dirname} is returned; the set of 
cross certificate pairs comprises the value(s) of the {\em crossCertificatePair} attribute. 
If the local .af-db Directory is accessed, however, the set of cross certificate pairs is retrieved
from the file {\em CrossCSet} in the .af-db subdirectory identified by {\em dirname}.
If {\em update} is set to TRUE, the cross certificate pairs are added as entries 
to the PSE object CrossCSet; if that PSE object does not exist, however, it is created. \\
If the X.500 Directory is accessed and {\em attrtype} is {\em PemCertificateRevocationList}, 
the revocation list stored 
in the directory entry identified by {\em dirname} is returned. 
If the local .af-db Directory is accessed, however, the revocation list is retrieved from the
file {\em PemCrl} in the .af-db subdirectory identified by {\em dirname}.
The format of the revocation list is that defined by PEM (see RFC 1422, Appendix A). 
If {\em update} is set to TRUE, the revocation list is added as entry to the 
PSE object CrlSet; if that PSE object does not exist, however, it is created.
\end{quote}

{\bf revoke} 
\begin{quote}
This command is for CA PSEs only.
It revokes one or more certificates and enters the resulting revocation list into the 
Directory. \\
The directory may either be a X.500 directory or the local substitute provided by 
SecuDE ({\em .af-db}). (The decision whether a X.500 directory or the local substitute 
is used is done at compile time through the variable DX500 in the file CONFIG.make
at \$TOP/secude/config.) \\
The certificates which are to be revoked are identified by their serial numbers which are to be
entered interactively (see also {\em caserialnumbers} and {\em cacertificate}). 
Each serial number is submitted to the following check: \\
1. It is checked whether the given serial number is contained in the CA database in the
CA directory of the PSE-owning CA; this check is performed in order to find out whether the 
PSE-owning CA has issued a certificate with the given serial number. \\
2. It is checked whether the given serial number is already contained in the most current version
of the CA's revocation list. The CA's revocation list is retrieved from the {\em pemcrl} file
in the directory of the PSE-owning CA; its format is that specified by PEM. If there is no 
such file in the CA's directory, an empty revocation list will be created. \\
This check is performed in order to find out whether the certificate with the given serial number 
has already been revoked by the PSE-owning CA. \\
Only in case of at least one certificate having been revoked and added to the revocation list, the 
{\em lastUpdate} component of the revocation list is set to the current time, whereas the value 
of the {\em nextUpdate} component may individually be specified by the revoking CA. The extended
revocation list is written back to the {\em pemcrlwithcerts} database in the CA's directory; in addition, 
it is entered into the directory (X.500 or local substitute, respectively). 
Furthermore, the extended revocation list is added to the PSE object CrlSet in the CA's PSE.
\end{quote}

{\bf setparm} {\em algname}
\begin{quote}
Changes parameters of the given algorithm {\em algname}. See INTRO(3X) for valid algorithm names.
\end{quote}

{\bf show} {\em object/keyref}~ [DER] [KEYBITS] [ALL]
\begin{quote}
Prints {\em object} or {\em keyref} in suitable form to stdout. If the given object contains
keys, only the algorithm identifier are showed. The keyword DER can be used to additionally
show the DER-Code of the BitString of the key, while the keyword KEYBITS causes
additionally showing the two INTEGERS if RSA-keys are involved. Keyword ALL means both of them.
\end{quote}


{\bf split} for$=${\em serial},{\em issuer}~ rev$=${\em serial},{\em issuer}
\begin{quote}
Split cross certificate pair into its components ({\em forward} and {\em reverse} certificate)
and store them on PSE. The names of the PSE objects where the {\em forward} and {\em reverse} 
certificate are to be stored are asked for interactively. \\
The cross certificate pair to be split must be contained in the PSE object CrossCSet;
its components ({\em forward} and {\em reverse} certificate) are identified by their serial 
number {\em serial} and issuer {\em issuer}. At least one of the two components 
({\em forward} or {\em reverse} certificate) must be present. \\
No update is done on the PSE object CrossCSet.
\end{quote}

{\bf string2key} {\em string}~ {\em object/keyref} 
\begin{quote}
Generates a DES key from the given string and stores it in {\em object} or under {\em keyref}. The
key is generated using a one-way hash function.
\end{quote}


{\bf toc}
\begin{quote}
Show table of contents (toc). 
\end{quote}


{\bf verify} certificate$=${\em certobj}~ fcpath$=${\em fcpathobj}~ pkroot$=${\em pkrootobj}~ 
\begin{quote}
Verifies the chain Certificate -- FCPath -- PKRoot. {\em certobj}, {\em fcpathobj}, and {\em pkrootobj}
are PSE objects containing a Certificate, a FCPath, and a PKRoot, respectively. The default PSE objects
are SignCert, FCPath and PKRoot, if parameters are omitted. If only 'fcpath$=$' is given,
no FCPath is used for verification. \\
The global variable {\em af\_chk\_crl} determines whether a directory (either X.500 or .af-db, see also 
DirectoryType(5)) is to be accessed
in order to find out if any of the certificates encountered in the verification process is 
contained in the revocation list of its issuer.
The global variable {af\_search\_directory} determines whether a directory (either X.500 or .af-db, see also 
DirectoryType(5)) is to be accessed
in order to establish or complete the certification path required for the verification of {\em certobj}. 
\end{quote}

{\bf write} {\em object}~ {\em source}~ {\em type}
\begin{quote}
Read file {\em source} and write it as objectValue the given PSE object {\em object} (using
{\em sec\_write\_PSE()}). The objectType is taken from {\em type}.
Includes all PIN-handling. If the PSE object does not exist, it is created.
If {\em type} is omitted, the content of {\em source} is written to PSE object
{\em object} using {\em sec\_write()}.
\end{quote}

{\bf xdump} {\em object/keyref} 
\begin{quote}
Prints {\em object} or {\em keyref} in a suitable form to stdout.
\end{quote}

\nm{1}{sectool}{maintain your PSE}
\label{sectool}
\hl{Synopsis}
{\bf sectool} [ {\bf -tDvVWh} ] [ {\bf -p} {\em psename} ] [ {\bf -c} {\em cadir} ] [ {\bf -d} {\em dsa} ] [{\bf -A} {\em auth\_level}] \\
{\bf aliastool} [ {\bf -tDvVWh} ] [ {\bf -p} {\em psename} ] [ {\bf -c} {\em cadir} ] [ {\bf -d} {\em dsa} ] [{\bf -A} {\em auth\_level}] \\
{\bf directorytool} [ {\bf -tDvVWh} ] [ {\bf -p} {\em psename} ] [ {\bf -c} {\em cadir} ] [ {\bf -d} {\em dsa} ] [{\bf -A} {\em auth\_level}]
\addtotoc{aliastool}
\addtotoc{directorytool}

\hl{Description}
{\em sectool} is, like psemaint,  a maintenance program which can be used by both
certification authority administrators and users for the purpose
of maintaining their PSEs. This includes moving information (e.g. keys,
certificates, revocation lists etc.) from Unix files or a X.500 Directory
into the PSE and vice versa, generating keys, changing PINs, displaying
the content of the PSE, and maintaining the user's aliases. In contrast
to psemaint, which is line-oriented, sectool is an OpenWindows tool.

{\em Aliastool} is a subtool of sectool which only maintains the alias
files and AliasList PSE object.

{\em Directorytool} is a subtool of sectool which provides a comfortable
interface between X.500 Directories and SecuDE, particularly for the
exchange of security information between X.500 Directories and a PSE.

Sectool is still under development. The version included in SecuDE-4.1
is only a demonstrator version which provides a feeling how it works.
Most functions are still not implemented. SecuDE-5.0 will offer a fully
functional sectool.

\hl{Options}
\parname {{\bf -p} {\em psename}}
\pardescript {PSE {\em psename} is used instead of the default PSE {\em .pse}}. 

\parname {{\bf -c} {\em cadir}}
\pardescript {The PSE .capse contained in the CA directory {\em cadir}
 is used instead of the default PSE {\em .pse}.}

\parname {{\bf -d} {\em dsa}}
\pardescript {Object name of a certificate which contains a public RSA key. This is for Sqmodn only.}
  
\parname {{\bf -A} {\em auth\_level}}
\pardescript {Level of authentication used for X.500 Directory access
                    {\em auth\_level} may have one of the values 'SIMPLE' or 'STRONG'
                    (default: environment variable AUTHLEVEL or 'No authentication')
                    STRONG implies the use of signed DAP operations}
 

\nm{1}{secxlock}{lock the local X display using strong authentication with your PSE}
\label{secxlock}
\hl{Synopsis}
{\bf secxlock} [ {\bf -h} ] [ {\bf -p} {\em psename} ] [ {\bf -c} {\em cadir} ]

\hl{Description}
{\em secxlock}  Locks the local X display using strong authentication with your PSE.

\nm{1}{sign}{sign files / verify signatures of files}
\addtotoc{verify}
\label{sign}
\hl{Synopsis}
{\bf sign} [ {\bf -CvVWUth} ] [ {\bf -p} {\em psename} ] [ {\bf -c} {\em cadir} ] [ {\bf -k} {\em key} ] [ {\bf 
-a} {\em issueralg} ] [ {\bf -h} {\em hashinput} ]
\\ \hspace *{1cm} 
 [ {\em files} ]
\\
{\bf verify} [ {\bf -DFRvVWtUh} ] [ {\bf -p} {\em psename} ] [ {\bf -c} {\em cadir} ] [ {\bf 
-k} {\em key} ]
\\ \hspace *{1cm} 
[ {\bf -f} {\em fcpath} ] [ {\bf -d} {\em dsaname} ] [ {\bf -A} {\em authlevel} ] [ {\em files} ]
\hl{Description}
{\bf Sign} generates digital signatures of {\em files}. {\em files} is a list of filenames. For each
{\em file} from the list of files, the signature is stored in file {\em file}.sig.
as ASN.1-encoded data type Signature (as produced by e\_Signature()). If no {\em files} are specified, 
stdin is signed and 
the signature is written to stdout. 

Each signature will be produced using the PSE-object SKnew or SignSK
of the PSE indicated through {\bf -p} {\em psename} or {\bf -c} {\em cadir}.
If {\bf -c} {\em cadir} is given, the PSE .capse of a CA residing in the CA directory {\em cadir}
is selected. \\
If {\bf -p} {\em psename} is given, the PSE {\em psename} is selected. Per default the PSE {\em .pse} is 
selected.

The signature algorithm can be given with {\bf -a} {\em issueralg}. 
{\em issueralg} must be a
signature algorithm (AlgType SIG, see INTRO(3) on available algorithms) which fits to the associated 
algorithm
of the signature key (e.g. the algorithm md5WithRsa cannot be used with an ElGamal key). The *TimeDate 
algorithms
are SecuDE-defined. With these algorithms the time and date when the signature was produced is 
contained
in the signature value and can be restored during the verification.
The default for {\em issueralg} is md5WithRsaTimedate or dsaWithSHA, depending on the signature key. 

If option {\bf -C} is given, for each file the user certificate and the forward certification path related to
the corresponding verification key is written to {\em file}.ctf as ASN.1-encoded data type Certicates 
(note the plural; Certificates is the X.509 Certificates which is a SEQUENCE of the user certificate and
the forward certification path). This allows any user who shares the same public root key to verify
this digital signature. If option {\bf -C} is not given, the digital signature of the file can only be
verified by the signing user itself, using his PSE-object Cert or SignCert. This can be useful to
protect own files against manipulation with no need that others are able to validate this.

The .sig and .ctf files are created if they do not exist.
 
Option {\bf -k} {\em key} allows to specify the signature key to be used. {\em key} may
be the name of a PSE-object or a key reference. In case of option {\bf -k} {\em key} is given,
option {\bf -C} must not be used.

If the selected signature algorithm is sqmodnWithRsa, the hashinput for Sqmodn (modulus) is taken 
from the own verification key which is the public key contained in the PSE-object Cert or SignCert.
If {\bf -h} {\em hashinput} is given, the hashinput for Sqmodn is taken from {\em hashinput}
which may be the name of a PSE-object or a key reference.

Option {\bf -v} renders the sign command verbose, and options {\bf -V} and {\bf -W} provide some further
logging information. For test purposes, option {\bf -t} requests
to control the malloc/free behaviour, and option {\bf -U} requests to measure the time used for the 
cryptographic
algorithms.
\\ [1em]

{\bf Verify} verifies the digital signatures of {\em files}. For each file from the list of files, 
the signature is expected in {\em file}.sig
as ASN.1-encoded data type Signature (as produced by e\_Signature()). The signature will be verfied using 
the PSE-object Cert or SignCert
of the PSE indicated through {\bf -p} {\em psename} or {\bf -c} {\em cadir}.
If {\bf -c} {\em cadir} is given, the PSE .capse of a CA residing in the CA directory {\em cadir}
is selected. \\
If {\bf -p} {\em psename} is given, the PSE {\em psename} is selected. Per default, the PSE {\em .pse} 
is selected.

{\em verify} uses the verification procedure specified in af\_verify(3).

If option {\bf -D} is given, missing certificates will be automatically retrieved from the Directory.
The Directory may either be a X.500 directory or the local substitute provided by 
SecuDE ({\em .af-db}) (see also DirectoryType(5)).

If the X.500 Directory is accessed, parameter {\em dsaname} (option {\bf -d}) allows to specify the name of the DSA (Directory System Agent) which
will initially be contacted. {\em dsaname} is a name which must be provided in the 
{\em dsaptailor} file of the system as {\em dsa\_address} parameter. If {\bf -d} {\em dsaname} is
not given, the default DSA, which is the first {\em dsa\_address} parameter in the {\em dsaptailor} 
file, is contacted.
Parameter {\em authlevel} (option {\bf -A}) may be provided to determine the level of authentication used when binding. If {\bf -A} {\em authlevel} is omitted, the requested 
level of authentication is taken from the environment variable AUTHLEVEL, and is set to {\em no 
authentication}, if no such variable exists.
In case of simple authentication being used, the caller's distinguished name and
X.500 password are retrieved from the PSE objects Name and QuipuPWD, respectively.

If option {\bf -F} is provided, the own FCPath is considered as being trusted.
This is useful for optimizing the verification process,
if the originator of a digital signature and the PSE owner have a common point of trust
within their forward certification paths, or if the PSE owner wishes to verify signatures
generated by himself.

If option {\bf -R} is provided, a check of certificate revocation lists is required for all certificates
which are in the certification path. In case that option {\bf -D} is additionally provided, missing CRLs will
automatically be retrieved from the Directory. In addition, whenever a CRL is consulted, the 
nextUpdate field of the CRL is compared with the current time and date, and in case of nextUpdate
having expired, the actual CRL will be retrieved from the Directory.

If for a particular file from the list {\em file}.ctf exists and contains an ASN.1 encoded data object Certificates, 
user certificate and forward 
certification path for the verification process are taken from there in order to validate the signature
of {\em file}. The final trusted key for 
the verification process is taken from PSE-objects PKRoot or PKList of the specified PSE.
If the file {\em file}.ctf does not exist, the own user certificate of PSE-object Cert or SignCert and
the own forward certification path of PSE-object FCPath will be used for the verification.

Parameter {\bf -k} {\em key} and {\bf -f} {\em fcpath} allow to specify 
alternative PSE-objects being used for the verification process. This is in general only useful for
test purposes. {\em key} may be the name of a PSE-object containing either a certificate
or a key only, encoded as KeyInfo, or may be a key reference. If {\em key} denotes a key only,
no further certicate chain will be checked.

Option {\bf -v} renders the verify command verbose, and options {\bf -V} and {\bf -W} provide some
further logging information. For test purposes, option {\bf -t} requests
to control the malloc/free behaviour and option {\bf -U} requests to measure the time used for the 
cryptographic
algorithms. In case that a smartcard terminal is used, option {\bf -T} requests to perform each public key 
RSA operation in the smartcard terminal instead with software in the workstation (the latter is the 
default). 

 
\hl{Options}

\parname {{\bf -C}}
\pardescript {The file {\em file}.ctf will be generated, containing the user certificate and the 
forward certification path (as ASN.1-encoded data type Certificates) from the PSE-objects Cert/SignCert
and FCPath of the signer of a file. This parameter applies for sign only.}

\parname {{\bf -D}}
\pardescript {Missing certificates will automatically be retrieved from the Directory (X.500 or .af-db). 
This parameter applies for verify only.}

\parname {{\bf -F}}
\pardescript {Consider own FCPath as trusted. This parameter applies for verify only.}

\parname {{\bf -R}}
\pardescript {Requests that certificate revocation lists will be consulted during
the verification process. This parameter applies for verify only.}

\parname {{\bf -A} {\em authlevel}}
\pardescript {Level of authentication to be used when the X.500 Directory is accessed. 
This parameter applies for verify only.}

\parname {{\bf -d} {\em dsaname}}
\pardescript {Name of the DSA to be accessed for retrieving certificates and certificate revocation lists.}

\parname {{\bf -p} {\em psename}}
\pardescript {The PSE {\em psename} is used instead of the default PSE {\em .pse}.}

\parname {{\bf -c} {\em cadir}}
\pardescript {The PSE .capse contained in the CA directory {\em cadir}
 is used instead of the default PSE {\em .pse}.}

\parname {{\bf -a} {\em signalg}}
\pardescript {The algorithm {\em signalg} is used as signature algorithm.  This parameter applies
for sign only. md5WithRsaTimeDate is the default algorithm. {\em signalg} must be a
signature algorithm (AlgType SIG, see INTRO(3) on available algorithms) which fits to the associated 
algorithm
of the signature key (e.g. the algorithm md5WithRsa cannot be used with an ElGamal key). The *TimeDate 
algorithms
are SecuDE-defined. With these algorithms the time and date when the signature was produced is 
contained
in the signature value and can be restored during the verification.}

\parname {{\bf -h} {\em hashinput}}
\pardescript {If the signature algorithm is sqmodnWithRsa, 
{\em hashinput} denotes a public RSA key which serves as hashinput (per default the own verification 
key is being used for this purpose). If {\em hashinput} is numeric, it denotes a key reference.
Otherwise it denotes a PSE-object which may contain either a certificate or a key only, encoded as 
KeyInfo. This parameter applies for sign only.}

\parname {{\bf -k} {\em key}}
\pardescript {If {\em key} is numeric, it denotes a key reference under which the signature/verification 
key and 
corresponding algorithm identifier was previously installed. If {\em key} contains 
also non-numeric characters, it denotes the name of a PSE object which contains 
the signature/verification key and corresponding algorithm identifier. In the latter case,
the PSE-object may contain either a certificate or a key only, encoded as KeyInfo.}

\parname {{\bf -f} {\em fcpath}}
\pardescript {Name of a PSE object which contains the Forward Certification Path as ASN.1-encoded
data type FCPath (as produced by e\_FCPath()).}

\parname {{\bf -v}}
\pardescript {Makes sign and verify verbose.}

\parname {{\bf -V}}
\pardescript {Makes sign and verify Verbose.}

\parname {{\bf -t}}
\pardescript {Enables the control of the malloc/free behaviour. For tests only.}

\parname {{\bf -T}}
\pardescript {Enforces that public key RSA operations are performed in the smartcard terminal
instead with software in the workstation, which is the default. Applies only if smartcards
are used.}

\parname {{\bf -U}}
\pardescript {Enables the measurement of time used for the cryptographic algorithms. For tests only.}

\hl{See Also}
af\_sign(3), af\_verify(3)

\nm{3X}{INTRO}{Introduction to security functions}
\label{intro3}
\hl{Description}
\addtotocsmall{SecuDE Library Functions Summary}
The SecuDE library functions are grouped into five major collections which 
can be identified by the prefex of the function name (sec\_, af\_,
aux\_, pem\_ and e\_/d\_).

%\begin{figure}
\input{genstruct11}
{\footnotesize Fig.\arabic{Abb}:
General SecuDE structure}
%\end{figure}
\\ [1em]
The following modules are currently realized (Fig. 1):
\bi
\m {\bf Personal Security Environment and Cryptography (Secure)}. 
   The cryptographic functionality and the PSE functionality
   is strongly coupled in SecuDE. Keys which are being
   used by the cryptographic functions are normally addressed
   through references to PSE-objects. In the smartcard realization
   the PSE is a separated device where cryptographic functions
   are performed. The Secure module provides
   the basic cryptographic functions for the generation and 
   verification of digital signatures, and encryption and decryption 
   of data, and the basic PSE access functions. No higher level
   functionality like certificate processing is available in this module.
   Two PSE realizations are availabe in this module, one of them
   is a particular smartcard realization. Secure-IF, the interface of 
   this module, however, hides different technologies from
   the applications, i.e. Secure-IF claims to be an abstract security
   interface from the application's point of view which allows various
   PSE realizations including smartcard environments without affecting 
   the application's structure.
   The description of the {\em Smartcard Application Interface} (SCA-IF) 
   used in SecuDE is available on request.
   Particularly, the Personal Security Environment and Cryptography 
   module comprises
   \bi
   \m RSA, DSA and DES as basic cryptosystems,
   \m key generation,
   \m different message digest algorithms (SqmodN, MD2, MD4, MD5,
      SHA), 
   \m different signature and encryption algorithms (e.g. PKCS \#1),
   \m routines to access the PSE, handling (create, delete, read, write)
      of PSE objects.
   \ei
   The functions realizing this module are prefixed with sec\_.
\m {\bf Authentication Framework and Certification (AF)}. This module
   adds X.509 certification functionality to SecuDE.
   Both local (i.e. PSE-located) certificates and directory-located
   certificates can be addressed. Together with the Secure module, the
   following functionality is provided:
   \bi
   \m sign, verify, encrypt, and decrypt information using PSE-based or 
      directory-based keys, certificates, certification pathes and 
      certificate revocation lists,
   \m maintain a PSE with the objects defined in the AF 
      module, i.e. maintain certificates, crosscertificate pairs,
      the forward certification path, the public root key,
      certificate revocation lists, and lists of trusted public keys.
   \m check PSE for validity and consistency,
   \ei
   Functions for the support of the X.509 authentication framework are
   prefixed with af\_.
\m {\bf Key Management Support (KM)}. 
   This module provides functions for the ge\-ne\-ra\-tion and distribution
   of keys, certificates,
   cross-certificates, and certification pathes, provides additional
   functionality for the 
   implementation of a Certification Authority (CA), and supports the
   interaction between user and CA
   as well as between CA's.

   Key management support functions are also prefixed with af\_. 
\m {\bf Privacy Enhanced Mail Support (PEM)}. This module covers functions 
   which realize the Internet Specifications RFC 1421 - 1423. 
   The basic idea of PEM is to define document oriented message 
   encipherment and authentication procedures for the protection of 
   messages through the use of 
   end-to-end cryptography between originator and recipient with no special
   processing
   requirements imposed on the message transfer system (in contrast to
   transfer 
   protocol oriented security functionality as with X.400). This makes them
   transparent to the mail 
   transfer systems and applicable for local security services, too. 
   Particularly, this module provides the following functions:
   \bi
   \m enhance messages, i.e. create MIC-CLEAR, MIC-ONLY and
      ENCRYPTED message formats,
   \m de-enhance messages, i.e. scan MIC-CLEAR, MIC-ONLY and
      ENCRYPTED message formats, and perform the necessary
      validation steps (including CRL checks)
   \m create Certification Request, Certification Reply, CRL Storage
      Request and CRL Storage Reply message formats,
   \m scan Certification Request, Certification Reply, CRL Storage
      Request and CRL Storage Reply message formats, and perform
      appropriate actions.
   \ei
   Functions for PEM support are prefixed with pem\_.
\m {\bf ASN.1 Encoding/Decoding Functions}
   ASN.1 encoding and decoding functions are available 
   for all SecuDE information objects which are intended for external
   use (i.e. which are either stored externally, for instance in the
   PSE, or exchanged via communication protocols). 
   The encoding/decoding functions
   transform from the internal C-structures of the objects to
   corresponding (and in many cases standardized) ASN.1 codes
   and vice-versa. The encoding functions generally apply distinguished encoding 
   (DER) according to X.509 clause 8.7 in order to be able to process 
   digitally signed objects.

   ASN.1 encoding functions are prefixed with e\_, ASN.1 decoding functions 
   are prefixed with d\_.
\m {\bf Auxiliary Functions}
   A number of auxiliary functions are available for general functions,
   for instance
   \bi
   \m handling of distinguished names, algorithm identifiers, object
      identifiers and similar basic elements,
   \m UTCTime handling functions,
   \m error handling,
   \m print routines
   \m alias naming functions
   \ei
   Auxiliary functions are prefixed with aux\_.
\ei 

{\bf Keys, Algorithm Identifiers and Object Identifiers}
\addtotocsmall{Keys, Algorithm Identifiers and Object Identifiers}
\\ [1em]
All keys are processed in a type {\em KeyInfo} (see SEC(5)) which holds a 
bit representation of the 
key plus its algorithm identifier. An algorithm identifier
is a pair of object identifier (which identifies the algorithm) and 
algorithm dependant parameter set of that
algorithm. An object identifier is a structured set of nonnegative integers 
which represent a node or leaf
in a tree of objects (i.e. of algorithms in our case).
{\small
\bvtab
\4 typdef struct \{ \\
\6	AlgId     \2 *subjectAI; \\
\6      BitString \2 subjectkey; \\
\4 \} KeyInfo; \\
\evtab
}
with
{\small
\bvtab
\4 typedef struct \{ \\
\6      ObjId  \2  *objid; \3 /* object identifier */ \\
\6      char   \2  *parm;  \3 /* alg-specific parameters */ \\
\4 \} AlgId; \\
\evtab
}
{\small
\bvtab
\4 typedef struct \{ \\
\6      int           \3  oid\_nelem;     \3 /* number of integers */ \\
\6      unsigned int  \3  *oid\_elements; \3 /* array of integers  */ \\
\4 \} ObjId; \\
\evtab
}
{\small
\bvtab
\4 typedef struct \{ \\
\6      unsigned int \3   nbits;  \3 /* number of bits */ \\
\6      char         \3  *bits;   \3 /* bitstring */ \\
\4 \} BitString; \\
\evtab
}
Thus each key is linked to the algorithm to be used. The algorithm 
identifier is assigned
during key generation. 
\\ [1em]
In case of RSA keys, the BitString {\em subjectkey} consists of the DER 
code (see {\em Encoding of PSE Objects}) of the type {\em KeyBits}.
{\small
\btab
\2      typedef struct \{ \\
\3	        OctetString \2 part1; \\
\3      	OctetString \2 part2; \\
\3      	OctetString \2 part3; \\
\3      	OctetString \2 part4; \\
\2      \} KeyBits; \\
\etab
}
Part3 and part4 are unused in case of RSA keys.
Part1 and part2 contain the prime numbers $p$ and $q$ in case of secret keys, and the 
modulus $m$ and the public exponent $e$ in case of public keys. OctetString is a similar
type like BitString dealing with octets instead of bits. 
\\ [1em]
In case of DSAkeys, the BitString {\em subjectkey} consists of the DER 
code  of the type {\em KeyBits}, too.
Part1 to part4 contain $y$, $p$, $q$ and $g$ in case of secret DSA keys, and  
$x$, $p$, $q$ and $g$ in case of public DSA keys. 
\\ [1em]
Keys (i.e. {\em KeyInfo's}) are supposed to reside either in PSEs or in security boxes
which are separate devices attached to the Unix system. Both functionality can be modelled by
the sec\_* functions. If keys have to be passed or identified via
parameters of the sec\_* functions, this is normally done with the type 
{\em Key}:
{\small
\btab
\2 typedef struct \{ \\
\3      KeyInfo  \1 *key; \\
\3      KeyRef   \1  keyref; \\
\3      PSESel    \1 *pse\_sel; \\
\2 \} Key;
\etab
}
This parameter type allows either to pass the key in {\em key}, or to refer 
to a key reference
{\em keyref} in a security box (modelled in SecuDE through a per user key 
pool), 
or to refer to a PSE object via {\em pse\_sel} (see {\em PSE Objects} 
below). 
Only one of the three parts of this type must be non zero. 
\\ [1em]
{\bf Cryptographic Algorithms}
\addtotocsmall{Cryptographic Algorithms} 
\\ [1em]
In most cases algorithms are identified by algorithm identifiers, in some 
cases by names (i.e.
NULL terminated character strings being used in the pem environment). 
In addition, addresses of predefined AlgId structures
are also available as externals (through including {\em secure.h}). The 
following algorithms are available :
\bc
{\small
\begin{tabular}{|l|l|l|c|l|} \hline
{\bf Name}      & {\bf AlgId *}      &  {\bf Parameter}  & {\bf Object Identifier}    & {\bf Type}   \\ \hline
desECB          & desECB             &  --               & \{ 1 3 14 3 2 6 \}         & SYM\_ENC \\
desCBC          & desCBC             &  IV zeroes        & \{ 1 3 14 3 2 7 \}         & SYM\_ENC \\
desECB3         & desEDE             &  --               & \{ 1 3 14 3 2 17 \}        & SYM\_ENC \\
desCBC3         & desCBC3            &  IV zeroes        & \{ 1 3 36 3 1 11 \}        & SYM\_ENC \\
desCBC\_pad     & desCBC\_pad        &  IV zeroes        & \{ 1 3 36 3 1 5 \}         & SYM\_ENC \\
desCBC3\_pad    & desCBC3\_pad       &  IV zeroes        & \{ 1 3 36 3 1 13 \}        & SYM\_ENC \\
DES-ECB         & desECB             &  --               & \{ 1 3 14 3 2 6 \}         & SYM\_ENC \\
DES-CBC         & desCBC             &  IV zeroes        & \{ 1 3 14 3 2 7 \}         & SYM\_ENC \\
DES-EDE         & desEDE             &  --               & \{ 1 3 14 3 2 17 \}        & SYM\_ENC \\ rsa             & rsa                &  Keysize 512      & \{ 2 5 8 1 1 \}            & ASYM\_ENC \\
RSA             & rsaEncryption      &  --               & \{ 1 2 840 113549 1 1 1 \} & ASYM\_ENC \\
dsa             & dsa                &  --               & \{ 1 3 14 3 2 12 \}        & ASYM\_ENC \\
dsaSK           & dsaSK              &  Keysize 512      & \{ 1 3 36 3 1 20 \}        & ASYM\_ENC \\
NIST-DSA        & dsa                &  --               & \{ 1 3 14 3 2 12 \}        & ASYM\_ENC \\
sqmodn          & sqmodn             &  Blocksize 512    & \{ 2 5 8 2 1 \}            & HASH \\
md2             & md2                &  --               & \{ 1 2 840 113549 2 2 \}   & HASH \\
md4             & md4                &  --               & \{ 1 2 840 113549 2 4 \}   & HASH \\
md5             & md5                &  --               & \{ 1 2 840 113549 2 5 \}   & HASH \\
sha             & sha                &  --               & \{ 1 3 14 3 2 18 \}        & HASH \\
RSA-MD2         & md2                &  --               & \{ 1 2 840 113549 2 2 \}   & HASH \\
RSA-MD5         & md5                &  --               & \{ 1 2 840 113549 2 5 \}   & HASH \\
NIST-SHA        & sha                &  --               & \{ 1 3 14 3 2 18 \}        & HASH \\
sqmodnWithRsa   & sqmodnWithRsa      &  Keysize 512      & \{ 2 5 8 3 1 \}            & SIG \\
md2WithRsa      & md2WithRsa         &  --               & \{ 1 3 14 7 2 3 1 \}       & SIG \\
md4WithRsa      & md4WithRsa         &  --               & \{ 1 3 14 3 2 2 \}         & SIG \\
md5WithRsa      & md5WithRsa         &  --               & \{ 1 3 14 3 2 3 \}         & SIG \\
md2WithRsaEncryption & md2WithRsaEncryption &  --        & \{ 1 2 840 113549 1 1 2 \} & SIG \\
md4WithRsaEncryption & md4WithRsaEncryption &  --        & \{ 1 3 14 3 2 4 \}         & SIG \\
md5WithRsaEncryption & md5WithRsaEncryption &  --        & \{ 1 2 840 113549 1 1 4 \} & SIG \\
md2WithRsaTimeDate   & md2WithRsaTimeDate   &  --        & \{ 1, 3, 36, 3, 1, 22 \}   & SIG \\
md4WithRsaTimeDate   & md4WithRsaTimedate   &  --        & \{ 1, 3, 36, 3, 1, 24 \}   & SIG \\
md5WithRsaTimeDate   & md5WithRsaTimedate   &  --        & \{ 1, 3, 36, 3, 1, 25 \}   & SIG \\
dsaWithSHA      & dsaWithSHA         &  --               & \{ 1 3 14 3 2 13 \}        & SIG \\
\hline
\end{tabular}
}
\ec

\underline{Note:} Some algorithms appear more than once because they can be used under 
different names.
The algorithm identifier uniquely identifies the algorithm. A -- in the parameter field 
indicates an ASN.1 NULL value as parameter. Parameter values shown for algorithms
with parameters are default values. 

{\large\bf DES Algorithms:} 
 
The length of the encryption result is always a multiple of 64 bits. 
 
In case of {\bf desCBC\_pad} and {\bf desCBC3\_pad} 
algorithm, additional encoding which allows 
the decrypting routine ({\em sec\_de\-crypt}/{\em af\_decrypt}) to restore 
the plaintext length is added 
by the encryption routine ({\em sec\_encrypt}/{\em af\_encrypt}) prior to 
encryption. 
If $n$ is the plaintext length,
8 - $n$ $mod$ 8 octets are padded by the encryption routine with
the last octet of the last block containing the number of 
valid octets of that block (between 0 and 7), i.e. if the plaintext 
consists 
of a multiple of eight octets, one extra block is added with the last octet 
set to zero. 
The decryption routine expects this padding. 
 
In case of {\bf desCBC} algorithm, 
padding as defined in RFC 1423 is applied prior to encrypting
which again enables the decryption routine to restore the plaintext length:
\begin{quote}
   The input to the DES CBC encryption process shall be padded to a
   multiple of 8 octets, in the following manner.  Let n be the length
   in octets of the input.  Pad the input by appending 8-(n mod 8)
   octets to the end of the message, each having the value 8-(n mod 8),
   the number of octets being added.  In hexadecimal, the possible
   paddings are:  01, 0202, 030303, 04040404, 0505050505, 060606060606,
   07070707070707, and 0808080808080808.  All input is padded with 1 to
   8 octets to produce a multiple of 8 octets in length.  The padding
   can be removed unambiguously after decryption.
\end{quote} 
In all other cases,
zeroes are padded prior to encrypting until an eight-octet boundary is 
reached, i.e.
no octets are padded if the plaintext length is a multiple of eight octets.
Measures which allow to restore the original plaintext length must
be taken by the application in this case.
\\ [1em]
The algorithms desEDE, desCBC3 and desCBC3\_pad imply each block
to be encrypted with a double key {\em \{k1, k2\}} in the encryption-
decryption-encryption mode,
i. e. each block is encrypted with k1, afterwards decrypted with k2, and 
then encrypted with k1.
Decryption of a block is done vice versa, i. e. decryption with k1, then 
encryption with k2
and then decryption with k1.
\\ [1em]
{\large\bf RSA Algorithms:}

{\em rsa} is the RSA algorithm as defined in X.509. {\em rsaEncryption}, 
{\em md2WithRsaEncryption}
and {\em md5With\-RsaEncryption} are the algorithms defined in PKCS \#1. 
They use a specific
padding method for the RSA input value. {\em md2WithRsa}, {\em md4WithRsa} 
and {\em md5WithRsa}
are defined by OIW Stable Agreements. Here, the RSA input value is left-
padded with zeroes
prior to RSA encryption. {\em md4WithRsaEncryption} is defined by OIW, but 
uses the
PKCS padding method.

The algorithms {\em md2WithRsaTimeDate}, {\em md4WithRsaTimeDate} and {\em 
md5WithRsaTimeDate}
are SecuDE-defined. They are basicly the same as the corresponding PKCS \#1 
signature algorithms
with the following differences:
\be
\m The rsa input block is coded with BlockType 05 instead of 01.
\m The 13 octets after the BlockType contain the date and time of 
signature, encoded
   as GMT UTCTime, instead of 13 0xFF padding octets as defined in PKCS 
\#1.
\ee

Interpretation of Integer Values

The ASN.1 basic encoding rules [ISO8825] together with the X.509 defined 
DER rules
define the encoding of integer values
which is used throughout this specification. To recall from this
definition the value of an integer will be represented with the minimum
possible number of octets.  The highest significant octet comes first
followed by the next significant octet until the least significant
octet as last one. Each octet consists of 8 bits of which the high
significant bit is the first bit and the least significant bit is the
last one.

The definition of {\em subjectPublicKey} (from X.509 Authentication 
Framework) is
a BitString comprising the ASN.1 encoded type of

\bc
	SEQUENCE \{ INTEGER, INTEGER \}
\ec
\noindent
where the first part represents the modulus and the second the public 
exponent.
For example the following encoding represents the ASN.1 encoding of such a
sequence.

\btab
	\1 SEQUENCE (30) L 47 $=$ \{            \\
	\2      INTEGER (02) L 40 $=$           \\
	\3              {\tt 72430266 95995A0F BB148995 393AC2F8 }\\
	\3              {\tt 6092F33A BAEC832B 42FF0926 78C0271F }\\
	\3              {\tt D94479AD 957E5682 6EB3E228 3C1FC338 }\\
	\3              {\tt 06F1E775 32F9812D 21ABEB13 F412A851 }\\
	\2      INTEGER (02) L 03 $=$           \\
	\3              {\tt 010001    }              \\
	\1 \}
\etab
\noindent
Note: SecuDE considers the components of incoming public keys to be 
unsigned integers;
the sign of the integer will be ignored. One leading zero octet will be 
accepted, too.
Public keys produced by SecuDE will be encoded as SEQUENCE of signed 
integers, i.e.
SecuDE will produce a leading zero octet if the most significant bit of a 
component
is one.
\\ [1em]
Encryption

In order to encrypt arbitrary text the input data to encryption must be
segmented in data blocks of equal length.  The length of every data
block is determined by the $keysize$, i.e. the amount of bits to
represent the modulus $N$.  The largest number $L$ of octets containing
fewer bits than the modulus is then defined as

\begin{eqnarray*}
	L	& = & (keysize-1)/8 \\
	keysize & = & int ( log_2 (N) + 1 )
\end{eqnarray*}

Each data block is interpreted as an unsigned integer of length $L$ octets
according to the rules of ASN.1 encoding of integers, except that leading
zero octets may occur and that the value is unsigned.
The last data block, if incomplete, is padded with zero octets.
Additional data blocks of padding are not used.

The data blocks which represent the integer values 0 or 1 will be handled 
in
a special way since the regular RSA computation would not change these 
values.
In order to avoid these data in the encrypted data block the value
$2^{keysize-1}$ will be added before encryption.

The result $Y$ of encrypting one data block $X$, (after the possible 
modification for
the values 0 or 1), is computed with the public key $e$
\begin{eqnarray*}
	Y = X^e ~(mod ~N)
\end{eqnarray*}
\noindent
and gives at most $keysize$ bits. The encrypted data block is extended
with leading zero bits to build a BIT~STRING of size $keybits$. The 
contents
of the BIT~STRING represents the (unsigned) integer value of $Y$.
The result of encryption is the concatenated bitstring of all encrypted 
data
blocks.
\\ [1em]
Decryption

The decryption of arbitrary text uses data blocks of size $keysize$ bits.
These data blocks are interpreted as integer values $Y$ with the highest
significant bit first.
The result of decrypting one data block is computed with the private key 
$d$
\begin{eqnarray*}
	X = (Y^d ~(mod ~N)) ~(mod ~2^{8L})
\end{eqnarray*}
\noindent
The resulting (unsigned) integer value $X$ is transformed into an 
OCTET~STRING
of size $L$ octets with the assumption that the originating
block had this size.  This includes stripping off any increment for
possible integer values 0 or 1.  The padding which had been added by
the encryption will not be discarded.

The result of decryption is the concatenated octetstring of all decrypted
data blocks.
\\ [1em]
{\bf Signatures} 

The signatures are produced with 2 steps of processing on the input data.
The first step is to produce a hash value of the input data. The signature
itself is then produced with encrypting this hash value with the private
key. It will be assumed, that the resulting hash value corresponds to the
$keysize$ of the signature key, i.e. the hash value will be treated $mod 
~N$
the public modulus.

The length of the resulting signature will be extended to a multiple of
8 bits by prepending leading zero bits, but arbitrary lengthes of
signatures will be accepted for verification.
\\ [1em]
{\bf Verification}

In order to verify a given signature $S$ of a text, the first step is to
produce the hash value $H$ of the input data as it was described in the 
last section.
Then the signature value will be computed with the signers public key $e$ 
\begin{eqnarray*}
	V = S^e ~(mod ~N)
\end{eqnarray*}
\noindent
and compared with the hash value $H$. The verification succeeds, if
\begin{eqnarray*}
	V \equiv H ~(mod ~N).
\end{eqnarray*}
\\ [1em]
{\large\bf DSA Algorithms}

    A DSA public key is a BitString
    which contains the ASN.1 DER code of
    \bvtab
    \4  SEQUENCE \{ \\
    \4  \2       key INTEGER, - - y (public key)   \\
    \4  \2       params DSAParameters OPTIONAL  \\
    \4  \} \\
    \evtab
    with
    \bvtab
    DSAParameters ::= SEQUENCE \{ \\
    \4  \2       prime1 [0] INTEGER, - - p \\
    \4  \2       prime2 [1] INTEGER, - - q \\
    \4  \2       base [2] INTEGER, - - g \\
    \4  \} \\
    \evtab
    
    A DSA secret key is a BitString
    which contains the ASN.1 DER code of
    \bvtab
    \4  SEQUENCE \{ \\
    \4  \2       key INTEGER, - - x (secret key)   \\
    \4  \2       params DSAParameters OPTIONAL  \\
    \4  \} \\
    \evtab
    with
    \bvtab
    DSAParameters ::= SEQUENCE \{ \\
    \4  \2       prime1 [0] INTEGER, - - p \\
    \4  \2       prime2 [1] INTEGER, - - q \\
    \4  \2       base [2] INTEGER, - - g \\
    \4  \} \\
    \evtab


{\bf Square-mod-N}

\noindent
The input data is segmented into data blocks of equal length~~$L$
\begin{eqnarray*}
	 L	& = & (keysize-1)/16 \\
	keysize & = & int(log_2(N)+1)
\end{eqnarray*}
\noindent
Each octet of a data block is split into 2 sedecimal digits comprising
the original octet. Each sedecimal digit is prepended with the sedecimal 
digit
$0xF$ and gives one octet for the hash block $B$. The length of the hash 
block
is then $2L$.
The possible free bits remaining in the hash block - up to keysize - are 
left zero.
The last block, if incomplete, will be padded with binary ones.
The so produced integer value is added to the last hash result $H_i$
and then squared ($mod ~N$) giving a new hash result, the starting value
for the first block is assumed to be zero.
\begin{eqnarray*}
	H_0 & = & 0	\\
	H_i & = & (( H_{i-1} \oplus B_i )^2) ~(mod ~N), i = 1, \ldots
\end{eqnarray*}
The add operation $\oplus$ represents the boolean function exclusive or.
\\ [1em]
{\bf PSE Objects}
\addtotocsmall{PSE Objects} 
\\ [1em]
Some of the structures handled as parameters of the security functions (e. 
g. keys and certificates)
are supposed to reside in the Personal Security Environment (PSE), e.g. in 
smartcards.

PSE objects are handled at the parameter interface of the sec\_* functions 
by means of the type
{\em PSESel} (PSE selector):
{\small
\btab
\2 typedef struct \{ \\
\3      char  \1  *app\_name; \\
\3      char  \1  *pin;      \\
\3      struct \{            \\
\4         char *name;       \\
\4         char *pin;        \\
\3      \}    \1 object;     \\
\3      int    \1  dev;      \\
\3      int    \1  app\_id;   \\
\2 \} PSESel;
\etab
}
This structure allows to identify a PSE object by an application name (e.g. 
in the
case of multifunctional smartcards) and an object name. In case of the SW-
PSE, the
application name is the name of the directory which comprises the PSE (see 
below).

In addition, this structure allows to provide a PIN (Personal Identification 
Number)
both as global PIN for the whole application (or PSE) or as object-specific 
PIN.
In case of the SW-PSE, this PIN is a password which is hashed into a DES 
key. If no
PIN is given when requesting the access to a PSE object, and the requested 
object
is PIN-protected, the PIN will be asked from /dev/tty (in case of the SW-
PSE) or
at the auxiliary device (depending on the smartcard environment). If 
specific
smartcard environments are implemented, the passing of PIN's via sec\_* 
parameters
may be impossible.

PSE objects known by the sec\_* functions are {\em 
KeyInfo} which holds a key
plus algorithm identifier, and {\em PSEToc} which holds the table of 
contents of the
PSE. For more information see SEC-PSE-OBJECTS(4).

PSE objects known by the af\_* functions are, for instance, {\em Certificate} 
which holds an X.509 certificate,
{\em FCPath} which holds a forward certification path (in the sense of 
X.509), {\em PKRoot} which
holds the root verification key (i. e. the public key of the highest 
certification authority),
and {\em PKList} which holds a chained list of public keys. For more 
information see
AF-PSE-OBJECTS(4). \\ [1em] 
{\bf Software Realization of the PSE (SW-PSE)} \\ [1em]
The model of the software realization of the PSE was developed under the 
assumption that
it is necessary to store all security relevant and personal information in 
a multi-user
environment in standard 
background storage media which belong to the file system of the 
corresponding
operating system and which are principally accessible by everyone who
has access to the system. Only the standard access control mechanisms 
provided by the operating system are assumed to be available. But even if 
the
operating system is ``secure'', security problems remain, eg. the problem
of privileged people (system administrators, maintenance) who in general 
have
access to all data. Therefore the only possibility is to use encryption 
techniques
with keys which exist in the mind of the user only, but which do not exist 
in
the system for longer time.

A software PSE is a Unix directory (not to be confused with an X.500 
directory).
It is not necessary to take the multifunctionality of a smartcard into 
consideration.
Each application has its own directory. The name of the directory is the 
name of the
application (e.g. {\em .pse}). If the name of the application does not 
begin with a slash,
the PSE is located in the HOME directory of the user, otherwise the name is 
considered 
as the fully qualified pathname of the PSE.

A file name within the PSE with the suffix {\em .sf} indicates that the
content of the file is encrypted in the following way:
\be
\m A PIN or password which is entered by the user via the keyboard is 
mapped onto a 
   DES key by means of a one-way function (the terms PIN and password are 
used 
   synonymously in this context).
\m The content of {\em object} is stored in the file {\em object}.sf in 
DES-encrypted 
   form using this key (.sf stands for {\em secret file}). This is also 
called ``PIN-encrypted''
   or ``PIN-protected'' in the following.
\m The PIN itself is DES-encrypted with this key, too, and stored either in 
the file {\em object}.pw, 
   if the PIN is object specific, or in the file pse.pw, if the PIN is the 
one for the whole PSE
   (.pw stands for {\em password}).
\m Before reading {\em object} one can recognize PIN-protection by the 
suffix {\em .sf}, verify
   the correctness of the PIN entered by the user through hashing and 
encrypting this PIN and 
   comparing the result with the content of the file {\em object}.pw or 
pse.pw resp., and decrypt the file
   {\em object}.sf afterwards.
\ee
The software realization of the PSE consists of: 
\bi
\m The PSE PIN (optional). \\
   This is the PIN which is valid for the whole PSE. It is stored
   in encrypted form in the file {\em pse.pw}, if it exists, otherwise
   the file {\em pse.pw} does not exist.
\m The table of contents (Toc). \\
   If {\em pse.pw} exists,
   the Toc is contained in encrypted form in the file {\em Toc.sf}, 
   otherwise it is contained in clear in the file {\em Toc}.
\m The PSE owner's name. \\
   If {\em pse.pw} exists,
   the owner's name is contained in encrypted form in the file {\em 
Name.sf}, 
   otherwise it is contained in clear in the file {\em Name}.
\m An arbitrary number of files containing the data objects and optionally 
their 
   object-specific PINs (in encrypted form). 
   Each data object is stored in one file. If the name of the file is {\em 
object} 
   with no {\em .sf} suffix, the object is not PIN protected and stored in 
clear 
   in this file. If the name of the file is {\em object.sf}, the object is 
   PIN-protected and stored in encrypted form in this file.
   If, in this case, a file {\em object.pw} exists, it contains the 
corresponding PIN.
   Otherwise, i.e. if the name of the object
   file has the suffix {\em .sf}, but no corresponding {\em .pw} file 
exists, the data object
   is encrypted with the PSE-PIN. 
\ei
The internal structure and bit representation of the data objects is 
application dependent. 
However, in order to achieve a system independant bit representation, 
predefined PSE objects 
which are necessary when using SEC- and AF-functions are encoded by 
applying
the {\em Basic Enoding Rules for ASN.1} (BER) with X.509 DER restrictions 
to the ASN.1 definitions 
of those objects. This is called DER-code in the following. In addition,
corresponding C-structures are defined for these objects. For each PSE 
object both encoding 
and decoding functions exist which perform
the mapping between the program-internal C-structure and the corresponding 
DER-code and vice versa.
See in E\_SEC(3X) and E\_AF(3X) for the available encoding and decoding 
functions and AF-PSE-Objects(4)
and SEC-PSE-Objects(4) for the corresponding ASN.1-structures and C-
structures. The mechanism
of DER-encoding is used for other purposes, too, e.g. to produce exchange 
formates for communication
protocols (see E\_X400(3X)).

The internal structure and bit representation of the Toc is described in 
SEC-PSE-OBJECTS(4). 
The internal structure and bit representation of the owner's name (Name) 
and other
PSE objects for the use of the AF-functions are described in AF-PSE-
OBJECTS(4).
\\ [1em]
This is a pretty simple model which largely prevents the user from being 
eavesdropped by
others. It does not prevent modifications of the user's PSE by unauthorized
persons, but it provides means to the user to recognize such modifications, 
and to check
the consistancy of his PSE. There is no way, however, to restore a 
forgotten PIN from
the stored PSE data.
\\ [1em]
Example of a software PSE ({\em object1} without PIN-protection, 
{\em object2} object-PIN protected, {\em object3} PSE-PIN protected): 
\\[1em]
{\small
\parbox[t]{4cm}{
{\bf Filename}
}
\parbox[t]{10.8cm}{
{\bf Content}
} \\
\parbox[t]{4cm}{
pse.pw
}
\parbox[t]{10.8cm}{
Encrypted PSE-PIN (of the entire PSE).
} \\
\parbox[t]{4cm}{
Toc.sf
}
\parbox[t]{10.8cm}{
Table of Contents of the PSE, PIN-protected (PSE-PIN).
} \\
\parbox[t]{4cm}{
Name.sf
}
\parbox[t]{10.8cm}{
PSE owner's name, PIN-protected (PSE-PIN).
} \\
\parbox[t]{4cm}{
{\em object1}
}
\parbox[t]{10.8cm}{
Object 1, application-specific, without PIN-protection.
} \\
\parbox[t]{4cm}{
{\em object2}.sf
}
\parbox[t]{10.8cm}{
Object 2, application-specific, PIN-protected (object-PIN).
} \\
\parbox[t]{4cm}{
{\em object2}.pw
}
\parbox[t]{10.8cm}{
Encrypted PIN for {\em object2}.
} \\
\parbox[t]{4cm}{
{\em object3}
}
\parbox[t]{10.8cm}{
Object 3, application-specific, PIN-protected (PSE-PIN).
}
} \\ [1em]
In addition to the PSE, a key pool is provided where keys (which means the 
ASN.1 DER code
of KeyInfo) can be stored and restored by means of key references. 
Technically, the key pool is also a
PSE with the only difference that it has the fixed name .key\_pool in the 
home directory of the user and that a user-specific encryption key is used 
which is compiled into the
software. 
\\ [1em]
{\bf Distinguished Names} 
\\ [1em]
See INTRO(1) for a detailled explanation of distinguished names and
the two representations of them handled by SecuDE.
The functions aux\_Name2DName() and aux\_DName2Name do the mapping
between these two distinguished name representations.
\\ [1em]
{\bf Functions for the support of Internet Privacy Enhanced Mail (PEM)} 
\\ [1em]
The basic idea of {\em PEM} is to define security services
for the protection of texts
which are document oriented (in contrast to transfer protocol oriented)
in that they are transparent to the mail transfer systems.
In summary, an outbound message is subjected to the following
composition of transformations:

\begin{displaymath}
Transmit\_Form=Encode(Encrypt(Canonicalize(Local\_Form)))
\end{displaymath}

``Encrypt'' means cryptographic encryption.
``Encode'' means the printable representation of an arbitrary octet string
(also referred to as ``zoning'').
An encapsulated header portion of so called ``encapsulated header fields''
is added to the transformed text.
It contains encryption and signature control fields inserted in plaintext.
The supported encapsulated header fields are
Proc-Type, DEK-Info, Originator-ID-Asymmetric,
Originator-Certificate, Issuer-Certificate, MIC-Info,
Recipient-ID-Asymmetric, Key-Info (see {\em RFC 1423: 4.6 Summary of
Encapsulated Header Fields}).

A C-language structure called {\em PemInfo}
contains the encryption and signature control informations
and is utilized by the {\em pem\_*} interface functions
in order to process a message text.

{\small
\bvtab
typedef struct \{ \\
\1   Boolean     \4  confidential;\3 /* TRUE iff PEM shall be encrypted */ 
\\
\1   Boolean     \4  clear;       \3 /* TRUE iff PEM shall be not encoded 
*/ \\
\1   Key         \4 *encryptKEY;  \3 /* plain DES-key */ \\
\1   Certificates\4 *origcert;    \3 /* originator certificates */ \\
\1   AlgId       \4 *signAI;      \3 /* signature algorithm id */ \\
\1   RecpList    \4 *recplist;    \3  /* list of recipients' informations 
*/ \\
  \} PemInfo; \\ \\

typedef struct \{ \\
\1   KeyInfo     \4 *key;         \3 /* in PemInfo:encryptKEY: plain DES-
key */ \\
\1   KeyRef      \4  keyref;      \3 /* in PemInfo:encryptKEY: unused */ \\
\1   PSESel      \4 *pse\_sel;    \3 /* in PemInfo:encryptKEY: unused */ \\
  \} Key; \\ \\

typedef struct \{  \\
\1   AlgId       \4 *subjectAI;   \3 /* in PemInfo:encryptKEY: plain DES-IV 
*/ \\
\1   BitString   \4 subjectkey;  \3 /* in PemInfo:encryptKEY: plain DES-key 
*/ \\
   \} KeyInfo; \\ \\

typedef struct reclist \{ \\
\1   Certificate \4 *recpcert;    \3 /* recipient's user certificate */ \\
\1   OctetString \4 *key;         \3 /* RSA-encrypted DES-key */ \\
\1   struct reclist \4 *next;     \3 /* RSA-encrypted DES-key */ \\
   \} RecpList;
\etab
}
The {\em pem\_create} functions map
a plain user text and a related {\em PemInfo} onto
a privacy enhanced mail text.
Inversely, the {\em pem\_scan} functions map
a privacy enhanced mail text onto
a plain user text and a related {\em PemInfo}
and verifies the message integrity.
\\ [1em]
{\bf Include Files}
\\ [1em]
All include files which are indicated in the following subroutine 
descriptions can be found
in the directory \$TOP/secude/src/include, where \$TOP is installation-
dependant, e.g. \$TOP=/usr/local.
Application programs which use SecuDE subroutines should be compiled 
therefore with
option -I\$TOP/secude/src/include.
\\ [1em]
{\bf Binding Application Programs}
\addtotocsmall{Binding Application Programs}
\\ [1em]
The SecuDE library is \$TOP/secude/lib/libsecude.a. 
In addition, SecuDE provides the library \$TOP/secude/lib/libisode.a which 
contains a collection
of necessary ISODE subroutine objects. 
When binding application programs with SecuDE subroutines one should use 
therefore options
-L\$TOP/secude/lib -lsecude -lisode.  
 
At sites which have a full ISODE installation, the original libisode.a can 
be used 
instead of \$TOP/secude/lib/libisode.a when binding application programs.

\hl{Errors}
\addtotoc{Errors}
In case of an error ({\em Return Value} -1, if return parameter type  RC, 
or NULL pointer else),
the error cause is indicated in the global variable {\em err\_stack} (data 
type ErrStack).
\bvtab
\4 extern struct ErrStack \{                 \\
\5        int             \3 e\_number;      \\
\5        char            \3 *e\_text;       \\
\5        char            \3 *e\_addr;       \\
\5        Struct\_No      \3  e\_addrtype;   \\
\5        char	          \3 *e\_proc;       \\
\5        struct ErrStack \3 *next;	     \\
\4 \} *err\_stack;
\evtab
err\_stack is a pointer to a chained list of errors which represents a 
trace of all errors
which occured inside the called routine. The first element in the list is 
th most recent error.
err\_stack can be printed using {\em aux\_fprint\_error()} and freed using 
{\em aux\_free\_error()}
(see aux\_error(3)). 
 
{\em err\_stack}\pf e\_proc is the name of the routine where the error 
occured. 
 
If {\em err\_stack}\pf e\_addr is not NULL, it contains the address of a 
structure which caused
the error, for instance the address of a Certificate which could not be 
verified. 
{\em err\_stack}\pf e\_addrtype is of type Struc\_No and indicates the type 
of the address. 
 
{\em err\_stack}\pf e\_text contains an additional explanatory text 
description of the error situation.
\\ [1em]
{\em err\_stack}\pf e\_number can have the following values: \\ [1em]
\firstbox  {1 EALGID}
\secondbox  {Invalid Algorithm Identifier} \\
\firstbox  {2 EAPP}
\secondbox  {Cannot select application} \\
\firstbox  {3 EAPPNAME}
\secondbox  {Application name does not exist} \\
\firstbox  {4 ECREATEAPP}
\secondbox  {Cannot create application (e.g. application name already 
exists)} \\
\firstbox  {5 EOBJ}
\secondbox  {Cannot select object} \\
\firstbox  {6 EOBJNAME}
\secondbox  {Object does not exist} \\
\firstbox  {7 ECREATEOBJ}
\secondbox  {Cannot create object (e.g. object already exists)} \\
\firstbox  {8 EPIN}
\secondbox  {Invalid PIN} \\
\firstbox  {9 EVERIFICATION}
\secondbox  {Verification unsuccessful} \\
\firstbox  {10 ESYSTEM}
\secondbox  {System call failed inside routine} \\
\firstbox  {11 EINVALID}
\secondbox  {Invalid argument} \\
\firstbox  {12 EDAMAGE}
\secondbox  {Toc of PSE not readable or PSE inconsistent} \\
\firstbox  {13 EMALLOC}
\secondbox  {Unable to allocate new memory} \\
\firstbox  {14 EDECRYPT}
\secondbox  {Wrong state of sec\_decrypt} \\
\firstbox  {15 EENCRYPT}
\secondbox  {Wrong state of sec\_encrypt} \\
\firstbox  {16 EHASH}
\secondbox  {Wrong state of sec\_hash} \\
\firstbox  {17 EENCODE}
\secondbox  {ASN.1-encoding error} \\
\firstbox  {18 EDECODE}
\secondbox  {ASN.1-decoding error} \\
\firstbox  {19 ESIGN}
\secondbox  {Wrong state of sec\_sign} \\
\firstbox  {20 EVERIFY}
\secondbox  {Wrong state of sec\_verify} \\ 
\firstbox  {100 EOPEN}
\secondbox  {PSE is already open} \\
\firstbox  {101 EVALIDITY}
\secondbox  {Invalid validity date of certificate} \\
\firstbox  {102 EPK}
\secondbox  {PK already exists in PKList} \\
\firstbox  {103 ENAME}
\secondbox  {Name already exists in PKList} \\
\firstbox  {104 ENOPK}
\secondbox  {PK not found in PKList} \\
\firstbox  {105 ENONAME}
\secondbox  {Name not found in PKList} \\
\firstbox  {106 EROOTKEY}
\secondbox  {Highest verification key not available} \\
\firstbox  {107 ENODIR}
\secondbox  {Directory service does not respond} \\
\firstbox  {108 ENAMEDIR}
\secondbox  {No object assigned to this name found in directory} \\
\firstbox  {109 EASCDIR}
\secondbox  {Directory access rights not sufficient for requested 
operation} \\
\firstbox  {110 EATTRDIR}
\secondbox  {No directory entry of requested attribute type found in 
directory} \\
\firstbox {201 ESPACE}
\secondbox {Malloc cannot allocate space} \\
\firstbox {202 EPOINTER}
\secondbox {A pointer wasn't allocated by calling function} \\
\firstbox {203 EINTEGER}
\secondbox {Unexpected integer value} \\
\firstbox {204 ERETURN}
\secondbox {Unexpected return value of a called function} \\
\firstbox {205 EMSGBUF}
\secondbox {Syntax Error of msgbuf} \\
\firstbox {206 EMIC}
\secondbox {Verification of MIC unsuccessful} \\
\firstbox {207 ECTFOWNER}
\secondbox {Certificate owner is not signer of PEM text} \\
\firstbox {208 EMYNAME}
\secondbox {``my name'' missing in list of Recipient-IDs} \\
\firstbox {209 EENCRMIC}
\secondbox {MIC couldn't be encrypted} \\
\firstbox {210 EENCRBODY}
\secondbox {PEM body couldn't be encrypted} \\
\firstbox {211 EDECRMIC}
\secondbox {MIC couldn't be decrypted} \\
\firstbox {212 EDECRBODY}
\secondbox {PEM body couldn't be decrypted} \\
\firstbox {213 EPEMBOUND}
\secondbox {PEM encapsulation boundary lines inconsistent} \\
\firstbox  {401 ELABEL}
\secondbox  {Security label inconsistent or invalid} \\
\firstbox  {402 EPOLICY}
\secondbox  {Unknown security policy} \\
\firstbox  {403 ENOTOKEN}
\secondbox  {According to message security label
	       no message token required;
	       or message sequence number missing on input} \\
\firstbox  {404 ERECIPNAME}
\secondbox  {Recipient name missing or invalid} \\
\firstbox  {405 ERECIPKEY}
\secondbox  {Recipient public key not available} \\
\firstbox  {406 ESECCONTEXT}
\secondbox  {Unacceptable security context} \\
\firstbox  {407 EMAC}
\secondbox  {Message authentication check (verification) failed} \\
\firstbox  {408 ETOKENCRYPT}
\secondbox  {Cannot decrypt (message or bind) token} \\
\firstbox  {409 ETOKSIGN}
\secondbox  {(Message or bind) token verification failed} \\
\firstbox  {410 ETOKRANDOM}
\secondbox  {Unacceptable random number in bind token} \\
\firstbox  {411 ETOKTIME}
\secondbox  {Unacceptable (message or bind) token time} \\
\firstbox  {412 ECREDCERT}
\secondbox  {Credential certificates failure} \\
\firstbox  {413 ECREDKEY}
\secondbox  {Unverifiable partner public key in
	       bind token of credentials} \\

\hl{Flaws and anticipated changes}
A certain amount of control over the security operations of the SecuDE
functions is done via global variables. This is not very well structured
and bears a risk of unexpected behaviour. The next version of SecuDE
will introduce the concept of a  ``security context'' which will have 
to be established prior to security operations and which will have to be passed
to the security functions as parameter. This will be a considerable change
to most of the API.

The error handling of SecuDE is sometimes not satifying. Error messages and codes
are sometimes nothing saying or misleading. Expect to find a major reshuffle
of error codes and error messages for the next version.

\nm{3X}{af\_cadb\_add\_Certificate}{Add Certificate to CA Database}
\label{af_cadb_add_Certificate}
\hl{Synopsis}
\#include $<$af.h$>$

RC {\bf af\_cadb\_add\_Certificate} {\em (keytype, newcert, cadir)} \\
KeyType     {\em keytype}; \\
Certificate {\em *newcert}; \\
char	    {\em *cadir};
\hl{Parameter}
\parname  {{\em keytype}}
\pardescript  {Type of the certificate: \\
                    SIGNATURE: user certificate of the signature key \\
                    ENCRYPTION: user certificate of the encryption key} 

\parname  {{\em newcert}}
\pardescript  {Certificate which is to be inserted into the CA database}

\parname  {{\em cadir}}
\pardescript  {Name of the CA directory, where the CA database resides} 

\parname  {{\em Return Value}}
\pardescript  {0 or -1}
\hl{Description}
af\_cadb\_add\_Certificate inserts the certificate identified by {\em newcert} into the 
calling CA's database which resides in the CA directory {\em cadir}. 

The certificate identified by {\em newcert} is first inserted into the CA's {\em cert} database;
the key under which the certificate is placed is derived from the certificate's serial number.

It is then added to the set of certificates placed in the CA's {\em user} database under the key
which is derived from the name of the certificate owner.

A zero return indicates no error.
A -1 return indicates an error.



\subsubsection{af\_cadb\_get\_Certificate}
\nm{3X}{af\_cadb\_add\_PemCrlWithCerts}{Add Revocation List to CA Database}
\label{af_cadb_add_PemCrlWithCerts}
\hl{Synopsis}
\#include $<$af.h$>$

RC {\bf af\_cadb\_add\_PemCrlWithCerts} {\em (pemcrlwithcerts, cadir)} \\
PemCrlWithCerts	{\em *pemcrlwithcerts}; \\
char		{\em *cadir};
\hl{Parameter}
\parname  {{\em pemcrlwithcerts}}
\pardescript  {Revocation list with accompanying originator certificate} 

\parname  {{\em cadir}}
\pardescript  {Name of the CA directory, where the CA database resides}

\parname  {{\em Return Value}}
\pardescript  {0 or -1}
\hl{Description}
af\_cadb\_add\_PemCrlWithCerts inserts the revocation list with accompanying originator certificate
(identified by {\em pemcrlwithcerts}) into the calling CA's {\em pemcrl} database. 

The key under which the revocation list and accompanying originator certificate are placed is derived 
from the name of the issuer of the revocation list.

af\_cadb\_add\_PemCrlWithCerts replaces an existing entry if it has the same key.

This routine supports the CRL-storage request mechanism defined by PEM (RFC 1424).

A  zero return indicates no error.
A -1 return indicates an error.




\subsubsection{af\_cadb\_list\_PemCrlWithCerts}
\nm{3X}{af\_cadb\_add\_user}{Add User to CA Database}
\label{af_cadb_add_user}

\hl{Synopsis}

\#include $<$af.h$>$

RC {\bf af\_cadb\_add\_user} {\em (name, cadir)} \\
Name {\em *name}; \\
char {\em *cadir};
\hl{Parameter}
\parname  {{\em name}}
\pardescript  {Name of the user who is to be stored in the CA database} 

\parname  {{\em cadir}}
\pardescript  {Name of the CA directory, where the CA database resides}

\parname  {{\em Return Value}}
\pardescript  {0 or -1}
\hl{Description}
af\_cadb\_add\_user inserts the name {\em name} as new entry into the calling CA's {\em user} 
database which resides in the CA directory {\em cadir}.

A  zero return indicates no error.
A -1 return indicates an error.



\subsubsection{af\_cadb\_get\_user}
\nm{3X}{af\_cadb\_get\_Certificate}{Get Certificate from CA Database}
\label{af_cadb_get_Certificate}
\hl{Synopsis}
\#include $<$af.h$>$

Certificate *{\bf af\_cadb\_get\_Certificate} {\em (serial, cadir)} \\
int  {\em serial}; \\
char {\em *cadir};
\hl{Parameter}
\parname  {{\em serial}}
\pardescript  {Serial number of requested certificate} 

\parname  {{\em cadir}}
\pardescript  {Name of the CA directory, where the CA database resides}

\parname  {{\em Return Value}}
\pardescript  {Address of a Certificate or NULL pointer}
\hl{Description}
af\_cadb\_get\_Certificate accesses the calling CA's {\em cert} database and returns the address of 
the certificate identified by serial number {\em serial}. 

A NULL pointer return indicates
\bi
\m that the requested certificate is not found in the CA's {\em cert} database.
\m an error.
\ei



\subsubsection{af\_cadb\_list\_user}
\nm{3X}{af\_cadb\_get\_PemCrlWithCerts}{Get Revocation List from CA Database}
\label{af_cadb_get_PemCrlWithCerts}
\hl{Synopsis}
\#include $<$af.h$>$

PemCrlWithCerts *{\bf af\_cadb\_get\_PemCrlWithCerts} {\em (name, cadir)} \\
Name	{\em *name}; \\
char	{\em *cadir};
\hl{Parameter}
\parname  {{\em name}}
\pardescript  {Name of the issuer of a required revocation list} 

\parname  {{\em cadir}}
\pardescript  {Name of the CA directory, where the CA database resides}

\parname  {{\em Return Value}}
\pardescript  {Address of a Revocation List or NULL pointer.}
\hl{Description}
af\_cadb\_get\_PemCrlWithCerts accesses the calling CA's {\em pemcrl} database and returns the 
address of the revocation list issued by the CA with name {\em name}. The requested revocation list
is accompanied by its issuer's originator certificate.

This routine supports the CRL-retrieval reply mechanism defined by PEM (RFC 1424).

A NULL pointer return indicates
\bi
\m that the requested revocation list is not found in the CA's {\em pemcrl} database.
\m an error.
\ei


\subsection{ASN.1 Encoding and Decoding Functions}
\nm{3X}{af\_cadb\_get\_user}{Get all Certificates issued to a User}
\label{af_cadb_get_user}
\hl{Synopsis}
\#include $<$af.h$>$

SET\_OF\_IssuedCertificate *{\bf af\_cadb\_get\_user} {\em (name, cadir)} \\
Name {\em *name}; \\
char {\em *cadir};
\hl{Parameter}
\parname  {{\em name}}
\pardescript  {Name of the user whose certificates are requested} 

\parname  {{\em cadir}}
\pardescript  {Name of the CA directory, where the CA database resides}

\parname  {{\em Return Value}}
\pardescript  {Address of a Set of Issued Certificates or NULL pointer}
\hl{Description}
af\_cadb\_get\_user returns the address of a set whose elements represent the certificates 
which have been issued to the user identified by {\em name}. Each member of the set identifies
a certificate by its serial number and indicates the certificate's date of issue.

A NULL pointer return indicates
\bi
\m that there is no entry with key {\em name} stored in the CA's {\em user} database.
\m an error.
\ei



\subsubsection{af\_cadb\_add\_Certificate}
\nm{3X}{af\_cadb\_list\_PemCrlWithCerts}{Get all Revocation Lists from CA Database}
\label{af_cadb_list_PemCrlWithCerts}
\hl{Synopsis}
\#include $<$af.h$>$

SET\_OF\_PemCrlWithCerts *{\bf af\_cadb\_list\_PemCrlWithCerts} {\em (cadir)} \\
char	{\em *cadir};
\hl{Parameter}
\parname  {{\em cadir}}
\pardescript  {Name of the CA directory, where the CA database resides} 

\parname  {{\em Return Value}}
\pardescript  {Address of a Set of Revocation Lists or NULL pointer.}
\hl{Description}
af\_cadb\_list\_PemCrlWithCerts traverses the calling CA's {\em pemcrl} database and returns all data
stored there. Each datum represents the revocation list of a known CA and is accompanied by
the originator certificate of that CA.

This routine supports the CRL-retrieval reply mechanism defined by PEM (RFC 1424).

A NULL pointer return indicates
\bi
\m that the CA's {\em pemcrl} database is empty.
\m an error.
\ei




\subsubsection{af\_cadb\_get\_PemCrlWithCerts}
\nm{3X}{af\_cadb\_list\_user}{Get Names of all Certified Users}
\label{af_cadb_list_user}
\hl{Synopsis}
\#include $<$af.h$>$

SET\_OF\_Name *{\bf af\_cadb\_list\_user} {\em (cadir)} \\
char {\em *cadir};
\hl{Parameter}
\parname  {{\em cadir}}
\pardescript  {Name of the CA directory, where the CA database resides} 

\parname  {{\em Return Value}}
\pardescript  {Address of a Set of Names or NULL pointer}
\hl{Description}
af\_cadb\_list\_user traverses the calling CA's {\em user} database and returns all keys
stored there. Each key represents the name of a user who has been certified by the
calling CA.

A NULL pointer return indicates
\bi
\m that the CA's {\em user} database is empty.
\m an error.
\ei




\subsubsection{af\_cadb\_add\_PemCrlWithCerts}
\nm{3X}{af\_create\_Certificate}{Create a prototype certificate from the
public key info.}
\label{af_make_certificate}
\hl{Synopsis}
\#include $<$af.h$>$

Certificate *{\bf af\_create\_Certificate}{\em (keyinfo, sig\_alg, obj\_name, subject)} \\
KeyInfo *{\em keyinfo}; \\
AlgId *{\em sig\_alg}; \\
char *{\em obj\_name}; \\
DName {\em *subject};
\hl{Parameter}
\parname{{\em keyinfo}}
\pardescript{ the public key info.}

\parname{{\em sig\_alg}}
\pardescript{ signature algorithm }

\parname{{\em obj\_name}}
\pardescript{ name of PSE object where secret signature key resides }

\parname{{\em subject}}
\pardescript{ the intended owner of the certificate }

\parname{{\em Return Value}}
\pardescript{ the pseudo certificate or NULL.}
\hl{Description}
{\em af\_create\_Certificate} builds a prototype certificate around the
public key identified by {\em keyinfo}. A prototype certificate is a self-signed
certificate of the own public (signature or encryption) key. The 
prototype certificate can be sent to a certification authority, which may check
or exchange some of the data (e.g. the signature algorithm, serialnumber or the validity time frame)
and replace the signature by its own signature, in order to produce a real certificate.
\\ [1em]
The version is set to the default. The serialnumber is set to $0$.
The subject name is taken from parameter {\em subject}. If parameter {\em subject} is NULL, however, it is 
retrieved from PSE object {\em Name}. The issuer name is set to the subject name.
The signature algorithm identifier is set to the
own signature algorithm; however, if the own signature 
key is of type {\em ASYM\_ENC}, the algorithm name associated with the certificate's signature is derived
from parameter {\em sig\_alg}. The validity is set to the interval
from now on for one year. Finally, the signature will be created
with the secret key which resides in the PSE object specified by parameter {\em obj\_name}.
The creation of a prototype certificate according to this procedure enables a
certification authority to verify the prototype certificate with
the public key in {\em subjectPK}, i.e. to check whether the public
key is part of an RSA key pair and the secret key is in the hand of the
creator of the prototype certificate (this is a rather weak proof
which does not prevent intelligent attacks but which may help to prevent
unintentional key mismanagement).
\\ [1em]
The return value contains the pointer to the created prototype certificate or
the NULL pointer in case of errors.
\\ [1em]
All necessary memory of the return value is provided by the called function.
The memory of the returned {\em certificate} my be released with 
{\em aux\_free\_Certificate()}.


\subsubsection{af\_get\_EncryptedKey}
\nm{3X}{af\_decrypt}{Decrypt bitstring using AF PSE objects}
\label{af_decrypt}
\hl{Synopsis}
\#include $<$af.h$>$

RC {\bf af\_decrypt} {\em (in\_bits, out\_octets, more, key)} \\
BitString *{\em in\_bits}; \\
OctetString *{\em out\_octets}; \\
More {\em more}; \\
Key *{\em key};
\hl{Parameter}
\parname  {{\em in\_bits}}
\pardescript  {BitString of the data to be decrypted.}

\parname  {{\em out\_octets}}
\pardescript  {OctetString of the decrypted data. Memory must be provided by the calling program.}

\parname  {{\em more}}
\pardescript  {MORE: More data will follow for this decryption process. \\
                  END: Last data of this decryption process.}

\parname  {{\em key}}
\pardescript  {Structure which identifies the decryption key.}

\parname  {{\em Return Value}}
\pardescript  {Number of decrypted octets in {\em out\_octets}, or -1.}
\hl{Description}
af\_decrypt decrypts the input data of bitstring {\em in\_bits} and returns the decrypted data
in {\em out\_octets}. Several successive calls of af\_decrypt can be chained
to one decryption process by means of {\em more}.

The number of bits in {\em in\_bits} is arbitrary. The number of octets in {\em out\_octets}
corresponds in case of {\em more} $=$ MORE to the parameters of the indicated algorithm
(e.g. a multiple of eight in case of DES or DES3 algorithms and a multiple of blocksize/8
in case of RSA). The remaining octets are collected by af\_decrypt.

af\_decrypt puts the decrypted data into {\em out\_octets}\pf octets at the offset
{\em out\_octets}\pf noctets and returns the number of decrypted octets. In addition, this number is added 
to {\em out\_octets}\pf noctets.
The calling program must provide {\em out\_octets}\pf noctets and {\em out\_octets}\pf octets and sufficient
memory in {\em out\_octets}\pf octets.
The amount of memory should be not less than
({\em in\_bits}\pf nbits) $/$ 8 $+$ {\em out\_octets}\pf noctets $+$ $n$ with $n = 8$ 
in case of DES or DES3 algorithms and $n = keysize / 8$ in case of RSA.

Decryption key and corresponding algorithm are determined by parameter {\em key} as follows:
\be
\m If {\em key} is the NULL pointer,
   the own secret decryption key, which is stored in the PSE object
   {\em DecSKnew} or {\em DecSKold}, respectively, is used. 
   In this case, the decryption follows
   the procedure described in Vol. 1, Principles of Security Operations, {\em Operation of
   Encryption Keys}.
   If a single RSA key pair is used for both signature and encryption purposes, however, the own secret key is
   obtained from PSE object {\em SKnew} or {\em SKold}, respectively.
\m If {\em key}\pf key is not the NULL pointer, the structure it points to
   contains algorithm identifier and key.
\m If {\em key}\pf key is the NULL pointer and {\em key}\pf keyref $>$ 0,
   key and algorithm identifier which are referenced by this number are used. This is a key
   previously installed under this reference with {\em af\_gen\_key} or 
   {\em af\_put\_EncryptedKey}.
\m If {\em key}\pf key is the NULL pointer and {\em key}\pf keyref $=$ 0,
   {\em key}\pf pse\_sel indicates the PSE object which contains key and algorithm.
\ee

{\bf In case of RSA algorithm:}
\be
\m The decryption key which is of type BitString is supposed to be
   a {\bf secret key}. It consists of the substructure described in
   SEC-PSE-OBJECTS(4),
   which in case of a secret key consists of the secret
   prime factors. af\_decrypt uses internally the
   decoding function {\em d\_KeyBits} to get the prime factors {\em p} and {\em q}.
\m The bitstring passed through {\em in\_bits} is internally blocked into portions of
   {\em keysize} bits. These blocks are decrypted into blocks of {\em blocksize} bits
   (padded with trailing ZEROES) which in turn are combined into the octetstring {\em out\_octets}, i.e
   the octetstring of the decrypted data consists of less bits than the bitstring of the encrypted data
   according to the relation between {\em blocksize} and {\em keysize}.
   {\em blocksize} is derived from {\em keysize} as the largest multiple of octets which consists of
   less bits than {\em keysize} (for instance $keysize = 512$ leads to $blocksize = 63$).
\m af\_decrypt does not assume any specific padding prior encrypting in order to be able to
   restore the original plaintext length. This must be done by the application before 
   calling  af\_encrypt and after calling af\_decrypt.
\m Since there is no special mechanism to encode the length of the original plaintext prior
   to encryption, decrypting encrypted (with {\em af\_encrypt}) data with {\em af\_decrypt}
   leads to a result which is longer than the original plaintext with trailing zeroes.
\ee
{\bf In case of DES or DES3 algorithm:} \\ [1em]
   While the number of bits in {\em in\_bits} is arbitrary for each single call to
   {\em af\_decrypt}, the number of bits of the input data for the whole
   decryption process (until {\em more} $=$ END) must be a multiple of 64.

   In case of {\bf desCBC\_pad}, {\bf desECB\_pad}, {\bf desCBC3\_pad} or 
   {\bf desECB3\_pad} algorithm, {\em af\_decrypt} considers 
   the last octet of the last block as the number of 
   valid octets of that block (between 0 and 7) which enables {\em af\_decrypt}
   to restore the original octetstring. If the last octet of the last block has not
   a value between 0 and 7 after decryption, an error is indicated.

   In case of {\bf desCBC\_pem} or {\bf desECB\_pem} algorithm, {\em af\_decrypt} assumes
   that padding as defined in RFC 1423 has been applied prior to encrypting
   which again enables {\em af\_decrypt}
   to restore the original octetstring.

   In case of {\bf desCBC}, {\bf desECB}, {\bf desCBC3} or {\bf desECB3} algorithm, {\em af\_decrypt} does
   not assume any specific padding prior to encrypting. The decrypting result is a multiple
   of 8 octets, and measures which allow to restore the original plaintext length are 
   assumed to be taken by the application (of {\em af\_encrypt} and {\em af\_decrypt}).

\subsubsection{af\_sign}
\nm{3X}{af\_dir\_delete\_Certificate}{Remove Certificate from Directory}
\addtotoc{af\_afdb\_delete\_Certificate}
\hl{Synopsis}
\#include $<$af.h$>$ 

RC {\bf af\_dir\_delete\_Certificate} {\em (serial, issuer, type)} \\
int {\em serial}; \\
DName {\em *issuer}; \\
CertificateType {\em type}; 

RC {\bf af\_afdb\_delete\_Certificate} {\em (dname, keytype)} \\
DName {\em *dname}; \\
KeyType {\em keytype};
\hl{Parameter}
\parname  {{\em serial}}
\pardescript  {Serial number of the certificate which is to be removed
from the Directory.} 

\parname  {{\em issuer}}
\pardescript  {Issuer's distinguished name.} 

\parname  {{\em type}}
\pardescript  {Type of certificate to be removed from the X.500 Directory: \\
                    usercert: {\em userCertificate} \\
                    cacert: {\em cACertificate}.} 

\parname  {{\em dname}}
\pardescript  {Owner's distinguished name (.af-db Directory only).} 

\parname  {{\em keytype}}
\pardescript  {Type of certificate to be removed from the Directory (.af-db Directory only): \\
                    SIGNATURE: {\em signature certificate} \\
                    ENCRYPTION: {\em encryption certificate}.} 

\parname  {{\em Return Value}}
\pardescript  {0 or -1.}
\hl{Description}
{\em af\_dir\_delete\_Certificate} removes the certificate which is universally 
identified by its serial number {\em serial} and its issuer {\em issuer} from the 
caller's X.500 Directory entry. The caller's distinguished name is derived from
the global variable {\em bind\_dname} which is used to authenticate the caller to the
Directory System Agent (DSA) initially contacted.
The specified certificate is removed as value from the
{\em userCertificate} attribute or the {\em cACertificate} attribute, depending
on {\em type}.
If the serial number of the certificate which is to be removed from the Directory 
is unique among the serial numbers of all certificates stored in the requested attribute, 
it is sufficient to identify the obsolete certificate by its serial number, that is, 
the issuer's distinguished name may be omitted.

The caller of {\em af\_dir\_delete\_Certificate} must be the owner of the certificate
which is to be removed from the Directory; otherwise, the Directory access control
will refuse this operation.

The return value is 0 if the Directory entry succeeds.

The return value is -1 for one of the following reasons:
\bi
\m the Directory service does not respond (ENODIR);
\m the caller's distinguished name does not identify a Directory object (ENAMEDIR);
\m no attribute of the requested type ({\em userCertificate} or {\em cACertificate})
is found in the Directory entry associated with the caller, that is, the Directory entry
associated with the caller does not belong to the object class being required
({\em strongAuthenticationUser} or {\em certificationAuthority}) (EATTRDIR);
\m the specified certificate does not exist in the Directory entry 
identified by the caller's distinguished name (EOBJ);
\m the Directory access control refuses this operation (EACCDIR).
\ei
{\em af\_afdb\_delete\_Certificate} removes the certificate which is
identified by {\em keytype} from the 
local .af-db Directory entry of {\em dname}. If a single RSA key pair is used for both signature and encryption purposes, however,
{\em keytype} will not be evaluated. In this case, the certificate stored as file {\em Cert} within the
local .af-db Directory entry of {\em dname} is removed.



\subsubsection{af\_dir\_enter\_CertificatePair}
\nm{3X}{af\_dir\_delete\_CertificatePair}{Remove Certificate Pair from Directory}
\addtotoc{af\_afdb\_delete\_CertificatePair}

\hl{Synopsis}

\#include $<$af.h$>$

RC {\bf af\_dir\_delete\_CertificatePair} {\em (cpair)} \\
CertificatePair {\em *cpair};

RC {\bf af\_afdb\_delete\_CertificatePair} {\em (dname, cpair)} \\
DName {\em *dname}; \\
CertificatePair {\em *cpair};
\hl{Parameter}
\parname  {{\em cpair}}
\pardescript  {The cross certificate pair which is to be removed from the Directory.} 

\parname  {{\em dname}}
\pardescript  {DName of the owner of the Directory entry (.af-db Directory only).} 

\parname  {{\em Return Value}}
\pardescript  {0 or -1.}
\hl{Description}
{\em af\_dir\_delete\_CertificatePair} removes the cross certificate pair {\em cpair} 
as value from the {\em crossCertificatePair} attribute within the caller's Directory 
entry. The caller's distinguished name is derived from
the global variable {\em bind\_dname} which is used to authenticate the caller to the
Directory System Agent (DSA) initially contacted. At least one of the two components 
(forward or reverse certificate) of the cross 
certificate pair must be present. Each component is identified by its serial number
and its issuer.

The caller of {\em af\_dir\_delete\_CertificatePair} must be the owner of the Directory
entry from where the cross certificate pair {\em cpair} is to be removed; otherwise, the 
Directory access control will refuse this operation.

If {\em cpair} is the only value of the {\em crossCertificatePair} attribute, the 
{\em crossCertificatePair} attribute will be removed from the Directory entry.

The return value is 0 if the Directory entry succeeds.

The return value is -1 for one of the following reasons:
\bi
\m the Directory service does not respond (ENODIR);
\m the caller's distinguished name does not identify a Directory object (ENAMEDIR);
\m no attribute of type {\em crossCertificatePair} is found in the Directory entry 
associated with the caller (EATTRDIR);
\m the specified cross certificate pair does not exist in the Directory entry 
identified by the caller's distinguished name (EOBJ);
\m the Directory access control refuses this operation (EACCDIR).
\ei
{\em af\_afdb\_delete\_CertificatePair} removes the cross certificate pair {\em cpair} 
from the local .af-db Directory entry identified by {\em dname}. At least one of the two components 
(forward or reverse certificate) of the cross certificate pair must be present.



\subsubsection{af\_dir\_enter\_PemCrl}
\nm{3X}{af\_dir\_enter\_Certificate}{Enter Certificate into Directory}
\addtotoc{af\_afdb\_enter\_Certificate}
\label{af_enter_Certificate}
\hl{Synopsis}
\#include $<$af.h$>$ 

RC {\bf af\_dir\_enter\_Certificate} {\em (cert, type)} \\
Certificate {\em *cert}; \\
CertificateType {\em type}; 

RC {\bf af\_afdb\_enter\_Certificate} {\em (cert, keytype, replace)} \\
Certificate {\em *cert}; \\
KeyType {\em keytype}; \\
Boolean {\em replace};
\hl{Parameter}
\parname  {{\em cert}}
\pardescript  {The certificate to be stored in the Directory. } 

\parname  {{\em type}}
\pardescript  {Type of certificate to be stored in the X.500 Directory: \\
                    usercert: {\em userCertificate} \\
                    cacert: {\em cACertificate}.} 

\parname  {{\em keytype}}
\pardescript  {Type of the certified key (.af-db Directory only): \\
                    SIGNATURE: {\em signature key certificate} \\
                    ENCRYPTION: {\em encryption key certificate}.} 

\parname  {{\em replace}}
\pardescript  {Flag which determines whether or not an already existing certificate of the same {\em keytype} shall be replaced in the .af-db Directory} 

\parname  {{\em Return Value}}
\pardescript {0 or -1.}
\hl{Description}
{\em af\_dir\_enter\_Certificate} enters the certificate {\em cert} into the X.500 Directory 
entry associated with the certificate owner. The certificate {\em cert} is added as value
to the {\em userCertificate} attribute or to the {\em cACertificate} attribute,
depending on {\em type}.

The caller of {\em af\_dir\_enter\_Certificate} must be the owner of the certificate 
which is to be entered into the Directory; otherwise, the Directory access 
control will refuse this operation.

In case of the {\em userCertificate} attribute being addressed, the Directory entry
associated with the certificate owner must belong to the object class
{\em strongAuthenticationUser}; in the other case, it must belong to the
object class {\em certificationAuthority}. Otherwise, an attribute error will be
reported.

The return value is 0 if the Directory entry succeeds.

The return value is -1 for one of the following reasons:
\bi
\m the Directory service does not respond (ENODIR);
\m the certificate owner's distinguished name does not identify a Directory object (ENAMEDIR);
\m no attribute of the requested type ({\em userCertificate} or {\em cACertificate}) is found 
in the entry, that is, the Directory entry associated with the certificate owner does not
belong to the object class being required ({\em strongAuthenticationUser} or 
{\em certificationAuthority}) (EATTRDIR);
\m the certificate {\em cert} already exists in the Directory entry associated with 
its owner (ECREATEOBJ);
\m the Directory access control refuses this operation (EACCDIR).
\ei
{\em af\_afdb\_enter\_Certificate} enters the certificate {\em cert} into the local .af-db
Directory 
entry associated with the certificate owner. The certificate {\em cert} is added as file {\em SignCert}
or {\em EncCert}, depending on {\em keytype}. If a certificate of the requested {\em keytype} already
exists in the relevant .af-db Directory entry, it will not be replaced, unless {\em replace} is set to TRUE.
If a single RSA key pair is used for both signature and encryption purposes, however, the certificate {\em cert} is added as
file {\em Cert} to the local .af-db Directory entry associated with the certificate owner. If a certificate already
exists in the relevant .af-db Directory entry, it will not be replaced, unless {\em replace} is set to TRUE.



\subsubsection{af\_dir\_retrieve\_Certificate}
\nm{3X}{af\_dir\_enter\_CertificatePair}{Enter Pair of Cross Certificates into Directory}
\addtotoc{af\_afdb\_enter\_CertificatePair}
\hl{Synopsis}
\#include $<$af.h$>$ 

RC {\bf af\_dir\_enter\_CertificatePair} {\em (cpair, dname)} \\
CertificatePair {\em *cpair};
DName {\em *dname};

RC {\bf af\_afdb\_enter\_CertificatePair} {\em (cpair, dname)} \\
CertificatePair {\em *cpair}; \\ 
DName {\em *dname};
\hl{Parameter}
\parname  {{\em dname}}
\pardescript  {Distinguished name of the certification authority which wants to store
the cross certificate pair in its Directory entry.} 

\parname  {{\em cpair}}
\pardescript  {The cross certificate pair to be stored in the Directory. } 

\parname  {{\em Return Value}}
\pardescript {0 or -1.}
\hl{Description}
{\em af\_dir\_enter\_CertificatePair} enters the cross certificate pair {\em cpair} 
into the X.500 Directory entry identified by {\em dname}. At least one of the two components 
(forward or reverse certificate) of the cross certificate pair must be present.

An attribute of type {\em crossCertificatePair} is optional within a Directory entry
belonging to the object class {\em certificationAuthority}. If the Directory entry of
the certification authority identified by {\em dname} already contains an attribute of
type {\em crossCertificatePair}, the certificate pair {\em cpair} is added as value
to that attribute; otherwise, an attribute of type {\em crossCertificatePair} will be
created in the Directory entry, its value being specified by {\em cpair}.

The caller of {\em af\_dir\_enter\_CertificatePair} must correspond to the Directory
object identified by {\em dname}; otherwise, the Directory access control will refuse 
this operation.

The Directory entry identified by {\em dname} must belong to the object class
{\em certificationAuthority}; otherwise, an attribute error will be reported.

The return value is 0 if the Directory entry succeeds.

The return value is -1 for one of the following reasons:
\bi
\m the Directory service does not respond (ENODIR);
\m the parameter {\em dname} does not identify a Directory object (ENAMEDIR);
\m the Directory entry identified by {\em dname} does not belong to the object class
{\em certificationAuthority} (EOBJCLASS);
\m the Directory access control refuses this operation (EACCDIR).
\ei
{\em af\_afdb\_enter\_CertificatePair} enters the cross certificate pair {\em cpair} 
into the local .af-db Directory entry identified by {\em dname}. At least one of the two components 
(forward or reverse certificate) of the cross certificate pair must be present.



\subsubsection{af\_dir\_retrieve\_CertificatePair}
\nm{3X}{af\_dir\_enter\_PemCrl}{Enter PEM Revocation List into Directory}
\addtotoc{af\_afdb\_enter\_PemCrl}

\hl{Synopsis}

\#include $<$af.h$>$

RC {\bf af\_dir\_enter\_PemCrl} {\em (pemcrl)} \\
PemCrl {\em *pemcrl};

RC {\bf af\_afdb\_enter\_PemCrl} {\em (pemcrl)} \\
PemCrl {\em *pemcrl};
\hl{Parameter}
\parname  {{\em pemcrl}}
\pardescript  {Pointer to a revocation list with PEM syntax which is to replace the existing 
attribute value.} 

\parname  {{\em Return Value}}
\pardescript  {0 or -1.}
\hl{Description}
{\em af\_dir\_enter\_PemCrl} enters the revocation list {\em pemcrl} into 
the Directory entry associated with the issuer of that revocation list.
The format of the revocation list is that defined by PEM (see RFC 1422).

The caller of {\em af\_dir\_enter\_PemCrl} must be the issuer of the revocation list
{\em pemcrl}; otherwise, the Directory access control will 
refuse this operation.

The caller of {\em af\_dir\_enter\_PemCrl} must belong to the object class 
{\em certificationAuthority}.

The return value is 0 if the Directory entry succeeds.

The return value is -1 for one of the following reasons:
\bi
\m the Directory service does not respond (ENODIR);
\m the distinguished name of the issuer of the revocation list does not identify a Directory 
object (ENAMEDIR);
\m the Directory entry associated with the issuer of {\em pemcrl} does not belong to the
object class {\em certificationAuthority} (EATTRDIR);
\m the Directory access control refuses this operation (EACCDIR).
\ei
{\em af\_afdb\_enter\_PemCrl} enters the revocation list {\em pemcrl} 
into the local .af-db Directory entry associated with the issuer of {\em pemcrl}.



\subsubsection{af\_dir\_retrieve\_PemCrl}
\nm{3X}{af\_dir\_retrieve\_Certificate}{Retrieve Certificate from Directory}
\hl{Synopsis}
\#include $<$af.h$>$

SET\_OF\_Certificate {\bf *af\_dir\_retrieve\_Certificate} {\em (dname, type)} \\
DName {\em *dname}; \\
CertificateType {\em type}; 

SET\_OF\_Certificate {\bf *af\_afdb\_retrieve\_Certificate} {\em (dname, keytype)} \\
DName {\em *dname}; \\
KeyType {\em keytype};
\hl{Parameter}
\parname  {{\em dname}}
\pardescript  {Distinguished name of certificate owner} 

\parname  {{\em type}}
\pardescript  {Type of certificate to be retrieved from the X.500 Directory: \\
                    usercert: {\em userCertificate} \\
                    cacert: {\em cACertificate}.} 

\parname  {{\em keytype}}
\pardescript  {Type of requested certified key (.af-db Directory only): \\
                    SIGNATURE: {\em signature certificate} \\
                    ENCRYPTION: {\em encryption certificate}.} 

\parname  {{\em Return Value}}
\pardescript  {The set of certificates or NULL pointer.}
\hl{Description}
{\em af\_dir\_retrieve\_Certificate} returns a set of certificates stored in the 
X.500 Directory entry identified by {\em dname}. The set of certificates comprises the
value(s) of the {\em userCertificate} attribute or the {\em cACertificate} attribute,
depending on {\em type}. \\
In most cases, the set contains the certificate of the public signature key and the 
certificate of the public encryption key. After this function having returned 
its result, the calling process is in the position to select one certificate 
by comparing the algorithm identifier of the subject public key info.

The return value is the NULL pointer for one of the following reasons:
\bi
\m the Directory service does not respond (ENODIR);
\m the parameter {\em dname} does not identify a Directory object (ENAMEDIR);
\m no attribute of the requested type ({\em userCertificate} or {\em cACertificate})
is found in the Directory entry, that is, the Directory entry identified by {\em dname} 
does not belong to the object class being required ({\em strongAuthenticationUser} or  
{\em certificationAuthority}) (EATTRDIR).
\ei
{\em af\_afdb\_retrieve\_Certificate} returns a set of certificates stored in the 
local .af-db Directory entry identified by {\em dname}.
The returned set of certificates comprises the certificate value stored as file {\em Cert}
within the selected .af-db directory. If no such file exists
in the selected .af-db directory, the set of certificates comprises either the
value of the signature certificate or the value of the encryption certificate, 
depending on {\em keytype}.



\subsubsection{af\_dir\_delete\_Certificate}
\nm{3X}{af\_dir\_retrieve\_CertificatePair}{Retrieve Pair of Cross Certificates from Directory}
\addtotoc{af\_afdb\_retrieve\_CertificatePair}

\hl{Synopsis}

\#include $<$af.h$>$ 

SET\_OF\_CertificatePair {\bf *af\_dir\_retrieve\_CertificatePair} {\em (dname)} \\
DName {\em *dname};

SET\_OF\_CertificatePair {\bf *af\_afdb\_retrieve\_CertificatePair} {\em (dname)} \\
DName {\em *dname};
\hl{Parameter}
\parname  {{\em dname}}
\pardescript  {Distinguished name of certification authority which is the owner of the requested
cross certificate pairs} 

\parname  {{\em Return Value}}
\pardescript  {The set of cross certificate pairs or NULL pointer.}
\hl{Description}
{\em af\_dir\_retrieve\_CertificatePair} returns the set of cross certificate pairs 
stored in the X.500 Directory entry identified by {\em dname}. The set of cross certificate pairs 
comprises the value(s) of the (multi-valued) {\em crossCertificatePair} attribute. \\
Each cross certificate pair is composed of one forward certificate and one reverse certificate;
at least one of the two components must be present in a cross certificate pair.

The return value is the NULL pointer for one of the following reasons:
\bi
\m the Directory service does not respond (ENODIR);
\m the parameter {\em dname} does not identify a Directory object (ENAMEDIR);
\m no attribute of type {\em crossCertificatePair} is found in the Directory entry
identified by {\em dname} (EATTRDIR).
\ei
{\em af\_afdb\_retrieve\_CertificatePair} returns the set of cross certificate pairs 
stored in the local .af-db Directory entry identified by {\em dname}. 
The set of cross certificate pairs 
comprises the value of the CrossCertificatePair entry. \\
Each cross certificate pair is composed of one forward certificate and one reverse certificate;
at least one of the two components must be present in a cross certificate pair.



\subsubsection{af\_dir\_delete\_CertificatePair}
\nm{3X}{af\_dir\_retrieve\_PemCrl}{Retrieve PEM Revocation List from Directory}
\addtotoc{af\_afdb\_retrieve\_PemCrl}

\hl{Synopsis}

\#include $<$af.h$>$

PemCrl {\bf *af\_dir\_retrieve\_PemCrl} {\em (dname)} \\
DName {\em *dname};

PemCrl {\bf *af\_afdb\_retrieve\_PemCrl} {\em (dname)} \\
DName {\em *dname};
\hl{Parameter}
\parname  {{\em dname}}
\pardescript  {Distinguished name of the certification authority which is the issuer of 
the requested revocation list.} 

\parname  {{\em Return Value}}
\pardescript  {Address of a PEM revocation list or NULL pointer.}
\hl{Description}
{\em af\_dir\_retrieve\_PemCrl} reads the attribute of type {\em pemCRL} from the Directory entry 
identified by {\em dname}, and interprets its value as a revocation list whose underlying
syntax is that defined by PEM (see RFC 1422).
{\em af\_dir\_retrieve\_PemCrl} returns the address of that revocation list.

The return value is the NULL pointer for one of the following resons:
\bi
\m the Directory service does not respond (ENODIR);
\m the parameter {\em dname} does not identify a Directory object (ENAMEDIR);
\m no attribute of type {\em pemCRL} is found in the Directory entry, that is, the 
Directory entry identified by {\em dname} does not belong to 
the object class {\em certificationAuthority} (EATTRDIR).
\ei
{\em af\_afdb\_retrieve\_PemCrl} returns the revocation list 
stored in the local .af-db Directory entry identified by {\em dname}.



\subsubsection{af\_cadb\_add\_user}
\nm{3X}{af\_encrypt}{Encrypt octetstring using AF PSE objects}
\label{af_encrypt}
\hl{Synopsis}
\#include $<$af.h$>$

RC {\bf af\_encrypt} {\em (in\_octets, out\_bits, more, key, dname)} \\
OctetString *{\em in\_octets}; \\
BitString *{\em out\_bits}; \\
More {\em more}; \\
Key *{\em key}; \\
DName *{\em dname};
\hl{Parameter}
\parname  {{\em in\_octets}}
\pardescript  {OctetString of the data to be encrypted.}

\parname  {{\em out\_bits}}
\pardescript  {BitString of the encrypted data. Memory must be provided by the calling program.}

\parname  {{\em more}}
\pardescript  {MORE: More data will follow for this encryption process. \\
                  END: Last data of this encryption process.}

\parname  {{\em key}}
\pardescript  {Structure which identifies the encryption key.}

\parname  {{\em dname}}
\pardescript  {DName of the intended recipient of the data.}

\parname  {{\em Return Value}}
\pardescript  {Number of encrypted bits in {\em out\_bits}, or -1.}
\hl{Description}
af\_encrypt encrypts the input data of octetstring {\em in\_octets} and returns the encrypted data
in {\em out\_bits}. Several successive calls of af\_encrypt can be chained
to one encryption process by means of {\em more}.

The number of octets in {\em in\_octets} is arbitrary. The number of bits in {\em out\_bits}
corresponds in case of {\em more} $=$ MORE to the parameters of the indicated algorithm
(e.g. a multiple of 64 in case of DES or DES3 algorithms and a multiple of keysize
in case of RSA). The remaining bits are collected by af\_encrypt.

af\_encrypt puts the encrypted data into {\em out\_bits}\pf bits at the offset
{\em out\_bits}\pf nbits and returns the number of encrypted bits. In addition, this number is added 
to {\em out\_bits}\pf nbits.
The calling program must provide {\em out\_bits}\pf nbits and {\em out\_bits}\pf bits and sufficient
memory in {\em out\_bits}\pf bits.
The amount of memory should be not less than
{\em in\_octets}\pf noctets $+$ ({\em out\_bits}\pf nbits) $/$ 8 $+$ $n$ with $n = 8$ 
in case of DES or DES3 algorithms and $n = keysize / 8$ in case of RSA.

Encryption key and corresponding algorithm are determined by parameters {\em key} and {\em dname} as follows:
\be
\m If {\em key} is the NULL pointer and {\em dname} is the NULL pointer,
   the own public encryption key, which is part of the user certificate stored in the PSE object
   {\em EncCert}, is used.
   If a single RSA key pair is used for both signature and encryption purposes, however, the own public encryption key
   is retrieved from PSE object {\em Cert}.
\m If {\em key} is the NULL pointer and {\em dname} is not the NULL pointer,
   the public encryption key of {\em dname} is searched in the PSE object {\em EKList}.
   If a single RSA key pair is used for both signature and encryption purposes, however, the public encryption key of 
   {\em dname} is searched in the PSE object {\em PKList}.
\m If {\em key}\pf key is not the NULL pointer, the structure it points to
   contains algorithm identifier and key.
\m If {\em key}\pf key is the NULL pointer and {\em key}\pf keyref $>$ 0,
   key and algorithm identifier which are referenced by this number are used. This is a key
   previously installed under this reference with {\em af\_gen\_key} or 
   {\em af\_put\_EncryptedKey}.
\m If {\em key}\pf key is the NULL pointer and {\em key}\pf keyref $=$ 0,
   {\em key}\pf pse\_sel indicates the PSE object which contains key and algorithm.
\ee

{\bf In case of RSA algorithm:}
\be
\m The encryption key which is of type BitString is supposed to be
   a {\bf public key}. It consists of the substructure described in
   SEC-PSE-OBJECTS(4),
   which in case of a public key consists of the
   modulus and the public exponent. af\_encrypt uses internally the
   decoding function {\em d\_KeyBits} to get the modulus {\em n} and the exponent {\em e}.
\m The octetstring passed through {\em in\_octets} is internally blocked into portions of
   {\em blocksize} bits. These blocks are encrypted into blocks of {\em keysize} bits
   (padded with trailing ZEROES) which in turn are combined into the bitstring {\em out\_bits}, i.e
   the bitstring of the encrypted data consists of more bits than the octetstring of the cleartext data
   according to the relation between {\em blocksize} and {\em keysize}.
   The length of the encrypted data is always a multiple of {\em keysize} bits.
   {\em blocksize} is derived from {\em keysize} as the largest multiple of octets which consists of
   less bits than {\em keysize} (for instance $keysize = 512$ leads to $blocksize = 63$).
\m There is no special mechanism to encode the length of the original plaintext prior
   to encryption. Decrypting encrypted (with {\em af\_encrypt}) data with {\em af\_decrypt}
   leads to a result with a length of a multiple of {\em blocksize} octets, i.e. the decrypted
   plaintext is longer than the original plaintext with trailing zeroes.
\ee
{\bf In case of DES or DES3 algorithm:}
   The length of the encryption result is always a multiple of 64 bits.

   In case of {\bf desCBC\_pad}, {\bf desECB\_pad}, {\bf desCBC3\_pad} or 
   {\bf desECB3\_pad} algorithm, additional encoding which allows 
   {\em af\_decrypt} to restore the plaintext length is added prior
   to encryption in case of {\em more} $=$ MORE. If $n$ is the plaintext length,
   8 - $n$ $mod$ 8 octets are padded with
   the last octet of the last block containing the number of 
   valid octets of that block (between 0 and 7), i.e. if the plaintext consists 
   of a multiple of eight octets, one extra block is added with the last octet set to zero.

   In case of {\bf desCBC\_pem} or {\bf desECB\_pem} algorithm, 
   padding as defined in RFC 1424 is applied prior to encrypting
   which again enables {\em af\_decrypt} to restore the plaintext length.

   In case of {\bf desCBC}, {\bf desECB}, {\bf desCBC3} or {\bf desECB3} algorithm,
   trailing zeroes are padded prior to encrypting until an eight-octet boundary is reached, i.e.
   no octets are padded if the plaintext length is a multiple of eight.
   Measures which allow to restore the original plaintext length must
   be taken by the application (of {\em af\_encrypt} and {\em af\_decrypt}).

\subsubsection{af\_decrypt}
\nm{3X}{af\_gen\_key}{Generate DES key or RSA key pair}
\label{af_gen_key}
\hl{Synopsis}
\#include $<$af.h$>$

RC {\bf af\_gen\_key} {\em (key, ktype, replace)} \\
Key *{\em key}; \\
KeyType {\em ktype}; \\
Boolean {\em replace};
\hl{Parameter}
\parname  {{\em key}}
\pardescript  {Structure which determines the generated key.}

\parname  {{\em ktype}}
\pardescript{type of the key pair:
		    SIGNATURE: signature key pair \\
		    ENCRYPTION: encryption key pair.}

\parname  {{\em replace}}
\pardescript  {if FALSE, do not overwrite existing key.}

\parname  {{\em Return Value}}
\pardescript  {0 or -1.}
\hl{Description}
af\_gen\_key generates a
\bi
\m  DES key, 
    if the algorithm encryption method 
    of {\em key}\pf key\pf subjectAI (as returned by aux\_ObjId2AlgEnc()) is DES.
 
    A DES key is a 64 bit long BitString.
\m  DES3 key, 
    if the algorithm encryption method 
    of {\em key}\pf key\pf subjectAI (as returned by aux\_ObjId2AlgEnc()) is DES3.
 
    DES3 is triple block encryption in the fashion encryption(k1)-decryption(k2)-encryption(k1).
    A DES3 key is a 128 bit long BitString, the first 64 bits comprising k1 and the
    second 64 bits comprising k2.
\m  RSA key pair, 
    if the algorithm encryption method 
    of {\em key}\pf key\pf subjectAI (as returned by aux\_ObjId2AlgEnc()) is RSA. 

    An RSA public key is a BitString
    which contains the ASN.1 DER code of
    \bvtab
    \4  SEQUENCE \{ \\
    \4  \2       n INTEGER,   \\
    \4  \2       e INTEGER  \\
    \4  \} \\
    \evtab
    $n$ is the modulus and $e$ is the public exponent.
    

    An RSA secret key is a BitString
    which contains the ASN.1 DER code of
    \bvtab
    \4  SEQUENCE \{ \\
    \4  \2       p INTEGER,   \\
    \4  \2       q INTEGER  \\
    \4  \} \\
    \evtab
    $p$ and $q$ are the two prime factors of the modulus.

\m  DSA key pair, 
    if the algorithm encryption method 
    of {\em key}\pf key\pf subjectAI (as returned by aux\_ObjId2AlgEnc()) is DSA. 

    A DSA public key is a BitString
    which contains the ASN.1 DER code of
    \bvtab
    \4  SEQUENCE \{ \\
    \4  \2       key INTEGER, - - y (public key)   \\
    \4  \2       params DSAParameters OPTIONAL  \\
    \4  \} \\
    \evtab
    with
    \bvtab
    DSAParameters ::= SEQUENCE \{ \\
    \4  \2       prime1 [0] INTEGER, - - p \\
    \4  \2       prime2 [1] INTEGER, - - q \\
    \4  \2       base [2] INTEGER, - - g \\
    \4  \} \\
    \evtab
    
    A DSA secret key is a BitString
    which contains the ASN.1 DER code of
    \bvtab
    \4  SEQUENCE \{ \\
    \4  \2       key INTEGER, - - x (secret key)   \\
    \4  \2       params DSAParameters OPTIONAL  \\
    \4  \} \\
    \evtab
    with
    \bvtab
    DSAParameters ::= SEQUENCE \{ \\
    \4  \2       prime1 [0] INTEGER, - - p \\
    \4  \2       prime2 [1] INTEGER, - - q \\
    \4  \2       base [2] INTEGER, - - g \\
    \4  \} \\
    \evtab

\ei

The key is returned as follows in case of a DES key or DES3 key:

If {\em key}\pf keyref $=$ 0 and {\em key}\pf pse\_sel is not the NULL pointer, the generated key
is stored in the PSE object specified by {\em key}\pf pse\_sel. The object will be
created first. 
If the object already exists and {\em replace} is FALSE, {\em af\_gen\_key}
does not overwrite the object and returns -1.
 
If {\em key}\pf keyref $>$ 0, the generated key is stored under this key reference, until it is
deleted with sec\_del\_key. 
If the key reference already exists and {\em replace} is FALSE, {\em af\_gen\_key}
does not overwrite the key and returns -1.
 
If {\em key}\pf keyref $=$ -1, the generated key is stored under a key reference which is generated 
by af\_gen\_key and returned in {\em key}\pf keyref. The key remains there until it is deleted
with sec\_del\_key. \\ [0.5cm]
The keys are returned as follows in case of an RSA Key Pair:

The public key is returned in {\em key}\pf key\pf subjectkey. Memory is provided by the called program.
The secret key is handled according to the parameter {\em key} as follows: 

If {\em key}\pf keyref $= 0$ and {\em key}\pf pse\_sel is the NULL pointer, the
generated secret key is stored in the PSE object {\em SignSK} or
{\em DecSKnew}, depending on {\em ktype}. 
If the PSE where the keypair is stored is restricted to carry one RSA keypair only, 
the generated secret key is stored in the PSE object {\em SKnew}, instead.

If {\em key}\pf keyref $=$ 0 and {\em key}\pf pse\_sel is not the NULL pointer, the generated secret key
is stored in the PSE object specified by {\em key}\pf pse\_sel. The object will be
created first. 
If the object already exists and {\em replace} is FALSE, {\em af\_gen\_key}
does not overwrite the object and returns -1.
 
If {\em key}\pf keyref $>$ 0, the generated secret key is stored under this key reference until it is
deleted with sec\_del\_key. 
If the key reference already exists and {\em replace} is FALSE, {\em af\_gen\_key}
does not overwrite the key and returns -1.
 
If {\em key}\pf keyref $=$ -1, the generated secret key is stored under a key reference which is generated 
by af\_gen\_key and returned in {\em key}\pf keyref. The key remains there until it is deleted
with sec\_del\_key.

\subsubsection{af\_create\_Certificate}
\nm{3X}{af\_get\_EncryptedKey}{Encrypt key}
\label{af_get_EncryptedKey}
\hl{Synopsis}
\#include $<$af.h$>$

RC {\bf af\_get\_EncryptedKey} {\em (encrypted\_key, plain\_key, encryption\_key, name, encryption\_key\_algid)} \\
EncryptedKey *{\em encrypted\_key}; \\
Key *{\em plain\_key}; \\
Key *{\em encryption\_key}; \\
DName *{\em name}; \\
AlgId *{\em encryption\_key\_algid};
\hl{Parameter}
\parname  {{\em encrypted\_key}}
\pardescript  {Encrypted key.} 

\parname  {{\em plain\_key}}
\pardescript  {Structure which identifies the key to be encrypted.} 

\parname  {{\em encryption\_key}}
\pardescript  {Structure which identifies the encryption key.} 

\parname  {{\em name}}
\pardescript  {DName of the intended recipient of the encrypted key.} 

\parname  {{\em encryption\_key\_algid}}
\pardescript  {Algorithm according to which the encryption will be performed.} 

\parname  {{\em Return Value}}
\pardescript  {0 or -1.}

\hl{Description}

The key identified by {\em plain\_key} is encrypted with the key and algorithm identified by
{\em encryption\_key} or {\em name} and returned in 
{\em encrypted\_key}. Memory is provided by the called program. 

If {\em encryption\_key} is the NULL pointer and {\em name} is the NULL pointer,
the own public encryption key is used, which is part of the user certificate stored in the PSE object
{\em EncCert} or {\em Cert} (depending on whether or not a single RSA key pair is used for both signature and
encryption purposes). 

If {\em encryption\_key} is the NULL pointer and {\em name} 
is not the NULL pointer, the public encryption key of {\em name} is searched in 
the PSE object {\em EKList} (or {\em PKList}, depending on whether or not a single RSA key pair is used for both signature and
encryption purposes), and used for the encryption of {\em plain\_key}.

If {\em encryption\_key} is not the NULL pointer, the key identified by this structure
is used for the encryption of {\em plain\_key}. 

The algorithm identified by {\em encryption\_key\_algid} may be used to determine the algorithm
according to which the encryption of {\em plain\_key} shall be performed. {\em encryption\_key\_algid}
supersedes the algorithm identifier inherent to the key used as {\em encryption\_key}. 

This function is intended to support the so called ``Hybrid method'' where information which
has to be transmitted confidentially is encrypted with the DES algorithm while the corresponding DES key
is transmitted in RSA encrypted form. af\_get\_EncryptedKey is useful for the sender
of such a key.

\subsubsection{af\_put\_EncryptedKey}
\nm{3X}{af\_pse\_add\_CertificatePairSet}{Add set of cross certificate pairs to the set of cross certificate pairs in the PSE}
\label{af_add_CertificatePairSet}
\hl{Synopsis}
\#include $<$af.h$>$

RC {\bf af\_pse\_add\_CertificatePairSet} {\em (cpairset)} \\
SET\_OF\_CertificatePair *{\em cpairset};
\hl{Parameter}
\parname  {{\em cpairset}}
\pardescript  {Set of cross certificate pairs to be added.}

\parname  {{\em Return Value}}
\pardescript  {0 or -1.}
\hl{Description}
af\_pse\_add\_CertificatePairSet adds the set of cross certificate pairs {\em cpairset}
to the set of cross certificate pairs in the PSE object {\em CrossCSet}. 
If any of the cross certificate pairs in {\em cpairset} already exists in the set of cross
certificate pairs stored as value in the PSE object {\em CrossCSet}, it will not be added there.
If all cross certificate pairs in {\em cpairset} already exist in the required set,
the PSE object {\em CrossCSet} is not updated and -1 is returned; otherwise, the respective 
PSE object is updated. 
\\ [1em]
A call of af\_pse\_open() is not required before calling af\_pse\_add\_CertificatePairSet()
(see af\_pse\_open(3X)).

\subsubsection{af\_pse\_update\_CertificatePairSet}
\nm{3X}{af\_pse\_add\_PK}{Add public key to the list of public verification or encryption keys in the PSE}
\label{af_add_PK}
\hl{Synopsis}
\#include $<$af.h$>$

RC {\bf af\_pse\_add\_PK} {\em (type, tbs)} \\
KeyType {\em type}; \\
ToBeSigned *{\em tbs};
\hl{Parameter}
\parname  {{\em type}}
\pardescript  {Type of the key: \\
                    SIGNATURE: public signature verification key of a communication partner. \\
                    ENCRYPTION: public encryption key of a 
                                communication partner.}

\parname  {{\em tbs}}
\pardescript  {ToBeSigned part of the certificate to be added.}

\parname  {{\em Return Value}}
\pardescript  {0 or -1.}
\hl{Description}
af\_pse\_add\_PK adds a public key to the list of known 
verification keys (PKList) or to the list of known encryption keys (EKList), depending
on {\em type}.
If the PSE where the public key is to be stored is restricted to hold a single RSA key pair
for both signature and encryption purposes, however, only the PKList will be considered for storing the public key,
no matter what the value of {\em type} is.
PKList and EKList are chained lists of ToBeSigned-structures which contain the
whole ToBeSigned field of the certificate which belongs to a public key.
af\_pse\_add\_PK adds the ToBeSigned-structure specified by {\em tbs} to the list.
It updates the respective PSE object. No update is done and -1 is returned if
either the same issuer/serialnumber combination or the same public key as in {\em tbs}
already exists in the required list.
\\ [1em]
A call of af\_pse\_open() is not required before calling af\_pse\_add\_PK()
(see af\_pse\_open(3X)).


\subsubsection{af\_pse\_add\_PemCRL}
\nm{3X}{af\_pse\_add\_PemCRL}{Add Revocation List to the set of Revocation Lists in the PSE}
\label{af_add_PemCRL}
\hl{Synopsis}
\#include $<$af.h$>$ 

RC {\bf af\_pse\_add\_PemCRL} {\em (crlpse)} \\
CrlPSE *{\em crlpse}; \\
\hl{Parameter}
\parname  {{\em crlpse}}
\pardescript  {Revocation List to be added.}

\parname  {{\em Return Value}}
\pardescript  {0 or -1.}
\hl{Description}
af\_pse\_add\_PemCRL adds a revocation list specified by {\em crlpse} to the set
of revocation lists stored in the PSE object {\em CrlSet}. It updates that PSE object. 
If a revocation list with the same issuer as in {\em crlpse} is already contained 
in the required list, it will be overwritten by {\em crlpse} in order to maintain
the most current revocation list available from that issuer.

{\em crlpse} identifies a revocation list with PEM format which has been retrieved from
the Directory (X.500 or .af-db). It has a simplified format in that it only comprises the distinguished
name of the issuer of that revocation list, an indication of its next scheduled update,
as well as the serial numbers of all revoked certificates contained in that revocation list.
 
A revocation list retrieved from the Directory will be added to the set of revocation lists
stored in the PSE only in case of its verification having succeeded. 
\\ [1em]
A call of af\_pse\_open() is not required before calling af\_pse\_add\_PemCRL()
(see af\_pse\_open(3X)).


\subsubsection{af\_pse\_delete\_PemCRL}
\nm{3X}{af\_pse\_close}{Close PSE with AF objects}
\label{af_sc_close}
\hl{Synopsis}
\#include $<$af.h$>$ 

RC {\bf af\_pse\_close} {\em (object)} \\
ObjId {\em *object}
\hl{Description}
af\_pse\_close calls sec\_close({\em pse\_sel}) (see sec\_close(3X)) 
with {\em pse\_sel} filled from the global structure {\em AF\_pse}. If the PSE
or the object identified by {\em object} is not open (see af\_pse\_open()), -1 is returned.
If {\em object} is NULL, {\em af\_pse\_close()} resets the global variable {\em AF\_pse.pin} to NULL.
Otherwise {\em AF\_pse.object[..].pin} is reset to NULL. A subsequent {\em af\_pse\_open()}
to the same PSE or object will do a PIN check again.

\subsubsection{af\_pse\_get\_Name}
\nm{3X}{af\_pse\_create}{Create PSE with AF objects}
\label{af_pse_create}
\hl{Synopsis}
\#include $<$af.h$>$

PSESel {\bf *af\_pse\_create} {\em (object)} \\
ObjId {\em *object}
\hl{Description}
{\em af\_pse\_create()} creates the PSE identified by the global structure {\em AF\_pse}.
It calls sec\_create({\em pse\_sel}) (see sec\_create(3X)) 
with {\em pse\_sel} filled from the global structure {\em AF\_pse}.
{\em object} is the object identifier of the AF object to be created.
If {\em object} is NULL, the entire PSE is created by setting pse\_sel\pf object.name
to NULL prior to the call of sec\_create().
{\em af\_pse\_create()} returns NULL if the object or PSE to be created already exists.
 
In case of success, {\em af\_pse\_create} returns the address of the PSESel structure which came back from
the call to sec\_create, and {\em AF\_pse.pin}, {\em AF\_pse.app\_id} and, in case of
{\em object} is not NULL, {\em AF\_pse.object[..].pin} are set to those values returned
by sec\_create(). The memory of the returned PSESel structure can be released using free().

\subsubsection{af\_pse\_close}
\nm{3X}{af\_pse\_delete\_PK}{Delete entry from the list of trusted public keys (PKList/EKList) from PSE}
\label{af_del_PK}
\hl{Synopsis}
\#include $<$af.h$>$ 

RC {\bf af\_pse\_delete\_PK} {\em (type, name, issuer, serial)} \\
KeyType {\em type}; \\
DName *{\em name}; \\
DName *{\em issuer}; \\
inr {\em serial}
\hl{Parameter}
\parname  {{\em type}}
\pardescript  {Type of the key: \\
                    SIGNATURE: public signature verification key of a communication partner. \\
                    ENCRYPTION: public encryption key of a
                                communication partner.}

\parname  {{\em name}}
\pardescript  {DName of the partner.}

\parname  {{\em issuer}}
\pardescript  {DName of the issuer.}

\parname  {{\em serial}}
\pardescript  {Serial number.}

\parname  {{\em Return Value}}
\pardescript  {0 or -1.}
\hl{Description}
af\_pse\_delete\_PK deletes an entry from the list of trusted 
verification keys (PKList) or to the list of trusted encryption keys (EKList), depending
on {\em type}. It updates the respective PSE object. In case of the last entry of the required
list being deleted the respective PSE object is deleted, too.
If the PSE from where the entry is to be removed is restricted to hold a single RSA key pair
for both signature and encryption purposes, however, only the PKList will be considered for deleting the identified entry,
no matter what the value of {\em type} is.

PKList and EKList are chained lists of ToBeSigned-structures which contain the
whole ToBeSigned field of the certificate which belongs to the public key. If 
{\em name} is not NULL and {\em issuer} is NULL, all entries which have the same partner name (or
subject name) are deleted. Otherwise, {\em issuer} and {\em serial} must not
be NULL, and the entry which has the same issuer name and serial number is
deleted.  
\\ [1em]
A call of af\_pse\_open() is not required before calling af\_pse\_delete\_PK()
(see af\_pse\_open(3X)).

\subsubsection{af\_pse\_get\_owner}
\nm{3X}{af\_pse\_delete\_PemCRL}{Remove Revocation List from the set of Revocation Lists in the PSE}
\label{af_delete_PemCRL}
\hl{Synopsis}
\#include $<$af.h$>$ 

RC {\bf af\_pse\_delete\_PemCRL} {\em (issuer)} \\
DName *{\em issuer}; \\
\hl{Parameter}
\parname  {{\em issuer}}
\pardescript  {Issuer whose Revocation List is to be removed from PSE object CrlSet.}

\parname  {{\em Return Value}}
\pardescript  {0 or -1.}
\hl{Description}
af\_pse\_delete\_PemCRL removes the revocation list issued by {\em issuer} from the set
of revocation lists stored in the PSE object {\em CrlSet} and updates that PSE object. 
\\ [1em]
A call of af\_pse\_open() is not required before calling af\_pse\_delete\_PemCRL()
(see af\_pse\_open(3X)).



\subsubsection{af\_pse\_exchange\_PK}
\nm{3X}{af\_pse\_exchange\_PK}{Exchange entry in the list of trusted public keys (PKList/EKList) from PSE}
\label{af_change_PK}
\hl{Synopsis}
\#include $<$af.h$>$

RC {\bf af\_pse\_exchange\_PK} {\em (type, tbs)} \\
KeyType {\em type}; \\
ToBeSigned *{\em tbs};
\hl{Parameter}
\parname  {{\em type}}
\pardescript  {Type of the key: \\
                    SIGNATURE: public signature verification key of a communication partner. \\
                    ENCRYPTION: public encryption key of a
                                communication partner.} 

\parname  {{\em tbs}}
\pardescript  {ToBeSigned part of the certificate to be exchanged.}

\parname  {{\em Return Value}}
\pardescript  {0 or -1.}
\hl{Description}
af\_pse\_exchange\_PK exchanges a ToBeSigned-entry in the list of known 
verification keys (PKList) or in the list of known encryption keys (EKList), depending
on {\em type}. The entry to be exchanged is identified by the partner name (subject name
contained in {\em tbs}) and, if this is not unique, by the issuer name contained in {\em tbs}.
It updates the respective PSE object.
If the PSE where the ToBeSigned-entry is to be exchanged is restricted to hold a single RSA key pair
for both signature and encryption purposes, however, only the PKList will be considered for exchanging the identified ToBeSigned-entry,
no matter what the value of {\em type} is.
No update is done and -1 is returned if
the entry cannot be found in the required list.
\\ [1em]
A call of af\_pse\_open() is not required before calling af\_pse\_exchange\_PK()
(see af\_pse\_open(3X)).

\subsubsection{af\_pse\_delete\_PK}
\nm{3X}{af\_pse\_get\_AliasList}{Get AliasList from PSE}
\label{af_get_AliasList}
\hl{Synopsis}
\#include $<$af.h$>$

AliasList *{\bf af\_pse\_get\_AliasList} {\em ()} \\
\hl{Description}
af\_pse\_get\_AliasList returns the content of PSE object AliasList (which
comprises the alias database of the owner of the PSE).
\\ [1em]
A call of af\_pse\_open() is not required before calling af\_pse\_get\_AliasList()
(see af\_pse\_open(3X)).


\subsubsection{af\_pse\_get\_QuipuPWD}
\nm{3X}{af\_pse\_get\_Certificate}{Get Certificate from PSE}
\label{af_get_Certificate}
\hl{Synopsis}
\#include $<$af.h$>$

Certificate *{\bf af\_pse\_get\_Certificate} {\em (type, issuer, serial)} \\
KeyType {\em type}; \\
DName	{\em *issuer}; \\
int	{\em serial};
\hl{Parameter}
\parname  {{\em type}}
\pardescript  {Type of the certificate: \\
                    SIGNATURE: user certificate of the signature key \\
                    ENCRYPTION: user certificate of the encryption key.} 

\parname  {{\em issuer}}
\pardescript  {name of the issuer of a requested cross
		certificate}

\parname  {{\em serial}}
\pardescript  {serial number of a requested cross
		certificate.} 

\parname  {{\em Return Value}}
\pardescript  {Address of Certificate or NULL pointer.}
\hl{Description}
af\_pse\_get\_Certificate returns the address of a Certificate which contains
either a user certificate of the public signature key 
or a user certificate of the public encryption key, depending on {\em type}. 

If {\em issuer} is given, i.e. {\em issuer} is not NULL, a cross certificate issued
by {\em issuer} is searched from the corresponding certificate set in PSE objects 
{\em SignCSet} or {\em EncCSet} and returned in the return value. 
If {\em serial} is additionally given, a cross
certificate with that serial number is searched. Otherwise, if {\em issuer}
is NULL, the hierarchy certificate from PSE objects {\em SignCert} or {\em EncCert}
is returned.

If the PSE from which the certificate is retrieved is restricted to hold a single RSA key pair
for both signature and encryption purposes, however, the requested certificate is returned
from PSE objects {\em CSet} or {\em Cert}, depending on whether a cross certificate or a hierarchy
certificate is requested. In this case, {\em type} will not be evaluated.

NULL is returned if the requested certificate is not found.
\\ [1em]
A call of af\_pse\_open() is not required before calling af\_pse\_get\_Certificate()
(see af\_pse\_open(3X)).

\subsubsection{af\_pse\_get\_CertificateSet}
\nm{3X}{af\_pse\_get\_CertificatePairSet}{Get Set of Cross Certificate Pairs from PSE}
\label{af_get_CertificatePairSet}
\hl{Synopsis}
\#include $<$af.h$>$

SET\_OF\_CertificatePair *{\bf af\_pse\_get\_CertificatePairSet} {\em ()} \\
\hl{Description}
af\_pse\_get\_CertificatePairSet returns the address of a set which contains all 
cross certificate pairs by which the certification authority owning the PSE and other
certification authorities certify each other's public signature keys.

Each cross certificate pair is composed of two components: one forward and one
reverse certificate. Forward and reverse certificates are related to each other in the 
following way: The owner (subject) of the forward certificate (the certification authority
which is the owner of the PSE) is the issuer of the reverse certificate belonging to the same
pair (and vice versa).

The set of cross certificate pairs is stored in the PSE object {\em CrossCSet}.
\\ [1em]
A call of af\_pse\_open() is not required before calling af\_pse\_get\_CertificatePairSet()
(see af\_pse\_open(3X)).

\subsubsection{af\_pse\_get\_FCPath}
\nm{3X}{af\_pse\_get\_CertificateSet}{Get CertificateSet from PSE}
\label{af_get_CertificateSet}
\hl{Synopsis}
\#include $<$af.h$>$

SET\_OF\_Certificate *{\bf af\_pse\_get\_CertificateSet} {\em (type)} \\
KeyType {\em type}; \\\
\hl{Parameter}
\parname  {{\em type}}
\pardescript  {Type of the certificate: \\
                    SIGNATURE: user certificate of the signature key \\
                    ENCRYPTION: user certificate of the encryption key.} 

\parname  {{\em Return Value}}
\pardescript  {Address of CertificateSet or NULL pointer.}
\hl{Description}
af\_pse\_get\_CertificateSet returns the address of a CertificateSet which contains
either all cross certificates of the public signature key 
or all cross certificates of the public encryption key, depending on {\em type}.

The certificate set is stored in the PSE object
{\em SignCSet} or {\em EncCSet}, respectively.

If the PSE from which the certificate set is retrieved is restricted to hold a single RSA key pair
for both signature and encryption purposes, however, the requested certificate set is returned
from PSE object {\em CSet}. In that case, {\em type} will not be evaluated.
\\ [1em]
A call of af\_pse\_open() is not required before calling af\_pse\_get\_CertificateSet()
(see af\_pse\_open(3X)).

\subsubsection{af\_pse\_get\_CertificatePairSet}
\nm{3X}{af\_pse\_get\_Certificates}{Get Certificates from PSE}
\label{af_get_Certificates}
\hl{Synopsis}
\#include $<$af.h$>$ 

Certificates *{\bf af\_pse\_get\_Certificates} {\em (type, name)} \\
KeyType {\em type}; \\
DName *{\em name};
\hl{Parameter}
\parname  {{\em type}}
\pardescript  {Type of the user certificate of Certificates: \\
                    SIGNATURE: user certificate of the signature key \\
                    ENCRYPTION: user certificate of the encryption key.} 

\parname  {{\em name}}
\pardescript  {DName of the certification authority of an intended recipient or NULL pointer.}

\parname  {{\em Return Value}}
\pardescript  {Address of Certificates or NULL pointer.}
\hl{Description}
af\_pse\_get\_Certificates returns the address of a Certificates containing an user certificate and the 
related forward 
certification path. The user certificate is either the certificate of the signature key,
or the certificate of the encryption key, depending on {\em type}.

User certificate and forward certification path are both stored
in the PSE objects {\em SignCert} or {\em EncCert}, and {\em FCPath}. If the PSE from which the originator certificate 
is retrieved is restricted to hold a single RSA key pair
for both signature and encryption purposes, however, the user certificate is stored in PSE object {\em Cert}; in this case, 
{\em type} will not be evaluated.

If {\em name} is the NULL pointer, Certificates contains the complete forward certification path. Otherwise
the DName of an issuer can be specified in {\em name}. In this case Certificates containes a reduced forward 
certification path:
\be
\m If {\em name} is the name of the issuer of the user certificate, no forward certification path
   is returned. 
\m Otherwise, the level (of the forward certification path) where the certificate of issuer {\em name} is found
   contains only this certificate.
\m Below this level all cross certificates are omitted.
\m Above this level all certificates are omitted.
\ee
If {\em name} is specified but not found in the PSE, the NULL pointer is returned.
\\ [1em]
A call of af\_pse\_open() is not required before calling af\_pse\_get\_Certificates()
(see af\_pse\_open(3X)).


\subsubsection{af\_pse\_get\_PKRoot}
\nm{3X}{af\_pse\_get\_CrlSet}{Get set of Revocation Lists from PSE}
\label{af_get_CrlSet}
\hl{Synopsis}
\#include $<$af.h$>$

CrlSet *{\bf af\_pse\_get\_CrlSet} {\em ()} \\
\hl{Description}
af\_pse\_get\_CrlSet returns the address of the set of revocation lists of all
certification authorities known to the owner of the PSE.

Each member of this set represents a revocation list which has been retrieved from 
the Directory (X.500) and stored in the set using a simplified format: It comprises the distinguished
name of the issuer of a revocation list, a {\em nextUpdate} field specifying when the next
revocation list of that issuer is scheduled to be issued, and the serial numbers of all revoked
certificates contained in that revocation list. The {\em nextUpdate} field of a specific 
revocation list informs the owner of the PSE of when next to access the 
Directory in order to maintain the most current revocation list available from a given
certification authority. 

The set of revocation lists is stored in the PSE object {\em CrlSet}.
\\ [1em]
A call of af\_pse\_open() is not required before calling af\_pse\_get\_CrlSet()
(see af\_pse\_open(3X)).


\subsubsection{af\_pse\_get\_SerialNumbers}
\nm{3X}{af\_pse\_get\_FCPath}{Get forward certification path from PSE}
\label{af_get_FCPath}
\hl{Synopsis}
\#include $<$af.h$>$ 

FCPath *{\bf af\_pse\_get\_FCPath} {\em (name)} \\
DName *{\em name};
\hl{Parameter}
\parname  {{\em name}}
\pardescript  {DName of the certification authority of an intended recipient or NULL pointer.}

\parname  {{\em Return Value}}
\pardescript  {Address of FCPath or NULL pointer.}
\hl{Description}
af\_pse\_get\_FCPath returns the address of an FCPath containing the forward certification path.

The forward certification path is stored on the PSE object
{\em FCPath}.

If {\em name} is the NULL pointer, the complete forward certification path is returned. Otherwise
the DName of an issuer can be specified in {\em name}. In this case a reduced forward 
certification path is returned:
\be
\m The level where the certificate of issuer {\em name} is found contains only this certificate.
\m Below this level all cross certificates are omitted.
\m Above this level all certificates are omitted.
\ee
If {\em name} is specified but not found in the PSE, the NULL pointer is returned.
\\ [1em]
A call of af\_pse\_open() is not required before calling af\_pse\_get\_FCPath()
(see af\_pse\_open(3X)).

\subsubsection{af\_pse\_get\_Certificates}
\nm{3X}{af\_pse\_get\_Name}{Get Name from PSE}
\label{af_get_Name}
\hl{Synopsis}
\#include $<$af.h$>$

DName *{\bf af\_pse\_get\_Name} {\em ()} \\
\hl{Description}
af\_pse\_get\_Name returns the content of PSE object Name (which
contains the distinguished name of the owner of the PSE).
\\ [1em]
A call of af\_pse\_open() is not required before calling af\_pse\_get\_Name()
(see af\_pse\_open(3X)).

\subsubsection{af\_pse\_get\_Certificate}
\nm{3X}{af\_pse\_get\_PK}{Get KeyInfo from the list of trusted public keys (PKList/EKList) from PSE}
\label{af_search_Name}
\hl{Synopsis}
\#include $<$af.h$>$

KeyInfo *{\bf af\_pse\_get\_PK} {\em (type, subject, issuer, serial)} \\
KeyType {\em type}; \\
DName *{\em subject}; \\
DName *{\em issuer}; \\
int {\em serial};
\hl{Parameter}
\parname  {{\em type}}
\pardescript  {Type of the key: \\
                    SIGNATURE: public signature verification key of a communication partner. \\
                    ENCRYPTION: public encryption key of a
                                communication partner.} 

\parname  {{\em subject}}
\pardescript  {DName of the partner.}

\parname  {{\em issuer}}
\pardescript  {DName of the issuer of the partner.}

\parname  {{\em serial}}
\pardescript  {serial number.}

\parname  {{\em Return Value}}
\pardescript  {Address of KeyInfo or NULL.}
\hl{Description}
af\_pse\_get\_PK returns the PublicKeyInfo of an entry in the list of trusted 
verification keys (PKList) or in the list of trusted encryption keys (EKList), depending
on {\em type}.
If the PSE from which the required PublicKeyInfo is retrieved is restricted to hold a single RSA key pair
for both signature and encryption purposes, however, only the PKList will be considered for returning the required PublicKeyInfo,
no matter what the value of {\em type} is.

Both PKList and EKList may contain multiple entries per subject name, however,
each entry is uniquely identified by the issuer-serialnumber pair.

If {\em subject} is not NULL and {\em issuer} is NULL, PK of the first entry which
matches parameter {\em subject} is returned.

If {\em subject} is not NULL and {\em issuer} is not NULL, PK of that entry which 
matches all three parameters {\em subject}, {\em issuer} and {\em serial} is returned.
 
If {\em subject} is NULL and {\em issuer} is not NULL, PK of that entry which matches the
parameters {\em issuer} and {\em serial} is returned.

NULL is returned if the specified entry cannot be found.
\\ [1em]
A call of af\_pse\_open() is not required before calling af\_pse\_get\_PK()
(see af\_pse\_open(3X)).

\subsubsection{af\_pse\_get\_TBS}
\nm{3X}{af\_pse\_get\_PKList}{Get list of public verification or encryption keys from PSE}
\label{af_get_PKList}
\hl{Synopsis}
\#include $<$af.h$>$

PKList *{\bf af\_pse\_get\_PKList} {\em (type)} \\
KeyType {\em type};
\hl{Parameter}
\parname  {{\em type}}
\pardescript  {Type of the list: \\
                    SIGNATURE: List of known public signature verification keys of communication partners. \\
                    ENCRYPTION: List of known public encryption keys of
                                communication partners.}

\parname  {{\em Return Value}}
\pardescript  {Address of PKList or NULL pointer.}
\hl{Description}
af\_pse\_get\_PKList returns the address of PKList, containing either a chained list of all known
public verification keys or a list of all known public encryption keys of communication partners,
depending on {\em type}.
Each list element is a ToBeSigned field from the certificate which belongs to the public key.
 
The list is stored on the PSE object {\em PKList} or {\em EKList}, respectively.

If the PSE from which the PKList is retrieved is restricted to hold a single RSA key pair
for both signature and encryption purposes, however, the list is in any case retrieved from PSE oject {\em PKList},
no matter what the value of {\em type} is.
\\ [1em]
A call of af\_pse\_open() is not required before calling af\_pse\_get\_PKList()
(see af\_pse\_open(3X)).


\subsubsection{af\_pse\_get\_CrlSet}
\nm{3X}{af\_pse\_get\_PKRoot}{Get top level verification key from PSE}
\label{af_get_PKRoot}
\hl{Synopsis}
\#include $<$af.h$>$

PKRoot *{\bf af\_pse\_get\_PKRoot} ()
\hl{Parameter}
\parname  {{\em Return Value}}
\pardescript  {Address of PKRoot or NULL pointer.}
\hl{Description}
af\_pse\_get\_PKRoot returns the address of PKRoot. This contains DName, public key, and a corresponding
serial number of the top level certification authority (highest verification key).
The corresponding serial number is the lowest serial number of all certificates to be 
verified with this key.

Both public key and serial number are available in an actual version and in a version which was
actual before.

The top level verification keys are stored in the PSE object
{\em PKRoot}.
\\ [1em]
A call of af\_pse\_open() is not required before calling af\_pse\_get\_PKRoot()
(see af\_pse\_open(3X)).


\subsubsection{af\_pse\_get\_PKList}
\nm{3X}{af\_pse\_get\_QuipuPWD}{Read X.500 Password from PSE}
\label{af_get_QuipuPWD}
\hl{Synopsis}
\#include $<$af.h$>$

char *{\bf af\_pse\_get\_QuipuPWD} {\em ()} \\
\hl{Description}
af\_pse\_get\_QuipuPWD returns the content of PSE object QuipuPWD (which
comprises the X.500 password of the PSE owner, used for simple authentication to the
X.500 Directory).
\\ [1em]
A call of af\_pse\_open() is not required before calling af\_pse\_get\_QuipuPWD()
(see af\_pse\_open(3X)).


\subsubsection{af\_pse\_update\_Certificate}
\nm{3X}{af\_pse\_get\_SerialNumbers}{Get sequence of serialnumbers from PSE}
\label{af_get_SerialNumbers}
\hl{Synopsis}
\#include $<$af.h$>$

SerialNumbers *{\bf af\_pse\_get\_SerialNumbers} {\em ()} \\
\hl{Description}
af\_pse\_get\_SerialNumbers returns the address of the sequence of serialnumbers
used by the owner of the PSE (which must be a certification authority).

The sequence of serialnumbers is composed of two integers {\em initial} and {\em actual}:
{\em initial} contains the value of the serialnumber assigned to the first
certificate issued by the CA, whereas {\em actual}
holds the value of the serialnumber which will be assigned to the certificate that will next be issued
by the CA.

The sequence of serialnumbers is stored in the PSE object {\em SerialNumbers}.
\\ [1em]
A call of af\_pse\_open() is not required before calling af\_pse\_get\_SerialNumbers()
(see af\_pse\_open(3X)).


\subsubsection{af\_pse\_get\_AliasList}
\nm{3X}{af\_pse\_get\_TBS}{Get ToBeSigned from the list of trusted public keys (PKList/EKList) from PSE}
\label{af_search_tbs_Name}
\hl{Synopsis}
\#include $<$af.h$>$

ToBeSigned *{\bf af\_pse\_get\_TBS} {\em (type, subject, issuer, serial)} \\
KeyType {\em type}; \\
DName *{\em subject}; \\
DName *{\em issuer}; \\
int {\em serial};
\hl{Parameter}
\parname  {{\em type}}
\pardescript  {Type of the key: \\
                    SIGNATURE: public signature verification key of a communication partner. \\
                    ENCRYPTION: public encryption key of a
                                communication partner.}

\parname  {{\em subject}}
\pardescript  {DName of the partner.}

\parname  {{\em issuer}}
\pardescript  {DName of the issuer.}

\parname  {{\em serial}}
\pardescript  {serial number.}

\parname  {{\em Return Value}}
\pardescript  {Address of KeyInfo or NULL.}
\hl{Description}
af\_pse\_get\_TBS returns an entry (which is a ToBeSigned) from the list of trusted 
verification keys (PKList) or in the list of trusted encryption keys (EKList), depending
on {\em type}.
If the PSE from which the required entry is retrieved is restricted to hold a single RSA key pair
for both signature and encryption purposes, however, only the PKList will be considered for returning the requested entry,
no matter what the value of {\em type} is.

Both PKList and EKList may contain multiple entries per subject name, however,
each entry is uniquely identified by the issuer-serialnumber pair.

If {\em subject} is not NULL and {\em issuer} is NULL, the first entry which
matches the parameter {\em subject} is returned.

If {\em subject} is not NULL and {\em issuer} is not NULL, the entry which 
matches all three parameters {\em subject}, {\em issuer} and {\em serial} is returned.
 
If {\em subject} is NULL and {\em issuer} is not NULL, the entry which matches the
parameters {\em issuer} and {\em serial} is returned.

NULL is returned if the specified entry cannot be found.
\\ [1em]
A call of af\_pse\_open() is not required before calling af\_pse\_get\_TBS()
(see af\_pse\_open(3X)).

\subsubsection{af\_encrypt}
\nm{3X}{af\_pse\_get\_owner}{Search public key in the list of trusted public keys (PKList/EKList) from PSE}
\label{af_search_PK}
\hl{Synopsis}
\#include $<$af.h$>$

DName *{\bf af\_pse\_get\_owner} {\em (type, pk)} \\
KeyType {\em type}; \\
KeyInfo *{\em pk};
\hl{Parameter}
\parname  {{\em type}}
\pardescript  {Type of the key: \\
                    SIGNATURE: public signature verification key of a communication partner. \\
                    ENCRYPTION: public encryption key of a
                                communication partner.}

\parname  {{\em pk}}
\pardescript  {public key (X.509 SubjectPublicKeyInfo).}

\parname  {{\em Return Value}}
\pardescript  {Address of DName or NULL.}
\hl{Description}
af\_pse\_get\_owner searches {\em pk} in the list of known 
verification keys (PKList) or in the list of known encryption keys (EKList), depending
on {\em type}, and returns the name of its owner (address of DName).
\\ [1em]
A call of af\_pse\_open() is not required before calling af\_pse\_get\_owner()
(see af\_pse\_open(3X)).

\subsubsection{af\_pse\_get\_PK}
\nm{3X}{af\_pse\_open}{Open PSE with AF objects}
\label{af_pse_open}
\hl{Synopsis}
\#include $<$af.h$>$

PSESel {\bf *af\_pse\_open} {\em (object, createflag)} \\
ObjId {\em *object} \\
Boolean {\em createflag}
\hl{Description}
{\em af\_pse\_open()} opens the PSE identified by the global structure {\em AF\_pse}.
It calls sec\_open({\em pse\_sel}) (see sec\_open(3X)) 
with {\em pse\_sel} filled from the global structure {\em AF\_pse}.
The main purpose is to check the existence of the PSE or PSE object and
to provide access to it through PIN check.
{\em object} is the object identifier of the AF object to be opened.
If {\em object} is NULL, the entire PSE is opened by setting pse\_sel\pf object.name
to NULL prior to the call of sec\_open().
If {\em object} is not NULL and {\em createflag} is TRUE, the object identified by {\em object}
is created if it does not exist.
 
In case of success, {\em af\_pse\_open} returns the address of the PSESel structure which came back from
the call to sec\_open, and {\em AF\_pse.pin}, {\em AF\_pse.app\_id} and, in case of
{\em object} is not NULL, {\em AF\_pse.object[..].pin} are set to those values returned
by sec\_open(). The memory of the returned PSESel structure can be released using free().
If {\em af\_pse\_open()} is not successful, i.e. if the object does not exist or the
PIN check fails, NULL is returned.
\\ [1em]
If the PSE or object is already open, sec\_open (which does the PIN check) is not called, 
and only the corresponding PSESel structure is returned, i.e. the PSE or an object
can be opened more than once, but PIN checking is done only the first time. 
{\em AF\_pse.pin} is used as indicator whether the PSE is already open. If {\em AF\_pse.pin} is not NULL,
the PSE is considered to be already open. {\em af\_pse\_open()} sets {\em AF\_pse.pin} to the value returned
by sec\_open, which is either the address of the PIN if the connected PSE returns the PIN (the
SW-PSE returns the PIN, smartcard based PSEs probably not), or a pointer to a NULL terminated
string if the PSE or object does not require a PIN or the PSE does not return the PIN.
AF\_pse.pin is reset to NULL by {\em af\_pse\_close()}.
 
Similarly, {\em AF\_pse.object[..].pin} of the object identified by {\em object} is used as
indicator whether the object is already open or not.
\\ [1em]
All af\_pse routines which access PSE objects
open the corresponding object using af\_pse\_open(), but they do not
close the object. This allows to access several PSE objects within one program (or process)
and do PIN checking only once when accessing the first time. If PIN checking is required explicitly,
af\_pse\_close() should be used before accessing an object.

\subsubsection{af\_pse\_create}
\nm{3X}{af\_pse\_update\_AliasList}{Update user-defined aliases in the PSE}
\label{af_update_AliasList}
\hl{Synopsis}
\#include $<$af.h$>$ 

RC {\bf af\_pse\_update\_AliasList} {\em (alist)} \\
AliasList *{\em alist};
\hl{Parameter}
\parname  {{\em alist}}
\pardescript  {List of alias names.}

\parname  {{\em Return Value}}
\pardescript  {0 or -1.}
\hl{Description}

af\_pse\_update\_AliasList selects from the supplied alias list {\em alist} all user-defined aliases, i.e.,
all aliases whose corresponding {\em aliasf} field is set to {\em useralias}. It stores the
resulting alias list in the PSE object {\em AliasList}.
\\ [1em]
A call of af\_pse\_open() is not required before calling af\_pse\_update\_AliasList()
(see af\_pse\_open(3X)).


\subsubsection{af\_pse\_update\_QuipuPWD}
\nm{3X}{af\_pse\_update\_Certificate}{Update Certificate in the PSE}
\label{af_update_Certificate}
\hl{Synopsis}
\#include $<$af.h$>$

RC {\bf af\_pse\_update\_Certificate} {\em (type, cert, hierarchy)} \\
KeyType {\em type}; \\
Certificate *{\em cert}; \\
Boolean {\em hierarchy};
\hl{Parameter}
\parname  {{\em type}}
\pardescript  {Type of the certificate: \\
                    SIGNATURE: user certificate of the signature key \\
                    ENCRYPTION: user certificate of the encryption key.} 

\parname  {{\em cert}}
\pardescript  {user certificate.} \\
\parname  {{\em hierarchy}}
\pardescript  {TRUE if cert is hierarchy certificate, FALSE if cert is cross certificate.} \\
\parname  {{\em Return Value}}
\pardescript  {0 or -1.}
\hl{Description}
af\_pse\_update\_Certificate stores Certificate {\em cert} in the PSE.
\\ [1em]
{\em Cert} contains either a user certificate of the public signature key 
or a user certificate of the public encryption key, depending on {\em type}.
\\ [1em]
The certificate is stored in the PSE object {\em SignCert} or 
{\em EncCert} respectively, if it is a hierarchy certificate, i.e. if it is a certificate
issued by a CA of the own CA tree. This is indicated by {\em hierarchy} $=$ TRUE. 
\\ [1em]
Otherwise, if {\em hierarchy} $=$ FALSE, {\em cert} is a cross certificate of the user's
public signature or encryption key. It is stored in this case in the PSE object {\em SignCSet} or 
{\em EncCSet} respectively.
If {\em cert} does not exist in the appropriate certificate set,
it is added to the set.
\\ [1em]
If the PSE where the certificate is to be stored is restricted to hold a single RSA key pair
for both signature and encryption purposes, however, the certificate is stored in PSE object {\em CSet} or {\em Cert},
depending on whether the certificate is considered a cross certificate or a hierarchy certificate. In that case, {\em type} will not
be evaluated.
\\ [1em]
A call of af\_pse\_open() is not required before calling af\_pse\_update\_Certificate()
(see af\_pse\_open(3X)).

\subsubsection{af\_pse\_update\_FCPath}
\nm{3X}{af\_pse\_update\_CertificatePairSet}{Update Set of Cross Certificate Pairs in the PSE}
\label{af_update_CertificatePairSet}
\hl{Synopsis}
\#include $<$af.h$>$

RC {\bf af\_pse\_update\_CertificatePairSet} {\em (cpairset)} \\
SET\_OF\_CertificatePair *{\em cpairset};
\hl{Parameter}
\parname  {{\em cpairset}}
\pardescript  {Set of Cross Certificate Pairs.}

\parname  {{\em Return Value}}
\pardescript  {0 or -1.}
\hl{Description}
af\_pse\_update\_CertificatePairSet stores the set of cross certificate pairs {\em cpairset} 
in the PSE object {\em CrossCSet}.
\\ [1em]
A call of af\_pse\_open() is not required before calling af\_pse\_update\_CertificatePairSet()
(see af\_pse\_open(3X)).


\subsubsection{af\_pse\_update\_AliasList}
\nm{3X}{af\_pse\_update\_CrlSet}{Update set of Revocation Lists in the PSE}
\label{af_update_CrlSet}
\hl{Synopsis}
\#include $<$af.h$>$

RC {\bf af\_pse\_update\_CrlSet} {\em (crlset)} \\
CrlSet *{\em crlset}; \\
\hl{Parameter}
\parname  {{\em crlset}}
\pardescript  {Set of revocation lists.}

\parname  {{\em Return Value}}
\pardescript  {0 or -1.}
\hl{Description}
af\_pse\_update\_CrlSet stores {\em crlset} in the PSE object {\em CrlSet} 
where {\em crlset} is the set of revocation lists of all certification authorities 
known to the owner of the PSE.
\\ [1em]
A call of af\_pse\_open() is not required before calling af\_pse\_update\_CrlSet()
(see af\_pse\_open(3X)).


\subsubsection{af\_pse\_update\_SerialNumbers}
\nm{3X}{af\_pse\_update\_DName}{Update Name in the PSE}
\label{af_update_DName}
\hl{Synopsis}
\#include $<$af.h$>$ 

RC {\bf af\_pse\_update\_PKRoot} {\em (dname)} \\
DName *{\em dname};
\hl{Parameter}
\parname  {{\em dname}}
\pardescript  {Distinguished name of the PSE owner}

\parname  {{\em Return Value}}
\pardescript  {0 or -1.}
\hl{Description}
af\_pse\_update\_DName stores DName {\em dname} (which comprises the distinguished name
of the PSE owner) in the PSE object {\em Name}.
\\ [1em]
A call of af\_pse\_open() is not required before calling af\_pse\_update\_DName()
(see af\_pse\_open(3X)).

\subsubsection{af\_pse\_update\_PKList}
\nm{3X}{af\_pse\_update\_FCPath}{Update forward certification path in the PSE}
\label{af_update_FCPath}
\hl{Synopsis}
\#include $<$af.h$>$ 

RC {\bf af\_pse\_update\_FCPath} {\em (fcpath)} \\
FCPath *{\em fcpath};
\hl{Parameter}
\parname  {{\em fcpath}}
\pardescript  {Forward Certification Path.}

\parname  {{\em Return Value}}
\pardescript  {0 or -1.}
\hl{Description}
af\_pse\_update\_FCPath stores FCPath {\em fcpath} in the PSE object
{\em FCPath}.
\\ [1em]
A call of af\_pse\_open() is not required before calling af\_pse\_update\_FCPath()
(see af\_pse\_open(3X)).

\subsubsection{af\_pse\_update\_PKRoot}
\nm{3X}{af\_pse\_update\_PKList}{Update list of public verification or encryption keys in the PSE}
\label{af_update_PKList}
\hl{Synopsis}
\#include $<$af.h$>$

RC {\bf af\_pse\_update\_PKList} {\em (type, list)} \\
KeyType {\em type}; \\
PKList *{\em list};
\hl{Parameter}
\parname  {{\em type}}
\pardescript  {Type of the list: \\
                    SIGNATURE: List of known public signature verification keys of communication partners. \\
                    ENCRYPTION: List of known public encryption keys of
                                communication partners.}

\parname  {{\em list}}
\pardescript  {Chained list of public keys.}

\parname  {{\em Return Value}}
\pardescript  {0 or -1.}
\hl{Description}
af\_pse\_update\_PKList stores {\em list}, which is either a PKList or an EKList, 
on the PSE. {\em list} is stored in the PSE object {\em PKList} or {\em EKList}, depending
on {\em type}.
If the PSE where {\em list} is to be stored is restricted to hold a single RSA key pair
for both signature and encryption purposes, however, {\em list} is in any case stored in PSE object {\em PKList}, no
matter what the value of {\em type} is.
\\ [1em]
A call of af\_pse\_open() is not required before calling af\_pse\_update\_PKList()
(see af\_pse\_open(3X)).

\subsubsection{af\_pse\_update\_CrlSet}
\nm{3X}{af\_pse\_update\_PKRoot}{Update top level verification key in the PSE}
\label{af_update_PKRoot}

\hl{Synopsis}
\#include $<$af.h$>$ 

RC {\bf af\_pse\_update\_PKRoot} {\em (pkroot)} \\
PKRoot *{\em pkroot};
\hl{Parameter}
\parname  {{\em pkroot}}
\pardescript  {Top level verification keys (new/old).}

\parname  {{\em Return Value}}
\pardescript  {0 or -1.}

\hl{Description}
af\_pse\_update\_PKRoot stores PKRoot {\em pkroot} in the PSE object {\em PKRoot}.
\\ [1em]
A call of af\_pse\_open() is not required before calling af\_pse\_update\_PKRoot()
(see af\_pse\_open(3X)).

\subsubsection{af\_pse\_update\_DName}
\nm{3X}{af\_pse\_update\_QuipuPWD}{Update X.500 Password in the PSE}
\label{af_update_QuipuPWD}
\hl{Synopsis}
\#include $<$af.h$>$ 

RC {\bf af\_pse\_update\_QuipuPWD} {\em (pwd)} \\
char *{\em pwd};
\hl{Parameter}
\parname  {{\em pwd}}
\pardescript  {X.500 password, used for simple authentication.}

\parname  {{\em Return Value}}
\pardescript  {0 or -1.}
\hl{Description}

af\_pse\_update\_QuipuPWD stores the user's X.500 password, identified by the string {\em pwd}, in the PSE object {\em QuipuPWD}. The characters of {\em pwd} are restricted to those of {\em GraphicString} syntax.  
\\ [1em]
A call of af\_pse\_open() is not required before calling af\_pse\_update\_QuipuPWD()
(see af\_pse\_open(3X)).


\subsubsection{af\_pse\_add\_PK}
\nm{3X}{af\_pse\_update\_SerialNumbers}{Update sequence of serialnumbers on the PSE}
\label{af_update_SerialNumbers}
\hl{Synopsis}
\#include $<$af.h$>$

RC {\bf af\_pse\_update\_SerialNumbers} {\em (serialnums)} \\
SerialNumbers *{\em serialnums}; \\
\hl{Parameter}
\parname  {{\em serialnums}}
\pardescript  {Sequence of serialnumbers.}

\parname  {{\em Return Value}}
\pardescript  {0 or -1.}
\hl{Description}
af\_pse\_update\_SerialNumbers stores {\em serialnums} in the PSE object {\em SerialNumbers},
where {\em serialnums} is the sequence of serialnumbers used by the PSE owning certification
authority. 

af\_pse\_update\_SerialNumbers is called after a certification authority has issued a
certificate and thereby increased the value of the {\em actual} component of its sequence of
serialnumbers. The value of the {\em initial} component remains unchanged.
\\ [1em]
A call of af\_pse\_open() is not required before calling af\_pse\_update\_SerialNumbers()
(see af\_pse\_open(3X)).


\subsubsection{af\_pse\_add\_CertificatePairSet}
\nm{3X}{af\_put\_EncryptedKey}{Decrypt key}
\label{af_put_EncryptedKey}

\hl{Synopsis}

\#include $<$af.h$>$ 

RC {\bf af\_put\_EncryptedKey} {\em (encrypted\_key, plain\_key, decryption\_key\_algid)} \\
EncryptedKey *{\em encrypted\_key}; \\
Key *{\em plain\_key}; \\
AlgId *{\em decryption\_key\_algid};
\hl{Parameter}
\parname  {{\em encrypted\_key}}
\pardescript  {Encrypted key.} 

\parname  {{\em plain\_key}}
\pardescript  {Structure which determines the decrypted key.} 

\parname  {{\em decryption\_key\_algid}}
\pardescript  {Algorithm according to which the decryption will be performed.} 

\parname  {{\em Return Value}}
\pardescript  {0 or -1.}

\hl{Description}

The encrypted key given in {\em encrypted\_key} is decrypted using the
the own secret decryption key, which is stored in the PSE object
{\em DecSKnew} or {\em DecSKold}, respectively. If a single RSA key pair is used for both signature and encryption
purposes, however, the own secret key is stored in the PSE object {\em SKnew} or {\em SKold}, respectively.
The decryption follows the procedure described in Vol. 1, Principles of Security Operations, 
{\em Operation of Encryption}.
The decrypted key is handled according to {\em plain\_key} as follows:

If {\em plain\_key}\pf keyref $=$ 0 and {\em plain\_key}\pf pse\_sel is the NULL pointer, the decrypted key is
returned as BitString in {\em plain\_key}\pf key\pf subjectkey. Memory is provided by the called program. 

If {\em plain\_key}\pf keyref $>$ 0, the decrypted key is stored under this key reference until it is
deleted with sec\_del\_key. 

If {\em plain\_key}\pf keyref $=$ -1, the decrypted key is stored under a key reference which is generated 
by af\_put\_EncryptedKey and returned in {\em plain\_key}\pf keyref. The key remains there until it is deleted
with sec\_del\_key. 

The algorithm identified by {\em decryption\_key\_algid} may be used to determine the algorithm
according to which the decryption of {\em encrypted\_key} shall be performed. {\em decryption\_key\_algid}
supersedes the algorithm identifier inherent to the own secret decryption key.

This function is intended to support the so called ``Hybrid method'' where information which
has to be transmitted confidentially is encrypted with the DES algorithm while the corresponding DES key
is transmitted in RSA encrypted form. af\_put\_EncryptedKey is useful for the receiver
of such a key.

\subsubsection{af\_dir\_enter\_Certificate}
\nm{3X}{af\_sign}{sign octetstring with own signature key}
\label{af_sign}
\hl{Synopsis}
\#include $<$af.h$>$

RC {\bf af\_sign} {\em (in\_octets, signature, more)} \\
OctetString *{\em in\_octets}; \\
Signature *{\em signature}; \\
More {\em more};

RC {\bf af\_OctetString2SignedFile} {\em (file, ostr, withcerts, signai)} \\
char *{\em file};
OctetString *{\em ostr}; \\
Boolean {\em withcerts}; \\
AlgId *{\em sigai};

\hl{Parameter}
\parname  {{\em in\_octets}}
\pardescript  {OctetString of the data to be signed.} 

\parname  {{\em signature}}
\pardescript  {Returned signature. Memory is provided by the called program.}

\parname  {{\em more}}
\pardescript  {MORE: More data will follow for this sign process. \\
                  END: Last data of this sign process.}

\parname  {{\em Return Value}}
\pardescript  {0 or -1.}
\hl{Description}
{\bf af\_sign} is the general purpose sign routine which signs the given
{\em in\_octets} and produces the signature {\em signature}.
In case of {\em more} $=$ MORE or END af\_sign hashes {\em in\_octets} onto
an internal hash value, using the algorithm as described below.
In case of {\em more} $=$ END this hash value is encrypted using key and
algorithm as described below and returned as BitString in {\em signature}\pf signature.
All necessary memory for {\em signature}\pf signature and {\em signature}\pf signAI
will be provided by the called program.

The own secret signature key, which is stored in the PSE
object {\em SKnew} or {\em SignSK}, is used as signature key. 

The algorithm to be used is determined as follows:
\be
\m if {\em signature}\pf signAI\pf objid is not the NULL pointer, the algorithm
   determined by this object identifier is used.
\m otherwise, i.e. if either {\em signature}\pf signAI or {\em signature}\pf signAI\pf objid 
   is the NULL pointer, the algorithm
   associated to the own secret signature key is used.
   In addition, this algorithm identifier is returned in {\em signature}\pf aignAI\pf objid.
   All necessary memory allocation is done by the called program.
\ee

{\bf af\_OctetString2SignedFile} signs the given OctetString {\em ostr}, writes {\em ostr}
to the file {\em file}, and writes the signature as ASN.1-encoded Signature to {\em file}.sig.
If {\em withcerts} is TRUE, the file {\em file}.ctf containing the ASN.1-encoded Certificates
from the PSE (which is the user certificate and the forward certification path) is additionally
written. Files are created, if they don't exist.

\subsubsection{af\_verify}
\nm{3X}{af\_verify}{Verify signature and certificates}
\addtotoc{af\_verify\_Certificates}
\addtotoc{af\_check\_validity}
\addtotoc{af\_SignedFile2OctetString}
\label{af_verify}
\hl{Synopsis}
\#include $<$af.h$>$ 

extern Boolean af\_chk\_crl, af\_access\_directory; \\
extern Verficationresult *verifresult; \\ [1em]
RC {\bf af\_verify} {\em (in\_octets, signature, more, or\_cert, time, pkroot)} \\
OctetString *{\em in\_octets}; \\
Signature *{\em signature}; \\
More {\em more}; \\
Certificates *{\em or\_cert}; \\
UTCTime *{\em time}; \\
PKRoot *{\em pkroot};

RC {\bf af\_verify\_Certificates} {\em (or\_cert, time, pkroot)} \\
Certificates *{\em or\_cert}; \\
UTCTime *{\em time}; \\
PKRoot *{\em pkroot};

RC {\bf af\_check\_validity\_of\_Certificate} {\em (time, certificate)} \\
UTCTime *{\em time}; \\
Certificate *{\em certificate};

RC {\bf af\_check\_validity\_of\_PKRoot} {\em (time, pkroot)} \\
UTCTime *{\em time}; \\
PKRoot *{\em pkroot};

RC {\bf af\_check\_validity\_of\_ToBeSigned} {\em (time, tobesigned)} \\
UTCTime *{\em time}; \\
ToBeSigned *{\em tobesigned};

OctetString {\bf *af\_SignedFile2OctetString} {\em (file)} \\
char *{\em file};

\hl{Parameter}
\parname  {{\em in\_octets}}
\pardescript  {OctetString of the input data for the verification.}

\parname  {{\em signature}}
\pardescript  {Signature to be verified.}

\parname  {{\em more}}
\pardescript  {MORE: More input data will follow for this verification process. \\
                  END: Last input data of this verification process.}

\parname  {{\em or\_cert}}
\pardescript  {Originator Certificate (in form of an X.509 Certificates).}

\parname  {{\em time}}
\pardescript  {Verification time.}

\parname  {{\em pkroot}}
\pardescript  {Structure containing the top level verification key, or NULL pointer.}

\parname  {{\em Return Value}}
\pardescript  {0 (Verification positive) or -1.}
\hl{Description}
{\bf af\_verify} is the general purpose verification routine which verifies the given
{\em signature} of a given {\em in\_octets}, and the whole certification path given
in {\em or\_cert}. 
In case of {\em more} $=$ MORE or END, {\bf af\_verify} hashes {\em in\_octets} onto
an internal hash value, using the algorithm as described below.
In case of {\em more} $=$ END the signature given in {\em signature}\pf signature
is decrypted with the PK contained in the user certificate which in turn is part of the
originator certificate, and the result is compared
with the previously computed internal hash value. The algorithm to be used is either 
{\em signature}\pf signAI, if {\em signature}\pf signAI\pf objid is not the
NULL pointer, or the algorithm belonging to PK of the user certificate. If both hash values
are equal, the verification strategy described below is performed, i.e. the whole certification path
contained in {\em or\_cert} is verified, with the last uncertified public key
contained in {\em pkroot}. If the verification succeeds finally, a return value
of 0 is returned. Otherwise, a return value of -1 is returned, and the certificate which could
not be verified is indicated in af\_error.cert. In either case, it generates the external
variable {\em verifresult} which provides more information about the verification process (see C. Verification Result below).
{\em verifresult} can be printed using aux\_fprint\_VerificationResult(), and can be released
using aux\_free\_VerificationResult(). If {\em verifresult} is not NULL when af\_verify is
called with more $=$ END, af\_verify assumes that this is the verification result of a former call to
af\_verify and releases this address with aux\_free\_VerificationResult.

If {\em time} is not the NULL pointer, it specifies date and time of verification. Otherwise
time and date of verification is the current time.

If {\em pkroot} is not the NULL pointer, it specifies the top level public verification key.
Otherwise the top level verification key is taken from the PSE object {\em PKRoot}. \\ [1em]
{\bf af\_verify\_Certificates} verifies only the the originator certificate {\em or\_cert}.
It produces also the external variable {\em verifresult}.
\\ [1em]
{\bf af\_check\_validity\_of\_Certificate} returns 0 if {\em time} is within the validity interval
of {\em certificate}, otherwise it returns -1.
\\ [1em]
{\bf af\_check\_validity\_of\_PKRoot} returns 0 if {\em time} is within the validity interval
of {\em pkroot}, otherwise it returns -1.
\\ [1em]
{\bf af\_check\_validity\_of\_ToBeSigned} returns 0 if {\em time} is within the validity interval
of {\em tobesigned}, otherwise it returns -1.
\\ [1em]
{\bf af\_SignedFile2OctetString} returns the content of file {\em file} as OctetString
if it can be validated with the signature in {\em file}.sig.
 
If {\em file}.ctf exists, the
content of this file is assumed to be an ASN.1-encoded Certificates (user certificate and
forward certification path) and is being used for the verification. Otherwise the
user certificate Cert/SignCert and the forward certification path FCPath from the PSE
is being used for the verification.

A NULL pointer is returned if {\em file}.sig doesn't exist, or if the verification
fails for any reason.
 
af\_SignedFile2OctetString produces, like af\_verify, the external variable {\em verifresult}. 

\hl{Verification Strategy}

The verification process is ruled by the parameters
{\em or\_cert} and {\em pkroot} and the PSE objects {\em PKList} and {\em FCPath} (if
existent). It is also dependant on the point of time provided by parameter {\em time}, which
specifies the time and date of verification; if there
is no time provided, the verification time is set to the current time.
In addition, the verification process can be controlled by the global boolean variables
{\em af\_chk\_crl}, {\em af\_FCPath\_is\_trusted}, and {\em af\_access\_directory}.
\\ [1em]
{\em pkroot} contains the top level verification key, where top 
level does not necessarily refer to the top level of a certification tree 
(that is, pkroot does not necessarily need to correspond to the
public key of a Root-CA). Instead, {\em top level} refers to that level 
of the certification tree where the recipient wants the verification 
process to terminate; it may identify any of the verifier's points of trust.
{\em top level verification key} then represents the 
public key involved in the last verification step.
If {\em pkroot} is empty, the top level verification key is 
taken from the PSE object {\em PKRoot}.
\\ [1em]
Before the verification process starts, it is checked whether the information stored
in {\em pkroot} has expired (see af\_check\_validity\_of\_PKRoot(3X)). An expired
{\em pkroot} information is indicated by its {\em notafter} field having already
passed.
\\ [1em]
If there is no originator certificate {\em or\_cert} to be evaluated 
by the verifier, the signature contained in {\em signature} is 
validated with the top level verification key derived from {\em pkroot}, 
with no further verification step being applied. In order that the 
verification of {\em signature} be successful, {\em pkroot} must contain the 
originator's public key; the originator who has 
generated the signature may be a user, a CA, or a Root-CA.
If {\em pkroot} is empty, however, the top level verification key is 
taken from the PSE object {\em PKRoot}.
\\ [1em]
If the originator certificate {\em or\_cert} is not empty, it
comprises at least one user certificate and optionally one
forward certification path. If af\_verify was called, the user certificate 
contains the public key required for validating the signature supplied in 
{\em signature}; otherwise, the user certificate identifies the
certificate which is to be validated with the optionally appended
forward certification path.
\\ [1em]
There are two ways of constructing a certification path, starting with the 
originator's certificate and ending with the public key of a CA which the 
verifier trusts: \\
The certification path may be extracted completely from a given certification 
path supplied by the originator (this is discussed in section A). 
However, if the originator has not provided a certification path, or the recipient 
fails to identify a trusted CA within an incoming 
certification path, a Directory (X.500 or .af-db) is accessed in order to build 
(complete) the originator's certification path (this is discussed in detail 
in section B).
\\ [1em]

{\bf A. Construction of a Certification Path from a given Forward Certification Path}
\\ [1em]
If the originator has supplied a FCPath (a detailed discussion on the structure 
of a FCPath is given in Volume 1), the verification
process run by the recipient has to extract an optimal chain of certificates 
from the given FCPath; the chain is optimal if it is as short as possible.
\\ [1em]
The selection of a chain of certificates from a given FCPath is performed
from bottom to top, using a stack of certificates whose initial value
is represented by the user certificate.
\\ [1em]
The PKList and FCPath checks described below are only performed in case that {\em af\_chk\_crl}
is set to FALSE, i.e., no revocation lists are to be consulted. As a further restriction, 
the verifier's PSE object {\em FCPath} is only
considered if {\em af\_FCPath\_is\_trusted} is set to TRUE. Note that the
FCPath check described below will first reduce the verifier's FCPath (stored in PSE object
{\em FCPath}) to a chain of hierarchy certificates (see reduce\_FCPath\_to\_HierarchyPathwhich()) 
which may all be trusted. The FCPath check is useful for optimizing the verification process,
if the originator of the digital signature and its recipient have a common point of trust
within their forward certification paths.
\\ [1em]
If af\_verify was called, the user certificate is considered as follows (if
af\_verify\_Certificates was called, however, the user certificate is considered in the
same manner, except that the PKList and FCPath checks are omitted):
\be
\m Validity \\
It is checked whether the time and date of verification specified by {\em time} lies 
within the validity time frame of the user certificate.
\m CRL Check \\
If {\em af\_chk\_crl} is set to TRUE, the user certificate is checked against the current 
revocation list of its issuer, to ensure that it has not been revoked.
\m PKList \\
If the originator's public signature key held within the user certificate
is trusted and has already been stored in the recipient's PKList (whose
corresponding information was found not to have expired),
the signature is validated with this public key, with there being no stack of 
certificates to be evaluated.
\m FCPath \\
If the user certificate is found in the recipient's PSE object {\em FCPath} (whose
corresponding certificate was found not to have expired), its public
key may be trusted and used for validating the signature, with there being no stack of 
certificates to be evaluated.
\m PKRoot \\
If the issuer of the user certificate corresponds to the CA at the top level
({\em pkroot}), the top level verification key is derived from {\em pkroot}. It is 
used for verifying the user certificate which is the only element of the stack.
\m Cross Check \\
If the issuer of the user certificate has been cross-certified by the own Root CA, the 
reverse component of the relevant cross certificate pair (which may be found in PSE
object {\em CrossCSet}) is appended to the user certificate (added to the stack of certificates), 
and the top level verification key is derived from {\em pkroot} (which then corresponds
to the own Root CA).
\ee
If none of that applies to the user certificate, the incoming forward certification path
is processed from bottom to top, as long as the hierarchy levels being encountered contain
a single certificate only. The processing of the forward certification path stops
at the first hierarchy level that is multi-valued, i.e., that contains more than one
certificate.
Each certificate belonging to a single-valued hierarchy level is considered as described
above, with an additional check on whether it can be verified using the public key held 
within the certificate at the next level above.
\\ [1em]
The following part describes how the certificates of multi-valued FCPath levels are selected
to form part of the chain of certificates which is then submitted to the validation process:
\\ [1em]
Each level of the FCPath contributes exactly one certificate to the stack.
At any level, there are two ways of selecting the certificate which is next to be 
added to the stack: one way shall be called {\em horizontal mode} and refers to the 
set of certificates at that particular level of the FCPath; the other one shall be 
called {\em vertical mode} and refers to the set of certificates at the next level 
above. \\
The certificate that was last added to the stack (starting with the first certificate 
at the first FCPath level that is multi-valued) is considered in the 
following way:
\\ [1em]
Condition A.1: PKList \\
If the public key of the CA representing that level has already been stored in 
the recipient's PKList (whose corresponding information was found not to have expired),
the certificate last added to the stack (owned by that CA) need not be verified 
and is therefore removed from the stack. The CA's public key is used as the 
top level verification key. That completes the construction of the chain of
certificates.
\\ [1em]
Condition A.2: FCPath \\
If the certificate is found in the recipient's PSE object {\em FCPath} (whose corresponding 
information was found not to have expired), its public
key may be trusted and used for validating the signature, with there being no stack of 
certificates to be evaluated.
\\ [1em]
Condition A.3: PKRoot \\
If the issuer of that certificate corresponds to the CA at the top level
({\em pkroot}), the top level verification key is derived from {\em pkroot}.
That completes the construction of the chain of certificates.
\\ [1em]
Condition A.4: Cross Check \\
If the issuer of the certificate being considered has been cross-certified by the own Root CA, the 
reverse component of the relevant cross certificate pair (which may be found in PSE
object {\em CrossCSet}) is added to the stack of certificates, 
and the top level verification key is derived from {\em pkroot} (which then corresponds
to the own Root CA).
\\ [1em]
Condition A.5: Cross or Hierarchy certificate? 
\bi
\m Cross certificate \\
If the certificate last added to the stack is
a cross certificate which does not satisfy any of the conditions A.1 to A.4,
it is removed from the stack, and the next certificate (if existent) within the 
set of certificates at that level is put on top of the stack 
({\em horizontal mode}) and examined in the way described above.
This is repeated until any of the remaining certificates at that level satisfies 
any of the conditions A.1 to A.4, or until a hierarchy certificate is encountered. 
In the latter case, the construction of the stack is continued at the next level 
above ({\em vertical mode}).
\m Hierarchy certificate \\
If the certificate last added to the stack is
a hierarchy certificate, the first certificate in the set of certificates at
the next level above is put on top of the stack and examined in the way
described above ({\em vertical mode}).
\ei
If at a particular level of the FCPath there is no way of selecting
the hierarchy certificate (i.e., the FCPath is incomplete), all certificates at 
that particular level are considered as cross certificates. If they all do not 
satisfy any of the conditions A.1 to A.4, the hierarchy certificate at the previous level 
is removed from the stack, and the construction of the stack is resumed at
the previous level.
It is then examined whether any of the remaining cross certificates at that 
(previous) level satisfies any of the conditions A.1 to A.4 ({\em horizontal mode}).
\\ [1em]
If the hierarchy certificate at the first level of the FCPath has been 
removed from the stack (according to the rule described above), and 
the remaining cross certificates at that level do not satisfy any of the conditions A.1 to A.4, 
the verification process terminates with an error message reporting that 
no chain of certificates could be extracted from the given FCPath, unless
the {\em af\_access\_directory} flag is set (see section B).
\\ [1em]
If a CA trusted by the recipient was identified within an incoming FCPath, the certificates
extracted from the multi-valued hierarchy levels of the forward certification path are
submitted to the following checks:
\bi
\m Each certificate of the constructed stack of certificates is verified using the public 
key held within the
certificate at the next level above, and the highest certificate is  
verified by the top level verification key.
\m If the {\em af\_chk\_crl} flag is set to TRUE, one additional validation step
is required for the certificates establishing the constructed stack of certificates: 
Each certificate is checked against the current revocation list from the 
certificate's issuer to ensure that revoked certificates are not employed. 
This requires at worst one directory access per certificate of a chain. One 
revoked certificate within the certification path discredits all certificates 
below and the user signature as well. If a revoked certificate is encountered,
the verifier is warned, and the verification process terminates with an 
appropriate error message being displayed. \\ [1em]
\ei

{\bf B. Construction of a Certification Path with Directory Support (X.500 or .af-db)}
\\ [1em] 
The recipient may use the information stored in a Directory (X.500 or .af-db) in order to 
construct or complete a certification path from the originator up to one of the recipient's
trusted CAs.
\\ [1em]
A Directory is accessed if the following holds true:
\bi
\m The {\em af\_access\_directory} flag is set;
\m There is no FCPath supplied by the originator, or the FCPath supplied 
by the originator does not contain a certification path that would contain a 
CA trusted by the recipient.
\ei
The originator must supply to the recipient at least its user certificate. An optionally
provided forward certification path is considered as described in section A.
The certificate first submitted to the directory support routine may either be
\bi
\m the user certificate itself (in case that the originator has not provided
its forward certification path, or its forward certification path does not contain a 
CA which the recipient trusts),
\m or the certificate of the highest single-valued level of the originator's FCPath.
\ei
The directory support is carried out as follows:
\\ [1em]
Step 1: Access the directory entry of the issuer of the certificate submitted
to the directory support routine, and return the set of certificates stored in 
its {\em cACertificate} attribute.
\\ [1em]
Step 2: Again, the certification path is built step by step, using a stack of
certificates which in the following is referred to as {\em stack A}.
In addition, a second stack (referred to as {\em stack B}) is managed whose 
elements represent set of certificates. The set of certificates last retrieved 
from the Directory is put on top of this stack. The set of certificates returned 
as result of the first {\em read}-operation (see step 1) forms the initial value 
of stack B.
\\ [1em]
Step 3: A certificate (starting with the first) within the set of certificates
on top of stack B is added to stack A, provided that
\\ [1em]
B.1: it is not yet contained in this stack (this is done in order to avoid
loops in the certification path);

B.2: its validity time frame intersects with the validity time frame of all
certificates contained in this stack;

B.3: it certifies the public key required for the validation of the certificate
at the previous level or the text signature 
(this check has to be performed as certificates held within directory entries 
may refer to different key pairs owned by the same directory object).
\\ [1em]
The certificate last added to stack A is considered in the same way as
described for the case where no directory support is required (see section A): 
\bi
\m If it does not satisfy any of the conditions A.1 to A.4, the {\em cACertificate} attribute 
within the directory entry of its issuer is accessed, and the returned set of 
certificates is put on top of stack B. Then, the procedure described above 
(step 3) is repeated.
\m If it satisfies condition A.1 (PKList), it is removed from stack A, and its 
public key is used as the top level verification key. That completes 
the construction of the certification path.
\m If it satisfies condition A.2 (FCPath), it is removed from stack A, and its 
public key is used as the top level verification key. That completes 
the construction of the certification path.
\m If it satisfies condition A.3 (PKRoot), the top level verification key is 
derived from {\em pkroot}. That completes the construction of the 
certification path.
\m If it satisfies condition A.4 (Cross Check), the 
reverse component of the relevant cross certificate pair (which may be found in PSE
object {\em CrossCSet}) is added to the stack of certificates, and the top level verification key is 
derived from {\em pkroot}. That completes the construction of the 
certification path.
\ei

Step 4: The certificates within the set of certificates on top of stack B
are checked one after the other, until one certificate is found that
satisfies requirements B.1 to B.3 and is therefore added to stack A.
\\ [1em]
Step 5: If none of the certificates within the set of certificates on top
of stack B fulfil requirements B.1 to B.3, it is
examined whether there is a {\em CrossCertificatePair} attribute contained
in the owner's directory entry, where owner refers to the owner ({\em subject})
of the set of certificates which has been completely exploited.
(By taking the {\em CrossCertificatePair} attribute into account, it is ensured
that the certification path under construction terminates at some CA in the
recipient's certification tree, even if the originator belongs to a 
different certification tree.) If the entry under consideration contains such
an attribute, it is checked whether
any of the issuers of the forward certificates are known to the recipient
(PKRoot, PKList, FCPath). If such an issuer is found, its public key represents the
top level verification key; that completes the construction of the 
certification path.

Otherwise (or in case that there is no {\em CrossCertificatePair} attribute 
found within the owner's directory entry), the top elements of the two stacks
are removed from their respective stacks. Then, the procedure described
as step 3 is resumed, its input being the next certificate within the
set of certificates now on top of stack B (for the meaning of {\em next}
see step 4). If there are no further certificates to be considered 
within that set of certificates, the procedure under step 5 is carried out.
\\ [1em]
If all the certificates within the set of certificates representing
the initial value of stack B and even the forward certificates 
retrieved from the {\em CrossCertificatePair} attribute within the
directory entry initially accessed turn out to be inappropriate 
for being members of a certification path, the verification process
terminates with an appropriate error message being displayed.
\\ [1em]
If a chain of certificates has been found, it is validated as described for the
case where no directory support was required. \\ \\
{\bf C. Verification Result}
\\ [1em]
The following C-structures are used for collecting any data generated by the af\_verify
af\_verify\_Certificates routines, monitoring the verification process itself: 

{\small
\btab
\1      typedef struct VerificationResult \{ \\
\2		VerificationStep \2 **verifstep; \\
\2		int \2	             trustedKey; \\
\2		Boolean \2	     success; \\
\2		Boolean \2	     textverified; \\
\2		Name \2		    *top\_name; \\
\2		UTCTime \2 	    *date; \\
\2		int \2		     top\_serial; \\
\1       \} VerificationResult; \\
\etab
}
with: \\ \\
{\small
\btab
\1      typedef struct VerificationStep \{ \\
\2		Certificate \2	*cert; \\
\2		int \2		crlcheck; \\
\2		UTCTime	\2	*date; \\
\2		int \2		supplied; \\
\1       \} VerificationStep; \\
\etab
}

The {\em verifstep} component within the {\em VerificationResult} structure identifies a 
linked list of elements of type {\em VerificationStep}.
Each element of the linked list
\bi
\m identifies a certificate which forms part of the originator's certification path and
that was either successfully verified or failed to be verified
({\em cert});
\m indicates whether the certificate {\em cert} was checked against its issuer's revocation 
list ({\em crlcheck});
\m indicates whether the certificate {\em cert} was supplied within the received certification
path or was retrieved from a Directory (X.500 or .af-db) ({\em supplied});
\m provides the revocation date, in case of the certificate {\em cert} having been revoked
({\em date});
\m provides the next scheduled date of issue, in case of the relevant revoction list being 
obsolete ({\em date}).
\ei

The routine {\bf aux\_fprint\_VerificationResult} is used for printing the contents of the
{\em VerificationResult} structure in a user-friendly manner. Memory allocated for
a {\em VerificationResult} structure can be freed by the {\bf aux\_free\_VerificationResult}
routine.

\subsubsection{af\_gen\_key}
\nm{3X}{aux\_DName}{Distinguished Name Handling}
\label{aux_name}
\hl{Synopsis}

\#include $<$isode/psap.h$>$ \\
\#include $<$secure.h$>$ \\
\#include $<$IF-types.h$>$ 

DName *{\bf aux\_Name2DName} {\em (name)} \\
char {\em *name};

char *{\bf aux\_DName2Name} {\em (dname)} \\
DName {\em *dname};

int {\bf aux\_cmp\_DName} {\em  (dname1, dname2)} \\
DName {\em *dname1, *dname2};

int {\bf aux\_cmp\_Name} {\em  (name1, name2)} \\
Name {\em *name1, *name2};

int {\bf aux\_checkPemDNameSubordination} {\em  (sup, sub)} \\
DName {\em *sup, *sub};

\hl{Description}
{\bf aux\_Name2DName} and {\em aux\_DName2Name} transform between
the printable character string representation {\em Name} and the
C-structure {\em DName} of distinguished names. 

{\bf aux\_cmp\_DName} compares the two DName *dname1 and *dname2.
If they represent the same distinguished names,
0 is returned, otherwise 1. 

{\bf aux\_cmp\_Name} compares the two Name *name1 and *name2 by
transforming the printable character string representation {\em name1} 
and {\em name2} into DName structure representations using
{\em aux\_Name2DName()} and applying {\em aux\_cmp\_DName()}
afterwards.
If they represent the same distinguished names,
0 is returned, otherwise 1.

{\bf aux\_checkPemDNameSubordination} compares the two DName structures {\em *sup} and {\em *sub}.
1 is returned, 
if {\em sub} is subordinate to {\em sup} in the DIT, i.e., {\em sub} is constructed of exactly the same
Relative Distinguished Name components as {\em sup}, with some additional Relative Distinguished Name
components appended.
If subordination is not detected, 0 is returned. -1 is returned in case of invalid parameters.\\
This routine is useful in the context of the PEM trust model (RFC 1422), where 
Organizational CAs are expected to sign certificates only if the subject distinguished
name in the certificate is subordinate to their own distinguished name, thereby 
documenting the subject's affiliation to the organization.

\subsection{Error Handling}
\nm{3X}{aux\_UTCTime}{UTCTime handling Functions}
\label{aux_time}
\hl{Synopsis}

\#include $<$secure.h$>$

extern Boolean aux\_localtime;

UTCTime *{\bf aux\_current\_UTCTime} {\em ()}

UTCTime *{\bf aux\_delta\_UTCTime} {\em (utctime)} \\
UTCTime *{\em utctime}; 

int {\bf aux\_interval\_UTCTime} {\em (utctime, notbefore, notafter)} \\
UTCTime *{\em utctime}; \\ 
UTCTime *{\em notbefore}; \\ 
UTCTime *{\em notafter};

int {\bf aux\_cmp\_UTCTime} {\em (utctime1, utctime2)} \\
UTCTime *{\em utctime1}; \\
UTCTime *{\em utctime2}; 

char *{\bf aux\_readable\_UTCTime} {\em (utctime)} \\
UTCTime *{\em utctime}; 

\hl{Description}
{\bf aux\_current\_UTCTime} returns the current time in UTCTime format. If
{\em aux\_localtime} is TRUE, the time is generated as local time (plus
or minus the time difference to GMT), otherwise it is generated as GMT.

{\bf aux\_delta\_UTCTime} returns {\em utctime} plus 1 year, or NULL if
{\em utctime} is invalid. The returned UTCTime is in the local time format
if {\em aux\_localtime} is true and in the GMT format otherwise. 

{\bf aux\_interval\_UTCTime} returns 0 if {\em utctime} is inside the interval
between {\em notbefore} and {\em notafter} (including the boundaries), or 1 if
it is outside. It returns -1 if one of the given UTCTimes is invalid.

{\bf aux\_cmp\_UTCTime} returns 1 if {\em utctime1} is later than {\em utctime2}.
It returns 2 if {\em utctime2} is later than {\em utctime1}. It returns 0
if both times are equal. It returns -1 if one of the UTCTimes is invalid.

{\bf aux\_readable\_UTCTime} returns {\em utctime} is printable character string
as produced by {\em ctime()}, however without trailing newline character. It
returns NULL is {\em utctime} is invalid.

Input parameters in UTCTime format can be both in GMT or local time format. The
format of output parameters in UTCTime format is controlled by {\em aux\_localtime}.
Necessary memory is allocated by the called program and can be freed using
{\em free()}.

\subsection{Distinguished Name Handling}
\nm{3X}{aux\_algorithms}{Algorithms and Object Identifiers}
\label{aux_aid}
\hl{Synopsis}

\#include $<$secure.h$>$ 

char {\bf *aux\_ObjId2Name} {\em (oid)} \\
ObjId {\em *oid};

AlgId {\bf *aux\_ObjId2AlgId} {\em (oid)}  \\
ObjId {\em *oid};

ParmType {\bf aux\_ObjId2ParmType} {\em (oid)} \\
ObjId {\em *oid};

AlgType {\bf aux\_ObjId2AlgType} {\em (oid)}  \\
ObjId {\em *oid};

AlgEnc {\bf aux\_ObjId2AlgEnc} {\em (oid)}  \\
ObjId {\em *oid};

AlgHash {\bf aux\_ObjId2AlgHash} {\em (oid)}  \\
ObjId {\em *oid};

AlgMode {\bf aux\_ObjId2AlgMode} {\em (oid)}  \\
ObjId {\em *oid};

AlgSpecial {\bf aux\_ObjId2AlgSpecial} {\em (oid)}  \\
ObjId {\em *oid};

ObjId {\bf *aux\_Name2ObjId} {\em (name)}  \\
char {\em *name};

AlgId {\bf *aux\_Name2AlgId} {\em (name)}  \\
char {\em *name};

ParmType {\bf aux\_Name2ParmType} {\em (name)} \\
char {\em *name};

AlgType {\bf aux\_Name2AlgType} {\em (name)}  \\
char {\em *name};

AlgEnc {\bf aux\_Name2AlgEnc} {\em (name)}  \\
char {\em *name};

AlgHash {\bf aux\_Name2AlgHash} {\em (name)}  \\
char {\em *oid};

\hl{Description}
These routines provide values associated to algorithms in the global
algorithm list {\em alglist} (see SEC(5)).

The parameter type ParmType is one of 
\bi
\m PARM\_NULL, indicating that the algorithm has no parameter,
\m PARM\_INTEGER, indicating a parameter of type INTEGER,
\m PARM\_OctetString, indicating a parameter of type OctetString.
\ei
The algorithm type AlgType is one of                                                   
\bi
\m SYM\_ENC, indicating a symmetric encryption algorithm,
\m ASYM\_ENC, indicating an asymmetric encryption algorithm,
\m HASH, indicating a hash algorithm,
\m SIG, indicating a signature algorithm,
\m OTHER, indicating other type of algorithm.
\ei
The algorithm encryption method AlgEnc is one of 
\bi
\m RSA, indicating RSA algorithm,
\m DES, indicating DES algorithm,
\m DES3, indicating DES3 algorithm,
\m ELGAMAL, indicating ElGamal algorithm,
\m NOENC, indicating other algorithms, e.g. hash algorithms,
\ei
The algorithm hash method AlgHash is one of 
\bi
\m SQMODN
\m MD2
\m MD4
\m MD5
\m SHS
\m NOHASH, indicating other algorithms, e.g. encryption algorithms,
\ei
The algorithm mode AlgMode is one of 
\bi
\m ECB
\m CBC
\m NOMODE, indicating no modes are defined for this algorithm,
\ei
AlgMode is currently used only for DES algorithms.

The algorithm specials AlgSpecial is one of 
\bi
\m WITH\_PADDING
\m WITH\_PEM\_PADDING
\m PKCS\_BT\_01
\m PKCS\_BT\_02
\m NOSPECIAL, indicating no special features are defined for this algorithm,
\ei
The padding features are defiend for DES algorithms. PKCS\_BT\_01 means PKCS\#1
defined block encoding of block type 01. PKCS\_BT\_02 means PKCS\#1 defined block
encoding of block type 02.

Parameter {\em oid} denotes an algorithm's object identifier, parameter
{\em name} denotes an algorithm's name. Valid algorithm names and object 
identifiers can be found in INTRO(3X) under Algorithms.

The above functions map between the indicated parameters.

\subsection{Free Allocated Space}
\nm{3X}{aux\_alias}{Alias Name Mapping}
\label{aux_alias}
\hl{Synopsis}

\#include $<$af.h$>$ 

DName *{\bf aux\_alias2DName} {\em (alias)} \\
char *{\em alias}; 

Name *{\bf aux\_alias2Name} {\em (alias)} \\
char *{\em alias}; 

char *{\bf aux\_DName2alias} {\em (dname, type)} \\
DName *{\em dname}; \\
AliasType {\em type}; 

char *{\bf aux\_Name2alias} {\em (name, type)} \\
Name *{\em name}; \\
AliasType {\em type}; 

char *{\bf aux\_Name2aliasf} {\em (name, type, aliasf)} \\
Name *{\em name}; \\
AliasType {\em type}; \\
AliasFile {\em aliasf};

char *{\bf aux\_DName2aliasf} {\em (dname, type, aliasf)} \\
DName *{\em dname}; \\
AliasType {\em type}; \\
AliasFile {\em aliasf};

Name *{\bf aux\_search\_AliasList} {\em (name, pattern)} \\
Name *{\em name}; \\
char *{\em pattern};

RC *{\bf aux\_add\_alias} {\em (alias, dname, aliasf, prior, writef)} \\
char *{\em alias}; \\ 
DName *{\em dname}; \\
AliasFile {\em aliasf}; \\
Boolean prior; \\
Boolean writef;

RC *{\bf aux\_add\_alias\_name} {\em (alias, name, aliasf, prior, writef)} \\
char *{\em alias}; \\ 
Name *{\em name}; \\
AliasFile {\em aliasf}; \\
Boolean prior; \\
Boolean writef;

RC *{\bf aux\_delete\_alias} {\em (alias, aliasf, writef)} \\
char *{\em alias}; \\
AliasFile {\em aliasf}; \\
Boolean writef;

void {\bf aux\_put\_AliasList} {\em (aliasf)} \\
AliasFile {\em aliasf}; 

Boolean *{\bf aux\_alias} {\em (alias)} \\
char *{\em alias}; 

Boolean *{\bf aux\_alias\_chkfile} {\em (alias, aliasf)} \\
char *{\em alias}; \\
AliasFile {\em aliasf};

Name *{\bf aux\_next\_AliasList} {\em (name)} \\
Name *{\em name};

Name *{\bf aux\_alias\_nxtname} {\em (reset)} \\
Boolean {\em reset};

char *{\bf aux\_alias\_getall} {\em (name)} \\
Name *{\em name};

char *{\bf aux\_fprint\_alias2dname} {\em (file, pattern)} \\
FILE *{\em file}; \\
char *{\em pattern}; 

char *{\bf aux\_fprint\_dname2alias} {\em (file, pattern)} \\
FILE *{\em file}; \\
char *{\em pattern};

AliasList *{\bf d\_AliasList} {\em (ostr)} \\
OctetString *{\em ostr};

OctetString *{\bf e\_AliasList} {\em (alist, aliasf)} \\
AliasList *{\em alist}; \\
AliasFile *{\em aliasf};

void {\bf aux\_free\_AliasList} {\em (alist)} \\
AliasList **{\em alist};

RC {\bf aux\_fprint\_AliasList} {\em (file, alist)} \\
FILE *{\em file}; \\
AliasList *{\em alist};

\hl{Description}
Alias names for distinguished names can be defined on a per user basis in either the PSE-object
AliasList or in the file \$HOME/.af-alias, and on a per system basis in the file
\$TOP/secude/.af-db/.af-alias. If the PSE-object AliasList exists, user-defined aliases
are taken from there, otherwise user-defined aliases are taken from \$HOME/.af-alias.

More than one alias name may be defined for one target name. The target name must be a
distinguished name, either in the Name or in the DName form. The alias names are
stored in an ASN.1 encoded OctetString which decodes into the internal structure
\begin{verbatim}
struct aliaslist {
        struct aliases {
                char          *aname; /* alias names */
                AliasFile  aliasfile; /* SYSTEM or USER Alias File */
                struct aliases *next;
        } *a;
        Name    *dname;               /* distinguished name */
        struct aliaslist *next;
};
typedef struct aliaslist AliasList;
typedef struct aliases Aliases;
\end{verbatim}
If the ASN.1 encoded OctetString is stored in the files \$HOME/.af-alias and \$TOP/secude/.af-db/.af-alias as signed file in order to protect its integrity.
The signature is verified when reading these files and newly generated when
writing these files. If the ASN.1 encoded OctetString is stored as PSE-object
AliasList, the PSE protection mechanism is used to protect its integrity.

{\em type} is an enumerated data type which may have one
of the values ANYALIAS, RFCMAIL, X400MAIL, or LOCALNAME. This allows to distinguish
different types of aliases through their syntax. An RFCMAIL type is an alias name which
contains a '@' character. An X400MAIL type is an alias which contains a '=' character.
A LOCALNAME type is an alias which contains neither a '@' nor a '=' character (a login
name, for instance).
ANYALIAS just refers to the first alias which may be of any type.
AliasFile is an enumerated data type which may have the values useralias
or systemalias. useralias refers to the user alias file, systemalias refers
to the system alias file.

On the first call of a routine which transform aliases to DNames or vice versa, the user 
alias file and the system alias file are read into an internal AliasList which
consists of memory obtained through malloc(). The alias transformation
routines return copies of this AliasList. The AliasList can be released
with {\em aux\_free\_AliasList ((AliasList **)0)}. All Names, DNames and alias names returned by 
the alias routines can be freed with the appropriate free routines. The alias routines 
maintain an internal pointer to the ``current'' entry.  

{\bf aux\_alias2Name} searches for {\em alias} in the AliasList
and returns the corresponding target
(a distinguished name in Name format). If {\em alias}
is not found as alias entry, it returns {\em alias} itself. Since an alias name can be
of the Name form (e.g. in the case of X.400 OR-names being aliases to DNames, see the second 
example above), the comparison of alias names is done on the basis of the DName type to which
the printable Name forms are transformed by {\em af\_alias2Name()}.
Keywords which do not
denote a SecuDE recognized DN attribute, like PRMD and ADMD in the example above,
are ignored for this comparison. This allows to define X.400 OR-names as alias names
for distinguished names.

Since the return value of {\bf aux\_alias2Name} does not allow to distinguish whether
{\em alias} is a defined alias name or not, the function {\bf aux\_alias} can be
used to decide this. {\bf aux\_alias} returns TRUE is {\em alias} is in the AliasList,
otherwise it returns FALSE. {\bf aux\_alias\_chkfile} does the same as aux\_alias
except that it checks only alias from the given alias file.

In the example above, af\_alias2Name("grimm") would return 

"C=DE; O=gmd; OU=I2; CN=R. Grimm".
\\ [1em]
{\bf aux\_alias2DName} returns the corresponding DName if {\em alias} is found in
the alias file. If {\em alias} is not found, 
it returns the DName which is obtained
through transforming {\em alias} itself to the DName type. If this fails, Null is
returned.
\\ [1em]
{\bf aux\_DName2alias} returns the first alias name of type {\em type} given to {\em dname}.
It returns Null if {\em dname} is not found as a target name in the alias list, 
or it has no
alias of the requested type. 
\\ [1em]
{\bf aux\_Name2alias} returns the first alias name of type {\em type} given to {\em name}.
It returns Null if {\em name} is not found as a target name in the alias list, 
or it has no
alias of the requested type. 
\\ [1em]
{\bf aux\_Name2aliasf} is like aux\_Name2alias except that it looks only for aliases
which are defined in the requested AliasFile, i.e. which are either system aliases
or user aliases. 
\\ [1em]
{\bf aux\_DName2aliasf} is like aux\_Name2aliasf except that it handles a DName
instead of a Name
\\ [1em]
{\bf aux\_add\_alias} adds the given {\em alias} and {\em dname} combination to
the alias file indicated by {\em file}. {\em prior} $=$ TRUE, the new alias is
chained to the first position, otherwise it is chained to the last position.
If {\em writef} $=$ TRUE, the corresponding alias file is updated immediately.
If {\em writef} $=$ FALSE, only the internal AliasList is changed. To update
the corresponding alias file, {\bf aux\_put\_AliasList} {\em (file)} must be
used. Aux\_add\_alias returns 0 on success. It returns 0, too, if the
given combination exists already in the alias file. Otherwise, it returns -1.
\\ [1em]
{\bf aux\_add\_alias\_name} does the same as {\bf aux\_add\_alias} except that
it handles a Name instead of a DName.
\\ [1em]
{\bf aux\_delete\_alias} deletes the given {\em alias} from the alias file (either from
the USER alias file or from the SYSTEM alias file, depending where it came from).
{\em writef} has the same meaning as above.
\\ [1em]
{\bf aux\_search\_AliasList} returns a name which contains {\em pattern} in any of
its attributes. If the input parameter {\em name} is a string of length zero,
it searches from the ``current'' position. At the end of the AliasList it starts
again at the begin of the AliasList and searches at most until to the position
which was ``current'' when aux\_search\_AliasList was called. If {\em name} is the 
NULL pointer, ``current'' is set to the begin of the AliasList before the search starts.
If {\em name} is a Name, it starts the search after this position. The AliasList
is sorted in alphabetic order of the target which is a distinguished name in the Name form.
\\ [1em]
{\bf aux\_next\_AliasList} is like aux\_search\_AliasList except that it doesn't searh
for a pattern but returns just the next name. 
\\ [1em]
{\bf aux\_alias\_nxtname} has its own ``current'' pointer which is independent of that
of the other functions. It returns the next name after this ``current'' and increments
its ``current''. In contrast to the other routines it does not wrap over the end of
the AliasList, but returns a NULL pointer in case that the end of the AliasList
is reached and sets its ``current'' to the begin of the AliasList. If{\em reset} is TRUE,
it returns the first name of the AliasList and sets its ``current'' to top.
\\ [1em]
{\bf aux\_alias\_getall} returns all aliases of the given name in one character string.
The aliases are separated by ':' characters.
\\ [1em]
{\bf aux\_fprint\_alias2dname} searches alias names which contain {\em pattern} and
prints one line per hit of the form
\bc
{\em aliasname} - - -$>$ $<${\em distinguished name}$>$
\ec
to file pointer {\em file}.
\\ [1em]
{\bf aux\_fprint\_dname2alias} searches distinguished names which contain {\em pattern} and
prints one line per hit of the form
\bc
$<${\em distinguished name}$>$ - - -$>$  {\em aliasname}
\ec
to file pointer {\em file}.

The following routines are intended for SecuDE-internal use. {\bf d\_AliasList} decodes the
given OctetString {\em ostr} into an AliasList structure. {\bf e\_AliasList} does the reverse
process, whereby it encodes only those aliases of which the source is the same as the
indicated AliasFile {\em aliasf}, i.e. it encodes only the user aliases if aliasf $=$ useralias,
or only the system aliases if aliasf $=$ systemalias. {\bf aux\_free\_AliasList} frees
the given {\em alist}, and {\bf aux\_fprint\_AliasList} prints the given {\em alist}
to the given {\em file}.

\subsection{UTCTime handling Functions}
\nm{3X}{aux\_cpy}{Copy and Compare}
\label{aux_cpy}
\hl{Synopsis}

\#include $<$secure.h$>$
 
ObjId {\bf *aux\_cpy\_ObjId} {\em (oid)} \\
ObjId {\em *oid};

int {\bf aux\_cpy2\_ObjId} {\em (dup\_oid, oid)} \\
ObjId {\em *dup\_oid, *oid};

int {\bf aux\_cmp\_ObjId} {\em (oid1, oid2)} \\
ObjId {\em *oid1, *oid2};

AlgId {\bf *aux\_cpy\_AlgId} {\em (aid)} \\
AlgId {\em *aid};

int {\bf aux\_cpy2\_AlgId} {\em (dup\_aid, aid)} \\
AlgId {\em *dup\_aid, *aid};

int {\bf aux\_cmp\_AlgId} {\em (aid1, aid2)} \\
AlgId {\em *aid1, *aid2};

KeyInfo {\bf *aux\_cpy\_KeyInfo} {\em (keyinfo)} \\
KeyInfo {\em *keyinfo};

int {\bf aux\_cpy2\_KeyInfo} {\em (dup\_keyinfo, keyinfo)} \\
KeyInfo {\em *dup\_keyinfo, *keyinfo};

int {\bf aux\_cmp\_KeyInfo} {\em (keyinfo1, keyinfo2)} \\
KeyInfo {\em *keyinfo1, *keyinfo2};

Certificate {\bf *aux\_cpy\_Certificate} {\em (certificate)} \\
Certificate {\em *certificate};

int {\bf aux\_cpy2\_Certificate} {\em (dup\_certificate, certificate)} \\
Certificate {\em *dup\_certificate, *certificate};

int {\bf aux\_cmp\_DName} {\em  (dname1, dname2)} \\
DName {\em *dname1, *dname2};

DName *{\bf aux\_cpy\_DName} {\em  (dname)} \\
DName {\em *dname};

int {\bf aux\_cpy2\_DName} {\em (dup\_dname, dname)} \\
DName {\em *dup\_dname, *dname};

RevCert *{\bf aux\_cpy\_RevCert} {\em  (revcert)} \\
RevCert {\em *revcert};

Crl *{\bf aux\_cpy\_Crl} {\em  (crl)} \\
Crl {\em *crl};

RevCertPem *{\bf aux\_cpy\_RevCertPem} {\em  (revcertpem)} \\
RevCertPem {\em *revcertpem};

PemCrl *{\bf aux\_cpy\_PemCrl} {\em  (pemcrl)} \\
PemCrl {\em *pemcrl};

CertificatePair *{\bf aux\_cpy\_CertificatePair} {\em  (cpair)} \\
CertificatePair {\em *cpair};

OCList *{\bf aux\_cpy\_OCList} {\em  (oclist)} \\
OCList {\em *oclist};
\hl{Description}
{\bf aux\_cpy\_ObjId} creates a structure ObjId, copies the value
of {\em oid} into it and returns it.
                   
{\bf aux\_cpy2\_ObjId} copies the value of {\em oid} into {\em dup\_oid}
and returns 0 on success, -1 on error.

{\bf aux\_cmp\_ObjId} returns 0 if {\em oid1} and {\em oid2} are equal,
and 1 otherwise.

{\bf aux\_cpy\_AlgId} creates a structure AlgId, copies the value
of {\em aid} into it and returns it.

{\bf aux\_cpy2\_AlgId} copies the value of {\em aid} into {\em dup\_aid}
and returns 0 on success, -1 on error.

{\bf aux\_cmp\_AlgId} returns 0 if {\em aid1} and {\em aid2} are equal
(both in the Object Identifiers and parameters),
and 1 otherwise.

{\bf aux\_cpy\_KeyInfo} creates a structure KeyInfo, copies the value
of {\em keyinfo} into it and returns it.

{\bf aux\_cpy2\_KeyInfo} copies the value of {\em keyinfo} into {\em dup\_keyinfo}
and returns 0 on success, -1 on error.

{\bf aux\_cmp\_KeyInfo} returns 0
if {\em keyinfo1} and {\em keyinfo2} are equal
(in the Object Identifiers, parameters, and BitStrings of keys),
and 1 otherwise.

{\bf aux\_cpy\_Certificate} creates a structure Certificate, copies the value
of {\em certificate} into it and returns it.

{\bf aux\_cpy2\_Certificate} copies the value of {\em certificate} into {\em dup\_certificate}
and returns 0 on success, -1 on error.

{\bf aux\_cmp\_DName} compares the two DName *dname1 and *dname2.
If they represent the same distinguished names,
0 is returned, otherwise 1. \\
The comparison is attribute-wise
and regards upper and lower cases equal.

{\bf aux\_cpy\_DName} copies {\em dname} into a newly generated and
allocated DName structure which is returned. It returns NULLDNAME
if {\em dname} is not a valid DName.

{\bf aux\_cpy2\_DName} copies the value of {\em dname} into {\em dup\_dname}
and returns 0 on success, -1 on error.

{\bf aux\_cpy\_RevCert} creates a structure RevCert, copies the value
of {\em revcert} into it and returns it.

{\bf aux\_cpy\_Crl} creates a structure Crl, copies the value
of {\em crl} into it and returns it.

{\bf aux\_cpy\_RevCertPem} creates a structure RevCertPem, copies the value
of {\em revcertpem} into it and returns it.

{\bf aux\_cpy\_PemCrl} creates a structure PemCrl, copies the value
of {\em pemcrl} into it and returns it.



\subsection{Algorithm and Object Identifiers}
\nm{3X}{aux\_enchex}{Zoning, Text Transformations}
\label{aux_encdec}
\hl{Synopsis}

\#include $<$secure.h$>$
 
OctetString  {\bf *aux\_enchex} {\em (text)} \\
OctetString {\em *text};

OctetString  {\bf *aux\_dechex} {\em (hexa)} \\
OctetString {\em *hexa};

OctetString  {\bf *aux\_encap} {\em (text)} \\
OctetString {\em *text};

OctetString  {\bf *aux\_decap} {\em (ap)} \\
OctetString {\em *ap};

OctetString  {\bf *aux\_encrfc} {\em (text)} \\
OctetString {\em *text};

OctetString  {\bf *aux\_decrfc} {\em (pren)} \\
OctetString {\em *pren};

OctetString  {\bf *aux\_rfc2hex} {\em (pren)} \\
OctetString {\em *pren};

OctetString  {\bf *aux\_hex2rfc} {\em (hexa)} \\
OctetString {\em *hexa};

OctetString  {\bf *aux\_hex2ap} {\em (hexa)} \\
OctetString {\em *hexa};

OctetString  {\bf *aux\_ap2hex} {\em (ap)} \\
OctetString {\em *ap};

OctetString  {\bf *aux\_rfc2ap} {\em (pren)} \\
OctetString {\em *pren};

OctetString  {\bf *aux\_ap2rfc} {\em (ap)} \\
OctetString {\em *ap};
\hl{Description}
All zoning and transformation functions transform the character string
of the input OctetString
and return the result in a newly created OctetString which
can be freed by aux\_free\_OctetString().

{\bf aux\_enchex} encodes the content of {\em text}
into a hexadecimal {\em 0--9 A--F} representation.
The returned OctetString has the length
$(text$\pf $noctets)*2$ .

{\bf aux\_dechex} decodes the hexadecimal {\em 0--9 A--F}
representation in {\em hexa}
into the original octets.
The returned OctetString has the length
$(hexa$\pf $noctets)/2$ .

{\bf aux\_encap} encodes the content of {\em text}
into a hexadecimal {\em A--P} representation.
The returned OctetString has the length
$(text$\pf $noctets)*2$ .

{\bf aux\_decap} decodes the hexadecimal {\em A--P}
representation in {\em ap}
into the original octets.
The returned OctetString has the length
$(ap$\pf $noctets)/2$ .

{\bf aux\_encrfc} encodes the content of {\em text}
according to the encoding rules of RFC 1421
resulting in a ``printable encoding''. \\
The length of the returned OctetString is at most
$(text$\pf $noctets)*4/3+4$ .

{\bf aux\_decrfc} decodes the ``printable encoding'' in {\em pren}
according to the encoding rules of RFC 1421. \\
The length of the returned OctetString is at most
$(pren$\pf $noctets)*3/4+1$ .

{\bf aux\_rfc2hex, aux\_hex2rfc, aux\_hex2ap, aux\_ap2hex,
aux\_rfc2ap,} and {\bf aux\_ap2rfc}
transform between the three different printable encodings of
octet strings. ``2'' stands for ``to'' and gives the direction
of the transformation, e.g.
{\em aux\_hex2rfc} transforms the hexadecimal {\em 0--9, A--F}
representation of two printable characters per one octet
into the printable encoding according to RFC 1421 of
four printable characters per three octets. Etc.

\subsection{OctetString Handling}
\nm{3X}{aux\_error}{Error Handling}
\label{aux_error}
\hl{Synopsis}

\#include $<$af.h$>$ 


extern struct ErrStack *err\_stack; 


void {\bf aux\_add\_error} {\em (number, text, addr, addrtypr, proc)} \\
int {\em number}; \\
char {\em *text, *addr}; \\
Struct\_No {\em addrtype}; \\
char {\em *proc}; \\ [1em]
void {\bf aux\_fprint\_error} {\em (file, last\_only)} \\
FILE {\em *file}; \\
int {\em last\_only}; \\ [1em]
void {\bf aux\_free\_error} {\em ()} \\ [1em]
int {\bf aux\_last\_error} {\em ()}
\hl{Description}
For error reporting purposes, SecuDE provides an error stack which collects all
errors which occured during the processing of Secude functions. This stack is not
intended to be exploited by normal users, but for the experienced user or programmer,
who is rougly familiar with the program code, it provides some backtracing
functionality in case of errors. The stack can be lengthy depending on the depth
of nested function calls.  

The error stack has the following form: 

\bvtab
\2 typedef struct \{ \\
\4        int  \4            e\_number; \\
\4        char \4           *e\_text;   \\
\4        char \4           *e\_addr;   \\
\4        Struct\_No   \4     e\_addrtype; \\
\4        char \4           *e\_proc;   \\
\4        struct ErrStack  \4 *next;   \\
 \2 \} ErrStack; \\ 
\evtab

The error stack is ordered most recent first.
 
The global variable {\em err\_stack}
is the pointer to the error stack. $err\_stack = NULL$ indicates that no error occured so far.

The error stack holds the following information per entry:

{\em e\_number} is the corresponding error number (see INTRO(3)), {\em e\_text} is an additional
explanatory text. {\em addr} can be either NULL or the address of a data element (i. e. 
structure address) which is interesting in conjunction with the error. {\em addrtype} is the
type of {\em addr} (see secure.h for appropriate values). {\em proc} is the name of the 
routine where the error occured.
\\ [1em]
{\em aux\_add\_error()} adds an entry to the error stack. It allocates the necessary memory.
\\ [1em]
{\em aux\_fprint\_error()} prints the current error stack in suitable form to file pointer {\em file}.
If {\em last\_only} is not NULL, only the most recent entry is printed.
\\ [1em]
{\em aux\_free\_error()} frees the error stack and sets err\_stack to NULL.
\\ [1em]
{\em aux\_last\_error()} returns the error number of the most recent error, or 0 if
no error occured.

\nm{3X}{aux\_fprint}{Printing af-objects, sec-objects and pem-objects}
\label{aux_printostring}
\hl{Synopsis}

\#include $<$stdio.h$>$ \\
\#include $<$secure.h$>$ \\ [1em]
void {\bf aux\_fprint\_OctetString} {\em (file, ostr)} \\
FILE {\em *file}; \\
OctetString {\em *ostr};

void {\bf aux\_fprint\_BitString} {\em (file, bstr)} \\
FILE {\em *file}; \\
BitString {\em *bstr};

void {\bf aux\_xdump} {\em (buffer, len, addrtype)}  \\
void {\bf aux\_fxdump} {\em (dump\_file, buffer, len, addrtype)}  \\
char {\em *buffer}; \\
int  {\em len, addr\_type}; \\
FILE*{\em dump\_file};

{\bf aux\_fprint\_PSESel} {\em (file, pse)} \\
FILE {\em *file}; \\
PSESel {\em *pse};

{\bf aux\_fprint\_PSEToc} {\em (file, psetoc)} \\
FILE {\em *file}; \\
PSEToc {\em *psetoc};

{\bf aux\_fprint\_KeyBits} {\em (file, keybits)} \\
FILE {\em *file}; \\
KeyBits {\em *keybits};

{\bf aux\_fprint\_KeyInfo} {\em (file, keyinfo)} \\
FILE {\em *file}; \\
KeyInfo {\em *keyinfo};

{\bf aux\_fprint\_AlgId} {\em (file, algid)} \\
FILE {\em *file}; \\
AlgId {\em *algid};

{\bf aux\_fprint\_ObjId} {\em (file, objid)} \\
FILE {\em *file}; \\
ObjId {\em *objid};
\\ [1em]
\#include $<$stdio.h$>$ \\
\#include $<$af.h$>$ \\ [1em]
{\bf aux\_fprint\_ToBeSigned} {\em (file, tobesigned)} \\
FILE {\em *file}; \\
ToBeSigned {\em *tobesigned};

{\bf aux\_fprint\_Certificate} {\em (file, certificate)} \\
FILE {\em *file}; \\
Certificate {\em *certificate};

{\bf aux\_fprint\_CertificateSet} {\em (file, certset)} \\
FILE {\em *file}; \\
SET\_OF\_Certificate {\em *certset};

{\bf aux\_fprint\_Certificates} {\em (file, certificates)} \\
FILE {\em *file}; \\
Certificates {\em *certificates};

{\bf aux\_fprint\_FCPath} {\em (file, fcpath)} \\
FILE {\em *file}; \\
FCPath {\em *fcpath};

{\bf aux\_fprint\_PKRoot} {\em (file, pkroot)} \\
FILE {\em *file}; \\
PKRoot {\em *pkroot};

{\bf aux\_fprint\_PKList} {\em (file, pklist)} \\
FILE {\em *file}; \\
PKList {\em *pklist};

{\bf aux\_fprint\_Crl} {\em (file, crl)} \\
FILE {\em *file}; \\
Crl {\em *crl};

{\bf aux\_fprint\_RevCert} {\em (file, revcert)} \\
FILE {\em *file}; \\
RevCert {\em *revcert};

{\bf aux\_fprint\_PemCrl} {\em (file, pemcrl)} \\
FILE {\em *file}; \\
PemCrl {\em *pemcrl};

{\bf aux\_fprint\_RevCertPem} {\em (file, revcertpem)} \\
FILE {\em *file}; \\
RevCertPem {\em *revcertpem};

{\bf aux\_fprint\_CrlSet} {\em (file, crlset)} \\
FILE {\em *file}; \\
CrlSet {\em *crlset};

{\bf aux\_fprint\_CrlPSE} {\em (file, crlpse)} \\
FILE {\em *file}; \\
CrlPSE {\em *crlpse};

{\bf aux\_fprint\_OCList} {\em (file, oclist)} \\
FILE {\em *file}; \\
OCList {\em *oclist};

{\bf aux\_fprint\_IssuedCertificate} {\em (file, isscert)} \\
FILE {\em *file}; \\
IssuedCertificate {\em *isscert};

{\bf aux\_fprint\_SET\_OF\_IssuedCertificate} {\em (file, isscertset)} \\
FILE {\em *file}; \\
SET\_OF\_IssuedCertificate {\em *isscertset};

{\bf aux\_fprint\_SET\_OF\_Name} {\em (file, nameset)} \\
FILE {\em *file}; \\
SET\_OF\_Name {\em *nameset};

{\bf aux\_fprint\_CertificatePairSet} {\em (file, cpairset)} \\
FILE {\em *file}; \\
SET\_OF\_CertificatePair {\em *cpairset};

{\bf aux\_fprint\_VerificationResult} {\em (file, verifresult)} \\
FILE {\em *file}; \\
VerificationResult {\em *verifresult};
\\ [1em]
\#include $<$stdio.h$>$ \\
\#include $<$pem.h$>$ \\ [1em]
{\bf aux\_fprint\_PemInfo} {\em (file, peminfo)} \\
FILE {\em *file}; \\
PemInfo {\em *peminfo};

\hl{Description}

{\bf aux\_xdump} writes the input {\em buffer} in a
``dump format'' (hexadecimal {\em 0--9, A--F}) to {\em stdout}.
{\bf aux\_fxdump} writes the input {\em buffer} in a
``dump format'' (hexadecimal {\em 0--9, A--F}) to {\em dump\_file}.
If {\em addrtype} is set to 0, xdump will print relative addresses,
otherwise absolute adresses.
{\em len} gives the length of the input {\em buffer}.

{\small
\begin{verbatim}
adress   hexadecimal format                        text
000 000  00000000 00000000  00000000 00000000     |................|
000 010  etc. until end of the buffer (len)
\end{verbatim}
}

The {\bf aux\_fprint\_*} functions print the given structures in a suitable
format to the given file pointer {\em file}. {\bf aux\_fprint\_OctetString}
and {\bf aux\_fprint\_BitString} print a dump-format with relative addresses. 
The print format of KeyInfos
containing RSA keys can be controlled by means of the external variable
\bc
{\small
char print\_keyinfo\_flag;
}
\ec
If this flag is set to ALGID (this is the default), the AlgId of the KeyInfo
is printed. If it is set to DER, the DER code contained in BitString subjectkey  
is printed. If it is set to KEYBITS, the decoded DER code of
subjectkey which shows the two integer components of the key is printed. These three
flags can be OR'ed to get any combination.

\subsection{Copy and Compare}
\nm{3X}{aux\_free}{Free allocated space}
\label{aux_free}
\hl{Synopsis}

\#include $<$secure.h$>$ \\
void {\bf aux\_free\_OctetString} {\em (ostr)} \\
OctetString {\em **ostr};

void {\bf aux\_free\_BitString} {\em (bstr)} \\
BitString {\em **bstr};

void {\bf aux\_free\_ObjId} {\em (oid)} \\
ObjId {\em **oid};

void {\bf aux\_free\_AlgId} {\em (aid)} \\
AlgId {\em **aid};

void {\bf aux\_free2\_AlgId} {\em (aid)} \\
AlgId {\em *aid};

void {\bf aux\_free\_PSEToc} {\em (psetoc)} \\
PSEToc {\em **psetoc};

void {\bf aux\_free2\_PSEToc} {\em (psetoc)} \\
PSEToc {\em *psetoc};

void {\bf aux\_free\_KeyBits} {\em (keybits)} \\
KeyBits {\em **keybits};

void {\bf aux\_free2\_KeyBits} {\em (keybits)} \\
KeyBits {\em *keybits};

void {\bf aux\_free\_KeyInfo} {\em (keyinfo)} \\
KeyInfo {\em **keyinfo};

void {\bf aux\_free2\_KeyInfo} {\em (keyinfo)} \\
KeyInfo {\em *keyinfo};
\\[1em]
\#include $<$af.h$>$ 

void {\bf aux\_free\_ToBeSigned} {\em (tbs)} \\
ToBeSigned {\em **tbs};

void {\bf aux\_free2\_ToBeSigned} {\em (tbs)} \\
ToBeSigned {\em *tbs};

void {\bf aux\_free\_Certificate} {\em (cert)} \\
Certificate {\em **cert};

void {\bf aux\_free2\_Certificate} {\em (cert)} \\
Certificate {\em *cert};

void {\bf aux\_free\_CertificateSet} {\em (certset)} \\
SET\_OF\_Certificate {\em **certset};

void {\bf aux\_free\_CrossCertificates} {\em (ccerts)} \\
CrossCertificates {\em **ccerts};

void {\bf aux\_free2\_CrossCertificates} {\em (ccerts)} \\
CrossCertificates {\em *ccerts};

void {\bf aux\_free\_FCPath} {\em (fcpath)} \\
FCPath {\em **fcpath};

void {\bf aux\_free\_PKRoot} {\em (pkroot)} \\
PKRoot {\em **pkroot};

void {\bf aux\_free\_PKList} {\em (pklist)} \\
PKList {\em **pklist};

void {\bf aux\_free\_Certificates} {\em (certs)} \\
Certificates {\em **certs};

void {\bf aux\_free\_DName} {\em (dname)} \\
DName {\em **dname};

void {\bf aux\_free2\_DName} {\em (dname)} \\
DName {\em *dname};

void {\bf aux\_free\_RevCert} {\em (revcert)} \\
RevCert {\em **revcert};

void {\bf aux\_free2\_RevCert} {\em (revcert)} \\
RevCert {\em *revcert};

void {\bf aux\_free\_Crl} {\em (crl)} \\
Crl {\em **crl};

void {\bf aux\_free2\_Crl} {\em (crl)} \\
Crl {\em *crl};

void {\bf aux\_free\_VerificationResult} {\em (verifresult)} \\
VerificationResult {\em **verifresult};

\hl{Description}
The {\bf aux\_free\_*} {\em (parm)} functions free the respective members of {\em *parm}
and {\em *parm} itself. The pointer {\em *parm} is set to NULL on return.

The {\bf aux\_free2\_*} {\em (parm)} functions free the respective members of {\em parm}
only.

\subsection{ISODE Support}
\nm{3X}{aux\_isode}{ISODE Support}
\label{aux_isode}
\hl{Synopsis}

\#include $<$isode/psap.h$>$ \\
\#include $<$secure.h$>$ \\
\#include $<$IF-types.h$>$ 

OctetString {\bf *aux\_PE2OctetString} {\em  (pe)} \\
PE {\em pe};

PE {\bf aux\_OctetString2PE} {\em (ostr)} \\
OctetString {\em *ostr};
\hl{Description}
{\bf aux\_PE2OctetString}
transforms the ISODE-defined presentation element pe, which
in terms of ISODE represents an ASN.1 octetstring,
into an OctetString, which contains the corresponding ASN.1 transfer
protocol data stream.
On success a pointer to the OctetString is returned.
On error a null pointer is returned.
The structure of an presentation element is defined in $<$isode/psap.h$>$.

{\bf aux\_OctetString2PE}
transforms the OctetString *ostr, which contains an ASN.1 transfer
protocol data stream, into
the corresponding ISODE-defined presentation element pe, which
in terms of ISODE represents an ASN.1 octetstring.
The presentation element is returned.
On error the presentation element is the null element.
The structure of an presentation element is defined in $<$isode/psap.h$>$.

\subsection{Alias Name Mapping}
\nm{3X}{aux\_octetstring}{OctetString Handling}
\label{aux_ostringhand}
\hl{Synopsis}

\#include $<$secure.h$>$
 
OctetString {\bf *aux\_create\_OctetString} {\em (text)} \\
char {\em *text};

OctetString {\bf *aux\_new\_OctetString} {\em (length)} \\
int {\em length};

void {\bf aux\_free\_OctetString} {\em (ostr)} \\
OctetString {\em **ostr};

RC {\bf aux\_append\_OctetString} {\em (to, append)} \\
OctetString {\em *to, *append};

RC {\bf aux\_append\_char} {\em (to, append)} \\
OctetString {\em *to};    \\
char {\em *append};

RC {\bf aux\_searchitem} {\em (ostr, item, pos)} \\
OctetString {\em *ostr};    \\
char {\em *item};    \\
unsigned int {\em *pos};

RC {\bf *aux\_cmpitem} {\em (msgbuf, item, pos)}  \\
OctetString {\em *msgbuf};    \\
char {\em *item};    \\
int {\em pos};

OctetString {\bf *aux\_file2OctetString} {\em (filename)} \\
char {\em *filename};

int {\bf aux\_OctetString2file} {\em (ostr, filename[, flag])} \\
OctetString {\em *ostr};    \\
char {\em *filename};
int {\em flag};
\hl{Description}
{\bf aux\_create\_OctetString} creates an OctetString with length {\em strlen(text)} $+$ 1
and character string {\em text}.
hex'00' denotes end of {\em text}.

{\bf aux\_new\_OctetString} creates an OctetString with length {\em length}. The octets
are set to zero.

{\bf aux\_free\_OctetString} frees both 
{\em *ostr}\pf octets and the struct OctetString {\em **ostr} itself.
The pointer {\em *ostr} is set to NULL on return.
See also paragraph \ref{aux_free} for all aux\_free* functions.

{\bf aux\_append\_OctetString} appends the octets of {\em append} to the octets
of {\em to}
and adds {\em append\pf noctets} to {\em to\pf noctets}.
{\em append} remains unchanged.
If {\em to} doesn't exist or the allocation of new space fails,
a negative integer is returned, otherwise 0.
If {\em append} doesn't exist or has length 0, {\em to}
remains unchanged, too, and the returncode is also 0.

{\bf aux\_append\_char} appends the character string {\em append} to the octets
of {\em to} and adds {\em strlen(append)} to {\em to\pf noctets}.
{\em append} remains unchanged.
hex'00' denotes end of {\em append}.
If {\em to} doesn't exist or the allocation of new space fails,
a negative integer is returned, otherwise 0.
If {\em append} doesn't exist or has length 0, {\em to}
remains unchanged, too, and the returncode is also 0.

{\bf aux\_searchitem}
searches in the OctetString {\em ostr} for a character string equal to
{\em item}. The search begins at position {\em *pos}.
If the search is successful, {\em *pos} gives the position
of the first octet behind the first
{\em item} found in {\em ostr}, and the return code is 0.
If the search is not successful, -1 is returned.

{\bf aux\_cmpitem} returns 0, if the sequence of octets in {\em msgbuf}
starting at position {\em pos} and ending at position
$pos+strlen(item)$
is equal to the sequence of characters in {\em item}.
aux\_cmpitem returns 1, if they are not equal.

{\bf aux\_file2OctetString} reads the file {\em filename} into
an OctetString, which it creates and returns. If {\em filename}
is NULL or has zero length, it reads from stdin.
On error it returns the NULL pointer.

{\bf aux\_OctetString2file} writes the content of the OctetString
{\em ostr} into the file {\em filename},
which it opens according to {\em flag}:
 
0: no overwrite (file must not exist), \\
1: overwrite (file must exist), \\
2: create or overwrite, \\
3: append (file must exist), \\
4: create or append.
 
If {\em filename} is NULL or has zero length, it writes
to stdout ({\em flag} has no meaning in this case).
 
Returncode 0 indicates success, -1 indicates an error.

\subsection{Printing Af-Objects, Sec-Objects and Pem-Objects}
\nm{3X}{e\_AF}{ASN.1 Encoding and decoding functions for AF-IF}
\label{Encoding-/Decoding-Routinen}

\hl{Synopsis}

\#include $<$af.h$>$ 

OctetString *{\bf e\_DName} {\em (name)} \\
DName *{\em name};

DName *{\bf d\_DName} {\em (octetstring)} \\
OctetString *{\em octetstring};

OctetString *{\bf e\_Certificate} {\em (certificate)} \\
Certificate *{\em certificate};

Certificate *{\bf d\_Certificate} {\em (octetstring)} \\
OctetString *{\em octetstring};

OctetString *{\bf e\_CertificateSet} {\em (certificateset)} \\
SET\_OF\_Certificate *{\em certificateset};

SET\_OF\_Certificate *{\bf d\_CertificateSet} {\em (octetstring)} \\
OctetString *{\em octetstring};

OctetString *{\bf e\_CertificatePairSet} {\em (cpairset)} \\
SET\_OF\_CertificatePair *{\em cpairset};

SET\_OF\_CertificatePair *{\bf d\_CertificatePairSet} {\em (octetstring)} \\
OctetString *{\em octetstring};

OctetString *{\bf e\_ToBeSigned} {\em (tobesigned)} \\
ToBeSigned *{\em tobesigned};

OctetString *{\bf e\_FCPath} {\em (fcpath)} \\
FCPath *{\em fcpath};

FCPath *{\bf d\_FCPath} {\em (octetstring)} \\
OctetString *{\em octetstring};

OctetString *{\bf e\_SerialNumbers} {\em (serialnums)} \\
SerialNumbers *{\em serialnums};

SerialNumbers *{\bf d\_SerialNumbers} {\em (octetstring)} \\
OctetString *{\em octetstring};

OctetString *{\bf e\_Certificates} {\em (certificates)} \\
Certificates *{\em certificates};

Certificates *{\bf d\_Certificates} {\em (octetstring)} \\
OctetString *{\em octetstring};

OctetString *{\bf e\_PKRoot} {\em (pkroot)} \\
PKRoot *{\em pkroot};

PKRoot *{\bf d\_PKRoot} {\em (octetstring)} \\
OctetString *{\em octetstring};

OctetString *{\bf e\_PKList} {\em (pklist)} \\
PKList *{\em pklist};

PKList *{\bf d\_PKList} {\em (octetstring)} \\
OctetString *{\em octetstring};

OctetString *{\bf e\_Attribute} {\em (attr)} \\
Attribute *{\em attr};

Attribute *{\bf d\_Attribute} {\em (octetstring)} \\
OctetString *{\bf octetstring};

OctetString *{\bf e\_PemCrl} {\em (pemcrl)} \\
PemCrl *{\em pemcrl};

PemCrl *{\bf d\_PemCrl} {\em (octetstring)} \\
OctetString *{\bf octetstring};

OctetString *{\bf e\_RevCertPem} {\em (revcertpem)} \\
RevCertPem *{\em revcertpem};

RevCertPem *{\bf d\_RevCertPem} {\em (octetstring)} \\
OctetString *{\bf octetstring};

OctetString *{\bf e\_CrlTBS} {\em (rcltbs)} \\
CrlTBS *{\em rcltbs};

OctetString *{\bf e\_SET\_OF\_IssuedCertificate} {\em (isscertset)} \\
SET\_OF\_IssuedCertificate  *{\em isscertset};

SET\_OF\_IssuedCertificate  *{\bf d\_SET\_OF\_IssuedCertificate} {\em (octetstring)}
OctetString *{\em octetstring};
\hl{Description}     
The functions e\_* (Encode) transform the given structure into an OctetString
and return its address. Memory of the entire structure is provided 
by the called program and can be released
by aux\_free\_OctetString().

The functions d\_* (Decode) transform the given OctetString into the indicated structure and return
a pointer to that structure. Memory of the entire structure is provided 
by the called program and can be released by the respective aux\_free* function (see~\ref{aux_free}).

OctetString consists of the ASN.1 encoding of the corresponding ASN.1 description of the C-structure
(see AF-PSE-OBJECTS(4) and AF-DIR-OBJECTS(4)).

\subsection{PSE Objects}
\nm{3X}{e\_SEC}{ASN.1 encoding and decoding functions for SEC-IF}
\label{Encoding-/Decoding-Secure}
\hl{Synopsis}
\#include $<$secure.h$>$ \\ [0.5cm]
OctetString *{\bf e\_KeyInfo} {\em (keyinfo)} \\
KeyInfo *{\em keyinfo}; 

KeyInfo *{\bf d\_KeyInfo} {\em (octetstring)} \\
OctetString *{\em octetstring}; 

RC {\bf d2\_KeyInfo} {\em (octetstring, keyinfo)} \\
OctetString *{\em octetstring}; \\
KeyInfo *{\em keyinfo}; 

OctetString *{\bf e\_EncryptedKey} {\em (encryptedkey)} \\
EncryptedKey *{\em encryptedkey}; 

EncryptedKey *{\bf d\_EncryptedKey} {\em (octetstring)} \\
OctetString *{\em octetstring}; 

RC {\bf d2\_EncryptedKey} {\em (octetstring, encryptedkey)} \\
OctetString *{\em octetstring}; \\
EncryptedKey *{\em encryptedkey}; 

OctetString *{\bf e\_Signature} {\em (signature)} \\
Signature *{\em signature}; 

Signature *{\bf d\_Signature} {\em (octetstring)} \\
OctetString *{\em octetstring}; 

RC {\bf d2\_Signature} {\em (octetstring, signature)} \\
OctetString *{\em octetstring}; \\
Signature *{\em signature}; 

BitString *{\bf e\_KeyBits} {\em (keybits)} \\
KeyBits *{\em keybits}; 

RC {\bf e2\_KeyBits} {\em (keybits, bitstring)} \\
KeyBits *{\em keybits}; \\
BitString *{\em bitstring}; 

KeyBits *{\bf d\_KeyBits} {\em (bitstring)} \\
BitString *{\em bitstring}; 

RC {\bf d2\_KeyBits} {\em (bitstring, keybits)} \\
BitString *{\em bitstring}; \\
KeyBits *{\em keybits}; 

OctetString *{\bf e\_AlgId} {\em (alg\_id)} \\
AlgId *{\em alg\_id}; 

AlgId *{\bf d\_AlgId} {\em (octetstring)} \\
OctetString *{\em octetstring}; 

RC {\bf d2\_AlgId} {\em (octetstring, alg\_id)} \\
OctetString *{\em octetstring}; \\
AlgId *{\em alg\_id}; 

OctetString *{\bf e\_PSEToc} {\em (pse\_toc)} \\
PSEToc *{\em pse\_toc}; 

PSEToc *{\bf d\_PSEToc} {\em (octetstring)} \\
OctetString *{\em octetstring}; 

OctetString *{\bf e\_PSEObject} {\em (objectType, objectValue)} \\
ObjId *{\em objectType}; \\
OctetString *{\em objectValue}; 

OctetString *{\bf d\_PSEObject} {\em (objectType, PSEObject)} \\
ObjId *{\em objectType}; \\
OctetString *{\em PSEObject}; 

\hl{Description}     
The functions e\_* encode the given structure into an OctetString or BitString
respectively and return its address. Memory of the entire structure is provided 
by the called program and can be released
by aux\_free\_OctetString() or aux\_free\_BitString(). 

The functions e2\_* encode the given structure into a given OctetString or BitString
respectively. Memory for the {\em octets} member or {\em bits} member of the given structure
is provided by the called program and can be released
using  free(). 

The functions d\_* decode the given OctetString into the indicated structure and return
a pointer to that structure. Memory of the entire structure is provided 
by the called program and can be released by the respective aux\_free* function (see~\ref{aux_free}).

The functions d2\_* decode the given OctetString into the given structure.
Memory for those members of the given structure which are pointers is provided 
by the called program and can be released using appropriate aux\_free* function (see~\ref{aux_free}).

OctetString or BitString consists of the ASN.1 encoding of the corresponding ASN.1 description of the C-structure (see SEC-PSE-OBJECTS(4) and AF-PSE-OBJECTS(4)). 
\\ [1em]
The function e\_PSEObject encodes the given {\em objectType} and {\em objectValue} into the
DER-code of the ASN.1 structure
\bc
{\small
\bvtab
PSEObject ::= \3 {\bf SEQUENCE} \{ \\
\5 objectType \3 OBJECT IDENTIFIER, \\
\5 objectValue \3 ANY DEFINED BY objectType \\
\3 \}
\evtab
}
\ec
{\em ObjectValue} is the DER-code of an arbitrary ASN.1 structure. 

The function d\_PSEObject extracts objectType and objectValue from the given
DER-code in {\em PSEObject} and returns objectType in {\em objectType} and
objectValue as return value. All necessary memory is allocated by the 
called program.

\subsection{PSE-Objects}
\nm{3X}{pem\_certify}{Scan PEM msg, sign the Originator-Certificate, and create new PEM msg}
\label{pem_certify}
\hl{Synopsis}
\#include $<$pem.h$>$ 

RC {\bf pem\_certify} {\em (ifname, ofname, verbose, cadir)} \\
char {\em *ifname, *ofname, *cadir}; \\
Boolean {\em verbose} \\
\hl{Input-Parameter}
\parname  {\em ifname}
\pardescript {Pathname of the  file
		    which contains the PEM.
		    If {\em ifname} is the NULL pointer,
		    the PEM is read from stdin.}

\parname  {\em ofname}
\pardescript {Pathname of the file
		    into which the cleartext message body is written.
		    If {\em ofname} is the NULL pointer,
		    the cleartext message body is written to stdout.}

\parname  {\em cadir}
\pardescript {The UNIX directory of the CA.}

\parname  {\em verbose}
\pardescript {If TRUE, pem\_certify tells to stderr what it's doing.} \\
\hl{Output-Parameter}
\parname  {\em Returncode RC}
\pardescript {-1 if any error occured, 0 if no error occured.} \\
\hl{Description}
pem\_certify reads the input file $<$ifname$>$,
opens the output file $<$ofname$>$,
opens the caller's PSE ({\em af\_pse\_open})
and calls the function {\em pem\_scan}.
pem\_certify signs the originator certificate which is supposed to be 
a prototype certificate and calls
pem\_create to recreate the PEM message, now with a
signed originator certificate and a forward certification path
and writes it to $<$ofname$>$.
This PEM massage  can be verified now.
pem\_certify evaluates all possible error codes and reports
them in readable form to stderr, if {\em verbose } is TRUE.
In particular, pem\_certify reports very clearly
the result of the message integrity check MIC of the PEM.
\subsection{Zoning, Text Transformations}
\nm{3X}{pem\_cinfo}{Generate signature and encryption control info for/of PEM text}
\label{pem_cinfo}
\hl{Synopsis}
\#include $<$pem.h$>$ 

RC {\bf pem\_cinfo} {\em (info)} \\
PemInfo {\em *info};
\hl{Description}
{\em pem\_cinfo} supports the collection of signature and
encryption control informations and stores them into
the structure PemInfo {\em info}.
pem\_cinfo is either the first of pem\_create,
or, alternatively, it is performed prior to the call of pem\_create.
That is, because the full set of informations in the structure PemInfo
serves as input to pem\_create and all pem\_c* subroutines.


The parameter {\em info} is defined by the calling function.
Some informations are already stored on input to pem\_cinfo.
pem\_cinfo completes the set of informations.


On input to pem\_cinfo, the subfields {\em confidential} and {\em clear}
must be set. If {\em confidential} = TRUE,
{\em recplist} of {\em info} must be created by calling function, too;
in this {\em recplist},
for every recipient's certificate, at least
the owner's name {\em tbs.subject} must be set on input.


On output, pem\_cinfo will have filled the subfields
{\em encryptKEY} and,  for every recipient in {\em recplist}, {\em key}.
If on input one or more of the elements
{\em origcert, signAI}, or a recipient's public encryption key
in {\em recpcert} (in recplist) were not filled,
pem\_cinfo will provide these informations, too.
For every recipient's certificate, pem\_cinfo tries also to collect the
informations {\em tbs.issuer} and {\em tbs.serialnumber}
from {\em EKList} of the caller's PSE or from a public directory.


pem\_cinfo performs the following steps:

\begin{enumerate}
\item
If {\em origcert} has no value on input,
read the originator-certificate (struct Certificates)
with the help of {\em af\_pse\_get\_Certificates}
and store it in {\em origcert}.
\item
If {\em signAI} has no value on input,
take the public key algorithm identifier
from the user's certificate of {\em origcert}
and store it in {\em signAI}.


If PEM type is not ``ENCRYPTED'',
set {\em info\pf encryptKEY} to {\em NULL} and return.
If confidentiality service is required, resume with the following steps:
\item
Generate a DES-key with the help of
af\_gen\_key and store it as key-reference in
{\em info\pf encryptKEY}.
\item
If in a {\em recpcert} (of {\em recplist})
the public encryption key has no value on input,
search for it in the {\em EKList} of the caller's PSE
with the help of {\em af\_pse\_get\_owner}
and store it in this {\em recpcert} .
If this fails, try to collect the recipient's certificate
from a public directory with the help of {\em af\_dir\_retrieve\_Certificate}.
If this also fails, or if
in a {\em recpcert}
the owner's name (tbs.subject) has no input value,
delete this entry from the recplist.
\item
For every recipient in the {\em recplist},
use his public encryption key in {\em recpcert}
in order to RSA-encrypt the DES-key stored in
{\em info\pf encryptKEY}
(call to {\em af\_get\_EncryptedKey}) and store
the result in {\em key} of the respective {\em recplist} entry.
\end{enumerate}

\subsubsection{pem\_read}
\nm{3X}{pem\_create}{Generate a PEM text}
\label{pem_create}
\hl{Synopsis}
\#include $<$pem.h$>$ 

RC {\bf pem\_create} {\em (info, in, pem)} \\
OctetString {\em *in, *pem}; \\
PemInfo {\em *info};
\hl{Input-Parameter}
\parname  {\em info}
\pardescript {Signature and encryption control informations.} \\
\parname  {\em in}
\pardescript {Cleartext created by user, subject to
		  privacy enhanced services.
		  It may contain embedded (multiple) PEMs.}
\hl{Output-Parameter}
\parname  {\em pem}
\pardescript {RFC 1421 specified text between the
		  privacy enhanced message encapsulation boundary lines
		  (included).
		  The OctetString structure of {\em pem} is
		  created by the calling function.
		  However, the character string in {\em pem}
		  is allocated by {\em pem\_create}.} 

\parname  {\em Returncode RC}
\pardescript {negative if erraneous, 0 if OK.}
\hl{Description}
pem\_create evaluates the structure PemInfo (info) and the cleartext (in),
and creates the PEM text (pem):
the resulting text is the RFC 1421 specified text between the
privacy enhanced message encapsulation boundary lines (included).
The signature and encryption control informations
stored in a structure PemInfo serve as input to the pem\_create function.
The storage of these control informations into a structure PemInfo
is supported by pem\_cinfo, which can be performed
before the call to pem\_create.
Alternatively, pem\_cinfo can be called as first step inside of
pem\_create.
pem\_create performs the following steps:

{\small
\parname  {\em pem\_cinfo}
\pardescript {optional: prepares PemInfo for input to the other
		    pem\_c* subroutines. Can also be called prior
		    to pem\_create} 


\parname  {\em pem\_chd}
\pardescript {write any of the encapsulated header titles
		    (called by the other pem\_c* functions)}

\parname  {\em pem\_cinit}
\pardescript {create pem\pf octets and put Pre-EB and Proc-Type header into it} \\
\parname  {\em pem\_cdek}
\pardescript {append DEK-Info header to pem\pf octets} \\
\parname  {\em pem\_csend}
\pardescript {append Originator-ID, Certificate,
		    Issuer-Certificate header} \\
\parname  {\em pem\_sign}
\pardescript {produce MIC: canonicalize msg body {\em in} and apply
		    digital signature to it
		    (use MIC production defined by RFC 1421)}

\parname  {\em pem\_cmic}
\pardescript {(encrypt and) encode MIC and append MIC-Info} \\
\parname  {\em pem\_crec}
\pardescript {append Recipient-ID, Key-Info
		    (recipient keys in structure PemInfo are already encrypted,
		    e.g. by pem\_cinfo)} 


\parname  {\em CR--LF}
\pardescript {append empty line (local form: one extra line feed)} \\
\parname  {\em pem\_cbody}
\pardescript {canonicalize, encrypt and encode msg body (from {\em in})
		    and append} \\
\parname  {\em pem\_cend}
\pardescript {append Post-EB as last line}
}

\subsubsection{pem\_scan}
\nm{3X}{pem\_crl}{Creates a PEM text of Proc-Type CRL, and report errors to caller}
\label{pem_crl}
\hl{Synopsis}
\#include $<$pem.h$>$ 

RC {\bf pem\_crl} {\em (issuer, pem, cadir)} \\
SET\_OF\_DName {\em *issuer}; \\
OctetString {\em *pem}; \\
char {\em *cadir}; \\
\hl{Input-Parameter}
\parname  {\em issuer}
\pardescript {A list of issuers.}

\parname  {\em cadir}
\pardescript {The UNIX directory of the CA.}

\hl{Output-Parameter}
\parname  {\em pem}
\pardescript {RFC 1421 specified text between the
		  privacy enhanced message encapsulation boundary lines
		  (included).
		  The OctetString structure of {\em pem} is
		  created by the calling function.
		  However, the character string in {\em pem}
		  is allocated by {\em pem\_crl}.} 

\parname  {\em Returncode RC}
\pardescript {-1 if any error occured, 0 if no error occured.} \\
\hl{Description}
pem\_crl creates the PEM message pem of Proc-Type CRL.
This message contains the {\bf Proc-Type } field and one group of a {\bf CRL} field,
an {\bf Originator-Certificate} field and any {\bf Issuer-Certificate} fields
for each issuer given in the list {\em issuer}. A CRL field stores the certificate
revocation list with a signature of one issuer which can be verified with the following
originator and issuer certificates.

\subsubsection{pem\_certify}
\nm{3X}{pem\_crl\_retrieval\_request}{Creates a PEM text of Proc-Type CRL-RETRIEVAL-REQUEST, and report errors to caller}
\label{pem_crl_retrieval_request}
\hl{Synopsis}
\#include $<$pem.h$>$ 

RC {\bf pem\_crl\_retrieval\_request} {\em (issuer, pem)} \\
SET\_OF\_DName {\em *issuer}; \\
OctetString {\em *pem}; \\
\hl{Input-Parameter}
\parname  {\em issuer}
\pardescript {A list of issuers.}

\hl{Output-Parameter}
\parname  {\em pem}
\pardescript {RFC 1421 specified text between the
		  privacy enhanced message encapsulation boundary lines
		  (included).
		  The OctetString structure of {\em pem} is
		  created by the calling function.
		  However, the character string in {\em pem}
		  is allocated by {\em pem\_crl\_retrieval\_request}.} 

\parname  {\em Returncode RC}
\pardescript {-1 if any error occured, 0 if no error occured.} \\
\hl{Description}
pem\_crl\_retrieval\_request creates the PEM message pem of Proc-Type CRL-RETRIEVAL-REQUEST.
This message contains the {\bf Proc-Type } field and one {\bf Issuer} field
for each issuer given in the list {\em issuer}. The value of such a field is the
encoded distinguished name of the issuer.

\subsubsection{pem\_crl}
\nm{3X}{pem\_get\_header}{Scan a PEM text}
\label{pem_get_header}
\hl{Synopsis}
\#include $<$pem.h$>$ 

RC {\bf pem\_get\_header} {\em (info, set\_of\_pemcrlwithcerts, issuer, signature, buf)} \\
PemInfo {\em *info}; \\
SET\_OF\_PemCrlWithCerts {\em **set\_of\_pemcrlwithcerts}; \\
SET\_OF\_DName 	{\em **issuer}; \\
BitString {\em *signature}; \\
OctetString {\em *buf};
\hl{Input-Parameter}
\parname  {\em buf}
\pardescript {RFC 1421 specified text between the
		    privacy enhanced message encapsulation boundary lines
		    (included).
		    If an embedded multi-level PEM is to be scanned,
		    the first Pre-EB of the pem OctetString must be
		    the Pre-EB of the embedded PEM to be scanned.
		    pem\_sbody will automatically find the corresponding
		    Post-EB (counting Pre-EBs up, and Post-EBs down).}

\hl{Output-Parameter}
\parname  {\em info}
\pardescript {Signature and encryption control information.
		    The {\em PemInfo} structure of {\em info}
		    is to be allocated by the calling function.
		    However, the pointers below {\em info}:
		    {\em encryptKEY}, {\em origcert}, {\em signAI},
		    and {\em recplist}, are created by {\em pem\_scan}.
		    The informations stored into {\em info} are a result of
		    scanning the encapsulated header fields in {\em pem}.} 

\parname  {\em signature}
\pardescript {Signature of the scaned PEM body which is encoded in the {\bf MIC } header field.
                    The memory of the BitString structure
                    {\em signature} is created by the calling function.} 

\parname  {\em set\_of\_pemcrl...}
\pardescript {Structure to store CRLs in case of Proc-Type CRL.} \\
\parname  {\em issuer}
\pardescript {Structure to store issuer names in case of Proc-Type CRL-RETRIEVAL-REQUEST.} \\
\parname  {\em Returncode RC}
\pardescript {negative if erraneous, 0 if OK.} \\
\hl{Description}

pem\_get\_header evaluates the PEM text {\em buf} and fills the structures PemInfo {\em info} and Bitstring {\em signature } or
SET\_OF\_PemCrlWithCerts {\em set\_of\_pemcrlwithcerts} or SET\_OF\_DName {\em issuer} depending
on then Proc-Type of the PEM message.

\subsubsection{pem\_cinfo}
\nm{3X}{pem\_read}{Read and scan a PEM text, and report errors to caller}
\label{pem_read}
\hl{Synopsis}
\#include $<$pem.h$>$ 

RC {\bf pem\_read} {\em (ifname, ofname, depth, verbose, cadir)} \\
char {\em *ifname, *ofname, *cadir}; \\
int {\em depth}; \\
Boolean {\em verbose} \\
\hl{Input-Parameter}
\parname  {\em ifname}
\pardescript {Pathname of the file
		    which contains the PEM text.
		    If {\em ifname} is the NULL pointer,
		    the PEM text is read from stdin.}

\parname  {\em ofname}
\pardescript {Pathname of the file
		    into which the cleartext message body is written.
		    If {\em ofname} is the NULL pointer,
		    the cleartext message body is written to stdout.}

\parname  {\em depth}
\pardescript {Integer greater or equal to zero.
		    $depth = 0$ reads the outmost PEM
		    (first Pre-EB, last Post-EB).
		    $depth > 0$ reads the {\em depth}'th embedded PEM
		    ($(depth+1)$st Pre-EB, $(last-depth)$th Post-EB).
		    $depth < 0$ is treated like $depth = 0$.}

\parname  {\em verbose}
\pardescript {If TRUE, pem\_read tells to stderr what it's doing.} \\
\parname  {\em cadir}
\pardescript {The UNIX directory of the CA.}

\hl{Output-Parameter}
\parname  {\em Returncode RC}
\pardescript {-1 if any error occured, 0 if no error occured.} \\
\hl{Description}
pem\_read reads the input file $<$ifname$>$,
opens the output file $<$ofname$>$,
and opens the caller's PSE ({\em af\_pse\_open}).
Then it skips all characters of the read file before the
$(depth+1)$st Pro-EB
and calls the function {\em pem\_scan}.
In normal case pem\_read writes the (decrypted) PEM body in cleartext into the output file.
If the PEM message if of Proc-Type CRL-RETRIEVAL-REQUEST, a corresponding PEM CRL messsage
containing the requested CRLs is written to the output file.
pem\_read evaluates all possible error codes and reports
them in readable form to stderr, if {\em verbose } is TRUE.
In particular, pem\_read reports very clearly
the result of the message integrity check MIC of the PEM.

\subsubsection{pem\_write}
\nm{3X}{pem\_scan}{Scan a PEM text}
\label{pem_scan}
\hl{Synopsis}
\#include $<$pem.h$>$ 

RC {\bf pem\_scan} {\em (info, set\_of\_pemcrlwithcerts, issuer, cbody, pem, no\_path\_verification)} \\
PemInfo {\em *info}; \\
SET\_OF\_PemCrlWithCerts {\em **set\_of\_pemcrlwithcerts}; \\
SET\_OF\_DName 	{\em **issuer}; \\
OctetString {\em *cbody, *pem}; \\
Boolean {\em *no\_path\_verification};
\hl{Input-Parameter}
\parname  {\em pem}
\pardescript {RFC 1421 specified text between the
		    privacy enhanced message encapsulation boundary lines
		    (included).
		    If an embedded multi-level PEM is to be scanned,
		    the first Pre-EB of the pem OctetString must be
		    the Pre-EB of the embedded PEM to be scanned.
		    pem\_sbody will automatically find the corresponding
		    Post-EB (counting Pre-EBs up, and Post-EBs down).}

\parname  {\em no\_path\_verification}
\pardescript {If set to TRUE the forward certification path is not verified.}
\hl{Output-Parameter}
\parname  {\em info}
\pardescript {Signature and encryption control information.
		    The {\em PemInfo} structure of {\em info}
		    is to be allocated by the calling function.
		    However, the pointers below {\em info}:
		    {\em encryptKEY}, {\em origcert}, {\em signAI},
		    and {\em recplist}, are created by {\em pem\_scan}.
		    The informations stored into {\em info} are a result of
		    scanning the encapsulated header fields in {\em pem}.} 

\parname  {\em cbody}
\pardescript {Cleartext created by {\em pem\_scan} as result
		    of scanning the input parameter {\em pem}
		    and applying the control informations found in the
		    encapsulated header fields on the message body.
		    The OctetString structure of {\em out} is created by
		    the calling function.
		    The character string in {\em out}, however,
		    is allocated by {\em pem\_scan}.} 

\parname  {\em set\_of\_pemcrl...}
\pardescript {Structure to store CRLs in case of Proc-Type CRL.} \\
\parname  {\em issuer}
\pardescript {Structure to store issuer names in case of Proc-Type CRL-RETRIEVAL-REQUEST.} \\
\parname  {\em Returncode RC}
\pardescript {negative if erraneous, 0 if OK.} \\
\hl{Description}

pem\_scan evaluates the PEM text (pem) and fills structure PemInfo (info)
and creates the cleartext (out) by scanning the encapsulated header fields and
decrypting the message body.
The message body is decrypted with the help of a DES-key
which is contained in the recipient-related Key-Info header fields,
however RSA-encrypted.
In order to find ``my'' corresponding Key-Info field,
the input parameter ``my name'' is used
to find ``my'' corresponding Recipient-ID header field.
If the input parameter ``myname'' is not set,
pem\_scan evaluates the caller's encryption certificate from the PSE.
\\
The returncode tells, if the MIC was correct.
pem\_scan performs the following steps:

{\small
\parname  {\em pem\_find\_delim}
\pardescript {find first empty line (CR--LF--CR--LF or, in local form LF--LF)
		    which is interpreted as delimiting line between
		    encapsulated header portion and PEM body.} 

\parname  {\em pem\_get\_header}
\pardescript {scan and interpret the header field} \\
\parname  {\em af\_decrypt}
\pardescript {if encrypted, decrypt the body of the message} 

\parname  {\em aux\_canon}
\pardescript {canonicalize the plaintext msg body} 

\parname  {\em af\_verify}
\pardescript {verify the MIC and the forward certification path} 

\parname  {\em aux\_add\_alias}
\pardescript {store an alias for the sender of the message} 

\parname  {\em af\_pse\_add\_PK}
\pardescript {add the public key into the PSE object {\bf PKList}} 

}
\subsubsection{pem\_get\_header}
\nm{3X}{pem\_write}{Create and write a PEM text}
\label{pem_write}
\hl{Synopsis}
\#include $<$pem.h$>$ 

RC {\bf pem\_write} {\em (recips, ifname, ofname, encr, clear, verbose)} \\
RecpList {\em *recips}; \\
char {\em *ofname, *ifname}; \\
Boolean {\em encr, clear, verbose}; \\
\hl{Input-Parameter}
\parname  {\em recips}
\pardescript {List of intended recipients, only evaluated,
		    if PEM type is ``ENCRYPTED''
		    (i.e. if  parameter {\em encr} is set to TRUE).
		    In this case, at least the certificates' owners
		    must be set. If the other entries of {\em recips}
		    are set, too, they would be respected by the
		    PEM creation process. Otherwise, their values
		    will be collected during the
		    PEM creation process.}

\parname  {\em ifname}
\pardescript {Pathname of the UNIX file
		    which contains the cleartext message body.
		    If {\em ifname} is the NULL pointer or ZERO string,
		    the message body is read from stdin.}

\parname  {\em ofname}
\pardescript {Pathname of the UNIX file
		    into which the created PEM is written.
		    If {\em ofname} is the NULL pointer or ZERO string,
		    the PEM is written to stdout.}

\parname  {\em encr}
\pardescript {Boolean, set to TRUE, iff the type of the PEM to be created
		    is intended to be ``ENCRYPTED''.}

\parname  {\em clear}
\pardescript {Boolean, set to TRUE, iff the type of the PEM to be created
		    is intended to be ``MIC-CLEAR''.
		    If {\em encr} = TRUE, {\em clear} is ignored.}

\parname  {\em verbose}
\pardescript {If TRUE, pem\_write tells to stderr what it's doing.} \\
\hl{Output-Parameter}
\parname  {\em Returncode RC}
\pardescript {-1 if any error occured, 0 if no error occured.} \\
\hl{Description}
pem\_write reads the input file $<$ifname$>$,
opens the output file $<$ofname$>$,
and opens the caller's PSE ({\em af\_pse\_open}).
A PemInfo structure is created, filled with the input parameters
to pem\_write, and passed to the called function {\em pem\_cinfo},
which completes the values for PemInfo.
With these informations, {\em pem\_create} is called.
pem\_write writes the created PEM into the output file.
pem\_write evaluates all possible error codes and reports
them in readable form to stderr if {\em verbose} is TRUE.

\subsubsection{pem\_crl\_retrieval\_request}
\nm{3X}{sec\_chpin}{Change PIN}
\label{sec_chpin}
\hl{Synopsis}
\#include $<$secure.h$>$ \\ [0.5cm]
RC {\bf sec\_chpin} {\em (pse\_sel, newpin)} \\
PSESel *{\em pse\_sel}; \\
char *{\em newpin};
\hl{Parameter}
\parname  {{\em pse\_sel}}
\pardescript  {Structure which identifies the PSE object.} 

\parname  {{\em newpin}}
\pardescript  {New PIN.} 

\parname  {{\em Return Value}}
\pardescript  {0 or -1.}
\hl{Description}
Sec\_chpin changes the PIN of the PSE object specified by {\em pse\_sel}.
As a result, the PSE object is decrypted with the old PIN (if any) and eventually
encrypted with the new PIN.
If {\em pse\_sel}\pf object.name is omitted, the PIN corresponding to the entire
PSE is changed. In this case, all PSE objects which have the global PIN (including the
Toc) are decrypted with the old key and encrypted with the new key.\\
The old PIN can be passed to sec\_chpin in {\em pse\_sel}\pf pin or {\em pse\_sel}\pf object.pin,
or the program will ask for it interactively.
If {\em newpin} is the NULL pointer, the program will also ask for the new PIN.

\subsubsection{sec\_read\_toc}
\nm{3X}{sec\_close}{Close PSE object}
\label{sec_close}
\hl{Synopsis}
\#include $<$secure.h$>$ \\ [0.5cm]
RC {\bf sec\_close} {\em (pse\_sel)} \\
PSESel *{\em pse\_sel};
\hl{Parameter}
\parname  {{\em pse\_sel}}
\pardescript  {Structure which identifies the PSE object.} 

\parname  {{\em Return Value}}
\pardescript  {0 or -1.}
\hl{Description}
Sec\_close closes a PSE object. This is a dummy operation in case of the SW-PSE. \\ [0.5cm]
In case of a SC, a closed object cannot be accessed anymore prior to reopen 
it with sec\_open. 

{\em pse\_sel}\pf app\_id can be used to pass a reference to an application which was generated
by sec\_open, instead of an application name.

\subsubsection{sec\_read}
\nm{3X}{sec\_create}{Create PSE or PSE object}
\label{sec_create}
\hl{Synopsis}
\#include $<$secure.h$>$ \\ [0.5cm]
RC {\bf sec\_create} {\em (pse\_sel)} \\
PSESel *{\em pse\_sel};
\hl{Parameter}
\parname  {{\em pse\_sel}}
\pardescript  {Structure which identifies the PSE object.} 

\parname  {{\em Return Value}}
\pardescript  {0 or -1.}
\hl{Description}
Sec\_create creates an entire PSE or a PSE object. 
The object belongs to the application identified by {\em pse\_sel}\pf app\_name.
In case of the SW-PSE, the application name is the name of the corresponding directory. 

{\em pse\_sel}\pf object.name is the name of the object to be created. It can be omitted 
(NULL pointer) in order to create a new application. In case of the SW-PSE, 
this creates the entire PSE, i.e. it creates a new directory
with the name {\em pse\_sel}\pf app\_name in the HOME directory of
the user. 
 
The PIN which allows the creation of a new object in the PSE ist either specified in
{\em pse\_sel}\pf pin, or sec\_create asks for it interactively.
The PIN to be installed for the object
is either specified in {\em pse\_sel}\pf object.pin, or sec\_create asks for it interactively.
If the user returns CR only in this case, no PIN protection for the created object
is installed. All interactively entered PIN's are returned by sec\_create in the appropriate
parameter fields.

\subsubsection{sec\_delete}
\nm{3X}{sec\_decrypt}{Decrypt bitstring}
\label{sec_decrypt}
\hl{Synopsis}
\#include $<$secure.h$>$ \\ [0.5cm]
RC {\bf sec\_decrypt} {\em (in\_bits, out\_octets, more, key)} \\
BitString *{\em in\_bits}; \\
OctetString *{\em out\_octets}; \\
More {\em more}; \\
Key *{\em key};
\hl{Parameter}
\parname  {{\em in\_bits}}
\pardescript  {BitString of the data to be decrypted.}

\parname  {{\em out\_octets}}
\pardescript  {OctetString of the decrypted data. Memory must be provided by the calling program.}

\parname  {{\em more}}
\pardescript  {MORE: More data will follow for this decryption process. \\
                  END: Last data of this decryption process.}

\parname  {{\em key}}
\pardescript  {Structure which identifies the decryption key.}

\parname  {{\em Return Value}}
\pardescript  {Number of decrypted octets in {\em out\_octets}, or -1.}
\hl{Description}
Sec\_decrypt decrypts the input data of bitstring {\em in\_bits} and returns the decrypted data
in {\em out\_octets}. Several successive calls of sec\_decrypt can be chained
to one decryption process by means of {\em more}.
          
The number of bits in {\em in\_bits} is arbitrary (see remark below for DES). The number of octets in {\em out\_octets}
corresponds in case of {\em more} $=$ MORE to the parameters of the indicated algorithm
(e.g. a multiple of eight in case of DES or DES3 algorithms and a multiple of blocksize/8
in case of RSA). The remaining octets are collected by sec\_decrypt.

Sec\_decrypt puts the decrypted data into {\em out\_octets}\pf octets at the offset
{\em out\_octets}\pf noctets and returns the number of decrypted octets. In addition, this number is added 
to {\em out\_octets}\pf noctets.
The calling program must provide {\em out\_octets}\pf noctets and {\em out\_octets}\pf octets and sufficient
memory in {\em out\_octets}\pf octets. 
The amount of memory should be not less than
({\em in\_bits}\pf nbits) $/$ 8 $+$ {\em out\_octets}\pf noctets $+$ $n$ with $n = 8$ 
in case of DES or DES3 algorithms and $n = keysize / 8$ in case of RSA.

Decryption key and corresponding algorithm are determined by parameter {\em key} as follows:
\be
\m If {\em key}\pf key is not the NULL pointer, the structure it points to
   contains algorithm identifier and key.
\m If {\em key}\pf key is the NULL pointer and {\em key}\pf keyref $>$ 0,
   key and algorithm identifier which are referenced by this number are used. This is a key
   previously installed under this reference with {\em sec\_gen\_key} or 
   {\em sec\_put\_EncryptedKey}.
\m If {\em key}\pf key is the NULL pointer and {\em key}\pf keyref $=$ 0,
   {\em key}\pf pse\_sel indicates the PSE object which contains key and algorithm.
\ee

{\bf In case of RSA algorithm:}
\be
\m The decryption key which is of type BitString is supposed to be
   a {\bf secret key}. It consists of the substructure described in
   SEC-PSE-OBJECTS(4), which in case of a secret key consists of the secret
   prime factors. Sec\_decrypt uses internally the
   decoding function {\em d\_KeyBits} to get the prime factors {\em p} and {\em q}.
\m The bitstring passed through {\em in\_bits} is internally blocked into portions of
   {\em keysize} bits, each block considered to represent a positive integer number with the first bit
   being the most significant bit. These blocks are decrypted into blocks of {\em blocksize} bits
   (padded with trailing ZEROES) which in turn are combined into the octetstring {\em out\_octets}, i.e
   the octetstring of the decrypted data consists of less bits than the bitstring 
   of the encrypted data
   according to the relation between {\em blocksize} and {\em keysize}.
   The length of the decrypted data is always a multiple of {\em blocksize} octets.
   {\em blocksize} is derived from {\em keysize} as the largest multiple of octets which consists of
   less bits than {\em keysize} (for instance $keysize = 512$ leads to $blocksize = 63$).
\m Sec\_decrypt does not assume any specific padding prior encrypting in order to be able to
   restore the original plaintext length. This must be done by the application before 
   calling  sec\_encrypt and after calling sec\_decrypt.
\m Since there is no special mechanism to encode the length of the original plaintext prior
   to encryption, decrypting encrypted (with {\em sec\_encrypt}) data with {\em sec\_decrypt}
   leads to a result which is longer than the original plaintext with trailing zeroes.
\ee
{\bf In case of DES or DES3 algorithm:} \\ [1em]
   While the number of bits in {\em in\_bits} is arbitrary for each single call to
   {\em sec\_decrypt}, the number of bits of the input data for the whole
   decryption process (until {\em more} $=$ END) must be a multiple of 64. 


\subsubsection{sec\_hash}
\nm{3X}{sec\_del\_key}{Delete key by reference from key pool}
\label{sec_del_key}
\hl{Synopsis}
\#include $<$secure.h$>$ \\ [0.5cm]
RC {\bf sec\_del\_key} {\em (keyref)} \\
KeyRef {\em keyref};
\hl{Parameter}
\parname  {{\em keyref}}
\pardescript  {Reference to an existing key.} 

\parname  {{\em Return Value}}
\pardescript  {0 or -1.}
\hl{Description}
The key referenced by {\em keyref} is deleted from the key pool.

\subsubsection{sec\_get\_EncryptedKey}
\nm{3X}{sec\_delete}{Delete PSE object}
\label{sec_delete}
\hl{Synopsis}
\#include $<$secure.h$>$ \\ [0.5cm]
RC {\bf sec\_delete} {\em (pse\_sel)} \\
PSESel *{\em pse\_sel};
\hl{Parameter}
\parname  {{\em pse\_sel}}
\pardescript  {Structure which identifies the PSE object.} 

\parname  {{\em Return Value}}
\pardescript  {0 or -1.}
\hl{Description}
Sec\_delete deletes a PSE object. 
The object belongs to the application identified by {\em pse\_sel}\pf app\_name.
In case of the SW-PSE, the application name is the name of the corresponding directory. 

{\em pse\_sel}\pf object.name is the name of the object to be deleted. It can be omitted 
(NULL pointer) in case of the SW-PSE in order to delete the entire PSE. \\[1ex]
The PSE-PIN is either specified in
{\em pse\_sel}\pf pin, or sec\_delete asks for it interactively.
The object specific PIN, if any, is either specified in {\em pse\_sel}\pf object.pin, 
or sec\_delete asks for it interactively.

\subsubsection{sec\_rename}
\nm{3X}{sec\_encrypt}{Encrypt octetstring}
\label{sec_encrypt}
\hl{Synopsis}
\#include $<$secure.h$>$ \\ [0.5cm]
RC {\bf sec\_encrypt} {\em (in\_octets, out\_bits, more, key)} \\
OctetString *{\em in\_octets}; \\
BitString *{\em out\_bits}; \\
More {\em more}; \\
Key *{\em key};
\hl{Parameter}
\parname  {{\em in\_octets}}
\pardescript  {OctetString of the data to be encrypted.}

\parname  {{\em out\_bits}}
\pardescript  {BitString of the encrypted data. Memory must be provided by the calling program.}

\parname  {{\em more}}
\pardescript  {MORE: More data will follow for this encryption process. \\
                  END: Last data of this encryption process.}

\parname  {{\em key}}
\pardescript  {Structure which identifies the encryption key.}

\parname  {{\em Return Value}}
\pardescript  {Number of encrypted bits in {\em out\_bits}, or -1.}
\hl{Description}
Sec\_encrypt encrypts the input data of octetstring {\em in\_octets} and returns the encrypted data
in {\em out\_bits}. Several successive calls of sec\_encrypt can be chained
to one encryption process by means of {\em more}.
          
The number of octets in {\em in\_octets} is arbitrary. The number of bits in {\em out\_bits}
corresponds in case of {\em more} $=$ MORE to the parameters of the indicated algorithm
(e.g. a multiple of 64 in case of DES or DES3 algorithms and a multiple of keysize
in case of RSA). The remaining bits are collected by sec\_encrypt.

Sec\_encrypt puts the encrypted data into {\em out\_bits}\pf bits at the offset
{\em out\_bits}\pf nbits and returns the number of encrypted bits. In addition, this number is added 
to {\em out\_bits}\pf nbits.
The calling program must provide {\em out\_bits}\pf nbits and {\em out\_bits}\pf bits and sufficient
memory in {\em out\_bits}\pf bits. 
The amount of memory should be not less than
{\em in\_octets}\pf noctets $+$ ({\em out\_bits}\pf nbits) $/$ 8 $+$ $n$ with $n = 8$ 
in case of DES or DES3 algorithms and $n = keysize / 8$ in case of RSA.

Encryption key and corresponding algorithm are determined by parameter {\em key} as follows:
\be
\m If {\em key}\pf key is not the NULL pointer, the structure it points to
   contains algorithm identifier and key.
\m If {\em key}\pf key is the NULL pointer and {\em key}\pf keyref $>$ 0,
   key and algorithm identifier which are referenced by this number are used. This is a key
   previously installed under this reference with {\em sec\_gen\_key} or 
   {\em sec\_put\_EncryptedKey}.
\m If {\em key}\pf key is the NULL pointer and {\em key}\pf keyref $=$ 0,
   {\em key}\pf pse\_sel indicates the PSE object which contains key and algorithm.
\ee

{\bf In case of RSA algorithm:}
\be
\m The encryption key which is of type BitString is supposed to be
   a {\bf public key}. It consists of the substructure described in
   SEC-PSE-OBJECTS(4), which in case of a public key consists of the
   modulus and the public exponent. Sec\_encrypt uses internally the
   decoding function {\em d\_KeyBits} to get the modulus {\em n} and the exponent {\em e}.
\m The octetstring passed through {\em in\_octets} is internally blocked into portions of
   {\em blocksize} bits, each block considered to represent a positive integer number with the first bit
   being the most significant bit. These blocks are encrypted into blocks of {\em keysize} bits
   (padded with trailing ZEROES) which in turn are combined into the bitstring {\em out\_bits}, i.e
   the bitstring of the encrypted data consists of more bits than the octetstring of the cleartext data
   according to the relation between {\em blocksize} and {\em keysize}. 
   The length of the encrypted data is always a multiple of {\em keysize} bits. 
   {\em blocksize} is derived from {\em keysize} as the largest multiple of octets which consists of
   less bits than {\em keysize} (for instance $keysize = 512$ leads to $blocksize = 63$).
\m There is no special mechanism to encode the length of the original plaintext prior
   to encryption. Decrypting encrypted (with {\em sec\_encrypt}) data with {\em sec\_decrypt}
   leads to a result with a length of a multiple of {\em blocksize} octets, i.e. the decrypted
   plaintext is longer than the original plaintext with trailing zeroes.
\ee
{\bf In case of DES or DES3 algorithm:}
   The length of the encryption result is always a multiple of 64 bits.


\subsubsection{sec\_decrypt}
\nm{3X}{sec\_gen\_key}{Generate DES or RSA key}
\label{sec_gen_key}
\hl{Synopsis}
\#include $<$secure.h$>$ \\ [0.5cm]
RC {\bf sec\_gen\_key} {\em (key, replace)} \\
Key *{\em key}; \\
Boolean {\em replace};
\hl{Parameter}
\parname  {{\em key}}
\pardescript  {Structure which determines the generated key.} 

\parname  {{\em replace}}
\pardescript  {if FALSE, do not overwrite existing key.} 

\parname  {{\em Return Value}}
\pardescript  {0 or -1.}
\hl{Description}
Sec\_gen\_key generates a
\bi
\m  DES key, 
    if the algorithm encryption method 
    of {\em key}\pf key\pf subjectAI (as returned by aux\_ObjId2AlgEnc()) is DES. 

    A DES key is a 64 bit long BitString.
\m  DES3 key, 
    if the algorithm encryption method 
    of {\em key}\pf key\pf subjectAI (as returned by aux\_ObjId2AlgEnc()) is DES3. 

    DES3 is triple block encryption in the fashion encryption(k1)-decryption(k2)-encryption(k1).
    A DES3 key is a 128 bit long BitString, the first 64 bits comprising k1 and the
    second 64 bits comprising k2.
\m  RSA key pair, 
    if the algorithm encryption method 
    of {\em key}\pf key\pf subjectAI (as returned by aux\_ObjId2AlgEnc()) is RSA. 

    An RSA public key is a BitString
    which contains the ASN.1 DER code of
    \bvtab
    \4  SEQUENCE \{ \\
    \4  \2       n INTEGER,   \\
    \4  \2       e INTEGER  \\
    \4  \} \\
    \evtab
    $n$ is the modulus and $e$ is the public exponent.
    

    An RSA secret key is a BitString
    which contains the ASN.1 DER code of
    \bvtab
    \4  SEQUENCE \{ \\
    \4  \2       p INTEGER,   \\
    \4  \2       q INTEGER  \\
    \4  \} \\
    \evtab
    $p$ and $q$ are the two prime factors of the modulus.

\m  DSA key pair, 
    if the algorithm encryption method 
    of {\em key}\pf key\pf subjectAI (as returned by aux\_ObjId2AlgEnc()) is DSA. 

    A DSA public key is a BitString
    which contains the ASN.1 DER code of
    \bvtab
    \4  SEQUENCE \{ \\
    \4  \2       key INTEGER, - - y (public key)   \\
    \4  \2       params DSAParameters OPTIONAL  \\
    \4  \} \\
    \evtab
    with
    \bvtab
    DSAParameters ::= SEQUENCE \{ \\
    \4  \2       prime1 [0] INTEGER, - - p \\
    \4  \2       prime2 [1] INTEGER, - - q \\
    \4  \2       base [2] INTEGER, - - g \\
    \4  \} \\
    \evtab
    
    A DSA secret key is a BitString
    which contains the ASN.1 DER code of
    \bvtab
    \4  SEQUENCE \{ \\
    \4  \2       key INTEGER, - - x (secret key)   \\
    \4  \2       params DSAParameters OPTIONAL  \\
    \4  \} \\
    \evtab
    with
    \bvtab
    DSAParameters ::= SEQUENCE \{ \\
    \4  \2       prime1 [0] INTEGER, - - p \\
    \4  \2       prime2 [1] INTEGER, - - q \\
    \4  \2       base [2] INTEGER, - - g \\
    \4  \} \\
    \evtab
\ei

The key is returned as follows in case of a DES key or DES3 key:
\be
\m If {\em key}\pf keyref $=$ 0 and {\em key}\pf pse\_sel is the NULL pointer, the generated key is
   returned as BitString in {\em key}\pf key\pf subjectkey. Memory is provided by the called program. 
\m If {\em key}\pf keyref $=$ 0 and {\em key}\pf pse\_sel is not the NULL pointer, the generated key
   is stored in the PSE object specified by {\em key}\pf pse\_sel.
   The object will be created first. If the object exists already and {\em replace} is FALSE, 
   {\em sec\_gen\_key} does not overwrite the object and returns -1.
\m If {\em key}\pf keyref $>$ 0, the generated key is stored under this key reference until it is
   deleted with sec\_del\_key.
   If the key reference exists already and {\em replace} is FALSE, {\em sec\_gen\_key}
   does not overwrite the key and returns -1.
\m If {\em key}\pf keyref $=$ -1, the generated key is stored under a key reference which is generated 
   by sec\_gen\_key and returned in {\em key}\pf keyref. The key remains there until it is deleted
   with sec\_del\_key.
\ee
The keys are returned as follows in case of an RSA or DSA key pair: 

The public key is returned in {\em key}\pf key\pf subjectkey. Memory is provided by the called program.
The private key is stored under a key reference or in a PSE object as described above for a DES key in 
cases 2, 3, or 4.

\subsubsection{sec\_get\_key}
\nm{3X}{sec\_get\_EncryptedKey}{Encrypt key}
\label{sec_get_enc_key}
\hl{Synopsis}
\#include $<$secure.h$>$ \\ [0.5cm]
RC {\bf sec\_get\_EncryptedKey} {\em (encrypted\_key, plain\_key, encryption\_key)} \\
EncryptedKey *{\em encrypted\_key}; \\
Key *{\em plain\_key}; \\
Key *{\em encryption\_key};
\hl{Parameter}
\parname  {{\em encrypted\_key}}
\pardescript  {Encrypted key.} 

\parname  {{\em plain\_key}}
\pardescript  {Structure which identifies the key to be encrypted.} 

\parname  {{\em encryption\_key}}
\pardescript  {Structure which identifies the encryption key.} 

\parname  {{\em Return Value}}
\pardescript  {0 or -1.}
\hl{Description}
The key identified by {\em plain\_key} is encrypted with the key and algorithm identified by
{\em encryption\_key} and returned in 
{\em encrypted\_key}. All memory in {\em encrypted\_key} which is referred to by pointers
is provided by the called program. 

This function is intended to support the so called ``hybrid method'' where information which
has to be transmitted confidentially is encrypted with the DES algorithm while the corresponding DES key
is transmitted in RSA encrypted form. Sec\_get\_encrypted\_key is useful for the sender
of such a key.

\subsubsection{sec\_put\_EncryptedKey}
\nm{3X}{sec\_get\_key}{Get key from key pool or from PSE}
\label{sec_get_key}
\hl{Synopsis}
\#include $<$secure.h$>$ \\ [0.5cm]
RC {\bf sec\_get\_key} {\em (keyinfo, keyref, key)} \\
KeyInfo *{\em keyinfo}; \\
KeyRef {\em keyref}; \\
Key *{\em key};
\hl{Parameter}
\parname  {{\em keyinfo}}
\pardescript  {KeyInfo structure which holds the returned key.} 

\parname  {{\em keyref}}
\pardescript  {Reference to an existing key.} 

\parname  {{\em key}}
\pardescript  {Structure which determines the key.} 

\parname  {{\em Return Value}}
\pardescript  {0 or -1.}
\hl{Description}
If {\em keyref} is non zero, the content of the keyinfo structure referenced 
by {\em keyref} is restored from the key pool and returned 
in {\em keyinfo}. The necessary memory in {\em keyinfo} is provided
by the called program. 

If {\em keyref} is zero, and {\em key} is not the NULL pointer, {\em key}
refers to the key to be returned.

\subsubsection{sec\_put\_key}
\nm{3X}{sec\_hash}{Hash octetstring}
\label{sec_hash}
\hl{Synopsis}
\#include $<$secure.h$>$ \\ [0.5cm]
RC {\bf sec\_hash} {\em (in\_octets, hash\_result, more, alg\_id, hash\_input)} \\
OctetString *{\em in\_octets}; \\
OctetString *{\em hash\_result}; \\
More {\em more}; \\
AlgId *{\em alg\_id}; \\
HashInput *{\em hash\_input};
\hl{Parameter}
\parname  {{\em in\_octets}}
\pardescript  {OctetString of the data to be hashed.} 

\parname  {{\em hash\_result}}
\pardescript  {OctetString of the hash result. Memory is provided by the called program.} 

\parname  {{\em more}}
\pardescript  {MORE: More data will follow for this hash process. \\
                  END: Last data of this hash process.} 
      
\parname  {{\em alg\_id}}
\pardescript  {Algorithm identifier of the hash function to be used. Each algorithm which is of type
              HASH or SIG (see INTRO(3)) is possible, e.g.: \\
                  sqmodn \\
                  md2 \\
                  md4 \\
                  md5 \\
                  sha \\
                  sqmodnWithRsa \\
                  md2WithRsa \\
                  md4WithRsa \\
                  md5WithRsa \\
                  md2WithRsaEncryption \\
                  md4WithRsaEncryption \\
                  md5WithRsaEncryption \\
                  rsa\_md2\_pem \\
                  rsa\_md5\_pem} \\ [0.5cm]
\parname  {{\em hash\_input}}
\pardescript  {Additional algorithm specific parameters.} 

\parname  {{\em Return Value}}
\pardescript  {0 or -1.}
\hl{Description}
OctetString {\em in\_octets} is hashed into octetstring {\em hash\_result} using the algorithm
{\em alg\_id}. {\em More} allows to chain several successive calls of sec\_hash to one
hash process. 

The number of octets in {\em in\_octets} is arbitrary. Sec\_hash puts the hash value as octetstring into
{\em hash\_result} in case of {\em more} $=$ END. The called program provides sufficient memory
in {\em hash\_result}. 

In case of sqmodn or sqmodnWithRsa, {\em hash\_input} is a BitString which contains the 
public key (as ASN.1 encoded sequence of the modulus $n$ and the public
exponent $e$). Sec\_hash extracts the modulus $n$ from this BitString by using the function
d\_KeyBits.

\subsubsection{sec\_sign}
\nm{3X}{sec\_open}{Open PSE or PSE object}
\label{sec_open}
\hl{Synopsis}
\#include $<$secure.h$>$ \\ [0.5cm]
RC {\bf sec\_open} {\em (pse\_sel)} \\
PSESel *{\em pse\_sel};
\hl{Parameter}
\parname  {{\em pse\_sel}}
\pardescript  {Structure which identifies the PSE object.} 

\parname  {{\em Return Value}}
\pardescript  {0 or -1.}
\hl{Description}
Sec\_open opens a PSE object. If the object is PIN protected, sec\_open performs
all necessary actions for the PIN check.
The object belongs to the application identified by {\em pse\_sel}\pf app\_name.
In case of the SW-PSE the application name is the name of the corresponding directory. 

{\em pse\_sel}\pf object.name is the name of the object to be opened. If {\em pse\_sel}\pf object.name
is the NULL pointer, sec\_open refers to the entire PSE. \\
If the object is PIN protected, the PIN check is performed with {\em pse\_sel}\pf object.pin.
If {\em pse\_sel}\pf object.pin is the NULL pointer, sec\_open asks for the PIN
interactively and returns the plain PIN in {\em pse\_sel}\pf object.pin. 

Sec\_open returns a reference number for the application in {\em pse\_sel}\pf app\_id which
can be used instead of the application name during successive sec\_close, sec\_read, 
or sec\_write calls.

\subsubsection{sec\_close}
\nm{3X}{sec\_put\_EncryptedKey}{Decrypt key}
\label{sec_put_decr_key}
\hl{Synopsis}
\#include $<$secure.h$>$ \\ [0.5cm]
RC {\bf sec\_put\_EncryptedKey} {\em (encrypted\_key, plain\_key, decryption\_key, replace)} \\
EncryptedKey *{\em encrypted\_key}; \\
Key *{\em plain\_key}; \\
Key *{\em decryption\_key}; \\
Boolean {\em replace};
\hl{Parameter}
\parname  {{\em encrypted\_key}}
\pardescript  {Encrypted key.} 

\parname  {{\em plain\_key}}
\pardescript  {Structure which determines the decrypted key.} 

\parname  {{\em decryption\_key}}
\pardescript  {Structure which identifies the decryption key.} 

\parname  {{\em replace}}
\pardescript  {If TRUE, replace existing key} 

\parname  {{\em Return Value}}
\pardescript  {0 or -1.}
\hl{Description}
The encrypted key given in {\em encrypted\_key} is decrypted with the key and algorithm identified by
{\em decryption\_key}. The decrypted key is handled according to {\em plain\_key} as follows: 

If {\em plain\_key}\pf keyref $=$ 0 and {\em plain\_key}\pf pse\_sel is the NULL pointer, the decrypted key is
returned as BitString in {\em plain\_key}\pf key\pf subjectkey. Memory is provided by the called program. 

If {\em plain\_key}\pf keyref $=$ 0 and {\em plain\_key}\pf pse\_sel is not the NULL pointer, the decrypted key
is stored in the PSE object specified by {\em plain\_key}\pf pse\_sel. The object must already exist. 

If {\em plain\_key}\pf keyref $>$ 0, the decrypted key is stored under this key reference until it is
deleted with sec\_del\_key. 

If {\em plain\_key}\pf keyref $=$ -1, the decrypted key is stored under a key reference which is generated 
by sec\_put\_EncryptedKey and returned in {\em plain\_key}\pf keyref. The key remains there until it is deleted
with sec\_del\_key. 

If the decrypted key is to be stored in the key\_pool or as PSE object, and a key with that
reference or name exists already, it will be replaced only in case of {\em replace} set to TRUE.

This function is intended to support the so called ``hybrid method'' where information which
has to be transmitted confidentially is encrypted with the DES algorithm while the corresponding DES key
is transmitted in RSA encrypted form. Sec\_put\_decrypted\_key is useful for the receiver
of such a key.

\subsubsection{sec\_string\_to\_key}
\nm{3X}{sec\_put\_key}{Put key to the key pool with reference number}
\label{sec_put_key}
\hl{Synopsis}
\#include $<$secure.h$>$ \\ [0.5cm]
RC {\bf sec\_put\_key} {\em (keyinfo, keyref)} \\
KeyInfo *{\em keyinfo}; \\
KeyRef {\em keyref};
\hl{Parameter}
\parname  {{\em keyinfo}}
\pardescript  {KeyInfo structure with the key to be stored in the key pool.} 

\parname  {{\em keyref}}
\pardescript  {Reference to a non existing key.} 

\parname  {{\em Return Value}}
\pardescript  {keyref or -1.}
\hl{Description}
The content of the given {\em keyinfo} is stored in the key pool according to {\em keyref}: 
\be
\m If {\em keyref} $>$ 0, {\em keyinfo} is stored under this key reference until it is
   deleted with sec\_del\_key. {\em keyref} must not exist.
\m If {\em key}\pf keyref $=$ -1, {\em keyinfo} is stored under a key reference which is generated 
   by sec\_put\_key and returned in the return value. It remains there until it is deleted
   with sec\_del\_key.
\ee

\subsubsection{sec\_del\_key}
\nm{3X}{sec\_random}{Generate random octetstring, bitstring, characterstring, integer, long}
\label{random}
\hl{Synopsis}
\#include $<$secure.h$>$ \\ [0.5cm]
OctetString {\bf *sec\_random\_ostr} {\em (noctets)} \\
unsigned int {\em noctets}; 

BitString {\bf *sec\_random\_bstr} {\em (nbits)} \\
unsigned int {\em nbits}; 

char {\bf *sec\_random\_str} {\em (nchar, chars)} \\
unsigned int {\em nchar}; \\
char *{\em chars}; 

int {\bf sec\_random\_int} {\em (r1, r2)} \\
int {\em r1, r2}; 

long {\bf sec\_random\_long} {\em (r1, r2)} \\
long {\em r1, r2};
\hl{Description}
Sec\_random\_* return each a randomly generated OctetString, BitString, or NULL-terminated
character string of the required length, and integer or long integer in the range between
{\em r1} and {\em r2} respectively. Memory is provided by the called program
where appropriate. 

In sec\_random\_str the set of characters the returned character string shall consist of can
be specified in {\em chars}. If {\em chars} is the NULL pointer, the returned character string
consists of the ASCII representation of characters as defined by the ASN.1 type
PrintableString.
They consist of the characters
\begin{center}
{\small
A to Z \\
a to z \\
0 to 9 \\
' ( ) + , - . / : = ?  
}
\end {center}

\subsubsection{sec\_create}
\nm{3X}{sec\_read}{Read PSE object into an octetstring}
\addtotoc{sec\_read\_PSE}
\label{sec_read}
\hl{Synopsis}
\#include $<$secure.h$>$ \\ [0.5cm]
RC {\bf sec\_read} {\em (pse\_sel, content)} \\
PSESel *{\em pse\_sel}; \\
OctetString *{\em content}; 

RC {\bf sec\_read\_PSE} {\em (pse\_sel, type, value)} \\
PSESel *{\em pse\_sel}; \\
ObjId *type; \\
OctetString *{\em value};
\hl{Parameter}
\parname  {{\em pse\_sel}}
\pardescript  {Structure which identifies the PSE object.} 

\parname  {{\em content}}
\pardescript  {Decrypted content of the object identified by {\em pse\_sel}\pf object.name.} 

\parname  {{\em type}}
\pardescript  {Object identifier of the PSE object.} 

\parname  {{\em value}}
\pardescript  {Decrypted content of the objectValue part of the object 
               identified by {\em pse\_sel}\pf object.name.} 

\parname  {{\em Return Value}}
\pardescript  {0 or -1.}
\hl{Description}
{\bf Sec\_read} reads the PSE object -- identified by {\em pse\_sel}\pf object.name 
and previously opened by sec\_open -- into octetstring {\em content}.
In case of PIN protection the octetstring is
decrypted before using the PIN which is either passed to the program through {\em pse\_sel}
or which was interactively asked for. Sec\_read reads the entire object. 

Sec\_read provides {\em content}\pf noctets and allocates the necessary memory
in {\em content}\pf octets which can be released by the calling program using free(). 

In case of a SW-PSE, the object can be read without being opened before. It is recommended, however,
to use sec\_open before reading an object to be compatible with applications using
a SC environment. \\ [1em]
{\bf Sec\_read\_PSE} returns the objectType in {\em type} and the DER-code of objectValue
in {\em value} for objects of the form
\bc
{\small
\bvtab
PSEObject ::= \3 {\bf SEQUENCE} \{ \\
\5 objectType \3 OBJECT IDENTIFIER, \\
\5 objectValue \3 ANY DEFINED BY objectType \\
\3 \}
\evtab
}
\ec
It uses d\_PSEObject() to decode PSEObject (see E\_SEC(3X)).
It returns -1 if the object is not of this form, i.e. it cannot be decoded with d\_PSEObject().
Sec\_read\_PSE allocates the necessary memory for {\em type}\pf oid\_elements and {\em value}\pf octets.

\subsubsection{sec\_write}
\nm{3X}{sec\_read\_toc}{Print the table of contents of the PSE}
\label{sec_print_toc}
\hl{Synopsis}
\#include $<$secure.h$>$ \\ [0.5cm]
RC {\bf sec\_print\_toc} {\em (pse\_sel)} \\
PSESel *{\em pse\_sel};
\hl{Parameter}
\parname  {{\em pse\_sel}}
\pardescript  {Structure which identifies the PSE.} 

\parname  {{\em Return Value}}
\pardescript  {0 or -1.}
\hl{Description}
The table of contents (toc) of the PSE identified by {\em pse\_sel} is printed to stderr.

\subsection{ASN.1 encoding and Decoding Functions}
\nm{3X}{sec\_rename}{Rename an object in the PSE}
\label{sec_rename}
\hl{Synopsis}
\#include $<$secure.h$>$ \\ [0.5cm]
RC {\bf sec\_rename} {\em (pse\_sel, name)} \\
PSESel *{\em pse\_sel}; \\
char  *{\em name};
\hl{Parameter}
\parname  {{\em pse\_sel}}
\pardescript  {Structure which identifies the PSE object.} 

\parname  {{\em name}}
\pardescript  {the new name of the PSE object.} 

\parname  {{\em Return Value}}
\pardescript  {0 or -1.}
\hl{Description}
The object of the PSE identified by {\em pse\_sel} will be renamed
with the name given in the second parameter. The contents of the
object will not be changed, but the Toc entry of this object
will reflect that change. If the call succeeds the function
returns 0, otherwise in case of errors -1.

\subsubsection{sec\_open}
\nm{3X}{sec\_sign}{Sign octetstring}
\label{sec_sign}
\hl{Synopsis}
\#include $<$secure.h$>$ \\ [0.5cm]
RC {\bf sec\_sign} {\em (in\_octets, signature, more, key, hash\_input)} \\
OctetString *{\em in\_octets}; \\
Signature *{\em signature}; \\
More {\em more}; \\
Key *{\em key}; \\
HashInput *{\em hash\_input};
\hl{Parameter}
\parname  {{\em in\_octets}}
\pardescript  {OctetString of the data to be signed.} 

\parname  {{\em signature}}
\pardescript  {Returned signature. Memory is provided by the called program.} 

\parname  {{\em more}}
\pardescript  {MORE: More data will follow for this sign process. \\
                  END: Last data of this sign process.} 

\parname  {{\em key}}
\pardescript  {Structure which identifies the signature key.} 

\parname  {{\em hash\_input}}
\pardescript  {Additional algorithm specific parameters.} 

\parname  {{\em Return Value}}
\pardescript  {0 or -1.}
\hl{Description}
In case of {\em more} $=$ MORE or END sec\_sign hashes {\em in\_octets} onto
an internal hash value, using the algorithm as described below.
If {\em hash\_input} is not the NULL pointer, this parameter is taken
as initial value for the hash function.
In case of {\em more} $=$ END this hash value is encrypted using key and
algorithm as described below and returned as BitString in {\em signature}\pf signature.
All necessary memory for returned information will be provided by the
called program. 

The signature key is determined by parameter {\em key} as follows:
\be
\m If {\em key}\pf key is not the NULL pointer, the structure it points to
   contains the key.
\m If {\em key}\pf key is the NULL pointer and {\em key}\pf keyref $>$ 0,
   the key which is referenced by this number is used. This is a key
   previously installed under this reference with {\em sec\_gen\_key} or 
   {\em sec\_put\_EncryptedKey}.
\m If {\em key}\pf key is the NULL pointer and {\em key}\pf keyref $=$ 0,
   {\em key}\pf pse\_sel indicates the PSE object which contains the key.
\ee
The algorithm to be used is determined in the following order:
\be
\m If {\em key}\pf alg is not the NULL pointer, this algorithm
   is used.
\m If {\em signature}\pf signAI is not the NULL pointer, this algorithm
   is used.
\m Otherwise, the algorithm associated to the key is used.
\ee
   The used algorithm identifier 
   is returned in {\em signature}\pf signAI.
   All necessary memory allocation is done by the called program.

If the algorithm is sqmodnWithRsa, {\em hash\_input} is a BitString which contains the 
public key (as ASN.1 encoded sequence of the modulus $n$ and the public
exponent $e$). The modulus $n$ is extracted from this BitString by using the function
d\_KeyBits.

\subsubsection{sec\_verify}
\nm{3X}{sec\_string\_to\_key}{Generate DES key from string}
\label{sec_string_to_key}
\hl{Synopsis}
\#include $<$secure.h$>$ \\ [0.5cm]
RC {\bf sec\_string\_to\_key} {\em (pin, des\_key)} \\
char *{\em pin}; \\
Key *{\em des\_key};
\hl{Parameter}
\parname  {{\em pin}}
\pardescript  {PIN (Personal Identification Number) or password.} 

\parname  {{\em des\_key}}
\pardescript  {Structure which determines the resulting DES key.} 

\parname  {{\em Return Value}}
\pardescript  {0 or -1.}                                
\hl{Description}
Sec\_string\_to\_key is a one-way function which generates a DES key from a PIN or password.
The resulting DES key is returned as specified by {\em des\_key}:
\be
\m If {\em des\_key}\pf keyref $=$ 0 and {\em des\_key}\pf pse\_sel is the NULL pointer, the generated key is
   returned as BitString in {\em des\_key}\pf key\pf subjectkey. Memory is provided by the called program. 
\m If {\em des\_key}\pf keyref $=$ 0 and {\em des\_key}\pf pse\_sel is not the NULL pointer, the generated key
   is stored in the PSE object specified by {\em des\_key}\pf pse\_sel. The object must already exist. 
\m If {\em des\_key}\pf keyref $>$ 0, the generated key is stored under this key reference until it is
   deleted with sec\_del\_key.
\m If {\em des\_key}\pf keyref $=$ -1, the generated key is stored under a key reference which is generated 
   by sec\_string\_to\_key and returned in {\em des\_key}\pf keyref. The key remains there until it is deleted
   with sec\_del\_key.
\ee
The assigned algorithm identifier is {\em desCBC} in either case.

\subsubsection{sec\_random}
\nm{3X}{sec\_verify}{Verify signature}
\label{sec_verify}
\hl{Synopsis}
\#include $<$secure.h$>$ \\ [0.5cm]
RC {\bf sec\_verify} {\em (in\_octets, signature, more, key, hash\_input)} \\
OctetString *{\em in\_octets}; \\
Signature *{\em signature}; \\
More {\em more}; \\
Key *{\em key}; \\
HashInput *{\em hash\_input};
\hl{Parameter}
\parname  {{\em in\_octets}}
\pardescript  {OctetString of the input data for the verification.} 

\parname  {{\em signature}}
\pardescript  {Signature to be verified.} 

\parname  {{\em more}}
\pardescript  {MORE: More input data will follow for this verification process. \\
                  END: Last input data of this verification process.} 

\parname  {{\em key}}
\pardescript  {Structure which identifies the verification key.} 

\parname  {{\em hash\_input}}
\pardescript  {Additional algorithm specific parameters.} 

\parname  {{\em Return Value}}
\pardescript  {0 (verification positive) or -1.}
\hl{Description}
In case of {\em more} $=$ MORE or END sec\_verify hashes {\em in\_octets} onto
an internal hash value, using the algorithm as described below.
If {\em hash\_input} is not the NULL pointer, this parameter is taken
as initial value for the hash function.
In case of {\em more} $=$ END the signature given in {\em signature}\pf signature
is decrypted using key and algorithm as described below, and the result is compared
with the previously computed internal hash value. If both are equal, the verification
is positive. 

The verification key is determined by parameter {\em key} as follows:
\be
\m If {\em key}\pf key is not the NULL pointer, the structure it points to
   contains the key.
\m If {\em key}\pf key is the NULL pointer and {\em key}\pf keyref $>$ 0,
   the key which is referenced by this number is used. This is a key
   previously installed under this reference with {\em sec\_gen\_key} or 
   {\em sec\_put\_EncryptedKey}.
\m If {\em key}\pf key is the NULL pointer and {\em key}\pf keyref $=$ 0,
   {\em key}\pf pse\_sel indicates the PSE object which contains the key.
\ee
The algorithm to be used is determined as follows:
\be
\m If {\em signature}\pf signAI\pf objid is not the NULL pointer, the algorithm
   determined by this object identifier is used.
\m Otherwise, i.e. if either {\em signature}\pf signAI or {\em signature}\pf signAI\pf objid 
   is the NULL pointer, the algorithm
   associated to the key determined by parameter {\em key} as above is used.
\ee
If the algorithm is sqmodnWithRsa, {\em hash\_input} is a BitString which contains the 
public key (as ASN.1 encoded sequence of the modulus $n$ and the public
exponent $e$). The modulus $n$ is extracted from this BitString by using the function
d\_KeyBits.

\subsubsection{sec\_gen\_key}
\nm{3X}{sec\_write}{Write PSE object from octetstring}
\addtotoc{sec\_write\_PSE}
\label{sec_write}
\hl{Synopsis}
\#include $<$secure.h$>$ \\ [0.5cm]
RC {\bf sec\_write} {\em (pse\_sel, content)} \\
PSESel *{\em pse\_sel}; \\
OctetString *{\em content}; 

RC {\bf sec\_write\_PSE} {\em (pse\_sel, type, value)} \\
PSESel *{\em pse\_sel}; \\
ObjId *type; \\
OctetString *{\em value};
\hl{Parameter}
\parname  {{\em pse\_sel}}
\pardescript  {Structure which identifies the PSE object.} 

\parname  {{\em content}}
\pardescript  {Decrypted content of the object identified by {\em pse\_sel}\pf object.name.} 

\parname  {{\em type}}
\pardescript  {Object identifier of the PSE object.} 

\parname  {{\em value}}
\pardescript  {Decrypted content of the objectValue part of the object 
               identified by {\em pse\_sel}\pf object.name.} 

\parname  {{\em Return Value}}
\pardescript  {0 or -1.}
\hl{Description}
{\bf Sec\_write} writes octetstring {\em content} to the PSE object specified by 
{\em pse\_sel}\pf object.name which has been previously opened by sec\_open. 
In case of PIN protection the octetstring is
PIN encrypted before. Sec\_write overwrites the entire object. 

In case of a SW-PSE, the object can be overwritten without being opened before. It is recommended, however,
to use sec\_open before writing an object to be compatible with applications using
a SC environment. \\ [1em]
{\bf Sec\_write\_PSE} encodes the given {\em type} and {\em value} into the DER-code of the 
ASN.1 structure
\bc
{\small
\bvtab
PSEObject ::= \3 {\bf SEQUENCE} \{ \\
\5 objectType \3 OBJECT IDENTIFIER, \\
\5 objectValue \3 ANY DEFINED BY objectType \\
\3 \}
\evtab
}
\ec
and writes it to the PSE object specified by {\em pse\_sel}\pf object.name. It uses the encoding function
e\_PSEObject() (see E\_SEC(3X)). Sec\_write\_PSE overwrites the entire object.

\subsubsection{sec\_chpin}
\nm{4}{INTRO}{Introduction to File and Object Formats}
\label{intro4}
\hl{Description}
In order to achieve a system independant bit representation, all security 
objects 
which are stored on files or exchanged via communication protocols are 
defined as ASN.1 structures and encoded by applying
the {\em Basic Enoding Rules for ASN.1} (BER) with X.509 DER restrictions 
to these 
ASN.1 structures. This is simply called DER code in the following. 

Within a C-program those objects have corresponding C-structure 
representations.

The following section describes all objects of the PSE, presenting their 
ASN.1 definitions
and the corresponding C-structures, and all objects which are exchanged via 
the X.400-88
protocols.

The available encoding and decoding functions which provide the mapping 
between the 
program-internal C-structures and the corresponding ASN.1 DER-code and vice 
versa are described
in E\_SEC(3X), E\_AF(3X), and E\_X400(3X).

\nm{4}{AF-Dir-Objects}{Directory Objects of the AF-Interface}
\label{af-dirobj}

\hl{Synopsis}

\#include $<$af.h$>$

\hl{Description}
     
This section lists directory objects needed by the
directory oriented af\_dir\_retrieve\_* and af\_dir\_enter\_* functions.
Each object is presented in terms of C-language structures
as they are needed by the interface subroutines and
by the application programmer.
The bit coding of the objects is given by applying
ASN.1 Basic Encoding Rules to the corresponding ASN.1 structures as they
are defined in Vol. 2, 2.1. Transformation between those two representations
is provided by the respective encoding/decoding functions e\_*(3X).

\subsubsection{Directory Attributes}
\hll{Attribute}
Directory attribute type and values. \\
\underline{C-Structure of the object:}

{\small
\btab
\1      typedef struct Attribute \{ \\
\2              ObjId \2   type; \\
\2              SET\_OF \2      *value; \\
\1       \} Attribute; \\ \\ \\
with:   \\ \\
\1      typedef struct set\_of \{ \\
\2              char  \2          *element; \\
\2              struct set\_of \2 *next; \\
\1      \} SET\_OF; \\
\etab
}

The structure SET\_OF can be used by any ASN.1 type ``SET OF'',
in that the subfield {\em *element} is only a placeholder
of an address of the respective SET element.
In particular, attributes are described by an attribute type
and a set of attribute values. In the following example,
the use of these C-structures is demonstrated with
the attribute type ``Certificate''.

{\small
\btab
\1 /* example use: */   \\ \\
\2      SET\_OF     \2   *attrvalue; \\
\2      Attribute   \2   *acert;     \\
\2      Certificate \2   *cert;      \\ \\
\2      for( attrvalue = acert$->$value;  \\
\3         attrvalue != (SET\_OF *)0;  \\
\3         attrvalue = attrvalue$->$next ) \\
\2         \{ /* work on */ cert = (Certificate *)attrvalue$->$element; \} \\
\etab
}

Encoding (and decoding) of an attribute depends on its attribute type.
Thus, before encoding (and decoding) {\em value}\pf {\em element},
the ObjId {\em type} is evaluated.
\\
Encoding/Decoding: e\_Attribute(), d\_Attribute() \\
Used by: af\_dir\_retrieve\_*(), af\_dir\_enter\_*()

\subsubsection{PemCrl}
\hll{PemCrl}
Revocation List with PEM syntax. \\
\underline{C-Structure of the object:}

{\small
\btab
\1      typedef struct PemCrl \{  \\
\2              OctetString \5  *tbs\_DERcode; \\
\2              PemCrlTBS  \5   *tbs;        \\
\2              Signature \5    *sig; \\
\1      \} PemCrl;  \\ \\
with: \\ \\
\1      typedef struct PemCrlTBS \{ \\
\2              AlgId \5        *signatureAI; \\
\2              DName \5         *issuer; \\
\2              SEQUENCE\_OF\_RevCertPem \5     *revokedCertificates; \\
\2              UTCTime  \5     *lastUpdate; \\
\2              UTCTime  \5     *nextUpdate; \\
\1       \} PemCrlTBS; \\ \\
\1      typedef struct Signature \{  \\
\2              AlgId \5        *signAI; \\
\2              BitString \5    signature; \\
\1 \}           Signature;  \\ \\
\1      typedef struct RevCertPem \{ \\
\2              int  \5          serialnumber; \\
\2              UTCTime \5      *revocationDate; \\
\1      \} RevCertPem;  \\ \\
with: \\ \\
\1      typedef struct sequence\_of\_RevCertPem \{ \\
\2              RevCertPem          \5 *element; \\
\2              SEQUENCE\_OF\_RevCertPem \5 *next; \\
\1      \} SEQUENCE\_OF\_RevCertPem;  \\
\etab
}

Below, a search in a list of revoked certificates is demonstrated:

{\small
\btab
\1 /* Search revoked certificates: */ \\ \\
\1      PemCrl   \4 *pemcrl;    \\
\1      SEQUENCE\_OF\_RevCertPem \4 *seq;  \\
\1      /* First verify pemcrl$->$sig with pemcrl$->$tbs\_DERcode. Then: */ \\
\1      for( seq = pemcrl$->$tbs$->$revokedCertificates; \\
\2        seq != (SEQUENCE\_OF\_RevCertPem *)0; \\
\2        seq = seq$->$next ) \\
\1      \{ /* check seq$->$element$->$serialnumber and seq$->$element$->$revocationDate */ \} \\
\etab
}

Encoding/Decoding: e\_PemCrl(), d\_PemCrl() \\
Used by: af\_dir\_retrieve\_PemCrl(), af\_dir\_enter\_PemCrl()


\subsection{CA Database Objects}
\nm{4}{AF-PSE-objects}{PSE objects of the AF-interface}
\label{af-sw-cc}

\hl{Synopsis}

\#include $<$af.h$>$

\hl{Description}
     
This section lists PSE objects needed by the af\_* functions. 
Each object is presented both in terms
of C-language structures as they are needed by the interface subroutines and
by the application programmer, and in terms of corresponding ASN.1 structures
which are needed as references for the bit coding of the object.
 
Each AF PSE object is wrapped in the following ASN.1 structure:
{\small
\bvtab
\2 PSEObject ::= \3 {\bf SEQUENCE} \{ \\
\7 objectType \3 OBJECT IDENTIFIER, \\
\7 objectValue \3 ANY DEFINED BY objectType \\
\5 \}
\evtab
}
The following object identifiers are used:
\bc
\begin{tabular}{|l|l|l|} \hline
{\bf Object Name} & {\bf Object Identifier} & {\bf Content} \\ \hline
SignCert       & \{ 1 3 36 2 1 1 \} & certificate of public verification key      \\
EncCert        & \{ 1 3 36 2 1 2 \} & certificate of public encryption key        \\
Cert           & \{ 1 3 36 2 1 3 \} & certificate of public key                    \\
SignCSet       & \{ 1 3 36 2 2 1 \} & cross-certificates of public verification key \\
EncCSet        & \{ 1 3 36 2 2 2 \} & cross-certificates of public encryption key   \\
CSet           & \{ 1 3 36 2 2 3 \} & cross-certificates of public key            \\
CrossCSet      & \{ 1 3 36 2 8 1 \} & cross certificate pairs		     \\
SignSK         & \{ 1 3 36 2 3 1 \} & secret signature key                        \\
DecSKnew       & \{ 1 3 36 2 3 2 \} & secret decryption key (current)             \\
DecSKold       & \{ 1 3 36 2 3 3 \} & secret decryption key (old)                 \\
SKnew          & \{ 1 3 36 2 3 4 \} & secret key (current)                        \\
SKold          & \{ 1 3 36 2 3 5 \} & secret key (old)                            \\
FCPath         & \{ 1 3 36 2 4 1 \} & forward certification path                  \\
PKRoot         & \{ 1 3 36 2 5 1 \} & top level public verification key           \\
PKList         & \{ 1 3 36 2 6 1 \} & list of trusted public verification keys    \\
EKList         & \{ 1 3 36 2 6 2 \} & list of trusted public encryption keys      \\
CrlSet         & \{ 1 3 36 2 9 1 \} & list of revocation lists         \\
SerialNumbers  & \{ 1 3 36 2 10 1 \} & current serial number (CA only)         \\
EDBKey         & \{ 1 3 36 2 11 1 \} & DSA database encryption key        \\
AliasList      & \{ 1 3 36 2 12 1 \} & user's alias list         \\
QuipuPWD       & \{ 1 3 36 2 13 1 \} & password for X.500 directory access         \\
Name           & \{ 1 3 36 2 7 1 \}  & owner's distinguished name                      \\ \hline
\end{tabular}
\ec
The AF PSE objects {\em Cert}, {\em CSet}, {\em SKnew}, and {\em SKold} are used in case
of a PSE which is restricted to hold a single RSA key pair for both signature and encryption purposes.
In this case, there are no objects {\em SignCert}, {\em EncCert}, {\em SignCSet}, {\em EncCSet}, {\em SignSK},
{\em DecSKnew}, and {\em DecSKold} installed on the PSE. \\ [1em]
The object identifier of each object is given in the table above.

The structure of objectValue of each object is given in the sections below.
The whole objects (i.e. the DER-code of PSEObject) can be read/written from/to
the PSE using the functions sec\_read() and sec\_write(). The DER-code
of objectValue can be read/written from/to the PSE using the functions
sec\_read\_PSE() and sec\_write\_PSE().
The transformation between the C-representation and the DER oriented bit coding
is provided by the respective encoding/decoding functions e\_*(3X). 

\subsubsection{Name}
\hll{Name}
Owner's distinguished name \\
\underline{C-Structure of the object:} DName

{\small
\bvtab
\2 typedef struct DName DName;                  \\
\2 typedef struct RDName RDName;                \\
\2 typedef struct AVA AVA;                      \\
\2 struct DName \{                              \\
\4        RDName       \3 *element\_IF\_2;      \\
\4        DName        \3 *next;                \\
\2 \}                                           \\ [1em]
\2 struct RDName \{                             \\
\4        AVA          \3 *member\_IF\_0;       \\
\4        RDName       \3 *next;                \\
\2 \};                                          \\ [1em]
\2 struct AVA \{                                \\ 
\4        ObjId  \3 *element\_IF\_0;            \\
\4        PElement     \3 *element\_IF\_1;      \\
\2 \};                                          \\
\evtab
}

\underline{ASN.1-Structure of objectValue:}

{\small
\begin {center}
\begin {tabular}{ll}
Name & ::= DistinguishedName    \\
DistinguishedName & ::= RDNSequence              \\
RDNSequence  & ::= {\bf SEQUENCE OF} RelativeDistinguishedName \\
 & \\
RelativeDistinguishedName & ::= {\bf SET OF} AttributeValueAssertion \\
 & \\
AttributeValueAssertion   &
   ::= {\bf SEQUENCE} \{ AttributeType, AttributeValue \} \\
 & \\
AttributeType  &  ::= {\bf OBJECT IDENTIFIER} \\
AttributeValue &  ::= {\bf ANY} -- -- defined by AttributeType
\end {tabular}
\end {center}
}
The X.500 recommendations on the directory specify
distinguished names for the purpose of unique identification of the directory objects
(X.501, Directory Information Model).
For example, distinguished names are assigned to human users.
Also, issuer and subject of a certificate are identified by their distinguished names.
The format of distinguished names is defined in
X.501, Annex C.
The directory attribute {\em DistinguishedName} is a sequence of {\em Relative DistinguishedName}
which in turn is a set of attributeType/attributeValue pairs.
Within SecuDe
only a limited set of attribute types is used to construct relative distinguished names,
these are:
countryName, organizationalName, organizationalUnitName, commonName, surname,
title, serialNumber, localityName, streetAddress, and businessCategory.
All other attribute types would be ignored. SecuDE uses the X.520 defined object identifiers
for the identification of attribute types.

The corresponding C structure {\em DName} uses the ISODE defined presentation element
PElement to carry the attribute value. 
\\ [1em]
Encoding/Decoding: e\_DName(), d\_DName(),

which transform between the C-structure {\em DName} and the ASN.1 DER code.
There are other name transformation functions which transform between
the printable representation {\em Name} and the C-structure {\em DName}: \\
aux\_Name2DName(), aux\_DName2Name() (see AUX\_NAME(3X)).

\subsubsection{SignSK}
\hll{SKnew, SKold, DecSKnew, DecSKold, SignSK}
Secret component of asymmetric key pair.

\underline{C-Structure of the object:} KeyInfo
{\small
\bvtab
\4      typedef struct KeyInfo \{ \\
\6              AlgId        \3 *subjectAI; \\
\6              BitString    \3 subjectkey; \\
\4      \} KeyInfo; \\ \\ \\
with: \\ \\
\4      typedef struct AlgId \{  \\
\6              ObjId  \3 *objid; \\
\6              char         \3 *parm; \\
\4      \} AlgId; \\ \\ \\
\4      typedef struct ObjId \{  \\
\6              int          \3 oid\_nelem; \\
\6              unsigned int \3 *oid\_elements; \\
\4      \} ObjId;  \\  \\ \\
\4      typedef struct BitString \{  \\
\6              unsigned int \3 nbits; \\
\6              char         \3 *bits; \\
\4      \} BitString;  \\
\evtab
}

\underline{ASN.1-Structure of objectValue:}
{\small
\bvtab
\4 SubjectPrivateKeyInfo
\evtab
}

{\em SubjectPrivateKeyInfo} is defined to have the same format as
{\em SubjectPublicKeyInfo}, cf. X.509, Annex G.
However, note the substructure of the private key BIT STRING.

{\small
\bvtab
\1 SubjectPrivateKeyInfo ::= \5 {\bf SEQUENCE} \{  \\
\7 algorithm         \2 AlgorithmIdentifier,    \\
\7 subjectPrivateKey BitString            \\
\7 -- -- \\
\7 -- -- the BitString of subjectPrivateKey   \\
\7 -- -- contains the ASN.1 encoding of a sequence of \\
\7 -- -- the factors p and q of the RSA-modulus n:   \\
\7 -- -- \\
\7 -- -- SEQUENCE \{ \\
\7 -- -- \2       p INTEGER,   \\
\7 -- -- \2       q INTEGER  \\
\7 -- -- \} \\
\6 \} \\
\evtab
\bvtab
\1 AlgorithmIdentifier ::= \5 {\bf SEQUENCE} \{    \\
\7 algorithm  \3 OBJECT IDENTIFIER, \\
\7 parameters \3 ANY DEFINED BY algorithm  \\
\6 \}
\evtab
}

Encoding/Decoding: e\_KeyInfo(), d\_KeyInfo() \\
Used by: af\_sign()


\subsubsection{Cert}
\hll{Cert, SignCert, EncCert}
X.509 Public key certificate (which is a User Certificate or a CA Certificate) 

\underline{C-Structure of the object:}

{\small
\bvtab
\4      typedef struct Certificate \{  \\
\6              OctetString   \4 *tbs\_DERcode; \\
\6              ToBeSigned    \4 *tbs; \\
\6              Signature     \4 *sig; \\
\4      \} Certificate;  \\ \\ \\
with: \\ \\
\4      typedef struct Signature \{  \\
\6              AlgId         \3 *signAI; \\
\6              BitString     \3 signature; \\
\4 \}           Signature;  \\ \\ \\
\4      typedef struct ToBeSigned \{ \\
\6              int           \3 version; \\
\6              int           \3 serialnumber; \\
\6              AlgId         \3 *signatureAI; \\
\6              DName          \3 *issuer; \\
\6              UTCTime       \3 *notbefore; \\
\6              UTCTime       \3 *notafter; \\
\6              DName          \3 *subject; \\
\6              KeyInfo       \3 *subjectPK; \\
\4      \} ToBeSigned;  \\ \\ \\
\4      typedef struct KeyInfo \{  \\
\6              AlgId         \3 *subjectAI; \\
\6              BitString     \3 subjectkey; \\
\4      \} KeyInfo; \\ \\ \\
\4      typedef struct OctetString \{ \\
\6              unsigned int  \3 noctets; \\
\6              char          \3 *octets; \\
\4      \} OctetString;  \\ \\ \\
\4      typedef char UTCTime;
\evtab
}
and AlgId, BitString as in SKnew.

\underline{ASN.1-Structure of objectValue:}
{\small
\bvtab
\1 Cert ::=    \3 Certificate \\ \\
\1 Certificate ::= \3 {\bf SIGNED SEQUENCE} \{  \\
\5 version [0]          \5 INTEGER DEFAULT 0,          \\
\5 serialNumber         \5 INTEGER,                    \\
\5 signature            \5 AlgorithmIdentifier,        \\
\5 issuer               \5 Name,                       \\
\5 validity             \5 Validity,                   \\
\5 subject              \5 Name,                       \\
\5 subjectPublicKeyInfo \5 SubjectPublicKeyInfo     \\
\4 \}
\evtab
}
 
{\em Certificate} is defined by X.509, Annex G.
{\em Algorithm\-Identifier} is defined in X.509, Annex G,
as a SEQUENCE of an Object Identifier and a parameters type
which depends on the algorithm.
{\em Name} is defined in X.501, Annex C,
as a SEQUENCE of Relative Distinguished Names,
which are sets of Attribute-Value-Assertions.
{\em Validity} is defined in X.509, Annex G,
as a SEQUENCE of the UTCTimes {\em notBefore} and {\em notAfter}.


{\em SubjectPublicKeyInfo} is defined by X.509, Annex G.
The substructure of the public key BitString is defined by
X.509, Annex C, C.3.
\\ [1em]

{\small
\bvtab
\1 SubjectPublicKeyInfo ::= \5 {\bf SEQUENCE} \{  \\
\7 algorithm         \2 AlgorithmIdentifier,    \\
\7 subjectPublicKey  BitString            \\
\7 -- -- \\
\7 -- -- the BitString of subjectPublicKey   \\
\7 -- -- contains the ASN.1 encoding of a sequence of \\
\7 -- -- the RSA-modulus n and the pubRSA-exponent e:   \\
\7 -- -- \\
\7 -- -- SEQUENCE \{ \\
\7 -- -- \2       n INTEGER,   \\
\7 -- -- \2       e INTEGER  \\
\7 -- -- \} \\
\6 \} \\
\evtab
}

See also X.509, Annex G, for the SIGNED MACRO,
which is replaced by the following MACRO:

{\small
\begin {center}
\begin {tabular}{lll}
SIGNED MACRO   ::= & & \\
BEGIN              & & \\
TYPE NOTATION  ::= & type(ToBeSigned)     & \\
VALUE NOTATION ::= & type(VALUE           & \\
		   & SEQUENCE \{          & \\
		   & ToBeSigned,          & \\
		   & AlgorithmIdentifier, & \\
 & \multicolumn{2}{l} {-- -- of the algorithm used to generate}  \\
 & \multicolumn{2}{l} {-- -- the signature}                      \\
		   & BitString \}          & \\
 & \multicolumn{2}{l} {-- -- where the BIT STRING is the result} \\
 & \multicolumn{2}{l} {-- -- of the encryption of the value}     \\
 & \multicolumn{2}{l} {-- -- of the hash of ToBeSigned}          \\
 & ) & \\
END & &
\end {tabular}
\end {center}
}
 
Encoding/Decoding: e\_Certificate(), d\_Certificate() \\
Used by: af\_pse\_get\_Certificate(), af\_pse\_get\_Certificates(), af\_pse\_update\_Certificate(), 

\subsubsection{SignCSet}
\hll{CSet, SignCSet, EncCSet}
CrossCertificates issued for the own public signature or encryption key.

\underline{C-Structure of the object:}

{\small
\begin{center}
typedef SET\_OF(Certificate)	SET\_OF\_Certificate;
\end{center}
}

{\em ASN.1-Structure of objectValue:}
{\small
\begin{center}
{\bf SET OF} Certificate
\end{center}
}
Encoding/Decoding: e\_CertificateSet(), d\_CertificateSet()



\subsubsection{CrossCSet}
\hll{CrossCSet}
Cross Certificate Pairs issued for the own public signature key.

\underline{C-Structure of the object:} 
{\small
\bvtab
\4 typedef SET\_OF(CertificatePair)	SET\_OF\_CertificatePair;
\evtab
}


\underline{ASN.1-Structure of objectValue:}
{\small
\bvtab
\4        CrossCSet ::= {\bf SET OF} CertificatePair \\ [0.5cm]
\4        CertificatePair ::= \4 {\bf SEQUENCE} \{ \\
\9                 forward [0] Certificate OPTIONAL, \\
\9                 reverse [1] Certificate OPTIONAL  \\
\8 \}
\evtab
}

Encoding/Decoding: e\_CertificatePairSet(), d\_CertificatePairSet()

\subsubsection{FCPath}
\hll{FCPath}
Own Forward Certification Path. 

\underline{C-Structure of the object:}

{\small
\bvtab
\4      typedef struct FCPath \{  \\
\6              SET\_OF\_Certificate \4 *liste; \\
\6              FCPath               \4 *next\_forwardpath; \\
\4      \} FCPath;  \\ \\ \\
with: \\ \\
\4      typedef struct set\_of\_Certificate \{ \\
\6              Certificate          \4 *element; \\
\6              SET\_OF\_Certificate \4 *next; \\
\4      \} SET\_OF\_Certificate;  \\
\evtab
}


\underline{ASN.1-Structure of objectValue:}
{\small
\bvtab
\2 FCPath ::=                    \6 ForwardCertificationPath \\
\2 ForwardCertificationPath ::=  \6 {\bf SEQUENCE OF} CrossCertificates \\
\2 CrossCertificates ::=         \6 {\bf SET OF} Certificate
\evtab
}

{\em FCPath} is an element of {\em Certificates} (note the plural).
{\em Certificates} is defined in X.509, Annex G,
as a SEQUENCE of a user certificate and a forward certification path.
The forward certification path is a SEQUENCE of cross certificates,
which are SETs of 1-level certificates.
One cross certificate per SET is supposed to be
the hierarchy certificate of the path.
The data of the PSE object {\em FCPath}
can be composed with the data of
{\em Cert} or of
{\em SignCert} in order to build an
n-level originator certificate of ASN.1-type {\em Certificates}.

{\small
\bvtab
\1 Certificates ::= \3 {\bf SEQUENCE} \{   \\
\5 certificate          \4 Certificate,                \\
\5 certificationPath    \4 ForwardCertificationPath OPTIONAL   \\
\4 \}
\evtab
}

Encoding/Decoding: e\_FCPath(), d\_FCPath() \\
Used by: af\_pse\_get\_FCPath(), af\_pse\_update\_FCPath(), af\_pse\_get\_Certificates()

\subsubsection{PKRoot}
\hll{PKRoot}
Public key of the root CA (actual/old version).

\underline{C-Structure of the object:}

{\small
\bvtab
\4      typedef struct PKRoot \{ \\
\6              DName          \3 *ca; \\
\6              struct Serial \3 *new; \\
\6              struct Serial \3 *old; \\
\4      \} PKRoot;  \\ \\ \\
with: \\ \\
\4      struct Serial \{ \\
\6             int            \3 serial; \\
\6             KeyInfo        \3 *key; \\
\4      \}; \\
\evtab
}


\underline{ASN.1-Structure of objectValue:}

{\small
\bvtab
\3 PKRoot ::= \3 {\bf SEQUENCE} \{     \\
\7 cA                \2 Name,                 \\
\7 serialNew         \2 INTEGER,              \\
\7 keyNew            \2 SubjectPublicKeyInfo, \\
\7 serialOld         \2 INTEGER,              \\
\7 keyOld            \2 SubjectPublicKeyInfo \\
\6 \}
\evtab
}
 
{\em Name} is defined in X.501, Annex C,
as a SEQUENCE of Relative Distinguished Names,
which are sets of Attribute-Value-Assertions.
{\em SubjectPublicKeyInfo} is defined by X.509, Annex G.


Encoding/Decoding: e\_PKRoot(), d\_PKRoot() \\
Used by: af\_pse\_get\_PKRoot(), af\_pse\_update\_PKRoot(), af\_verify()

\subsubsection{PKList}
\hll{PKList, EKList}
{\em Content of the object:} Trusted public keys of communication partners.
 
\underline{C-Structure of the object:}

{\small
\bvtab
\4      typedef struct set\_of\_ToBeSigned \{ \\
\6              ToBeSigned   \3 *element; \\
\6              PKList       \3 *next; \\
\4      \} PKList; \\ \\ \\
\evtab
}


\underline{ASN.1-Structure of objectValue:}

{\small
\bvtab
\3 PKList ::= \3 {\bf SET OF SEQUENCE} \{  \\
\7 version [0]     \3 INTEGER DEFAULT 0,       \\
\7 serialNumber    \3 INTEGER,                 \\
\7 signature       \3 AlgorithmIdentifier,     \\
\7 issuer          \3 Name,                    \\
\7 validity        \3 Validity,                \\
\7 partner         \3 Name,                    \\
\7 verificationKey \3 SubjectPublicKeyInfo \\
\6 \}
\evtab
}
 
Compare the definition of {\em Certificate} above. A PKList is defined
as a set of {\em ToBeSigned} values of certificates.
 
The {\em verificationKey} is supposed to have the value
of the currently valid public verification key of the {\em partner}.
Before adding it to this list, it should be verified through
the full certification path.


Encoding/Decoding: e\_PKList(), d\_PKList() \\
Used by: af\_pse\_get\_PKList(), af\_pse\_update\_PKList(), af\_pse\_add\_PK(), af\_pse\_update\_PK(),
af\_pse\_delete\_PK(), af\_pse\_get\_owner()


\subsubsection{CrlSet}
\hll{CrlSet}
Set of Revocation Lists of all known certification authorities.
 
\underline{C-Structure of the object:}

{\small
\bvtab
\4      typedef struct set\_of\_CrlPSE \{ \\
\6              CrlPSE   \3 *element; \\
\6              CrlSet   \3 *next; \\
\4      \} CrlSet; \\ \\ \\
with: \\ \\
\4      typedef struct CrlPSE \{ \\
\6              DName          \3 *issuer; \\
\6              UTCTime        \3 *nextUpdate; \\
\6              SET\_OF\_int     \3 *serialset; \\
\4      \} CrlPSE;  \\ \\ \\
with: \\ \\
\4      typedef struct set\_of\_int \{ \\
\6              int          \3 element; \\
\6              SET\_OF\_int \3 *next; \\
\4      \} SET\_OF\_int;  \\
\evtab
}


\underline{ASN.1-Structure of objectValue:}

{\small
\bvtab
\3 CrlSet ::= \3 {\bf SET OF SEQUENCE} \{  \\
\7 issuer          \3 Name,                    \\
\7 nextUpdate      \3 UTCTime,                \\
\7 serialset       \3 SET OF INTEGER          \\
\6 \}
\evtab
}
 
Encoding/Decoding: e\_CrlSet(), d\_CrlSet() \\
Used by: af\_pse\_get\_CrlSet(), af\_pse\_update\_CrlSet()


\subsubsection{SerialNumbers}
\hll{SerialNumbers}
Serial Numbers used by a certification authority.
 
\underline{C-Structure of the object:}

{\small
\bvtab
\4      typedef struct SerialNumbers \{ \\
\6              int   \3 initial; \\
\6              int   \3 actual; \\
\4      \} SerialNumbers;
\evtab
}

\underline{ASN.1-Structure of objectValue:}

{\small
\bvtab
\3 SerialNumbers ::= \3 {\bf SEQUENCE} \{     \\
\7 initial         \2 INTEGER,    \\
\7 actual          \2 INTEGER     \\
\6 \}
\evtab
}

{\em initial} contains the value of the serialnumber assigned to the first
certificate issued by the certification authority, whereas {\em actual}
holds the value of the serialnumber which will be assigned to the certificate that will next be issued
by the certification authority.


Encoding/Decoding: e\_SerialNumbers(), d\_SerialNumbers() \\
Used by: af\_pse\_get\_SerialNumbers(), af\_pse\_update\_SerialNumbers()


\subsection{Directory Objects}
\nm{4}{CA-Database-objects}{CA Database objects of the AF-interface}
\label{cadb}

\hl{Synopsis}

\#include $<$af.h$>$

\hl{Description}
     
This section lists CA database objects required by the af\_cadb\_* functions. 
Each object is presented in terms of C-language structures as they are needed by the 
interface subroutines and by the application programmer. 
\subsubsection{IssuedCertificate}
\hll{IssuedCertificate}
Serial number and date of issue. \\
\underline{C-Structure of the object:}

{\small
\btab
\1      typedef struct IssuedCertificate \{ \\
\2              int  \2          serialnumber; \\
\2              UTCTime \2  *date\_of\_issue; \\
\1       \} IssuedCertificate; \\
\etab
}

Encoding/Decoding: e\_IssuedCertificate(), d\_IssuedCertificate()

\subsubsection{PemCrlWithCerts}
\hll{PemCrlWithCerts}
PEM Revocation List with Originator Certificate. \\
\underline{C-Structure of the object:}

{\small
\btab
\1      typedef struct PemCrlWithCerts \{ \\
\2              PemCrl  \2          *pemcrl; \\
\2              Certificates \2  *certificates; \\
\1       \} PemCrlWithCerts; \\
\etab
}

Encoding/Decoding: e\_PemCrlWithCerts(), d\_PemCrlWithCerts()



\subsection{PSE Selection}
\label{cc_sel}
\nm{4}{SEC-PSE-Objects}{PSE Objects of the SEC-Interface}
\label{sec-sw-cc}
\hl{Synopsis}
\#include $<$secure.h$>$ 

\hl{Description}     
This section lists PSE objects needed by the sec\_* functions. Each object is presented in terms
of C-language structures as they are needed by the interface subroutines and
by the application programmer as well. The bit coding of the objects in the PSE
is given by applaying ASN.1 Basic Encoding Rules to the corresponding ASN.1 structures which
are additionally listed here.
Transformation between those two representations
is provided by the respective encoding/decoding functions e\_*(3X).

\subsubsection{Keys}
\hll{Keys}
On invocation of {\em sec\_encrypt}, {\em sec\_decrypt}, {\em sec\_sign}, {\em sec\_verify},
{\em sec\_get\_EncryptedKey}, {\em sec\_put\_EncryptedKey}, and {\em sec\_gen\_key}, necessary
keys can also be specified by reference to a PSE object (through parameter {\em key}). In this
case, the PSE object must be internally structured as X.509 (Annex G) defined
{\em SubjectPublicKeyInfo}. Seen from the C-language programmer, the PSE object 
has the following structure:
       
{\small
\bvtab
\4      typedef struct KeyInfo \{ \\
\6              AlgId \3        *subjectAI; \\
\6              BitString \3    subjectkey; \\
\4      \} KeyInfo;  \\
\evtab
}

In case of RSA keys, the BitString {\em subjectkey} consists of the ASN.1-encoded representation of the
ASN.1 sequence {\em KeyBits} (see SEC-PSE-OBJECTS(4)). 
It can be decoded with the function
{\em d\_KeyBits()} into the following C-structure:

{\small
\bvtab
\4      typedef struct KeyBits \{ \\
\6	        OctetString \4 part1; \\
\6      	OctetString \4 part2; \\
\4      \} KeyBits; \\
\evtab
}

Part1 and part2 contain the prime numbers $p$ and $q$ in case of secret keys, and the 
modulus $m$ and the public exponent $e$ in case of public keys. The content of the
C-structure can be encoded into the ASN.1-encoded BitString with the function
{\em e\_KeyBits()}.

The corresponding ASN.1 notation which is the basis for the bit coding of the objects are:

{\small
\bvtab
\1 KeyInfo ::= \3 {\bf SEQUENCE} \{  \\
\5 algorithm         \2 AlgorithmIdentifier,    \\
\5 key               \2 BitString            \\
\5 -- -- \\
\5 -- -- the BitString of key    \\
\5 -- -- contains the ASN.1 encoding of a sequence of two \\
\5 -- -- INTEGERs part1 and part2, which are the RSA-modulus    \\
\5 -- -- n and the public RSA-exponent e in case of a public key,    \\
\5 -- -- or the two prime numbers $p$ and $q$ in case of a secret key.    \\
\5 -- -- \\
\5 -- -- SEQUENCE \{ \\
\5 -- -- \2       part1 INTEGER,   \\
\5 -- -- \2       part2 INTEGER  \\
\5 -- -- \} \\
\4 \}
\evtab
}

and

{\small
\bvtab
\1 KeyBits ::= \3 {\bf SEQUENCE} \{ \\
\5                 part1 \2  INTEGER    \\
\5                 part2 \2  INTEGER \\
\4 \}
\evtab
}


For explanation of the used names see SEC(5). 

The OctetString which is stored on the PSE can be encoded or decoded with functions
{\em e\_KeyInfo} and {\em d\_KeyInfo} respectively.

\subsubsection{Toc}
\hll{Toc}
The table of contents (toc) of the PSE is maintained by those sec\_* functions which 
handle the PSE. The C-structure of the toc given below is used only internally by these
functions. The application programmer does not need to handle them.

{\small
\bvtab
\4      typedef struct PSE\_Toc \{ \\
\6              char                \4 *owner; \\
\6              UTCTime             \4 *create; \\
\6              UTCTime             \4 *update; \\
\6		unsigned int        \4  status; \\
\6              struct PSE\_Objects \4 *obj; \\
\4      \} PSEToc;
\evtab
}
with:
{\small
\bvtab
\4      struct PSE\_Objects \{ \\
\6              char                \4 *name; \\
\6              UTCTime             \4 *create; \\
\6              UTCTime             \4 *update; \\
\6	        int                 \4  noOctets; \\
\6	        unsigned int        \4  status; \\
\6              struct PSE\_Objects \4 *next; \\
\4      \};
\evtab
}

UTCTime is defined in SEC(5).
\subsection{Privacy Enhanced Mail Functions} 

\subsubsection{pem\_create}
\nm{5}{INTRO}{Introduction to miscellaneous facilities}
\label{intro5}
\hl{Description}
This section mainly contains all C type and data definitions which are 
contained
in the include files $<$af.h$>$, $<$pem.h$>$ and$<$secure.h$>$.

\subsection{Authentication Framework Functions}         

\subsubsection{af\_pse\_open}
\nm{5}{PSE-Selection}{PSE-Selection at the AF-Interface}

\hl{Synopsis}

\#include $<$af.h$>$

\hl{Description}
     
The af\_* functions do not provide the possibility
to specify at their parameter interface the names and locations of
PSE objects to be used, as it is possible with the sec\_* functions by
means of the structure PSESel. af\_* functions operate on a predefined
set of 12 objects in a PSE with the predefined name {\em .pse}.
However, all af\_* functions use the global structure AF\_pse. AF\_pse is of
type AFPSESel:

{\small
\bvtab
\4 typedef struct \{ \\
\6        char \1    *app\_name; \\
\6        char \1    *pin; \\
\6        struct \{ \\
\8            char \1 *name; \\
\8            char \1 *pin; \\
\6        \}  \1      object[PSE\_MAXOBJ]; \\
\6        int \1     dev; \\
\6        int \1     app\_id; \\
\4 \} AFPSESel; 
\evtab
}

This global structure can be used for two purposes:
\be
\m AF\_pse contains the application name. This is the
   name of the directory constituting the PSE. The name is interpreted 
   relatively to the HOME directory, if it does not begin with character '/'.
   The application name is initialized with {\em .pse} as default value.
   AF\_pse\pf app\_name can be used to specify another PSE before calling
   an af\_* routine. If multiple PSEs are used simultaneously, the content
   of this global structure must be saved for each PSE and restored
   before a call to an af\_* routine.
\m AF\_pse contains all interactively entered PIN's in order to avoid multiple
   questioning of PIN's in case of multiple access to the same PSE object within
   one program. After a call to af\_sign, for instance, which asks for the PIN
   of the PSE and for the PIN of the PSE object SignSK, if there is any,
   AF\_pse\pf pin contains the PSE PIN and AF\_pse.object[1]\pf pin contains the
   PIN of the PSE object SignSK. A second call to af\_sign within the same
   program will not ask again for those PINs. PIN questionning can be
   enforced again by clearing the PINs in the global structure AF\_pse.
   See AF(5) for the exact definition of AF\_pse.
\ee
This structure can be used by the programmer by declaring \\

{\small
extern AFPSESel AF\_pse;
}
\subsection{Cryptographic Functions}
\subsubsection{sec\_encrypt}
