*** /var/spool/ftp/pub/Crypto/SSL/064/SSLeay-0.6.3/./Configure	Thu Jul 25 10:26:44 1996
--- ./Configure	Thu Aug 29 23:50:25 1996
***************
*** 80,86 ****
  
  # HPUX config.  I've been building on HPUX 9, so the options may be
  # different on version 10.
! "hpux-cc",	"cc:-DB_ENDIAN -D_HPUX_SOURCE -Aa +ESlit +Oall +O4 -Wl,-a,archive:::asm/pa-risc.s",
  "hpux-kr-cc",	"cc:-DB_ENDIAN -DNOCONST -DNOPROTO -D_HPUX_SOURCE:::asm/pa-risc.s",
  "hpux-gcc",	"gcc:-DB_ENDIAN -O3::BN_LLONG:",
  
--- 80,86 ----
  
  # HPUX config.  I've been building on HPUX 9, so the options may be
  # different on version 10.
! "hpux-cc",	"cc:-DB_ENDIAN -D_HPUX_SOURCE -Aa +ESlit +O2 -Wl,-a,archive:::asm/pa-risc.s",
  "hpux-kr-cc",	"cc:-DB_ENDIAN -DNOCONST -DNOPROTO -D_HPUX_SOURCE:::asm/pa-risc.s",
  "hpux-gcc",	"gcc:-DB_ENDIAN -O3::BN_LLONG:",
  
***************
*** 117,122 ****
--- 117,124 ----
  
  # Windows NT, Microsoft Visual C++ 4.0
  "VC-NT","cl:::BN_LLONG RC4_INDEX:",
+ "VC-WIN32","cl:::BN_LLONG RC4_INDEX:",
+ "VC-WIN16","cl:::MD2_CHAR DES_PTR RC4_INDEX THIRTY_TWO_BITS:",
  "VC-W31-16","cl:::BN_LLONG MD2_CHAR DES_PTR RC4_INDEX SIXTEEN_BITS:",
  "VC-W31-32","cl:::MD2_CHAR DES_PTR RC4_INDEX THIRTY_TWO_BITS:",
  "VC-MSDOS","cl:::BN_LLONG MD2_CHAR DES_PTR RC4_INDEX SIXTEEN_BITS:",
*** /var/spool/ftp/pub/Crypto/SSL/064/SSLeay-0.6.3/./INSTALL	Thu Jul 25 15:44:47 1996
--- ./INSTALL	Thu Aug 29 23:50:25 1996
***************
*** 108,116 ****
  gcc -O2 -DASM -c -Icrypto -Iinclude crypto/crypto.c
  
  This last option is probably the best way to go when porting to another
! platform or building shared libraries.  It sucks for development so
  I don't normally use it.
  
  have fun
  
! eric 21-Jun-1996
--- 108,124 ----
  gcc -O2 -DASM -c -Icrypto -Iinclude crypto/crypto.c
  
  This last option is probably the best way to go when porting to another
! platform or building shared libraries.  It is not good for development so
  I don't normally use it.
  
+ To build shared libararies under unix, have a look in shlib, basically 
+ you are on your own, but it is quite easy and all you have to do
+ is compile 2 (or 3) files.
+ 
+ For mult-threading, have a read of doc/threads.doc.  Again it is quite
+ easy and normally only requires some extra callbacks to be defined
+ by the application.
+ 
  have fun
  
! eric 19-Aug-1996
*** /var/spool/ftp/pub/Crypto/SSL/064/SSLeay-0.6.3/./Makefile.ssl	Thu Aug  8 01:54:11 1996
--- ./Makefile.ssl	Fri Aug 30 04:40:40 1996
***************
*** 1,6 ****
  #
  # Makefile for all the SSL related library routines and utilities
! VERSION	= 0.6.3
  #
  # make install will install:
  #   libraries into $INSTALLTOP/lib
--- 1,6 ----
  #
  # Makefile for all the SSL related library routines and utilities
! VERSION	= 0.6.4
  #
  # make install will install:
  #   libraries into $INSTALLTOP/lib
***************
*** 34,44 ****
  # NOIDEA  - Define to build without the IDEA algorithm
  # NORC4   - Define to build without the RC4 algorithm
  # NORC2   - Define to build without the RC2 algorithm
! # THREADS - Define when building with threads, you will also need any
  #	    system defines as well, i.e. _REENTERANT for Solaris 2.[34]
  # TERMIO  - Define the termio terminal subsystem, needed if sgtty is missing.
  # TERMIOS - Define the termios terminal subsystem, Silicon Graphics.
  # LOCK_DEBUG - turns on lots of lock debug output :-)
  
  CC= cc
  CFLAG= -O -DNOPROTO
--- 34,46 ----
  # NOIDEA  - Define to build without the IDEA algorithm
  # NORC4   - Define to build without the RC4 algorithm
  # NORC2   - Define to build without the RC2 algorithm
! # THREADS - Define when building with threads, you will probably also need any
  #	    system defines as well, i.e. _REENTERANT for Solaris 2.[34]
  # TERMIO  - Define the termio terminal subsystem, needed if sgtty is missing.
  # TERMIOS - Define the termios terminal subsystem, Silicon Graphics.
  # LOCK_DEBUG - turns on lots of lock debug output :-)
+ # REF_CHECK - turn on some xyz_free() assertions.
+ # CRYPTO_MDEBUG - turns on my 'memory leak' detecting stuff
  
  CC= cc
  CFLAG= -O -DNOPROTO
***************
*** 60,71 ****
  TOP=	.
  DIRS=	crypto ssl rsaref apps test tools
  ONEDIRS=out tmp
! EDIRS=	times doc bugs util include certs ms shlib
  MISC=	COPYRIGHT Configure INSTALL Makefile.ssl Makefile \
! 	RAMBLINGS README README.050 README.051 README.052 TODO \
! 	README.060 README.061 README.062 \
  	VERSION PROBLEMS MINFO makefile.one e_os.h \
! 	MICROSOFT
  WDIRS=	windows
  LIB=	libcrypto.a
  LIBS=	libcrypto.a libssl.a 
--- 62,73 ----
  TOP=	.
  DIRS=	crypto ssl rsaref apps test tools
  ONEDIRS=out tmp
! EDIRS=	times doc bugs util include certs ms shlib ssl3 mt
  MISC=	COPYRIGHT Configure INSTALL Makefile.ssl Makefile \
! 	README README.050 README.051 README.052 TODO \
! 	README.060 README.061 README.062 README.063 README.064 \
  	VERSION PROBLEMS MINFO makefile.one e_os.h \
! 	MICROSOFT makevms.com
  WDIRS=	windows
  LIB=	libcrypto.a
  LIBS=	libcrypto.a libssl.a 
***************
*** 93,98 ****
--- 95,101 ----
  	done;
  
  clean:
+ 	/bin/rm -f *.o core a.out fluff
  	@for i in $(DIRS) ;\
  	do \
  	(cd $$i; echo "cleaning $$i..."; \
***************
*** 99,105 ****
  	$(MAKE) clean ); \
  	/bin/rm -f $(LIB); \
  	done;
! 	/bin/rm -f *.a *.o speed.* *.map *.so
  	/bin/rm -f $(TARFILE)
  	@for i in $(ONEDIRS) ;\
  	do \
--- 102,108 ----
  	$(MAKE) clean ); \
  	/bin/rm -f $(LIB); \
  	done;
! 	/bin/rm -f *.a *.o speed.* *.map *.so .pure core
  	/bin/rm -f $(TARFILE)
  	@for i in $(ONEDIRS) ;\
  	do \
*** /var/spool/ftp/pub/Crypto/SSL/064/SSLeay-0.6.3/./README	Tue Aug  6 15:57:45 1996
--- ./README	Fri Aug 30 01:07:51 1996
***************
*** 1,4 ****
! 		SSLeay 0.6.3 06-Aug-1996
  		Copyright (c) 1996, Eric Young
  		All rights reserved.
  
--- 1,4 ----
! 		SSLeay 0.6.4 30-Aug-1996
  		Copyright (c) 1996, Eric Young
  		All rights reserved.
  
***************
*** 95,104 ****
  	A initial version of the library manual.
  
  To install this package, read the INSTALL file.
! For the Microsoft word, read INSTALL.MS
  This library has been compiled and tested on Solaris 2.[34] (sparc and x86),
  SunOS 4.1.3, DGUX, OSF1 Alpha, HPUX 9, AIX 3.5(?), IRIX 5.[23],
  LINUX, NeXT (intel), linux, Windows NT, Windows 3.1, MSDOS 6.22.
  
  Due to time constraints, the current release has only be rigorously tested
  on Solaris 2.[45], Linux and Windows NT, Windows 3.1 (under NT) and MSDOS.
--- 95,106 ----
  	A initial version of the library manual.
  
  To install this package, read the INSTALL file.
! For the Microsoft word, read MICROSOFT
  This library has been compiled and tested on Solaris 2.[34] (sparc and x86),
  SunOS 4.1.3, DGUX, OSF1 Alpha, HPUX 9, AIX 3.5(?), IRIX 5.[23],
  LINUX, NeXT (intel), linux, Windows NT, Windows 3.1, MSDOS 6.22.
+ 
+ Multithreading has been tested under Windows NT and Solaris 2.5.1
  
  Due to time constraints, the current release has only be rigorously tested
  on Solaris 2.[45], Linux and Windows NT, Windows 3.1 (under NT) and MSDOS.
*** /var/spool/ftp/pub/Crypto/SSL/064/SSLeay-0.6.3/./TODO	Thu Jul 25 09:03:51 1996
--- ./TODO	Thu Aug 29 23:50:25 1996
***************
*** 7,14 ****
    I will probably not get this fixed for a while, it is just there so
    I could test things.
  
- * Multi-threaded support, I've started...
- 
  + Implement SSL v 3, I will actually soon be looking at starting (he
    says for the 20th time :-).
  
--- 7,12 ----
*** /dev/null	Fri Aug 30 04:16:48 1996
--- ./README.063	Thu Aug 29 23:50:25 1996
***************
*** 0 ****
--- 1,7 ----
+ 0.6.3
+ 
+ Bug fixes and the addition of some nice stuff to the 'ca' program.
+ Have a read of doc/ns-ca.doc for how hit has been modified so
+ it can be driven from a CGI script.  The CGI script is not provided,
+ but that is just being left as an excersize for the reader :-).
+ 
*** /dev/null	Fri Aug 30 04:16:48 1996
--- ./README.064	Fri Aug 30 04:39:41 1996
***************
*** 0 ****
--- 1,25 ----
+ SSLeay 0.6.4 30/08/96 eay
+ 
+ I've just finished some test builds on Windows NT, Windows 3.1, Solaris 2.3,
+ Solaris 2.5, Linux, IRIX, HPUX 10 and everthing seems to work :-).
+ 
+ The main changes in this release
+ 
+ - Thread safe.  have a read of doc/threads.doc and play in the mt directory.
+   For anyone using 0.6.3 with threads, I found 2 major errors so consider
+   moving to 0.6.4.  I have a test program that builds under NT and
+   solaris.
+ - The get session-id callback has changed.  Have a read of doc/callback.doc.
+ - The X509_cert_verify callback (the SSL_verify callback) now
+   has another argument.  Have a read of doc/callback.doc
+ - 'ca -preserve', sign without re-ordering the DN.  Not tested much.
+ - VMS support.
+ - Compile time memory leak detection can now be built into SSLeay.
+   Read doc/memory.doc
+ - CONF routines now understand '\', '\n', '\r' etc.  What this means is that
+   the  SPKAC object mentioned in doc/ns-ca.doc can be on multiple lines.
+ - 'ssleay ciphers' added, lists the default cipher list for SSLeay.
+ - RC2 key setup is now compatable with Netscape.
+ - Modifed server side of SSL implementation, big performance difference when
+ 	  using session-id reuse.
+ 
*** /var/spool/ftp/pub/Crypto/SSL/064/SSLeay-0.6.3/./VERSION	Thu Aug  8 00:53:43 1996
--- ./VERSION	Fri Aug 30 00:50:33 1996
***************
*** 1,6 ****
! Version 0.6.3 eay
  	- A few minor memory leaks in the pkcs7 stuff.
! 	- Assed -modulus option to 'rsa'.
  	- A fix to SSL_set_rbio(), if was free()ing the ssl->wbio.
  	- A few mods to crypto/rand/randfile.c
  	- Error in ASN1_INTEGER_set, I had the endian around the wrong way
--- 1,73 ----
! Version 0.6.4 30/08/96 eay
! 	- ca -preserve added, this will sign without modifying the DN, if
! 	  it passes the other tests.  Not tested much.
! 	- test/Makefile.ssl reorganisation so that the tests can be run
! 	  indervidually, thanks to Clifford Heath <cjh@osa.com.au>.
! 	- CRL ASN.1 encoding fixed I belive.  Thanks to
! 	  Gordon Chaffee <chaffee@odie.CS.Berkeley.EDU> for prompting me
! 	  to look at the X509v3 specs again.
! 	- VMS support, including the VMS tcp BIO, thanks to
! 	  David L. Jones <jonesd@kcgl1.eng.ohio-state.edu>
! 	- Read doc/callback.doc
! 	- Read doc/memory.doc
! 	- X509_cert_verify() modified so the callback can override _ANY_
! 	  error.
! 	- Bug in ASN1_put_object(), would only show up if ASN.1 tags
! 	  were > 0x3f.  Thanks to Dirk Kuhlmann <derek@prz.tu-berlin.de>.
! 	- Bug in BN_ascii2bn(), basically the function was never being used :-(
! 	  thanks to Emanuele Pucciarelli <emanuele@debian.org>
! 	- Config files have been cleaned up.  \n and \r represent newlines
! 	  and a \ will join the next line with the \n removed.
! 	- Fix for the error case in ASN.1 paring for the M_ASN1_D2I_Finish()
! 	  macro in asn1_mac.h, thanks again to 
! 	  Gordon Chaffee <chaffee@odie.CS.Berkeley.EDU>
! 	- HPUX config changed, sugested by Rene Eberhard <reberhar@itr.ch>.
! 	- The get session-id SSL_CTX callback has had a 'copy' int * added.
! 	  If 1 the reference count is incremented, else the origional
! 	  of the SSL_SESSION passed in is used.
! 	- VERIFY_ROOT_OK (self signed cert) now prints the correct thing
! 	  from X509_cert_verify_error_string().
! 	- 'ssleay ciphers' added, lists the default cipher list for SSLeay.
! 	  'ssleay ciphers -v' lists a more textual listing of all ciphers.
! 	- Added a memory leak define.  If CRYPTO_MDEBUG is defined while
! 	  SSLeay is being built, memory leak detection is compiled in.
! 	  SSLeay will report memory leaks if they occur when it exits.
! 	  Don't worry about this too much normally.
! 	- crypto/rc2/rc2_skey.c has been changed so there is now a
! 	  4th argument to RC2_set_key().  This is the 'bits' argument.
! 	  The previous version of RC2 was equivilant to setting this
! 	  parameter to 1024.  BSAFE sets this to the key size, eg 128.
! 	  Thanks to Peter Gutmann <pgut01@cs.auckland.ac.nz> for his
! 	  help on this stuff.  The term used by Peter for the BSAFE
! 	  modification is 'espionage-enabled' rc2 :-).
! 	- Added doc/threads.doc
! 	- Prototypes added in the XXXX_dup() macros.
! 	- Added another arg to X509_cert_verify().  It is passed
! 	  through to the callback function.  This is needed for a
! 	  multithreaded environment.  The SSL protocol passes the SSL
! 	  structure.
! 	- Modifed server side of SSL protocol so that '2' writes are 
! 	  coalesed into one, make a big performance difference when
! 	  using session-id reuse, the TCP/IP protocol was timing out.
! 	  Problem noticed by Tim Hudson <tjh@mincom.oz.au>
! 	- Found a bug in multi-threading finally :-).  It would cause my
! 	  100 threads, 100 times to fail about 1 in 4 :-).
! 	- mt/mttest.c - solaris/nt multithreading test, very very beta
! 	- Fix to WIN32 Endian_Reverse32 in md5_locl.h and sha_locl.h,
! 	  apps/ca.c was not printing crl's out,
! 	  Replaces some code with a call to a2i_ASN1_INTEGER().
! 	  All of these, thats to Gordon Chaffee <chaffee@odie.CS.Berkeley.EDU>
! 	- Changed some session-id callback parameters.
! 	- -outform text added to apps/crl.c, thanks to 
! 	  Simon J. Gerraty <sjg@frodo.dn.itg.telecom.com.au> for the
! 	  patches.
! 	- Fixed a wrong lock and a 'non-multithreading' problem in
! 	  bn_mont.c that only showed up when using the 'word' version.
! 	- 'util\mk1mf no-asm VC-NT' was not working.
! 
! Version 0.6.3 08/08/96 eay
  	- A few minor memory leaks in the pkcs7 stuff.
! 	- Added -modulus option to 'rsa'.
  	- A fix to SSL_set_rbio(), if was free()ing the ssl->wbio.
  	- A few mods to crypto/rand/randfile.c
  	- Error in ASN1_INTEGER_set, I had the endian around the wrong way
*** /var/spool/ftp/pub/Crypto/SSL/064/SSLeay-0.6.3/./MINFO	Thu Aug  8 01:54:49 1996
--- ./MINFO	Fri Aug 30 04:41:20 1996
***************
*** 4,10 ****
  CC=cc
  CFLAG=-O -DNOPROTO
  DIRS=crypto ssl rsaref apps test tools
! EDIRS=times doc bugs util include certs ms shlib
  EX_HEADER=
  EX_LIBS=
  GENERAL=Makefile
--- 4,10 ----
  CC=cc
  CFLAG=-O -DNOPROTO
  DIRS=crypto ssl rsaref apps test tools
! EDIRS=times doc bugs util include certs ms shlib ssl3 mt
  EX_HEADER=
  EX_LIBS=
  GENERAL=Makefile
***************
*** 16,34 ****
  MAKEFILE=Makefile.ssl
  MAN1=1
  MAN3=3
! MISC=COPYRIGHT Configure INSTALL Makefile.ssl Makefile RAMBLINGS README README.050 README.051 README.052 TODO README.060 README.061 README.062 VERSION PROBLEMS MINFO makefile.one e_os.h MICROSOFT
! NAME=SSLeay-0.6.3
  ONEDIRS=out tmp
  PEX_LIBS=-L. -L.. -L../.. -L../../..
  SHELL=/bin/sh
! TARFILE=SSLeay-0.6.3.tar
  TOP=.
! VERSION=0.6.3
  WDIRS=windows
! WTARFILE=SSLeay-0.6.3-win.tar
  RELATIVE_DIRECTORY=
  RELATIVE_DIRECTORY=crypto
! ALL=Makefile README cryptlib.c cryptlib.h date.h crypto.h cryptoall.h
  CC=cc
  CFLAG=-g
  CFLAGS=-I. -I../include -g -DCFLAGS=" \"cc -g\" "
--- 16,34 ----
  MAKEFILE=Makefile.ssl
  MAN1=1
  MAN3=3
! MISC=COPYRIGHT Configure INSTALL Makefile.ssl Makefile README README.050 README.051 README.052 TODO README.060 README.061 README.062 README.063 README.064 VERSION PROBLEMS MINFO makefile.one e_os.h MICROSOFT makevms.com
! NAME=SSLeay-0.6.4
  ONEDIRS=out tmp
  PEX_LIBS=-L. -L.. -L../.. -L../../..
  SHELL=/bin/sh
! TARFILE=SSLeay-0.6.4.tar
  TOP=.
! VERSION=0.6.4
  WDIRS=windows
! WTARFILE=SSLeay-0.6.4-win.tar
  RELATIVE_DIRECTORY=
  RELATIVE_DIRECTORY=crypto
! ALL=Makefile README cryptlib.c mem.c cryptlib.h date.h crypto.h cryptoall.h
  CC=cc
  CFLAG=-g
  CFLAGS=-I. -I../include -g -DCFLAGS=" \"cc -g\" "
***************
*** 41,49 ****
  INCLUDES=-I.. -I../../include
  INSTALLTOP=/usr/local/ssl
  LIB=../libcrypto.a
! LIBOBJ=cryptlib.o
  LIBS=
! LIBSRC=cryptlib.c
  MAKE=make -f Makefile.ssl
  MAKEDEPEND=makedepend -fMakefile.ssl
  MAKEFILE=Makefile.ssl
--- 41,49 ----
  INCLUDES=-I.. -I../../include
  INSTALLTOP=/usr/local/ssl
  LIB=../libcrypto.a
! LIBOBJ=cryptlib.o mem.o
  LIBS=
! LIBSRC=cryptlib.c mem.c
  MAKE=make -f Makefile.ssl
  MAKEDEPEND=makedepend -fMakefile.ssl
  MAKEFILE=Makefile.ssl
***************
*** 50,56 ****
  PEX_LIBS=
  RM=/bin/rm -f
  SDIRS=md sha des rc4 rc2 idea bn rsa dsa dh buffer stack lhash rand error objects evp pem x509 asn1 meth conf txt_db pkcs7
! SRC=cryptlib.c
  TOP=..
  RELATIVE_DIRECTORY=
  RELATIVE_DIRECTORY=crypto/md
--- 50,56 ----
  PEX_LIBS=
  RM=/bin/rm -f
  SDIRS=md sha des rc4 rc2 idea bn rsa dsa dh buffer stack lhash rand error objects evp pem x509 asn1 meth conf txt_db pkcs7
! SRC=cryptlib.c mem.c
  TOP=..
  RELATIVE_DIRECTORY=
  RELATIVE_DIRECTORY=crypto/md
***************
*** 658,664 ****
  TOP=..
  RELATIVE_DIRECTORY=
  RELATIVE_DIRECTORY=apps
! ALL=Makefile verify.c asn1pars.c req.c dgst.c dh.c enc.c gendh.c errstr.c ca.c pkcs7.c crl2p7.c crl.c rsa.c x509.c genrsa.c s_server.c s_client.c s_filter.c speed.c hashdir.c s_time.c s_mult.c apps.c s_cb.c s_socket.c s_eio.c version.c sess_id.c apps.h progs.h s_apps.h s_eio.h testcert.h 
  A_OBJ=apps.o
  A_SRC=apps.c
  CC=cc
--- 658,664 ----
  TOP=..
  RELATIVE_DIRECTORY=
  RELATIVE_DIRECTORY=apps
! ALL=Makefile verify.c asn1pars.c req.c dgst.c dh.c enc.c gendh.c errstr.c ca.c pkcs7.c crl2p7.c crl.c rsa.c x509.c genrsa.c s_server.c s_client.c s_filter.c speed.c hashdir.c s_time.c s_mult.c apps.c s_cb.c s_socket.c s_eio.c version.c sess_id.c ciphers.c apps.h progs.h s_apps.h s_eio.h testcert.h 
  A_OBJ=apps.o
  A_SRC=apps.c
  CC=cc
***************
*** 670,678 ****
  EXE=ssleay
  EXHEADER=
  EX_LIBS=
! E_EXE=verify asn1pars req dgst dh enc gendh errstr ca crl rsa x509 genrsa s_server s_client s_filter speed hashdir s_time s_mult version pkcs7 crl2pkcs7 sess_id
! E_OBJ=verify.o asn1pars.o req.o dgst.o dh.o enc.o gendh.o errstr.o ca.o pkcs7.o crl2p7.o crl.o rsa.o x509.o genrsa.o s_server.o s_client.o s_filter.o speed.o hashdir.o s_time.o s_mult.o apps.o s_cb.o s_socket.o s_eio.o version.o sess_id.o
! E_SRC=verify.c asn1pars.c req.c dgst.c dh.c enc.c gendh.c errstr.c ca.c pkcs7.c crl2p7.c crl.c rsa.c x509.c genrsa.c s_server.c s_client.c s_filter.c speed.c hashdir.c s_time.c s_mult.c apps.c s_cb.c s_socket.c s_eio.c version.c sess_id.c
  GENERAL=Makefile
  HEADER=apps.h progs.h s_apps.h s_eio.h testcert.h 
  INCLUDES=-I../include
--- 670,678 ----
  EXE=ssleay
  EXHEADER=
  EX_LIBS=
! E_EXE=verify asn1pars req dgst dh enc gendh errstr ca crl rsa x509 genrsa s_server s_client s_filter speed hashdir s_time s_mult version pkcs7 crl2pkcs7 sess_id ciphers
! E_OBJ=verify.o asn1pars.o req.o dgst.o dh.o enc.o gendh.o errstr.o ca.o pkcs7.o crl2p7.o crl.o rsa.o x509.o genrsa.o s_server.o s_client.o s_filter.o speed.o hashdir.o s_time.o s_mult.o apps.o s_cb.o s_socket.o s_eio.o version.o sess_id.o ciphers.o
! E_SRC=verify.c asn1pars.c req.c dgst.c dh.c enc.c gendh.c errstr.c ca.c pkcs7.c crl2p7.c crl.c rsa.c x509.c genrsa.c s_server.c s_client.c s_filter.c speed.c hashdir.c s_time.c s_mult.c apps.c s_cb.c s_socket.c s_eio.c version.c sess_id.c ciphers.c
  GENERAL=Makefile
  HEADER=apps.h progs.h s_apps.h s_eio.h testcert.h 
  INCLUDES=-I../include
***************
*** 686,692 ****
  PROGS=ssleay.c
  RM=/bin/rm -f
  SCRIPTS=CA.sh der_chop
! SRC=verify.c asn1pars.c req.c dgst.c dh.c enc.c gendh.c errstr.c ca.c pkcs7.c crl2p7.c crl.c rsa.c x509.c genrsa.c s_server.c s_client.c s_filter.c speed.c hashdir.c s_time.c s_mult.c apps.c s_cb.c s_socket.c s_eio.c version.c sess_id.c
  SSLEAY=ssleay
  S_OBJ=s_cb.o s_socket.o s_eio.o
  S_SRC=s_cb.c s_socket.c s_eio.c
--- 686,692 ----
  PROGS=ssleay.c
  RM=/bin/rm -f
  SCRIPTS=CA.sh der_chop
! SRC=verify.c asn1pars.c req.c dgst.c dh.c enc.c gendh.c errstr.c ca.c pkcs7.c crl2p7.c crl.c rsa.c x509.c genrsa.c s_server.c s_client.c s_filter.c speed.c hashdir.c s_time.c s_mult.c apps.c s_cb.c s_socket.c s_eio.c version.c sess_id.c ciphers.c
  SSLEAY=ssleay
  S_OBJ=s_cb.o s_socket.o s_eio.o
  S_SRC=s_cb.c s_socket.c s_eio.c
*** /var/spool/ftp/pub/Crypto/SSL/064/SSLeay-0.6.3/./makefile.one	Thu Aug  8 01:54:49 1996
--- ./makefile.one	Fri Aug 30 04:41:21 1996
***************
*** 128,208 ****
  	$(OBJ_D)/hashdir.o $(OBJ_D)/s_time.o $(OBJ_D)/s_mult.o \
  	$(OBJ_D)/apps.o $(OBJ_D)/s_cb.o $(OBJ_D)/s_socket.o \
  	$(OBJ_D)/s_eio.o $(OBJ_D)/version.o $(OBJ_D)/sess_id.o \
! 	$(OBJ_D)/ssleay.o
  
  CRYPTOOBJ=$(OBJ_D)/cryptlib.o \
! 	$(OBJ_D)/md2_dgst.o $(OBJ_D)/md5_dgst.o $(OBJ_D)/md2_one.o \
! 	$(OBJ_D)/md5_one.o $(OBJ_D)/sha_dgst.o $(OBJ_D)/sha1dgst.o \
! 	$(OBJ_D)/sha_one.o $(OBJ_D)/sha1_one.o $(OBJ_D)/set_key.o \
! 	$(OBJ_D)/ecb_enc.o $(OBJ_D)/ede_enc.o $(OBJ_D)/cbc_enc.o \
! 	$(OBJ_D)/cbc3_enc.o $(OBJ_D)/ecb3_enc.o $(OBJ_D)/cfb64enc.o \
! 	$(OBJ_D)/cfb64ede.o $(OBJ_D)/cfb_enc.o $(OBJ_D)/ofb64ede.o \
! 	$(OBJ_D)/enc_read.o $(OBJ_D)/enc_writ.o $(OBJ_D)/fcrypt.o \
! 	$(OBJ_D)/ncbc_enc.o $(OBJ_D)/ofb64enc.o $(OBJ_D)/ofb_enc.o \
! 	$(OBJ_D)/str2key.o $(OBJ_D)/pcbc_enc.o $(OBJ_D)/qud_cksm.o \
! 	$(OBJ_D)/rand_key.o $(OBJ_D)/xcbc_enc.o $(OBJ_D)/read_pwd.o \
! 	$(OBJ_D)/rpc_enc.o $(OBJ_D)/cbc_cksm.o $(OBJ_D)/supp.o \
! 	$(OBJ_D)/rc4_enc.o $(OBJ_D)/rc2_ecb.o $(OBJ_D)/rc2_skey.o \
! 	$(OBJ_D)/rc2_cbc.o $(OBJ_D)/rc2cfb64.o $(OBJ_D)/rc2ofb64.o \
! 	$(OBJ_D)/i_cbc.o $(OBJ_D)/i_cfb64.o $(OBJ_D)/i_ofb64.o \
! 	$(OBJ_D)/i_ecb.o $(OBJ_D)/i_skey.o $(OBJ_D)/bn_add.o \
! 	$(OBJ_D)/bn_div.o $(OBJ_D)/bn_exp.o $(OBJ_D)/bn_lib.o \
! 	$(OBJ_D)/bn_mod.o $(OBJ_D)/bn_mul.o $(OBJ_D)/bn_print.o \
! 	$(OBJ_D)/bn_rand.o $(OBJ_D)/bn_shift.o $(OBJ_D)/bn_sub.o \
! 	$(OBJ_D)/bn_word.o $(OBJ_D)/bn_gcd.o $(OBJ_D)/bn_prime.o \
! 	$(OBJ_D)/bn_err.o $(OBJ_D)/bn_sqr.o $(OBJ_D)/bn_mulw.o \
! 	$(OBJ_D)/bn_recp.o $(OBJ_D)/bn_mont.o $(OBJ_D)/rsa_enc.o \
! 	$(OBJ_D)/rsa_gen.o $(OBJ_D)/rsa_lib.o $(OBJ_D)/rsa_sign.o \
! 	$(OBJ_D)/rsa_err.o $(OBJ_D)/dsa_lib.o $(OBJ_D)/dsa_vrf.o \
! 	$(OBJ_D)/dsa_sign.o $(OBJ_D)/dsa_err.o $(OBJ_D)/dh_gen.o \
! 	$(OBJ_D)/dh_key.o $(OBJ_D)/dh_lib.o $(OBJ_D)/dh_check.o \
! 	$(OBJ_D)/dh_err.o $(OBJ_D)/buffer.o $(OBJ_D)/bio_lib.o \
! 	$(OBJ_D)/bio_cb.o $(OBJ_D)/buf_err.o $(OBJ_D)/bss_mem.o \
! 	$(OBJ_D)/bss_null.o $(OBJ_D)/bss_fd.o $(OBJ_D)/bss_file.o \
! 	$(OBJ_D)/bss_sock.o $(OBJ_D)/bf_buff.o $(OBJ_D)/stack.o \
! 	$(OBJ_D)/lhash.o $(OBJ_D)/lh_stats.o $(OBJ_D)/md5_rand.o \
! 	$(OBJ_D)/randfile.o $(OBJ_D)/err.o $(OBJ_D)/err_all.o \
! 	$(OBJ_D)/obj_dat.o $(OBJ_D)/obj_lib.o $(OBJ_D)/obj_err.o \
! 	$(OBJ_D)/encode.o $(OBJ_D)/digest.o $(OBJ_D)/evp_enc.o \
! 	$(OBJ_D)/evp_key.o $(OBJ_D)/e_ecb_d.o $(OBJ_D)/e_cbc_d.o \
! 	$(OBJ_D)/e_cfb_d.o $(OBJ_D)/e_ofb_d.o $(OBJ_D)/e_ecb_i.o \
! 	$(OBJ_D)/e_cbc_i.o $(OBJ_D)/e_cfb_i.o $(OBJ_D)/e_ofb_i.o \
! 	$(OBJ_D)/e_ecb_3d.o $(OBJ_D)/e_cbc_3d.o $(OBJ_D)/e_rc4.o \
! 	$(OBJ_D)/e_names.o $(OBJ_D)/e_cfb_3d.o $(OBJ_D)/e_ofb_3d.o \
! 	$(OBJ_D)/e_xcbc_d.o $(OBJ_D)/e_ecb_r2.o $(OBJ_D)/e_cbc_r2.o \
! 	$(OBJ_D)/e_cfb_r2.o $(OBJ_D)/e_ofb_r2.o $(OBJ_D)/m_md2.o \
! 	$(OBJ_D)/m_md5.o $(OBJ_D)/m_sha.o $(OBJ_D)/m_sha1.o \
! 	$(OBJ_D)/m_dss.o $(OBJ_D)/m_dss1.o $(OBJ_D)/m_names.o \
! 	$(OBJ_D)/p_open.o $(OBJ_D)/p_seal.o $(OBJ_D)/p_sign.o \
! 	$(OBJ_D)/p_verify.o $(OBJ_D)/p_lib.o $(OBJ_D)/bio_md.o \
! 	$(OBJ_D)/evp_err.o $(OBJ_D)/pem_sign.o $(OBJ_D)/pem_seal.o \
! 	$(OBJ_D)/pem_info.o $(OBJ_D)/pem_lib.o $(OBJ_D)/pem_err.o \
! 	$(OBJ_D)/x509_def.o $(OBJ_D)/x509_r2x.o $(OBJ_D)/x509_cmp.o \
! 	$(OBJ_D)/x509_obj.o $(OBJ_D)/x509_req.o $(OBJ_D)/x509_vrf.o \
! 	$(OBJ_D)/x509_crt.o $(OBJ_D)/x509_ath.o $(OBJ_D)/x509_err.o \
! 	$(OBJ_D)/a_object.o $(OBJ_D)/a_bitstr.o $(OBJ_D)/a_utctm.o \
! 	$(OBJ_D)/a_int.o $(OBJ_D)/a_octet.o $(OBJ_D)/a_print.o \
! 	$(OBJ_D)/a_type.o $(OBJ_D)/a_set.o $(OBJ_D)/a_dup.o \
! 	$(OBJ_D)/a_d2i_fp.o $(OBJ_D)/a_i2d_fp.o $(OBJ_D)/a_sign.o \
! 	$(OBJ_D)/a_verify.o $(OBJ_D)/x_algor.o $(OBJ_D)/x_val.o \
! 	$(OBJ_D)/x_pubkey.o $(OBJ_D)/x_sig.o $(OBJ_D)/x_req.o \
! 	$(OBJ_D)/x_attrib.o $(OBJ_D)/x_name.o $(OBJ_D)/x_cinf.o \
! 	$(OBJ_D)/x_x509.o $(OBJ_D)/x_crl.o $(OBJ_D)/x_info.o \
! 	$(OBJ_D)/x_spki.o $(OBJ_D)/d2i_r_pr.o $(OBJ_D)/i2d_r_pr.o \
! 	$(OBJ_D)/d2i_r_pu.o $(OBJ_D)/i2d_r_pu.o $(OBJ_D)/d2i_s_pr.o \
! 	$(OBJ_D)/d2i_s_pu.o $(OBJ_D)/d2i_pu.o $(OBJ_D)/d2i_pr.o \
! 	$(OBJ_D)/i2d_pu.o $(OBJ_D)/i2d_pr.o $(OBJ_D)/t_req.o \
! 	$(OBJ_D)/t_x509.o $(OBJ_D)/t_pkey.o $(OBJ_D)/p7_i_s.o \
! 	$(OBJ_D)/p7_signi.o $(OBJ_D)/p7_signd.o $(OBJ_D)/p7_recip.o \
! 	$(OBJ_D)/p7_enc_c.o $(OBJ_D)/p7_evp.o $(OBJ_D)/p7_dgst.o \
! 	$(OBJ_D)/p7_s_e.o $(OBJ_D)/p7_enc.o $(OBJ_D)/p7_lib.o \
! 	$(OBJ_D)/f_int.o $(OBJ_D)/i2d_dh.o $(OBJ_D)/d2i_dh.o \
! 	$(OBJ_D)/n_pkey.o $(OBJ_D)/a_hdr.o $(OBJ_D)/x_pkey.o \
! 	$(OBJ_D)/a_bool.o $(OBJ_D)/x_exten.o $(OBJ_D)/asn1_par.o \
! 	$(OBJ_D)/asn1_lib.o $(OBJ_D)/asn1_err.o $(OBJ_D)/meth_lib.o \
! 	$(OBJ_D)/x509meth.o $(OBJ_D)/by_file.o $(OBJ_D)/by_dir.o \
! 	$(OBJ_D)/meth_err.o $(OBJ_D)/conf.o $(OBJ_D)/conf_err.o \
! 	$(OBJ_D)/txt_db.o
  
  SSLOBJ=$(OBJ_D)/ssl_lib.o \
  	$(OBJ_D)/ssl_err2.o $(OBJ_D)/ssl_trc.o $(OBJ_D)/ssl_cert.o \
--- 128,208 ----
  	$(OBJ_D)/hashdir.o $(OBJ_D)/s_time.o $(OBJ_D)/s_mult.o \
  	$(OBJ_D)/apps.o $(OBJ_D)/s_cb.o $(OBJ_D)/s_socket.o \
  	$(OBJ_D)/s_eio.o $(OBJ_D)/version.o $(OBJ_D)/sess_id.o \
! 	$(OBJ_D)/ciphers.o $(OBJ_D)/ssleay.o
  
  CRYPTOOBJ=$(OBJ_D)/cryptlib.o \
! 	$(OBJ_D)/mem.o $(OBJ_D)/md2_dgst.o $(OBJ_D)/md5_dgst.o \
! 	$(OBJ_D)/md2_one.o $(OBJ_D)/md5_one.o $(OBJ_D)/sha_dgst.o \
! 	$(OBJ_D)/sha1dgst.o $(OBJ_D)/sha_one.o $(OBJ_D)/sha1_one.o \
! 	$(OBJ_D)/set_key.o $(OBJ_D)/ecb_enc.o $(OBJ_D)/ede_enc.o \
! 	$(OBJ_D)/cbc_enc.o $(OBJ_D)/cbc3_enc.o $(OBJ_D)/ecb3_enc.o \
! 	$(OBJ_D)/cfb64enc.o $(OBJ_D)/cfb64ede.o $(OBJ_D)/cfb_enc.o \
! 	$(OBJ_D)/ofb64ede.o $(OBJ_D)/enc_read.o $(OBJ_D)/enc_writ.o \
! 	$(OBJ_D)/fcrypt.o $(OBJ_D)/ncbc_enc.o $(OBJ_D)/ofb64enc.o \
! 	$(OBJ_D)/ofb_enc.o $(OBJ_D)/str2key.o $(OBJ_D)/pcbc_enc.o \
! 	$(OBJ_D)/qud_cksm.o $(OBJ_D)/rand_key.o $(OBJ_D)/xcbc_enc.o \
! 	$(OBJ_D)/read_pwd.o $(OBJ_D)/rpc_enc.o $(OBJ_D)/cbc_cksm.o \
! 	$(OBJ_D)/supp.o $(OBJ_D)/rc4_enc.o $(OBJ_D)/rc2_ecb.o \
! 	$(OBJ_D)/rc2_skey.o $(OBJ_D)/rc2_cbc.o $(OBJ_D)/rc2cfb64.o \
! 	$(OBJ_D)/rc2ofb64.o $(OBJ_D)/i_cbc.o $(OBJ_D)/i_cfb64.o \
! 	$(OBJ_D)/i_ofb64.o $(OBJ_D)/i_ecb.o $(OBJ_D)/i_skey.o \
! 	$(OBJ_D)/bn_add.o $(OBJ_D)/bn_div.o $(OBJ_D)/bn_exp.o \
! 	$(OBJ_D)/bn_lib.o $(OBJ_D)/bn_mod.o $(OBJ_D)/bn_mul.o \
! 	$(OBJ_D)/bn_print.o $(OBJ_D)/bn_rand.o $(OBJ_D)/bn_shift.o \
! 	$(OBJ_D)/bn_sub.o $(OBJ_D)/bn_word.o $(OBJ_D)/bn_gcd.o \
! 	$(OBJ_D)/bn_prime.o $(OBJ_D)/bn_err.o $(OBJ_D)/bn_sqr.o \
! 	$(OBJ_D)/bn_mulw.o $(OBJ_D)/bn_recp.o $(OBJ_D)/bn_mont.o \
! 	$(OBJ_D)/rsa_enc.o $(OBJ_D)/rsa_gen.o $(OBJ_D)/rsa_lib.o \
! 	$(OBJ_D)/rsa_sign.o $(OBJ_D)/rsa_err.o $(OBJ_D)/dsa_lib.o \
! 	$(OBJ_D)/dsa_vrf.o $(OBJ_D)/dsa_sign.o $(OBJ_D)/dsa_err.o \
! 	$(OBJ_D)/dh_gen.o $(OBJ_D)/dh_key.o $(OBJ_D)/dh_lib.o \
! 	$(OBJ_D)/dh_check.o $(OBJ_D)/dh_err.o $(OBJ_D)/buffer.o \
! 	$(OBJ_D)/bio_lib.o $(OBJ_D)/bio_cb.o $(OBJ_D)/buf_err.o \
! 	$(OBJ_D)/bss_mem.o $(OBJ_D)/bss_null.o $(OBJ_D)/bss_fd.o \
! 	$(OBJ_D)/bss_file.o $(OBJ_D)/bss_sock.o $(OBJ_D)/bf_buff.o \
! 	$(OBJ_D)/stack.o $(OBJ_D)/lhash.o $(OBJ_D)/lh_stats.o \
! 	$(OBJ_D)/md5_rand.o $(OBJ_D)/randfile.o $(OBJ_D)/err.o \
! 	$(OBJ_D)/err_all.o $(OBJ_D)/obj_dat.o $(OBJ_D)/obj_lib.o \
! 	$(OBJ_D)/obj_err.o $(OBJ_D)/encode.o $(OBJ_D)/digest.o \
! 	$(OBJ_D)/evp_enc.o $(OBJ_D)/evp_key.o $(OBJ_D)/e_ecb_d.o \
! 	$(OBJ_D)/e_cbc_d.o $(OBJ_D)/e_cfb_d.o $(OBJ_D)/e_ofb_d.o \
! 	$(OBJ_D)/e_ecb_i.o $(OBJ_D)/e_cbc_i.o $(OBJ_D)/e_cfb_i.o \
! 	$(OBJ_D)/e_ofb_i.o $(OBJ_D)/e_ecb_3d.o $(OBJ_D)/e_cbc_3d.o \
! 	$(OBJ_D)/e_rc4.o $(OBJ_D)/e_names.o $(OBJ_D)/e_cfb_3d.o \
! 	$(OBJ_D)/e_ofb_3d.o $(OBJ_D)/e_xcbc_d.o $(OBJ_D)/e_ecb_r2.o \
! 	$(OBJ_D)/e_cbc_r2.o $(OBJ_D)/e_cfb_r2.o $(OBJ_D)/e_ofb_r2.o \
! 	$(OBJ_D)/m_md2.o $(OBJ_D)/m_md5.o $(OBJ_D)/m_sha.o \
! 	$(OBJ_D)/m_sha1.o $(OBJ_D)/m_dss.o $(OBJ_D)/m_dss1.o \
! 	$(OBJ_D)/m_names.o $(OBJ_D)/p_open.o $(OBJ_D)/p_seal.o \
! 	$(OBJ_D)/p_sign.o $(OBJ_D)/p_verify.o $(OBJ_D)/p_lib.o \
! 	$(OBJ_D)/bio_md.o $(OBJ_D)/evp_err.o $(OBJ_D)/pem_sign.o \
! 	$(OBJ_D)/pem_seal.o $(OBJ_D)/pem_info.o $(OBJ_D)/pem_lib.o \
! 	$(OBJ_D)/pem_err.o $(OBJ_D)/x509_def.o $(OBJ_D)/x509_r2x.o \
! 	$(OBJ_D)/x509_cmp.o $(OBJ_D)/x509_obj.o $(OBJ_D)/x509_req.o \
! 	$(OBJ_D)/x509_vrf.o $(OBJ_D)/x509_crt.o $(OBJ_D)/x509_ath.o \
! 	$(OBJ_D)/x509_err.o $(OBJ_D)/a_object.o $(OBJ_D)/a_bitstr.o \
! 	$(OBJ_D)/a_utctm.o $(OBJ_D)/a_int.o $(OBJ_D)/a_octet.o \
! 	$(OBJ_D)/a_print.o $(OBJ_D)/a_type.o $(OBJ_D)/a_set.o \
! 	$(OBJ_D)/a_dup.o $(OBJ_D)/a_d2i_fp.o $(OBJ_D)/a_i2d_fp.o \
! 	$(OBJ_D)/a_sign.o $(OBJ_D)/a_verify.o $(OBJ_D)/x_algor.o \
! 	$(OBJ_D)/x_val.o $(OBJ_D)/x_pubkey.o $(OBJ_D)/x_sig.o \
! 	$(OBJ_D)/x_req.o $(OBJ_D)/x_attrib.o $(OBJ_D)/x_name.o \
! 	$(OBJ_D)/x_cinf.o $(OBJ_D)/x_x509.o $(OBJ_D)/x_crl.o \
! 	$(OBJ_D)/x_info.o $(OBJ_D)/x_spki.o $(OBJ_D)/d2i_r_pr.o \
! 	$(OBJ_D)/i2d_r_pr.o $(OBJ_D)/d2i_r_pu.o $(OBJ_D)/i2d_r_pu.o \
! 	$(OBJ_D)/d2i_s_pr.o $(OBJ_D)/d2i_s_pu.o $(OBJ_D)/d2i_pu.o \
! 	$(OBJ_D)/d2i_pr.o $(OBJ_D)/i2d_pu.o $(OBJ_D)/i2d_pr.o \
! 	$(OBJ_D)/t_req.o $(OBJ_D)/t_x509.o $(OBJ_D)/t_pkey.o \
! 	$(OBJ_D)/p7_i_s.o $(OBJ_D)/p7_signi.o $(OBJ_D)/p7_signd.o \
! 	$(OBJ_D)/p7_recip.o $(OBJ_D)/p7_enc_c.o $(OBJ_D)/p7_evp.o \
! 	$(OBJ_D)/p7_dgst.o $(OBJ_D)/p7_s_e.o $(OBJ_D)/p7_enc.o \
! 	$(OBJ_D)/p7_lib.o $(OBJ_D)/f_int.o $(OBJ_D)/i2d_dh.o \
! 	$(OBJ_D)/d2i_dh.o $(OBJ_D)/n_pkey.o $(OBJ_D)/a_hdr.o \
! 	$(OBJ_D)/x_pkey.o $(OBJ_D)/a_bool.o $(OBJ_D)/x_exten.o \
! 	$(OBJ_D)/asn1_par.o $(OBJ_D)/asn1_lib.o $(OBJ_D)/asn1_err.o \
! 	$(OBJ_D)/meth_lib.o $(OBJ_D)/x509meth.o $(OBJ_D)/by_file.o \
! 	$(OBJ_D)/by_dir.o $(OBJ_D)/meth_err.o $(OBJ_D)/conf.o \
! 	$(OBJ_D)/conf_err.o $(OBJ_D)/txt_db.o
  
  SSLOBJ=$(OBJ_D)/ssl_lib.o \
  	$(OBJ_D)/ssl_err2.o $(OBJ_D)/ssl_trc.o $(OBJ_D)/ssl_cert.o \
***************
*** 569,579 ****
--- 569,585 ----
  $(OBJ_D)/sess_id.o: $(SRC_D)/apps/sess_id.c
  	$(CC) -o $(OBJ_D)/sess_id.o -DMONOLITH $(APP_CFLAGS) -c $(SRC_D)/apps/sess_id.c
  
+ $(OBJ_D)/ciphers.o: $(SRC_D)/apps/ciphers.c
+ 	$(CC) -o $(OBJ_D)/ciphers.o -DMONOLITH $(APP_CFLAGS) -c $(SRC_D)/apps/ciphers.c
+ 
  $(OBJ_D)/ssleay.o: $(SRC_D)/apps/ssleay.c
  	$(CC) -o $(OBJ_D)/ssleay.o -DMONOLITH $(APP_CFLAGS) -c $(SRC_D)/apps/ssleay.c
  
  $(OBJ_D)/cryptlib.o: $(SRC_D)/crypto/cryptlib.c
  	$(CC) -o $(OBJ_D)/cryptlib.o $(LIB_CFLAGS) -DCFLAGS="\"$(CC) $(CFLAG)\"" -c $(SRC_D)/crypto/cryptlib.c
+ 
+ $(OBJ_D)/mem.o: $(SRC_D)/crypto/mem.c
+ 	$(CC) -o $(OBJ_D)/mem.o $(LIB_CFLAGS) -c $(SRC_D)/crypto/mem.c
  
  $(OBJ_D)/md2_dgst.o: $(SRC_D)/crypto/md/md2_dgst.c
  	$(CC) -o $(OBJ_D)/md2_dgst.o $(LIB_CFLAGS) -c $(SRC_D)/crypto/md/md2_dgst.c
*** /var/spool/ftp/pub/Crypto/SSL/064/SSLeay-0.6.3/./e_os.h	Wed Jul 24 15:33:19 1996
--- ./e_os.h	Thu Aug 29 23:50:25 1996
***************
*** 187,192 ****
--- 187,196 ----
  #  endif
  #endif
  
+ #if defined(THREADS) || defined(sun)
+ #define _REENTRANT
+ #endif
+ 
  /***********************************************/
  
  #ifndef NOPROTO
***************
*** 238,254 ****
  #define MD5_DIGEST_LENGTH 16
  #endif
  
- #ifdef undef
- #ifndef THREADS
- #define CRYPTO_w_lock(type)
- #define CRYPTO_w_unlock(type)
- #define CRYPTO_r_lock(type)
- #define CRYPTO_r_unlock(type)
- #endif
- #endif
- 
  #ifdef  __cplusplus
  }
  #endif
  
  #endif
--- 242,250 ----
  #define MD5_DIGEST_LENGTH 16
  #endif
  
  #ifdef  __cplusplus
  }
  #endif
  
  #endif
+ 
*** /var/spool/ftp/pub/Crypto/SSL/064/SSLeay-0.6.3/./MICROSOFT	Fri Jul 12 09:49:19 1996
--- ./MICROSOFT	Fri Aug 30 01:05:48 1996
***************
*** 3,13 ****
  The good news, to build SSLeay for the Microsft World
  
  Windows 3.1 DLL's
! perl Configure VC-W31-32
  nmake -f ms\w31dll.mak
  
! Windows NT DLL's
! perl Configure VC-NT
  nmake -f ms\ntdll.mak
  
  ms-dos
--- 3,13 ----
  The good news, to build SSLeay for the Microsft World
  
  Windows 3.1 DLL's
! perl Configure VC-WIN16
  nmake -f ms\w31dll.mak
  
! Windows NT/95 DLL's
! perl Configure VC-WIN32
  nmake -f ms\ntdll.mak
  
  ms-dos
***************
*** 22,33 ****
  All builds were made under Windows NT - this means long filenames, so
  you may have problems under Windows 3.1 but probably not under 95.
  
- I still have not done a work around for error recording for Windows
- 3.1 DLL's, but I know how I would do it.  I would simply look up the
- calling hosts ID and keep a 'error' structure hash table.  When the
- DLL is detached, I would remove the entry.  Time has prevented me
- putting this in in this verson. [ 0.6.1 update - this is now fixed ]
- 
  Because file pointers don't work in DLL's under Windows 3.1 (well at
  least stdin/stdout don't and I don't like having to differentiate
  between these and other file pointers), I now use the BIO file-pointer
--- 22,27 ----
***************
*** 48,54 ****
  
  The DLL and static builds are large memory model.
  
! To build static libraries for NT or win 3.1
  
  perl util/mk1mf.pl VC-NT > mf-stat.nt
  perl util/mk1mf.pl VC-W31-32 > mf-stat.w31
--- 42,48 ----
  
  The DLL and static builds are large memory model.
  
! To build static libraries for NT/95 or win 3.1
  
  perl util/mk1mf.pl VC-NT > mf-stat.nt
  perl util/mk1mf.pl VC-W31-32 > mf-stat.w31
***************
*** 66,72 ****
  x86w16.asm	- 16bit assember - used in the msdos build.
  x86w32.asm	- 32bit assember, win 3.1 segments, used for win16 build.
  
! If you feel compeled to build the 16bit maths routines in the windows 3.1
  build,
  perl Configure VC-W31-16
  perl util/mk1mf.pl dll VC-W31-16 > mf-dll.w31
--- 60,66 ----
  x86w16.asm	- 16bit assember - used in the msdos build.
  x86w32.asm	- 32bit assember, win 3.1 segments, used for win16 build.
  
! If you feel compelled to build the 16bit maths routines in the windows 3.1
  build,
  perl Configure VC-W31-16
  perl util/mk1mf.pl dll VC-W31-16 > mf-dll.w31
***************
*** 88,94 ****
  
  For both NT and Windows 3.1, I have not written the code so that
  s_client, s_server can take input from the keyboard.  You can happily
! start 2 up in seperate windows, watch them handshake, and then sit
  there for-ever.  I have not had the time to get this working, and I've
  been able to test things from a unix box to the NT box :-).
  Try running ssleay s_server on the windows box
--- 82,88 ----
  
  For both NT and Windows 3.1, I have not written the code so that
  s_client, s_server can take input from the keyboard.  You can happily
! start applications up in seperate windows, watch them handshake, and then sit
  there for-ever.  I have not had the time to get this working, and I've
  been able to test things from a unix box to the NT box :-).
  Try running ssleay s_server on the windows box
***************
*** 96,101 ****
--- 90,97 ----
  and run ssleay s_time from another window.
  This often stuffs up on Windows 3.1, but I'm not worried since this is
  probably a problem with my demo applications, not the libraries.
+ Windows NT 4.0 Beta2 somtimes has problems but I belive that
+ is a Beta2 problem, not mine.
  
  After a build of one of the version of microsoft SSLeay,
  'cd ms' and then run 'test'.  This should check everything out and
***************
*** 116,123 ****
  	edit crypto/bn/bn.h by hand, it will be clobered the next time
  	you run Configure by the contents of crypto/bn/bn.org).
  	SSLeay version -o will list the compile options.
! 	For VC-NT you need bn(64,32) or bn(32,32)
! 	For VC-W31-32 you need bn(32,32)
  	For VC-W31-16 you need bn(32,16) or bn(16,16)
  	For VC-MSDOS you need bn(32,16) or bn(16,16).
  
--- 112,119 ----
  	edit crypto/bn/bn.h by hand, it will be clobered the next time
  	you run Configure by the contents of crypto/bn/bn.org).
  	SSLeay version -o will list the compile options.
! 	For VC-NT/VC-WIN32 you need bn(64,32) or bn(32,32)
! 	For VC-W31-32/VC-WIN16 you need bn(32,32)
  	For VC-W31-16 you need bn(32,16) or bn(16,16)
  	For VC-MSDOS you need bn(32,16) or bn(16,16).
  
***************
*** 133,145 ****
  	error) and unless you want to work out which optimising flag
  	to turn off, I'm not going to help you :-).  I also noticed
  	that code often ran slower when compiled with /G3.
! 3)	You tried to do multi-threading in SSLeay.  Don't, I don't
! 	claim to be supporting it yet.
! 4)	Under NT, malloc goes stupid.  You are probably linking with
  	the wrong library, there are problems if you mix the threaded
  	and non-threaded libraries (due to the DLL being staticly
  	linked with one and the applicaion using another.
  
! Well hopefully that most of the MS issues handles, see you in ssl-users :-).
  
! eric 22-Jun-1996
--- 129,139 ----
  	error) and unless you want to work out which optimising flag
  	to turn off, I'm not going to help you :-).  I also noticed
  	that code often ran slower when compiled with /G3.
! 3)	Under NT/95, malloc goes stupid.  You are probably linking with
  	the wrong library, there are problems if you mix the threaded
  	and non-threaded libraries (due to the DLL being staticly
  	linked with one and the applicaion using another.
  
! Well hopefully thats most of the MS issues handled, see you in ssl-users :-).
  
! eric 30-Aug-1996
*** /dev/null	Fri Aug 30 04:16:48 1996
--- ./makevms.com	Thu Aug 29 23:50:26 1996
***************
*** 0 ****
--- 1,65 ----
+ $!
+ $! This procedure compiles the SSL sources into 2 libraries:
+ $!	[.CRYPTO]CRYPTO-xxx.OLB		! crypto-graphics subroutines
+ $!	[.SSL]SSL-xxx.OLB		! SSL protocol.
+ $!
+ $!  where 'xxx' specifies the machine achitecture: AXP or VAX
+ $!
+ $!  To perform 1 sub-option, specify P1 as one of:
+ $!	INCLUDE CRYPTO SSL SSL_TASK
+ $!
+ $!  Requirements:
+ $!	DECC 4.0   	(may work with other versions)
+ $!	OpenVMS 6.1	(may work with other versions)
+ $!
+ $ original_default = f$environment("DEFAULT")
+ $ proc = f$environment("PROCEDURE")
+ $ proc_dir = f$parse("1.1;1",proc) - "1.1;1"
+ $ set default 'proc_dir'
+ $!
+ $! Copy all include files to [.include]
+ $!
+ $ set noon
+ $ if P1 .nes. "" then goto do_'p1'
+ $ do_
+ $ write sys$output "Rebuilding [.include] directory..."
+ $ delete [.include]*.h;*
+ $ backup [.*...]*.h; includes.bck/save
+ $ backup includes.bck/save [.include]
+ $ delete includes.bck;
+ $ if p1 .nes. "" then goto cleanup
+ $!
+ $! Build crypto lib.
+ $!
+ $ do_crypto:
+ $ write sys$Output "Making CRYPTO library"
+ $ set default [.crypto]
+ $ @libvms
+ $ set default [-]
+ $ if p1 .nes. "" then goto cleanup
+ $!
+ $! Build SSL lib.
+ $!
+ $ do_ssl:
+ $ write sys$output "Making SSL library"
+ $ set default [.ssl]
+ $ libname = "ssl-axp.olb"
+ $ if f$getsyi("CPU") .lt. 128 then libname = "ssl-vax.olb"
+ $ if f$search(libname) .eqs. "" then library/create/log 'libname'
+ $ cc ssl.c/include=[-.include]/prefix=all
+ $ library/replace 'libname' ssl.obj
+ $ set default [-]
+ $ if p1 .nes. "" then goto cleanup
+ $!
+ $ do_ssl_task:
+ $ write sys$output "Building SSL_TASK.EXE, the DECnet-based SSL engine"
+ $ set default [.ssl]
+ $ libname = "ssl-axp.olb"
+ $ if f$getsyi("CPU") .lt. 128 then libname = "ssl-vax.olb"
+ $ cc ssl_task/include=[-.include]/prefix=all
+ $ cryptolib = "[-.crypto]crypto-" + f$element(1,"-",libname)
+ $ link ssl_task,'libname'/library,'cryptolib'/library
+ $!
+ $ cleanup:
+ $ set default 'original_default'
+ $ write sys$output "Done"
*** /var/spool/ftp/pub/Crypto/SSL/064/SSLeay-0.6.3/./crypto/asn1/asn1_lib.c	Tue Aug  6 15:57:44 1996
--- ./crypto/asn1/asn1_lib.c	Fri Aug 30 00:58:28 1996
***************
*** 57,63 ****
  static void asn1_put_length();
  #endif
  
! char *ASN1_version="ASN1 part of SSLeay 0.6.3 06-Aug-1996";
  
  int ASN1_check_infinite_end(p,len)
  unsigned char **p;
--- 57,63 ----
  static void asn1_put_length();
  #endif
  
! char *ASN1_version="ASN1 part of SSLeay 0.6.4 30-Aug-1996";
  
  int ASN1_check_infinite_end(p,len)
  unsigned char **p;
***************
*** 185,196 ****
  	else
  		{
  		*(p++)=i|V_ASN1_PRIMATIVE_TAG;
! 		while (tag > 0x3f)
  			{
! 			*(p++)=(tag&0x3f)|0x80;
  			tag>>=7;
  			}
! 		*(p++)=(tag&0x3f);
  		}
  	if ((constructed == 2) && (length == 0))
  		*(p++)=0x80; /* der_put_length would output 0 instead */
--- 185,196 ----
  	else
  		{
  		*(p++)=i|V_ASN1_PRIMATIVE_TAG;
! 		while (tag > 0x7f)
  			{
! 			*(p++)=(tag&0x7f)|0x80;
  			tag>>=7;
  			}
! 		*(p++)=(tag&0x7f);
  		}
  	if ((constructed == 2) && (length == 0))
  		*(p++)=0x80; /* der_put_length would output 0 instead */
*** /var/spool/ftp/pub/Crypto/SSL/064/SSLeay-0.6.3/./crypto/asn1/asn1_mac.h	Sun Jul 21 00:36:26 1996
--- ./crypto/asn1/asn1_mac.h	Thu Aug 29 23:50:28 1996
***************
*** 83,89 ****
  	return(ret); \
  err:\
  	ASN1err((e),c.error); \
! 	if (ret != NULL) func(ret); \
  	if ((a != NULL) && (*a == ret)) *a=NULL; \
  	return(NULL)
  
--- 83,89 ----
  	return(ret); \
  err:\
  	ASN1err((e),c.error); \
! 	if ((ret != NULL) && (a != NULL) && (*a != ret)) func(ret); \
  	if ((a != NULL) && (*a == ret)) *a=NULL; \
  	return(NULL)
  
***************
*** 183,189 ****
  
  /* New macros */
  #define M_ASN1_New_Malloc(ret,type) \
! 	if ((ret=(type *)malloc(sizeof(type))) == NULL) goto err2;
  
  #define M_ASN1_New(arg,func) \
  	if (((arg)=func()) == NULL) return(NULL)
--- 183,189 ----
  
  /* New macros */
  #define M_ASN1_New_Malloc(ret,type) \
! 	if ((ret=(type *)Malloc(sizeof(type))) == NULL) goto err2;
  
  #define M_ASN1_New(arg,func) \
  	if (((arg)=func()) == NULL) return(NULL)
*** /var/spool/ftp/pub/Crypto/SSL/064/SSLeay-0.6.3/./crypto/asn1/a_bitstr.c	Wed Jul 17 16:45:34 1996
--- ./crypto/asn1/a_bitstr.c	Thu Aug 29 23:50:28 1996
***************
*** 118,124 ****
  	i= *(p++);
  	if (len-- > 1) /* using one because of the bits left byte */
  		{
! 		s=(unsigned char *)malloc((int)len);
  		if (s == NULL)
  			{
  			i=ERR_R_MALLOC_FAILURE;
--- 118,124 ----
  	i= *(p++);
  	if (len-- > 1) /* using one because of the bits left byte */
  		{
! 		s=(unsigned char *)Malloc((int)len);
  		if (s == NULL)
  			{
  			i=ERR_R_MALLOC_FAILURE;
***************
*** 132,138 ****
  		s=NULL;
  
  	ret->length=(int)len;
! 	if (ret->data != NULL) free(ret->data);
  	ret->data=s;
  	ret->type=V_ASN1_BIT_STRING;
  	if (a != NULL) (*a)=ret;
--- 132,138 ----
  		s=NULL;
  
  	ret->length=(int)len;
! 	if (ret->data != NULL) Free((char *)ret->data);
  	ret->data=s;
  	ret->type=V_ASN1_BIT_STRING;
  	if (a != NULL) (*a)=ret;
***************
*** 150,156 ****
  	{
  	ASN1_BIT_STRING *ret;
  
! 	ret=(ASN1_BIT_STRING *)malloc(sizeof(ASN1_BIT_STRING));
  	if (ret == NULL)
  		{
  		ASN1err(ASN1_F_ASN1_BIT_STRING_TYPE_NEW,ERR_R_MALLOC_FAILURE);
--- 150,156 ----
  	{
  	ASN1_BIT_STRING *ret;
  
! 	ret=(ASN1_BIT_STRING *)Malloc(sizeof(ASN1_BIT_STRING));
  	if (ret == NULL)
  		{
  		ASN1err(ASN1_F_ASN1_BIT_STRING_TYPE_NEW,ERR_R_MALLOC_FAILURE);
***************
*** 166,173 ****
  ASN1_BIT_STRING *a;
  	{
  	if (a == NULL) return;
! 	if (a->data != NULL) free(a->data);
! 	free(a);
  	}
  
  int ASN1_BIT_STRING_cmp(a,b)
--- 166,173 ----
  ASN1_BIT_STRING *a;
  	{
  	if (a == NULL) return;
! 	if (a->data != NULL) Free((char *)a->data);
! 	Free((char *)a);
  	}
  
  int ASN1_BIT_STRING_cmp(a,b)
*** /var/spool/ftp/pub/Crypto/SSL/064/SSLeay-0.6.3/./crypto/asn1/a_dup.c	Wed Jul 17 16:45:35 1996
--- ./crypto/asn1/a_dup.c	Thu Aug 29 23:50:28 1996
***************
*** 63,69 ****
  	if (x == NULL) return(NULL);
  
  	i=i2d(x,NULL);
! 	b=(unsigned char *)malloc((unsigned int)i+10);
  	if (b == NULL)
  		{ ASN1err(ASN1_F_ASN1_DUP,ERR_R_MALLOC_FAILURE); return(NULL); }
  	p= b;
--- 63,69 ----
  	if (x == NULL) return(NULL);
  
  	i=i2d(x,NULL);
! 	b=(unsigned char *)Malloc((unsigned int)i+10);
  	if (b == NULL)
  		{ ASN1err(ASN1_F_ASN1_DUP,ERR_R_MALLOC_FAILURE); return(NULL); }
  	p= b;
***************
*** 70,75 ****
  	i2d(x,&p);
  	p= b;
  	ret=d2i(NULL,&p,i);
! 	free(b);
  	return(ret);
  	}
--- 70,75 ----
  	i2d(x,&p);
  	p= b;
  	ret=d2i(NULL,&p,i);
! 	Free((char *)b);
  	return(ret);
  	}
*** /var/spool/ftp/pub/Crypto/SSL/064/SSLeay-0.6.3/./crypto/asn1/a_hdr.c	Wed Jul 17 16:45:35 1996
--- ./crypto/asn1/a_hdr.c	Thu Aug 29 23:50:28 1996
***************
*** 115,119 ****
  	ASN1_OCTET_STRING_free(a->header);
  	if (a->meth != NULL)
  		a->meth->destroy(a->data);
! 	free(a);
  	}
--- 115,119 ----
  	ASN1_OCTET_STRING_free(a->header);
  	if (a->meth != NULL)
  		a->meth->destroy(a->data);
! 	Free((char *)a);
  	}
*** /var/spool/ftp/pub/Crypto/SSL/064/SSLeay-0.6.3/./crypto/asn1/a_i2d_fp.c	Wed Jul 17 16:45:35 1996
--- ./crypto/asn1/a_i2d_fp.c	Thu Aug 29 23:50:28 1996
***************
*** 81,87 ****
  	int i,j=0,n,ret=1;
  
  	n=i2d(x,NULL);
! 	b=(char *)malloc(n);
  	if (b == NULL)
  		{
  		ASN1err(ASN1_F_ASN1_I2D_BIO,ERR_R_MALLOC_FAILURE);
--- 81,87 ----
  	int i,j=0,n,ret=1;
  
  	n=i2d(x,NULL);
! 	b=(char *)Malloc(n);
  	if (b == NULL)
  		{
  		ASN1err(ASN1_F_ASN1_I2D_BIO,ERR_R_MALLOC_FAILURE);
***************
*** 103,108 ****
  		j+=i;
  		n-=i;
  		}
! 	free(b);
  	return(ret);
  	}
--- 103,108 ----
  		j+=i;
  		n-=i;
  		}
! 	Free((char *)b);
  	return(ret);
  	}
*** /var/spool/ftp/pub/Crypto/SSL/064/SSLeay-0.6.3/./crypto/asn1/a_int.c	Fri Aug  2 17:24:02 1996
--- ./crypto/asn1/a_int.c	Thu Aug 29 23:50:28 1996
***************
*** 138,146 ****
  		goto err;
  		}
  
! 	/* We must malloc stuff, even for 0 bytes otherwise it
  	 * signifies a missing NULL parameter. */
! 	s=(unsigned char *)malloc((int)len+1);
  	if (s == NULL)
  		{
  		i=ERR_R_MALLOC_FAILURE;
--- 138,146 ----
  		goto err;
  		}
  
! 	/* We must Malloc stuff, even for 0 bytes otherwise it
  	 * signifies a missing NULL parameter. */
! 	s=(unsigned char *)Malloc((int)len+1);
  	if (s == NULL)
  		{
  		i=ERR_R_MALLOC_FAILURE;
***************
*** 170,176 ****
  		p+=len;
  		}
  
! 	if (ret->data != NULL) free(ret->data);
  	ret->data=s;
  	ret->length=(int)len;
  	if (a != NULL) (*a)=ret;
--- 170,176 ----
  		p+=len;
  		}
  
! 	if (ret->data != NULL) Free((char *)ret->data);
  	ret->data=s;
  	ret->length=(int)len;
  	if (a != NULL) (*a)=ret;
***************
*** 195,202 ****
  	if (a->length < (sizeof(long)+1))
  		{
  		if (a->data != NULL)
! 			free(a->data);
! 		a->data=(unsigned char *)malloc(sizeof(long)+1);
  		}
  	if (a->data == NULL)
  		{
--- 195,202 ----
  	if (a->length < (sizeof(long)+1))
  		{
  		if (a->data != NULL)
! 			Free((char *)a->data);
! 		a->data=(unsigned char *)Malloc(sizeof(long)+1);
  		}
  	if (a->data == NULL)
  		{
***************
*** 267,273 ****
  	ret->type=V_ASN1_INTEGER;
  	j=BN_num_bits(bn);
  	len=((j == 0)?0:((j/8)+1));
! 	ret->data=(unsigned char *)malloc(len+4);
  	ret->length=BN_bn2bin(bn,ret->data);
  	return(ret);
  err:
--- 267,273 ----
  	ret->type=V_ASN1_INTEGER;
  	j=BN_num_bits(bn);
  	len=((j == 0)?0:((j/8)+1));
! 	ret->data=(unsigned char *)Malloc(len+4);
  	ret->length=BN_bn2bin(bn,ret->data);
  	return(ret);
  err:
*** /var/spool/ftp/pub/Crypto/SSL/064/SSLeay-0.6.3/./crypto/asn1/a_object.c	Wed Aug  7 16:11:00 1996
--- ./crypto/asn1/a_object.c	Thu Aug 29 23:50:28 1996
***************
*** 179,186 ****
  		}
  	if ((ret->data == NULL) || (ret->length < len))
  		{
! 		if (ret->data != NULL) free(ret->data);
! 		ret->data=(unsigned char *)malloc((int)len);
  		if (ret->data == NULL)
  			{ i=ERR_R_MALLOC_FAILURE; goto err; }
  		}
--- 179,186 ----
  		}
  	if ((ret->data == NULL) || (ret->length < len))
  		{
! 		if (ret->data != NULL) Free((char *)ret->data);
! 		ret->data=(unsigned char *)Malloc((int)len);
  		if (ret->data == NULL)
  			{ i=ERR_R_MALLOC_FAILURE; goto err; }
  		}
***************
*** 205,211 ****
  	{
  	ASN1_OBJECT *ret;
  
! 	ret=(ASN1_OBJECT *)malloc(sizeof(ASN1_OBJECT));
  	if (ret == NULL)
  		{
  		ASN1err(ASN1_F_ASN1_OBJECT_NEW,ERR_R_MALLOC_FAILURE);
--- 205,211 ----
  	{
  	ASN1_OBJECT *ret;
  
! 	ret=(ASN1_OBJECT *)Malloc(sizeof(ASN1_OBJECT));
  	if (ret == NULL)
  		{
  		ASN1err(ASN1_F_ASN1_OBJECT_NEW,ERR_R_MALLOC_FAILURE);
***************
*** 224,230 ****
  ASN1_OBJECT *a;
  	{
  	if ((a == NULL) || !a->dynamic) return;
! 	if (a->data != NULL) free(a->data);
! 	free(a);
  	}
  
--- 224,230 ----
  ASN1_OBJECT *a;
  	{
  	if ((a == NULL) || !a->dynamic) return;
! 	if (a->data != NULL) Free((char *)a->data);
! 	Free((char *)a);
  	}
  
*** /var/spool/ftp/pub/Crypto/SSL/064/SSLeay-0.6.3/./crypto/asn1/a_print.c	Wed Jul 17 16:45:35 1996
--- ./crypto/asn1/a_print.c	Thu Aug 29 23:50:28 1996
***************
*** 146,152 ****
  		}
  	if (len != 0)
  		{
! 		s=(unsigned char *)malloc((int)len+1);
  		if (s == NULL)
  			{
  			i=ERR_R_MALLOC_FAILURE;
--- 146,152 ----
  		}
  	if (len != 0)
  		{
! 		s=(unsigned char *)Malloc((int)len+1);
  		if (s == NULL)
  			{
  			i=ERR_R_MALLOC_FAILURE;
***************
*** 159,165 ****
  	else
  		s=NULL;
  
! 	if (ret->data != NULL) free(ret->data);
  	ret->length=(int)len;
  	ret->data=s;
  	ret->type=tag;
--- 159,165 ----
  	else
  		s=NULL;
  
! 	if (ret->data != NULL) Free((char *)ret->data);
  	ret->length=(int)len;
  	ret->data=s;
  	ret->type=tag;
*** /var/spool/ftp/pub/Crypto/SSL/064/SSLeay-0.6.3/./crypto/asn1/a_sign.c	Sat Jul 20 00:16:22 1996
--- ./crypto/asn1/a_sign.c	Thu Aug 29 23:50:28 1996
***************
*** 100,108 ****
  			}
  		}
  	inl=i2d(data,NULL);
! 	buf_in=(unsigned char *)malloc((unsigned int)inl);
  	outll=outl=EVP_PKEY_size(pkey);
! 	buf_out=(unsigned char *)malloc((unsigned int)outl);
  	if ((buf_in == NULL) || (buf_out == NULL))
  		{
  		outl=0;
--- 100,108 ----
  			}
  		}
  	inl=i2d(data,NULL);
! 	buf_in=(unsigned char *)Malloc((unsigned int)inl);
  	outll=outl=EVP_PKEY_size(pkey);
! 	buf_out=(unsigned char *)Malloc((unsigned int)outl);
  	if ((buf_in == NULL) || (buf_out == NULL))
  		{
  		outl=0;
***************
*** 121,127 ****
  		ASN1err(ASN1_F_ASN1_SIGN,ERR_R_EVP_LIB);
  		goto err;
  		}
! 	if (signature->data != NULL) free(signature->data);
  	signature->data=buf_out;
  	buf_out=NULL;
  	signature->length=outl;
--- 121,127 ----
  		ASN1err(ASN1_F_ASN1_SIGN,ERR_R_EVP_LIB);
  		goto err;
  		}
! 	if (signature->data != NULL) Free((char *)signature->data);
  	signature->data=buf_out;
  	buf_out=NULL;
  	signature->length=outl;
***************
*** 129,136 ****
  err:
  	memset(&ctx,0,sizeof(ctx));
  	if (buf_in != NULL)
! 		{ memset((char *)buf_in,0,(unsigned int)inl); free(buf_in); }
  	if (buf_out != NULL)
! 		{ memset((char *)buf_out,0,outll); free(buf_out); }
  	return(outl);
  	}
--- 129,136 ----
  err:
  	memset(&ctx,0,sizeof(ctx));
  	if (buf_in != NULL)
! 		{ memset((char *)buf_in,0,(unsigned int)inl); Free((char *)buf_in); }
  	if (buf_out != NULL)
! 		{ memset((char *)buf_out,0,outll); Free((char *)buf_out); }
  	return(outl);
  	}
*** /var/spool/ftp/pub/Crypto/SSL/064/SSLeay-0.6.3/./crypto/asn1/a_type.c	Wed Jul 17 16:45:35 1996
--- ./crypto/asn1/a_type.c	Thu Aug 29 23:50:28 1996
***************
*** 249,255 ****
  			break;
  			}
  		}
! 	free((char *)a);
  	}
  
  int i2d_ASN1_bytes(a, pp, tag, xclass)
--- 249,255 ----
  			break;
  			}
  		}
! 	Free((char *)(char *)a);
  	}
  
  int i2d_ASN1_bytes(a, pp, tag, xclass)
***************
*** 307,314 ****
  		{
  		if (ret->length < len)
  			{
! 			if (ret->data != NULL) free(ret->data);
! 			s=(unsigned char *)malloc((int)len);
  			if (s == NULL)
  				{
  				i=ERR_R_MALLOC_FAILURE;
--- 307,314 ----
  		{
  		if (ret->length < len)
  			{
! 			if (ret->data != NULL) Free((char *)ret->data);
! 			s=(unsigned char *)Malloc((int)len);
  			if (s == NULL)
  				{
  				i=ERR_R_MALLOC_FAILURE;
***************
*** 323,329 ****
  	else
  		{
  		s=NULL;
! 		if (ret->data != NULL) free(ret->data);
  		}
  
  	ret->length=(int)len;
--- 323,329 ----
  	else
  		{
  		s=NULL;
! 		if (ret->data != NULL) Free((char *)ret->data);
  		}
  
  	ret->length=(int)len;
*** /var/spool/ftp/pub/Crypto/SSL/064/SSLeay-0.6.3/./crypto/asn1/a_utctm.c	Wed Jul 17 16:45:35 1996
--- ./crypto/asn1/a_utctm.c	Fri Aug 30 03:55:45 1996
***************
*** 124,130 ****
  	{
  	ASN1_UTCTIME *ret;
  
! 	ret=(ASN1_UTCTIME *)malloc(/*sizeof(ASN1_UTCTIME)*/ 32);
  	if (ret == NULL)
  		{
  		ASN1err(ASN1_F_ASN1_UTCTIME_NEW,ERR_R_MALLOC_FAILURE);
--- 124,130 ----
  	{
  	ASN1_UTCTIME *ret;
  
! 	ret=(ASN1_UTCTIME *)Malloc(/*sizeof(ASN1_UTCTIME)*/ 32);
  	if (ret == NULL)
  		{
  		ASN1err(ASN1_F_ASN1_UTCTIME_NEW,ERR_R_MALLOC_FAILURE);
***************
*** 138,144 ****
  	{
  	ASN1_UTCTIME *ret;
  
! 	ret=(ASN1_UTCTIME *)malloc(/*sizeof(ASN1_UTCTIME)*/ 32);
  	if (ret == NULL)
  		{
  		ASN1err(ASN1_F_ASN1_UTCTIME_DUP,ERR_R_MALLOC_FAILURE);
--- 138,144 ----
  	{
  	ASN1_UTCTIME *ret;
  
! 	ret=(ASN1_UTCTIME *)Malloc(/*sizeof(ASN1_UTCTIME)*/ 32);
  	if (ret == NULL)
  		{
  		ASN1err(ASN1_F_ASN1_UTCTIME_DUP,ERR_R_MALLOC_FAILURE);
***************
*** 151,157 ****
  void ASN1_UTCTIME_free(a)
  ASN1_UTCTIME *a;
  	{
! 	if (a != NULL) free(a);
  	}
  
  int ASN1_UTCTIME_check(a)
--- 151,157 ----
  void ASN1_UTCTIME_free(a)
  ASN1_UTCTIME *a;
  	{
! 	if (a != NULL) Free((char *)a);
  	}
  
  int ASN1_UTCTIME_check(a)
***************
*** 201,207 ****
  time_t t;
  	{
  	struct tm *ts;
! #if defined(THREADS) && defined(sun)
  	struct tm data;
  #endif
  
--- 201,207 ----
  time_t t;
  	{
  	struct tm *ts;
! #if defined(THREADS)
  	struct tm data;
  #endif
  
***************
*** 208,217 ****
  	if (s == NULL)
  		s=ASN1_UTCTIME_new();
  	if (s == NULL) return(NULL);
! #if defined(THREADS) && defined(sun)
! 	ts=gmtime_r(&t,&data);
  #else
! 	ts=gmtime(&t);
  #endif
  	sprintf(s,"%02d%02d%02d%02d%02d%02dZ",ts->tm_year%100,
  		ts->tm_mon+1,ts->tm_mday,ts->tm_hour,ts->tm_min,ts->tm_sec);
--- 208,217 ----
  	if (s == NULL)
  		s=ASN1_UTCTIME_new();
  	if (s == NULL) return(NULL);
! #if defined(THREADS)
! 	ts=(struct tm *)gmtime_r(&t,&data);
  #else
! 	ts=(struct tm *)gmtime(&t);
  #endif
  	sprintf(s,"%02d%02d%02d%02d%02d%02dZ",ts->tm_year%100,
  		ts->tm_mon+1,ts->tm_mday,ts->tm_hour,ts->tm_min,ts->tm_sec);
*** /var/spool/ftp/pub/Crypto/SSL/064/SSLeay-0.6.3/./crypto/asn1/a_verify.c	Wed Jul 17 16:45:36 1996
--- ./crypto/asn1/a_verify.c	Thu Aug 29 23:50:28 1996
***************
*** 79,85 ****
  		}
  	
  	inl=i2d(data,NULL);
! 	buf_in=(unsigned char *)malloc((unsigned int)inl);
  	if (buf_in == NULL)
  		{
  		ASN1err(ASN1_F_ASN1_VERIFY,ERR_R_MALLOC_FAILURE);
--- 79,85 ----
  		}
  	
  	inl=i2d(data,NULL);
! 	buf_in=(unsigned char *)Malloc((unsigned int)inl);
  	if (buf_in == NULL)
  		{
  		ASN1err(ASN1_F_ASN1_VERIFY,ERR_R_MALLOC_FAILURE);
***************
*** 92,98 ****
  	EVP_VerifyUpdate(&ctx,(unsigned char *)buf_in,inl);
  
  	memset(buf_in,0,(unsigned int)inl);
! 	free(buf_in);
  
  	if (EVP_VerifyFinal(&ctx,(unsigned char *)signature->data,
  			(unsigned int)signature->length,pkey) <= 0)
--- 92,98 ----
  	EVP_VerifyUpdate(&ctx,(unsigned char *)buf_in,inl);
  
  	memset(buf_in,0,(unsigned int)inl);
! 	Free((char *)buf_in);
  
  	if (EVP_VerifyFinal(&ctx,(unsigned char *)signature->data,
  			(unsigned int)signature->length,pkey) <= 0)
*** /var/spool/ftp/pub/Crypto/SSL/064/SSLeay-0.6.3/./crypto/asn1/f_int.c	Wed Jul 17 16:45:37 1996
--- ./crypto/asn1/f_int.c	Thu Aug 29 23:50:28 1996
***************
*** 143,157 ****
  		if (num+i > slen)
  			{
  			if (s == NULL)
! 				sp=(unsigned char *)malloc(
  					(unsigned int)num+i*2);
  			else
! 				sp=(unsigned char *)realloc(s,
  					(unsigned int)num+i*2);
  			if (sp == NULL)
  				{
  				ASN1err(ASN1_F_A2I_ASN1_INTEGER,ERR_R_MALLOC_FAILURE);
! 				if (s != NULL) free(s);
  				goto err;
  				}
  			s=sp;
--- 143,157 ----
  		if (num+i > slen)
  			{
  			if (s == NULL)
! 				sp=(unsigned char *)Malloc(
  					(unsigned int)num+i*2);
  			else
! 				sp=(unsigned char *)Realloc(s,
  					(unsigned int)num+i*2);
  			if (sp == NULL)
  				{
  				ASN1err(ASN1_F_A2I_ASN1_INTEGER,ERR_R_MALLOC_FAILURE);
! 				if (s != NULL) Free((char *)s);
  				goto err;
  				}
  			s=sp;
*** /var/spool/ftp/pub/Crypto/SSL/064/SSLeay-0.6.3/./crypto/asn1/i2d_dh.c	Wed Jul 17 16:45:37 1996
--- ./crypto/asn1/i2d_dh.c	Thu Aug 29 23:50:28 1996
***************
*** 95,101 ****
  	ASN1_put_object(&p,1,tot,V_ASN1_SEQUENCE,V_ASN1_UNIVERSAL);
  
  	bs.type=V_ASN1_INTEGER;
! 	bs.data=(unsigned char *)malloc(max+4);
  	if (bs.data == NULL)
  		{
  		ASN1err(ASN1_F_I2D_DHPARAMS,ERR_R_MALLOC_FAILURE);
--- 95,101 ----
  	ASN1_put_object(&p,1,tot,V_ASN1_SEQUENCE,V_ASN1_UNIVERSAL);
  
  	bs.type=V_ASN1_INTEGER;
! 	bs.data=(unsigned char *)Malloc(max+4);
  	if (bs.data == NULL)
  		{
  		ASN1err(ASN1_F_I2D_DHPARAMS,ERR_R_MALLOC_FAILURE);
***************
*** 108,114 ****
  		bs.length=BN_bn2bin(num[i],bs.data);
  		i2d_ASN1_INTEGER(&bs,&p);
  		}
! 	free(bs.data);
  	ret=t;
  err:
  	if (num[2] != NULL) BN_free(num[2]);
--- 108,114 ----
  		bs.length=BN_bn2bin(num[i],bs.data);
  		i2d_ASN1_INTEGER(&bs,&p);
  		}
! 	Free((char *)bs.data);
  	ret=t;
  err:
  	if (num[2] != NULL) BN_free(num[2]);
*** /var/spool/ftp/pub/Crypto/SSL/064/SSLeay-0.6.3/./crypto/asn1/i2d_r_pr.c	Wed Jul 17 16:45:37 1996
--- ./crypto/asn1/i2d_r_pr.c	Thu Aug 29 23:50:28 1996
***************
*** 102,108 ****
  
  	i2d_ASN1_INTEGER(&bs,&p);
  
! 	bs.data=(unsigned char *)malloc(max+4);
  	if (bs.data == NULL)
  		{
  		ASN1err(ASN1_F_I2D_RSAPRIVATEKEY,ERR_R_MALLOC_FAILURE);
--- 102,108 ----
  
  	i2d_ASN1_INTEGER(&bs,&p);
  
! 	bs.data=(unsigned char *)Malloc(max+4);
  	if (bs.data == NULL)
  		{
  		ASN1err(ASN1_F_I2D_RSAPRIVATEKEY,ERR_R_MALLOC_FAILURE);
***************
*** 114,120 ****
  		bs.length=BN_bn2bin(num[i],bs.data);
  		i2d_ASN1_INTEGER(&bs,&p);
  		}
! 	free(bs.data);
  	*pp=p;
  	return(t);
  	}
--- 114,120 ----
  		bs.length=BN_bn2bin(num[i],bs.data);
  		i2d_ASN1_INTEGER(&bs,&p);
  		}
! 	Free((char *)bs.data);
  	*pp=p;
  	return(t);
  	}
*** /var/spool/ftp/pub/Crypto/SSL/064/SSLeay-0.6.3/./crypto/asn1/i2d_r_pu.c	Wed Jul 17 16:45:37 1996
--- ./crypto/asn1/i2d_r_pu.c	Thu Aug 29 23:50:28 1996
***************
*** 88,94 ****
  	ASN1_put_object(&p,1,tot,V_ASN1_SEQUENCE,V_ASN1_UNIVERSAL);
  
  	bs.type=V_ASN1_INTEGER;
! 	bs.data=(unsigned char *)malloc(max+4);
  	if (bs.data == NULL)
  		{
  		ASN1err(ASN1_F_I2D_RSAPUBLICKEY,ERR_R_MALLOC_FAILURE);
--- 88,94 ----
  	ASN1_put_object(&p,1,tot,V_ASN1_SEQUENCE,V_ASN1_UNIVERSAL);
  
  	bs.type=V_ASN1_INTEGER;
! 	bs.data=(unsigned char *)Malloc(max+4);
  	if (bs.data == NULL)
  		{
  		ASN1err(ASN1_F_I2D_RSAPUBLICKEY,ERR_R_MALLOC_FAILURE);
***************
*** 100,106 ****
  		bs.length=BN_bn2bin(num[i],bs.data);
  		i2d_ASN1_INTEGER(&bs,&p);
  		}
! 	free(bs.data);
  	*pp=p;
  	return(t);
  	}
--- 100,106 ----
  		bs.length=BN_bn2bin(num[i],bs.data);
  		i2d_ASN1_INTEGER(&bs,&p);
  		}
! 	Free((char *)bs.data);
  	*pp=p;
  	return(t);
  	}
*** /var/spool/ftp/pub/Crypto/SSL/064/SSLeay-0.6.3/./crypto/asn1/Makefile.ssl	Thu Aug  8 01:54:28 1996
--- ./crypto/asn1/Makefile.ssl	Fri Aug 30 04:40:59 1996
***************
*** 108,114 ****
  	mv -f Makefile.new $(MAKEFILE)
  
  clean:
! 	/bin/rm -f *.o *.obj lib tags core .nfs* *.old *.bak fluff
  
  errors:
  	perl $(TOP)/util/err-ins.pl $(ERR).err $(ERR).h
--- 108,114 ----
  	mv -f Makefile.new $(MAKEFILE)
  
  clean:
! 	/bin/rm -f *.o *.obj lib tags core .pure .nfs* *.old *.bak fluff
  
  errors:
  	perl $(TOP)/util/err-ins.pl $(ERR).err $(ERR).h
*** /var/spool/ftp/pub/Crypto/SSL/064/SSLeay-0.6.3/./crypto/asn1/n_pkey.c	Wed Jul 17 16:45:37 1996
--- ./crypto/asn1/n_pkey.c	Thu Aug 29 23:50:28 1996
***************
*** 144,151 ****
  		}
  
  	if (pkey->private_key->data != NULL)
! 		free(pkey->private_key->data);
! 	if ((pkey->private_key->data=(unsigned char *)malloc(l[0])) == NULL)
  		{
  		ASN1err(ASN1_F_I2D_NETSCAPE_RSA,ERR_R_MALLOC_FAILURE);
  		goto err;
--- 144,151 ----
  		}
  
  	if (pkey->private_key->data != NULL)
! 		Free((char *)pkey->private_key->data);
! 	if ((pkey->private_key->data=(unsigned char *)Malloc(l[0])) == NULL)
  		{
  		ASN1err(ASN1_F_I2D_NETSCAPE_RSA,ERR_R_MALLOC_FAILURE);
  		goto err;
***************
*** 153,159 ****
  	zz=pkey->private_key->data;
  	i2d_RSAPrivateKey(a,&zz);
  
! 	if ((os2.data=(unsigned char *)malloc(os2.length)) == NULL)
  		{
  		ASN1err(ASN1_F_I2D_NETSCAPE_RSA,ERR_R_MALLOC_FAILURE);
  		goto err;
--- 153,159 ----
  	zz=pkey->private_key->data;
  	i2d_RSAPrivateKey(a,&zz);
  
! 	if ((os2.data=(unsigned char *)Malloc(os2.length)) == NULL)
  		{
  		ASN1err(ASN1_F_I2D_NETSCAPE_RSA,ERR_R_MALLOC_FAILURE);
  		goto err;
***************
*** 185,191 ****
  	i2d_ASN1_OCTET_STRING(&os2,&p);
  	ret=l[5];
  err:
! 	if (os2.data != NULL) free(os2.data);
  	if (alg != NULL) X509_ALGOR_free(alg);
  	if (pkey != NULL) NETSCAPE_PKEY_free(pkey);
  	r=r;
--- 185,191 ----
  	i2d_ASN1_OCTET_STRING(&os2,&p);
  	ret=l[5];
  err:
! 	if (os2.data != NULL) Free((char *)os2.data);
  	if (alg != NULL) X509_ALGOR_free(alg);
  	if (pkey != NULL) NETSCAPE_PKEY_free(pkey);
  	r=r;
***************
*** 346,352 ****
  	ASN1_INTEGER_free(a->version);
  	X509_ALGOR_free(a->algor);
  	ASN1_OCTET_STRING_free(a->private_key);
! 	free(a);
  	}
  
  #endif /* NO_RC4 */
--- 346,352 ----
  	ASN1_INTEGER_free(a->version);
  	X509_ALGOR_free(a->algor);
  	ASN1_OCTET_STRING_free(a->private_key);
! 	Free((char *)a);
  	}
  
  #endif /* NO_RC4 */
*** /var/spool/ftp/pub/Crypto/SSL/064/SSLeay-0.6.3/./crypto/asn1/p7_dgst.c	Wed Aug  7 16:40:05 1996
--- ./crypto/asn1/p7_dgst.c	Thu Aug 29 23:50:28 1996
***************
*** 114,119 ****
  	X509_ALGOR_free(a->md);
  	PKCS7_free(a->contents);
  	ASN1_OCTET_STRING_free(a->digest);
! 	free(a);
  	}
  
--- 114,119 ----
  	X509_ALGOR_free(a->md);
  	PKCS7_free(a->contents);
  	ASN1_OCTET_STRING_free(a->digest);
! 	Free((char *)a);
  	}
  
*** /var/spool/ftp/pub/Crypto/SSL/064/SSLeay-0.6.3/./crypto/asn1/p7_enc.c	Wed Aug  7 16:40:05 1996
--- ./crypto/asn1/p7_enc.c	Thu Aug 29 23:50:28 1996
***************
*** 104,109 ****
  	if (a == NULL) return;
  	ASN1_INTEGER_free(a->version);
  	PKCS7_ENC_CONTENT_free(a->enc_data);
! 	free(a);
  	}
  
--- 104,109 ----
  	if (a == NULL) return;
  	ASN1_INTEGER_free(a->version);
  	PKCS7_ENC_CONTENT_free(a->enc_data);
! 	Free((char *)a);
  	}
  
*** /var/spool/ftp/pub/Crypto/SSL/064/SSLeay-0.6.3/./crypto/asn1/p7_enc_c.c	Wed Aug  7 16:40:05 1996
--- ./crypto/asn1/p7_enc_c.c	Thu Aug 29 23:50:28 1996
***************
*** 111,116 ****
  	ASN1_OBJECT_free(a->content_type);
  	X509_ALGOR_free(a->algorithm);
  	ASN1_OCTET_STRING_free(a->enc_data);
! 	free(a);
  	}
  
--- 111,116 ----
  	ASN1_OBJECT_free(a->content_type);
  	X509_ALGOR_free(a->algorithm);
  	ASN1_OCTET_STRING_free(a->enc_data);
! 	Free((char *)a);
  	}
  
*** /var/spool/ftp/pub/Crypto/SSL/064/SSLeay-0.6.3/./crypto/asn1/p7_evp.c	Wed Aug  7 16:40:05 1996
--- ./crypto/asn1/p7_evp.c	Thu Aug 29 23:50:28 1996
***************
*** 109,114 ****
  	ASN1_INTEGER_free(a->version);
  	sk_pop_free(a->recipientinfo,PKCS7_RECIP_INFO_free);
  	PKCS7_ENC_CONTENT_free(a->enc_data);
! 	free(a);
  	}
  
--- 109,114 ----
  	ASN1_INTEGER_free(a->version);
  	sk_pop_free(a->recipientinfo,PKCS7_RECIP_INFO_free);
  	PKCS7_ENC_CONTENT_free(a->enc_data);
! 	Free((char *)a);
  	}
  
*** /var/spool/ftp/pub/Crypto/SSL/064/SSLeay-0.6.3/./crypto/asn1/p7_i_s.c	Wed Aug  7 16:40:05 1996
--- ./crypto/asn1/p7_i_s.c	Thu Aug 29 23:50:28 1996
***************
*** 104,109 ****
  	if (a == NULL) return;
  	X509_NAME_free(a->issuer);
  	ASN1_INTEGER_free(a->serial);
! 	free(a);
  	}
  
--- 104,109 ----
  	if (a == NULL) return;
  	X509_NAME_free(a->issuer);
  	ASN1_INTEGER_free(a->serial);
! 	Free((char *)a);
  	}
  
*** /var/spool/ftp/pub/Crypto/SSL/064/SSLeay-0.6.3/./crypto/asn1/p7_lib.c	Wed Aug  7 16:52:14 1996
--- ./crypto/asn1/p7_lib.c	Thu Aug 29 23:50:28 1996
***************
*** 150,156 ****
  		{
  		if ((*a)->asn1 != NULL)
  			{
! 			free((*a)->asn1);
  			(*a)->asn1=NULL;
  			}
  		(*a)->length=0;
--- 150,156 ----
  		{
  		if ((*a)->asn1 != NULL)
  			{
! 			Free((char *)(*a)->asn1);
  			(*a)->asn1=NULL;
  			}
  		(*a)->length=0;
***************
*** 233,239 ****
  	{
  	if (a == NULL) return;
  
! 	if (a->asn1 != NULL) free(a->asn1);
  
  	if (a->d.ptr != NULL)
  		{
--- 233,239 ----
  	{
  	if (a == NULL) return;
  
! 	if (a->asn1 != NULL) Free((char *)a->asn1);
  
  	if (a->d.ptr != NULL)
  		{
***************
*** 266,271 ****
  		}
  	if (a->type != NULL)
  		ASN1_OBJECT_free(a->type);
! 	free((char *)a);
  	}
  
--- 266,271 ----
  		}
  	if (a->type != NULL)
  		ASN1_OBJECT_free(a->type);
! 	Free((char *)(char *)a);
  	}
  
*** /var/spool/ftp/pub/Crypto/SSL/064/SSLeay-0.6.3/./crypto/asn1/p7_recip.c	Wed Aug  7 16:40:05 1996
--- ./crypto/asn1/p7_recip.c	Thu Aug 29 23:50:28 1996
***************
*** 114,119 ****
  	PKCS7_ISSUER_AND_SERIAL_free(a->issuer_and_serial);
  	X509_ALGOR_free(a->key_enc_algor);
  	ASN1_OCTET_STRING_free(a->enc_key);
! 	free(a);
  	}
  
--- 114,119 ----
  	PKCS7_ISSUER_AND_SERIAL_free(a->issuer_and_serial);
  	X509_ALGOR_free(a->key_enc_algor);
  	ASN1_OCTET_STRING_free(a->enc_key);
! 	Free((char *)a);
  	}
  
*** /var/spool/ftp/pub/Crypto/SSL/064/SSLeay-0.6.3/./crypto/asn1/p7_signd.c	Wed Aug  7 16:40:05 1996
--- ./crypto/asn1/p7_signd.c	Thu Aug 29 23:50:28 1996
***************
*** 124,129 ****
  	sk_pop_free(a->cert,X509_free);
  	sk_pop_free(a->crl,X509_CRL_free);
  	sk_pop_free(a->signer_info,PKCS7_SIGNER_INFO_free);
! 	free(a);
  	}
  
--- 124,129 ----
  	sk_pop_free(a->cert,X509_free);
  	sk_pop_free(a->crl,X509_CRL_free);
  	sk_pop_free(a->signer_info,PKCS7_SIGNER_INFO_free);
! 	Free((char *)a);
  	}
  
*** /var/spool/ftp/pub/Crypto/SSL/064/SSLeay-0.6.3/./crypto/asn1/p7_signi.c	Wed Aug  7 16:40:05 1996
--- ./crypto/asn1/p7_signi.c	Thu Aug 29 23:50:28 1996
***************
*** 130,135 ****
  	X509_ALGOR_free(a->digest_enc_alg);
  	ASN1_OCTET_STRING_free(a->enc_digest);
  	sk_pop_free(a->unauth_attr,X509_ATTRIBUTE_free);
! 	free(a);
  	}
  
--- 130,135 ----
  	X509_ALGOR_free(a->digest_enc_alg);
  	ASN1_OCTET_STRING_free(a->enc_digest);
  	sk_pop_free(a->unauth_attr,X509_ATTRIBUTE_free);
! 	Free((char *)a);
  	}
  
*** /var/spool/ftp/pub/Crypto/SSL/064/SSLeay-0.6.3/./crypto/asn1/p7_s_e.c	Wed Aug  7 16:40:05 1996
--- ./crypto/asn1/p7_s_e.c	Thu Aug 29 23:50:28 1996
***************
*** 130,135 ****
  	sk_pop_free(a->cert,X509_free);
  	sk_pop_free(a->crl,X509_CRL_free);
  	sk_pop_free(a->signer_info,PKCS7_SIGNER_INFO_free);
! 	free(a);
  	}
  
--- 130,135 ----
  	sk_pop_free(a->cert,X509_free);
  	sk_pop_free(a->crl,X509_CRL_free);
  	sk_pop_free(a->signer_info,PKCS7_SIGNER_INFO_free);
! 	Free((char *)a);
  	}
  
*** /var/spool/ftp/pub/Crypto/SSL/064/SSLeay-0.6.3/./crypto/asn1/pkcs8.c	Tue Jul 23 21:41:31 1996
--- ./crypto/asn1/pkcs8.c	Thu Aug 29 23:50:28 1996
***************
*** 112,121 ****
  
  	i=CRYPTO_add_lock(&a->references,-1,CRYPTO_LOCK_X509_KEY);
  	if (i > 0) return;
  
  	X509_CINF_free(a->cert_info);
  	X509_ALGOR_free(a->sig_alg);
  	ASN1_BIT_STRING_free(a->signature);
! 	free(a);
  	}
  
--- 112,128 ----
  
  	i=CRYPTO_add_lock(&a->references,-1,CRYPTO_LOCK_X509_KEY);
  	if (i > 0) return;
+ #ifdef REF_CHECK
+ 	if (i < 0)
+ 		{
+ 		fprintf(stderr,"X509_KEY_free, bad reference count\n");
+ 		abort();
+ 		}
+ #endif
  
  	X509_CINF_free(a->cert_info);
  	X509_ALGOR_free(a->sig_alg);
  	ASN1_BIT_STRING_free(a->signature);
! 	Free((char *)a);
  	}
  
*** /var/spool/ftp/pub/Crypto/SSL/064/SSLeay-0.6.3/./crypto/asn1/t_pkey.c	Wed Jul 17 16:45:38 1996
--- ./crypto/asn1/t_pkey.c	Thu Aug 29 23:50:28 1996
***************
*** 94,100 ****
  	int i,ret=0;
  
  	i=RSA_size(x);
! 	m=(unsigned char *)malloc((unsigned int)i+10);
  	if (m == NULL)
  		{
  		RSAerr(RSA_F_RSA_PRINT,ERR_R_MALLOC_FAILURE);
--- 94,100 ----
  	int i,ret=0;
  
  	i=RSA_size(x);
! 	m=(unsigned char *)Malloc((unsigned int)i+10);
  	if (m == NULL)
  		{
  		RSAerr(RSA_F_RSA_PRINT,ERR_R_MALLOC_FAILURE);
***************
*** 125,131 ****
  	if (!print(bp,"coefficient:",x->iqmp,m,off)) goto err;
  	ret=1;
  err:
! 	if (m != NULL) free(m);
  	return(ret);
  	}
  
--- 125,131 ----
  	if (!print(bp,"coefficient:",x->iqmp,m,off)) goto err;
  	ret=1;
  err:
! 	if (m != NULL) Free((char *)m);
  	return(ret);
  	}
  
***************
*** 140,146 ****
  
  	/* larger than needed but what the hell :-) */
  	i=BN_num_bytes(x->g)*2;
! 	m=(unsigned char *)malloc((unsigned int)i+10);
  	if (m == NULL)
  		{
  		DSAerr(DSA_F_DSA_PRINT,ERR_R_MALLOC_FAILURE);
--- 140,146 ----
  
  	/* larger than needed but what the hell :-) */
  	i=BN_num_bytes(x->g)*2;
! 	m=(unsigned char *)Malloc((unsigned int)i+10);
  	if (m == NULL)
  		{
  		DSAerr(DSA_F_DSA_PRINT,ERR_R_MALLOC_FAILURE);
***************
*** 165,171 ****
  	if (!print(bp,"G:",x->g,m,off)) goto err;
  	ret=1;
  err:
! 	if (m != NULL) free(m);
  	return(ret);
  	}
  
--- 165,171 ----
  	if (!print(bp,"G:",x->g,m,off)) goto err;
  	ret=1;
  err:
! 	if (m != NULL) Free((char *)m);
  	return(ret);
  	}
  
***************
*** 251,257 ****
  	int reason=ERR_R_BUF_LIB,i,ret=0;
  
  	i=BN_num_bytes(x->p);
! 	m=(unsigned char *)malloc((unsigned int)i+10);
  	if (m == NULL)
  		{
  		reason=ERR_R_MALLOC_FAILURE;
--- 251,257 ----
  	int reason=ERR_R_BUF_LIB,i,ret=0;
  
  	i=BN_num_bytes(x->p);
! 	m=(unsigned char *)Malloc((unsigned int)i+10);
  	if (m == NULL)
  		{
  		reason=ERR_R_MALLOC_FAILURE;
***************
*** 270,276 ****
  		}
  	ret=1;
  err:
! 	if (m != NULL) free(m);
  	DHerr(DH_F_DHPARAMS_PRINT,reason);
  	return(ret);
  	}
--- 270,276 ----
  		}
  	ret=1;
  err:
! 	if (m != NULL) Free((char *)m);
  	DHerr(DH_F_DHPARAMS_PRINT,reason);
  	return(ret);
  	}
*** /var/spool/ftp/pub/Crypto/SSL/064/SSLeay-0.6.3/./crypto/asn1/t_req.c	Wed Jul 17 16:45:38 1996
--- ./crypto/asn1/t_req.c	Thu Aug 29 23:50:28 1996
***************
*** 113,119 ****
  	i=ri->pubkey->public_key->length;
  	d2i_RSAPublicKey(&rsa,(unsigned char **)&s,(long)i);
  	i=RSA_size(rsa);
! 	m=s=(char *)malloc((unsigned int)i+10);
  	s[0]=0;
  	n=BN_bn2bin(rsa->n,(unsigned char *)&(s[1]));
  	if (s[1] & 0x80)
--- 113,119 ----
  	i=ri->pubkey->public_key->length;
  	d2i_RSAPublicKey(&rsa,(unsigned char **)&s,(long)i);
  	i=RSA_size(rsa);
! 	m=s=(char *)Malloc((unsigned int)i+10);
  	s[0]=0;
  	n=BN_bn2bin(rsa->n,(unsigned char *)&(s[1]));
  	if (s[1] & 0x80)
***************
*** 136,142 ****
  		sprintf(str,"%02x%s",(unsigned char)s[i],((i+1) == n)?"":":");
  		if (BIO_puts(bp,str) <= 0) goto err;
  		}
! 	free(m);
  	if (BIO_puts(bp,"\n") <= 0) goto err;
  	neg=(rsa->e->neg)?"-":"";
  	
--- 136,142 ----
  		sprintf(str,"%02x%s",(unsigned char)s[i],((i+1) == n)?"":":");
  		if (BIO_puts(bp,str) <= 0) goto err;
  		}
! 	Free((char *)m);
  	if (BIO_puts(bp,"\n") <= 0) goto err;
  	neg=(rsa->e->neg)?"-":"";
  	
*** /var/spool/ftp/pub/Crypto/SSL/064/SSLeay-0.6.3/./crypto/asn1/t_x509.c	Thu Aug  1 09:42:34 1996
--- ./crypto/asn1/t_x509.c	Thu Aug 29 23:50:28 1996
***************
*** 186,192 ****
  err:
  	if (rsa != NULL) RSA_free(rsa);
  	if (dsa != NULL) DSA_free(dsa);
! 	if (m != NULL) free(m);
  	return(ret);
  	}
  
--- 186,192 ----
  err:
  	if (rsa != NULL) RSA_free(rsa);
  	if (dsa != NULL) DSA_free(dsa);
! 	if (m != NULL) Free((char *)m);
  	return(ret);
  	}
  
***************
*** 284,290 ****
  err:
  		X509err(X509_F_X509_NAME_PRINT,ERR_R_BUF_LIB);
  		}
! 	if (m != NULL) free(m);
  	return(ret);
  	}
  
--- 284,290 ----
  err:
  		X509err(X509_F_X509_NAME_PRINT,ERR_R_BUF_LIB);
  		}
! 	if (m != NULL) Free((char *)m);
  	return(ret);
  	}
  
*** /var/spool/ftp/pub/Crypto/SSL/064/SSLeay-0.6.3/./crypto/asn1/x_algor.c	Wed Jul 17 16:45:39 1996
--- ./crypto/asn1/x_algor.c	Thu Aug 29 23:50:28 1996
***************
*** 106,111 ****
  	if (a == NULL) return;
  	ASN1_OBJECT_free(a->algorithm);
  	ASN1_TYPE_free(a->parameter);
! 	free(a);
  	}
  
--- 106,111 ----
  	if (a == NULL) return;
  	ASN1_OBJECT_free(a->algorithm);
  	ASN1_TYPE_free(a->parameter);
! 	Free((char *)a);
  	}
  
*** /var/spool/ftp/pub/Crypto/SSL/064/SSLeay-0.6.3/./crypto/asn1/x_attrib.c	Sat Jul 20 23:07:13 1996
--- ./crypto/asn1/x_attrib.c	Thu Aug 29 23:50:28 1996
***************
*** 138,143 ****
  		sk_pop_free(a->value.set,ASN1_TYPE_free);
  	else
  		ASN1_TYPE_free(a->value.single);
! 	free(a);
  	}
  
--- 138,143 ----
  		sk_pop_free(a->value.set,ASN1_TYPE_free);
  	else
  		ASN1_TYPE_free(a->value.single);
! 	Free((char *)a);
  	}
  
*** /var/spool/ftp/pub/Crypto/SSL/064/SSLeay-0.6.3/./crypto/asn1/x_cinf.c	Sun Jul 21 14:19:04 1996
--- ./crypto/asn1/x_cinf.c	Thu Aug 29 23:50:28 1996
***************
*** 181,186 ****
  	ASN1_BIT_STRING_free(a->issuerUID);
  	ASN1_BIT_STRING_free(a->subjectUID);
  	sk_pop_free(a->extensions,X509_EXTENSION_free);
! 	free(a);
  	}
  
--- 181,186 ----
  	ASN1_BIT_STRING_free(a->issuerUID);
  	ASN1_BIT_STRING_free(a->subjectUID);
  	sk_pop_free(a->extensions,X509_EXTENSION_free);
! 	Free((char *)a);
  	}
  
*** /var/spool/ftp/pub/Crypto/SSL/064/SSLeay-0.6.3/./crypto/asn1/x_crl.c	Tue Jul 23 21:41:17 1996
--- ./crypto/asn1/x_crl.c	Fri Aug 30 00:11:08 1996
***************
*** 75,85 ****
--- 75,87 ----
  
  	M_ASN1_I2D_len(a->serialNumber,i2d_ASN1_INTEGER);
  	M_ASN1_I2D_len(a->revocationDate,i2d_ASN1_UTCTIME);
+ 	M_ASN1_I2D_len_SEQ_opt(a->extensions,i2d_X509_EXTENSION);
  
  	M_ASN1_I2D_seq_total();
  
  	M_ASN1_I2D_put(a->serialNumber,i2d_ASN1_INTEGER);
  	M_ASN1_I2D_put(a->revocationDate,i2d_ASN1_UTCTIME);
+ 	M_ASN1_I2D_put_SEQ_opt(a->extensions,i2d_X509_EXTENSION);
  
  	M_ASN1_I2D_finish();
  	}
***************
*** 95,100 ****
--- 97,103 ----
  	M_ASN1_D2I_start_sequence();
  	M_ASN1_D2I_get(ret->serialNumber,d2i_ASN1_INTEGER);
  	M_ASN1_D2I_get(ret->revocationDate,d2i_ASN1_UTCTIME);
+ 	M_ASN1_D2I_get_seq_opt(ret->extensions,d2i_X509_EXTENSION);
  	M_ASN1_D2I_Finish(a,X509_REVOKED_free,ASN1_F_D2I_X509_REVOKED);
  	}
  
***************
*** 102,107 ****
--- 105,111 ----
  X509_CRL_INFO *a;
  unsigned char **pp;
  	{
+ 	int v1=0;
  	long l=0;
  	M_ASN1_I2D_vars(a);
  
***************
*** 117,123 ****
  	M_ASN1_I2D_len(a->lastUpdate,i2d_ASN1_UTCTIME);
  	M_ASN1_I2D_len(a->nextUpdate,i2d_ASN1_UTCTIME);
  	M_ASN1_I2D_len_SEQ_opt(a->revoked,i2d_X509_REVOKED);
! 	M_ASN1_I2D_len_IMP_set_opt(a->extensions,i2d_X509_EXTENSION,0);
  
  	M_ASN1_I2D_seq_total();
  
--- 121,128 ----
  	M_ASN1_I2D_len(a->lastUpdate,i2d_ASN1_UTCTIME);
  	M_ASN1_I2D_len(a->nextUpdate,i2d_ASN1_UTCTIME);
  	M_ASN1_I2D_len_SEQ_opt(a->revoked,i2d_X509_REVOKED);
! 	M_ASN1_I2D_len_EXP_set_opt(a->extensions,i2d_X509_EXTENSION,0,
! 		V_ASN1_SEQUENCE,v1);
  
  	M_ASN1_I2D_seq_total();
  
***************
*** 130,136 ****
  	M_ASN1_I2D_put(a->lastUpdate,i2d_ASN1_UTCTIME);
  	M_ASN1_I2D_put(a->nextUpdate,i2d_ASN1_UTCTIME);
  	M_ASN1_I2D_put_SEQ_opt(a->revoked,i2d_X509_REVOKED);
! 	M_ASN1_I2D_put_IMP_set_opt(a->extensions,i2d_X509_EXTENSION,0);
  
  	M_ASN1_I2D_finish();
  	}
--- 135,142 ----
  	M_ASN1_I2D_put(a->lastUpdate,i2d_ASN1_UTCTIME);
  	M_ASN1_I2D_put(a->nextUpdate,i2d_ASN1_UTCTIME);
  	M_ASN1_I2D_put_SEQ_opt(a->revoked,i2d_X509_REVOKED);
! 	M_ASN1_I2D_put_EXP_set_opt(a->extensions,i2d_X509_EXTENSION,0,
! 		V_ASN1_SEQUENCE,v1);
  
  	M_ASN1_I2D_finish();
  	}
***************
*** 179,189 ****
  		if (ret->extensions != NULL)
  			{
  			while (sk_num(ret->extensions))
! 				X509_REVOKED_free((X509_REVOKED *)
  				sk_pop(ret->extensions));
  			}
  			
! 		M_ASN1_D2I_get_IMP_set_opt(ret->extensions,d2i_X509_EXTENSION,0);
  		}
  
  	M_ASN1_D2I_Finish(a,X509_CRL_INFO_free,ASN1_F_D2I_X509_CRL_INFO);
--- 185,196 ----
  		if (ret->extensions != NULL)
  			{
  			while (sk_num(ret->extensions))
! 				X509_EXTENSION_free((X509_EXTENSION *)
  				sk_pop(ret->extensions));
  			}
  			
! 		M_ASN1_D2I_get_set_EXP_opt(ret->extensions,d2i_X509_EXTENSION,
! 			0,V_ASN1_SEQUENCE);
  		}
  
  	M_ASN1_D2I_Finish(a,X509_CRL_INFO_free,ASN1_F_D2I_X509_CRL_INFO);
***************
*** 232,237 ****
--- 239,245 ----
  	M_ASN1_New_Malloc(ret,X509_REVOKED);
  	M_ASN1_New(ret->serialNumber,ASN1_INTEGER_new);
  	M_ASN1_New(ret->revocationDate,ASN1_UTCTIME_new);
+ 	ret->extensions=NULL;
  	return(ret);
  	M_ASN1_New_Error(ASN1_F_X509_REVOKED_NEW);
  	}
***************
*** 272,278 ****
  	if (a == NULL) return;
  	ASN1_INTEGER_free(a->serialNumber);
  	ASN1_UTCTIME_free(a->revocationDate);
! 	free(a);
  	}
  
  void X509_CRL_INFO_free(a)
--- 280,287 ----
  	if (a == NULL) return;
  	ASN1_INTEGER_free(a->serialNumber);
  	ASN1_UTCTIME_free(a->revocationDate);
! 	sk_pop_free(a->extensions,X509_EXTENSION_free);
! 	Free((char *)a);
  	}
  
  void X509_CRL_INFO_free(a)
***************
*** 286,292 ****
  	ASN1_UTCTIME_free(a->nextUpdate);
  	sk_pop_free(a->revoked,X509_REVOKED_free);
  	sk_pop_free(a->extensions,X509_EXTENSION_free);
! 	free(a);
  	}
  
  void X509_CRL_free(a)
--- 295,301 ----
  	ASN1_UTCTIME_free(a->nextUpdate);
  	sk_pop_free(a->revoked,X509_REVOKED_free);
  	sk_pop_free(a->extensions,X509_EXTENSION_free);
! 	Free((char *)a);
  	}
  
  void X509_CRL_free(a)
***************
*** 298,308 ****
  
  	i=CRYPTO_add(&a->references,-1,CRYPTO_LOCK_X509_CRL);
  	if (i > 0) return;
  
  	X509_CRL_INFO_free(a->crl);
  	X509_ALGOR_free(a->sig_alg);
  	ASN1_BIT_STRING_free(a->signature);
! 	free(a);
  	}
  
  static int X509_REVOKED_cmp(a,b)
--- 307,324 ----
  
  	i=CRYPTO_add(&a->references,-1,CRYPTO_LOCK_X509_CRL);
  	if (i > 0) return;
+ #ifdef REF_CHECK
+ 	if (i < 0)
+ 		{
+ 		fprintf(stderr,"X509_CRL_free, bad reference count\n");
+ 		abort();
+ 		}
+ #endif
  
  	X509_CRL_INFO_free(a->crl);
  	X509_ALGOR_free(a->sig_alg);
  	ASN1_BIT_STRING_free(a->signature);
! 	Free((char *)a);
  	}
  
  static int X509_REVOKED_cmp(a,b)
*** /var/spool/ftp/pub/Crypto/SSL/064/SSLeay-0.6.3/./crypto/asn1/x_exten.c	Sat Jul 20 23:43:38 1996
--- ./crypto/asn1/x_exten.c	Thu Aug 29 23:50:28 1996
***************
*** 126,131 ****
  	if (a == NULL) return;
  	ASN1_OBJECT_free(a->object);
  	ASN1_OCTET_STRING_free(a->value);
! 	free(a);
  	}
  
--- 126,131 ----
  	if (a == NULL) return;
  	ASN1_OBJECT_free(a->object);
  	ASN1_OCTET_STRING_free(a->value);
! 	Free((char *)a);
  	}
  
*** /var/spool/ftp/pub/Crypto/SSL/064/SSLeay-0.6.3/./crypto/asn1/x_info.c	Tue Jul 23 21:42:08 1996
--- ./crypto/asn1/x_info.c	Thu Aug 29 23:50:28 1996
***************
*** 56,62 ****
  	{
  	X509_INFO *ret=NULL;
  
! 	ret=(X509_INFO *)malloc(sizeof(X509_INFO));
  	if (ret == NULL)
  		{
  		ASN1err(ASN1_F_X509_INFO_NEW,ERR_R_MALLOC_FAILURE);
--- 56,62 ----
  	{
  	X509_INFO *ret=NULL;
  
! 	ret=(X509_INFO *)Malloc(sizeof(X509_INFO));
  	if (ret == NULL)
  		{
  		ASN1err(ASN1_F_X509_INFO_NEW,ERR_R_MALLOC_FAILURE);
***************
*** 78,86 ****
  
  	i=CRYPTO_add(&x->references,-1,CRYPTO_LOCK_X509_INFO);
  	if (i > 0) return;
  
  	if (x->x509 != NULL) X509_free(x->x509);
  	if (x->crl != NULL) X509_CRL_free(x->crl);
  	if (x->x_pkey != NULL) X509_PKEY_free(x->x_pkey);
! 	free((char *)x);
  	}
--- 78,93 ----
  
  	i=CRYPTO_add(&x->references,-1,CRYPTO_LOCK_X509_INFO);
  	if (i > 0) return;
+ #ifdef REF_CHECK
+ 	if (i < 0)
+ 		{
+ 		fprintf(stderr,"X509_INFO_free, bad reference count\n");
+ 		abort();
+ 		}
+ #endif
  
  	if (x->x509 != NULL) X509_free(x->x509);
  	if (x->crl != NULL) X509_CRL_free(x->crl);
  	if (x->x_pkey != NULL) X509_PKEY_free(x->x_pkey);
! 	Free((char *)x);
  	}
*** /var/spool/ftp/pub/Crypto/SSL/064/SSLeay-0.6.3/./crypto/asn1/x_name.c	Wed Jul 17 22:45:13 1996
--- ./crypto/asn1/x_name.c	Thu Aug 29 23:50:28 1996
***************
*** 207,212 ****
  	if (a == NULL) return;
  	ASN1_OBJECT_free(a->object);
  	ASN1_BIT_STRING_free(a->value);
! 	free(a);
  	}
  
--- 207,212 ----
  	if (a == NULL) return;
  	ASN1_OBJECT_free(a->object);
  	ASN1_BIT_STRING_free(a->value);
! 	Free((char *)a);
  	}
  
*** /var/spool/ftp/pub/Crypto/SSL/064/SSLeay-0.6.3/./crypto/asn1/x_pkey.c	Tue Jul 23 22:08:18 1996
--- ./crypto/asn1/x_pkey.c	Thu Aug 29 23:50:28 1996
***************
*** 126,135 ****
  
  	i=CRYPTO_add(&x->references,-1,CRYPTO_LOCK_X509_PKEY);
  	if (i > 0) return;
  
  	if (x->enc_algor != NULL) X509_ALGOR_free(x->enc_algor);
  	if (x->enc_pkey != NULL) ASN1_OCTET_STRING_free(x->enc_pkey);
  	if (x->dec_pkey != NULL)EVP_PKEY_free(x->dec_pkey);
! 	if ((x->key_data != NULL) && (x->key_free)) free(x->key_data);
! 	free((char *)x);
  	}
--- 126,142 ----
  
  	i=CRYPTO_add(&x->references,-1,CRYPTO_LOCK_X509_PKEY);
  	if (i > 0) return;
+ #ifdef REF_CHECK
+ 	if (i < 0)
+ 		{
+ 		fprintf(stderr,"X509_PKEY_free, bad reference count\n");
+ 		abort();
+ 		}
+ #endif
  
  	if (x->enc_algor != NULL) X509_ALGOR_free(x->enc_algor);
  	if (x->enc_pkey != NULL) ASN1_OCTET_STRING_free(x->enc_pkey);
  	if (x->dec_pkey != NULL)EVP_PKEY_free(x->dec_pkey);
! 	if ((x->key_data != NULL) && (x->key_free)) Free((char *)x->key_data);
! 	Free((char *)(char *)x);
  	}
*** /var/spool/ftp/pub/Crypto/SSL/064/SSLeay-0.6.3/./crypto/asn1/x_pubkey.c	Wed Jul 17 16:45:39 1996
--- ./crypto/asn1/x_pubkey.c	Thu Aug 29 23:50:28 1996
***************
*** 102,108 ****
  	if (a == NULL) return;
  	X509_ALGOR_free(a->algor);
  	ASN1_BIT_STRING_free(a->public_key);
! 	free(a);
  	}
  
  
--- 102,108 ----
  	if (a == NULL) return;
  	X509_ALGOR_free(a->algor);
  	ASN1_BIT_STRING_free(a->public_key);
! 	Free((char *)a);
  	}
  
  
*** /var/spool/ftp/pub/Crypto/SSL/064/SSLeay-0.6.3/./crypto/asn1/x_req.c	Tue Jul 23 21:43:08 1996
--- ./crypto/asn1/x_req.c	Thu Aug 29 23:50:28 1996
***************
*** 158,164 ****
  	X509_NAME_free(a->subject);
  	X509_PUBKEY_free(a->pubkey);
  	sk_pop_free(a->attributes,X509_ATTRIBUTE_free);
! 	free(a);
  	}
  
  int i2d_X509_REQ(a,pp)
--- 158,164 ----
  	X509_NAME_free(a->subject);
  	X509_PUBKEY_free(a->pubkey);
  	sk_pop_free(a->attributes,X509_ATTRIBUTE_free);
! 	Free((char *)a);
  	}
  
  int i2d_X509_REQ(a,pp)
***************
*** 216,226 ****
  
  	i=CRYPTO_add(&a->references,-1,CRYPTO_LOCK_X509_REQ);
  	if (i > 0) return;
  
  	X509_REQ_INFO_free(a->req_info);
  	X509_ALGOR_free(a->sig_alg);
  	ASN1_BIT_STRING_free(a->signature);
! 	free(a);
  	}
  
  
--- 216,233 ----
  
  	i=CRYPTO_add(&a->references,-1,CRYPTO_LOCK_X509_REQ);
  	if (i > 0) return;
+ #ifdef REF_CHECK
+ 	if (i < 0)
+ 		{
+ 		fprintf(stderr,"X509_REQ_free, bad reference count\n");
+ 		abort();
+ 		}
+ #endif
  
  	X509_REQ_INFO_free(a->req_info);
  	X509_ALGOR_free(a->sig_alg);
  	ASN1_BIT_STRING_free(a->signature);
! 	Free((char *)a);
  	}
  
  
*** /var/spool/ftp/pub/Crypto/SSL/064/SSLeay-0.6.3/./crypto/asn1/x_sig.c	Wed Jul 17 16:45:39 1996
--- ./crypto/asn1/x_sig.c	Thu Aug 29 23:50:28 1996
***************
*** 102,108 ****
  	if (a == NULL) return;
  	X509_ALGOR_free(a->algor);
  	ASN1_OCTET_STRING_free(a->digest);
! 	free(a);
  	}
  
  
--- 102,108 ----
  	if (a == NULL) return;
  	X509_ALGOR_free(a->algor);
  	ASN1_OCTET_STRING_free(a->digest);
! 	Free((char *)a);
  	}
  
  
*** /var/spool/ftp/pub/Crypto/SSL/064/SSLeay-0.6.3/./crypto/asn1/x_spki.c	Wed Jul 17 16:45:39 1996
--- ./crypto/asn1/x_spki.c	Thu Aug 29 23:50:28 1996
***************
*** 109,115 ****
  	if (a == NULL) return;
  	X509_PUBKEY_free(a->pubkey);
  	ASN1_IA5STRING_free(a->challenge);
! 	free(a);
  	}
  
  int i2d_NETSCAPE_SPKI(a,pp)
--- 109,115 ----
  	if (a == NULL) return;
  	X509_PUBKEY_free(a->pubkey);
  	ASN1_IA5STRING_free(a->challenge);
! 	Free((char *)a);
  	}
  
  int i2d_NETSCAPE_SPKI(a,pp)
***************
*** 165,170 ****
  	NETSCAPE_SPKAC_free(a->spkac);
  	X509_ALGOR_free(a->sig_algor);
  	ASN1_BIT_STRING_free(a->signature);
! 	free(a);
  	}
  
--- 165,170 ----
  	NETSCAPE_SPKAC_free(a->spkac);
  	X509_ALGOR_free(a->sig_algor);
  	ASN1_BIT_STRING_free(a->signature);
! 	Free((char *)a);
  	}
  
*** /var/spool/ftp/pub/Crypto/SSL/064/SSLeay-0.6.3/./crypto/asn1/x_val.c	Wed Jul 17 16:45:40 1996
--- ./crypto/asn1/x_val.c	Thu Aug 29 23:50:28 1996
***************
*** 102,107 ****
  	if (a == NULL) return;
  	ASN1_UTCTIME_free(a->notBefore);
  	ASN1_UTCTIME_free(a->notAfter);
! 	free(a);
  	}
  
--- 102,107 ----
  	if (a == NULL) return;
  	ASN1_UTCTIME_free(a->notBefore);
  	ASN1_UTCTIME_free(a->notAfter);
! 	Free((char *)a);
  	}
  
*** /var/spool/ftp/pub/Crypto/SSL/064/SSLeay-0.6.3/./crypto/asn1/x_x509.c	Tue Jul 23 21:43:34 1996
--- ./crypto/asn1/x_x509.c	Thu Aug 29 23:50:28 1996
***************
*** 121,130 ****
  
  	i=CRYPTO_add(&a->references,-1,CRYPTO_LOCK_X509);
  	if (i > 0) return;
  
  	X509_CINF_free(a->cert_info);
  	X509_ALGOR_free(a->sig_alg);
  	ASN1_BIT_STRING_free(a->signature);
! 	free(a);
  	}
  
--- 121,137 ----
  
  	i=CRYPTO_add(&a->references,-1,CRYPTO_LOCK_X509);
  	if (i > 0) return;
+ #ifdef REF_CHECK
+ 	if (i < 0)
+ 		{
+ 		fprintf(stderr,"X509_free, bad reference count\n");
+ 		abort();
+ 		}
+ #endif
  
  	X509_CINF_free(a->cert_info);
  	X509_ALGOR_free(a->sig_alg);
  	ASN1_BIT_STRING_free(a->signature);
! 	Free((char *)a);
  	}
  
*** /var/spool/ftp/pub/Crypto/SSL/064/SSLeay-0.6.3/./crypto/bn/bn_knuth.c	Wed Jul 17 16:45:40 1996
--- ./crypto/bn/bn_knuth.c	Thu Aug 29 23:50:29 1996
***************
*** 78,84 ****
  #define DONE	11
  
  int new_total=0;
! int free_total=0;
  int max=0,max_total=0;
  
  BIGNUM *LBN_new(void );
--- 78,84 ----
  #define DONE	11
  
  int new_total=0;
! int Free_total=0;
  int max=0,max_total=0;
  
  BIGNUM *LBN_new(void );
***************
*** 366,372 ****
  BN_print(stdout,b); printf(" =\n");
  BN_print(stdout,r); printf("\n");
  
! printf("BN_new() =%d\nBN_free()=%d max=%d\n",new_total,free_total,max);
  
  
  	exit(0);
--- 366,372 ----
  BN_print(stdout,b); printf(" =\n");
  BN_print(stdout,r); printf("\n");
  
! printf("BN_new() =%d\nBN_free()=%d max=%d\n",new_total,Free_total,max);
  
  
  	exit(0);
***************
*** 418,423 ****
  	{
  	max_total--;
  	if (max_total > max) max=max_total;
! 	free_total++;
  	BN_free(a);
  	}
--- 418,423 ----
  	{
  	max_total--;
  	if (max_total > max) max=max_total;
! 	Free_total++;
  	BN_free(a);
  	}
*** /var/spool/ftp/pub/Crypto/SSL/064/SSLeay-0.6.3/./crypto/bn/bn_lib.c	Tue Aug  6 15:57:42 1996
--- ./crypto/bn/bn_lib.c	Fri Aug 30 00:58:28 1996
***************
*** 49,55 ****
  #include "cryptlib.h"
  #include "bn.h"
  
! char *BN_version="Big Number part of SSLeay 0.6.3 06-Aug-1996";
  
  static BN_ULONG data_one=1L;
  static BIGNUM const_one={&data_one,1,1,0};
--- 49,55 ----
  #include "cryptlib.h"
  #include "bn.h"
  
! char *BN_version="Big Number part of SSLeay 0.6.4 30-Aug-1996";
  
  static BN_ULONG data_one=1L;
  static BIGNUM const_one={&data_one,1,1,0};
***************
*** 165,174 ****
  	if (a->d != NULL)
  		{
  		memset(a->d,0,a->max*sizeof(a->d[0]));
! 		free(a->d);
  		}
  	memset(a,0,sizeof(BIGNUM));
! 	free(a);
  	}
  
  void BN_free(a)
--- 165,174 ----
  	if (a->d != NULL)
  		{
  		memset(a->d,0,a->max*sizeof(a->d[0]));
! 		Free(a->d);
  		}
  	memset(a,0,sizeof(BIGNUM));
! 	Free(a);
  	}
  
  void BN_free(a)
***************
*** 175,182 ****
  BIGNUM *a;
  	{
  	if (a == NULL) return;
! 	if (a->d != NULL) free(a->d);
! 	free(a);
  	}
  
  BIGNUM *BN_new()
--- 175,182 ----
  BIGNUM *a;
  	{
  	if (a == NULL) return;
! 	if (a->d != NULL) Free(a->d);
! 	Free(a);
  	}
  
  BIGNUM *BN_new()
***************
*** 184,195 ****
  	BIGNUM *ret;
  	BN_ULONG *p;
  
! 	ret=(BIGNUM *)malloc(sizeof(BIGNUM));
  	if (ret == NULL) goto err;
  	ret->top=0;
  	ret->neg=0;
  	ret->max=(BN_DEFAULT_BITS/BN_BITS2);
! 	p=(BN_ULONG *)malloc(sizeof(BN_ULONG)*(ret->max+1));
  	if (p == NULL) goto err;
  	ret->d=p;
  
--- 184,195 ----
  	BIGNUM *ret;
  	BN_ULONG *p;
  
! 	ret=(BIGNUM *)Malloc(sizeof(BIGNUM));
  	if (ret == NULL) goto err;
  	ret->top=0;
  	ret->neg=0;
  	ret->max=(BN_DEFAULT_BITS/BN_BITS2);
! 	p=(BN_ULONG *)Malloc(sizeof(BN_ULONG)*(ret->max+1));
  	if (p == NULL) goto err;
  	ret->d=p;
  
***************
*** 206,212 ****
  	BIGNUM *n;
  	int i,j;
  
! 	ret=(BN_CTX *)malloc(sizeof(BN_CTX));
  	if (ret == NULL) goto err2;
  
  	for (i=0; i<BN_CTX_NUM; i++)
--- 206,212 ----
  	BIGNUM *n;
  	int i,j;
  
! 	ret=(BN_CTX *)Malloc(sizeof(BN_CTX));
  	if (ret == NULL) goto err2;
  
  	for (i=0; i<BN_CTX_NUM; i++)
***************
*** 221,227 ****
  err:
  	for (j=0; j<i; j++)
  		BN_free(ret->bn[j]);
! 	free(ret);
  err2:
  	BNerr(BN_F_BN_CTX_NEW,ERR_R_MALLOC_FAILURE);
  	return(NULL);
--- 221,227 ----
  err:
  	for (j=0; j<i; j++)
  		BN_free(ret->bn[j]);
! 	Free(ret);
  err2:
  	BNerr(BN_F_BN_CTX_NEW,ERR_R_MALLOC_FAILURE);
  	return(NULL);
***************
*** 234,240 ****
  
  	for (i=0; i<BN_CTX_NUM; i++)
  		BN_clear_free(c->bn[i]);
! 	free(c);
  	}
  
  BIGNUM *bn_expand2(b, bits)
--- 234,240 ----
  
  	for (i=0; i<BN_CTX_NUM; i++)
  		BN_clear_free(c->bn[i]);
! 	Free(c);
  	}
  
  BIGNUM *bn_expand2(b, bits)
***************
*** 247,253 ****
  	while (bits > b->max*BN_BITS2)
  		{
  		n=((bits+BN_BITS2-1)/BN_BITS2)*2;
! 		p=b->d=(BN_ULONG *)realloc(b->d,sizeof(BN_ULONG)*(n+1));
  		if (p == NULL)
  			{
  			BNerr(BN_F_BN_EXPAND2,ERR_R_MALLOC_FAILURE);
--- 247,253 ----
  	while (bits > b->max*BN_BITS2)
  		{
  		n=((bits+BN_BITS2-1)/BN_BITS2)*2;
! 		p=b->d=(BN_ULONG *)Realloc(b->d,sizeof(BN_ULONG)*(n+1));
  		if (p == NULL)
  			{
  			BNerr(BN_F_BN_EXPAND2,ERR_R_MALLOC_FAILURE);
*** /var/spool/ftp/pub/Crypto/SSL/064/SSLeay-0.6.3/./crypto/bn/bn_mont.c	Wed Jul 17 16:45:41 1996
--- ./crypto/bn/bn_mont.c	Thu Aug 29 23:50:29 1996
***************
*** 93,99 ****
  	if (!BN_copy(r,a)) goto err;
  	n=mont->N;
  
! 	if (!BN_copy(t1,r)) goto err;
  	BN_mask_bits(t1,mont->ri);
  
  	a=t1;
--- 93,99 ----
  	if (!BN_copy(r,a)) goto err;
  	n=mont->N;
  
! 	if (!BN_copy(t1,a)) goto err;
  	BN_mask_bits(t1,mont->ri);
  
  	a=t1;
***************
*** 102,108 ****
  	nl=n->top;
  	if ((al == 0) || (nl == 0)) { r->top=0; return(1); }
  
! 	max=(nl+al+1); /* allow for overflow */
  	if (bn_expand(r,(max)*BN_BITS2) == NULL) goto err;
  
  	r->neg=a->neg^n->neg;
--- 102,108 ----
  	nl=n->top;
  	if ((al == 0) || (nl == 0)) { r->top=0; return(1); }
  
! 	max=(nl+al+1); /* allow for overflow (no?) XXX */
  	if (bn_expand(r,(max)*BN_BITS2) == NULL) goto err;
  
  	r->neg=a->neg^n->neg;
***************
*** 111,118 ****
  	rp=r->d;
  
  	/* clear the top bytes of T */
! 	for (i=r->top; i<max; i++)
  		r->d[i]=0;
  
  	r->top=max;
  	n0=mont->n0;
--- 111,119 ----
  	rp=r->d;
  
  	/* clear the top bytes of T */
! 	for (i=r->top; i<max; i++) /* memset? XXX */
  		r->d[i]=0;
+ /*	memset(&(r->d[r->top]),0,(max-r->top)*sizeof(BN_ULONG)); */
  
  	r->top=max;
  	n0=mont->n0;
***************
*** 122,134 ****
  		/* This is were part words probably goes wrong */
  		k=(rp[0]*n0)&BN_MASK2;
  		v=bn_mul_add_word(rp,np,nl,k);
! 		if (v)
  			for (x=nl; v; x++)
  				{
  				v2=rp[x];
  				v2+=v;
  				rp[x]=v2;
! 				v=(v2 < v)?1:0;
  				}
  		rp++;
  		}
--- 123,135 ----
  		/* This is were part words probably goes wrong */
  		k=(rp[0]*n0)&BN_MASK2;
  		v=bn_mul_add_word(rp,np,nl,k);
! 		
  		for (x=nl; v; x++)
  			{
  			v2=rp[x];
  			v2+=v;
  			rp[x]=v2;
! 			v=(v2 < v)?1:0;	/* ever true? XXX */
  			}
  		rp++;
  		}
***************
*** 135,144 ****
  	while (r->d[r->top-1] == 0)
  		r->top--;
  
  	BN_rshift(ret,r,mont->ri);
  
  	if (BN_ucmp(ret,mont->N) >= 0)
! 		bn_qsub(ret,ret,mont->N);
  	retn=1;
  err:
  	return(retn);
--- 136,149 ----
  	while (r->d[r->top-1] == 0)
  		r->top--;
  
+ /* fprintf(stderr,"top=%d new=%d\n",max,r->top); */
  	BN_rshift(ret,r,mont->ri);
  
  	if (BN_ucmp(ret,mont->N) >= 0)
! 		{
! /*		BN_sub(ret,ret,mont->N);   */
! 		bn_qsub(ret,ret,mont->N); /* XXX */
! 		}
  	retn=1;
  err:
  	return(retn);
***************
*** 179,190 ****
  	{
  	BN_MONT_CTX *ret;
  
! 	if ((ret=(BN_MONT_CTX *)malloc(sizeof(BN_MONT_CTX))) == NULL)
  		return(NULL);
  	ret->ri=0;
  	ret->RR=BN_new();
  	ret->N=BN_new();
  	ret->Ni=NULL;
  	return(ret);
  	}
  
--- 184,200 ----
  	{
  	BN_MONT_CTX *ret;
  
! 	if ((ret=(BN_MONT_CTX *)Malloc(sizeof(BN_MONT_CTX))) == NULL)
  		return(NULL);
  	ret->ri=0;
  	ret->RR=BN_new();
  	ret->N=BN_new();
  	ret->Ni=NULL;
+ 	if ((ret->RR == NULL) || (ret->N == NULL))
+ 		{
+ 		BN_MONT_CTX_free(ret);
+ 		return(NULL);
+ 		}
  	return(ret);
  	}
  
***************
*** 194,200 ****
  	if (mont->RR != NULL) BN_free(mont->RR);
  	if (mont->N != NULL) BN_free(mont->N);
  	if (mont->Ni != NULL) BN_free(mont->Ni);
! 	free(mont);
  	}
  
  int BN_MONT_CTX_set(mont,mod,ctx)
--- 204,210 ----
  	if (mont->RR != NULL) BN_free(mont->RR);
  	if (mont->N != NULL) BN_free(mont->N);
  	if (mont->Ni != NULL) BN_free(mont->Ni);
! 	Free(mont);
  	}
  
  int BN_MONT_CTX_set(mont,mod,ctx)
***************
*** 213,230 ****
  
  #ifdef MONT_WORD
  {
! 	int z;
  
  	BN_lshift(R,BN_value_one,BN_BITS2);		/* R */
! 	z=mod->top;
! 	mod->top=1;
! 	Ri=BN_mod_inverse(R,mod,ctx);			/* Ri */
  	BN_lshift(Ri,Ri,BN_BITS2);			/* R*Ri */
  	bn_qsub(Ri,Ri,BN_value_one);			/* R*Ri - 1 */
! 	BN_div(Ri,NULL,Ri,mod,ctx);
  	mont->n0=Ri->d[0];
  	BN_free(Ri);
! 	mod->top=z;
  }
  #else
  	BN_lshift(R,BN_value_one,mont->ri);		/* R */
--- 223,248 ----
  
  #ifdef MONT_WORD
  {
! 	BIGNUM tmod;
! 	/* int z; */
  
  	BN_lshift(R,BN_value_one,BN_BITS2);		/* R */
! 	/* I was bad, this modification of a passed variable was
! 	 * breaking the multithreaded stuff :-(
! 	 * z=mod->top;
! 	 * mod->top=1; */
! 	tmod.d=mod->d;
! 	tmod.top=1;
! 	tmod.max=mod->max;
! 	tmod.neg=mod->neg;
! 
! 	Ri=BN_mod_inverse(R,&tmod,ctx);			/* Ri */
  	BN_lshift(Ri,Ri,BN_BITS2);			/* R*Ri */
  	bn_qsub(Ri,Ri,BN_value_one);			/* R*Ri - 1 */
! 	BN_div(Ri,NULL,Ri,&tmod,ctx);
  	mont->n0=Ri->d[0];
  	BN_free(Ri);
! 	/* mod->top=z; */
  }
  #else
  	BN_lshift(R,BN_value_one,mont->ri);		/* R */
*** /var/spool/ftp/pub/Crypto/SSL/064/SSLeay-0.6.3/./crypto/bn/bn_print.c	Wed Jul 17 16:45:41 1996
--- ./crypto/bn/bn_print.c	Thu Aug 29 23:50:29 1996
***************
*** 53,59 ****
  
  static char *Hex="0123456789ABCDEF";
  
! /* Must 'free' the returned data */
  char *BN_bn2ascii(a)
  BIGNUM *a;
  	{
--- 53,59 ----
  
  static char *Hex="0123456789ABCDEF";
  
! /* Must 'Free' the returned data */
  char *BN_bn2ascii(a)
  BIGNUM *a;
  	{
***************
*** 61,67 ****
  	char *buf;
  	char *p;
  
! 	buf=(char *)malloc(a->top*BN_BYTES*2+2);
  	if (buf == NULL)
  		{
  		BNerr(BN_F_BN_BN2ASCII,ERR_R_MALLOC_FAILURE);
--- 61,67 ----
  	char *buf;
  	char *p;
  
! 	buf=(char *)Malloc(a->top*BN_BYTES*2+2);
  	if (buf == NULL)
  		{
  		BNerr(BN_F_BN_BN2ASCII,ERR_R_MALLOC_FAILURE);
***************
*** 95,101 ****
  	{
  	BIGNUM *ret=NULL;
  	BN_ULONG l=0;
! 	int neg=0,m,h,i,j,k;
  	int num;
  
  	if ((a == NULL) || (*a == '\0')) return(0);
--- 95,101 ----
  	{
  	BIGNUM *ret=NULL;
  	BN_ULONG l=0;
! 	int neg=0,h,m,i,j,k,c;
  	int num;
  
  	if ((a == NULL) || (*a == '\0')) return(0);
***************
*** 123,145 ****
  	if (bn_expand(ret,i*4) == NULL) goto err;
  
  	j=i; /* least significate 'hex' */
! 	m=BN_BYTES*2;
  	h=0;
! 	while (j-- > 0)
  		{
! 		if ((a[j] >= '0') && (a[j] <= '9')) k=a[j]-'0';
! 		else if ((a[j] >= 'a') && (a[j] <= 'f')) k=a[j]-'a'+10;
! 		else if ((a[j] >= 'A') && (a[j] <= 'F')) k=a[j]-'A'+10;
  		else k=0; /* paranoia */
  		l=(l<<4)|k;
  
! 		if (m-- == 0)
  			{
  			ret->d[h++]=l;
! 			l=0;
! 			m=BN_BYTES*2;
  			}
  		}
  	bn_fix_top(ret);
  	ret->neg=neg;
  
--- 123,152 ----
  	if (bn_expand(ret,i*4) == NULL) goto err;
  
  	j=i; /* least significate 'hex' */
! 	m=0;
  	h=0;
! 	while (j > 0)
  		{
! 		m=((BN_BYTES*2) <= j)?(BN_BYTES*2):j;
! 		l=0;
! 		for (;;)
! 			{
! 			c=a[j-m];
! 			if ((c >= '0') && (c <= '9')) k=c-'0';
! 			else if ((c >= 'a') && (c <= 'f')) k=c-'a'+10;
! 			else if ((c >= 'A') && (c <= 'F')) k=c-'A'+10;
  			else k=0; /* paranoia */
  			l=(l<<4)|k;
  
! 			if (--m <= 0)
  				{
  				ret->d[h++]=l;
! 				break;
  				}
  			}
+ 		j-=(BN_BYTES*2);
+ 		}
+ 	ret->top=h;
  	bn_fix_top(ret);
  	ret->neg=neg;
  
*** /var/spool/ftp/pub/Crypto/SSL/064/SSLeay-0.6.3/./crypto/bn/bn_rand.c	Wed Jul 17 16:45:41 1996
--- ./crypto/bn/bn_rand.c	Thu Aug 29 23:50:29 1996
***************
*** 65,71 ****
  	bit=(bits-1)%8;
  	mask=0xff<<bit;
  
! 	buf=(unsigned char *)malloc(bytes);
  	if (buf == NULL)
  		{
  		BNerr(BN_F_BN_RAND,ERR_R_MALLOC_FAILURE);
--- 65,71 ----
  	bit=(bits-1)%8;
  	mask=0xff<<bit;
  
! 	buf=(unsigned char *)Malloc(bytes);
  	if (buf == NULL)
  		{
  		BNerr(BN_F_BN_RAND,ERR_R_MALLOC_FAILURE);
***************
*** 103,109 ****
  	if (buf != NULL)
  		{
  		memset(buf,0,bytes);
! 		free(buf);
  		}
  	return(ret);
  	}
--- 103,109 ----
  	if (buf != NULL)
  		{
  		memset(buf,0,bytes);
! 		Free(buf);
  		}
  	return(ret);
  	}
*** /var/spool/ftp/pub/Crypto/SSL/064/SSLeay-0.6.3/./crypto/bn/Makefile.ssl	Thu Aug  8 01:54:23 1996
--- ./crypto/bn/Makefile.ssl	Fri Aug 30 04:40:54 1996
***************
*** 92,98 ****
  	mv -f Makefile.new $(MAKEFILE)
  
  clean:
! 	/bin/rm -f *.o */*.o *.obj lib tags core .nfs* *.old *.bak fluff bn_mulw.s
  
  errors:
  	perl $(TOP)/util/err-ins.pl $(ERR).err $(ERR).org # special case .org
--- 92,98 ----
  	mv -f Makefile.new $(MAKEFILE)
  
  clean:
! 	/bin/rm -f *.o */*.o *.obj lib tags core .pure .nfs* *.old *.bak fluff bn_mulw.s
  
  errors:
  	perl $(TOP)/util/err-ins.pl $(ERR).err $(ERR).org # special case .org
*** /var/spool/ftp/pub/Crypto/SSL/064/SSLeay-0.6.3/./crypto/buffer/bf_buff.c	Wed Jul 17 16:45:42 1996
--- ./crypto/buffer/bf_buff.c	Thu Aug 29 23:50:29 1996
***************
*** 93,105 ****
  	{
  	BIO_F_BUFFER_CTX *ctx;
  
! 	ctx=(BIO_F_BUFFER_CTX *)malloc(sizeof(BIO_F_BUFFER_CTX));
  	if (ctx == NULL) return(0);
  	ctx->bio=NULL;
! 	ctx->ibuf=(char *)malloc(DEFAULT_BUFFER_SIZE);
! 	if (ctx->ibuf == NULL) { free(ctx); return(0); }
! 	ctx->obuf=(char *)malloc(DEFAULT_BUFFER_SIZE);
! 	if (ctx->obuf == NULL) { free(ctx->ibuf); free(ctx); return(0); }
  	ctx->buf_size=DEFAULT_BUFFER_SIZE;
  	ctx->ibuf_len=0;
  	ctx->ibuf_off=0;
--- 93,105 ----
  	{
  	BIO_F_BUFFER_CTX *ctx;
  
! 	ctx=(BIO_F_BUFFER_CTX *)Malloc(sizeof(BIO_F_BUFFER_CTX));
  	if (ctx == NULL) return(0);
  	ctx->bio=NULL;
! 	ctx->ibuf=(char *)Malloc(DEFAULT_BUFFER_SIZE);
! 	if (ctx->ibuf == NULL) { Free(ctx); return(0); }
! 	ctx->obuf=(char *)Malloc(DEFAULT_BUFFER_SIZE);
! 	if (ctx->obuf == NULL) { Free(ctx->ibuf); Free(ctx); return(0); }
  	ctx->buf_size=DEFAULT_BUFFER_SIZE;
  	ctx->ibuf_len=0;
  	ctx->ibuf_off=0;
***************
*** 106,112 ****
  	ctx->obuf_len=0;
  	ctx->obuf_off=0;
  
! 	bi->init=0;
  	bi->ptr=(char *)ctx;
  	bi->flags=0;
  	return(1);
--- 106,112 ----
  	ctx->obuf_len=0;
  	ctx->obuf_off=0;
  
! 	bi->init=1;
  	bi->ptr=(char *)ctx;
  	bi->flags=0;
  	return(1);
***************
*** 119,127 ****
  
  	if (a == NULL) return(0);
  	b=(BIO_F_BUFFER_CTX *)a->ptr;
! 	if (b->ibuf != NULL) free(b->ibuf);
! 	if (b->obuf != NULL) free(b->obuf);
! 	free(a->ptr);
  	a->ptr=NULL;
  	a->init=0;
  	a->flags=0;
--- 119,127 ----
  
  	if (a == NULL) return(0);
  	b=(BIO_F_BUFFER_CTX *)a->ptr;
! 	if (b->ibuf != NULL) Free(b->ibuf);
! 	if (b->obuf != NULL) Free(b->obuf);
! 	Free(a->ptr);
  	a->ptr=NULL;
  	a->init=0;
  	a->flags=0;
***************
*** 264,269 ****
--- 264,270 ----
  	long ret=1;
  	char *p1,*p2;
  	int r;
+ 	BIO **bpp;
  
  	ctx=(BIO_F_BUFFER_CTX *)b->ptr;
  
***************
*** 274,282 ****
--- 275,286 ----
  		ctx->ibuf_len=0;
  		ctx->obuf_off=0;
  		ctx->obuf_len=0;
+ 		if (ctx->bio != NULL)
  			ret=BIO_ctrl(ctx->bio,cmd,num,ptr);
  		break;
  	case BIO_CTRL_INFO:
+ 		ret=(long)ctx->obuf_len;
+ 		break;
  	case BIO_CTRL_GET:
  	case BIO_CTRL_PENDING:
  		ret=(long)ctx->ibuf_len;
***************
*** 284,304 ****
  	case BIO_CTRL_SET:
  		if ((num > DEFAULT_BUFFER_SIZE) && (num != ctx->buf_size))
  			{
! 			p1=(char *)malloc((int)num);
! 			p2=(char *)malloc((int)num);
  			if ((p1 == NULL) || (p2 == NULL))
  				{
! 				if (p1 != NULL) free(p1);
  				ret=0;
  				}
  			else
  				{
! 				free(ctx->ibuf);
  				ctx->ibuf=p1;
  				ctx->ibuf_off=0;
  				ctx->ibuf_len=0;
  
! 				free(ctx->obuf);
  				ctx->obuf=p2;
  				ctx->obuf_off=0;
  				ctx->obuf_len=0;
--- 288,308 ----
  	case BIO_CTRL_SET:
  		if ((num > DEFAULT_BUFFER_SIZE) && (num != ctx->buf_size))
  			{
! 			p1=(char *)Malloc((int)num);
! 			p2=(char *)Malloc((int)num);
  			if ((p1 == NULL) || (p2 == NULL))
  				{
! 				if (p1 != NULL) Free(p1);
  				ret=0;
  				}
  			else
  				{
! 				Free(ctx->ibuf);
  				ctx->ibuf=p1;
  				ctx->ibuf_off=0;
  				ctx->ibuf_len=0;
  
! 				Free(ctx->obuf);
  				ctx->obuf=p2;
  				ctx->obuf_off=0;
  				ctx->obuf_len=0;
***************
*** 306,316 ****
  				}
  			}
  		break;
  	case BIO_CTRL_FLUSH:
  		r=BIO_write(ctx->bio,&(ctx->obuf[ctx->obuf_off]),
  			ctx->obuf_len);
! 		if (ret <= 0) return((long)r);
! 		if (ret == ctx->obuf_len)
  			{
  			ctx->obuf_len=0;
  			ctx->obuf_off=0;
--- 310,334 ----
  				}
  			}
  		break;
+ 	case BIO_CTRL_PUSH:
+ 		ctx->bio=(BIO *)ptr;
+ 		ret=1;
+ 		break;
+ 	case BIO_CTRL_POP:
+ 		bpp=(BIO **)ptr;
+ 		if ((bpp != NULL) && (*bpp != NULL))
+ 			{
+ 			*bpp=ctx->bio;
+ 			ret=1;
+ 			}
+ 		else
+ 			ret=0;
+ 		break;
  	case BIO_CTRL_FLUSH:
  		r=BIO_write(ctx->bio,&(ctx->obuf[ctx->obuf_off]),
  			ctx->obuf_len);
! 		if (r <= 0) return((long)r);
! 		if (r == ctx->obuf_len)
  			{
  			ctx->obuf_len=0;
  			ctx->obuf_off=0;
*** /var/spool/ftp/pub/Crypto/SSL/064/SSLeay-0.6.3/./crypto/buffer/bio_cb.c	Wed Jul 17 16:45:42 1996
--- ./crypto/buffer/bio_cb.c	Thu Aug 29 23:50:29 1996
***************
*** 73,79 ****
  	switch (cmd)
  		{
  	case BIO_CB_FREE:
! 		sprintf(p,"free - %s\n",bio->method->name);
  		break;
  	case BIO_CB_READ:
  		sprintf(p,"read(%d) - %s\n",argi,bio->method->name);
--- 73,79 ----
  	switch (cmd)
  		{
  	case BIO_CB_FREE:
! 		sprintf(p,"Free - %s\n",bio->method->name);
  		break;
  	case BIO_CB_READ:
  		sprintf(p,"read(%d) - %s\n",argi,bio->method->name);
*** /var/spool/ftp/pub/Crypto/SSL/064/SSLeay-0.6.3/./crypto/buffer/bio_lib.c	Wed Jul 17 16:45:42 1996
--- ./crypto/buffer/bio_lib.c	Thu Aug 29 23:50:29 1996
***************
*** 55,83 ****
  	{
  	BIO *ret=NULL;
  
! 	ret=(BIO *)malloc(sizeof(BIO));
  	if (ret == NULL)
  		{
  		BUFerr(BUF_F_BIO_NEW,ERR_R_MALLOC_FAILURE);
  		return(NULL);
  		}
! 	ret->method=method;
! 	ret->callback=NULL;
! 	ret->cb_arg=NULL;
! 	ret->init=0;
! 	ret->shutdown=1;
! 	ret->num=0;
! 	ret->flags=0;
! 	ret->ptr=NULL;
! 	if (method->create != NULL)
! 		if (!method->create(ret))
  			{
  			ret=NULL;
- 			free(ret);
  			}
  	return(ret);
  	}
  
  int BIO_free(a)
  BIO *a;
  	{
--- 55,92 ----
  	{
  	BIO *ret=NULL;
  
! 	ret=(BIO *)Malloc(sizeof(BIO));
  	if (ret == NULL)
  		{
  		BUFerr(BUF_F_BIO_NEW,ERR_R_MALLOC_FAILURE);
  		return(NULL);
  		}
! 	if (!BIO_set(ret,method))
  		{
+ 		Free(ret);
  		ret=NULL;
  		}
  	return(ret);
  	}
  
+ int BIO_set(bio,method)
+ BIO *bio;
+ BIO_METHOD *method;
+ 	{
+ 	bio->method=method;
+ 	bio->callback=NULL;
+ 	bio->cb_arg=NULL;
+ 	bio->init=0;
+ 	bio->shutdown=1;
+ 	bio->num=0;
+ 	bio->flags=0;
+ 	bio->ptr=NULL;
+ 	if (method->create != NULL)
+ 		if (!method->create(bio))
+ 			return(0);
+ 	return(1);
+ 	}
+ 
  int BIO_free(a)
  BIO *a;
  	{
***************
*** 89,95 ****
  
  	if (a->method->destroy == NULL) return(1);
  	ret=a->method->destroy(a);
! 	free(a);
  	return(1);
  	}
  
--- 98,104 ----
  
  	if (a->method->destroy == NULL) return(1);
  	ret=a->method->destroy(a);
! 	Free(a);
  	return(1);
  	}
  
*** /dev/null	Fri Aug 30 04:16:48 1996
--- ./crypto/buffer/bss_rtcp.c	Thu Aug 29 23:50:29 1996
***************
*** 0 ****
--- 1,235 ----
+ /* VMS */
+ #include <stdio.h>
+ #include <stdlib.h>
+ #include <string.h>
+ #include <errno.h>
+ #include "cryptlib.h"
+ #include "buffer.h"
+ 
+ #include <iodef.h>		/* VMS IO$_ definitions */
+ extern int SYS$QIOW();
+ typedef unsigned short io_channel;
+ /*************************************************************************/
+ struct io_status { short status, count; long flags; };
+ 
+ struct rpc_msg {		/* Should have member alignment inhibited */
+    char channel;		/* 'A'-app data. 'R'-remote client 'G'-global */
+    char function;		/* 'G'-get, 'P'-put, 'C'-confirm, 'X'-close */
+    unsigned short int length;	/* Amount of data returned or max to return */
+    char data[4092];		/* variable data */
+ };
+ #define RPC_HDR_SIZE (sizeof(struct rpc_msg) - 4092)
+ 
+ struct rpc_ctx {
+     int filled, pos;
+     struct rpc_msg msg;
+ };
+ 
+ static int rtcp_write(BIO *h,char *buf,int num);
+ static int rtcp_read(BIO *h,char *buf,int size);
+ static int rtcp_puts(BIO *h,char *str);
+ static int rtcp_gets(BIO *h,char *str,int size);
+ static long rtcp_ctrl(BIO *h,int cmd,long arg1,char *arg2);
+ static int rtcp_new(BIO *h);
+ static int rtcp_free(BIO *data);
+ 
+ static BIO_METHOD rtcp_method=
+ 	{
+ 	BIO_TYPE_FD,"RTCP",
+ 	rtcp_write,
+ 	rtcp_read,
+ 	rtcp_puts,
+ 	rtcp_gets,
+ 	rtcp_ctrl,
+ 	rtcp_new,
+ 	rtcp_free,
+ 	};
+ 
+ BIO_METHOD *BIO_s_rtcp()
+ 	{
+ 	return(&rtcp_method);
+ 	}
+ /*****************************************************************************/
+ /* Decnet I/O routines.
+  */
+ static int get ( io_channel chan, char *buffer, int maxlen, int *length )
+ {
+     int status;
+     struct io_status iosb;
+     status = SYS$QIOW ( 0, chan, IO$_READVBLK, &iosb, 0, 0,
+ 	buffer, maxlen, 0, 0, 0, 0 );
+     if ( (status&1) == 1 ) status = iosb.status;
+     if ( (status&1) == 1 ) *length = iosb.count;
+     return status;
+ }
+ 
+ static int put ( io_channel chan, char *buffer, int length )
+ {
+     int status;
+     struct io_status iosb;
+     status = SYS$QIOW ( 0, chan, IO$_WRITEVBLK, &iosb, 0, 0,
+ 	buffer, length, 0, 0, 0, 0 );
+     if ( (status&1) == 1 ) status = iosb.status;
+     return status;
+ }
+ /***************************************************************************/
+ 
+ static int rtcp_new(bi)
+ BIO *bi;
+ {
+     struct rpc_ctx *ctx;
+ 	bi->init=1;
+ 	bi->num=0;
+ 	bi->flags = 0;
+ 	bi->ptr=malloc(sizeof(struct rpc_ctx));
+ 	ctx = (struct rpc_ctx *) bi->ptr;
+ 	ctx->filled = 0;
+ 	ctx->pos = 0;
+ 	return(1);
+ }
+ 
+ static int rtcp_free(a)
+ BIO *a;
+ {
+ 	if (a == NULL) return(0);
+ 	if ( a->ptr ) free ( a->ptr );
+ 	a->ptr = NULL;
+ 	return(1);
+ }
+ 	
+ static int rtcp_read(b,out,outl)
+ BIO *b;
+ char *out;
+ int outl;
+ {
+     int status, length;
+     struct rpc_ctx *ctx;
+     /*
+      * read data, return existing.
+      */
+     ctx = (struct rpc_ctx *) b->ptr;
+     if ( ctx->pos < ctx->filled ) {
+ 	length = ctx->filled - ctx->pos;
+ 	if ( length > outl ) length = outl;
+ 	memmove ( out, &ctx->msg.data[ctx->pos], length );
+ 	ctx->pos += length;
+ 	return length;
+     }
+     /*
+      * Requst more data from R channel.
+      */
+     ctx->msg.channel = 'R';
+     ctx->msg.function = 'G';
+     ctx->msg.length = sizeof(ctx->msg.data);
+     status = put ( b->num, (char *) &ctx->msg, RPC_HDR_SIZE );
+     if ( (status&1) == 0 ) {
+ 	return -1;
+     }
+     /*
+      * Read.
+      */
+     ctx->pos = ctx->filled = 0;
+     status = get ( b->num, (char *) &ctx->msg, sizeof(ctx->msg), &length );
+     if ( (status&1) == 0 ) length = -1;
+     if ( ctx->msg.channel != 'R' || ctx->msg.function != 'C' ) {
+ 	length = -1;
+     }
+     ctx->filled = length - RPC_HDR_SIZE;
+     
+     if ( ctx->pos < ctx->filled ) {
+ 	length = ctx->filled - ctx->pos;
+ 	if ( length > outl ) length = outl;
+ 	memmove ( out, ctx->msg.data, length );
+ 	ctx->pos += length;
+ 	return length;
+     }
+ 
+     return length;
+ }
+ 
+ static int rtcp_write(b,in,inl)
+ BIO *b;
+ char *in;
+ int inl;
+ {
+     int status, i, segment, length;
+     struct rpc_ctx *ctx;
+     /*
+      * Output data, send in chunks no larger that sizeof(ctx->msg.data).
+      */
+     ctx = (struct rpc_ctx *) b->ptr;
+     for ( i = 0; i < inl; i += segment ) {
+ 	segment = inl - i;
+ 	if ( segment > sizeof(ctx->msg.data) ) segment = sizeof(ctx->msg.data);
+ 	ctx->msg.channel = 'R';
+ 	ctx->msg.function = 'P';
+ 	ctx->msg.length = segment;
+ 	memmove ( ctx->msg.data, &in[i], segment );
+ 	status = put ( b->num, (char *) &ctx->msg, segment + RPC_HDR_SIZE );
+ 	if ((status&1) == 0 ) { i = -1; break; }
+ 
+ 	status = get ( b->num, (char *) &ctx->msg, sizeof(ctx->msg), &length );
+ 	if ( ((status&1) == 0) || (length < RPC_HDR_SIZE) ) { i = -1; break; }
+ 	if ( (ctx->msg.channel != 'R') || (ctx->msg.function != 'C') ) {
+ 	   printf("unexpected response when confirming put %c %c\n",
+ 		ctx->msg.channel, ctx->msg.function );
+ 
+ 	}
+     }
+     return(i);
+ }
+ 
+ static long rtcp_ctrl(b,cmd,num,ptr)
+ BIO *b;
+ int cmd;
+ long num;
+ char *ptr;
+ 	{
+ 	long ret=1;
+ 
+ 	switch (cmd)
+ 		{
+ 	case BIO_CTRL_RESET:
+ 	case BIO_CTRL_EOF:
+ 		ret = 1;
+ 		break;
+ 	case BIO_CTRL_SET:
+ 		b->num = num;
+ 		ret = 1;
+ 	 	break;
+ 	case BIO_CTRL_SET_CLOSE:
+ 	case BIO_CTRL_FLUSH:
+ 		ret=1;
+ 		break;
+ 	case BIO_CTRL_GET_CLOSE:
+ 	case BIO_CTRL_INFO:
+ 	case BIO_CTRL_GET:
+ 	case BIO_CTRL_PENDING:
+ 	case BIO_CTRL_SHOULD_RETRY:
+ 	case BIO_CTRL_RETRY_TYPE:
+ 	default:
+ 		ret=0;
+ 		break;
+ 		}
+ 	return(ret);
+ 	}
+ 
+ static int rtcp_gets(bp,buf,size)
+ BIO *bp;
+ char *buf;
+ int size;
+ 	{
+ 	return(0);
+ 	}
+ 
+ static int rtcp_puts(bp,str)
+ BIO *bp;
+ char *str;
+ {
+     int length;
+     if (str == NULL) return(0);
+     length = strlen ( str );
+     if ( length == 0 ) return (0);
+     return rtcp_write ( bp,str, length );
+ }
+ 
*** /var/spool/ftp/pub/Crypto/SSL/064/SSLeay-0.6.3/./crypto/buffer/buffer.c	Wed Jul 17 16:45:43 1996
--- ./crypto/buffer/buffer.c	Thu Aug 29 23:50:29 1996
***************
*** 53,59 ****
  	{
  	BUF_MEM *ret;
  
! 	ret=(BUF_MEM *)malloc(sizeof(BUF_MEM));
  	if (ret == NULL)
  		{
  		BUFerr(BUF_F_BUF_MEM_NEW,ERR_R_MALLOC_FAILURE);
--- 53,59 ----
  	{
  	BUF_MEM *ret;
  
! 	ret=(BUF_MEM *)Malloc(sizeof(BUF_MEM));
  	if (ret == NULL)
  		{
  		BUFerr(BUF_F_BUF_MEM_NEW,ERR_R_MALLOC_FAILURE);
***************
*** 71,79 ****
  	if (a->data != NULL)
  		{
  		memset(a->data,0,(unsigned int)a->max);
! 		free(a->data);
  		}
! 	free(a);
  	}
  
  int BUF_MEM_grow(str, len)
--- 71,79 ----
  	if (a->data != NULL)
  		{
  		memset(a->data,0,(unsigned int)a->max);
! 		Free(a->data);
  		}
! 	Free(a);
  	}
  
  int BUF_MEM_grow(str, len)
***************
*** 92,100 ****
  		}
  	n=len*3/2;
  	if (str->data == NULL)
! 		ret=(char *)malloc((unsigned int)n);
  	else
! 		ret=(char *)realloc(str->data,(unsigned int)n);
  	if (ret == NULL)
  		{
  		BUFerr(BUF_F_BUF_MEM_GROW,ERR_R_MALLOC_FAILURE);
--- 92,100 ----
  		}
  	n=len*3/2;
  	if (str->data == NULL)
! 		ret=(char *)Malloc((unsigned int)n);
  	else
! 		ret=(char *)Realloc(str->data,(unsigned int)n);
  	if (ret == NULL)
  		{
  		BUFerr(BUF_F_BUF_MEM_GROW,ERR_R_MALLOC_FAILURE);
*** /var/spool/ftp/pub/Crypto/SSL/064/SSLeay-0.6.3/./crypto/buffer/buffer.h	Sat Jul 20 23:41:18 1996
--- ./crypto/buffer/buffer.h	Thu Aug 29 23:50:29 1996
***************
*** 198,204 ****
  		BIO_CLOSE|BIO_FP_APPEND,name)
  
  #define BIO_set_ssl(b,ssl,c)	BIO_ctrl(b,BIO_CTRL_SET,c,(char *)ssl)
! #define BIO_get_ssl(b,sslp)	BIO_ctrl(b,BIO_CTRL_GET,0,(char **)sslp)
  
  #define BIO_set_bio(b,bio)	BIO_ctrl(b,BIO_CTRL_SET,0,(char *)bio)
  /* #define BIO_set_md(b,md)	BIO_ctrl(b,BIO_CTRL_SET,1,(char *)md) */
--- 198,204 ----
  		BIO_CLOSE|BIO_FP_APPEND,name)
  
  #define BIO_set_ssl(b,ssl,c)	BIO_ctrl(b,BIO_CTRL_SET,c,(char *)ssl)
! #define BIO_get_ssl(b,sslp)	BIO_ctrl(b,BIO_CTRL_GET,0,(char *)sslp)
  
  #define BIO_set_bio(b,bio)	BIO_ctrl(b,BIO_CTRL_SET,0,(char *)bio)
  /* #define BIO_set_md(b,md)	BIO_ctrl(b,BIO_CTRL_SET,1,(char *)md) */
***************
*** 209,215 ****
  #define BIO_get_close(b)	BIO_ctrl(b,BIO_CTRL_GET_CLOSE,0,NULL)
  #define BIO_pending(b)		BIO_ctrl(b,BIO_CTRL_PENDING,0,NULL)
  #define BIO_flush(b)		BIO_ctrl(b,BIO_CTRL_FLUSH,0,NULL)
! #define BIO_push(b,bio)		BIO_ctrl(b,BIO_CTRL_PUSH,0,bio)
  /* the next 2 have been done as macros */
  /* #define BIO_should_retry(b)	BIO_ctrl(b,BIO_CTRL_SHOULD_RETRY,0,NULL) */
  /* #define BIO_retry_type(b)	BIO_ctrl(b,BIO_CTRL_RETRY_TYPE,0,NULL) */
--- 209,216 ----
  #define BIO_get_close(b)	BIO_ctrl(b,BIO_CTRL_GET_CLOSE,0,NULL)
  #define BIO_pending(b)		BIO_ctrl(b,BIO_CTRL_PENDING,0,NULL)
  #define BIO_flush(b)		BIO_ctrl(b,BIO_CTRL_FLUSH,0,NULL)
! #define BIO_push(b,bio)		BIO_ctrl(b,BIO_CTRL_PUSH,0,(char *)bio)
! #define BIO_pop(b,bio_pp)	BIO_ctrl(b,BIO_CTRL_POP,0,(char *)bio_pp)
  /* the next 2 have been done as macros */
  /* #define BIO_should_retry(b)	BIO_ctrl(b,BIO_CTRL_SHOULD_RETRY,0,NULL) */
  /* #define BIO_retry_type(b)	BIO_ctrl(b,BIO_CTRL_RETRY_TYPE,0,NULL) */
***************
*** 220,231 ****
  int	BUF_MEM_grow(BUF_MEM *str, int len);
  
  BIO *	BIO_new(BIO_METHOD *type);
  int	BIO_free(BIO *a);
  int	BIO_read(BIO *b, char *data, int len);
  int	BIO_gets(BIO *bp,char *buf, int size);
  int	BIO_write(BIO *b, char *data, int len);
  int	BIO_puts(BIO *bp,char *buf);
- int	BIO_puts(BIO *bp,char *buf);
  long	BIO_ctrl(BIO *bp,int cmd,long larg,char *parg);
  
  #ifndef WIN16
--- 221,232 ----
  int	BUF_MEM_grow(BUF_MEM *str, int len);
  
  BIO *	BIO_new(BIO_METHOD *type);
+ int	BIO_set(BIO *a,BIO_METHOD *type);
  int	BIO_free(BIO *a);
  int	BIO_read(BIO *b, char *data, int len);
  int	BIO_gets(BIO *bp,char *buf, int size);
  int	BIO_write(BIO *b, char *data, int len);
  int	BIO_puts(BIO *bp,char *buf);
  long	BIO_ctrl(BIO *bp,int cmd,long larg,char *parg);
  
  #ifndef WIN16
***************
*** 263,273 ****
  #endif
  
  BIO *	BIO_new();
  int	BIO_free();
  int	BIO_read();
  int	BIO_gets();
  int	BIO_write();
- int	BIO_puts();
  int	BIO_puts();
  long	BIO_ctrl();
  
--- 264,274 ----
  #endif
  
  BIO *	BIO_new();
+ int	BIO_set();
  int	BIO_free();
  int	BIO_read();
  int	BIO_gets();
  int	BIO_write();
  int	BIO_puts();
  long	BIO_ctrl();
  
*** /var/spool/ftp/pub/Crypto/SSL/064/SSLeay-0.6.3/./crypto/buffer/Makefile.ssl	Thu Aug  8 01:54:25 1996
--- ./crypto/buffer/Makefile.ssl	Fri Aug 30 04:40:56 1996
***************
*** 80,86 ****
  	mv -f Makefile.new $(MAKEFILE)
  
  clean:
! 	/bin/rm -f *.o *.obj lib tags core .nfs* *.old *.bak fluff
  
  errors:
  	perl $(TOP)/util/err-ins.pl $(ERR).err $(ERR).h
--- 80,86 ----
  	mv -f Makefile.new $(MAKEFILE)
  
  clean:
! 	/bin/rm -f *.o *.obj lib tags core .pure .nfs* *.old *.bak fluff
  
  errors:
  	perl $(TOP)/util/err-ins.pl $(ERR).err $(ERR).h
*** /var/spool/ftp/pub/Crypto/SSL/064/SSLeay-0.6.3/./crypto/conf/conf.c	Tue Aug  6 15:57:41 1996
--- ./crypto/conf/conf.c	Fri Aug 30 00:58:28 1996
***************
*** 84,90 ****
  
  #define scan_esc(p)	((*(++p) == '\0')?(p):(++p))
  
! char *CONF_version="CONF part of SSLeay 0.6.3 06-Aug-1996";
  
  LHASH *CONF_load(h,file,line)
  LHASH *h;
--- 84,90 ----
  
  #define scan_esc(p)	((*(++p) == '\0')?(p):(++p))
  
! char *CONF_version="CONF part of SSLeay 0.6.4 30-Aug-1996";
  
  LHASH *CONF_load(h,file,line)
  LHASH *h;
***************
*** 118,124 ****
  		goto err;
  		}
  
! 	section=(char *)malloc(10);
  	if (section == NULL)
  		{
  		CONFerr(CONF_F_CONF_LOAD,ERR_R_MALLOC_FAILURE);
--- 118,124 ----
  		goto err;
  		}
  
! 	section=(char *)Malloc(10);
  	if (section == NULL)
  		{
  		CONFerr(CONF_F_CONF_LOAD,ERR_R_MALLOC_FAILURE);
***************
*** 164,176 ****
  		/* check for line continuation */
  		if (bufnum >= 2)
  			{
  			p= &(buff->data[bufnum-1]);
! 			while ((p != buff->data) && (IS_WS(*p)))
  				p--;
  			if (	((p >= buff->data) && (*p == '\\')) &&
  				((p == buff->data) || (p[-1] != '\\')))
  				continue; 
  			}
  		bufnum=0;
  		buf=buff->data;
  
--- 164,185 ----
  		/* check for line continuation */
  		if (bufnum >= 2)
  			{
+ 			int n=0;
+ 
  			p= &(buff->data[bufnum-1]);
! 			while ((p != buff->data) &&
! 				((*p == '\n') || (*p == '\r')))
! 				{
! 				n++;
  				p--;
+ 				}
  			if (	((p >= buff->data) && (*p == '\\')) &&
  				((p == buff->data) || (p[-1] != '\\')))
+ 				{
+ 				bufnum-=n;
  				continue; 
  				}
+ 			}
  		bufnum=0;
  		buf=buff->data;
  
***************
*** 231,243 ****
  			p++;
  			*p='\0';
  
! 			if ((v=(CONF_VALUE *)malloc(sizeof(CONF_VALUE))) == NULL)
  				{
  				CONFerr(CONF_F_CONF_LOAD,ERR_R_MALLOC_FAILURE);
  				goto err;
  				}
  			if (psection == NULL) psection=section;
! 			v->name=(char *)malloc(strlen(pname)+1);
  			v->value=NULL;
  			if (v->name == NULL)
  				{
--- 240,252 ----
  			p++;
  			*p='\0';
  
! 			if ((v=(CONF_VALUE *)Malloc(sizeof(CONF_VALUE))) == NULL)
  				{
  				CONFerr(CONF_F_CONF_LOAD,ERR_R_MALLOC_FAILURE);
  				goto err;
  				}
  			if (psection == NULL) psection=section;
! 			v->name=(char *)Malloc(strlen(pname)+1);
  			v->value=NULL;
  			if (v->name == NULL)
  				{
***************
*** 272,296 ****
  				}
  			vv=(CONF_VALUE *)lh_insert(ret,(char *)v);
  			if (vv != NULL)
! 				abort(); /* vv should be NULL allways */
  			v=NULL;
  			}
  		}
  	if (buff != NULL) BUF_MEM_free(buff);
! 	if (section != NULL) free(section);
  	if (in != NULL) fclose(in);
  	return(ret);
  err:
  	if (buff != NULL) BUF_MEM_free(buff);
! 	if (section != NULL) free(section);
  	if (line != NULL) *line=eline;
  	if (in != NULL) fclose(in);
  	if ((h != ret) && (ret != NULL)) CONF_free(ret);
  	if (v != NULL)
  		{
! 		if (v->name != NULL) free(v->name);
! 		if (v->value != NULL) free(v->value);
! 		if (v != NULL) free(v);
  		}
  	return(NULL);
  	}
--- 281,310 ----
  				}
  			vv=(CONF_VALUE *)lh_insert(ret,(char *)v);
  			if (vv != NULL)
! 				{
! 				sk_delete_ptr(ts,(char *)vv);
! 				Free(vv->name);
! 				Free(vv->value);
! 				Free(vv);
! 				}
  			v=NULL;
  			}
  		}
  	if (buff != NULL) BUF_MEM_free(buff);
! 	if (section != NULL) Free(section);
  	if (in != NULL) fclose(in);
  	return(ret);
  err:
  	if (buff != NULL) BUF_MEM_free(buff);
! 	if (section != NULL) Free(section);
  	if (line != NULL) *line=eline;
  	if (in != NULL) fclose(in);
  	if ((h != ret) && (ret != NULL)) CONF_free(ret);
  	if (v != NULL)
  		{
! 		if (v->name != NULL) Free(v->name);
! 		if (v->value != NULL) Free(v->value);
! 		if (v != NULL) Free(v);
  		}
  	return(NULL);
  	}
***************
*** 381,387 ****
  	{
  	if (conf == NULL) return;
  
! 	conf->down_load=0; 	/* evil thing to make sure the 'free()'
  				 * works as expected */
  	lh_doall_arg(conf,(void (*)())value_free_hash,(char *)conf);
  
--- 395,401 ----
  	{
  	if (conf == NULL) return;
  
! 	conf->down_load=0; 	/* evil thing to make sure the 'Free()'
  				 * works as expected */
  	lh_doall_arg(conf,(void (*)())value_free_hash,(char *)conf);
  
***************
*** 416,428 ****
  	for (i=sk_num(sk)-1; i>=0; i--)
  		{
  		vv=(CONF_VALUE *)sk_value(sk,i);
! 		free(vv->value);
! 		free(vv->name);
! 		free(vv);
  		}
  	if (sk != NULL) sk_free(sk);
! 	free(a->section);
! 	free(a);
  	}
  
  static void clear_comments(p)
--- 430,442 ----
  	for (i=sk_num(sk)-1; i>=0; i--)
  		{
  		vv=(CONF_VALUE *)sk_value(sk,i);
! 		Free(vv->value);
! 		Free(vv->name);
! 		Free(vv);
  		}
  	if (sk != NULL) sk_free(sk);
! 	Free(a->section);
! 	Free(a);
  	}
  
  static void clear_comments(p)
***************
*** 461,467 ****
  char **pto,*from;
  	{
  	int q,r,rr=0,to=0,len=0;
! 	char *s,*e,*rp,*p,*rrp,*np,*cp;
  	BUF_MEM *buf;
  
  	if ((buf=BUF_MEM_new()) == NULL) return(0);
--- 475,481 ----
  char **pto,*from;
  	{
  	int q,r,rr=0,to=0,len=0;
! 	char *s,*e,*rp,*p,*rrp,*np,*cp,v;
  	BUF_MEM *buf;
  
  	if ((buf=BUF_MEM_new()) == NULL) return(0);
***************
*** 488,495 ****
  		else if (*from == '\\')
  			{
  			from++;
! 			if (*from == '\0') break;
! 			buf->data[to++]= *(from++);
  			}
  		else if (*from == '\0')
  			break;
--- 502,514 ----
  		else if (*from == '\\')
  			{
  			from++;
! 			v= *(from++);
! 			if (v == '\0') break;
! 			else if (v == 'r') v='\r';
! 			else if (v == 'n') v='\n';
! 			else if (v == 'b') v='\b';
! 			else if (v == 't') v='\t';
! 			buf->data[to++]= v;
  			}
  		else if (*from == '\0')
  			break;
***************
*** 558,566 ****
  			buf->data[to++]= *(from++);
  		}
  	buf->data[to]='\0';
! 	if (*pto != NULL) free(*pto);
  	*pto=buf->data;
! 	free(buf);
  	return(1);
  err:
  	if (buf != NULL) BUF_MEM_free(buf);
--- 577,585 ----
  			buf->data[to++]= *(from++);
  		}
  	buf->data[to]='\0';
! 	if (*pto != NULL) Free(*pto);
  	*pto=buf->data;
! 	Free(buf);
  	return(1);
  err:
  	if (buf != NULL) BUF_MEM_free(buf);
***************
*** 648,657 ****
  
  	if ((sk=sk_new_null()) == NULL)
  		goto err;
! 	if ((v=(CONF_VALUE *)malloc(sizeof(CONF_VALUE))) == NULL)
  		goto err;
  	i=strlen(section)+1;
! 	if ((v->section=(char *)malloc(i)) == NULL)
  		goto err;
  
  	memcpy(v->section,section,i);
--- 667,676 ----
  
  	if ((sk=sk_new_null()) == NULL)
  		goto err;
! 	if ((v=(CONF_VALUE *)Malloc(sizeof(CONF_VALUE))) == NULL)
  		goto err;
  	i=strlen(section)+1;
! 	if ((v->section=(char *)Malloc(i)) == NULL)
  		goto err;
  
  	memcpy(v->section,section,i);
***************
*** 671,677 ****
  	if (!ok)
  		{
  		if (sk != NULL) sk_free(sk);
! 		if (v != NULL) free(v);
  		v=NULL;
  		}
  	return(v);
--- 690,696 ----
  	if (!ok)
  		{
  		if (sk != NULL) sk_free(sk);
! 		if (v != NULL) Free(v);
  		v=NULL;
  		}
  	return(v);
*** /var/spool/ftp/pub/Crypto/SSL/064/SSLeay-0.6.3/./crypto/conf/Makefile.ssl	Thu Aug  8 01:54:29 1996
--- ./crypto/conf/Makefile.ssl	Fri Aug 30 04:41:00 1996
***************
*** 75,81 ****
  	mv -f Makefile.new $(MAKEFILE)
  
  clean:
! 	/bin/rm -f *.o *.obj lib tags core .nfs* *.old *.bak fluff
  
  errors:
  	perl $(TOP)/util/err-ins.pl $(ERR).err $(ERR).h
--- 75,81 ----
  	mv -f Makefile.new $(MAKEFILE)
  
  clean:
! 	/bin/rm -f *.o *.obj lib tags core .pure .nfs* *.old *.bak fluff
  
  errors:
  	perl $(TOP)/util/err-ins.pl $(ERR).err $(ERR).h
*** /dev/null	Fri Aug 30 04:16:48 1996
--- ./crypto/conf/ssleay.conf	Thu Aug 29 23:50:29 1996
***************
*** 0 ****
--- 1,80 ----
+ #
+ # This is a test configuration file for use in SSLeay etc...
+ #
+ 
+ init = 5
+ in\#it1 =10
+ init2='10'
+ init3='10\''
+ init4="10'"
+ init5='='10\'' again'
+ 
+ SSLeay::version = 0.5.0
+ 
+ [genrsa]
+ default_bits	= 512
+ SSLEAY::version = 0.5.0
+ 
+ [gendh]
+ default_bits	= 512
+ def_generator	= 2
+ 
+ [s_client]
+ cipher1		= 1234\
+ 567\n\n8\
+ 9ab
+ cipher2		= 'DES_CBC_MD5 DES_CBC_SHA DES_EDE_SHA RC4_MD5'
+ cipher3		= "DES_CBC_MD5 DES_CBC_SHA DES_EDE_SHA RC4_MD5"
+ cipher4		= DES_CBC_MD5 DES_CBC_SHA DES_EDE_SHA RC4_MD5
+ 
+ [ default ]
+ cert_dir	= $ENV::HOME/.ca_certs
+ 
+ HOME		= /tmp/eay
+ 
+ tmp_cert_dir	= $HOME/.ca_certs
+ tmp2_cert_dir	= thisis$(HOME)stuff
+ 
+ LOGNAME	= Eric Young (home=$HOME)
+ 
+ [ special ]
+ 
+ H=$HOME
+ H=$default::HOME
+ H=$ENV::HOME
+ #
+ # SSLeay example configuration file.
+ # This is mostly being used for generation of certificate requests.
+ #
+ 
+ RANDFILE		= $HOME/.rand
+ 
+ [ req ]
+ default_bits		= 512
+ default_keyfile 	= privkey.pem
+ 
+ Attribute_type_1	= countryName
+ Attribute_text_1	= Country Name (2 letter code)
+ Attribute_default_1	= AU
+ 
+ Attribute_type_2	= stateOrProvinceName
+ Attribute_text_2	= State or Province Name (full name)
+ Attribute_default_2	= Queensland
+ 
+ Attribute_type_3	= localityName
+ Attribute_text_3	= Locality Name (eg, city)
+ 
+ Attribute_type_4	= organizationName
+ Attribute_text_4	= Organization Name (eg, company)
+ Attribute_default_4	= Mincom Pty Ltd
+ 
+ Attribute_type_5	= organizationalUnitName
+ Attribute_text_5	= Organizational Unit Name (eg, section)
+ Attribute_default_5	= TR
+ 
+ Attribute_type_6	= commonName
+ Attribute_text_6	= Common Name (eg, YOUR name)
+ 
+ Attribute_type_7	= emailAddress
+ Attribute_text_7	= Email Address
+ 
*** /dev/null	Fri Aug 30 04:16:48 1996
--- ./crypto/conf/ssleay.conf2	Thu Aug 29 23:50:29 1996
***************
*** 0 ****
--- 1,78 ----
+ #
+ # This is a test configuration file for use in SSLeay etc...
+ #
+ 
+ init = 5
+ in\#it1 =10
+ init2='10'
+ init3='10\''
+ init4="10'"
+ init5='='10\'' again'
+ 
+ SSLeay::version = 0.5.0
+ 
+ [genrsa]
+ default_bits	= 512
+ SSLEAY::version = 0.5.0
+ 
+ [gendh]
+ default_bits	= 512
+ def_generator	= 2
+ 
+ [s_client]
+ cipher1		= DES_CBC_MD5:DES_CBC_SHA:DES_EDE_SHA:RC4_MD5\
+ cipher2		= 'DES_CBC_MD5 DES_CBC_SHA DES_EDE_SHA RC4_MD5'
+ cipher3		= "DES_CBC_MD5 DES_CBC_SHA DES_EDE_SHA RC4_MD5"
+ cipher4		= DES_CBC_MD5 DES_CBC_SHA DES_EDE_SHA RC4_MD5
+ 
+ [ default ]
+ cert_dir	= $ENV::HOME/.ca_certs
+ 
+ HOME		= /tmp/eay
+ 
+ tmp_cert_dir	= $HOME/.ca_certs
+ tmp2_cert_dir	= thisis$(HOME)stuff
+ 
+ LOGNAME	= Eric Young (home=$HOME)
+ 
+ [ special ]
+ 
+ H=$HOME
+ H=$default::HOME
+ H=$ENV::HOME
+ #
+ # SSLeay example configuration file.
+ # This is mostly being used for generation of certificate requests.
+ #
+ 
+ RANDFILE		= $HOME/.rand
+ 
+ [ req ]
+ default_bits		= 512
+ default_keyfile 	= privkey.pem
+ 
+ Attribute_type_1	= countryName
+ Attribute_text_1	= Country Name (2 letter code)
+ Attribute_default_1	= AU
+ 
+ Attribute_type_2	= stateOrProvinceName
+ Attribute_text_2	= State or Province Name (full name)
+ Attribute_default_2	= Queensland
+ 
+ Attribute_type_3	= localityName
+ Attribute_text_3	= Locality Name (eg, city)
+ 
+ Attribute_type_4	= organizationName
+ Attribute_text_4	= Organization Name (eg, company)
+ Attribute_default_4	= Mincom Pty Ltd
+ 
+ Attribute_type_5	= organizationalUnitName
+ Attribute_text_5	= Organizational Unit Name (eg, section)
+ Attribute_default_5	= TR
+ 
+ Attribute_type_6	= commonName
+ Attribute_text_6	= Common Name (eg, YOUR name)
+ 
+ Attribute_type_7	= emailAddress
+ Attribute_text_7	= Email Address
+ 
*** /var/spool/ftp/pub/Crypto/SSL/064/SSLeay-0.6.3/./crypto/conf/test.c	Wed Jul 17 16:45:43 1996
--- ./crypto/conf/test.c	Thu Aug 29 23:50:29 1996
***************
*** 60,66 ****
  		{
  		ERR_load_crypto_strings();
  		printf("unable to load configuration, line %ld\n",eline);
! 		ERR_print_errors(stderr);
  		exit(1);
  		}
  	lh_stats(conf,stdout);
--- 60,66 ----
  		{
  		ERR_load_crypto_strings();
  		printf("unable to load configuration, line %ld\n",eline);
! 		ERR_print_errors_fp(stderr);
  		exit(1);
  		}
  	lh_stats(conf,stdout);
*** /var/spool/ftp/pub/Crypto/SSL/064/SSLeay-0.6.3/./crypto/cryptlib.c	Wed Aug  7 09:24:25 1996
--- ./crypto/cryptlib.c	Fri Aug 30 00:58:29 1996
***************
*** 83,88 ****
--- 83,90 ----
  	"ssl_cert",
  	"ssl_session",
  	"ssl",
+ 	"rand",
+ 	"debug_malloc",
  	};
  
  char *SSLeay_version(t)
***************
*** 89,95 ****
  int t;
  	{
  	if (t == SSLEAY_VERSION)
! 		return("SSLeay 0.6.3 06-Aug-1996");
  	if (t == SSLEAY_OPTIONS)
  		{
  		static char buf[100];
--- 91,97 ----
  int t;
  	{
  	if (t == SSLEAY_VERSION)
! 		return("SSLeay 0.6.4 30-Aug-1996");
  	if (t == SSLEAY_OPTIONS)
  		{
  		static char buf[100];
***************
*** 284,286 ****
--- 286,317 ----
  		return("ERROR");
  	return(lock_names[type]);
  	}
+ 
+ #ifdef _DLL
+ #ifdef WIN32
+ 
+ /* All we really need to do is remove the 'error' state when a thread
+  * detaches */
+ 
+ BOOL WINAPI DLLEntryPoint(hinstDLL,fdwReason,lpvReserved)
+ HINSTANCE hinstDLL;
+ DWORD fdwReason;
+ LPVOID lpvReserved;
+ 	{
+ 	switch(fdwReason)
+ 		{
+ 	case DLL_PROCESS_ATTACH:
+ 		break;
+ 	case DLL_THREAD_ATTACH:
+ 		break;
+ 	case DLL_THREAD_DETACH:
+ 		ERR_remove_state(0);
+ 		break;
+ 	case DLL_PROCESS_DETACH:
+ 		break;
+ 		}
+ 	return(TRUE);
+ 	}
+ #endif
+ 
+ #endif
*** /var/spool/ftp/pub/Crypto/SSL/064/SSLeay-0.6.3/./crypto/crypto.c	Wed Aug  7 09:24:25 1996
--- ./crypto/crypto.c	Fri Aug 30 00:39:50 1996
***************
*** 51,56 ****
--- 51,83 ----
  #undef ASM
  #endif
  
+ #ifndef CRYPTO_SUBSET
+ /* Define all subset symbols. */
+ #define CRYPTO_LIB_SUBSET
+ #define CRYPTO_ASN1_SUBSET
+ #define CRYPTO_BN_SUBSET
+ #define CRYPTO_BUFFER_SUBSET
+ #define CRYPTO_CONF_SUBSET
+ #define CRYPTO_DES_SUBSET
+ #define CRYPTO_DH_SUBSET
+ #define CRYPTO_DSA_SUBSET
+ #define CRYPTO_ERROR_SUBSET
+ #define CRYPTO_EVP_SUBSET
+ #define CRYPTO_IDEA_SUBSET
+ #define CRYPTO_LHASH_SUBSET
+ #define CRYPTO_MD_SUBSET
+ #define CRYPTO_METH_SUBSET
+ #define CRYPTO_OBJECTS_SUBSET
+ #define CRYPTO_PEM_SUBSET
+ #define CRYPTO_RAND_SUBSET
+ #define CRYPTO_RC_SUBSET
+ #define CRYPTO_RSA_SUBSET
+ #define CRYPTO_SHA_SUBSET
+ #define CRYPTO_STACK_SUBSET
+ #define CRYPTO_TXT_DB_SUBSET
+ #define CRYPTO_X509_SUBSET
+ #endif
+ 
  #include <stdio.h>
  #include <stdlib.h>
  #include <string.h>
***************
*** 104,111 ****
--- 131,142 ----
  #include "asn1.h"
  #include "objects.h"
  
+ #ifdef CRYPTO_LIB_SUBSET
  #include "cryptlib.c"
+ #include "mem.c"
+ #endif
  
+ #ifdef CRYPTO_ASN1_SUBSET
  #include "asn1/a_bitstr.c"
  #include "asn1/a_d2i_fp.c"
  #include "asn1/a_dup.c"
***************
*** 165,170 ****
--- 196,203 ----
  #include "asn1/x_spki.c"
  #include "asn1/x_val.c"
  #include "asn1/x_x509.c"
+ #endif
+ #ifdef CRYPTO_BN_SUBSET
  #include "bn/bn_add.c"
  #include "bn/bn_div.c"
  #include "bn/bn_err.c"
***************
*** 185,190 ****
--- 218,225 ----
  #include "bn/bn_sqr.c"
  #include "bn/bn_sub.c"
  #include "bn/bn_word.c"
+ #endif
+ #ifdef CRYPTO_BUFFER_SUBSET
  #include "buffer/bf_buff.c"
  #include "buffer/bss_fd.c"
  #include "buffer/bss_file.c"
***************
*** 192,202 ****
--- 227,244 ----
  #include "buffer/bio_cb.c"
  #include "buffer/bss_mem.c"
  #include "buffer/bss_null.c"
+ #ifdef VMS
+ #include "buffer/bss_rtcp.c"
+ #endif
  #include "buffer/bss_sock.c"
  #include "buffer/buf_err.c"
  #include "buffer/buffer.c"
+ #endif
+ #ifdef CRYPTO_CONF_SUBSET
  #include "conf/conf.c"
  #include "conf/conf_err.c"
+ #endif
+ #ifdef CRYPTO_DES_SUBSET
  #include "des/cbc3_enc.c"
  #include "des/cbc_cksm.c"
  #include "des/cbc_enc.c"
***************
*** 222,238 ****
--- 264,288 ----
  #include "des/set_key.c"
  #include "des/str2key.c"
  #include "des/supp.c"
+ #endif
+ #ifdef CRYPTO_DH_SUBSET
  #include "dh/dh_check.c"
  #include "dh/dh_err.c"
  #include "dh/dh_gen.c"
  #include "dh/dh_key.c"
  #include "dh/dh_lib.c"
+ #endif
+ #ifdef CRYPTO_DSA_SUBSET
  #include "dsa/dsa_err.c"
  #include "dsa/dsa_lib.c"
  #include "dsa/dsa_sign.c"
  #include "dsa/dsa_vrf.c"
+ #endif
+ #ifdef CRYPTO_ERROR_SUBSET
  #include "error/err.c"
  #include "error/err_all.c"
+ #endif
+ #ifdef CRYPTO_EVP_SUBSET
  #include "evp/bio_md.c"
  #include "evp/digest.c"
  #include "evp/e_cbc_3d.c"
***************
*** 270,301 ****
--- 320,367 ----
  #include "evp/p_seal.c"
  #include "evp/p_sign.c"
  #include "evp/p_verify.c"
+ #endif
+ #ifdef CRYPTO_IDEA_SUBSET
  #include "idea/i_cbc.c"
  #include "idea/i_cfb64.c"
  #include "idea/i_ecb.c"
  #include "idea/i_ofb64.c"
  #include "idea/i_skey.c"
+ #endif
+ #ifdef CRYPTO_LHASH_SUBSET
  #include "lhash/lh_stats.c"
  #include "lhash/lhash.c"
+ #endif
+ #ifdef CRYPTO_MD_SUBSET
  #include "md/md2_dgst.c"
  #include "md/md2_one.c"
  #include "md/md5_dgst.c"
  #include "md/md5_one.c"
+ #endif
+ #ifdef CRYPTO_METH_SUBSET
  #include "meth/by_dir.c"
  #include "meth/by_file.c"
  #include "meth/meth_err.c"
  #include "meth/meth_lib.c"
  #include "meth/x509meth.c"
+ #endif
+ #ifdef CRYPTO_OBJECTS_SUBSET
  #include "objects/obj_dat.c"
  #include "objects/obj_err.c"
  #include "objects/obj_lib.c"
+ #endif
+ #ifdef CRYPTO_PEM_SUBSET
  #include "pem/pem_err.c"
  #include "pem/pem_info.c"
  #include "pem/pem_lib.c"
  #include "pem/pem_seal.c"
  #include "pem/pem_sign.c"
+ #endif
+ #ifdef CRYPTO_RAND_SUBSET
  #include "rand/md5_rand.c"
  #include "rand/randfile.c"
+ #endif
+ #ifdef CRYPTO_RC_SUBSET
  #include "rc2/rc2_cbc.c"
  #include "rc2/rc2_ecb.c"
  #include "rc2/rc2_skey.c"
***************
*** 302,318 ****
--- 368,394 ----
  #include "rc2/rc2cfb64.c"
  #include "rc2/rc2ofb64.c"
  #include "rc4/rc4_enc.c"
+ #endif
+ #ifdef CRYPTO_RSA_SUBSET
  #include "rsa/rsa_enc.c"
  #include "rsa/rsa_err.c"
  #include "rsa/rsa_gen.c"
  #include "rsa/rsa_lib.c"
  #include "rsa/rsa_sign.c"
+ #endif
+ #ifdef CRYPTO_SHA_SUBSET
  #include "sha/sha1_one.c"
  #include "sha/sha1dgst.c"
  #include "sha/sha_dgst.c"
  #include "sha/sha_one.c"
+ #endif
+ #ifdef CRYPTO_STACK_SUBSET
  #include "stack/stack.c"
+ #endif
+ #ifdef CRYPTO_TXT_DB_SUBSET
  #include "txt_db/txt_db.c"
+ #endif
+ #ifdef CRYPTO_X509_SUBSET
  #include "x509/x509_ath.c"
  #include "x509/x509_cmp.c"
  #include "x509/x509_crt.c"
***************
*** 322,324 ****
--- 398,401 ----
  #include "x509/x509_r2x.c"
  #include "x509/x509_req.c"
  #include "x509/x509_vrf.c"
+ #endif
*** /var/spool/ftp/pub/Crypto/SSL/064/SSLeay-0.6.3/./crypto/crypto.h	Tue Aug  6 15:57:18 1996
--- ./crypto/crypto.h	Thu Aug 29 23:50:26 1996
***************
*** 54,60 ****
  
  /* This is more to be used to check the correct DLL is being used
   * in the MS world. */
! #define SSLEAY_VERSION_NUMBER	0x0630	/* Version 0.5.1c would be 0513 */
  
  #define SSLEAY_VERSION		0
  #define SSLEAY_OPTIONS		1
--- 54,60 ----
  
  /* This is more to be used to check the correct DLL is being used
   * in the MS world. */
! #define SSLEAY_VERSION_NUMBER	0x0640	/* Version 0.5.1c would be 0513 */
  
  #define SSLEAY_VERSION		0
  #define SSLEAY_OPTIONS		1
***************
*** 80,86 ****
  #define	CRYPTO_LOCK_SSL_CERT		13
  #define	CRYPTO_LOCK_SSL_SESSION		14
  #define	CRYPTO_LOCK_SSL			15
! #define	CRYPTO_NUM_LOCKS		16
  
  #define CRYPTO_LOCK		1
  #define CRYPTO_UNLOCK		2
--- 80,88 ----
  #define	CRYPTO_LOCK_SSL_CERT		13
  #define	CRYPTO_LOCK_SSL_SESSION		14
  #define	CRYPTO_LOCK_SSL			15
! #define	CRYPTO_LOCK_RAND		16
! #define	CRYPTO_LOCK_MALLOC		17
! #define	CRYPTO_NUM_LOCKS		18
  
  #define CRYPTO_LOCK		1
  #define CRYPTO_UNLOCK		2
***************
*** 103,110 ****
--- 105,146 ----
  
  #endif
  
+ /* The following can be used to detect memory leaks in the SSLeay library.
+  * It used, it turns on malloc checking */
+ 
+ #define CRYPTO_MEM_CHECK_OFF	0x0
+ #define CRYPTO_MEM_CHECK_ON	0x1
+ 
+ /*
+ typedef struct crypto_mem_st
+ 	{
+ 	char *(*malloc_func)();
+ 	char *(*realloc_func)();
+ 	void (*free_func)();
+ 	} CRYPTO_MEM_FUNC;
+ */
+ 
  #ifndef NOPROTO
+ int CRYPTO_mem_ctrl(int mode);
+ #else
+ int CRYPTO_mem_ctrl();
+ #endif
  
+ #ifdef CRYPTO_MDEBUG
+ #define Malloc(num)     CRYPTO_malloc((int)num,__FILE__,__LINE__)
+ #define Realloc(addr,num) \
+ 	CRYPTO_realloc((char *)addr,(int)num,__FILE__,__LINE__)
+ #define FreeFunc	CRYPTO_free
+ #define Free(addr)	CRYPTO_free((char *)addr)
+ #else
+ #define Malloc		malloc
+ #define Realloc		realloc
+ #define FreeFunc	free
+ #define Free(addr)	free(addr)
+ #endif
+ 
+ #ifndef NOPROTO
+ 
  char *SSLeay_version(int type);
  unsigned long SSLeay(void);
  
***************
*** 123,130 ****
--- 159,178 ----
  char *CRYPTO_get_lock_name(int type);
  int CRYPTO_add_lock(int *pointer,int amount,int type, char *file,int line);
  
+ char *CRYPTO_malloc(int num,char *file,int line);
+ char *CRYPTO_realloc(char *addr,int num,char *file,int line);
+ void CRYPTO_free(char *);
+ #ifndef WIN16
+ void CRYPTO_mem_leaks_fp(FILE *);
+ #endif
+ #ifdef HEADER_BUFFER_H
+ void CRYPTO_mem_leaks(BIO *);
  #else
+ void CRYPTO_mem_leaks(char *);
+ #endif
  
+ #else
+ 
  char *SSLeay_version();
  unsigned long SSLeay();
  
***************
*** 138,143 ****
--- 186,199 ----
  unsigned long CRYPTO_thread_id();
  char *CRYPTO_get_lock_name();
  int CRYPTO_add_lock();
+ 
+ char *CRYPTO_malloc();
+ char *CRYPTO_realloc();
+ void CRYPTO_free();
+ #ifndef WIN16
+ void CRYPTO_mem_leaks_fp();
+ #endif
+ void CRYPTO_mem_leaks();
  
  #endif
  
*** /var/spool/ftp/pub/Crypto/SSL/064/SSLeay-0.6.3/./crypto/date.h	Thu Aug  8 00:59:29 1996
--- ./crypto/date.h	Fri Aug 30 04:04:33 1996
***************
*** 1 ****
! #define DATE	"Thu Aug  8 00:59:29 EST 1996"
--- 1 ----
! #define DATE	"Fri Aug 30 04:04:33 EST 1996"
*** /var/spool/ftp/pub/Crypto/SSL/064/SSLeay-0.6.3/./crypto/des/des.c	Wed Jul 17 16:45:44 1996
--- ./crypto/des/des.c	Thu Aug 29 23:50:29 1996
***************
*** 377,384 ****
  
  	if (buf == NULL)
  		{
! 		if (    (( buf=(unsigned char *)malloc(BUFSIZE+8)) == NULL) ||
! 			((obuf=(unsigned char *)malloc(BUFSIZE+8)) == NULL))
  			{
  			fputs("Not enough memory\n",stderr);
  			Exit=10;
--- 377,384 ----
  
  	if (buf == NULL)
  		{
! 		if (    (( buf=(unsigned char *)Malloc(BUFSIZE+8)) == NULL) ||
! 			((obuf=(unsigned char *)Malloc(BUFSIZE+8)) == NULL))
  			{
  			fputs("Not enough memory\n",stderr);
  			Exit=10;
*** /var/spool/ftp/pub/Crypto/SSL/064/SSLeay-0.6.3/./crypto/des/ecb_enc.c	Tue Aug  6 15:57:41 1996
--- ./crypto/des/ecb_enc.c	Fri Aug 30 00:58:27 1996
***************
*** 49,55 ****
  #include "spr.h"
  
  char *libdes_version="libdes v 3.24 - 20-Apr-1996 - eay";
! char *DES_version="DES part of SSLeay 0.6.3 06-Aug-1996";
  
  char *des_options()
  	{
--- 49,55 ----
  #include "spr.h"
  
  char *libdes_version="libdes v 3.24 - 20-Apr-1996 - eay";
! char *DES_version="DES part of SSLeay 0.6.4 30-Aug-1996";
  
  char *des_options()
  	{
*** /var/spool/ftp/pub/Crypto/SSL/064/SSLeay-0.6.3/./crypto/des/fcrypt.c	Wed Jul 17 16:45:45 1996
--- ./crypto/des/fcrypt.c	Thu Aug 29 23:50:29 1996
***************
*** 536,542 ****
  
  #ifndef NOPROTO
  #ifdef PERL5
! char *des_crypt(char *buf,char *salt);
  #else
  char *crypt(const char *buf,const char *salt);
  #endif
--- 536,542 ----
  
  #ifndef NOPROTO
  #ifdef PERL5
! char *des_crypt(const char *buf,char *salt);
  #else
  char *crypt(const char *buf,const char *salt);
  #endif
*** /var/spool/ftp/pub/Crypto/SSL/064/SSLeay-0.6.3/./crypto/des/Makefile.ssl	Thu Aug  8 01:54:22 1996
--- ./crypto/des/Makefile.ssl	Fri Aug 30 04:40:52 1996
***************
*** 87,93 ****
  	mv -f Makefile.new $(MAKEFILE)
  
  clean:
! 	/bin/rm -f *.o *.obj lib tags core .nfs* *.old *.bak fluff
  
  errors:
  
--- 87,93 ----
  	mv -f Makefile.new $(MAKEFILE)
  
  clean:
! 	/bin/rm -f *.o *.obj lib tags core .pure .nfs* *.old *.bak fluff
  
  errors:
  
*** /var/spool/ftp/pub/Crypto/SSL/064/SSLeay-0.6.3/./crypto/dh/dh.h	Sat Jul 20 23:41:17 1996
--- ./crypto/dh/dh.h	Thu Aug 29 23:50:30 1996
***************
*** 79,86 ****
  #define DH_UNABLE_TO_CHECK_GENERATOR	0x04
  #define DH_NOT_SUITABLE_GENERATOR	0x08
  
! #define DHparams_dup(x) (DH *)ASN1_dup(i2d_DHparams,(char *(*)()d2i_DHparams, \
! 		(char *)(x)))
  #define d2i_DHparams_fp(fp,x) (DH *)ASN1_d2i_fp((char *(*)())DH_new, \
  		(char *(*)())d2i_DHparams,(fp),(unsigned char **)(x))
  #define i2d_DHparams_fp(fp,x) ASN1_i2d_fp(i2d_DHparams,(fp), \
--- 79,86 ----
  #define DH_UNABLE_TO_CHECK_GENERATOR	0x04
  #define DH_NOT_SUITABLE_GENERATOR	0x08
  
! #define DHparams_dup(x) (DH *)ASN1_dup((int (*)())i2d_DHparams, \
! 		(char *(*)()d2i_DHparams,(char *)(x)))
  #define d2i_DHparams_fp(fp,x) (DH *)ASN1_d2i_fp((char *(*)())DH_new, \
  		(char *(*)())d2i_DHparams,(fp),(unsigned char **)(x))
  #define i2d_DHparams_fp(fp,x) ASN1_i2d_fp(i2d_DHparams,(fp), \
*** /var/spool/ftp/pub/Crypto/SSL/064/SSLeay-0.6.3/./crypto/dh/dh_lib.c	Tue Aug  6 15:57:42 1996
--- ./crypto/dh/dh_lib.c	Fri Aug 30 00:58:28 1996
***************
*** 50,62 ****
  #include "bn.h"
  #include "dh.h"
  
! char *DH_version="Diffie-Hellman part of SSLeay 0.6.3 06-Aug-1996";
  
  DH *DH_new()
  	{
  	DH *ret;
  
! 	ret=(DH *)malloc(sizeof(DH));
  	if (ret == NULL)
  		{
  		DHerr(DH_F_DH_NEW,ERR_R_MALLOC_FAILURE);
--- 50,62 ----
  #include "bn.h"
  #include "dh.h"
  
! char *DH_version="Diffie-Hellman part of SSLeay 0.6.4 30-Aug-1996";
  
  DH *DH_new()
  	{
  	DH *ret;
  
! 	ret=(DH *)Malloc(sizeof(DH));
  	if (ret == NULL)
  		{
  		DHerr(DH_F_DH_NEW,ERR_R_MALLOC_FAILURE);
***************
*** 79,85 ****
  	if (r->g != NULL) BN_clear_free(r->g);
  	if (r->pub_key != NULL) BN_clear_free(r->pub_key);
  	if (r->priv_key != NULL) BN_clear_free(r->priv_key);
! 	free(r);
  	}
  
  int DH_size(dh)
--- 79,85 ----
  	if (r->g != NULL) BN_clear_free(r->g);
  	if (r->pub_key != NULL) BN_clear_free(r->pub_key);
  	if (r->priv_key != NULL) BN_clear_free(r->priv_key);
! 	Free(r);
  	}
  
  int DH_size(dh)
*** /var/spool/ftp/pub/Crypto/SSL/064/SSLeay-0.6.3/./crypto/dh/Makefile.ssl	Thu Aug  8 01:54:24 1996
--- ./crypto/dh/Makefile.ssl	Fri Aug 30 04:40:55 1996
***************
*** 74,80 ****
  	mv -f Makefile.new $(MAKEFILE)
  
  clean:
! 	/bin/rm -f *.o */*.o *.obj lib tags core .nfs* *.old *.bak fluff
  
  errors:
  	perl $(TOP)/util/err-ins.pl $(ERR).err $(ERR).h
--- 74,80 ----
  	mv -f Makefile.new $(MAKEFILE)
  
  clean:
! 	/bin/rm -f *.o */*.o *.obj lib tags core .pure .nfs* *.old *.bak fluff
  
  errors:
  	perl $(TOP)/util/err-ins.pl $(ERR).err $(ERR).h
*** /var/spool/ftp/pub/Crypto/SSL/064/SSLeay-0.6.3/./crypto/dsa/dsa_lib.c	Tue Aug  6 15:57:43 1996
--- ./crypto/dsa/dsa_lib.c	Fri Aug 30 00:58:28 1996
***************
*** 53,65 ****
  #include "dsa.h"
  #include "asn1.h"
  
! char *DSA_version="\0DSA part of SSLeay 0.6.3 06-Aug-1996";
  
  DSA *DSA_new()
  	{
  	DSA *ret;
  
! 	ret=(DSA *)malloc(sizeof(DSA));
  	if (ret == NULL)
  		{
  		DSAerr(DSA_F_DSA_NEW,ERR_R_MALLOC_FAILURE);
--- 53,65 ----
  #include "dsa.h"
  #include "asn1.h"
  
! char *DSA_version="\0DSA part of SSLeay 0.6.4 30-Aug-1996";
  
  DSA *DSA_new()
  	{
  	DSA *ret;
  
! 	ret=(DSA *)Malloc(sizeof(DSA));
  	if (ret == NULL)
  		{
  		DSAerr(DSA_F_DSA_NEW,ERR_R_MALLOC_FAILURE);
***************
*** 88,93 ****
--- 88,100 ----
  
  	i=CRYPTO_add(&r->references,-1,CRYPTO_LOCK_DSA);
  	if (i > 0) return;
+ #ifdef REF_CHECK
+ 	if (i < 0)
+ 		{
+ 		fprintf(stderr,"DSA_free, bad reference count\n");
+ 		abort();
+ 		}
+ #endif
  
  	if (r->x != NULL) BN_clear_free(r->x);
  	if (r->y != NULL) BN_clear_free(r->y);
***************
*** 97,103 ****
  /*	if (r->dmp1 != NULL) BN_clear_free(r->dmp1);
  	if (r->dmq1 != NULL) BN_clear_free(r->dmq1);
  	if (r->iqmp != NULL) BN_clear_free(r->iqmp);*/
! 	free(r);
  	}
  
  int DSA_size(r)
--- 104,110 ----
  /*	if (r->dmp1 != NULL) BN_clear_free(r->dmp1);
  	if (r->dmq1 != NULL) BN_clear_free(r->dmq1);
  	if (r->iqmp != NULL) BN_clear_free(r->iqmp);*/
! 	Free(r);
  	}
  
  int DSA_size(r)
*** /var/spool/ftp/pub/Crypto/SSL/064/SSLeay-0.6.3/./crypto/dsa/Makefile.ssl	Thu Aug  8 01:54:24 1996
--- ./crypto/dsa/Makefile.ssl	Fri Aug 30 04:40:55 1996
***************
*** 74,80 ****
  	mv -f Makefile.new $(MAKEFILE)
  
  clean:
! 	/bin/rm -f *.o */*.o *.obj lib tags core .nfs* *.old *.bak fluff
  
  errors:
  	perl $(TOP)/util/err-ins.pl $(ERR).err $(ERR).h
--- 74,80 ----
  	mv -f Makefile.new $(MAKEFILE)
  
  clean:
! 	/bin/rm -f *.o */*.o *.obj lib tags core .pure .nfs* *.old *.bak fluff
  
  errors:
  	perl $(TOP)/util/err-ins.pl $(ERR).err $(ERR).h
*** /var/spool/ftp/pub/Crypto/SSL/064/SSLeay-0.6.3/./crypto/error/err.c	Wed Jul 24 15:42:38 1996
--- ./crypto/error/err.c	Thu Aug 29 23:50:30 1996
***************
*** 111,117 ****
  {ERR_R_ASN1_LIB				,"ASN1 lib"},
  {ERR_R_CONF_LIB				,"CONF lib"},
  {ERR_R_SSL_LIB				,"SSL lib"},
! {ERR_R_MALLOC_FAILURE			,"malloc failure"},
  {ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED	,"called a fuction you should not call"},
  {0,NULL},
  	};
--- 111,117 ----
  {ERR_R_ASN1_LIB				,"ASN1 lib"},
  {ERR_R_CONF_LIB				,"CONF lib"},
  {ERR_R_SSL_LIB				,"SSL lib"},
! {ERR_R_MALLOC_FAILURE			,"Malloc failure"},
  {ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED	,"called a fuction you should not call"},
  {0,NULL},
  	};
***************
*** 477,488 ****
  	{
  	ERR_STATE *p,tmp;
  
  	if (pid == 0)
  		pid=(unsigned long)CRYPTO_thread_id();
  	tmp.pid=pid;
  	CRYPTO_w_lock(CRYPTO_LOCK_ERR);
  	p=(ERR_STATE *)lh_retrieve(thread_hash,(char *)&tmp);
! 	if (p != NULL) free(p);
  	CRYPTO_w_unlock(CRYPTO_LOCK_ERR);
  	}
  
--- 477,490 ----
  	{
  	ERR_STATE *p,tmp;
  
+ 	if (thread_hash == NULL)
+ 		return;
  	if (pid == 0)
  		pid=(unsigned long)CRYPTO_thread_id();
  	tmp.pid=pid;
  	CRYPTO_w_lock(CRYPTO_LOCK_ERR);
  	p=(ERR_STATE *)lh_retrieve(thread_hash,(char *)&tmp);
! 	if (p != NULL) Free(p);
  	CRYPTO_w_unlock(CRYPTO_LOCK_ERR);
  	}
  
***************
*** 518,524 ****
  	/* ret == the error state, if NULL, make a new one */
  	if (ret == NULL)
  		{
! 		ret=(ERR_STATE *)malloc(sizeof(ERR_STATE));
  		if (ret == NULL) return(&fallback);
  		ret->pid=pid;
  		ret->top=0;
--- 520,526 ----
  	/* ret == the error state, if NULL, make a new one */
  	if (ret == NULL)
  		{
! 		ret=(ERR_STATE *)Malloc(sizeof(ERR_STATE));
  		if (ret == NULL) return(&fallback);
  		ret->pid=pid;
  		ret->top=0;
***************
*** 527,533 ****
  		tmpp=(ERR_STATE *)lh_insert(thread_hash,(char *)ret);
  		CRYPTO_w_unlock(CRYPTO_LOCK_ERR);
  		if (tmpp != NULL) /* old entry - should not happen */
! 			free(tmpp);
  		}
  	return(ret);
  	}
--- 529,535 ----
  		tmpp=(ERR_STATE *)lh_insert(thread_hash,(char *)ret);
  		CRYPTO_w_unlock(CRYPTO_LOCK_ERR);
  		if (tmpp != NULL) /* old entry - should not happen */
! 			Free(tmpp);
  		}
  	return(ret);
  	}
*** /var/spool/ftp/pub/Crypto/SSL/064/SSLeay-0.6.3/./crypto/error/Makefile.ssl	Thu Aug  8 01:54:26 1996
--- ./crypto/error/Makefile.ssl	Fri Aug 30 04:40:57 1996
***************
*** 72,78 ****
  	mv -f Makefile.new $(MAKEFILE)
  
  clean:
! 	/bin/rm -f *.o *.obj lib tags core .nfs* *.old *.bak fluff
  
  errors:
  
--- 72,78 ----
  	mv -f Makefile.new $(MAKEFILE)
  
  clean:
! 	/bin/rm -f *.o *.obj lib tags core .pure .nfs* *.old *.bak fluff
  
  errors:
  
*** /var/spool/ftp/pub/Crypto/SSL/064/SSLeay-0.6.3/./crypto/evp/bio_b64.c	Wed Jul 17 16:45:49 1996
--- ./crypto/evp/bio_b64.c	Thu Aug 29 23:50:30 1996
***************
*** 103,109 ****
  	{
  	BIO_B64_CTX *ctx;
  
! 	ctx=(BIO_B64_CTX *)malloc(sizeof(BIO_B64_CTX));
  	if (ctx == NULL) return(0);
  	ctx
  
--- 103,109 ----
  	{
  	BIO_B64_CTX *ctx;
  
! 	ctx=(BIO_B64_CTX *)Malloc(sizeof(BIO_B64_CTX));
  	if (ctx == NULL) return(0);
  	ctx
  
***************
*** 117,123 ****
  BIO *a;
  	{
  	if (a == NULL) return(0);
! 	free(a->ptr);
  	a->ptr=NULL;
  	a->init=0;
  	a->flags=0;
--- 117,123 ----
  BIO *a;
  	{
  	if (a == NULL) return(0);
! 	Free(a->ptr);
  	a->ptr=NULL;
  	a->init=0;
  	a->flags=0;
*** /var/spool/ftp/pub/Crypto/SSL/064/SSLeay-0.6.3/./crypto/evp/bio_enc.c	Wed Jul 17 16:45:49 1996
--- ./crypto/evp/bio_enc.c	Thu Aug 29 23:50:30 1996
***************
*** 102,108 ****
  	{
  	BIO_MD_CTX *ctx;
  
! 	ctx=(BIO_MD_CTX *)malloc(sizeof(BIO_MD_CTX));
  	if (ctx == NULL) return(0);
  
  	bi->init=0;
--- 102,108 ----
  	{
  	BIO_MD_CTX *ctx;
  
! 	ctx=(BIO_MD_CTX *)Malloc(sizeof(BIO_MD_CTX));
  	if (ctx == NULL) return(0);
  
  	bi->init=0;
***************
*** 115,121 ****
  BIO *a;
  	{
  	if (a == NULL) return(0);
! 	free(a->ptr);
  	a->ptr=NULL;
  	a->init=0;
  	a->flags=0;
--- 115,121 ----
  BIO *a;
  	{
  	if (a == NULL) return(0);
! 	Free(a->ptr);
  	a->ptr=NULL;
  	a->init=0;
  	a->flags=0;
*** /var/spool/ftp/pub/Crypto/SSL/064/SSLeay-0.6.3/./crypto/evp/bio_md.c	Wed Jul 17 16:45:49 1996
--- ./crypto/evp/bio_md.c	Thu Aug 29 23:50:30 1996
***************
*** 94,100 ****
  	{
  	BIO_F_MD_CTX *ctx;
  
! 	ctx=(BIO_F_MD_CTX *)malloc(sizeof(BIO_F_MD_CTX));
  	if (ctx == NULL) return(0);
  
  	bi->init=0;
--- 94,100 ----
  	{
  	BIO_F_MD_CTX *ctx;
  
! 	ctx=(BIO_F_MD_CTX *)Malloc(sizeof(BIO_F_MD_CTX));
  	if (ctx == NULL) return(0);
  
  	bi->init=0;
***************
*** 107,113 ****
  BIO *a;
  	{
  	if (a == NULL) return(0);
! 	free(a->ptr);
  	a->ptr=NULL;
  	a->init=0;
  	a->flags=0;
--- 107,113 ----
  BIO *a;
  	{
  	if (a == NULL) return(0);
! 	Free(a->ptr);
  	a->ptr=NULL;
  	a->init=0;
  	a->flags=0;
*** /var/spool/ftp/pub/Crypto/SSL/064/SSLeay-0.6.3/./crypto/evp/evp_enc.c	Tue Aug  6 15:57:44 1996
--- ./crypto/evp/evp_enc.c	Fri Aug 30 00:58:29 1996
***************
*** 49,55 ****
  #include "cryptlib.h"
  #include "envelope.h"
  
! char *EVP_version="EVP part of SSLeay 0.6.3 06-Aug-1996";
  
  void EVP_CipherInit(ctx,data,key,iv,enc)
  EVP_CIPHER_CTX *ctx;
--- 49,55 ----
  #include "cryptlib.h"
  #include "envelope.h"
  
! char *EVP_version="EVP part of SSLeay 0.6.4 30-Aug-1996";
  
  void EVP_CipherInit(ctx,data,key,iv,enc)
  EVP_CIPHER_CTX *ctx;
*** /var/spool/ftp/pub/Crypto/SSL/064/SSLeay-0.6.3/./crypto/evp/e_cbc_r2.c	Wed Jul 17 16:45:50 1996
--- ./crypto/evp/e_cbc_r2.c	Thu Aug 29 23:50:30 1996
***************
*** 85,91 ****
  		memcpy(&(ctx->c.rc2_cbc.oiv[0]),iv,8);
  	memcpy(&(ctx->c.rc2_cbc.iv[0]),&(ctx->c.rc2_cbc.oiv[0]),8);
  	if (key != NULL)
! 		RC2_set_key(&(ctx->c.rc2_cbc.ks),EVP_RC2_KEY_SIZE,key);
  	}
  
  static void rc2_cbc_cipher(ctx,out,in,inl)
--- 85,92 ----
  		memcpy(&(ctx->c.rc2_cbc.oiv[0]),iv,8);
  	memcpy(&(ctx->c.rc2_cbc.iv[0]),&(ctx->c.rc2_cbc.oiv[0]),8);
  	if (key != NULL)
! 		RC2_set_key(&(ctx->c.rc2_cbc.ks),EVP_RC2_KEY_SIZE,key,
! 			EVP_RC2_KEY_SIZE*8);
  	}
  
  static void rc2_cbc_cipher(ctx,out,in,inl)
*** /var/spool/ftp/pub/Crypto/SSL/064/SSLeay-0.6.3/./crypto/evp/e_cfb_r2.c	Wed Jul 17 16:45:50 1996
--- ./crypto/evp/e_cfb_r2.c	Thu Aug 29 23:50:30 1996
***************
*** 87,93 ****
  		memcpy(&(ctx->c.rc2_cfb.oiv[0]),iv,8);
  	memcpy(&(ctx->c.rc2_cfb.iv[0]),&(ctx->c.rc2_cfb.oiv[0]),8);
  	if (key != NULL)
! 		RC2_set_key(&(ctx->c.rc2_cfb.ks),RC2_KEY_LENGTH,key);
  	}
  
  static void rc2_cfb_cipher(ctx,out,in,inl)
--- 87,94 ----
  		memcpy(&(ctx->c.rc2_cfb.oiv[0]),iv,8);
  	memcpy(&(ctx->c.rc2_cfb.iv[0]),&(ctx->c.rc2_cfb.oiv[0]),8);
  	if (key != NULL)
! 		RC2_set_key(&(ctx->c.rc2_cfb.ks),EVP_RC2_KEY_SIZE,key,
! 			EVP_RC2_KEY_SIZE*8);
  	}
  
  static void rc2_cfb_cipher(ctx,out,in,inl)
*** /var/spool/ftp/pub/Crypto/SSL/064/SSLeay-0.6.3/./crypto/evp/e_ecb_r2.c	Wed Jul 17 16:45:50 1996
--- ./crypto/evp/e_ecb_r2.c	Thu Aug 29 23:50:30 1996
***************
*** 82,88 ****
  unsigned char *iv;
  	{
  	if (key != NULL)
! 		RC2_set_key(&(ctx->c.rc2_ecb.ks),EVP_RC2_KEY_SIZE,key);
  	}
  
  static void rc2_ecb_cipher(ctx,out,in,inl)
--- 82,89 ----
  unsigned char *iv;
  	{
  	if (key != NULL)
! 		RC2_set_key(&(ctx->c.rc2_ecb.ks),EVP_RC2_KEY_SIZE,key,
! 			EVP_RC2_KEY_SIZE*8);
  	}
  
  static void rc2_ecb_cipher(ctx,out,in,inl)
*** /var/spool/ftp/pub/Crypto/SSL/064/SSLeay-0.6.3/./crypto/evp/e_ofb_r2.c	Wed Jul 17 16:45:51 1996
--- ./crypto/evp/e_ofb_r2.c	Thu Aug 29 23:50:30 1996
***************
*** 87,93 ****
  		memcpy(&(ctx->c.rc2_cfb.oiv[0]),iv,8);
  	memcpy(&(ctx->c.rc2_cfb.iv[0]),&(ctx->c.rc2_cfb.oiv[0]),8);
  	if (key != NULL)
! 		RC2_set_key(&(ctx->c.rc2_cfb.ks),EVP_RC2_KEY_SIZE,key);
  	}
  
  static void rc2_ofb_cipher(ctx,out,in,inl)
--- 87,94 ----
  		memcpy(&(ctx->c.rc2_cfb.oiv[0]),iv,8);
  	memcpy(&(ctx->c.rc2_cfb.iv[0]),&(ctx->c.rc2_cfb.oiv[0]),8);
  	if (key != NULL)
! 		RC2_set_key(&(ctx->c.rc2_cfb.ks),EVP_RC2_KEY_SIZE,key,
! 			EVP_RC2_KEY_SIZE*8);
  	}
  
  static void rc2_ofb_cipher(ctx,out,in,inl)
*** /var/spool/ftp/pub/Crypto/SSL/064/SSLeay-0.6.3/./crypto/evp/Makefile.ssl	Thu Aug  8 01:54:27 1996
--- ./crypto/evp/Makefile.ssl	Fri Aug 30 04:40:58 1996
***************
*** 91,97 ****
  	mv -f Makefile.new $(MAKEFILE)
  
  clean:
! 	/bin/rm -f *.o *.obj lib tags core .nfs* *.old *.bak fluff
  
  errors:
  	perl $(TOP)/util/err-ins.pl $(ERR).err $(ERR).h
--- 91,97 ----
  	mv -f Makefile.new $(MAKEFILE)
  
  clean:
! 	/bin/rm -f *.o *.obj lib tags core .pure .nfs* *.old *.bak fluff
  
  errors:
  	perl $(TOP)/util/err-ins.pl $(ERR).err $(ERR).h
*** /var/spool/ftp/pub/Crypto/SSL/064/SSLeay-0.6.3/./crypto/evp/p_lib.c	Tue Jul 23 21:52:31 1996
--- ./crypto/evp/p_lib.c	Thu Aug 29 23:50:30 1996
***************
*** 69,75 ****
  	{
  	EVP_PKEY *ret;
  
! 	ret=(EVP_PKEY *)malloc(sizeof(EVP_PKEY));
  	if (ret == NULL)
  		{
  		EVPerr(EVP_F_EVP_PKEY_NEW,ERR_R_MALLOC_FAILURE);
--- 69,75 ----
  	{
  	EVP_PKEY *ret;
  
! 	ret=(EVP_PKEY *)Malloc(sizeof(EVP_PKEY));
  	if (ret == NULL)
  		{
  		EVPerr(EVP_F_EVP_PKEY_NEW,ERR_R_MALLOC_FAILURE);
***************
*** 91,96 ****
--- 91,103 ----
  
  	i=CRYPTO_add(&x->references,-1,CRYPTO_LOCK_EVP_PKEY);
  	if (i > 0) return;
+ #ifdef REF_CHECK
+ 	if (i < 0)
+ 		{
+ 		fprintf(stderr,"EVP_PKEY_free, bad reference count\n");
+ 		abort();
+ 		}
+ #endif
  
  	switch (x->type)
  		{
***************
*** 107,111 ****
  		DH_free(x->pkey.dh);
  		break;
  		}
! 	free((char *)x);
  	}
--- 114,118 ----
  		DH_free(x->pkey.dh);
  		break;
  		}
! 	Free((char *)x);
  	}
*** /var/spool/ftp/pub/Crypto/SSL/064/SSLeay-0.6.3/./crypto/evp/p_open.c	Wed Jul 17 16:45:52 1996
--- ./crypto/evp/p_open.c	Thu Aug 29 23:50:30 1996
***************
*** 72,78 ****
                  }
  
  	size=RSA_size(priv->pkey.rsa);
! 	key=(unsigned char *)malloc(size+2);
  	if (key == NULL)
  		{
  		/* ERROR */
--- 72,78 ----
                  }
  
  	size=RSA_size(priv->pkey.rsa);
! 	key=(unsigned char *)Malloc(size+2);
  	if (key == NULL)
  		{
  		/* ERROR */
***************
*** 92,98 ****
  	ret=1;
  err:
  	if (key != NULL) memset(key,0,size);
! 	free(key);
  	return(ret);
  	}
  
--- 92,98 ----
  	ret=1;
  err:
  	if (key != NULL) memset(key,0,size);
! 	Free(key);
  	return(ret);
  	}
  
*** /var/spool/ftp/pub/Crypto/SSL/064/SSLeay-0.6.3/./crypto/evp/p_s.c	Wed Jul 17 16:45:52 1996
--- ./crypto/evp/p_s.c	Thu Aug 29 23:50:30 1996
***************
*** 114,120 ****
  		EVPerr(EVP_F_EVP_SIGNFINAL,EVP_R_DIGEST_TOO_BIG_FOR_RSA_KEY);
  		return(0);
  		}
! 	s=(unsigned char *)malloc((unsigned int)j+1);
  	if (s == NULL)
  		{ EVPerr(EVP_F_EVP_SIGNFINAL,ERR_R_MALLOC_FAILURE); return(0); }
  	p=s;
--- 114,120 ----
  		EVPerr(EVP_F_EVP_SIGNFINAL,EVP_R_DIGEST_TOO_BIG_FOR_RSA_KEY);
  		return(0);
  		}
! 	s=(unsigned char *)Malloc((unsigned int)j+1);
  	if (s == NULL)
  		{ EVPerr(EVP_F_EVP_SIGNFINAL,ERR_R_MALLOC_FAILURE); return(0); }
  	p=s;
***************
*** 126,131 ****
  		*siglen=i;
  
  	memset(s,0,(unsigned int)j+1);
! 	free(s);
  	return(ret);
  	}
--- 126,131 ----
  		*siglen=i;
  
  	memset(s,0,(unsigned int)j+1);
! 	Free(s);
  	return(ret);
  	}
*** /var/spool/ftp/pub/Crypto/SSL/064/SSLeay-0.6.3/./crypto/idea/i_ecb.c	Tue Aug  6 15:57:41 1996
--- ./crypto/idea/i_ecb.c	Fri Aug 30 00:58:28 1996
***************
*** 48,54 ****
  #include "idea.h"
  #include "idea_lcl.h"
  
! char *IDEA_version="IDEA part of SSLeay 0.6.3 06-Aug-1996";
  
  char *idea_options()
  	{
--- 48,54 ----
  #include "idea.h"
  #include "idea_lcl.h"
  
! char *IDEA_version="IDEA part of SSLeay 0.6.4 30-Aug-1996";
  
  char *idea_options()
  	{
*** /var/spool/ftp/pub/Crypto/SSL/064/SSLeay-0.6.3/./crypto/idea/Makefile.ssl	Thu Aug  8 01:54:23 1996
--- ./crypto/idea/Makefile.ssl	Fri Aug 30 04:40:54 1996
***************
*** 72,78 ****
  	mv -f Makefile.new $(MAKEFILE)
  
  clean:
! 	/bin/rm -f *.o *.obj lib tags core .nfs* *.old *.bak fluff
  
  errors:
  
--- 72,78 ----
  	mv -f Makefile.new $(MAKEFILE)
  
  clean:
! 	/bin/rm -f *.o *.obj lib tags core .pure .nfs* *.old *.bak fluff
  
  errors:
  
*** /var/spool/ftp/pub/Crypto/SSL/064/SSLeay-0.6.3/./crypto/lhash/lhash.c	Tue Aug  6 15:57:41 1996
--- ./crypto/lhash/lhash.c	Fri Aug 30 00:58:28 1996
***************
*** 45,51 ****
   * [including the GNU Public Licence.]
   */
  
! char *lh_version="lhash part of SSLeay 0.6.3 06-Aug-1996";
  
  /* Code for dynamic hash table routines
   * Author - Eric Young v 2.0
--- 45,51 ----
   * [including the GNU Public Licence.]
   */
  
! char *lh_version="lhash part of SSLeay 0.6.4 30-Aug-1996";
  
  /* Code for dynamic hash table routines
   * Author - Eric Young v 2.0
*** /var/spool/ftp/pub/Crypto/SSL/064/SSLeay-0.6.3/./crypto/lhash/lh_test.c	Wed Jul 17 16:45:53 1996
--- ./crypto/lhash/lh_test.c	Thu Aug 29 23:50:30 1996
***************
*** 66,72 ****
  		if (buf[0] == '\0') break;
  		buf[256]='\0';
  		i=strlen(buf);
! 		p=malloc(i+1);
  		memcpy(p,buf,i+1);
  		lh_insert(conf,p);
  		}
--- 66,72 ----
  		if (buf[0] == '\0') break;
  		buf[256]='\0';
  		i=strlen(buf);
! 		p=Malloc(i+1);
  		memcpy(p,buf,i+1);
  		lh_insert(conf,p);
  		}
*** /var/spool/ftp/pub/Crypto/SSL/064/SSLeay-0.6.3/./crypto/lhash/Makefile.ssl	Thu Aug  8 01:54:25 1996
--- ./crypto/lhash/Makefile.ssl	Fri Aug 30 04:40:56 1996
***************
*** 72,78 ****
  	mv -f Makefile.new $(MAKEFILE)
  
  clean:
! 	/bin/rm -f *.o *.obj lib tags core .nfs* *.old *.bak fluff
  
  errors:
  
--- 72,78 ----
  	mv -f Makefile.new $(MAKEFILE)
  
  clean:
! 	/bin/rm -f *.o *.obj lib tags core .pure .nfs* *.old *.bak fluff
  
  errors:
  
*** /dev/null	Fri Aug 30 04:16:48 1996
--- ./crypto/libvms.com	Thu Aug 29 23:50:26 1996
***************
*** 0 ****
--- 1,31 ----
+ $!
+ $! Compile crypto.c as several subset modules and insert in crypto-xxx.olb.
+ $! If P1 is specifed, it specifies alternate list of subsets to compile.
+ $!
+ $ libname = "CRYPTO-AXP.OLB"
+ $ subset_list = "LIB,ASN1,BN,BUFFER,CONF,DES,DH,DSA,ERROR,EVP,IDEA,LHASH,MD," + -
+ 	"METH,OBJECTS,PEM,RAND,RC,RSA,SHA,STACK,TXT_DB,X509"
+ $ if p1 .nes. "" then subset_list = p1
+ $!
+ $ if f$getsyi("CPU") .lt. 128 then libname = "CRYPTO-VAX.OLB"
+ $ if f$search(libname) .eqs. "" then library/create/object/log 'libname'
+ $!
+ $ cc = "cc/include=[-.include]/prefix=all" + P2
+ $!
+ $ i = 0
+ $ next_subset:
+ $    subset = f$element(i,",",subset_list)
+ $    if subset .eqs. "," then goto done
+ $    i = i + 1
+ $    create crypto_'subset'.subset
+ #include "crypto.c"
+ $    ofile = "sys$disk:[]crypto_" + subset + ".obj"
+ $    on warning then goto next_subset
+ $    write sys$output "Compiling ", ofile
+ $    cc /object='ofile' crypto_'subset'.subset -
+ 	/define=(CRYPTO_SUBSET,CRYPTO_'subset'_SUBSET)
+ $    library/replace/log 'libname'/module=CRYPTO_'subset' 'ofile'
+ $    goto next_subset
+ $!
+ $ done:
+ $ exit
*** /var/spool/ftp/pub/Crypto/SSL/064/SSLeay-0.6.3/./crypto/Makefile.ssl	Thu Aug  8 01:54:21 1996
--- ./crypto/Makefile.ssl	Fri Aug 30 04:40:50 1996
***************
*** 35,42 ****
  GENERAL=Makefile README
  
  LIB= $(TOP)/libcrypto.a
! LIBSRC=	cryptlib.c
! LIBOBJ= cryptlib.o
  
  SRC= $(LIBSRC)
  
--- 35,42 ----
  GENERAL=Makefile README
  
  LIB= $(TOP)/libcrypto.a
! LIBSRC=	cryptlib.c mem.c
! LIBOBJ= cryptlib.o mem.o
  
  SRC= $(LIBSRC)
  
***************
*** 128,134 ****
  	done;
  
  clean:
! 	/bin/rm -f *.o */*.o *.obj llib tags core .nfs* *.old *.bak fluff
  	@for i in $(SDIRS) ;\
  	do \
  	(cd $$i; echo "making clean in $$i..."; \
--- 128,134 ----
  	done;
  
  clean:
! 	/bin/rm -f *.o */*.o *.obj llib tags core .pure .nfs* *.old *.bak fluff
  	@for i in $(SDIRS) ;\
  	do \
  	(cd $$i; echo "making clean in $$i..."; \
*** /var/spool/ftp/pub/Crypto/SSL/064/SSLeay-0.6.3/./crypto/md/Makefile.ssl	Thu Aug  8 01:54:21 1996
--- ./crypto/md/Makefile.ssl	Fri Aug 30 04:40:51 1996
***************
*** 72,78 ****
  	mv -f Makefile.new $(MAKEFILE)
  
  clean:
! 	/bin/rm -f *.o *.obj lib tags core .nfs* *.old *.bak fluff
  
  errors:
  
--- 72,78 ----
  	mv -f Makefile.new $(MAKEFILE)
  
  clean:
! 	/bin/rm -f *.o *.obj lib tags core .pure .nfs* *.old *.bak fluff
  
  errors:
  
*** /var/spool/ftp/pub/Crypto/SSL/064/SSLeay-0.6.3/./crypto/md/md2_dgst.c	Tue Aug  6 15:57:42 1996
--- ./crypto/md/md2_dgst.c	Fri Aug 30 00:58:28 1996
***************
*** 50,56 ****
  #include <string.h>
  #include "md2.h"
  
! char *MD2_version="MD2 part of SSLeay 0.6.3 06-Aug-1996";
  
  /* Implemented from RFC1319 The MD2 Message-Digest Algorithm
   */
--- 50,56 ----
  #include <string.h>
  #include "md2.h"
  
! char *MD2_version="MD2 part of SSLeay 0.6.4 30-Aug-1996";
  
  /* Implemented from RFC1319 The MD2 Message-Digest Algorithm
   */
*** /var/spool/ftp/pub/Crypto/SSL/064/SSLeay-0.6.3/./crypto/md/md5_dgst.c	Tue Aug  6 15:57:42 1996
--- ./crypto/md/md5_dgst.c	Fri Aug 30 00:58:28 1996
***************
*** 48,54 ****
  #include <stdio.h>
  #include "md5_locl.h"
  
! char *MD5_version="MD5 part of SSLeay 0.6.3 06-Aug-1996";
  
  /* Implemented from RFC1321 The MD5 Message-Digest Algorithm
   */
--- 48,54 ----
  #include <stdio.h>
  #include "md5_locl.h"
  
! char *MD5_version="MD5 part of SSLeay 0.6.4 30-Aug-1996";
  
  /* Implemented from RFC1321 The MD5 Message-Digest Algorithm
   */
*** /var/spool/ftp/pub/Crypto/SSL/064/SSLeay-0.6.3/./crypto/md/md5_locl.h	Wed Jul 17 16:45:55 1996
--- ./crypto/md/md5_locl.h	Thu Aug 29 23:50:30 1996
***************
*** 125,131 ****
  #define Endian_Reverse32(a) \
  	{ \
  	unsigned long l=(a); \
! 	((ROTATE(l,8)&0xFF00FF00)|(ROTATE(l,24)&0x00FF00FF)); \
  	}
  #else
  /* 6 instructions with rotate instruction, else 8 */
--- 125,131 ----
  #define Endian_Reverse32(a) \
  	{ \
  	unsigned long l=(a); \
! 	(a)=((ROTATE(l,8)&0x00FF00FF)|(ROTATE(l,24)&0xFF00FF00)); \
  	}
  #else
  /* 6 instructions with rotate instruction, else 8 */
*** /dev/null	Fri Aug 30 04:16:48 1996
--- ./crypto/mem.c	Thu Aug 29 23:50:26 1996
***************
*** 0 ****
--- 1,212 ----
+ #include <stdio.h>
+ #include <stdlib.h>
+ #include "buffer.h"
+ #include "lhash.h"
+ #include "cryptlib.h"
+ 
+ static int mh_mode=CRYPTO_MEM_CHECK_OFF;
+ 
+ static LHASH *mh=NULL;
+ 
+ typedef struct mem_st
+ 	{
+ 	char *addr;
+ 	int num;
+ 	char *file;
+ 	int line;
+ 	} MEM;
+ 
+ int CRYPTO_mem_ctrl(mode)
+ int mode;
+ 	{
+ 	int ret=mh_mode;
+ 
+ 	CRYPTO_w_lock(CRYPTO_LOCK_MALLOC);
+ 	switch (mode)
+ 		{
+ 	case CRYPTO_MEM_CHECK_ON:
+ 		mh_mode|=CRYPTO_MEM_CHECK_ON;
+ 		break;
+ 	case CRYPTO_MEM_CHECK_OFF:
+ 		mh_mode&= ~CRYPTO_MEM_CHECK_ON;
+ 		break;
+ 	default:
+ 		break;
+ 		}
+ 	CRYPTO_w_unlock(CRYPTO_LOCK_MALLOC);
+ 	return(ret);
+ 	}
+ 
+ static int mem_cmp(a,b)
+ MEM *a,*b;
+ 	{
+ 	return(a->addr - b->addr);
+ 	}
+ 
+ static unsigned long mem_hash(a)
+ MEM *a;
+ 	{
+ 	unsigned long ret;
+ 
+ 	ret=(unsigned long)a->addr;
+ 
+ 	ret=ret*17851+(ret>>14)*7+(ret>>4)*251;
+ 	return(ret);
+ 	}
+ 
+ char *CRYPTO_malloc(num,file,line)
+ int num;
+ char *file;
+ int line;
+ 	{
+ 	char *ret;
+ 	MEM *m;
+ 
+ 	if ((ret=malloc(num)) == NULL)
+ 		return(NULL);
+ 
+ 	if (mh_mode & CRYPTO_MEM_CHECK_ON)
+ 		{
+ 		if ((m=(MEM *)malloc(sizeof(MEM))) == NULL)
+ 			{
+ 			free(ret);
+ 			return(NULL);
+ 			}
+ 		CRYPTO_w_lock(CRYPTO_LOCK_MALLOC);
+ 		if (mh == NULL)
+ 			{
+ 			if ((mh=lh_new(mem_hash,mem_cmp)) == NULL)
+ 				{
+ 				free(ret);
+ 				free(m);
+ 				return(NULL);
+ 				}
+ 			}
+ 
+ 		m->addr=ret;
+ 		m->file=file;
+ 		m->line=line;
+ 		m->num=num;
+ 		if (lh_insert(mh,(char *)m) != NULL)
+ 			{
+ 			free(m);
+ 			free(ret);
+ 			abort();
+ 			ret=NULL;
+ 			}
+ 		CRYPTO_w_unlock(CRYPTO_LOCK_MALLOC);
+ 		}
+ 	return(ret);
+ 	}
+ 
+ void CRYPTO_free(addr)
+ char *addr;
+ 	{
+ 	MEM m,*mp;
+ 
+ 	if (mh_mode & CRYPTO_MEM_CHECK_ON)
+ 		{
+ 		CRYPTO_w_lock(CRYPTO_LOCK_MALLOC);
+ 		m.addr=addr;
+ 		mp=(MEM *)lh_delete(mh,(char *)&m);
+ 		if (mp != NULL)
+ 			free(mp);
+ 		CRYPTO_w_unlock(CRYPTO_LOCK_MALLOC);
+ 		}
+ 	free(addr);
+ 	}
+ 
+ char *CRYPTO_realloc(addr,num,file,line)
+ char *addr;
+ int num;
+ char *file;
+ int line;
+ 	{
+ 	char *ret;
+ 	MEM m,*mp;
+ 
+ 	ret=realloc(addr,num);
+ 	if (ret == addr) return(ret);
+ 
+ 	if (mh_mode & CRYPTO_MEM_CHECK_ON)
+ 		{
+ 		if (ret == NULL) return(NULL);
+ 		m.addr=addr;
+ 		CRYPTO_w_lock(CRYPTO_LOCK_MALLOC);
+ 		mp=(MEM *)lh_delete(mh,(char *)&m);
+ 		if (mp != NULL)
+ 			{
+ 			mp->addr=ret;
+ 			lh_insert(mh,(char *)mp);
+ 
+ 			if (mp != NULL)
+ 				mp->addr=ret;
+ 			else
+ 				abort();
+ 			}
+ 		CRYPTO_w_unlock(CRYPTO_LOCK_MALLOC);
+ 		}
+ 	return(ret);
+ 	}
+ 
+ typedef struct mem_leak_st
+ 	{
+ 	BIO *bio;
+ 	int chunks;
+ 	long bytes;
+ 	} MEM_LEAK;
+ 
+ static void print_leak(m,l)
+ MEM *m;
+ MEM_LEAK *l;
+ 	{
+ 	char buf[128];
+ 
+ 	sprintf(buf,"file=%s, line=%d, number=%d, address=%08lX\n",
+ 		m->file,m->line,m->num,(long)m->addr);
+ 	BIO_puts(l->bio,buf);
+ 	l->chunks++;
+ 	l->bytes+=m->num;
+ 	}
+ 
+ void CRYPTO_mem_leaks(b)
+ BIO *b;
+ 	{
+ 	MEM_LEAK ml;
+ 	char buf[80];
+ 
+ 	if (mh == NULL) return;
+ 	ml.bio=b;
+ 	ml.bytes=0;
+ 	ml.chunks=0;
+ 	CRYPTO_w_lock(CRYPTO_LOCK_MALLOC);
+ 	lh_doall_arg(mh,(void (*)())print_leak,(char *)&ml);
+ 	CRYPTO_w_unlock(CRYPTO_LOCK_MALLOC);
+ 	if (ml.chunks != 0)
+ 		{
+ 		sprintf(buf,"%ld bytes leaked in %d chunks\n",
+ 			ml.bytes,ml.chunks);
+ 		BIO_puts(b,buf);
+ 		}
+ 	/*
+ 	lh_stats_bio(mh,b);
+         lh_node_stats_bio(mh,b);
+         lh_node_usage_stats_bio(mh,b);
+ 	*/
+ 	}
+ 
+ #ifndef WIN16
+ void CRYPTO_mem_leaks_fp(fp)
+ FILE *fp;
+ 	{
+ 	BIO *b;
+ 
+ 	if (mh == NULL) return;
+ 	if ((b=BIO_new(BIO_s_file())) == NULL)
+ 		return;
+ 	BIO_set_fp(b,fp,BIO_NOCLOSE);
+ 	CRYPTO_mem_leaks(b);
+ 	BIO_free(b);
+ 	}
+ #endif
+ 
*** /var/spool/ftp/pub/Crypto/SSL/064/SSLeay-0.6.3/./crypto/meth/by_dir.c	Wed Jul 17 16:45:55 1996
--- ./crypto/meth/by_dir.c	Thu Aug 29 23:50:30 1996
***************
*** 106,116 ****
  			{
  			dir=(char *)sk_pop(st->data);
  			if (dir == NULL) break;
! 			free(dir);
  			}
  		sk_free(st->data);
  		}
! 	free((char *)st);
  	if (ctx->arg_type != NULL)
  		sk_free(ctx->arg_type);
  	if (ctx->args != NULL)
--- 106,116 ----
  			{
  			dir=(char *)sk_pop(st->data);
  			if (dir == NULL) break;
! 			Free(dir);
  			}
  		sk_free(st->data);
  		}
! 	Free((char *)st);
  	if (ctx->arg_type != NULL)
  		sk_free(ctx->arg_type);
  	if (ctx->args != NULL)
***************
*** 119,125 ****
  			{
  			p=sk_pop(ctx->args);
  			if (p == NULL) break;
! 			free(p);
  			}
  		sk_free(ctx->args);
  		}
--- 119,125 ----
  			{
  			p=sk_pop(ctx->args);
  			if (p == NULL) break;
! 			Free(p);
  			}
  		sk_free(ctx->args);
  		}
***************
*** 143,149 ****
  
  	if ((sk=sk_new_null()) == NULL) goto err;
  
! 	st=(X509_LOOKUP_DIR *)malloc(sizeof(X509_LOOKUP_DIR));
  	ctx->state=(char *)st;
  	if (st == NULL) goto err;
  	st->data=sk;
--- 143,149 ----
  
  	if ((sk=sk_new_null()) == NULL) goto err;
  
! 	st=(X509_LOOKUP_DIR *)Malloc(sizeof(X509_LOOKUP_DIR));
  	ctx->state=(char *)st;
  	if (st == NULL) goto err;
  	st->data=sk;
***************
*** 166,172 ****
  			if (!(sb.st_mode & S_IFDIR)) continue;
  
  			/* ok, seems to be a directory, lets keep it */
! 			d=(char *)malloc(strlen(dir)+1);
  			if (d == NULL) goto err;
  			strcpy(d,dir);
  			if (!sk_push(sk,d)) goto err;
--- 166,172 ----
  			if (!(sb.st_mode & S_IFDIR)) continue;
  
  			/* ok, seems to be a directory, lets keep it */
! 			d=(char *)Malloc(strlen(dir)+1);
  			if (d == NULL) goto err;
  			strcpy(d,dir);
  			if (!sk_push(sk,d)) goto err;
***************
*** 179,185 ****
  		{
  		if (sk != NULL)
  			for (i=0; i<sk_num(sk); i++)
! 				free((X509_INFO *)sk_value(sk,i));
  		}
  	return(ret);
  	}
--- 179,185 ----
  		{
  		if (sk != NULL)
  			for (i=0; i<sk_num(sk); i++)
! 				Free((X509_INFO *)sk_value(sk,i));
  		}
  	return(ret);
  	}
*** /var/spool/ftp/pub/Crypto/SSL/064/SSLeay-0.6.3/./crypto/meth/by_file.c	Tue Jul 23 21:53:00 1996
--- ./crypto/meth/by_file.c	Thu Aug 29 23:50:30 1996
***************
*** 116,122 ****
  		if (st->index[i] != NULL)
  			lh_free(st->index[i]);
  		}
! 	free((char *)st);
  	if (ctx->arg_type != NULL)
  		sk_free(ctx->arg_type);
  	if (ctx->args != NULL)
--- 116,122 ----
  		if (st->index[i] != NULL)
  			lh_free(st->index[i]);
  		}
! 	Free((char *)st);
  	if (ctx->arg_type != NULL)
  		sk_free(ctx->arg_type);
  	if (ctx->args != NULL)
***************
*** 125,131 ****
  			{
  			p=sk_pop(ctx->args);
  			if (p == NULL) break;
! 			free(p);
  			}
  		sk_free(ctx->args);
  		}
--- 125,131 ----
  			{
  			p=sk_pop(ctx->args);
  			if (p == NULL) break;
! 			Free(p);
  			}
  		sk_free(ctx->args);
  		}
***************
*** 150,156 ****
  
  	if ((sk=sk_new_null()) == NULL) goto err;
  
! 	st=(X509_LOOKUP_FILE *)malloc(sizeof(X509_LOOKUP_FILE));
  	ctx->state=(char *)st;
  	if (st == NULL) goto err;
  	for (i=0; i<METH_X509_NUMBER; i++)
--- 150,156 ----
  
  	if ((sk=sk_new_null()) == NULL) goto err;
  
! 	st=(X509_LOOKUP_FILE *)Malloc(sizeof(X509_LOOKUP_FILE));
  	ctx->state=(char *)st;
  	if (st == NULL) goto err;
  	for (i=0; i<METH_X509_NUMBER; i++)
***************
*** 229,235 ****
  				{
  				s=X509_NAME_oneline(xi->x509->cert_info->issuer);
  				fprintf(fp,"X509 issuer :%s\n",s);
! 				free(s);
  				fprintf(fp,"X509 serial :");
  #ifdef undef
  				i2a_ASN1_INTEGER(fp,xi->x509->cert_info->serialNumber);
--- 229,235 ----
  				{
  				s=X509_NAME_oneline(xi->x509->cert_info->issuer);
  				fprintf(fp,"X509 issuer :%s\n",s);
! 				Free(s);
  				fprintf(fp,"X509 serial :");
  #ifdef undef
  				i2a_ASN1_INTEGER(fp,xi->x509->cert_info->serialNumber);
***************
*** 236,248 ****
  #endif
  				s=X509_NAME_oneline(xi->x509->cert_info->subject);
  				fprintf(fp,"X509 subject:%s\n",s);
! 				free(s);
  				}
  			if (xi->crl != NULL)
  				{
  				s=X509_NAME_oneline(xi->crl->crl->issuer);
  				fprintf(fp,"CRL issuer  :%s\n",s);
! 				free(s);
  				}
  			if (xi->x_pkey != NULL)
  				{
--- 236,248 ----
  #endif
  				s=X509_NAME_oneline(xi->x509->cert_info->subject);
  				fprintf(fp,"X509 subject:%s\n",s);
! 				Free(s);
  				}
  			if (xi->crl != NULL)
  				{
  				s=X509_NAME_oneline(xi->crl->crl->issuer);
  				fprintf(fp,"CRL issuer  :%s\n",s);
! 				Free(s);
  				}
  			if (xi->x_pkey != NULL)
  				{
*** /var/spool/ftp/pub/Crypto/SSL/064/SSLeay-0.6.3/./crypto/meth/Makefile.ssl	Thu Aug  8 01:54:29 1996
--- ./crypto/meth/Makefile.ssl	Fri Aug 30 04:40:59 1996
***************
*** 74,80 ****
  	mv -f Makefile.new $(MAKEFILE)
  
  clean:
! 	/bin/rm -f *.o *.obj lib tags core .nfs* *.old *.bak fluff
  
  errors:
  	perl $(TOP)/util/err-ins.pl $(ERR).err $(ERR).h
--- 74,80 ----
  	mv -f Makefile.new $(MAKEFILE)
  
  clean:
! 	/bin/rm -f *.o *.obj lib tags core .pure .nfs* *.old *.bak fluff
  
  errors:
  	perl $(TOP)/util/err-ins.pl $(ERR).err $(ERR).h
*** /var/spool/ftp/pub/Crypto/SSL/064/SSLeay-0.6.3/./crypto/meth/meth_lib.c	Wed Jul 17 16:45:56 1996
--- ./crypto/meth/meth_lib.c	Thu Aug 29 23:50:30 1996
***************
*** 60,66 ****
  		METHerr(METH_F_METH_NEW,METH_R_NO_METH_STRUCTURE_PASSED);
  		goto err;
  		}
! 	if ((ret=(METHOD_CTX *)malloc(sizeof(METHOD_CTX))) == NULL)
  		{
  		METHerr(METH_F_METH_NEW,ERR_R_MALLOC_FAILURE);
  		goto err;
--- 60,66 ----
  		METHerr(METH_F_METH_NEW,METH_R_NO_METH_STRUCTURE_PASSED);
  		goto err;
  		}
! 	if ((ret=(METHOD_CTX *)Malloc(sizeof(METHOD_CTX))) == NULL)
  		{
  		METHerr(METH_F_METH_NEW,ERR_R_MALLOC_FAILURE);
  		goto err;
***************
*** 124,130 ****
  	if (type == METH_FREE)
  		{
  		sk_free(ctx->args);
! 		free(ctx);
  		}
  	return(ret);
  	}
--- 124,130 ----
  	if (type == METH_FREE)
  		{
  		sk_free(ctx->args);
! 		Free(ctx);
  		}
  	return(ret);
  	}
*** /var/spool/ftp/pub/Crypto/SSL/064/SSLeay-0.6.3/./crypto/meth/x509meth.c	Wed Jul 17 16:45:56 1996
--- ./crypto/meth/x509meth.c	Thu Aug 29 23:50:30 1996
***************
*** 124,130 ****
  	METHOD_CTX *m;
  	X_STATE *s;
  
! 	s=(X_STATE *)malloc(sizeof(X_STATE));
  	if (s == NULL)
  		{
  		METHerr(METH_F_X509_METHOD_INIT,ERR_R_MALLOC_FAILURE);
--- 124,130 ----
  	METHOD_CTX *m;
  	X_STATE *s;
  
! 	s=(X_STATE *)Malloc(sizeof(X_STATE));
  	if (s == NULL)
  		{
  		METHerr(METH_F_X509_METHOD_INIT,ERR_R_MALLOC_FAILURE);
***************
*** 135,141 ****
  		lh_new(X509_subject_name_hash,X509_subject_name_cmp);
  	if (s->CA_by_name_cache == NULL)
  		{
! 		free(s);
  		METHerr(METH_F_X509_METHOD_INIT,ERR_R_MALLOC_FAILURE);
  		return(-1);
  		}
--- 135,141 ----
  		lh_new(X509_subject_name_hash,X509_subject_name_cmp);
  	if (s->CA_by_name_cache == NULL)
  		{
! 		Free(s);
  		METHerr(METH_F_X509_METHOD_INIT,ERR_R_MALLOC_FAILURE);
  		return(-1);
  		}
*** /var/spool/ftp/pub/Crypto/SSL/064/SSLeay-0.6.3/./crypto/objects/Makefile.ssl	Thu Aug  8 01:54:27 1996
--- ./crypto/objects/Makefile.ssl	Fri Aug 30 04:40:57 1996
***************
*** 77,83 ****
  	mv -f Makefile.new $(MAKEFILE)
  
  clean:
! 	/bin/rm -f *.o *.obj lib tags core .nfs* *.old *.bak fluff
  
  errors:
  	perl $(TOP)/util/err-ins.pl $(ERR).err $(ERR).h
--- 77,83 ----
  	mv -f Makefile.new $(MAKEFILE)
  
  clean:
! 	/bin/rm -f *.o *.obj lib tags core .pure .nfs* *.old *.bak fluff
  
  errors:
  	perl $(TOP)/util/err-ins.pl $(ERR).err $(ERR).h
*** /var/spool/ftp/pub/Crypto/SSL/064/SSLeay-0.6.3/./crypto/objects/obj_lib.c	Thu Aug  1 11:05:03 1996
--- ./crypto/objects/obj_lib.c	Thu Aug 29 23:50:30 1996
***************
*** 63,69 ****
  		OBJerr(OBJ_F_OBJ_DUP,ERR_R_ASN1_LIB);
  		return(NULL);
  		}
! 	r->data=(unsigned char *)malloc(o->length);
  	if (r->data == NULL)
  		{
  		OBJerr(OBJ_F_OBJ_DUP,ERR_R_MALLOC_FAILURE);
--- 63,69 ----
  		OBJerr(OBJ_F_OBJ_DUP,ERR_R_ASN1_LIB);
  		return(NULL);
  		}
! 	r->data=(unsigned char *)Malloc(o->length);
  	if (r->data == NULL)
  		{
  		OBJerr(OBJ_F_OBJ_DUP,ERR_R_MALLOC_FAILURE);
*** /var/spool/ftp/pub/Crypto/SSL/064/SSLeay-0.6.3/./crypto/pem/Makefile.ssl	Thu Aug  8 01:54:27 1996
--- ./crypto/pem/Makefile.ssl	Fri Aug 30 04:40:58 1996
***************
*** 85,91 ****
  	mv -f Makefile.new $(MAKEFILE)
  
  clean:
! 	/bin/rm -f $(CTX_SIZE) *.o *.obj lib tags core .nfs* *.old *.bak fluff
  
  errors:
  	perl $(TOP)/util/err-ins.pl $(ERR).err $(ERR).org # SPECIAL CASE .org
--- 85,91 ----
  	mv -f Makefile.new $(MAKEFILE)
  
  clean:
! 	/bin/rm -f $(CTX_SIZE) *.o *.obj lib tags core .pure .nfs* *.old *.bak fluff
  
  errors:
  	perl $(TOP)/util/err-ins.pl $(ERR).err $(ERR).org # SPECIAL CASE .org
*** /var/spool/ftp/pub/Crypto/SSL/064/SSLeay-0.6.3/./crypto/pem/pem_info.c	Wed Jul 17 16:45:56 1996
--- ./crypto/pem/pem_info.c	Thu Aug 29 23:50:30 1996
***************
*** 194,202 ****
  		else	{
  			/* unknown */
  			}
! 		if (name != NULL) free(name);
! 		if (header != NULL) free(header);
! 		if (data != NULL) free(data);
  		name=NULL;
  		header=NULL;
  		data=NULL;
--- 194,202 ----
  		else	{
  			/* unknown */
  			}
! 		if (name != NULL) Free(name);
! 		if (header != NULL) Free(header);
! 		if (data != NULL) Free(data);
  		name=NULL;
  		header=NULL;
  		data=NULL;
***************
*** 220,227 ****
  		if (ret != sk) sk_free(ret);
  		}
  		
! 	if (name != NULL) free(name);
! 	if (header != NULL) free(header);
! 	if (data != NULL) free(data);
  	return(ret);
  	}
--- 220,227 ----
  		if (ret != sk) sk_free(ret);
  		}
  		
! 	if (name != NULL) Free(name);
! 	if (header != NULL) Free(header);
! 	if (data != NULL) Free(data);
  	return(ret);
  	}
*** /var/spool/ftp/pub/Crypto/SSL/064/SSLeay-0.6.3/./crypto/pem/pem_lib.c	Tue Aug  6 15:57:42 1996
--- ./crypto/pem/pem_lib.c	Fri Aug 30 00:58:28 1996
***************
*** 60,66 ****
  #include "des.h"
  #endif
  
! char *PEM_version="PEM part of SSLeay 0.6.3 06-Aug-1996";
  
  #define MIN_LENGTH	4
  
--- 60,66 ----
  #include "des.h"
  #endif
  
! char *PEM_version="PEM part of SSLeay 0.6.4 30-Aug-1996";
  
  #define MIN_LENGTH	4
  
***************
*** 212,220 ****
  			 (strcmp(name,PEM_STRING_X509_REQ) == 0))
  			)
  			break;
! 		free(nm);
! 		free(header);
! 		free(data);
  		}
  	if (!PEM_get_EVP_CIPHER_INFO(header,&cipher)) goto err;
  	if (!PEM_do_header(&cipher,data,&len,cb)) goto err;
--- 212,220 ----
  			 (strcmp(name,PEM_STRING_X509_REQ) == 0))
  			)
  			break;
! 		Free(nm);
! 		Free(header);
! 		Free(data);
  		}
  	if (!PEM_get_EVP_CIPHER_INFO(header,&cipher)) goto err;
  	if (!PEM_do_header(&cipher,data,&len,cb)) goto err;
***************
*** 231,239 ****
  	if (ret == NULL)
  		PEMerr(PEM_F_PEM_ASN1_READ_BIO,ERR_R_ASN1_LIB);
  err:
! 	free(nm);
! 	free(header);
! 	free(data);
  	return(ret);
  	}
  
--- 231,239 ----
  	if (ret == NULL)
  		PEMerr(PEM_F_PEM_ASN1_READ_BIO,ERR_R_ASN1_LIB);
  err:
! 	Free(nm);
! 	Free(header);
! 	Free(data);
  	return(ret);
  	}
  
***************
*** 294,300 ****
  
  	dsize=i2d(x,NULL);
  	/* dzise + 8 bytes are needed */
! 	data=(unsigned char *)malloc((unsigned int)dsize+20);
  	if (data == NULL)
  		{
  		PEMerr(PEM_F_PEM_ASN1_WRITE_BIO,ERR_R_MALLOC_FAILURE);
--- 294,300 ----
  
  	dsize=i2d(x,NULL);
  	/* dzise + 8 bytes are needed */
! 	data=(unsigned char *)Malloc((unsigned int)dsize+20);
  	if (data == NULL)
  		{
  		PEMerr(PEM_F_PEM_ASN1_WRITE_BIO,ERR_R_MALLOC_FAILURE);
***************
*** 350,356 ****
  	memset((char *)&ctx,0,sizeof(ctx));
  	memset(buf,0,PEM_BUFSIZE);
  	memset(data,0,(unsigned int)dsize);
! 	free(data);
  	return(ret);
  	}
  
--- 350,356 ----
  	memset((char *)&ctx,0,sizeof(ctx));
  	memset(buf,0,PEM_BUFSIZE);
  	memset(data,0,(unsigned int)dsize);
! 	Free(data);
  	return(ret);
  	}
  
***************
*** 541,547 ****
  			goto err;
  		}
  
! 	buf=(unsigned char *)malloc(PEM_BUFSIZE*8);
  	if (buf == NULL)
  		{
  		reason=ERR_R_MALLOC_FAILURE;
--- 541,547 ----
  			goto err;
  		}
  
! 	buf=(unsigned char *)Malloc(PEM_BUFSIZE*8);
  	if (buf == NULL)
  		{
  		reason=ERR_R_MALLOC_FAILURE;
***************
*** 561,567 ****
  		}
  	EVP_EncodeFinal(&ctx,buf,&outl);
  	if ((outl > 0) && (BIO_write(bp,(char *)buf,outl) != outl)) goto err;
! 	free(buf);
  	if (	(BIO_write(bp,"-----END ",9) != 9) ||
  		(BIO_write(bp,name,nlen) != nlen) ||
  		(BIO_write(bp,"-----\n",6) != 6))
--- 561,567 ----
  		}
  	EVP_EncodeFinal(&ctx,buf,&outl);
  	if ((outl > 0) && (BIO_write(bp,(char *)buf,outl) != outl)) goto err;
! 	Free(buf);
  	if (	(BIO_write(bp,"-----END ",9) != 9) ||
  		(BIO_write(bp,name,nlen) != nlen) ||
  		(BIO_write(bp,"-----\n",6) != 6))
***************
*** 730,738 ****
  	*header=headerB->data;
  	*data=(unsigned char *)dataB->data;
  	*len=bl;
! 	free(nameB);
! 	free(headerB);
! 	free(dataB);
  	return(1);
  err:
  	BUF_MEM_free(nameB);
--- 730,738 ----
  	*header=headerB->data;
  	*data=(unsigned char *)dataB->data;
  	*len=bl;
! 	Free(nameB);
! 	Free(headerB);
! 	Free(dataB);
  	return(1);
  err:
  	BUF_MEM_free(nameB);
*** /var/spool/ftp/pub/Crypto/SSL/064/SSLeay-0.6.3/./crypto/pem/pem_seal.c	Sat Jul 27 13:48:43 1996
--- ./crypto/pem/pem_seal.c	Thu Aug 29 23:50:30 1996
***************
*** 79,85 ****
  		j=RSA_size(pubk[i]->pkey.rsa);
  		if (j > max) max=j;
  		}
! 	s=(char *)malloc(max*2);
  	if (s == NULL)
  		{
  		PEMerr(PEM_F_PEM_SEALINIT,ERR_R_MALLOC_FAILURE);
--- 79,85 ----
  		j=RSA_size(pubk[i]->pkey.rsa);
  		if (j > max) max=j;
  		}
! 	s=(char *)Malloc(max*2);
  	if (s == NULL)
  		{
  		PEMerr(PEM_F_PEM_SEALINIT,ERR_R_MALLOC_FAILURE);
***************
*** 103,109 ****
  
  	ret=npubk;
  err:
! 	if (s != NULL) free(s);
  	memset(key,0,EVP_MAX_KEY_LENGTH);
  	return(ret);
  	}
--- 103,109 ----
  
  	ret=npubk;
  err:
! 	if (s != NULL) Free(s);
  	memset(key,0,EVP_MAX_KEY_LENGTH);
  	return(ret);
  	}
***************
*** 155,161 ****
  		}
  	i=RSA_size(priv->pkey.rsa);
  	if (i < 100) i=100;
! 	s=(unsigned char *)malloc(i*2);
  	if (s == NULL)
  		{
  		PEMerr(PEM_F_PEM_SEALFINAL,ERR_R_MALLOC_FAILURE);
--- 155,161 ----
  		}
  	i=RSA_size(priv->pkey.rsa);
  	if (i < 100) i=100;
! 	s=(unsigned char *)Malloc(i*2);
  	if (s == NULL)
  		{
  		PEMerr(PEM_F_PEM_SEALFINAL,ERR_R_MALLOC_FAILURE);
***************
*** 176,181 ****
  err:
  	memset((char *)&(ctx->md),0,sizeof(ctx->md));
  	memset((char *)&(ctx->cipher),0,sizeof(ctx->cipher));
! 	if (s != NULL) free(s);
  	return(ret);
  	}
--- 176,181 ----
  err:
  	memset((char *)&(ctx->md),0,sizeof(ctx->md));
  	memset((char *)&(ctx->cipher),0,sizeof(ctx->cipher));
! 	if (s != NULL) Free(s);
  	return(ret);
  	}
*** /var/spool/ftp/pub/Crypto/SSL/064/SSLeay-0.6.3/./crypto/pem/pem_sign.c	Wed Jul 17 16:45:57 1996
--- ./crypto/pem/pem_sign.c	Thu Aug 29 23:50:30 1996
***************
*** 64,70 ****
  	int i,ret=0;
  	unsigned int m_len;
  
! 	m=(unsigned char *)malloc(EVP_PKEY_size(pkey)+2);
  	if (m == NULL)
  		{
  		PEMerr(PEM_F_PEM_SIGNFINAL,ERR_R_MALLOC_FAILURE);
--- 64,70 ----
  	int i,ret=0;
  	unsigned int m_len;
  
! 	m=(unsigned char *)Malloc(EVP_PKEY_size(pkey)+2);
  	if (m == NULL)
  		{
  		PEMerr(PEM_F_PEM_SIGNFINAL,ERR_R_MALLOC_FAILURE);
***************
*** 78,83 ****
  	ret=1;
  err:
  	/* ctx has been zeroed by EVP_SignFinal() */
! 	if (m != NULL) free(m);
  	return(ret);
  	}
--- 78,83 ----
  	ret=1;
  err:
  	/* ctx has been zeroed by EVP_SignFinal() */
! 	if (m != NULL) Free(m);
  	return(ret);
  	}
*** /var/spool/ftp/pub/Crypto/SSL/064/SSLeay-0.6.3/./crypto/pkcs7/Makefile.ssl	Thu Aug  8 01:54:30 1996
--- ./crypto/pkcs7/Makefile.ssl	Fri Aug 30 04:41:00 1996
***************
*** 80,86 ****
  	mv -f Makefile.new $(MAKEFILE)
  
  clean:
! 	/bin/rm -f *.o *.obj lib tags core .nfs* *.old *.bak fluff
  
  errors:
  
--- 80,86 ----
  	mv -f Makefile.new $(MAKEFILE)
  
  clean:
! 	/bin/rm -f *.o *.obj lib tags core .pure .nfs* *.old *.bak fluff
  
  errors:
  
*** /var/spool/ftp/pub/Crypto/SSL/064/SSLeay-0.6.3/./crypto/rand/Makefile.ssl	Thu Aug  8 01:54:26 1996
--- ./crypto/rand/Makefile.ssl	Fri Aug 30 04:40:57 1996
***************
*** 72,78 ****
  	mv -f Makefile.new $(MAKEFILE)
  
  clean:
! 	/bin/rm -f *.o *.obj lib tags core .nfs* *.old *.bak fluff
  
  errors:
  
--- 72,78 ----
  	mv -f Makefile.new $(MAKEFILE)
  
  clean:
! 	/bin/rm -f *.o *.obj lib tags core .pure .nfs* *.old *.bak fluff
  
  errors:
  
*** /var/spool/ftp/pub/Crypto/SSL/064/SSLeay-0.6.3/./crypto/rand/md5_rand.c	Tue Aug  6 15:57:44 1996
--- ./crypto/rand/md5_rand.c	Fri Aug 30 00:58:29 1996
***************
*** 71,77 ****
  static unsigned char md[MD5_DIGEST_LENGTH];
  static int count=0;
  
! char *RAND_version="RAND part of SSLeay 0.6.3 06-Aug-1996";
  
  void RAND_cleanup()
  	{
--- 71,77 ----
  static unsigned char md[MD5_DIGEST_LENGTH];
  static int count=0;
  
! char *RAND_version="RAND part of SSLeay 0.6.4 30-Aug-1996";
  
  void RAND_cleanup()
  	{
***************
*** 86,92 ****
  unsigned char *buf;
  int num;
  	{
! 	int i,j,k;
  	MD5_CTX m;
  
  #ifdef NORAND
--- 86,92 ----
  unsigned char *buf;
  int num;
  	{
! 	int i,j,k,st_idx,st_num;
  	MD5_CTX m;
  
  #ifdef NORAND
***************
*** 93,98 ****
--- 93,115 ----
  	return;
  #endif
  
+ 	CRYPTO_w_lock(CRYPTO_LOCK_RAND);
+ 	st_idx=state_index;
+ 	st_num=state_num;
+ 
+ 	state_index=(state_index+num);
+ 	if (state_index > STATE_SIZE)
+ 		{
+ 		state_index%=STATE_SIZE;
+ 		state_num=STATE_SIZE;
+ 		}
+ 	else if (state_num < STATE_SIZE)	
+ 		{
+ 		if (state_index > state_num)
+ 			state_num=state_index;
+ 		}
+ 	CRYPTO_w_unlock(CRYPTO_LOCK_RAND);
+ 
  	for (i=0; i<num; i+=MD5_DIGEST_LENGTH)
  		{
  		j=(num-i);
***************
*** 100,113 ****
  
  		MD5_Init(&m);
  		MD5_Update(&m,md,MD5_DIGEST_LENGTH);
! 		k=(state_index+j)-STATE_SIZE;
  		if (k > 0)
  			{
! 			MD5_Update(&m,&(state[state_index]),j-k);
  			MD5_Update(&m,&(state[0]),k);
  			}
  		else
! 			MD5_Update(&m,&(state[state_index]),j);
  			
  		MD5_Update(&m,buf,j);
  		MD5_Final(md,&m);
--- 117,130 ----
  
  		MD5_Init(&m);
  		MD5_Update(&m,md,MD5_DIGEST_LENGTH);
! 		k=(st_idx+j)-STATE_SIZE;
  		if (k > 0)
  			{
! 			MD5_Update(&m,&(state[st_idx]),j-k);
  			MD5_Update(&m,&(state[0]),k);
  			}
  		else
! 			MD5_Update(&m,&(state[st_idx]),j);
  			
  		MD5_Update(&m,buf,j);
  		MD5_Final(md,&m);
***************
*** 116,131 ****
  
  		for (k=0; k<j; k++)
  			{
! 			state[state_index++]^=md[k];
! 			if (state_index >= STATE_SIZE)
  				{
! 				state_index=0;
! 				state_num=STATE_SIZE;
  				}
  			}
  		}
- 	if (state_index > state_num)
- 		state_num=state_index;
  	memset((char *)&m,0,sizeof(m));
  	}
  
--- 133,146 ----
  
  		for (k=0; k<j; k++)
  			{
! 			state[st_idx++]^=md[k];
! 			if (st_idx >= STATE_SIZE)
  				{
! 				st_idx=0;
! 				st_num=STATE_SIZE;
  				}
  			}
  		}
  	memset((char *)&m,0,sizeof(m));
  	}
  
***************
*** 133,139 ****
  unsigned char *buf;
  int num;
  	{
! 	int i,j,k;
  	MD5_CTX m;
  	static int init=1;
  	unsigned long l;
--- 148,154 ----
  unsigned char *buf;
  int num;
  	{
! 	int i,j,k,st_num,st_idx;
  	MD5_CTX m;
  	static int init=1;
  	unsigned long l;
***************
*** 151,159 ****
--- 166,177 ----
  	}
  #endif
  
+ 	CRYPTO_w_lock(CRYPTO_LOCK_RAND);
+ 
  	if (init)
  		{
  		init=0;
+ 		CRYPTO_w_unlock(CRYPTO_LOCK_RAND);
  		/* put in some default random data, we need more than
  		 * just this */
  		RAND_seed((unsigned char *)&m,sizeof(m));
***************
*** 192,199 ****
--- 210,226 ----
  		memset(state,0,STATE_SIZE);
  		memset(md,0,MD5_DIGEST_LENGTH);
  #endif
+ 		CRYPTO_w_lock(CRYPTO_LOCK_RAND);
  		}
  
+ 	st_idx=state_index;
+ 	st_num=state_num;
+ 	state_index+=num;
+ 	if (state_index > state_num)
+ 		state_index=(state_index%state_num);
+ 
+ 	CRYPTO_w_unlock(CRYPTO_LOCK_RAND);
+ 
  	while (num > 0)
  		{
  		j=(num >= MD5_DIGEST_LENGTH/2)?MD5_DIGEST_LENGTH/2:num;
***************
*** 203,223 ****
  #ifndef PURIFY
  		MD5_Update(&m,buf,j); /* purify complains */
  #endif
! 		k=(state_index+j)-state_num;
  		if (k > 0)
  			{
! 			MD5_Update(&m,&(state[state_index]),j-k);
  			MD5_Update(&m,&(state[0]),k);
  			}
  		else
! 			MD5_Update(&m,&(state[state_index]),j);
  		MD5_Final(md,&m);
  
  		for (i=0; i<j; i++)
  			{
! 			if (state_index >= state_num)
! 				state_index=0;
! 			state[state_index++]^=md[i];
  			*(buf++)=md[i+MD5_DIGEST_LENGTH/2];
  			}
  		}
--- 230,250 ----
  #ifndef PURIFY
  		MD5_Update(&m,buf,j); /* purify complains */
  #endif
! 		k=(st_idx+j)-st_num;
  		if (k > 0)
  			{
! 			MD5_Update(&m,&(state[st_idx]),j-k);
  			MD5_Update(&m,&(state[0]),k);
  			}
  		else
! 			MD5_Update(&m,&(state[st_idx]),j);
  		MD5_Final(md,&m);
  
  		for (i=0; i<j; i++)
  			{
! 			if (st_idx >= st_num)
! 				st_idx=0;
! 			state[st_idx++]^=md[i];
  			*(buf++)=md[i+MD5_DIGEST_LENGTH/2];
  			}
  		}
*** /var/spool/ftp/pub/Crypto/SSL/064/SSLeay-0.6.3/./crypto/rand/randfile.c	Mon Aug  5 12:08:49 1996
--- ./crypto/rand/randfile.c	Thu Aug 29 23:50:30 1996
***************
*** 78,84 ****
  	if (in == NULL) goto err;
  	for (;;)
  		{
! 		n=(bytes < BUFSIZE)?bytes:BUFSIZE;
  		i=fread(buf,1,n,in);
  		if (i <= 0) break;
  		/* even if n != i, use the full array */
--- 78,84 ----
  	if (in == NULL) goto err;
  	for (;;)
  		{
! 		n=(bytes < BUFSIZE)?(int)bytes:BUFSIZE;
  		i=fread(buf,1,n,in);
  		if (i <= 0) break;
  		/* even if n != i, use the full array */
*** /var/spool/ftp/pub/Crypto/SSL/064/SSLeay-0.6.3/./crypto/rc2/Makefile.ssl	Thu Aug  8 01:54:23 1996
--- ./crypto/rc2/Makefile.ssl	Fri Aug 30 04:40:53 1996
***************
*** 72,78 ****
  	mv -f Makefile.new $(MAKEFILE)
  
  clean:
! 	/bin/rm -f *.o *.obj lib tags core .nfs* *.old *.bak fluff
  
  errors:
  
--- 72,78 ----
  	mv -f Makefile.new $(MAKEFILE)
  
  clean:
! 	/bin/rm -f *.o *.obj lib tags core .pure .nfs* *.old *.bak fluff
  
  errors:
  
*** /var/spool/ftp/pub/Crypto/SSL/064/SSLeay-0.6.3/./crypto/rc2/rc2.h	Thu Aug  1 11:02:18 1996
--- ./crypto/rc2/rc2.h	Thu Aug 29 23:50:30 1996
***************
*** 56,62 ****
  #define RC2_DECRYPT	0
  
  /* I need to put in a mod for the alpha - eay */
! #define RC2_INT unsigned long
  
  #define RC2_BLOCK	8
  #define RC2_KEY_LENGTH	16
--- 56,62 ----
  #define RC2_DECRYPT	0
  
  /* I need to put in a mod for the alpha - eay */
! #define RC2_INT unsigned short
  
  #define RC2_BLOCK	8
  #define RC2_KEY_LENGTH	16
***************
*** 68,74 ****
  
  #ifndef NOPROTO
   
! void RC2_set_key(RC2_KEY *key, int len, unsigned char *data);
  void RC2_ecb_encrypt(unsigned char *in,unsigned char *out,RC2_KEY *key,
  	int encrypt);
  void RC2_encrypt(unsigned long *data,RC2_KEY *key,int encrypt);
--- 68,74 ----
  
  #ifndef NOPROTO
   
! void RC2_set_key(RC2_KEY *key, int len, unsigned char *data,int bits);
  void RC2_ecb_encrypt(unsigned char *in,unsigned char *out,RC2_KEY *key,
  	int encrypt);
  void RC2_encrypt(unsigned long *data,RC2_KEY *key,int encrypt);
*** /var/spool/ftp/pub/Crypto/SSL/064/SSLeay-0.6.3/./crypto/rc2/rc2test.c	Wed Jul 31 17:13:08 1996
--- ./crypto/rc2/rc2test.c	Thu Aug 29 23:50:31 1996
***************
*** 134,140 ****
  
  	for (n=0; n<4; n++)
  		{
! 		RC2_set_key(&key,16,&(RC2key[n][0]));
  
  		RC2_ecb_encrypt(&(RC2plain[n][0]),buf,&key,RC2_ENCRYPT);
  		if (memcmp(&(RC2cipher[n][0]),buf,8) != 0)
--- 134,140 ----
  
  	for (n=0; n<4; n++)
  		{
! 		RC2_set_key(&key,16,&(RC2key[n][0]),0 /* or 1024 */);
  
  		RC2_ecb_encrypt(&(RC2plain[n][0]),buf,&key,RC2_ENCRYPT);
  		if (memcmp(&(RC2cipher[n][0]),buf,8) != 0)
*** /var/spool/ftp/pub/Crypto/SSL/064/SSLeay-0.6.3/./crypto/rc2/rc2_ecb.c	Tue Aug  6 15:57:43 1996
--- ./crypto/rc2/rc2_ecb.c	Fri Aug 30 00:58:28 1996
***************
*** 48,54 ****
  #include "rc2.h"
  #include "rc2_locl.h"
  
! char *RC2_version="RC2 part of SSLeay 0.6.3 06-Aug-1996";
  
  /* RC2 as implemented frm a posting from
   * Newsgroups: sci.crypt
--- 48,54 ----
  #include "rc2.h"
  #include "rc2_locl.h"
  
! char *RC2_version="RC2 part of SSLeay 0.6.4 30-Aug-1996";
  
  /* RC2 as implemented frm a posting from
   * Newsgroups: sci.crypt
***************
*** 74,81 ****
  	l=d[0]=d[1]=0;
  	}
  
- #define rot(x,n)
- 
  void RC2_encrypt(d,key,encrypt)
  unsigned long *d;
  RC2_KEY *key;
--- 74,79 ----
***************
*** 87,97 ****
  	unsigned long l;
  
  	l=d[0];
! 	x0=l&0xffff;
! 	x1=(l>>16);
  	l=d[1];
! 	x2=l&0xffff;
! 	x3=(l>>16);
  
  	n=3;
  	i=5;
--- 85,95 ----
  	unsigned long l;
  
  	l=d[0];
! 	x0=(RC2_INT)l&0xffff;
! 	x1=(RC2_INT)(l>>16L);
  	l=d[1];
! 	x2=(RC2_INT)l&0xffff;
! 	x3=(RC2_INT)(l>>16L);
  
  	n=3;
  	i=5;
***************
*** 149,154 ****
  			}
  		}
  
! 	d[0]=(x0&0xffff)|((x1&0xffff)<<16);
! 	d[1]=(x2&0xffff)|((x3&0xffff)<<16);
  	}
--- 147,152 ----
  			}
  		}
  
! 	d[0]=(unsigned long)(x0&0xffff)|((unsigned long)(x1&0xffff)<<16L);
! 	d[1]=(unsigned long)(x2&0xffff)|((unsigned long)(x3&0xffff)<<16L);
  	}
*** /var/spool/ftp/pub/Crypto/SSL/064/SSLeay-0.6.3/./crypto/rc2/rc2_locl.h	Wed Jul 17 16:45:58 1996
--- ./crypto/rc2/rc2_locl.h	Thu Aug 29 23:50:30 1996
***************
*** 90,92 ****
--- 90,135 ----
  				} \
  			}
  
+ /* NOTE - c is not incremented as per n2l */
+ #define n2ln(c,l1,l2,n)	{ \
+ 			c+=n; \
+ 			l1=l2=0; \
+ 			switch (n) { \
+ 			case 8: l2 =((unsigned long)(*(--(c))))    ; \
+ 			case 7: l2|=((unsigned long)(*(--(c))))<< 8; \
+ 			case 6: l2|=((unsigned long)(*(--(c))))<<16; \
+ 			case 5: l2|=((unsigned long)(*(--(c))))<<24; \
+ 			case 4: l1 =((unsigned long)(*(--(c))))    ; \
+ 			case 3: l1|=((unsigned long)(*(--(c))))<< 8; \
+ 			case 2: l1|=((unsigned long)(*(--(c))))<<16; \
+ 			case 1: l1|=((unsigned long)(*(--(c))))<<24; \
+ 				} \
+ 			}
+ 
+ /* NOTE - c is not incremented as per l2n */
+ #define l2nn(l1,l2,c,n)	{ \
+ 			c+=n; \
+ 			switch (n) { \
+ 			case 8: *(--(c))=(unsigned char)(((l2)    )&0xff); \
+ 			case 7: *(--(c))=(unsigned char)(((l2)>> 8)&0xff); \
+ 			case 6: *(--(c))=(unsigned char)(((l2)>>16)&0xff); \
+ 			case 5: *(--(c))=(unsigned char)(((l2)>>24)&0xff); \
+ 			case 4: *(--(c))=(unsigned char)(((l1)    )&0xff); \
+ 			case 3: *(--(c))=(unsigned char)(((l1)>> 8)&0xff); \
+ 			case 2: *(--(c))=(unsigned char)(((l1)>>16)&0xff); \
+ 			case 1: *(--(c))=(unsigned char)(((l1)>>24)&0xff); \
+ 				} \
+ 			}
+ 
+ #undef n2l
+ #define n2l(c,l)        (l =((unsigned long)(*((c)++)))<<24L, \
+                          l|=((unsigned long)(*((c)++)))<<16L, \
+                          l|=((unsigned long)(*((c)++)))<< 8L, \
+                          l|=((unsigned long)(*((c)++))))
+ 
+ #undef l2n
+ #define l2n(l,c)        (*((c)++)=(unsigned char)(((l)>>24L)&0xff), \
+                          *((c)++)=(unsigned char)(((l)>>16L)&0xff), \
+                          *((c)++)=(unsigned char)(((l)>> 8L)&0xff), \
+                          *((c)++)=(unsigned char)(((l)     )&0xff))
+ 
*** /var/spool/ftp/pub/Crypto/SSL/064/SSLeay-0.6.3/./crypto/rc2/rc2_skey.c	Wed Jul 31 17:13:08 1996
--- ./crypto/rc2/rc2_skey.c	Thu Aug 29 23:50:31 1996
***************
*** 73,125 ****
  	0xfe,0x7f,0xc1,0xad,
  	};
  
! void RC2_set_key(key,len,data)
  RC2_KEY *key;
  int len;
  unsigned char *data;
  	{
  	int i,j;
! 	RC2_INT *k,*kk,tmp;
  	unsigned int c,d;
  
! 	kk=k= &(key->data[0]);
  	*k=0; /* for if there is a zero length key */
  
  	if (len > 128) len=128;
  
! 	/* I'm going to try to do this expantion by
! 	 * only operating with words. */
! 	i= -1;
! 	for (;;)
  		{
! 		if (++i >= len) break;
! 		*k= *(data++);
! 		if (++i >= len) break;
! 		*(k++)|= ((RC2_INT)*(data++))<<8;
  		}
! 	if (len&1)
  		{
! 		d=key_table[(*kk+ *k)&0xff];
! 		*(k++)|=(d<<8);
! 		i++;
! 		for (j=0; i<128; i+=2)
! 			{
! 			c=key_table[((*(kk++)>>8)+d)&0xff];
! 			d=key_table[ (*kk       +c)&0xff];
! 			*(k++)=(RC2_INT)c|(d<<8);
  			}
! 		}
! 	else
! 		{
! 		d=(unsigned int)(k[-1]>>8);
! 		for (; i<128; i+=2)
! 			{
! 			c=key_table[ ( *kk       +d)&0xff];
! 			d=key_table[((*(kk++)>>8)+c)&0xff];
! 			*(k++)=(RC2_INT)c|(d<<8);
! 			}
! 		}
! 	tmp=key->data[0];
! 	key->data[0]=(tmp&0xff00)|key_table[tmp&0xff];
  	}
  
--- 73,131 ----
  	0xfe,0x7f,0xc1,0xad,
  	};
  
! /* It has come to my attention that there are 2 versions of the RC2
!  * key schedule.  One which is normal, and anther which has a hook to
!  * use a reduced key length.
!  * BSAFE uses the 'retarded' version.  What I previously shipped is
!  * the same as specifying 1024 for the 'bits' parameter.  Bsafe uses
!  * a version where the bits parameter is the same as len*8 */
! void RC2_set_key(key,len,data,bits)
  RC2_KEY *key;
  int len;
  unsigned char *data;
+ int bits;
  	{
  	int i,j;
! 	unsigned char *k;
! 	RC2_INT *ki;
  	unsigned int c,d;
  
! 	k= (unsigned char *)&(key->data[0]);
  	*k=0; /* for if there is a zero length key */
  
  	if (len > 128) len=128;
+ 	if (bits <= 0) bits=1024;
+ 	if (bits > 1024) bits=1024;
  
! 	for (i=0; i<len; i++)
! 		k[i]=data[i];
! 
! 	/* expand table */
! 	d=k[len-1];
! 	j=0;
! 	for (i=len; i < 128; i++,j++)
  		{
! 		d=key_table[(k[j]+d)&0xff];
! 		k[i]=d;
  		}
! 
! 	/* hmm.... key reduction to 'bits' bits */
! 
! 	j=(bits+7)>>3;
! 	i=128-j;
! 	c= (0xff>>(-bits & 0x07));
! 
! 	d=key_table[k[i]&c];
! 	k[i]=d;
! 	while (i--)
  		{
! 		d=key_table[k[i+j]^d];
! 		k[i]=d;
  		}
! 
! 	/* copy from bytes into RC2_INT's */
! 	ki= &(key->data[63]);
! 	for (i=127; i>=0; i-=2)
! 		*(ki--)=((k[i]<<8)|k[i-1])&0xffff;
  	}
  
*** /var/spool/ftp/pub/Crypto/SSL/064/SSLeay-0.6.3/./crypto/rc2/version	Wed Jul 10 09:47:25 1996
--- ./crypto/rc2/version	Thu Aug 29 23:50:31 1996
***************
*** 1,3 ****
--- 1,11 ----
+ 1.1 23/08/96 - eay
+ 	Changed RC2_set_key() so it now takes another argument.  Many
+ 	thanks to Peter Gutmann <pgut01@cs.auckland.ac.nz> for the
+ 	clarification and origional specification of RC2.  BSAFE uses
+ 	this last parameter, 'bits'.  It the key is 128 bits, BSAFE
+ 	also sets this parameter to 128.  The old behaviour can be
+ 	duplicated by setting this parameter to 1024.
+ 
  1.0 08/04/96 - eay
  	First version of SSLeay with rc2.  This has been written from the spec
  	posted sci.crypt.  It is in this directory under rrc2.doc
*** /var/spool/ftp/pub/Crypto/SSL/064/SSLeay-0.6.3/./crypto/rc4/Makefile.ssl	Thu Aug  8 01:54:22 1996
--- ./crypto/rc4/Makefile.ssl	Fri Aug 30 04:40:52 1996
***************
*** 72,78 ****
  	mv -f Makefile.new $(MAKEFILE)
  
  clean:
! 	/bin/rm -f *.o *.obj lib tags core .nfs* *.old *.bak fluff
  
  errors:
  
--- 72,78 ----
  	mv -f Makefile.new $(MAKEFILE)
  
  clean:
! 	/bin/rm -f *.o *.obj lib tags core .pure .nfs* *.old *.bak fluff
  
  errors:
  
*** /var/spool/ftp/pub/Crypto/SSL/064/SSLeay-0.6.3/./crypto/rc4/rc4_enc.c	Thu Aug  8 01:54:12 1996
--- ./crypto/rc4/rc4_enc.c	Fri Aug 30 04:40:41 1996
***************
*** 58,64 ****
   * speedup on x86 */
  #undef RC4_INDEX
  
! char *RC4_version="RC4 part of SSLeay 0.6.3 06-Aug-1996";
  
  char *RC4_options()
  	{
--- 58,64 ----
   * speedup on x86 */
  #undef RC4_INDEX
  
! char *RC4_version="RC4 part of SSLeay 0.6.4 30-Aug-1996";
  
  char *RC4_options()
  	{
***************
*** 93,99 ****
          register RC4_INT *d;
          unsigned int i;
          
!         d=&(key->data[0]);
  	for (i=0; i<256; i++)
  		d[i]=i;
          key->x = 0;     
--- 93,99 ----
          register RC4_INT *d;
          unsigned int i;
          
!         d= &(key->data[0]);
  	for (i=0; i<256; i++)
  		d[i]=i;
          key->x = 0;     
*** /var/spool/ftp/pub/Crypto/SSL/064/SSLeay-0.6.3/./crypto/rc4/rc4_enc.org	Tue Aug  6 15:57:43 1996
--- ./crypto/rc4/rc4_enc.org	Fri Aug 30 00:58:28 1996
***************
*** 58,64 ****
   * speedup on x86 */
  #undef RC4_INDEX
  
! char *RC4_version="RC4 part of SSLeay 0.6.3 06-Aug-1996";
  
  char *RC4_options()
  	{
--- 58,64 ----
   * speedup on x86 */
  #undef RC4_INDEX
  
! char *RC4_version="RC4 part of SSLeay 0.6.4 30-Aug-1996";
  
  char *RC4_options()
  	{
***************
*** 93,99 ****
          register RC4_INT *d;
          unsigned int i;
          
!         d=&(key->data[0]);
  	for (i=0; i<256; i++)
  		d[i]=i;
          key->x = 0;     
--- 93,99 ----
          register RC4_INT *d;
          unsigned int i;
          
!         d= &(key->data[0]);
  	for (i=0; i<256; i++)
  		d[i]=i;
          key->x = 0;     
*** /var/spool/ftp/pub/Crypto/SSL/064/SSLeay-0.6.3/./crypto/rsa/Makefile.ssl	Thu Aug  8 01:54:24 1996
--- ./crypto/rsa/Makefile.ssl	Fri Aug 30 04:40:55 1996
***************
*** 74,80 ****
  	mv -f Makefile.new $(MAKEFILE)
  
  clean:
! 	/bin/rm -f *.o */*.o *.obj lib tags core .nfs* *.old *.bak fluff
  
  errors:
  	perl $(TOP)/util/err-ins.pl $(ERR).err $(ERR).h
--- 74,80 ----
  	mv -f Makefile.new $(MAKEFILE)
  
  clean:
! 	/bin/rm -f *.o */*.o *.obj lib tags core .pure .nfs* *.old *.bak fluff
  
  errors:
  	perl $(TOP)/util/err-ins.pl $(ERR).err $(ERR).h
*** /var/spool/ftp/pub/Crypto/SSL/064/SSLeay-0.6.3/./crypto/rsa/rsa_enc.c	Wed Jul 17 16:45:58 1996
--- ./crypto/rsa/rsa_enc.c	Thu Aug 29 23:50:31 1996
***************
*** 80,86 ****
  		goto err;
  		}
  	
! 	buf=(unsigned char *)malloc(num);
  	if (buf == NULL)
  		{
  		RSAerr(RSA_F_RSA_PUBLIC_ENCRYPT,ERR_R_MALLOC_FAILURE);
--- 80,86 ----
  		goto err;
  		}
  	
! 	buf=(unsigned char *)Malloc(num);
  	if (buf == NULL)
  		{
  		RSAerr(RSA_F_RSA_PUBLIC_ENCRYPT,ERR_R_MALLOC_FAILURE);
***************
*** 127,133 ****
  	if (buf != NULL) 
  		{
  		memset(buf,0,num);
! 		free(buf);
  		}
  	return(r);
  	}
--- 127,133 ----
  	if (buf != NULL) 
  		{
  		memset(buf,0,num);
! 		Free(buf);
  		}
  	return(r);
  	}
***************
*** 153,159 ****
  		RSAerr(RSA_F_RSA_PRIVATE_ENCRYPT,RSA_R_DATA_TO_LARGE_FOR_KEY_SIZE);
  		goto err;
  		}
! 	buf=(unsigned char *)malloc(num);
  	if (buf == NULL)
  		{
  		RSAerr(RSA_F_RSA_PRIVATE_ENCRYPT,ERR_R_MALLOC_FAILURE);
--- 153,159 ----
  		RSAerr(RSA_F_RSA_PRIVATE_ENCRYPT,RSA_R_DATA_TO_LARGE_FOR_KEY_SIZE);
  		goto err;
  		}
! 	buf=(unsigned char *)Malloc(num);
  	if (buf == NULL)
  		{
  		RSAerr(RSA_F_RSA_PRIVATE_ENCRYPT,ERR_R_MALLOC_FAILURE);
***************
*** 201,207 ****
  	if (buf != NULL)
  		{
  		memset(buf,0,num);
! 		free(buf);
  		}
  	return(r);
  	}
--- 201,207 ----
  	if (buf != NULL)
  		{
  		memset(buf,0,num);
! 		Free(buf);
  		}
  	return(r);
  	}
***************
*** 223,229 ****
  
  	num=BN_num_bytes(rsa->n);
  
! 	buf=(unsigned char *)malloc(num);
  	if (buf == NULL)
  		{
  		RSAerr(RSA_F_RSA_PRIVATE_DECRYPT,ERR_R_MALLOC_FAILURE);
--- 223,229 ----
  
  	num=BN_num_bytes(rsa->n);
  
! 	buf=(unsigned char *)Malloc(num);
  	if (buf == NULL)
  		{
  		RSAerr(RSA_F_RSA_PRIVATE_DECRYPT,ERR_R_MALLOC_FAILURE);
***************
*** 270,275 ****
--- 270,276 ----
  		RSAerr(RSA_F_RSA_PRIVATE_DECRYPT,RSA_R_NULL_BEFORE_BLOCK_MISSING);
  		goto err;
  		}
+ 
  	if (i < 8)
  		{
  		RSAerr(RSA_F_RSA_PRIVATE_DECRYPT,RSA_R_BAD_PAD_BYTE_COUNT);
***************
*** 290,296 ****
  	if (buf != NULL)
  		{
  		memset(buf,0,num);
! 		free(buf);
  		}
  	return(r);
  	}
--- 291,297 ----
  	if (buf != NULL)
  		{
  		memset(buf,0,num);
! 		Free(buf);
  		}
  	return(r);
  	}
***************
*** 311,317 ****
  	if (ctx == NULL) goto err;
  
  	num=BN_num_bytes(rsa->n);
! 	buf=(unsigned char *)malloc(num);
  	if (buf == NULL)
  		{
  		RSAerr(RSA_F_RSA_PUBLIC_DECRYPT,ERR_R_MALLOC_FAILURE);
--- 312,318 ----
  	if (ctx == NULL) goto err;
  
  	num=BN_num_bytes(rsa->n);
! 	buf=(unsigned char *)Malloc(num);
  	if (buf == NULL)
  		{
  		RSAerr(RSA_F_RSA_PUBLIC_DECRYPT,ERR_R_MALLOC_FAILURE);
***************
*** 383,389 ****
  	if (buf != NULL)
  		{
  		memset(buf,0,num);
! 		free(buf);
  		}
  	return(r);
  	}
--- 384,390 ----
  	if (buf != NULL)
  		{
  		memset(buf,0,num);
! 		Free(buf);
  		}
  	return(r);
  	}
*** /var/spool/ftp/pub/Crypto/SSL/064/SSLeay-0.6.3/./crypto/rsa/rsa_lib.c	Tue Aug  6 15:57:43 1996
--- ./crypto/rsa/rsa_lib.c	Fri Aug 30 00:58:28 1996
***************
*** 50,62 ****
  #include "bn.h"
  #include "rsa.h"
  
! char *RSA_version="RSA part of SSLeay 0.6.3 06-Aug-1996";
  
  RSA *RSA_new()
  	{
  	RSA *ret;
  
! 	ret=(RSA *)malloc(sizeof(RSA));
  	if (ret == NULL)
  		{
  		RSAerr(RSA_F_RSA_NEW,ERR_R_MALLOC_FAILURE);
--- 50,62 ----
  #include "bn.h"
  #include "rsa.h"
  
! char *RSA_version="RSA part of SSLeay 0.6.4 30-Aug-1996";
  
  RSA *RSA_new()
  	{
  	RSA *ret;
  
! 	ret=(RSA *)Malloc(sizeof(RSA));
  	if (ret == NULL)
  		{
  		RSAerr(RSA_F_RSA_NEW,ERR_R_MALLOC_FAILURE);
***************
*** 85,90 ****
--- 85,97 ----
  
  	i=CRYPTO_add(&r->references,-1,CRYPTO_LOCK_RSA);
  	if (i > 0) return;
+ #ifdef REF_CHECK
+ 	if (i < 0)
+ 		{
+ 		fprintf(stderr,"RSA_free, bad reference count\n");
+ 		abort();
+ 		}
+ #endif
  
  	if (r->n != NULL) BN_clear_free(r->n);
  	if (r->e != NULL) BN_clear_free(r->e);
***************
*** 94,100 ****
  	if (r->dmp1 != NULL) BN_clear_free(r->dmp1);
  	if (r->dmq1 != NULL) BN_clear_free(r->dmq1);
  	if (r->iqmp != NULL) BN_clear_free(r->iqmp);
! 	free(r);
  	}
  
  int RSA_size(r)
--- 101,107 ----
  	if (r->dmp1 != NULL) BN_clear_free(r->dmp1);
  	if (r->dmq1 != NULL) BN_clear_free(r->dmq1);
  	if (r->iqmp != NULL) BN_clear_free(r->iqmp);
! 	Free(r);
  	}
  
  int RSA_size(r)
*** /var/spool/ftp/pub/Crypto/SSL/064/SSLeay-0.6.3/./crypto/rsa/rsa_sign.c	Wed Jul 17 16:45:59 1996
--- ./crypto/rsa/rsa_sign.c	Thu Aug 29 23:50:31 1996
***************
*** 94,100 ****
  		RSAerr(RSA_F_RSA_SIGN,RSA_R_DIGEST_TOO_BIG_FOR_RSA_KEY);
  		return(0);
  		}
! 	s=(unsigned char *)malloc((unsigned int)j+1);
  	if (s == NULL)
  		{
  		RSAerr(RSA_F_RSA_SIGN,ERR_R_MALLOC_FAILURE);
--- 94,100 ----
  		RSAerr(RSA_F_RSA_SIGN,RSA_R_DIGEST_TOO_BIG_FOR_RSA_KEY);
  		return(0);
  		}
! 	s=(unsigned char *)Malloc((unsigned int)j+1);
  	if (s == NULL)
  		{
  		RSAerr(RSA_F_RSA_SIGN,ERR_R_MALLOC_FAILURE);
***************
*** 109,115 ****
  		*siglen=i;
  
  	memset(s,0,(unsigned int)j+1);
! 	free(s);
  	return(ret);
  	}
  
--- 109,115 ----
  		*siglen=i;
  
  	memset(s,0,(unsigned int)j+1);
! 	Free(s);
  	return(ret);
  	}
  
***************
*** 131,137 ****
  		return(0);
  		}
  
! 	s=(unsigned char *)malloc((unsigned int)siglen);
  	if (s == NULL)
  		{
  		RSAerr(RSA_F_RSA_VERIFY,ERR_R_MALLOC_FAILURE);
--- 131,137 ----
  		return(0);
  		}
  
! 	s=(unsigned char *)Malloc((unsigned int)siglen);
  	if (s == NULL)
  		{
  		RSAerr(RSA_F_RSA_VERIFY,ERR_R_MALLOC_FAILURE);
***************
*** 179,185 ****
  err:
  	if (sig != NULL) X509_SIG_free(sig);
  	memset(s,0,(unsigned int)siglen);
! 	free(s);
  	return(ret);
  	}
  
--- 179,185 ----
  err:
  	if (sig != NULL) X509_SIG_free(sig);
  	memset(s,0,(unsigned int)siglen);
! 	Free(s);
  	return(ret);
  	}
  
*** /var/spool/ftp/pub/Crypto/SSL/064/SSLeay-0.6.3/./crypto/sha/Makefile.ssl	Thu Aug  8 01:54:22 1996
--- ./crypto/sha/Makefile.ssl	Fri Aug 30 04:40:51 1996
***************
*** 72,78 ****
  	mv -f Makefile.new $(MAKEFILE)
  
  clean:
! 	/bin/rm -f *.o *.obj lib tags core .nfs* *.old *.bak fluff
  
  errors:
  
--- 72,78 ----
  	mv -f Makefile.new $(MAKEFILE)
  
  clean:
! 	/bin/rm -f *.o *.obj lib tags core .pure .nfs* *.old *.bak fluff
  
  errors:
  
*** /var/spool/ftp/pub/Crypto/SSL/064/SSLeay-0.6.3/./crypto/sha/sha1dgst.c	Tue Aug  6 15:57:43 1996
--- ./crypto/sha/sha1dgst.c	Fri Aug 30 00:58:28 1996
***************
*** 51,57 ****
  #include "sha.h"
  #include "sha_locl.h"
  
! char *SHA1_version="SHA1 part of SSLeay 0.6.3 06-Aug-1996";
  
  /* Implemented from SHA-1 document - The Secure Hash Algorithm
   */
--- 51,57 ----
  #include "sha.h"
  #include "sha_locl.h"
  
! char *SHA1_version="SHA1 part of SSLeay 0.6.4 30-Aug-1996";
  
  /* Implemented from SHA-1 document - The Secure Hash Algorithm
   */
*** /var/spool/ftp/pub/Crypto/SSL/064/SSLeay-0.6.3/./crypto/sha/sha_dgst.c	Tue Aug  6 15:57:43 1996
--- ./crypto/sha/sha_dgst.c	Fri Aug 30 00:58:28 1996
***************
*** 51,57 ****
  #include "sha.h"
  #include "sha_locl.h"
  
! char *SHA_version="SHA part of SSLeay 0.6.3 06-Aug-1996";
  
  /* Implemented from SHA document - The Secure Hash Algorithm
   */
--- 51,57 ----
  #include "sha.h"
  #include "sha_locl.h"
  
! char *SHA_version="SHA part of SSLeay 0.6.4 30-Aug-1996";
  
  /* Implemented from SHA document - The Secure Hash Algorithm
   */
*** /var/spool/ftp/pub/Crypto/SSL/064/SSLeay-0.6.3/./crypto/sha/sha_locl.h	Wed Jul 17 16:46:00 1996
--- ./crypto/sha/sha_locl.h	Thu Aug 29 23:50:31 1996
***************
*** 124,130 ****
  #define Endian_Reverse32(a) \
  	{ \
  	unsigned long l=(a); \
! 	((ROTATE(l,8)&0xFF00FF00)|(ROTATE(l,24)&0x00FF00FF)); \
  	}
  #else
  /* 6 instructions with rotate instruction, else 8 */
--- 124,130 ----
  #define Endian_Reverse32(a) \
  	{ \
  	unsigned long l=(a); \
! 	(a)=((ROTATE(l,8)&0x00FF00FF)|(ROTATE(l,24)&0xFF00FF00)); \
  	}
  #else
  /* 6 instructions with rotate instruction, else 8 */
*** /var/spool/ftp/pub/Crypto/SSL/064/SSLeay-0.6.3/./crypto/stack/Makefile.ssl	Thu Aug  8 01:54:25 1996
--- ./crypto/stack/Makefile.ssl	Fri Aug 30 04:40:56 1996
***************
*** 72,78 ****
  	mv -f Makefile.new $(MAKEFILE)
  
  clean:
! 	/bin/rm -f *.o *.obj lib tags core .nfs* *.old *.bak fluff
  
  errors:
  
--- 72,78 ----
  	mv -f Makefile.new $(MAKEFILE)
  
  clean:
! 	/bin/rm -f *.o *.obj lib tags core .pure .nfs* *.old *.bak fluff
  
  errors:
  
*** /var/spool/ftp/pub/Crypto/SSL/064/SSLeay-0.6.3/./crypto/stack/stack.c	Thu Aug  8 01:19:00 1996
--- ./crypto/stack/stack.c	Fri Aug 30 00:58:29 1996
***************
*** 58,64 ****
  #undef MIN_NODES
  #define MIN_NODES	4
  
! char *STACK_version="STACK part of SSLeay 0.6.3 06-Aug-1996";
  
  #ifndef NOPROTO
  #define	FP_ICC	(int (*)(const void *,const void *))
--- 58,64 ----
  #undef MIN_NODES
  #define MIN_NODES	4
  
! char *STACK_version="STACK part of SSLeay 0.6.4 30-Aug-1996";
  
  #ifndef NOPROTO
  #define	FP_ICC	(int (*)(const void *,const void *))
***************
*** 73,81 ****
  	STACK *ret;
  	int i;
  
! 	if ((ret=(STACK *)malloc(sizeof(STACK))) == NULL)
  		goto err0;
! 	if ((ret->data=(char **)malloc(sizeof(char *)*MIN_NODES)) == NULL)
  		goto err1;
  	for (i=0; i<MIN_NODES; i++)
  		ret->data[i]=NULL;
--- 73,81 ----
  	STACK *ret;
  	int i;
  
! 	if ((ret=(STACK *)Malloc(sizeof(STACK))) == NULL)
  		goto err0;
! 	if ((ret->data=(char **)Malloc(sizeof(char *)*MIN_NODES)) == NULL)
  		goto err1;
  	for (i=0; i<MIN_NODES; i++)
  		ret->data[i]=NULL;
***************
*** 85,91 ****
  	ret->sorted=0;
  	return(ret);
  err1:
! 	free((char *)ret);
  err0:
  	return(NULL);
  	}
--- 85,91 ----
  	ret->sorted=0;
  	return(ret);
  err1:
! 	Free((char *)ret);
  err0:
  	return(NULL);
  	}
***************
*** 99,105 ****
  
  	if (st->num_alloc <= st->num+1)
  		{
! 		s=(char **)realloc((char *)st->data,
  			(unsigned int)sizeof(char *)*st->num_alloc*2);
  		if (s == NULL)
  			return(0);
--- 99,105 ----
  
  	if (st->num_alloc <= st->num+1)
  		{
! 		s=(char **)Realloc((char *)st->data,
  			(unsigned int)sizeof(char *)*st->num_alloc*2);
  		if (s == NULL)
  			return(0);
***************
*** 238,244 ****
  STACK *st;
  	{
  	if (st == NULL) return;
! 	if (st->data != NULL) free((char *)st->data);
! 	free((char *)st);
  	}
  
--- 238,244 ----
  STACK *st;
  	{
  	if (st == NULL) return;
! 	if (st->data != NULL) Free((char *)st->data);
! 	Free((char *)st);
  	}
  
*** /var/spool/ftp/pub/Crypto/SSL/064/SSLeay-0.6.3/./crypto/txt_db/Makefile.ssl	Thu Aug  8 01:54:29 1996
--- ./crypto/txt_db/Makefile.ssl	Fri Aug 30 04:41:00 1996
***************
*** 72,78 ****
  	mv -f Makefile.new $(MAKEFILE)
  
  clean:
! 	/bin/rm -f *.o *.obj lib tags core .nfs* *.old *.bak fluff
  
  errors:
  
--- 72,78 ----
  	mv -f Makefile.new $(MAKEFILE)
  
  clean:
! 	/bin/rm -f *.o *.obj lib tags core .pure .nfs* *.old *.bak fluff
  
  errors:
  
*** /var/spool/ftp/pub/Crypto/SSL/064/SSLeay-0.6.3/./crypto/txt_db/txt_db.c	Tue Aug  6 15:57:45 1996
--- ./crypto/txt_db/txt_db.c	Fri Aug 30 00:58:29 1996
***************
*** 48,53 ****
--- 48,54 ----
  #include <stdio.h>
  #include <stdlib.h>
  #include <string.h>
+ #include "cryptlib.h"
  #include "buffer.h"
  #include "txt_db.h"
  
***************
*** 54,60 ****
  #undef BUFSIZE
  #define BUFSIZE	512
  
! char *TXT_DB_version="TXT_DB part of SSLeay 0.6.3 06-Aug-1996";
  
  TXT_DB *TXT_DB_read(in,num)
  BIO *in;
--- 55,61 ----
  #undef BUFSIZE
  #define BUFSIZE	512
  
! char *TXT_DB_version="TXT_DB part of SSLeay 0.6.4 30-Aug-1996";
  
  TXT_DB *TXT_DB_read(in,num)
  BIO *in;
***************
*** 73,79 ****
  	if ((buf=BUF_MEM_new()) == NULL) goto err;
  	if (!BUF_MEM_grow(buf,size)) goto err;
  
! 	if ((ret=(TXT_DB *)malloc(sizeof(TXT_DB))) == NULL)
  		goto err;
  	ret->num_fields=num;
  	ret->index=NULL;
--- 74,80 ----
  	if ((buf=BUF_MEM_new()) == NULL) goto err;
  	if (!BUF_MEM_grow(buf,size)) goto err;
  
! 	if ((ret=(TXT_DB *)Malloc(sizeof(TXT_DB))) == NULL)
  		goto err;
  	ret->num_fields=num;
  	ret->index=NULL;
***************
*** 80,88 ****
  	ret->qual=NULL;
  	if ((ret->data=sk_new_null()) == NULL)
  		goto err;
! 	if ((ret->index=(LHASH **)malloc(sizeof(LHASH *)*num)) == NULL)
  		goto err;
! 	if ((ret->qual=(int (**)())malloc(sizeof(int (**)())*num)) == NULL)
  		goto err;
  	for (i=0; i<num; i++)
  		{
--- 81,89 ----
  	ret->qual=NULL;
  	if ((ret->data=sk_new_null()) == NULL)
  		goto err;
! 	if ((ret->index=(LHASH **)Malloc(sizeof(LHASH *)*num)) == NULL)
  		goto err;
! 	if ((ret->qual=(int (**)())Malloc(sizeof(int (**)())*num)) == NULL)
  		goto err;
  	for (i=0; i<num; i++)
  		{
***************
*** 112,118 ****
  		else
  			{
  			buf->data[offset-1]='\0'; /* blat the '\n' */
! 			p=(char *)malloc(add+offset);
  			offset=0;
  			}
  		pp=(char **)p;
--- 113,119 ----
  		else
  			{
  			buf->data[offset-1]='\0'; /* blat the '\n' */
! 			p=(char *)Malloc(add+offset);
  			offset=0;
  			}
  		pp=(char **)p;
***************
*** 167,178 ****
  	if (er)
  		{
  #ifndef WIN16
! 		if (er == 1) fprintf(stderr,"malloc failure\n");
  #endif
  		if (ret->data != NULL) sk_free(ret->data);
! 		if (ret->index != NULL) free(ret->index);
! 		if (ret->qual != NULL) free((char *)ret->qual);
! 		if (ret != NULL) free(ret);
  		return(NULL);
  		}
  	else
--- 168,179 ----
  	if (er)
  		{
  #ifndef WIN16
! 		if (er == 1) fprintf(stderr,"Malloc failure\n");
  #endif
  		if (ret->data != NULL) sk_free(ret->data);
! 		if (ret->index != NULL) Free(ret->index);
! 		if (ret->qual != NULL) Free((char *)ret->qual);
! 		if (ret != NULL) Free(ret);
  		return(NULL);
  		}
  	else
***************
*** 348,357 ****
  		{
  		for (i=db->num_fields-1; i>=0; i--)
  			if (db->index[i] != NULL) lh_free(db->index[i]);
! 		free(db->index);
  		}
  	if (db->qual != NULL)
! 		free(db->qual);
  	if (db->data != NULL)
  		{
  		for (i=sk_num(db->data)-1; i>=0; i--)
--- 349,358 ----
  		{
  		for (i=db->num_fields-1; i>=0; i--)
  			if (db->index[i] != NULL) lh_free(db->index[i]);
! 		Free(db->index);
  		}
  	if (db->qual != NULL)
! 		Free(db->qual);
  	if (db->data != NULL)
  		{
  		for (i=sk_num(db->data)-1; i>=0; i--)
***************
*** 363,369 ****
  			if (max == NULL) /* new row */
  				{
  				for (n=0; n<db->num_fields; n++)
! 					free(p[n]);
  				}
  			else
  				{
--- 364,370 ----
  			if (max == NULL) /* new row */
  				{
  				for (n=0; n<db->num_fields; n++)
! 					Free(p[n]);
  				}
  			else
  				{
***************
*** 371,382 ****
  					{
  					if (((p[n] < (char *)p) || (p[n] > max))
  						&& (p[n] != NULL))
! 						free(p[n]);
  					}
  				}
! 			free(sk_value(db->data,i));
  			}
  		sk_free(db->data);
  		}
! 	free(db);
  	}
--- 372,383 ----
  					{
  					if (((p[n] < (char *)p) || (p[n] > max))
  						&& (p[n] != NULL))
! 						Free(p[n]);
  					}
  				}
! 			Free(sk_value(db->data,i));
  			}
  		sk_free(db->data);
  		}
! 	Free(db);
  	}
*** /var/spool/ftp/pub/Crypto/SSL/064/SSLeay-0.6.3/./crypto/x509/Makefile.ssl	Thu Aug  8 01:54:28 1996
--- ./crypto/x509/Makefile.ssl	Fri Aug 30 04:40:59 1996
***************
*** 78,84 ****
  	mv -f Makefile.new $(MAKEFILE)
  
  clean:
! 	/bin/rm -f *.o *.obj lib tags core .nfs* *.old *.bak fluff
  
  errors:
  	perl $(TOP)/util/err-ins.pl $(ERR).err $(ERR).h
--- 78,84 ----
  	mv -f Makefile.new $(MAKEFILE)
  
  clean:
! 	/bin/rm -f *.o *.obj lib tags core .pure .nfs* *.old *.bak fluff
  
  errors:
  	perl $(TOP)/util/err-ins.pl $(ERR).err $(ERR).h
*** /var/spool/ftp/pub/Crypto/SSL/064/SSLeay-0.6.3/./crypto/x509/x509.h	Sun Jul 21 00:18:57 1996
--- ./crypto/x509/x509.h	Thu Aug 29 23:50:31 1996
***************
*** 150,156 ****
  	{
  	ASN1_INTEGER *serialNumber;
  	ASN1_UTCTIME *revocationDate;
! 	int sequence; /* loaded sequence */
  	} X509_REVOKED;
  
  typedef struct X509_crl_info_st
--- 150,157 ----
  	{
  	ASN1_INTEGER *serialNumber;
  	ASN1_UTCTIME *revocationDate;
! 	STACK /* optional X509_EXTENSION */ *extensions;
! 	int sequence; /* load sequence */
  	} X509_REVOKED;
  
  typedef struct X509_crl_info_st
***************
*** 334,340 ****
  	ASN1_sign((int (*)())i2d_NETSCAPE_SPKAC, x->sig_algor,NULL, \
  		x->signature, (char *)x->spkac,pkey,md)
  
! #define X509_dup(x509) (X509 *)ASN1_dup(i2d_X509, \
  		(char *(*)())d2i_X509,(char *)x509)
  #define d2i_X509_fp(fp,x509) (X509 *)ASN1_d2i_fp((char *(*)())X509_new, \
  		(char *(*)())d2i_X509, (fp),(unsigned char **)(x509))
--- 335,341 ----
  	ASN1_sign((int (*)())i2d_NETSCAPE_SPKAC, x->sig_algor,NULL, \
  		x->signature, (char *)x->spkac,pkey,md)
  
! #define X509_dup(x509) (X509 *)ASN1_dup((int (*)())i2d_X509, \
  		(char *(*)())d2i_X509,(char *)x509)
  #define d2i_X509_fp(fp,x509) (X509 *)ASN1_d2i_fp((char *(*)())X509_new, \
  		(char *(*)())d2i_X509, (fp),(unsigned char **)(x509))
***************
*** 343,349 ****
  		(char *(*)())d2i_X509, (bp),(unsigned char **)(x509))
  #define i2d_X509_bio(bp,x509) ASN1_i2d_bio(i2d_X509,bp,(unsigned char *)x509)
  
! #define X509_CRL_dup(crl) (X509_CRL *)ASN1_dup(i2d_X509_CRL, \
  		(char *(*)())d2i_X509_CRL,(char *)crl)
  #define d2i_X509_CRL_fp(fp,crl) (X509_CRL *)ASN1_d2i_fp((char *(*)()) \
  		X509_CRL_new,(char *(*)())d2i_X509_CRL, (fp),\
--- 344,350 ----
  		(char *(*)())d2i_X509, (bp),(unsigned char **)(x509))
  #define i2d_X509_bio(bp,x509) ASN1_i2d_bio(i2d_X509,bp,(unsigned char *)x509)
  
! #define X509_CRL_dup(crl) (X509_CRL *)ASN1_dup((int (*)())i2d_X509_CRL, \
  		(char *(*)())d2i_X509_CRL,(char *)crl)
  #define d2i_X509_CRL_fp(fp,crl) (X509_CRL *)ASN1_d2i_fp((char *(*)()) \
  		X509_CRL_new,(char *(*)())d2i_X509_CRL, (fp),\
***************
*** 356,362 ****
  #define i2d_X509_CRL_bio(bp,crl) ASN1_i2d_bio(i2d_X509_CRL,bp,\
  		(unsigned char *)crl)
  
! #define PKCS7_dup(p7) (PKCS7 *)ASN1_dup(i2d_PKCS7, \
  		(char *(*)())d2i_PKCS7,(char *)p7)
  #define d2i_PKCS7_fp(fp,p7) (PKCS7 *)ASN1_d2i_fp((char *(*)()) \
  		PKCS7_new,(char *(*)())d2i_PKCS7, (fp),\
--- 357,363 ----
  #define i2d_X509_CRL_bio(bp,crl) ASN1_i2d_bio(i2d_X509_CRL,bp,\
  		(unsigned char *)crl)
  
! #define PKCS7_dup(p7) (PKCS7 *)ASN1_dup((int (*)())i2d_PKCS7, \
  		(char *(*)())d2i_PKCS7,(char *)p7)
  #define d2i_PKCS7_fp(fp,p7) (PKCS7 *)ASN1_d2i_fp((char *(*)()) \
  		PKCS7_new,(char *(*)())d2i_PKCS7, (fp),\
***************
*** 369,375 ****
  #define i2d_PKCS7_bio(bp,p7) ASN1_i2d_bio(i2d_PKCS7,bp,\
  		(unsigned char *)p7)
  
! #define X509_REQ_dup(req) (X509_REQ *)ASN1_dup(i2d_X509_REQ, \
  		(char *(*)())d2i_X509_REQ,(char *)req)
  #define d2i_X509_REQ_fp(fp,req) (X509_REQ *)ASN1_d2i_fp((char *(*)())\
  		X509_REQ_new, (char *(*)())d2i_X509_REQ, (fp),\
--- 370,376 ----
  #define i2d_PKCS7_bio(bp,p7) ASN1_i2d_bio(i2d_PKCS7,bp,\
  		(unsigned char *)p7)
  
! #define X509_REQ_dup(req) (X509_REQ *)ASN1_dup((int (*)())i2d_X509_REQ, \
  		(char *(*)())d2i_X509_REQ,(char *)req)
  #define d2i_X509_REQ_fp(fp,req) (X509_REQ *)ASN1_d2i_fp((char *(*)())\
  		X509_REQ_new, (char *(*)())d2i_X509_REQ, (fp),\
***************
*** 382,390 ****
  #define i2d_X509_REQ_bio(bp,req) ASN1_i2d_bio(i2d_X509_REQ,bp,\
  		(unsigned char *)req)
  
! #define RSAPublicKey_dup(rsa) (RSA *)ASN1_dup(i2d_RSAPublikKey, \
  		(char *(*)())d2i_RSAPublicKey,(char *)rsa)
! #define RSAPrivateKey_dup(rsa) (RSA *)ASN1_dup(i2d_RSAPrivateKey, \
  		(char *(*)())d2i_RSAPrivateKey,(char *)rsa)
  #define d2i_RSAPrivateKey_fp(fp,rsa) (RSA *)ASN1_d2i_fp((char *(*)())\
  		RSA_new,(char *(*)())d2i_RSAPrivateKey, (fp), \
--- 383,391 ----
  #define i2d_X509_REQ_bio(bp,req) ASN1_i2d_bio(i2d_X509_REQ,bp,\
  		(unsigned char *)req)
  
! #define RSAPublicKey_dup(rsa) (RSA *)ASN1_dup((int (*)())i2d_RSAPublikKey, \
  		(char *(*)())d2i_RSAPublicKey,(char *)rsa)
! #define RSAPrivateKey_dup(rsa) (RSA *)ASN1_dup((int (*)())i2d_RSAPrivateKey, \
  		(char *(*)())d2i_RSAPrivateKey,(char *)rsa)
  #define d2i_RSAPrivateKey_fp(fp,rsa) (RSA *)ASN1_d2i_fp((char *(*)())\
  		RSA_new,(char *(*)())d2i_RSAPrivateKey, (fp), \
***************
*** 397,406 ****
  #define i2d_RSAPrivateKey_bio(bp,rsa) ASN1_i2d_bio(i2d_RSAPrivateKey,bp, \
  		(unsigned char *)rsa)
  
! #define X509_NAME_dup(xn) (X509_NAME *)ASN1_dup(i2d_X509_NAME, \
  		(char *(*)())d2i_X509_NAME,(char *)xn)
  #define X509_NAME_ENTRY_dup(ne) (X509_NAME_ENTRY *)ASN1_dup( \
! 		i2d_X509_NAME_ENTRY, (char *(*)())d2i_X509_NAME_ENTRY,\
  		(char *)ne)
  
  #ifndef NOPROTO
--- 398,408 ----
  #define i2d_RSAPrivateKey_bio(bp,rsa) ASN1_i2d_bio(i2d_RSAPrivateKey,bp, \
  		(unsigned char *)rsa)
  
! #define X509_NAME_dup(xn) (X509_NAME *)ASN1_dup((int (*)())i2d_X509_NAME, \
  		(char *(*)())d2i_X509_NAME,(char *)xn)
  #define X509_NAME_ENTRY_dup(ne) (X509_NAME_ENTRY *)ASN1_dup( \
! 		(int (*)())i2d_X509_NAME_ENTRY, \
! 		(char *(*)())d2i_X509_NAME_ENTRY,\
  		(char *)ne)
  
  #ifndef NOPROTO
***************
*** 425,431 ****
  X509_REQ *	X509_to_X509_REQ(X509 *x, EVP_PKEY *pkey);
  X509 *		X509_REQ_to_X509(X509_REQ *r, int days,EVP_PKEY *pkey);
  int		X509_cert_verify(CERTIFICATE_CTX *ctx,X509 *xs, int (*cb)(),
! 			int *error); 
  
  void ERR_load_X509_strings(void );
  
--- 427,433 ----
  X509_REQ *	X509_to_X509_REQ(X509 *x, EVP_PKEY *pkey);
  X509 *		X509_REQ_to_X509(X509_REQ *r, int days,EVP_PKEY *pkey);
  int		X509_cert_verify(CERTIFICATE_CTX *ctx,X509 *xs, int (*cb)(),
! 			int *error,char *arg); 
  
  void ERR_load_X509_strings(void );
  
*** /var/spool/ftp/pub/Crypto/SSL/064/SSLeay-0.6.3/./crypto/x509/x509_ath.c	Wed Jul 17 18:02:23 1996
--- ./crypto/x509/x509_ath.c	Thu Aug 29 23:50:31 1996
***************
*** 54,60 ****
  	{
  	CERTIFICATE_CTX *ret=NULL;
  
! 	ret=(CERTIFICATE_CTX *)malloc(sizeof(CERTIFICATE_CTX));
  	if (ret == NULL) goto err;
  
  	ret->init=1;
--- 54,60 ----
  	{
  	CERTIFICATE_CTX *ret=NULL;
  
! 	ret=(CERTIFICATE_CTX *)Malloc(sizeof(CERTIFICATE_CTX));
  	if (ret == NULL) goto err;
  
  	ret->init=1;
***************
*** 88,99 ****
  	CRYPTO_w_unlock(CRYPTO_LOCK_X509);
  
  	for (i=0; i<a->num_dirs; i++)
! 		if (a->dirs[i] != NULL) free(a->dirs[i]);
! 	if (a->dirs != NULL) free(a->dirs);
! 	if (a->dirs_type != NULL) free(a->dirs_type);
  	for (i=0; i<a->num_paths; i++)
! 		if (a->paths[i] != NULL) free(a->paths[i]);
! 	if (a->paths != NULL) free(a->paths);
! 	if (a->path_type != NULL) free(a->path_type);
! 	free(a);
  	}
--- 88,99 ----
  	CRYPTO_w_unlock(CRYPTO_LOCK_X509);
  
  	for (i=0; i<a->num_dirs; i++)
! 		if (a->dirs[i] != NULL) Free((char *)a->dirs[i]);
! 	if (a->dirs != NULL) Free((char *)a->dirs);
! 	if (a->dirs_type != NULL) Free((char *)a->dirs_type);
  	for (i=0; i<a->num_paths; i++)
! 		if (a->paths[i] != NULL) Free((char *)a->paths[i]);
! 	if (a->paths != NULL) Free((char *)a->paths);
! 	if (a->path_type != NULL) Free((char *)a->path_type);
! 	Free((char *)a);
  	}
*** /var/spool/ftp/pub/Crypto/SSL/064/SSLeay-0.6.3/./crypto/x509/x509_cmp.c	Wed Jul 17 16:46:00 1996
--- ./crypto/x509/x509_cmp.c	Thu Aug 29 23:50:31 1996
***************
*** 84,90 ****
  	ret=strlen(str);
  	MD5_Init(&ctx);
  	MD5_Update(&ctx,(unsigned char *)str,ret);
! 	free(str);
  	MD5_Update(&ctx,(unsigned char *)a->cert_info->serialNumber->data,
  		(unsigned long)a->cert_info->serialNumber->length);
  	MD5_Final(&(md[0]),&ctx);
--- 84,90 ----
  	ret=strlen(str);
  	MD5_Init(&ctx);
  	MD5_Update(&ctx,(unsigned char *)str,ret);
! 	Free((char *)str);
  	MD5_Update(&ctx,(unsigned char *)a->cert_info->serialNumber->data,
  		(unsigned long)a->cert_info->serialNumber->length);
  	MD5_Final(&(md[0]),&ctx);
***************
*** 185,191 ****
  	if (str == NULL) return(0);
  	ret=strlen(str);
  	MD5((unsigned char *)str,ret,&(md[0]));
! 	free(str);
  	ret=(	((unsigned long)md[0]     )|((unsigned long)md[1]<<8L)|
  		((unsigned long)md[2]<<16L)|((unsigned long)md[3]<<24L)
  		)&0xffffffffL;
--- 185,191 ----
  	if (str == NULL) return(0);
  	ret=strlen(str);
  	MD5((unsigned char *)str,ret,&(md[0]));
! 	Free((char *)str);
  	ret=(	((unsigned long)md[0]     )|((unsigned long)md[1]<<8L)|
  		((unsigned long)md[2]<<16L)|((unsigned long)md[3]<<24L)
  		)&0xffffffffL;
*** /var/spool/ftp/pub/Crypto/SSL/064/SSLeay-0.6.3/./crypto/x509/x509_crt.c	Tue Jul 23 21:54:35 1996
--- ./crypto/x509/x509_crt.c	Thu Aug 29 23:50:31 1996
***************
*** 199,205 ****
  		ret=0;
  		}
  
! 	CRYPTO_w_lock(CRYPTO_LOCK_CERTIFICATE_CTX);
  
  	return(ret);	
  	}
--- 199,205 ----
  		ret=0;
  		}
  
! 	CRYPTO_w_unlock(CRYPTO_LOCK_CERTIFICATE_CTX);
  
  	return(ret);	
  	}
*** /var/spool/ftp/pub/Crypto/SSL/064/SSLeay-0.6.3/./crypto/x509/x509_obj.c	Wed Jul 17 16:46:01 1996
--- ./crypto/x509/x509_obj.c	Thu Aug 29 23:50:31 1996
***************
*** 122,128 ****
  		*p='\0';
  		}
  	p=b->data;
! 	free(b);
  	return(p);
  err:
  	X509err(X509_F_X509_NAME_ONELINE,ERR_R_MALLOC_FAILURE);
--- 122,128 ----
  		*p='\0';
  		}
  	p=b->data;
! 	Free((char *)b);
  	return(p);
  err:
  	X509err(X509_F_X509_NAME_ONELINE,ERR_R_MALLOC_FAILURE);
*** /var/spool/ftp/pub/Crypto/SSL/064/SSLeay-0.6.3/./crypto/x509/x509_req.c	Thu Aug  1 09:40:04 1996
--- ./crypto/x509/x509_req.c	Thu Aug 29 23:50:31 1996
***************
*** 76,82 ****
  	ri=ret->req_info;
  
  	ri->version->length=1;
! 	ri->version->data=(unsigned char *)malloc(1);
  	if (ri->version->data == NULL) goto err;
  	ri->version->data[0]=0; /* version == 0 */
  
--- 76,82 ----
  	ri=ret->req_info;
  
  	ri->version->length=1;
! 	ri->version->data=(unsigned char *)Malloc(1);
  	if (ri->version->data == NULL) goto err;
  	ri->version->data[0]=0; /* version == 0 */
  
***************
*** 101,107 ****
  	ri->pubkey->algor->algorithm=obj;
  
  	i=i2d_PublicKey(pkey,NULL);
! 	s=(unsigned char *)malloc((unsigned int)i+1);
  	if (s == NULL)
  		{
  		X509err(X509_F_X509_TO_X509_REQ,ERR_R_MALLOC_FAILURE);
--- 101,107 ----
  	ri->pubkey->algor->algorithm=obj;
  
  	i=i2d_PublicKey(pkey,NULL);
! 	s=(unsigned char *)Malloc((unsigned int)i+1);
  	if (s == NULL)
  		{
  		X509err(X509_F_X509_TO_X509_REQ,ERR_R_MALLOC_FAILURE);
*** /var/spool/ftp/pub/Crypto/SSL/064/SSLeay-0.6.3/./crypto/x509/x509_vrf.c	Tue Aug  6 15:57:44 1996
--- ./crypto/x509/x509_vrf.c	Fri Aug 30 00:58:29 1996
***************
*** 67,74 ****
  
  #ifndef NOPROTO
  static int verify(CERTIFICATE_CTX *c, X509 *xs, int (*cb)(), int depth,
! 	int *error);
! static int null_callback(int e, X509 *a, X509 *b, int c, int d);
  #else
  static int verify();
  static int null_callback();
--- 67,74 ----
  
  #ifndef NOPROTO
  static int verify(CERTIFICATE_CTX *c, X509 *xs, int (*cb)(), int depth,
! 	int *error,char *arg);
! static int null_callback(int e, X509 *a, X509 *b, int c, int d, char *arg);
  #else
  static int verify();
  static int null_callback();
***************
*** 78,84 ****
  void RSA_print_bytes();
  #endif
  
! char *X509_version="X509 part of SSLeay 0.6.3 06-Aug-1996";
  
  int X509_add_cert_file(ctx,file, type)
  CERTIFICATE_CTX *ctx;
--- 78,84 ----
  void RSA_print_bytes();
  #endif
  
! char *X509_version="X509 part of SSLeay 0.6.4 30-Aug-1996";
  
  int X509_add_cert_file(ctx,file, type)
  CERTIFICATE_CTX *ctx;
***************
*** 188,196 ****
  			if (ctx->num_dirs_alloced < (ctx->num_dirs+1))
  				{
  				ctx->num_dirs_alloced+=10;
! 				pp=(char **)malloc(ctx->num_dirs_alloced*
  					sizeof(char *));
! 				ip=(int *)malloc(ctx->num_dirs_alloced*
  					sizeof(int));
  				if ((pp == NULL) || (ip == NULL))
  					{
--- 188,196 ----
  			if (ctx->num_dirs_alloced < (ctx->num_dirs+1))
  				{
  				ctx->num_dirs_alloced+=10;
! 				pp=(char **)Malloc(ctx->num_dirs_alloced*
  					sizeof(char *));
! 				ip=(int *)Malloc(ctx->num_dirs_alloced*
  					sizeof(int));
  				if ((pp == NULL) || (ip == NULL))
  					{
***************
*** 201,213 ****
  					sizeof(char *));
  				memcpy(ip,ctx->dirs_type,(ctx->num_dirs_alloced-10)*
  					sizeof(int));
! 				if (ctx->dirs != NULL) free(ctx->dirs);
! 				if (ctx->dirs_type != NULL) free(ctx->dirs_type);
  				ctx->dirs=pp;
  				ctx->dirs_type=ip;
  				}
  			ctx->dirs_type[ctx->num_dirs]=type;
! 			ctx->dirs[ctx->num_dirs]=(char *)malloc((unsigned int)len+1);
  			if (ctx->dirs[ctx->num_dirs] == NULL) return(0);
  			strncpy(ctx->dirs[ctx->num_dirs],ss,(unsigned int)len);
  			ctx->dirs[ctx->num_dirs][len]='\0';
--- 201,215 ----
  					sizeof(char *));
  				memcpy(ip,ctx->dirs_type,(ctx->num_dirs_alloced-10)*
  					sizeof(int));
! 				if (ctx->dirs != NULL)
! 					Free((char *)ctx->dirs);
! 				if (ctx->dirs_type != NULL)
! 					Free((char *)ctx->dirs_type);
  				ctx->dirs=pp;
  				ctx->dirs_type=ip;
  				}
  			ctx->dirs_type[ctx->num_dirs]=type;
! 			ctx->dirs[ctx->num_dirs]=(char *)Malloc((unsigned int)len+1);
  			if (ctx->dirs[ctx->num_dirs] == NULL) return(0);
  			strncpy(ctx->dirs[ctx->num_dirs],ss,(unsigned int)len);
  			ctx->dirs[ctx->num_dirs][len]='\0';
***************
*** 219,257 ****
  	return(1);
  	}
  
! static int null_callback(e,a,b,c,d)
  int e;
  X509 *a;
  X509 *b;
  int c;
  int d;
  	{
  #ifdef LINT
! 	a=b; b=a; c=d; d=c;
  #endif
  	return(e);
  	}
  
! int X509_cert_verify(ctx,xs, cb,error)
  CERTIFICATE_CTX *ctx;
  X509 *xs;
  int (*cb)();
  int *error;
  	{
  	int ret;
  
  	if (cb == NULL)
! 		ret=verify(ctx,xs,null_callback,0,error);
! 	else	ret=verify(ctx,xs,cb,0,error);
  	return(ret);
  	}
  
! static int verify(ctx,xs, cb, depth, error)
  CERTIFICATE_CTX *ctx;
  X509 *xs;
  int (*cb)();
  int depth;
  int *error;
  	{
  	X509 *xi=NULL;
  	BUF_MEM *buf=NULL;
--- 221,262 ----
  	return(1);
  	}
  
! static int null_callback(e,a,b,c,d,f)
  int e;
  X509 *a;
  X509 *b;
  int c;
  int d;
+ char *f;
  	{
  #ifdef LINT
! 	a=b; b=a; c=d; d=c; f=NULL;
  #endif
  	return(e);
  	}
  
! int X509_cert_verify(ctx,xs, cb, error, arg)
  CERTIFICATE_CTX *ctx;
  X509 *xs;
  int (*cb)();
  int *error;
+ char *arg;
  	{
  	int ret;
  
  	if (cb == NULL)
! 		ret=verify(ctx,xs,null_callback,0,error,arg);
! 	else	ret=verify(ctx,xs,cb,0,error,arg);
  	return(ret);
  	}
  
! static int verify(ctx,xs, cb, depth, error, arg)
  CERTIFICATE_CTX *ctx;
  X509 *xs;
  int (*cb)();
  int depth;
  int *error;
+ char *arg;
  	{
  	X509 *xi=NULL;
  	BUF_MEM *buf=NULL;
***************
*** 265,276 ****
  			== 0) && (depth == 0))
  			{
  			reason=VERIFY_ERR_DEPTH_ZERO_SELF_SIGNED_CERT;
! 			ret=(*cb)(0,xs,xi,depth,reason);
  			}
  		else
  			{
  			reason=VERIFY_ERR_UNABLE_TO_GET_ISSUER;
! 			ret=(*cb)(0,xs,xi,depth,reason);
  			}
  		goto end;
  		}
--- 270,281 ----
  			== 0) && (depth == 0))
  			{
  			reason=VERIFY_ERR_DEPTH_ZERO_SELF_SIGNED_CERT;
! 			ret=(*cb)(0,xs,xi,depth,reason,arg);
  			}
  		else
  			{
  			reason=VERIFY_ERR_UNABLE_TO_GET_ISSUER;
! 			ret=(*cb)(0,xs,xi,depth,reason,arg);
  			}
  		goto end;
  		}
***************
*** 278,292 ****
  	if ((pkey=X509_extract_key(xi)) == NULL)
  		{
  		reason=VERIFY_ERR_UNABLE_TO_DECODE_ISSUER_PUBLIC_KEY;
! 		ret=(*cb)(0,xs,xi,depth,reason);
! 		goto end;
  		}
  
  	if (X509_verify(xs,pkey) <= 0)
  		{
  		reason=VERIFY_ERR_SIGNATURE_FAILURE;
! 		ret=(*cb)(0,xs,xi,depth,reason);
! 		goto end;
  		}
  
  	i=X509_cmp_current_time(xs->cert_info->validity->notBefore);
--- 283,296 ----
  	if ((pkey=X509_extract_key(xi)) == NULL)
  		{
  		reason=VERIFY_ERR_UNABLE_TO_DECODE_ISSUER_PUBLIC_KEY;
! 		ret=(*cb)(0,xs,xi,depth,reason,arg);
  		}
  
  	if (X509_verify(xs,pkey) <= 0)
  		{
  		reason=VERIFY_ERR_SIGNATURE_FAILURE;
! 		ret=(*cb)(0,xs,xi,depth,reason,arg);
! 		if (!ret) goto end;
  		}
  
  	i=X509_cmp_current_time(xs->cert_info->validity->notBefore);
***************
*** 293,306 ****
  	if (i == 0)
  		{
  		reason=VERIFY_ERR_ERROR_IN_NOT_BEFORE_FIELD;
! 		ret=(*cb)(0,xs,xi,depth,reason);
! 		goto end;
  		}
  	if (i > 0)
  		{
  		reason=VERIFY_ERR_CERT_NOT_YET_VALID;
! 		ret=(*cb)(0,xs,xi,depth,reason);
! 		goto end;
  		}
  
  	i=X509_cmp_current_time(xs->cert_info->validity->notAfter);
--- 297,310 ----
  	if (i == 0)
  		{
  		reason=VERIFY_ERR_ERROR_IN_NOT_BEFORE_FIELD;
! 		ret=(*cb)(0,xs,xi,depth,reason,arg);
! 		if (!ret) goto end;
  		}
  	if (i > 0)
  		{
  		reason=VERIFY_ERR_CERT_NOT_YET_VALID;
! 		ret=(*cb)(0,xs,xi,depth,reason,arg);
! 		if (!ret) goto end;
  		}
  
  	i=X509_cmp_current_time(xs->cert_info->validity->notAfter);
***************
*** 307,329 ****
  	if (i == 0)
  		{
  		reason=VERIFY_ERR_ERROR_IN_NOT_AFTER_FIELD;
! 		ret=((*cb)(0,xs,xi,depth,reason));
  		}
! 	else if (i < 0)
  		{
  		reason=VERIFY_ERR_CERT_HAS_EXPIRED;
! 		ret=(*cb)(0,xs,xi,depth,reason);
  		}
! 	else if (X509_name_cmp(xs->cert_info->subject,xs->cert_info->issuer)
  		!= 0)
  		{
  		/* say this one is ok and check the parent */
  		reason=VERIFY_OK;
! 		i=(*cb)(1,xs,xi,depth,reason);
  		if (!i)
  			ret=0;
  		else
! 			ret=verify(ctx,xi,cb,depth+1,error);
  		}
  	else
  		{
--- 311,337 ----
  	if (i == 0)
  		{
  		reason=VERIFY_ERR_ERROR_IN_NOT_AFTER_FIELD;
! 		ret=((*cb)(0,xs,xi,depth,reason,arg));
! 		if (!ret) goto end;
  		}
! 
! 	if (i < 0)
  		{
  		reason=VERIFY_ERR_CERT_HAS_EXPIRED;
! 		ret=(*cb)(0,xs,xi,depth,reason,arg);
! 		if (!ret) goto end;
  		}
! 
! 	if (X509_name_cmp(xs->cert_info->subject,xs->cert_info->issuer)
  		!= 0)
  		{
  		/* say this one is ok and check the parent */
  		reason=VERIFY_OK;
! 		i=(*cb)(1,xs,xi,depth,reason,arg);
  		if (!i)
  			ret=0;
  		else
! 			ret=verify(ctx,xi,cb,depth+1,error,arg);
  		}
  	else
  		{
***************
*** 332,344 ****
  		if (depth == 0)
  			{
  			reason=VERIFY_ERR_DEPTH_ZERO_SELF_SIGNED_CERT;
! 			ret=(*cb)(0,xs,xi,depth,reason);
  			}
  		else
  			{
  			/* self signed CA, we are happy with this */
  			reason=VERIFY_ROOT_OK;
! 			ret=(*cb)(1,xs,xi,depth,reason);
  			}
  		}
  end:
--- 340,352 ----
  		if (depth == 0)
  			{
  			reason=VERIFY_ERR_DEPTH_ZERO_SELF_SIGNED_CERT;
! 			ret=(*cb)(0,xs,xi,depth,reason,arg);
  			}
  		else
  			{
  			/* self signed CA, we are happy with this */
  			reason=VERIFY_ROOT_OK;
! 			ret=(*cb)(1,xs,xi,depth,reason,arg);
  			}
  		}
  end:
***************
*** 414,419 ****
--- 422,429 ----
  	switch (n)
  		{
  	case VERIFY_OK:
+ 		return("ok");
+ 	case VERIFY_ROOT_OK:
  		return("ok");
  	case VERIFY_ERR_UNABLE_TO_GET_ISSUER:
  		return("unable to get issuer certificate");
*** /var/spool/ftp/pub/Crypto/SSL/064/SSLeay-0.6.3/./ssl/Makefile.ssl	Thu Aug  8 01:54:30 1996
--- ./ssl/Makefile.ssl	Fri Aug 30 04:41:01 1996
***************
*** 86,92 ****
  	mv -f Makefile.new $(MAKEFILE)
  
  clean:
! 	/bin/rm -f *.o *.obj lib tags core .nfs* *.old *.bak fluff
  
  errors:
  	perl $(TOP)/util/err-ins.pl $(ERR).err $(ERR).h
--- 86,92 ----
  	mv -f Makefile.new $(MAKEFILE)
  
  clean:
! 	/bin/rm -f *.o *.obj lib tags core .pure .nfs* *.old *.bak fluff
  
  errors:
  	perl $(TOP)/util/err-ins.pl $(ERR).err $(ERR).h
*** /var/spool/ftp/pub/Crypto/SSL/064/SSLeay-0.6.3/./ssl/ssl.h	Fri Aug  2 16:38:17 1996
--- ./ssl/ssl.h	Fri Aug 30 03:39:57 1996
***************
*** 140,145 ****
--- 140,147 ----
  #define SSL_FILETYPE_ASN1	2
  #endif
  
+ typedef struct ssl_st *ssl_crock_st;
+ 
  /* Lets make this into an ASN.1 type structure as follows
   * SSL_SESSION_ID ::= SEQUENCE {
   *	version 		INTEGER,	-- structure version number
***************
*** 216,237 ****
  	 * returns 1, it means that the callback will do a
  	 * SSL_SESSION_free() when it has finished using it.  Otherwise,
  	 * on 0, it means the callback has finished with it. */
  #ifndef NOPROTO
! 	int (*new_session_cb)(SSL_SESSION *new_session);
  #else
  	int (*new_session_cb)();
  #endif
  
  #ifndef NOPROTO
! 	SSL_SESSION *(*get_session_cb)(unsigned char *key,int key_len);
  #else
  	SSL_SESSION *(*get_session_cb)();
  #endif
  
! 	int sess_connect;	/* SSL new (expensive) connection */
! 	int sess_connect_good;	/* SSL new (expensive) connection */
! 	int sess_accept;	/* SSL connection failues */
! 	int sess_accept_good;	/* SSL connection failues */
  	int sess_miss;		/* session lookup misses  */
  	int sess_timeout;	/* session reuse attempt on timeouted session */
  	int sess_hit;		/* session reuse actually done */
--- 218,241 ----
  	 * returns 1, it means that the callback will do a
  	 * SSL_SESSION_free() when it has finished using it.  Otherwise,
  	 * on 0, it means the callback has finished with it. */
+ 
  #ifndef NOPROTO
! 	int (*new_session_cb)(struct ssl_st *ssl,SSL_SESSION *sess);
  #else
  	int (*new_session_cb)();
  #endif
  
  #ifndef NOPROTO
! 	SSL_SESSION *(*get_session_cb)(struct ssl_st *ssl,
! 		unsigned char *data,int len,int *copy);
  #else
  	SSL_SESSION *(*get_session_cb)();
  #endif
  
! 	int sess_connect;	/* SSL new (expensive) connection - started */
! 	int sess_connect_good;	/* SSL new (expensive) connection - finished */
! 	int sess_accept;	/* SSL new (expensive) accept - started */
! 	int sess_accept_good;	/* SSL new (expensive) accept - finished */
  	int sess_miss;		/* session lookup misses  */
  	int sess_timeout;	/* session reuse attempt on timeouted session */
  	int sess_hit;		/* session reuse actually done */
***************
*** 327,335 ****
--- 331,341 ----
  #ifdef HEADER_BUFFER_H
  	BIO *rbio; /* used by SSL_read */
  	BIO *wbio; /* used by SSL_write */
+ 	BIO *bbio; /* used during session-id reuse */
  #else
  	char *rbio; /* used by SSL_read */
  	char *wbio; /* used by SSL_write */
+ 	char *bbio;
  #endif
  	int version;	/* procol version */
  
***************
*** 476,485 ****
  #define SSL_set_info_callback(ssl,cb)	((ssl)->info_callback=(cb))
  #define SSL_get_info_callback(ssl)	((ssl)->info_callback)
  
! #define SSL_CB_ACCEPT_LOOP		(SSL_ST_ACCEPT|0x01)
! #define SSL_CB_ACCEPT_EXIT		(SSL_ST_ACCEPT|0x02)
! #define SSL_CB_CONNECT_LOOP		(SSL_ST_CONNECT|0x01)
! #define SSL_CB_CONNECT_EXIT		(SSL_ST_CONNECT|0x02)
  
  /* Define the initial state
   * These are used as flags to be checked by SSL_in_connect_init() and
--- 482,493 ----
  #define SSL_set_info_callback(ssl,cb)	((ssl)->info_callback=(cb))
  #define SSL_get_info_callback(ssl)	((ssl)->info_callback)
  
! #define SSL_CB_LOOP			0x01
! #define SSL_CB_EXIT			0x02
! #define SSL_CB_ACCEPT_LOOP		(SSL_ST_ACCEPT|SSL_CB_LOOP)
! #define SSL_CB_ACCEPT_EXIT		(SSL_ST_ACCEPT|SSL_CB_EXIT)
! #define SSL_CB_CONNECT_LOOP		(SSL_ST_CONNECT|SSL_CB_LOOP)
! #define SSL_CB_CONNECT_EXIT		(SSL_ST_CONNECT|SSL_CB_EXIT)
  
  /* Define the initial state
   * These are used as flags to be checked by SSL_in_connect_init() and
***************
*** 521,526 ****
--- 529,535 ----
  #define SSL_ST_GET_CLIENT_MASTER_KEY_B		(0x31|SSL_ST_ACCEPT)
  #define SSL_ST_SEND_SERVER_VERIFY_A		(0x40|SSL_ST_ACCEPT)
  #define SSL_ST_SEND_SERVER_VERIFY_B		(0x41|SSL_ST_ACCEPT)
+ #define SSL_ST_SEND_SERVER_VERIFY_C		(0x42|SSL_ST_ACCEPT)
  #define SSL_ST_GET_CLIENT_FINISHED_A		(0x50|SSL_ST_ACCEPT)
  #define SSL_ST_GET_CLIENT_FINISHED_B		(0x51|SSL_ST_ACCEPT)
  #define SSL_ST_SEND_SERVER_FINISHED_A		(0x60|SSL_ST_ACCEPT)
***************
*** 582,587 ****
--- 591,597 ----
  void	SSL_flush_sessions(SSL_CTX *ctx,long tm);
  void	SSL_free(SSL *s);
  char *	SSL_get_cipher(SSL *s);
+ int	SSL_get_cipher_bits(SSL *s,int *alg_bits);
  int	SSL_get_fd(SSL *s);
  char *	SSL_get_cipher_list(SSL *s, int n);
  char *	SSL_get_shared_ciphers(SSL *s, char *buf, int len);
***************
*** 650,656 ****
  char *	SSL_get_peer_certificate(SSL *s);
  #endif
  
! void SSL_CTX_set_default_verify(SSL_CTX *ctx,int mode,int (*callback)());
  void SSL_CTX_set_cert_verify_cb(SSL_CTX *ctx, int (*cb)(),char *arg);
  int SSL_CTX_use_RSAPrivateKey(SSL_CTX *ctx, RSA *rsa);
  int SSL_CTX_use_RSAPrivateKey_ASN1(SSL_CTX *ctx, unsigned char *d, long len);
--- 660,669 ----
  char *	SSL_get_peer_certificate(SSL *s);
  #endif
  
! /* old name */
! #define SSL_CTX_set_default_verify(a,b,c) SSL_CTX_set_verify(a,b,c)
! 
! void SSL_CTX_set_verify(SSL_CTX *ctx,int mode,int (*callback)());
  void SSL_CTX_set_cert_verify_cb(SSL_CTX *ctx, int (*cb)(),char *arg);
  int SSL_CTX_use_RSAPrivateKey(SSL_CTX *ctx, RSA *rsa);
  int SSL_CTX_use_RSAPrivateKey_ASN1(SSL_CTX *ctx, unsigned char *d, long len);
***************
*** 680,685 ****
--- 693,699 ----
  void	SSL_flush_sessions();
  void	SSL_free();
  char *	SSL_get_cipher();
+ int	SSL_get_cipher_bits();
  int	SSL_get_fd();
  char *	SSL_get_cipher_list();
  char *	SSL_get_shared_ciphers();
***************
*** 748,754 ****
  char *	SSL_get_peer_certificate();
  #endif
  
! void SSL_CTX_set_default_verify();
  void SSL_CTX_set_cert_verify_cb();
  int SSL_CTX_use_RSAPrivateKey();
  int SSL_CTX_use_RSAPrivateKey_ASN1();
--- 762,768 ----
  char *	SSL_get_peer_certificate();
  #endif
  
! void SSL_CTX_set_verify();
  void SSL_CTX_set_cert_verify_cb();
  int SSL_CTX_use_RSAPrivateKey();
  int SSL_CTX_use_RSAPrivateKey_ASN1();
*** /var/spool/ftp/pub/Crypto/SSL/064/SSLeay-0.6.3/./ssl/ssltest.c	Wed Jul 24 14:27:10 1996
--- ./ssl/ssltest.c	Thu Aug 29 23:50:28 1996
***************
*** 50,55 ****
--- 50,56 ----
  #include <string.h>
  #include <errno.h>
  #include "buffer.h"
+ #include "crypto.h"
  #include "../e_os.h"
  #include "x509.h"
  #include "ssl.h"
***************
*** 65,71 ****
  
  #ifndef NOPROTO
  int MS_CALLBACK verify_callback(int ok, X509 *xs, X509 *xi, int depth,
! 	int error);
  #else
  int MS_CALLBACK verify_callback();
  #endif
--- 66,72 ----
  
  #ifndef NOPROTO
  int MS_CALLBACK verify_callback(int ok, X509 *xs, X509 *xi, int depth,
! 	int error,char *arg);
  #else
  int MS_CALLBACK verify_callback();
  #endif
***************
*** 116,121 ****
--- 117,124 ----
  		if ((bio_stdout=BIO_new(BIO_s_file())) != NULL)
  			BIO_set_fp(bio_stdout,stdout,BIO_NOCLOSE);
  
+ 	CRYPTO_mem_ctrl(CRYPTO_MEM_CHECK_ON);
+ 
  	argc--;
  	argv++;
  
***************
*** 184,190 ****
  	if (client_auth)
  		{
  		fprintf(stderr,"client authentication\n");
! 		SSL_CTX_set_default_verify(s_ctx,
  			SSL_VERIFY_PEER|SSL_VERIFY_FAIL_IF_NO_PEER_CERT,
  			verify_callback);
  		}
--- 187,193 ----
  	if (client_auth)
  		{
  		fprintf(stderr,"client authentication\n");
! 		SSL_CTX_set_verify(s_ctx,
  			SSL_VERIFY_PEER|SSL_VERIFY_FAIL_IF_NO_PEER_CERT,
  			verify_callback);
  		}
***************
*** 191,197 ****
  	if (server_auth)
  		{
  		fprintf(stderr,"server authentication\n");
! 		SSL_CTX_set_default_verify(c_ctx,SSL_VERIFY_PEER,
  			verify_callback);
  		}
  
--- 194,200 ----
  	if (server_auth)
  		{
  		fprintf(stderr,"server authentication\n");
! 		SSL_CTX_set_verify(c_ctx,SSL_VERIFY_PEER,
  			verify_callback);
  		}
  
***************
*** 199,206 ****
  end:
  	if (s_ctx != NULL) SSL_CTX_free(s_ctx);
  	if (c_ctx != NULL) SSL_CTX_free(c_ctx);
! 	exit(ret);
! 	return(0);
  	}
  
  #define W_READ	1
--- 202,213 ----
  end:
  	if (s_ctx != NULL) SSL_CTX_free(s_ctx);
  	if (c_ctx != NULL) SSL_CTX_free(c_ctx);
! 
! 	if (bio_stdout != NULL) BIO_free(bio_stdout);
! 
! 	ERR_remove_state(0);
! 	CRYPTO_mem_leaks(bio_err);
! 	EXIT(ret);
  	}
  
  #define W_READ	1
***************
*** 288,293 ****
--- 295,301 ----
  		if (!do_client && !do_server)
  			{
  			fprintf(stdout,"ERROR IN STARTUP\n");
+ 			ERR_print_errors(bio_err);
  			break;
  			}
  		if (do_client && !(done & C_DONE))
***************
*** 309,314 ****
--- 317,323 ----
  					else
  						{
  						fprintf(stderr,"ERROR in CLIENT\n");
+ 						ERR_print_errors(bio_err);
  						return(1);
  						}
  					}
***************
*** 340,345 ****
--- 349,355 ----
  					else
  						{
  						fprintf(stderr,"ERROR in CLIENT\n");
+ 						ERR_print_errors(bio_err);
  						return(1);
  						}
  					}
***************
*** 377,382 ****
--- 387,393 ----
  					else
  						{
  						fprintf(stderr,"ERROR in SERVER\n");
+ 						ERR_print_errors(bio_err);
  						return(1);
  						}
  					}
***************
*** 411,416 ****
--- 422,428 ----
  					else
  						{
  						fprintf(stderr,"ERROR in SERVER\n");
+ 						ERR_print_errors(bio_err);
  						return(1);
  						}
  					}
***************
*** 434,440 ****
  	fprintf(stdout,"DONE\n");
  err:
  	/* We have to set the BIO's to NULL otherwise they will be
! 	 * free()ed twice.  Once when th s_ssl is SSL_free()ed and
  	 * again when c_ssl is SSL_free()ed.
  	 * This is a hack required because s_ssl and c_ssl are sharing the same
  	 * BIO structure and SSL_set_bio() and SSL_free() automatically
--- 446,452 ----
  	fprintf(stdout,"DONE\n");
  err:
  	/* We have to set the BIO's to NULL otherwise they will be
! 	 * Free()ed twice.  Once when th s_ssl is SSL_free()ed and
  	 * again when c_ssl is SSL_free()ed.
  	 * This is a hack required because s_ssl and c_ssl are sharing the same
  	 * BIO structure and SSL_set_bio() and SSL_free() automatically
***************
*** 452,463 ****
  	return(0);
  	}
  
! int MS_CALLBACK verify_callback(ok, xs, xi, depth, error)
  int ok;
  X509 *xs;
  X509 *xi;
  int depth;
  int error;
  	{
  	char *s;
  
--- 464,476 ----
  	return(0);
  	}
  
! int MS_CALLBACK verify_callback(ok, xs, xi, depth, error, arg)
  int ok;
  X509 *xs;
  X509 *xi;
  int depth;
  int error;
+ char *arg;
  	{
  	char *s;
  
***************
*** 468,474 ****
  			fprintf(stderr,"depth=%d %s\n",depth,s);
  		else
  			fprintf(stderr,"depth=%d error=%d %s\n",depth,error,s);
! 		free(s);
  		}
  
  	return(ok);
--- 481,487 ----
  			fprintf(stderr,"depth=%d %s\n",depth,s);
  		else
  			fprintf(stderr,"depth=%d error=%d %s\n",depth,error,s);
! 		Free(s);
  		}
  
  	return(ok);
*** /var/spool/ftp/pub/Crypto/SSL/064/SSLeay-0.6.3/./ssl/ssl_asn1.c	Wed Aug  7 17:38:22 1996
--- ./ssl/ssl_asn1.c	Thu Aug 29 23:50:27 1996
***************
*** 73,79 ****
  unsigned char **pp;
  	{
  #define LSIZE2 (sizeof(long)*2)
! 	int v1,v2,v3;
  	unsigned char buf[4],ibuf1[LSIZE2],ibuf2[LSIZE2];
  	unsigned char ibuf3[LSIZE2],ibuf4[LSIZE2];
  	SSL_SESSION_ASN1 a;
--- 73,79 ----
  unsigned char **pp;
  	{
  #define LSIZE2 (sizeof(long)*2)
! 	int v1=0,v2=0,v3=0;
  	unsigned char buf[4],ibuf1[LSIZE2],ibuf2[LSIZE2];
  	unsigned char ibuf3[LSIZE2],ibuf4[LSIZE2];
  	SSL_SESSION_ASN1 a;
***************
*** 84,90 ****
  
  	/* Note that I cheat in the following 2 assignments.  I know
  	 * that if the ASN1_INTERGER passed to ASN1_INTEGER_set
! 	 * is > sizeof(long)+1, the buffer will not be re-malloc()ed.
  	 * This is a bit evil but makes things simple, no dynamic allocation
  	 * to clean up :-) */
  	a.version.length=LSIZE2;
--- 84,90 ----
  
  	/* Note that I cheat in the following 2 assignments.  I know
  	 * that if the ASN1_INTERGER passed to ASN1_INTEGER_set
! 	 * is > sizeof(long)+1, the buffer will not be re-Malloc()ed.
  	 * This is a bit evil but makes things simple, no dynamic allocation
  	 * to clean up :-) */
  	a.version.length=LSIZE2;
***************
*** 184,196 ****
  
  	ai.data=NULL; ai.length=0;
  	M_ASN1_D2I_get(aip,d2i_ASN1_INTEGER);
! 	version=ASN1_INTEGER_get(aip);
! 	if (ai.data != NULL) { free(ai.data); ai.data=NULL; ai.length=0; }
  
  	/* we don't care about the version right now :-) */
  	M_ASN1_D2I_get(aip,d2i_ASN1_INTEGER);
! 	ssl_version=ASN1_INTEGER_get(aip);
! 	if (ai.data != NULL) { free(ai.data); ai.data=NULL; ai.length=0; }
  
  	os.data=NULL; os.length=0;
  	M_ASN1_D2I_get(osp,d2i_ASN1_OCTET_STRING);
--- 184,196 ----
  
  	ai.data=NULL; ai.length=0;
  	M_ASN1_D2I_get(aip,d2i_ASN1_INTEGER);
! 	version=(int)ASN1_INTEGER_get(aip);
! 	if (ai.data != NULL) { Free(ai.data); ai.data=NULL; ai.length=0; }
  
  	/* we don't care about the version right now :-) */
  	M_ASN1_D2I_get(aip,d2i_ASN1_INTEGER);
! 	ssl_version=(int)ASN1_INTEGER_get(aip);
! 	if (ai.data != NULL) { Free(ai.data); ai.data=NULL; ai.length=0; }
  
  	os.data=NULL; os.length=0;
  	M_ASN1_D2I_get(osp,d2i_ASN1_OCTET_STRING);
***************
*** 206,212 ****
                          SSL_NUM_CIPHERS,sizeof(CIPHER),(int (*)())ssl_cipher_cmp);
  	if (cp == NULL)
  		{
! 		free(os.data);
  		c.error=SSL_R_UNSUPORTED_CIPHER;
  		goto err;
  		}
--- 206,212 ----
                          SSL_NUM_CIPHERS,sizeof(CIPHER),(int (*)())ssl_cipher_cmp);
  	if (cp == NULL)
  		{
! 		Free(os.data);
  		c.error=SSL_R_UNSUPORTED_CIPHER;
  		goto err;
  		}
***************
*** 219,237 ****
  
  	M_ASN1_D2I_get(osp,d2i_ASN1_OCTET_STRING);
  	ret->session_id_length=os.length;
! 	if (ret->session_id != NULL) free(ret->session_id);
  	ret->session_id=os.data;
  	os.data=NULL; os.length=0;
  
  	M_ASN1_D2I_get(osp,d2i_ASN1_OCTET_STRING);
  	ret->master_key_length=os.length;
! 	if (ret->master_key != NULL) free(ret->master_key);
  	ret->master_key=os.data;
  	os.data=NULL; os.length=0;
  
  	M_ASN1_D2I_get_IMP_opt(osp,d2i_ASN1_OCTET_STRING,0,V_ASN1_OCTET_STRING);
  	ret->key_arg_length=os.length;
! 	if (ret->key_arg != NULL) free(ret->key_arg);
  	ret->key_arg=os.data;
  	os.data=NULL; os.length=0;
  
--- 219,237 ----
  
  	M_ASN1_D2I_get(osp,d2i_ASN1_OCTET_STRING);
  	ret->session_id_length=os.length;
! 	if (ret->session_id != NULL) Free(ret->session_id);
  	ret->session_id=os.data;
  	os.data=NULL; os.length=0;
  
  	M_ASN1_D2I_get(osp,d2i_ASN1_OCTET_STRING);
  	ret->master_key_length=os.length;
! 	if (ret->master_key != NULL) Free(ret->master_key);
  	ret->master_key=os.data;
  	os.data=NULL; os.length=0;
  
  	M_ASN1_D2I_get_IMP_opt(osp,d2i_ASN1_OCTET_STRING,0,V_ASN1_OCTET_STRING);
  	ret->key_arg_length=os.length;
! 	if (ret->key_arg != NULL) Free(ret->key_arg);
  	ret->key_arg=os.data;
  	os.data=NULL; os.length=0;
  
***************
*** 239,245 ****
  	if (ai.data != NULL)
  		{
  		ret->time=ASN1_INTEGER_get(aip);
! 		free(ai.data); ai.data=NULL; ai.length=0;
  		}
  	else
  		ret->time=time(NULL);
--- 239,245 ----
  	if (ai.data != NULL)
  		{
  		ret->time=ASN1_INTEGER_get(aip);
! 		Free(ai.data); ai.data=NULL; ai.length=0;
  		}
  	else
  		ret->time=time(NULL);
***************
*** 248,254 ****
  	if (ai.data != NULL)
  		{
  		ret->timeout=ASN1_INTEGER_get(aip);
! 		free(ai.data); ai.data=NULL; ai.length=0;
  		}
  	else
  		ret->timeout=100;
--- 248,254 ----
  	if (ai.data != NULL)
  		{
  		ret->timeout=ASN1_INTEGER_get(aip);
! 		Free(ai.data); ai.data=NULL; ai.length=0;
  		}
  	else
  		ret->timeout=100;
*** /var/spool/ftp/pub/Crypto/SSL/064/SSLeay-0.6.3/./ssl/ssl_auth.c	Wed Jul 24 14:27:10 1996
--- ./ssl/ssl_auth.c	Thu Aug 29 23:50:27 1996
***************
*** 90,96 ****
  	{
  	SSL_CTX *ret;
  	
! 	ret=(SSL_CTX *)malloc(sizeof(SSL_CTX));
  	if (ret == NULL) goto err;
  
  	ret->num_cipher_list=0;
--- 90,96 ----
  	{
  	SSL_CTX *ret;
  	
! 	ret=(SSL_CTX *)Malloc(sizeof(SSL_CTX));
  	if (ret == NULL) goto err;
  
  	ret->num_cipher_list=0;
***************
*** 153,158 ****
--- 153,165 ----
  
  	i=CRYPTO_add(&a->references,-1,CRYPTO_LOCK_SSL_CTX);
  	if (i > 0) return;
+ #ifdef REF_CHECK
+ 	if (i < 0)
+ 		{
+ 		fprintf(stderr,"SSL_CTX_free, bad reference count\n");
+ 		abort();
+ 		}
+ #endif
  
  	if (a->sessions != NULL)
  		{
***************
*** 163,174 ****
  		CERTIFICATE_CTX_free(a->cert);
  	if (a->cipher_list != NULL)
  		{
! 		free(a->cipher_list[0]);
! 		free(a->cipher_list);
  		}
  	if (a->default_cert != NULL)
  		ssl_cert_free(a->default_cert);
! 	free(a);
  	}
  
  void SSL_CTX_set_default_passwd_cb(ctx,cb)
--- 170,181 ----
  		CERTIFICATE_CTX_free(a->cert);
  	if (a->cipher_list != NULL)
  		{
! 		Free((char *)a->cipher_list[0]);
! 		Free((char *)a->cipher_list);
  		}
  	if (a->default_cert != NULL)
  		ssl_cert_free(a->default_cert);
! 	Free((char *)a);
  	}
  
  void SSL_CTX_set_default_passwd_cb(ctx,cb)
***************
*** 187,193 ****
  	ctx->app_verify_arg=arg;
  	}
  
! void SSL_CTX_set_default_verify(ctx,mode,cb)
  SSL_CTX *ctx;
  int mode;
  int (*cb)();
--- 194,200 ----
  	ctx->app_verify_arg=arg;
  	}
  
! void SSL_CTX_set_verify(ctx,mode,cb)
  SSL_CTX *ctx;
  int mode;
  int (*cb)();
*** /var/spool/ftp/pub/Crypto/SSL/064/SSLeay-0.6.3/./ssl/ssl_cert.c	Wed Jul 24 14:27:10 1996
--- ./ssl/ssl_cert.c	Thu Aug 29 23:50:27 1996
***************
*** 54,60 ****
  	{
  	CERT *ret;
  
! 	ret=(CERT *)malloc(sizeof(CERT));
  	if (ret == NULL)
  		{
  		SSLerr(SSL_F_SSL_CERT_NEW,ERR_R_MALLOC_FAILURE);
--- 54,60 ----
  	{
  	CERT *ret;
  
! 	ret=(CERT *)Malloc(sizeof(CERT));
  	if (ret == NULL)
  		{
  		SSLerr(SSL_F_SSL_CERT_NEW,ERR_R_MALLOC_FAILURE);
***************
*** 77,87 ****
  
  	i=CRYPTO_add(&c->references,-1,CRYPTO_LOCK_SSL_CERT);
  	if (i > 0) return;
  
  	if (c->x509 != NULL) X509_free(c->x509);
  	if (c->privatekey != NULL) EVP_PKEY_free(c->privatekey);
  	if (c->publickey != NULL) EVP_PKEY_free(c->publickey);
! 	free(c);
  	}
  
  /* loads in the certificate from the server */
--- 77,94 ----
  
  	i=CRYPTO_add(&c->references,-1,CRYPTO_LOCK_SSL_CERT);
  	if (i > 0) return;
+ #ifdef REF_CHECK
+ 	if (i < 0)
+ 		{
+ 		fprintf(stderr,"ssl_cert_free, bad reference count\n");
+ 		abort();
+ 		}
+ #endif
  
  	if (c->x509 != NULL) X509_free(c->x509);
  	if (c->privatekey != NULL) EVP_PKEY_free(c->privatekey);
  	if (c->publickey != NULL) EVP_PKEY_free(c->publickey);
! 	Free(c);
  	}
  
  /* loads in the certificate from the server */
***************
*** 108,114 ****
  		i=s->ctx->app_verify_callback(s->ctx->app_verify_arg,s,x509);
  	else
  		i=X509_cert_verify(s->ctx->cert,x509,s->verify_callback,
! 			&s->verify_result);
  		
  	if ((s->verify_mode != SSL_VERIFY_NONE) && (!i))
  		{
--- 115,121 ----
  		i=s->ctx->app_verify_callback(s->ctx->app_verify_arg,s,x509);
  	else
  		i=X509_cert_verify(s->ctx->cert,x509,s->verify_callback,
! 			&s->verify_result,(char *)s);
  		
  	if ((s->verify_mode != SSL_VERIFY_NONE) && (!i))
  		{
*** /var/spool/ftp/pub/Crypto/SSL/064/SSLeay-0.6.3/./ssl/ssl_clnt.c	Thu Aug  1 11:52:33 1996
--- ./ssl/ssl_clnt.c	Thu Aug 29 23:50:27 1996
***************
*** 125,133 ****
  				ret= -1;
  				goto end;
  				}
! 			if (s->init_buf) free(s->init_buf);
  			s->init_buf=(unsigned char *)buf->data;
! 			free(buf);
  			s->init_num=0;
  			s->state=SSL_ST_SEND_CLIENT_HELLO_A;
  			s->ctx->sess_connect++;
--- 125,133 ----
  				ret= -1;
  				goto end;
  				}
! 			if (s->init_buf) Free((char *)s->init_buf);
  			s->init_buf=(unsigned char *)buf->data;
! 			Free((char *)buf);
  			s->init_num=0;
  			s->state=SSL_ST_SEND_CLIENT_HELLO_A;
  			s->ctx->sess_connect++;
***************
*** 211,220 ****
  			break;
  
  		case SSL_ST_OK:
! 			free(s->init_buf);
  			s->init_buf=NULL;
  			s->init_num=0;
! 			ERR_clear_error();
  
  			/* If we want to cache session-ids in the client
  			 * and we sucessfully add the session-id to the
--- 211,220 ----
  			break;
  
  		case SSL_ST_OK:
! 			Free(s->init_buf);
  			s->init_buf=NULL;
  			s->init_num=0;
! 		/*	ERR_clear_error();*/
  
  			/* If we want to cache session-ids in the client
  			 * and we sucessfully add the session-id to the
***************
*** 228,243 ****
  				CRYPTO_add(&s->session->references,1,
  					CRYPTO_LOCK_SSL_SESSION);
  
! 				if (!s->ctx->new_session_cb(s->session))
  					{
  					SSL_SESSION_free(s->session);
  					}
  				}
  
! 			/* auto flush every 32 connections */
  			if ((!(s->ctx->session_cache_mode &
  				SSL_SESS_CACHE_NO_AUTO_CLEAR)) &&
! 				((s->ctx->sess_accept_good & 0x1f) == 0x1f))
  				SSL_flush_sessions(s->ctx,time(NULL));
  
  			ret=1;
--- 228,243 ----
  				CRYPTO_add(&s->session->references,1,
  					CRYPTO_LOCK_SSL_SESSION);
  
! 				if (!s->ctx->new_session_cb(s,s->session))
  					{
  					SSL_SESSION_free(s->session);
  					}
  				}
  
! 			/* auto flush every 255 connections */
  			if ((!(s->ctx->session_cache_mode &
  				SSL_SESS_CACHE_NO_AUTO_CLEAR)) &&
! 				((s->ctx->sess_accept_good & 0xff) == 0))
  				SSL_flush_sessions(s->ctx,time(NULL));
  
  			ret=1;
***************
*** 321,327 ****
  		}
  	else
  		{
! 		if (s->session->session_id != NULL) free(s->session->session_id);
  		s->session->session_id=NULL;
  		s->session->session_id_length=0;
  
--- 321,327 ----
  		}
  	else
  		{
! 		if (s->session->session_id != NULL) Free(s->session->session_id);
  		s->session->session_id=NULL;
  		s->session->session_id_length=0;
  
***************
*** 391,409 ****
  		X509_free(s->session->peer);
  
  	/* hmmm, can we have the problem of the other session with this
! 	 * cert, free's it before we increment the reference count. */
! 	CRYPTO_w_lock(CRYPTO_LOCK_SSL_SESSION);
  	CRYPTO_w_lock(CRYPTO_LOCK_X509);
  	s->session->peer=s->session->cert->x509;
  	s->session->peer->references++;
  	CRYPTO_w_unlock(CRYPTO_LOCK_X509);
- 	CRYPTO_w_unlock(CRYPTO_LOCK_SSL_SESSION);
  
  	/* get conn_id */
  	if (s->conn_id_length != s->state_conn_id_length)
  		{
! 		if (s->conn_id) free(s->conn_id);
! 		s->conn_id=(unsigned char *)malloc(s->state_conn_id_length);
  		if (s->conn_id == NULL)
  			{
  			ssl_return_error(s);
--- 391,407 ----
  		X509_free(s->session->peer);
  
  	/* hmmm, can we have the problem of the other session with this
! 	 * cert, Free's it before we increment the reference count. */
  	CRYPTO_w_lock(CRYPTO_LOCK_X509);
  	s->session->peer=s->session->cert->x509;
  	s->session->peer->references++;
  	CRYPTO_w_unlock(CRYPTO_LOCK_X509);
  
  	/* get conn_id */
  	if (s->conn_id_length != s->state_conn_id_length)
  		{
! 		if (s->conn_id) Free(s->conn_id);
! 		s->conn_id=(unsigned char *)Malloc(s->state_conn_id_length);
  		if (s->conn_id == NULL)
  			{
  			ssl_return_error(s);
***************
*** 469,475 ****
  
  		s->challenge_length=CHALLENGE_LENGTH;
  		s2n(CHALLENGE_LENGTH,p);		/* challenge length */
! 		s->challenge=(unsigned char *)malloc(CHALLENGE_LENGTH);
  		if (s->challenge == NULL)
  			{
  			ssl_return_error(s);
--- 467,474 ----
  
  		s->challenge_length=CHALLENGE_LENGTH;
  		s2n(CHALLENGE_LENGTH,p);		/* challenge length */
! 		if (s->challenge != NULL) Free(s->challenge);
! 		s->challenge=(unsigned char *)Malloc(CHALLENGE_LENGTH);
  		if (s->challenge == NULL)
  			{
  			ssl_return_error(s);
***************
*** 515,521 ****
  		/* make a master key */
  		i=s->session->master_key_length=(unsigned char)
  			s->session->cipher->key_size;
! 		s->session->master_key=(unsigned char *)malloc((unsigned int)i+1);
  		if (s->session->master_key == NULL)
  			{
  			ssl_return_error(s);
--- 514,520 ----
  		/* make a master key */
  		i=s->session->master_key_length=(unsigned char)
  			s->session->cipher->key_size;
! 		s->session->master_key=(unsigned char *)Malloc((unsigned int)i+1);
  		if (s->session->master_key == NULL)
  			{
  			ssl_return_error(s);
***************
*** 541,547 ****
  		else
  			{
  			s->session->key_arg=(unsigned char *)
! 				malloc((unsigned int)i);
  			if (s->session->key_arg == NULL)
  				{
  				ssl_return_error(s);
--- 540,546 ----
  		else
  			{
  			s->session->key_arg=(unsigned char *)
! 				Malloc((unsigned int)i);
  			if (s->session->key_arg == NULL)
  				{
  				ssl_return_error(s);
***************
*** 830,838 ****
  				SSL_SESSION_ID_LENGTH))
  			{
  			if (s->session->session_id)
! 				free(s->session->session_id);
  			s->session->session_id=(unsigned char *)
! 				malloc(SSL_SESSION_ID_LENGTH);
  			if (s->session->session_id == NULL)
  				{
  				ssl_return_error(s);
--- 829,837 ----
  				SSL_SESSION_ID_LENGTH))
  			{
  			if (s->session->session_id)
! 				Free(s->session->session_id);
  			s->session->session_id=(unsigned char *)
! 				Malloc(SSL_SESSION_ID_LENGTH);
  			if (s->session->session_id == NULL)
  				{
  				ssl_return_error(s);
*** /var/spool/ftp/pub/Crypto/SSL/064/SSLeay-0.6.3/./ssl/ssl_des.c	Wed Jul 24 14:27:10 1996
--- ./ssl/ssl_des.c	Thu Aug 29 23:50:27 1996
***************
*** 67,74 ****
  	DES_CBC_STATE *ds;
  
  	if (s->crypt_state == NULL)
! 		s->crypt_state=(char *)malloc(sizeof(DES_CBC_STATE));
  	if (s->crypt_state == NULL) goto err;
  
  	ds=(DES_CBC_STATE *)s->crypt_state;
  
--- 67,76 ----
  	DES_CBC_STATE *ds;
  
  	if (s->crypt_state == NULL)
! 		{
! 		s->crypt_state=(char *)Malloc(sizeof(DES_CBC_STATE));
  		if (s->crypt_state == NULL) goto err;
+ 		}
  
  	ds=(DES_CBC_STATE *)s->crypt_state;
  
***************
*** 75,83 ****
  	if (s->key_material != NULL)
  		{
  		memset(s->key_material,0,s->key_material_length);
! 		free(s->key_material);
  		}
! 	s->key_material=(unsigned char *)malloc(MD5_DIGEST_LENGTH);
  	if (s->key_material == NULL) goto err;
  	s->key_material_length=MD5_DIGEST_LENGTH;
  
--- 77,85 ----
  	if (s->key_material != NULL)
  		{
  		memset(s->key_material,0,s->key_material_length);
! 		Free(s->key_material);
  		}
! 	s->key_material=(unsigned char *)Malloc(MD5_DIGEST_LENGTH);
  	if (s->key_material == NULL) goto err;
  	s->key_material_length=MD5_DIGEST_LENGTH;
  
***************
*** 160,175 ****
  	DES_EDE3_CBC_STATE *ds;
  
  	if (s->crypt_state == NULL)
! 		s->crypt_state=(char *)malloc(sizeof(DES_EDE3_CBC_STATE));
  	if (s->crypt_state == NULL) goto err;
  	ds=(DES_EDE3_CBC_STATE *)s->crypt_state;
  
  	if (s->key_material != NULL)
  		{
  		memset(s->key_material,0,s->key_material_length);
! 		free(s->key_material);
  		}
! 	s->key_material=(unsigned char *)malloc(MD5_DIGEST_LENGTH*3);
  	if (s->key_material == NULL) goto err;
  	s->key_material_length=MD5_DIGEST_LENGTH*3;
  
--- 162,179 ----
  	DES_EDE3_CBC_STATE *ds;
  
  	if (s->crypt_state == NULL)
! 		{
! 		s->crypt_state=(char *)Malloc(sizeof(DES_EDE3_CBC_STATE));
  		if (s->crypt_state == NULL) goto err;
+ 		}
  	ds=(DES_EDE3_CBC_STATE *)s->crypt_state;
  
  	if (s->key_material != NULL)
  		{
  		memset(s->key_material,0,s->key_material_length);
! 		Free(s->key_material);
  		}
! 	s->key_material=(unsigned char *)Malloc(MD5_DIGEST_LENGTH*3);
  	if (s->key_material == NULL) goto err;
  	s->key_material_length=MD5_DIGEST_LENGTH*3;
  
***************
*** 269,284 ****
  	DES_CFB_STATE *ds;
  
  	if (s->crypt_state == NULL)
! 		s->crypt_state=(char *)malloc(sizeof(DES_CFB_STATE));
  	if (s->crypt_state == NULL) goto err;
  	ds=(DES_CFB_STATE *)s->crypt_state;
  
  	if (s->key_material != NULL)
  		{
  		memset(s->key_material,0,s->key_material_length);
! 		free(s->key_material);
  		}
! 	s->key_material=(unsigned char *)malloc(MD5_DIGEST_LENGTH);
  	if (s->key_material == NULL) goto err;
  	s->key_material_length=MD5_DIGEST_LENGTH;
  
--- 273,290 ----
  	DES_CFB_STATE *ds;
  
  	if (s->crypt_state == NULL)
! 		{
! 		s->crypt_state=(char *)Malloc(sizeof(DES_CFB_STATE));
  		if (s->crypt_state == NULL) goto err;
+ 		}
  	ds=(DES_CFB_STATE *)s->crypt_state;
  
  	if (s->key_material != NULL)
  		{
  		memset(s->key_material,0,s->key_material_length);
! 		Free(s->key_material);
  		}
! 	s->key_material=(unsigned char *)Malloc(MD5_DIGEST_LENGTH);
  	if (s->key_material == NULL) goto err;
  	s->key_material_length=MD5_DIGEST_LENGTH;
  
*** /var/spool/ftp/pub/Crypto/SSL/064/SSLeay-0.6.3/./ssl/ssl_idea.c	Wed Jul 24 14:27:10 1996
--- ./ssl/ssl_idea.c	Thu Aug 29 23:50:27 1996
***************
*** 72,78 ****
  	IDEA_CBC_STATE *is;
  
  	if (s->crypt_state == NULL)
! 		s->crypt_state=(char *)malloc(sizeof(IDEA_CBC_STATE));
  	if (s->crypt_state == NULL) goto err;
  	is=(IDEA_CBC_STATE *)s->crypt_state;
  
--- 72,78 ----
  	IDEA_CBC_STATE *is;
  
  	if (s->crypt_state == NULL)
! 		s->crypt_state=(char *)Malloc(sizeof(IDEA_CBC_STATE));
  	if (s->crypt_state == NULL) goto err;
  	is=(IDEA_CBC_STATE *)s->crypt_state;
  
***************
*** 79,87 ****
  	if (s->key_material != NULL)
  		{
  		memset(s->key_material,0,s->key_material_length);
! 		free(s->key_material);
  		}
! 	md5d1=s->key_material=(unsigned char *)malloc(MD5_DIGEST_LENGTH*2);
  	if (s->key_material == NULL) goto err;
  	s->key_material_length=MD5_DIGEST_LENGTH*2;
  	md5d2= &(s->key_material[MD5_DIGEST_LENGTH]);
--- 79,87 ----
  	if (s->key_material != NULL)
  		{
  		memset(s->key_material,0,s->key_material_length);
! 		Free(s->key_material);
  		}
! 	md5d1=s->key_material=(unsigned char *)Malloc(MD5_DIGEST_LENGTH*2);
  	if (s->key_material == NULL) goto err;
  	s->key_material_length=MD5_DIGEST_LENGTH*2;
  	md5d2= &(s->key_material[MD5_DIGEST_LENGTH]);
*** /var/spool/ftp/pub/Crypto/SSL/064/SSLeay-0.6.3/./ssl/ssl_lib.c	Tue Aug  6 15:57:45 1996
--- ./ssl/ssl_lib.c	Fri Aug 30 00:58:29 1996
***************
*** 61,67 ****
  #include "ssl_rsa.h"
  #include "ssl_null.h"
  
! char *SSL_version="SSLeay 0.6.3 06-Aug-1996";
  
  /* THIS ARRAY MUST BE KEPT ORDERED BY c1, c2 and c3.
   * basically the second last 'value' which is a #define for these 3
--- 61,67 ----
  #include "ssl_rsa.h"
  #include "ssl_null.h"
  
! char *SSL_version="SSLeay 0.6.4 30-Aug-1996";
  
  /* THIS ARRAY MUST BE KEPT ORDERED BY c1, c2 and c3.
   * basically the second last 'value' which is a #define for these 3
***************
*** 69,75 ****
  CIPHER ssl_ciphers[SSL_NUM_CIPHERS]={
  /* NULL_WITH_MD5 v3 */
  	{	1,SSL_TXT_NULL_WITH_MD5,
! 	ssl_enc_null_init,(void (*)())free,
  	ssl_enc_null, ssl_compute_md5_mac,
  	8,MD5_MAC_SIZE,1,0,SSL_CK_NULL_WITH_MD5,0},
  
--- 69,75 ----
  CIPHER ssl_ciphers[SSL_NUM_CIPHERS]={
  /* NULL_WITH_MD5 v3 */
  	{	1,SSL_TXT_NULL_WITH_MD5,
! 	ssl_enc_null_init,(void (*)())FreeFunc,
  	ssl_enc_null, ssl_compute_md5_mac,
  	8,MD5_MAC_SIZE,1,0,SSL_CK_NULL_WITH_MD5,0},
  
***************
*** 76,88 ****
  #ifndef NO_RC4
  /* RC4_128_WITH_MD5 */
  	{	1,SSL_TXT_RC4_128_WITH_MD5,
! 	ssl_enc_rc4_init,(void (*)())free,
  	ssl_enc_rc4,ssl_compute_md5_mac,
  	16,MD5_MAC_SIZE,1,0,SSL_CK_RC4_128_WITH_MD5,0},
  
  /* RC4_128_EXPORT40_WITH_MD5 */
  	{	1,SSL_TXT_RC4_128_EXPORT40_WITH_MD5,
! 	ssl_enc_rc4_init,(void (*)())free,
  	ssl_enc_rc4,ssl_compute_md5_mac,
  	16,MD5_MAC_SIZE,1,0, SSL_CK_RC4_128_EXPORT40_WITH_MD5,40},
  #endif
--- 76,88 ----
  #ifndef NO_RC4
  /* RC4_128_WITH_MD5 */
  	{	1,SSL_TXT_RC4_128_WITH_MD5,
! 	ssl_enc_rc4_init,(void (*)())FreeFunc,
  	ssl_enc_rc4,ssl_compute_md5_mac,
  	16,MD5_MAC_SIZE,1,0,SSL_CK_RC4_128_WITH_MD5,0},
  
  /* RC4_128_EXPORT40_WITH_MD5 */
  	{	1,SSL_TXT_RC4_128_EXPORT40_WITH_MD5,
! 	ssl_enc_rc4_init,(void (*)())FreeFunc,
  	ssl_enc_rc4,ssl_compute_md5_mac,
  	16,MD5_MAC_SIZE,1,0, SSL_CK_RC4_128_EXPORT40_WITH_MD5,40},
  #endif
***************
*** 90,96 ****
  #ifndef NO_RC2
  /* RC2_128_CBC_WITH_MD5 */
  	{	1,SSL_TXT_RC2_128_CBC_WITH_MD5,
! 	ssl_enc_rc2_cbc_init,(void (*)())free,
  	ssl_enc_rc2_cbc,ssl_compute_md5_mac,
  	16,MD5_MAC_SIZE,8,8,SSL_CK_RC2_128_CBC_WITH_MD5,0},
  
--- 90,96 ----
  #ifndef NO_RC2
  /* RC2_128_CBC_WITH_MD5 */
  	{	1,SSL_TXT_RC2_128_CBC_WITH_MD5,
! 	ssl_enc_rc2_cbc_init,(void (*)())FreeFunc,
  	ssl_enc_rc2_cbc,ssl_compute_md5_mac,
  	16,MD5_MAC_SIZE,8,8,SSL_CK_RC2_128_CBC_WITH_MD5,0},
  
***************
*** 97,103 ****
  /* RC2_128_CBC_EXPORT40_WITH_MD5 */
  	{	1,SSL_TXT_RC2_128_CBC_EXPORT40_WITH_MD5,
  	ssl_enc_rc2_cbc_init,(void (*)())
! 	free,ssl_enc_rc2_cbc,ssl_compute_md5_mac,
  	16,MD5_MAC_SIZE,8,8,SSL_CK_RC2_128_CBC_EXPORT40_WITH_MD5,40},
  #endif
  
--- 97,103 ----
  /* RC2_128_CBC_EXPORT40_WITH_MD5 */
  	{	1,SSL_TXT_RC2_128_CBC_EXPORT40_WITH_MD5,
  	ssl_enc_rc2_cbc_init,(void (*)())
! 	FreeFunc,ssl_enc_rc2_cbc,ssl_compute_md5_mac,
  	16,MD5_MAC_SIZE,8,8,SSL_CK_RC2_128_CBC_EXPORT40_WITH_MD5,40},
  #endif
  
***************
*** 104,110 ****
  #ifndef NO_IDEA
  /* IDEA_128_CBC_WITH_MD5 */
  	{	1,SSL_TXT_IDEA_128_CBC_WITH_MD5,
! 	ssl_enc_idea_cbc_init,(void (*)())free,
  	ssl_enc_idea_cbc,ssl_compute_md5_mac,
  	16,MD5_MAC_SIZE,8,8, SSL_CK_IDEA_128_CBC_WITH_MD5,0},
  #endif
--- 104,110 ----
  #ifndef NO_IDEA
  /* IDEA_128_CBC_WITH_MD5 */
  	{	1,SSL_TXT_IDEA_128_CBC_WITH_MD5,
! 	ssl_enc_idea_cbc_init,(void (*)())FreeFunc,
  	ssl_enc_idea_cbc,ssl_compute_md5_mac,
  	16,MD5_MAC_SIZE,8,8, SSL_CK_IDEA_128_CBC_WITH_MD5,0},
  #endif
***************
*** 111,117 ****
  
  /* DES_64_CBC_WITH_MD5 */
  	{	1,SSL_TXT_DES_64_CBC_WITH_MD5,
! 	ssl_enc_des_cbc_init,(void (*)())free,
  	ssl_enc_des_cbc,ssl_compute_md5_mac,
  	8,MD5_MAC_SIZE,8,8,
  	SSL_CK_DES_64_CBC_WITH_MD5,0},
--- 111,117 ----
  
  /* DES_64_CBC_WITH_MD5 */
  	{	1,SSL_TXT_DES_64_CBC_WITH_MD5,
! 	ssl_enc_des_cbc_init,(void (*)())FreeFunc,
  	ssl_enc_des_cbc,ssl_compute_md5_mac,
  	8,MD5_MAC_SIZE,8,8,
  	SSL_CK_DES_64_CBC_WITH_MD5,0},
***************
*** 118,124 ****
  
  /* DES_64_CBC_WITH_SHA */
  	{	1,SSL_TXT_DES_64_CBC_WITH_SHA,
! 	ssl_enc_des_cbc_init,(void (*)())free,
  	ssl_enc_des_cbc,ssl_compute_sha_mac,
  	8,SHA_MAC_SIZE,8,8,
  	SSL_CK_DES_64_CBC_WITH_SHA,0},
--- 118,124 ----
  
  /* DES_64_CBC_WITH_SHA */
  	{	1,SSL_TXT_DES_64_CBC_WITH_SHA,
! 	ssl_enc_des_cbc_init,(void (*)())FreeFunc,
  	ssl_enc_des_cbc,ssl_compute_sha_mac,
  	8,SHA_MAC_SIZE,8,8,
  	SSL_CK_DES_64_CBC_WITH_SHA,0},
***************
*** 125,131 ****
  
  /* DES_192_EDE3_CBC_WITH_MD5 */
  	{	1,SSL_TXT_DES_192_EDE3_CBC_WITH_MD5,
! 	ssl_enc_des_ede3_cbc_init,(void (*)())free,
  	ssl_enc_des_ede3_cbc,ssl_compute_md5_mac,
  	24,MD5_MAC_SIZE,8,8,
  	SSL_CK_DES_192_EDE3_CBC_WITH_MD5,0},
--- 125,131 ----
  
  /* DES_192_EDE3_CBC_WITH_MD5 */
  	{	1,SSL_TXT_DES_192_EDE3_CBC_WITH_MD5,
! 	ssl_enc_des_ede3_cbc_init,(void (*)())FreeFunc,
  	ssl_enc_des_ede3_cbc,ssl_compute_md5_mac,
  	24,MD5_MAC_SIZE,8,8,
  	SSL_CK_DES_192_EDE3_CBC_WITH_MD5,0},
***************
*** 132,138 ****
  
  /* DES_192_EDE3_CBC_WITH_SHA */
  	{	1,SSL_TXT_DES_192_EDE3_CBC_WITH_SHA,
! 	ssl_enc_des_ede3_cbc_init,(void (*)())free,
  	ssl_enc_des_ede3_cbc,ssl_compute_sha_mac,
  	24,SHA_MAC_SIZE,8,8,
  	SSL_CK_DES_192_EDE3_CBC_WITH_SHA,0},
--- 132,138 ----
  
  /* DES_192_EDE3_CBC_WITH_SHA */
  	{	1,SSL_TXT_DES_192_EDE3_CBC_WITH_SHA,
! 	ssl_enc_des_ede3_cbc_init,(void (*)())FreeFunc,
  	ssl_enc_des_ede3_cbc,ssl_compute_sha_mac,
  	24,SHA_MAC_SIZE,8,8,
  	SSL_CK_DES_192_EDE3_CBC_WITH_SHA,0},
***************
*** 139,145 ****
  
  /* DES_64_CFB64_WITH_MD5_1 SSLeay */
  	{	1,SSL_TXT_DES_64_CFB64_WITH_MD5_1,
! 	ssl_enc_des_cfb_init,(void (*)())free,
  	ssl_enc_des_cfb,ssl_compute_md5_mac_1,
  	8,1,1,8,
  	SSL_CK_DES_64_CFB64_WITH_MD5_1,0},
--- 139,145 ----
  
  /* DES_64_CFB64_WITH_MD5_1 SSLeay */
  	{	1,SSL_TXT_DES_64_CFB64_WITH_MD5_1,
! 	ssl_enc_des_cfb_init,(void (*)())FreeFunc,
  	ssl_enc_des_cfb,ssl_compute_md5_mac_1,
  	8,1,1,8,
  	SSL_CK_DES_64_CFB64_WITH_MD5_1,0},
***************
*** 146,152 ****
  
  /* NULL SSLeay (testing) */
  	{	0,SSL_TXT_NULL,
! 	ssl_enc_null_init,(void (*)())free,
  	ssl_enc_null,ssl_compute_null_mac,
  	0,0,1,0,SSL_CK_NULL,0},
  
--- 146,152 ----
  
  /* NULL SSLeay (testing) */
  	{	0,SSL_TXT_NULL,
! 	ssl_enc_null_init,(void (*)())FreeFunc,
  	ssl_enc_null,ssl_compute_null_mac,
  	0,0,1,0,SSL_CK_NULL,0},
  
***************
*** 217,227 ****
  	s->rwstate=SSL_NOTHING;
  	s->state=SSL_ST_BEFORE;
  	s->rstate=SSL_ST_READ_HEADER;
! 	if (s->init_buf != NULL) free(s->init_buf);
  	s->init_buf=NULL;
  
! 	if (s->state_ccl != NULL) free(s->state_ccl);
  	s->state_ccl=NULL;
  	s->read_ahead=s->ctx->default_read_ahead;
  	s->wnum=0;
  	s->wpend_tot=0;
--- 217,232 ----
  	s->rwstate=SSL_NOTHING;
  	s->state=SSL_ST_BEFORE;
  	s->rstate=SSL_ST_READ_HEADER;
! 	if (s->init_buf != NULL)
! 		{
! 		Free(s->init_buf);
  		s->init_buf=NULL;
+ 		}
  
! 	if (s->state_ccl != NULL)
! 		{Free(s->state_ccl);
  		s->state_ccl=NULL;
+ 		}
  	s->read_ahead=s->ctx->default_read_ahead;
  	s->wnum=0;
  	s->wpend_tot=0;
***************
*** 246,267 ****
  	s->mac_data=NULL;
  	s->pad_data=NULL;
  
! 	if (s->crypt_state != NULL) free(s->crypt_state);
! 	s->crypt_state=NULL;
  	s->read_key=NULL;
  	s->write_key=NULL;
  
  	s->challenge_length=0;
! 	if (s->challenge != NULL) free(s->challenge);
  	s->challenge=NULL;
  
  	s->conn_id_length=0;
! 	if (s->conn_id != NULL) free(s->conn_id);
  	s->conn_id=NULL;
  
  	s->key_material_length=0;
! 	if (s->key_material != NULL) free(s->key_material);
  	s->key_material=NULL;
  
  	s->send=0;
  	s->clear_text=1;
--- 251,281 ----
  	s->mac_data=NULL;
  	s->pad_data=NULL;
  
! 	/* s->crypt_state=NULL; */
! 
  	s->read_key=NULL;
  	s->write_key=NULL;
  
  	s->challenge_length=0;
! 	if (s->challenge != NULL)
! 		{
! 		Free(s->challenge);
  		s->challenge=NULL;
+ 		}
  
  	s->conn_id_length=0;
! 	if (s->conn_id != NULL) 
! 		{
! 		Free(s->conn_id);
  		s->conn_id=NULL;
+ 		}
  
  	s->key_material_length=0;
! 	if (s->key_material != NULL)
! 		{
! 		Free(s->key_material);
  		s->key_material=NULL;
+ 		}
  
  	s->send=0;
  	s->clear_text=1;
***************
*** 284,298 ****
  		return(NULL);
  		}
  
! 	s=(SSL *)malloc(sizeof(SSL));
  	if (s == NULL) goto err;
  
  	s->rbio=NULL;
  	s->wbio=NULL;
  	s->init_buf=NULL;
! 	s->rbuf=(unsigned char *)malloc(SSL_MAX_RECORD_LENGTH_2_BYTE_HEADER+2);
  	if (s->rbuf == NULL) goto err;
! 	s->wbuf=(unsigned char *)malloc(SSL_MAX_RECORD_LENGTH_2_BYTE_HEADER+2);
  	if (s->wbuf == NULL) goto err;
  	s->num_cipher_list=0;
  	s->cipher_list=NULL;
--- 298,313 ----
  		return(NULL);
  		}
  
! 	s=(SSL *)Malloc(sizeof(SSL));
  	if (s == NULL) goto err;
  
  	s->rbio=NULL;
  	s->wbio=NULL;
+ 	s->bbio=NULL;
  	s->init_buf=NULL;
! 	s->rbuf=(unsigned char *)Malloc(SSL_MAX_RECORD_LENGTH_2_BYTE_HEADER+2);
  	if (s->rbuf == NULL) goto err;
! 	s->wbuf=(unsigned char *)Malloc(SSL_MAX_RECORD_LENGTH_2_BYTE_HEADER+2);
  	if (s->wbuf == NULL) goto err;
  	s->num_cipher_list=0;
  	s->cipher_list=NULL;
***************
*** 301,317 ****
  	s->conn_id=NULL;
  	s->key_material=NULL;
  	s->session=NULL;
- 	s->cert=ctx->default_cert;
  	if (ctx->default_cert != NULL)
  		{
! 		CRYPTO_add(&ctx->default_cert->references,1,CRYPTO_LOCK_X509);
  		}
  	s->verify_mode=ctx->default_verify_mode;
  	s->verify_callback=ctx->default_verify_callback;
- 	s->ctx=ctx;
  	s->debug=0;
  	s->info_callback=NULL;
  	CRYPTO_add(&ctx->references,1,CRYPTO_LOCK_SSL_CTX);
  	s->state_ccl=NULL;
  
  	s->verify_result=VERIFY_OK;
--- 316,335 ----
  	s->conn_id=NULL;
  	s->key_material=NULL;
  	s->session=NULL;
  	if (ctx->default_cert != NULL)
  		{
! 		CRYPTO_add(&ctx->default_cert->references,1,
! 			CRYPTO_LOCK_SSL_CERT);
! 		s->cert=ctx->default_cert;
  		}
+ 	else
+ 		s->cert=NULL;
  	s->verify_mode=ctx->default_verify_mode;
  	s->verify_callback=ctx->default_verify_callback;
  	s->debug=0;
  	s->info_callback=NULL;
  	CRYPTO_add(&ctx->references,1,CRYPTO_LOCK_SSL_CTX);
+ 	s->ctx=ctx;
  	s->state_ccl=NULL;
  
  	s->verify_result=VERIFY_OK;
***************
*** 327,332 ****
--- 345,360 ----
  void SSL_free(s)
  SSL *s;
  	{
+ 	if (s->bbio != NULL)
+ 		{
+ 		/* If the buffering BIO is in place, pop it off */
+ 		if (s->bbio == s->wbio)
+ 			{
+ 			BIO_pop(s->bbio,&s->wbio);
+ 			BIO_push(s->bbio,NULL);
+ 			}
+ 		BIO_free(s->bbio);
+ 		}
  	if (s->rbio != NULL)
  		BIO_free(s->rbio);
  	if ((s->wbio != NULL) && (s->wbio != s->rbio))
***************
*** 333,346 ****
  		BIO_free(s->wbio);
  
  	/* add extra stuff */
! 	free(s->rbuf);
! 	free(s->wbuf);
  	if (s->cipher_list != NULL)
  		{
! 		free(s->cipher_list[0]);
! 		free(s->cipher_list);
  		}
! 	if (s->init_buf != NULL) free(s->init_buf);
  	if ((s->session != NULL) && (s->session->cipher != NULL) &&
  		(s->session->cipher->crypt_cleanup != NULL) &&
  		(s->crypt_state != NULL))
--- 361,374 ----
  		BIO_free(s->wbio);
  
  	/* add extra stuff */
! 	Free(s->rbuf);
! 	Free(s->wbuf);
  	if (s->cipher_list != NULL)
  		{
! 		Free(s->cipher_list[0]);
! 		Free(s->cipher_list);
  		}
! 	if (s->init_buf != NULL) Free(s->init_buf);
  	if ((s->session != NULL) && (s->session->cipher != NULL) &&
  		(s->session->cipher->crypt_cleanup != NULL) &&
  		(s->crypt_state != NULL))
***************
*** 347,360 ****
  		s->session->cipher->crypt_cleanup(s->crypt_state);
  	if (s->session != NULL) SSL_SESSION_free(s->session);
  	if (s->cert != NULL) ssl_cert_free(s->cert);
! 	if (s->challenge != NULL) free(s->challenge);
! 	if (s->conn_id != NULL) free(s->conn_id);
! 	if (s->key_material != NULL) free(s->key_material);
! 	if (s->state_ccl != NULL) free(s->state_ccl);
! 	/* free up if allocated */
  
  	if (s->ctx) SSL_CTX_free(s->ctx);
! 	free((char *)s);
  	}
  
  void ssl_print_bytes(f, n, b)
--- 375,388 ----
  		s->session->cipher->crypt_cleanup(s->crypt_state);
  	if (s->session != NULL) SSL_SESSION_free(s->session);
  	if (s->cert != NULL) ssl_cert_free(s->cert);
! 	if (s->challenge != NULL) Free(s->challenge);
! 	if (s->conn_id != NULL) Free(s->conn_id);
! 	if (s->key_material != NULL) Free(s->key_material);
! 	if (s->state_ccl != NULL) Free(s->state_ccl);
! 	/* Free up if allocated */
  
  	if (s->ctx) SSL_CTX_free(s->ctx);
! 	Free((char *)s);
  	}
  
  void ssl_print_bytes(f, n, b)
***************
*** 512,520 ****
  	i=(*p == '\0')?0:1;
  	for (; *p; p++)
  		if (*p == ':') i++;
! 	pp=(char **)malloc(sizeof(char *)*(i+1));
  	if (pp == NULL) goto err;
! 	pp[0]=(char *)malloc(strlen(str)+1);
  	if (pp[0] == NULL) goto err;
  	strcpy(pp[0],str);
  	p=pp[0];
--- 540,548 ----
  	i=(*p == '\0')?0:1;
  	for (; *p; p++)
  		if (*p == ':') i++;
! 	pp=(char **)Malloc(sizeof(char *)*(i+1));
  	if (pp == NULL) goto err;
! 	pp[0]=(char *)Malloc(strlen(str)+1);
  	if (pp[0] == NULL) goto err;
  	strcpy(pp[0],str);
  	p=pp[0];
***************
*** 531,538 ****
  	pp[j]=NULL;
  	if (*rp != NULL)
  		{
! 		free(*rp[0]);
! 		free(*rp);
  		}
  
  	*rp=pp;
--- 559,566 ----
  	pp[j]=NULL;
  	if (*rp != NULL)
  		{
! 		Free(*rp[0]);
! 		Free(*rp);
  		}
  
  	*rp=pp;
***************
*** 547,558 ****
  SSL *s;
  int n;
  	{
! 	if (s->num_cipher_list > 0)
  		{
  		if (n < s->num_cipher_list)
  			return(s->cipher_list[n]);
  		}
! 	else if (s->ctx->num_cipher_list > 0)
  		{
  		if (n < s->ctx->num_cipher_list)
  			return(s->ctx->cipher_list[n]);
--- 575,587 ----
  SSL *s;
  int n;
  	{
! 	if ((s != NULL) && (s->num_cipher_list > 0))
  		{
  		if (n < s->num_cipher_list)
  			return(s->cipher_list[n]);
  		}
! 	else if ((s != NULL) && (s->ctx != NULL) &&
! 		(s->ctx->num_cipher_list > 0))
  		{
  		if (n < s->ctx->num_cipher_list)
  			return(s->ctx->cipher_list[n]);
***************
*** 573,578 ****
--- 602,631 ----
  	return(NULL);
  	}
  
+ int SSL_get_cipher_bits(s,alg_bits)
+ SSL *s;
+ int *alg_bits;
+ 	{
+ 	int ret=0;
+ 	CIPHER *c;
+ 
+ 	if ((s->session != NULL) && (s->session->cipher != NULL))
+ 		{
+ 		c=s->session->cipher;
+ 		if (c->enc_bits != 0)
+ 			ret=c->enc_bits;
+ 		else
+ 			ret=c->c3;
+ 		if (alg_bits != NULL) *alg_bits=c->c3;
+ 		}
+ 	else
+ 		{
+ 		if (alg_bits != NULL) *alg_bits=0;
+ 		}
+ 	
+ 	return(ret);
+ 	}
+ 
  char *SSL_get_shared_ciphers(s,buf,len)
  SSL *s;
  char *buf;
***************
*** 640,664 ****
  	{
  	X509 *r;
  	
- 	CRYPTO_w_lock(CRYPTO_LOCK_X509);
- 	CRYPTO_r_lock(CRYPTO_LOCK_SSL_SESSION);
- 
  	if ((s == NULL) || (s->session == NULL))
  		r=NULL;
  	else
  		r=s->session->peer;
  
! 	CRYPTO_r_unlock(CRYPTO_LOCK_SSL_SESSION);
  
! 	if (r == NULL)
! 		{
! 		CRYPTO_w_unlock(CRYPTO_LOCK_X509);
! 		return(0);
! 		}
  
- 	r->references++;
- 	CRYPTO_w_unlock(CRYPTO_LOCK_X509);
- 
  	return(r);
  	}
  
--- 693,707 ----
  	{
  	X509 *r;
  	
  	if ((s == NULL) || (s->session == NULL))
  		r=NULL;
  	else
  		r=s->session->peer;
  
! 	if (r == NULL) return(0);
  
! 	CRYPTO_add(&r->references,1,CRYPTO_LOCK_X509);
  
  	return(r);
  	}
  
***************
*** 715,727 ****
  void SSL_copy_session_id(t,f)
  SSL *t,*f;
  	{
  	/* Do we need to to SSL locking? */
  	SSL_set_session(t,SSL_get_session(f));
  
! 	CRYPTO_r_lock(CRYPTO_LOCK_X509);
! 	if (t->cert != NULL) ssl_cert_free(t->cert);
! 	if (f->cert != NULL) f->cert->references++;
! 
  	t->cert=f->cert;
! 	CRYPTO_r_unlock(CRYPTO_LOCK_X509);
  	}
--- 758,775 ----
  void SSL_copy_session_id(t,f)
  SSL *t,*f;
  	{
+ 	CERT *tmp;
+ 
  	/* Do we need to to SSL locking? */
  	SSL_set_session(t,SSL_get_session(f));
  
! 	tmp=t->cert;
! 	if (f->cert != NULL)
! 		{
! 		CRYPTO_add(&f->cert->references,1,CRYPTO_LOCK_SSL_CERT);
  		t->cert=f->cert;
! 		}
! 	else
! 		t->cert=NULL;
! 	if (tmp != NULL) ssl_cert_free(tmp);
  	}
*** /var/spool/ftp/pub/Crypto/SSL/064/SSLeay-0.6.3/./ssl/ssl_locl.h	Sat Jul 27 14:47:23 1996
--- ./ssl/ssl_locl.h	Thu Aug 29 23:50:27 1996
***************
*** 53,60 ****
  
  #include "../e_os.h"
  
- #include "crypto.h"
  #include "buffer.h"
  #include "rsa.h"
  #include "x509.h"
  
--- 53,60 ----
  
  #include "../e_os.h"
  
  #include "buffer.h"
+ #include "crypto.h"
  #include "rsa.h"
  #include "x509.h"
  
*** /var/spool/ftp/pub/Crypto/SSL/064/SSLeay-0.6.3/./ssl/ssl_null.c	Wed Jul 24 14:27:10 1996
--- ./ssl/ssl_null.c	Thu Aug 29 23:50:27 1996
***************
*** 56,62 ****
  	NULL_STATE *ns;
  
  	if (s->crypt_state == NULL)
! 		s->crypt_state=(char *)malloc(sizeof(NULL_STATE));
  	if (s->crypt_state == NULL)
  		goto err;
  	ns=(NULL_STATE *)s->crypt_state;
--- 56,62 ----
  	NULL_STATE *ns;
  
  	if (s->crypt_state == NULL)
! 		s->crypt_state=(char *)Malloc(sizeof(NULL_STATE));
  	if (s->crypt_state == NULL)
  		goto err;
  	ns=(NULL_STATE *)s->crypt_state;
*** /var/spool/ftp/pub/Crypto/SSL/064/SSLeay-0.6.3/./ssl/ssl_pkt.c	Wed Jul 24 14:27:10 1996
--- ./ssl/ssl_pkt.c	Thu Aug 29 23:50:27 1996
***************
*** 332,343 ****
  		SSLerr(SSL_F_WRITE_PENDING,SSL_R_BAD_WRITE_RETRY);
  		return(SSL_RWERR_BAD_WRITE_RETRY);
  		}
  	for (;;)
  		{
  		errno=0;
  		if (s->wbio != NULL)
  			{
! 			i=BIO_write(s->wbio,(char *)&(s->write_ptr[s->wpend_off]),
  				(unsigned int)s->wpend_len);
  			}
  		else
--- 332,345 ----
  		SSLerr(SSL_F_WRITE_PENDING,SSL_R_BAD_WRITE_RETRY);
  		return(SSL_RWERR_BAD_WRITE_RETRY);
  		}
+ 
  	for (;;)
  		{
  		errno=0;
  		if (s->wbio != NULL)
  			{
! 			i=BIO_write(s->wbio,
! 				(char *)&(s->write_ptr[s->wpend_off]),
  				(unsigned int)s->wpend_len);
  			}
  		else
*** /var/spool/ftp/pub/Crypto/SSL/064/SSLeay-0.6.3/./ssl/ssl_rc2.c	Wed Jul 24 14:27:10 1996
--- ./ssl/ssl_rc2.c	Thu Aug 29 23:50:27 1996
***************
*** 65,71 ****
  	RC2_CBC_STATE *ds;
  
  	if (s->crypt_state == NULL)
! 		s->crypt_state=(char *)malloc(sizeof(RC2_CBC_STATE));
  	if (s->crypt_state == NULL) goto err;
  	ds=(RC2_CBC_STATE *)s->crypt_state;
  
--- 65,71 ----
  	RC2_CBC_STATE *ds;
  
  	if (s->crypt_state == NULL)
! 		s->crypt_state=(char *)Malloc(sizeof(RC2_CBC_STATE));
  	if (s->crypt_state == NULL) goto err;
  	ds=(RC2_CBC_STATE *)s->crypt_state;
  
***************
*** 72,80 ****
  	if (s->key_material != NULL)
  		{
  		memset(s->key_material,0,s->key_material_length);
! 		free(s->key_material);
  		}
! 	md5d1=s->key_material=(unsigned char *)malloc(MD5_DIGEST_LENGTH*2);
  	if (s->key_material == NULL) goto err;
  	md5d2= &(s->key_material[MD5_DIGEST_LENGTH]);
  	s->key_material_length=MD5_DIGEST_LENGTH*2;
--- 72,80 ----
  	if (s->key_material != NULL)
  		{
  		memset(s->key_material,0,s->key_material_length);
! 		Free(s->key_material);
  		}
! 	md5d1=s->key_material=(unsigned char *)Malloc(MD5_DIGEST_LENGTH*2);
  	if (s->key_material == NULL) goto err;
  	md5d2= &(s->key_material[MD5_DIGEST_LENGTH]);
  	s->key_material_length=MD5_DIGEST_LENGTH*2;
***************
*** 83,97 ****
  
  	if (client)
  		{
! 		RC2_set_key(&(ds->rc2_read_ks),16,md5d1);
! 		RC2_set_key(&(ds->rc2_write_ks),16,md5d2);
  		s->read_key= md5d1;
  		s->write_key= md5d2;
  		}
  	else
  		{
! 		RC2_set_key(&(ds->rc2_read_ks),16,md5d2);
! 		RC2_set_key(&(ds->rc2_write_ks),16,md5d1);
  		s->read_key= md5d2;
  		s->write_key= md5d1;
  		}
--- 83,97 ----
  
  	if (client)
  		{
! 		RC2_set_key(&(ds->rc2_read_ks),16,md5d1,128);
! 		RC2_set_key(&(ds->rc2_write_ks),16,md5d2,128);
  		s->read_key= md5d1;
  		s->write_key= md5d2;
  		}
  	else
  		{
! 		RC2_set_key(&(ds->rc2_read_ks),16,md5d2,128);
! 		RC2_set_key(&(ds->rc2_write_ks),16,md5d1,128);
  		s->read_key= md5d2;
  		s->write_key= md5d1;
  		}
*** /var/spool/ftp/pub/Crypto/SSL/064/SSLeay-0.6.3/./ssl/ssl_rc4.c	Wed Jul 24 14:27:10 1996
--- ./ssl/ssl_rc4.c	Thu Aug 29 23:50:27 1996
***************
*** 64,70 ****
  	RC4_STATE *rc4s;
  
  	if (s->crypt_state == NULL)
! 		s->crypt_state=(char *)malloc(sizeof(RC4_STATE));
  	if (s->crypt_state == NULL) goto err;
  	rc4s=(RC4_STATE *)s->crypt_state;
  
--- 64,70 ----
  	RC4_STATE *rc4s;
  
  	if (s->crypt_state == NULL)
! 		s->crypt_state=(char *)Malloc(sizeof(RC4_STATE));
  	if (s->crypt_state == NULL) goto err;
  	rc4s=(RC4_STATE *)s->crypt_state;
  
***************
*** 71,79 ****
  	if (s->key_material != NULL)
  		{
  		memset(s->key_material,0,s->key_material_length);
! 		free(s->key_material);
  		}
! 	md5d1=s->key_material=(unsigned char *)malloc(MD5_DIGEST_LENGTH*2);
  	if (s->key_material == NULL) goto err;
  	s->key_material_length=MD5_DIGEST_LENGTH*2;
  	md5d2= &(s->key_material[MD5_DIGEST_LENGTH]);
--- 71,79 ----
  	if (s->key_material != NULL)
  		{
  		memset(s->key_material,0,s->key_material_length);
! 		Free(s->key_material);
  		}
! 	md5d1=s->key_material=(unsigned char *)Malloc(MD5_DIGEST_LENGTH*2);
  	if (s->key_material == NULL) goto err;
  	s->key_material_length=MD5_DIGEST_LENGTH*2;
  	md5d2= &(s->key_material[MD5_DIGEST_LENGTH]);
*** /var/spool/ftp/pub/Crypto/SSL/064/SSLeay-0.6.3/./ssl/ssl_rsa.c	Wed Jul 24 14:27:10 1996
--- ./ssl/ssl_rsa.c	Thu Aug 29 23:50:27 1996
***************
*** 152,159 ****
  
  	if (!ssl_set_cert_type(c,SSL_CT_X509_CERTIFICATE)) return(0);
  	if (c->x509 != NULL) X509_free(c->x509);
- 	c->x509=x;
  	CRYPTO_add(&x->references,1,CRYPTO_LOCK_X509);
  	if (c->publickey != NULL) EVP_PKEY_free(c->publickey);
  	pkey=X509_extract_key(x);
  	if (pkey == NULL)
--- 152,159 ----
  
  	if (!ssl_set_cert_type(c,SSL_CT_X509_CERTIFICATE)) return(0);
  	if (c->x509 != NULL) X509_free(c->x509);
  	CRYPTO_add(&x->references,1,CRYPTO_LOCK_X509);
+ 	c->x509=x;
  	if (c->publickey != NULL) EVP_PKEY_free(c->publickey);
  	pkey=X509_extract_key(x);
  	if (pkey == NULL)
***************
*** 463,471 ****
  	c=ctx->default_cert;
  
  	if (!ssl_set_cert_type(c,SSL_CT_X509_CERTIFICATE)) return(0);
  	if (c->x509 != NULL) X509_free(c->x509);
  	c->x509=x;
- 	CRYPTO_add(&x->references,1,CRYPTO_LOCK_X509);
  	if (c->publickey != NULL) EVP_PKEY_free(c->publickey);
  	pkey=X509_extract_key(x);
  	if (pkey == NULL)
--- 463,471 ----
  	c=ctx->default_cert;
  
  	if (!ssl_set_cert_type(c,SSL_CT_X509_CERTIFICATE)) return(0);
+ 	CRYPTO_add(&x->references,1,CRYPTO_LOCK_X509);
  	if (c->x509 != NULL) X509_free(c->x509);
  	c->x509=x;
  	if (c->publickey != NULL) EVP_PKEY_free(c->publickey);
  	pkey=X509_extract_key(x);
  	if (pkey == NULL)
***************
*** 581,588 ****
  		}
  	c->privatekey->type=EVP_PKEY_RSA;
  	c->privatekey->pkey.rsa=rsa;
- 
  	CRYPTO_add(&rsa->references,1,CRYPTO_LOCK_RSA);
  	return(1);
  	}
  
--- 581,588 ----
  		}
  	c->privatekey->type=EVP_PKEY_RSA;
  	c->privatekey->pkey.rsa=rsa;
  	CRYPTO_add(&rsa->references,1,CRYPTO_LOCK_RSA);
+ 
  	return(1);
  	}
  
*** /var/spool/ftp/pub/Crypto/SSL/064/SSLeay-0.6.3/./ssl/ssl_sess.c	Wed Jul 24 14:27:10 1996
--- ./ssl/ssl_sess.c	Thu Aug 29 23:50:27 1996
***************
*** 60,66 ****
  	SSL_SESSION *ss;
  	int i;
  
! 	ss=(SSL_SESSION *)malloc(sizeof(SSL_SESSION));
  	if (ss == NULL)
  		{
  		SSLerr(SSL_F_SSL_SESSION_NEW,ERR_R_MALLOC_FAILURE);
--- 60,66 ----
  	SSL_SESSION *ss;
  	int i;
  
! 	ss=(SSL_SESSION *)Malloc(sizeof(SSL_SESSION));
  	if (ss == NULL)
  		{
  		SSLerr(SSL_F_SSL_SESSION_NEW,ERR_R_MALLOC_FAILURE);
***************
*** 105,111 ****
  	if (session)
  		{
  		ss->session_id_length=SSL_SESSION_ID_LENGTH;
! 		ss->session_id=(unsigned char *)malloc(SSL_SESSION_ID_LENGTH);
  		if (ss->session_id == NULL)
  			{
  			SSLerr(SSL_F_SSL_GET_NEW_SESSION,ERR_R_MALLOC_FAILURE);
--- 105,111 ----
  	if (session)
  		{
  		ss->session_id_length=SSL_SESSION_ID_LENGTH;
! 		ss->session_id=(unsigned char *)Malloc(SSL_SESSION_ID_LENGTH);
  		if (ss->session_id == NULL)
  			{
  			SSLerr(SSL_F_SSL_GET_NEW_SESSION,ERR_R_MALLOC_FAILURE);
***************
*** 113,130 ****
  			return(0);
  			}
  
- 		CRYPTO_r_lock(CRYPTO_LOCK_SSL_CTX);
  		for (;;)
  			{
  			SSL_SESSION *r;
  
  			RAND_bytes(ss->session_id,SSL_SESSION_ID_LENGTH);
  			r=(SSL_SESSION *)lh_retrieve(s->ctx->sessions,
  				(char *)ss);
  			if (r == NULL) break;
  			/* else - woops a session_id match */
  			}
- 		CRYPTO_r_unlock(CRYPTO_LOCK_SSL_CTX);
  		}
  	else
  		{
--- 113,130 ----
  			return(0);
  			}
  
  		for (;;)
  			{
  			SSL_SESSION *r;
  
  			RAND_bytes(ss->session_id,SSL_SESSION_ID_LENGTH);
+ 			CRYPTO_r_lock(CRYPTO_LOCK_SSL_CTX);
  			r=(SSL_SESSION *)lh_retrieve(s->ctx->sessions,
  				(char *)ss);
+ 			CRYPTO_r_unlock(CRYPTO_LOCK_SSL_CTX);
  			if (r == NULL) break;
  			/* else - woops a session_id match */
  			}
  		}
  	else
  		{
***************
*** 152,167 ****
  
  	if (ret == NULL)
  		{
! 		CRYPTO_add(&s->ctx->sess_miss,1,CRYPTO_LOCK_SSL_CTX);
  		ret=NULL;
  		if ((s->ctx->get_session_cb != NULL) &&
! 			((ret=s->ctx->get_session_cb(session,len)) != NULL))
  			{
! 			CRYPTO_add(&s->ctx->sess_cb_hit,1,CRYPTO_LOCK_SSL_CTX);
  
  			/* The following should not return 1, otherwise,
  			 * things are very strange */
  			SSL_add_session(s->ctx,ret);
  			}
  		if (ret == NULL) return(0);
  		}
--- 152,173 ----
  
  	if (ret == NULL)
  		{
! 		int copy=1;
! 
! 		s->ctx->sess_miss++;
  		ret=NULL;
  		if ((s->ctx->get_session_cb != NULL) &&
! 			((ret=s->ctx->get_session_cb(s,session,len,&copy))
! 				!= NULL))
  			{
! 			s->ctx->sess_cb_hit++;
  
  			/* The following should not return 1, otherwise,
  			 * things are very strange */
  			SSL_add_session(s->ctx,ret);
+ 			/* auto free it */
+ 			if (!copy)
+ 				SSL_SESSION_free(ret);
  			}
  		if (ret == NULL) return(0);
  		}
***************
*** 170,176 ****
  #endif
  
  	/* If a thread got the session, then 'swaped', and another got
! 	 * it and then due to a time-out decided to 'free' it we could
  	 * be in trouble.  So I'll increment it now, then double decrement
  	 * later - am I speaking rubbish?. */
  	CRYPTO_add(&ret->references,1,CRYPTO_LOCK_SSL_SESSION);
--- 176,182 ----
  #endif
  
  	/* If a thread got the session, then 'swaped', and another got
! 	 * it and then due to a time-out decided to 'Free' it we could
  	 * be in trouble.  So I'll increment it now, then double decrement
  	 * later - am I speaking rubbish?. */
  	CRYPTO_add(&ret->references,1,CRYPTO_LOCK_SSL_SESSION);
***************
*** 180,192 ****
  #ifdef SSL_DEBUG
  		SSL_TRACE(SSL_ERR,"TIMEOUT ON SSL_SESSION\n");
  #endif
! 		CRYPTO_add(&s->ctx->sess_timeout,1,CRYPTO_LOCK_SSL_CTX);
  		SSL_remove_session(s->ctx,ret); /* remove it from the cache */
! 		SSL_SESSION_free(ret);		/* again to actually free it */
  		return(0);
  		}
  
! 	CRYPTO_add(&s->ctx->sess_hit,1,CRYPTO_LOCK_SSL_CTX);
  
  	/* ret->time=time(NULL); */ /* rezero timeout? */
  	/* again, just leave the session 
--- 186,198 ----
  #ifdef SSL_DEBUG
  		SSL_TRACE(SSL_ERR,"TIMEOUT ON SSL_SESSION\n");
  #endif
! 		s->ctx->sess_timeout++;
  		SSL_remove_session(s->ctx,ret); /* remove it from the cache */
! 		SSL_SESSION_free(ret);		/* again to actually Free it */
  		return(0);
  		}
  
! 	s->ctx->sess_hit++;
  
  	/* ret->time=time(NULL); */ /* rezero timeout? */
  	/* again, just leave the session 
***************
*** 211,217 ****
  	s=(SSL_SESSION *)lh_insert(ctx->sessions,(char *)c);
  	CRYPTO_w_unlock(CRYPTO_LOCK_SSL_CTX);
  
! 	/* If the same session if is being 're-added', free the old
  	 * one when the last person stops using it.
  	 * This will also work if it is alread in the cache.
  	 * The references will go up and then down :-) */
--- 217,223 ----
  	s=(SSL_SESSION *)lh_insert(ctx->sessions,(char *)c);
  	CRYPTO_w_unlock(CRYPTO_LOCK_SSL_CTX);
  
! 	/* If the same session if is being 're-added', Free the old
  	 * one when the last person stops using it.
  	 * This will also work if it is alread in the cache.
  	 * The references will go up and then down :-) */
***************
*** 234,249 ****
  		{
  		CRYPTO_w_lock(CRYPTO_LOCK_SSL_CTX);
  		r=(SSL_SESSION *)lh_delete(ctx->sessions,(char *)c);
- 		CRYPTO_w_unlock(CRYPTO_LOCK_SSL_CTX);
  		if (r == NULL)
  			{
  #ifdef SSL_DEBUG
! 			SSL_TRACE(SSL_ERR,"freeing a session that is not hashed\n");
  #endif
  			return;
  			}
  		else
  			SSL_SESSION_free(r);
  		}
  	}
  
--- 240,255 ----
  		{
  		CRYPTO_w_lock(CRYPTO_LOCK_SSL_CTX);
  		r=(SSL_SESSION *)lh_delete(ctx->sessions,(char *)c);
  		if (r == NULL)
  			{
  #ifdef SSL_DEBUG
! 			SSL_TRACE(SSL_ERR,"Freeing a session that is not hashed\n");
  #endif
  			return;
  			}
  		else
  			SSL_SESSION_free(r);
+ 		CRYPTO_w_unlock(CRYPTO_LOCK_SSL_CTX);
  		}
  	}
  
***************
*** 254,278 ****
  
  	i=CRYPTO_add(&ss->references,-1,CRYPTO_LOCK_SSL_SESSION);
  	if (i > 0) return;
  
  	if (ss->key_arg != NULL)
  		{
  		memset(ss->key_arg,0,ss->key_arg_length);
! 		free(ss->key_arg);
  		}
  	if (ss->master_key != NULL)
  		{
  		memset(ss->master_key,0,ss->master_key_length);
! 		free(ss->master_key);
  		}
  	if (ss->session_id != NULL)
  		{
  		memset(ss->session_id,0,ss->session_id_length);
! 		free(ss->session_id);
  		}
  	if (ss->cert != NULL) ssl_cert_free(ss->cert);
  	if (ss->peer != NULL) X509_free(ss->peer);
! 	free(ss);
  	}
  
  int SSL_set_session(s, session)
--- 260,291 ----
  
  	i=CRYPTO_add(&ss->references,-1,CRYPTO_LOCK_SSL_SESSION);
  	if (i > 0) return;
+ #ifdef REF_CHECK
+ 	if (i < 0)
+ 		{
+ 		fprintf(stderr,"SSL_SESSION_free, bad reference count\n");
+ 		abort();
+ 		}
+ #endif
  
  	if (ss->key_arg != NULL)
  		{
  		memset(ss->key_arg,0,ss->key_arg_length);
! 		Free(ss->key_arg);
  		}
  	if (ss->master_key != NULL)
  		{
  		memset(ss->master_key,0,ss->master_key_length);
! 		Free(ss->master_key);
  		}
  	if (ss->session_id != NULL)
  		{
  		memset(ss->session_id,0,ss->session_id_length);
! 		Free(ss->session_id);
  		}
  	if (ss->cert != NULL) ssl_cert_free(ss->cert);
  	if (ss->peer != NULL) X509_free(ss->peer);
! 	Free(ss);
  	}
  
  int SSL_set_session(s, session)
***************
*** 284,292 ****
  	if (session != NULL)
  		{
  		/* CRYPTO_w_lock(CRYPTO_LOCK_SSL);*/
  		if (s->session != NULL)
  			SSL_SESSION_free(s->session);
- 		CRYPTO_add(&session->references,1,CRYPTO_LOCK_SSL_SESSION);
  		s->session=session;
  		/* CRYPTO_w_unlock(CRYPTO_LOCK_SSL);*/
  		ret=1;
--- 297,305 ----
  	if (session != NULL)
  		{
  		/* CRYPTO_w_lock(CRYPTO_LOCK_SSL);*/
+ 		CRYPTO_add(&session->references,1,CRYPTO_LOCK_SSL_SESSION);
  		if (s->session != NULL)
  			SSL_SESSION_free(s->session);
  		s->session=session;
  		/* CRYPTO_w_unlock(CRYPTO_LOCK_SSL);*/
  		ret=1;
*** /var/spool/ftp/pub/Crypto/SSL/064/SSLeay-0.6.3/./ssl/ssl_srvr.c	Fri Aug  2 14:28:33 1996
--- ./ssl/ssl_srvr.c	Thu Aug 29 23:50:28 1996
***************
*** 85,90 ****
--- 85,91 ----
  	unsigned long l=time(NULL);
  	BUF_MEM *buf=NULL;
  	int ret= -1;
+ 	long num1,num2;
  	void (*cb)()=NULL;
  
  	RAND_seed((unsigned char *)&l,sizeof(l));
***************
*** 126,134 ****
  			if (!BUF_MEM_grow(buf,(int)
  				SSL_MAX_RECORD_LENGTH_3_BYTE_HEADER))
  				{ ret= -1; goto end; }
! 			if (s->init_buf) free(s->init_buf);
  			s->init_buf=(unsigned char *)buf->data;
! 			free(buf);
  			s->init_num=0;
  			s->state=SSL_ST_GET_CLIENT_HELLO_A;
  			s->ctx->sess_accept++;
--- 127,135 ----
  			if (!BUF_MEM_grow(buf,(int)
  				SSL_MAX_RECORD_LENGTH_3_BYTE_HEADER))
  				{ ret= -1; goto end; }
! 			if (s->init_buf) Free(s->init_buf);
  			s->init_buf=(unsigned char *)buf->data;
! 			Free(buf);
  			s->init_num=0;
  			s->state=SSL_ST_GET_CLIENT_HELLO_A;
  			s->ctx->sess_accept++;
***************
*** 183,189 ****
--- 184,221 ----
  			ret=server_verify(s);
  			if (ret <= 0) goto end;
  			s->init_num=0;
+ 			if (s->hit)
+ 				{
+ 				/* If we are in here, we have been
+ 				 * buffering the output, so we need to
+ 				 * flush it and remove buffering from
+ 				 * future traffic */
+ 				s->state=SSL_ST_SEND_SERVER_VERIFY_C;
+ 				BREAK;
+ 				}
+ 			else
+ 				{
  				s->state=SSL_ST_GET_CLIENT_FINISHED_A;
+ 				break;
+ 				}
+ 
+  		case SSL_ST_SEND_SERVER_VERIFY_C:
+  			/* get the number of bytes to write */
+  			num1=BIO_ctrl(s->wbio,BIO_CTRL_INFO,0,NULL);
+  			if (num1 != 0)
+  				{
+  				num2=BIO_flush(s->wbio);
+  				if (num2 < 0) goto end;
+  				if (num1 != num2)
+  					{
+  					ret=0;
+  					goto end;
+  					}
+  				/* flushed and now remove buffering */
+  				BIO_pop(s->bbio,&s->wbio);
+  				BIO_push(s->bbio,NULL);
+  				}
+  			s->state=SSL_ST_GET_CLIENT_FINISHED_A;
    			BREAK;
  
  		case SSL_ST_GET_CLIENT_FINISHED_A:
***************
*** 227,253 ****
  			break;
  
  		case SSL_ST_OK:
! 			free(s->init_buf);
  			s->init_buf=NULL;
  			s->init_num=0;
! 			ERR_clear_error();
  
! 			/* If we want to cache the session-id, and we actual
  			 * get too, and there is a callback, then call it. */
  			if ((s->ctx->session_cache_mode & SSL_SESS_CACHE_SERVER)
  				&& SSL_add_session(s->ctx,s->session) &&
  				(s->ctx->new_session_cb != NULL))
  				{
  				CRYPTO_add(&s->session->references,1,
  					CRYPTO_LOCK_SSL_SESSION);
! 				if (!s->ctx->new_session_cb(s->session))
  					SSL_SESSION_free(s->session);
  				}
  
! 			/* flush cache every 32 entries */
                          if (!((s->ctx->session_cache_mode &
                                  SSL_SESS_CACHE_NO_AUTO_CLEAR)) &&
! 				((s->ctx->sess_accept_good & 0x1f) == 0x1f))
                                  SSL_flush_sessions(s->ctx,time(NULL));
  
  			s->ctx->sess_accept_good++;
--- 259,286 ----
  			break;
  
  		case SSL_ST_OK:
! 			Free(s->init_buf);
  			s->init_buf=NULL;
  			s->init_num=0;
! 		/*	ERR_clear_error();*/
  
! 			/* If we want to cache the session-id, and we actually
  			 * get too, and there is a callback, then call it. */
  			if ((s->ctx->session_cache_mode & SSL_SESS_CACHE_SERVER)
+ 				&& !s->hit
  				&& SSL_add_session(s->ctx,s->session) &&
  				(s->ctx->new_session_cb != NULL))
  				{
  				CRYPTO_add(&s->session->references,1,
  					CRYPTO_LOCK_SSL_SESSION);
! 				if (!s->ctx->new_session_cb(s,s->session))
  					SSL_SESSION_free(s->session);
  				}
  
! 			/* flush cache every 255 entries */
                          if (!((s->ctx->session_cache_mode &
                                  SSL_SESS_CACHE_NO_AUTO_CLEAR)) &&
! 				((s->ctx->sess_accept_good & 0xff) == 0))
                                  SSL_flush_sessions(s->ctx,time(NULL));
  
  			s->ctx->sess_accept_good++;
***************
*** 330,336 ****
  	/* do key_arg before we unpack the crypted key. */
  	if (keya > 0)
  		{
! 		s->session->key_arg=(unsigned char *)malloc((unsigned int)keya);
  		if (s->session->key_arg == NULL)
  			{
  			ssl_return_error(s);
--- 363,369 ----
  	/* do key_arg before we unpack the crypted key. */
  	if (keya > 0)
  		{
! 		s->session->key_arg=(unsigned char *)Malloc((unsigned int)keya);
  		if (s->session->key_arg == NULL)
  			{
  			ssl_return_error(s);
***************
*** 357,363 ****
  	 * non-export ciphers */
  	if (	(i < 0) ||
  		((j == 0) && (i != (int)(s->session->cipher->key_size))) ||
! 		((j != 0) && (i != j)))
  		{
  		SSL_TRACE(SSL_ERR,"RSA decrypt error - i=%d enc_bits=%d\n",i,
  			s->session->cipher->enc_bits/8);
--- 390,397 ----
  	 * non-export ciphers */
  	if (	(i < 0) ||
  		((j == 0) && (i != (int)(s->session->cipher->key_size))) ||
! 		((j != 0) && ((i != j) || (s->state_clear+i !=
! 			(unsigned int)(s->session->cipher->key_size)))))
  		{
  		SSL_TRACE(SSL_ERR,"RSA decrypt error - i=%d enc_bits=%d\n",i,
  			s->session->cipher->enc_bits/8);
***************
*** 367,373 ****
  		}
  	i+=s->state_clear;
  	s->session->master_key_length=i;
! 	s->session->master_key=(unsigned char *)malloc((unsigned int)i+1);
  	memcpy(s->session->master_key,p,(unsigned int)i);
  	return(1);
  	}
--- 401,407 ----
  		}
  	i+=s->state_clear;
  	s->session->master_key_length=i;
! 	s->session->master_key=(unsigned char *)Malloc((unsigned int)i+1);
  	memcpy(s->session->master_key,p,(unsigned int)i);
  	return(1);
  	}
***************
*** 554,560 ****
  	p+=s->state_session_id_length;
  
  	/* challenge */
! 	s->challenge=(unsigned char *)malloc((unsigned int)s->challenge_length);
  	if (s->challenge == NULL)
  		{
  		ssl_return_error(s);
--- 588,595 ----
  	p+=s->state_session_id_length;
  
  	/* challenge */
! 	if (s->challenge != NULL) Free(s->challenge);
! 	s->challenge=(unsigned char *)Malloc((unsigned int)s->challenge_length);
  	if (s->challenge == NULL)
  		{
  		ssl_return_error(s);
***************
*** 581,590 ****
  		*(p++)=(unsigned char)hit;
  		if (!hit)
  			{			/* else add cert to session */
  			if (s->session->cert != NULL)
  				ssl_cert_free(s->session->cert);
  			s->session->cert=s->cert;		
- 			CRYPTO_add(&s->cert->references,1,CRYPTO_LOCK_X509);
  			}
  		else	/* We have a session id-cache hit, if the
  			 * session-id has no certificate listed against
--- 616,625 ----
  		*(p++)=(unsigned char)hit;
  		if (!hit)
  			{			/* else add cert to session */
+ 			CRYPTO_add(&s->cert->references,1,CRYPTO_LOCK_SSL_CERT);
  			if (s->session->cert != NULL)
  				ssl_cert_free(s->session->cert);
  			s->session->cert=s->cert;		
  			}
  		else	/* We have a session id-cache hit, if the
  			 * session-id has no certificate listed against
***************
*** 593,601 ****
  			{
  			if (s->session->cert == NULL)
  				{
- 				s->session->cert=s->cert;
  				CRYPTO_add(&s->cert->references,1,
! 					CRYPTO_LOCK_X509);
  				}
  			}
  
--- 628,636 ----
  			{
  			if (s->session->cert == NULL)
  				{
  				CRYPTO_add(&s->cert->references,1,
! 					CRYPTO_LOCK_SSL_CERT);
! 				s->session->cert=s->cert;
  				}
  			}
  
***************
*** 637,644 ****
  
  		/* make and send conn_id */
  		s2n(CONECTION_ID_LENGTH,p);	/* add conn_id length */
- 		s->conn_id=(unsigned char *)malloc(CONECTION_ID_LENGTH);
  		if (s->conn_id == NULL)
  			{
  			ssl_return_error(s);
  			SSLerr(SSL_F_SERVER_HELLO,ERR_R_MALLOC_FAILURE);
--- 672,680 ----
  
  		/* make and send conn_id */
  		s2n(CONECTION_ID_LENGTH,p);	/* add conn_id length */
  		if (s->conn_id == NULL)
+ 			s->conn_id=(unsigned char *)Malloc(CONECTION_ID_LENGTH);
+ 		if (s->conn_id == NULL)
  			{
  			ssl_return_error(s);
  			SSLerr(SSL_F_SERVER_HELLO,ERR_R_MALLOC_FAILURE);
***************
*** 665,670 ****
--- 701,732 ----
  		s->init_off=0;
  		}
  	/* SSL_ST_SEND_SERVER_HELLO_B */
+  	/* If we are using TCP/IP, the performace is bad if we do 2
+  	 * writes without a read between them.  This occurs when
+  	 * Session-id reuse is used, so I will put in a buffering module
+  	 */
+  	if (s->hit)
+  		{
+  		BIO *buf;
+  
+  		if (s->bbio == NULL)
+  			{
+  			buf=BIO_new(BIO_f_buffer());
+  			if (buf == NULL)
+  				{
+  				SSLerr(SSL_F_SERVER_HELLO,ERR_LIB_BUF);
+  				return(-1);
+  				}
+  			s->bbio=buf;
+  			}
+  		else
+  			buf=s->bbio;
+  		
+  		BIO_reset(buf);
+  		BIO_push(buf,s->wbio);
+  		s->wbio=buf;
+  		}
+  
  	return(ssl_do_write(s));
  	}
  
***************
*** 770,776 ****
  
  	if (s->state_ccl == NULL)
  		{
! 		s->state_ccl=(unsigned char *)malloc(MAX_CERT_CHALLENGE_LENGTH);
  		if (s->state_ccl == NULL)
  			{
  			SSLerr(SSL_F_REQUEST_CERTIFICATE,ERR_R_MALLOC_FAILURE);
--- 832,838 ----
  
  	if (s->state_ccl == NULL)
  		{
! 		s->state_ccl=(unsigned char *)Malloc(MAX_CERT_CHALLENGE_LENGTH);
  		if (s->state_ccl == NULL)
  			{
  			SSLerr(SSL_F_REQUEST_CERTIFICATE,ERR_R_MALLOC_FAILURE);
***************
*** 867,873 ****
                  i=s->ctx->app_verify_callback(s->ctx->app_verify_arg,s,x509);
          else
                  i=X509_cert_verify(s->ctx->cert,x509,s->verify_callback,
! 			&s->verify_result);
  
  	if (i)	/* we like the packet, now check the chksum */
  		{
--- 929,935 ----
                  i=s->ctx->app_verify_callback(s->ctx->app_verify_arg,s,x509);
          else
                  i=X509_cert_verify(s->ctx->cert,x509,s->verify_callback,
! 			&s->verify_result,(char *)s);
  
  	if (i)	/* we like the packet, now check the chksum */
  		{
***************
*** 880,886 ****
  		EVP_VerifyUpdate(&ctx,ccd,MIN_CERT_CHALLENGE_LENGTH);
  
  		i=i2d_X509(s->session->cert->x509,NULL);
! 		buf2=(unsigned char *)malloc((unsigned int)i);
  		if (buf2 == NULL)
  			{
  			SSLerr(SSL_F_REQUEST_CERTIFICATE,ERR_R_MALLOC_FAILURE);
--- 942,948 ----
  		EVP_VerifyUpdate(&ctx,ccd,MIN_CERT_CHALLENGE_LENGTH);
  
  		i=i2d_X509(s->session->cert->x509,NULL);
! 		buf2=(unsigned char *)Malloc((unsigned int)i);
  		if (buf2 == NULL)
  			{
  			SSLerr(SSL_F_REQUEST_CERTIFICATE,ERR_R_MALLOC_FAILURE);
***************
*** 889,895 ****
  		p2=buf2;
  		i=i2d_X509(s->session->cert->x509,&p2);
  		EVP_VerifyUpdate(&ctx,buf2,(unsigned int)i);
! 		free(buf2);
  
  		pkey=X509_extract_key(x509);
  		if (pkey == NULL) goto end;
--- 951,957 ----
  		p2=buf2;
  		i=i2d_X509(s->session->cert->x509,&p2);
  		EVP_VerifyUpdate(&ctx,buf2,(unsigned int)i);
! 		Free(buf2);
  
  		pkey=X509_extract_key(x509);
  		if (pkey == NULL) goto end;
*** /var/spool/ftp/pub/Crypto/SSL/064/SSLeay-0.6.3/./ssl/ssl_stat.c	Wed Jul 24 14:27:10 1996
--- ./ssl/ssl_stat.c	Thu Aug 29 23:50:28 1996
***************
*** 85,90 ****
--- 85,91 ----
  case SSL_ST_GET_CLIENT_MASTER_KEY_B: str="get client master key B"; break;
  case SSL_ST_SEND_SERVER_VERIFY_A: str="send server verify A"; break;
  case SSL_ST_SEND_SERVER_VERIFY_B: str="send server verify B"; break;
+ case SSL_ST_SEND_SERVER_VERIFY_C: str="send server verify C"; break;
  case SSL_ST_GET_CLIENT_FINISHED_A: str="get client finished A"; break;
  case SSL_ST_GET_CLIENT_FINISHED_B: str="get client finished B"; break;
  case SSL_ST_SEND_SERVER_FINISHED_A: str="send server finished A"; break;
***************
*** 151,156 ****
--- 152,158 ----
  case SSL_ST_GET_CLIENT_MASTER_KEY_B:	str="GCMKA"; break;
  case SSL_ST_SEND_SERVER_VERIFY_A:	str="SSV_A"; break;
  case SSL_ST_SEND_SERVER_VERIFY_B:	str="SSV_B"; break;
+ case SSL_ST_SEND_SERVER_VERIFY_C:	str="SSV_C"; break;
  case SSL_ST_GET_CLIENT_FINISHED_A:	str="GCF_A"; break;
  case SSL_ST_GET_CLIENT_FINISHED_B:	str="GCF_B"; break;
  case SSL_ST_SEND_SERVER_FINISHED_A:	str="SSF_A"; break;
*** /dev/null	Fri Aug 30 04:16:48 1996
--- ./ssl/ssl_task.c	Thu Aug 29 23:50:28 1996
***************
*** 0 ****
--- 1,300 ----
+ /* VMS */
+ /*
+  * DECnet object for servicing SSL.  We accept the inbound and speak a
+  * simple protocol for multiplexing the 2 data streams (application and
+  * ssl data) over this logical link.
+  *
+  * Logical names:
+  *    SSL_CIPHER	Defines a list of cipher specifications the server
+  *			will support in order of preference.
+  *    SSL_SERVER_CERTIFICATE
+  *			Points to PEM (privacy enhanced mail) file that
+  *			contains the server certificate and private password.
+  *    SYS$NET		Logical created by netserver.exe as hook for completing
+  *			DECnet logical link.
+  *
+  * Each NSP message sent over the DECnet link has the following structure:
+  *    struct rpc_msg { 
+  *      char channel;
+  *      char function;
+  *      short length;
+  *      char data[MAX_DATA];
+  *    } msg;
+  *
+  * The channel field designates the virtual data stream this message applies
+  * to and is one of:
+  *   A - Application data (payload).
+  *   R - Remote client connection that initiated the SSL connection.  Encrypted
+  *       data is sent over this connection.
+  *   G - General data, reserved for future use.
+  *
+  * The data streams are half-duplex read/write and have following functions:
+  *   G - Get, requests that up to msg.length bytes of data be returned.  The
+  *       data is returned in the next 'C' function response that matches the
+  *       requesting channel.
+  *   P - Put, requests that the first msg.length bytes of msg.data be appended
+  *       to the designated stream.
+  *   C - Confirms a get or put.  Every get and put will get a confirm response,
+  *       you cannot initiate another function on a channel until the previous
+  *       operation has been confirmed.
+  *
+  *  The 2 channels may interleave their operations, for example:
+  *        Server msg           Client msg
+  *         A, Get, 4092          ---->
+  *                               <----  R, get, 4092
+  *         R, Confirm, {hello}   ---->
+  *                               <----  R, put, {srv hello}
+  *         R, Confirm, 0         ---->
+  *                               .		(SSL handshake completed)
+  *                               .              (read first app data).
+  *                               <----  A, confirm, {http data}
+  *         A, Put, {http data}   ---->
+  *                               <----  A, confirm, 0
+  *
+  *  The length field is not permitted to be larger that 4092 bytes.
+  *
+  * Author: Dave Jones
+  * Date:   22-JUL-1996
+  */
+ #include <stdlib.h>
+ #include <stdio.h>
+ #include <iodef.h>		/* VMS IO$_ definitions */
+ #include <descrip.h>		/* VMS string descriptors */
+ extern int SYS$QIOW(), SYS$ASSIGN();
+ int LIB$INIT_TIMER(), LIB$SHOW_TIMER();
+ 
+ #include <string.h>		/* from ssltest.c */
+ #include <errno.h>
+ #include "buffer.h"
+ #include "../e_os.h"
+ #include "x509.h"
+ #include "ssl.h"
+ #include "err.h"
+ 
+ int MS_CALLBACK verify_callback(int ok, X509 *xs, X509 *xi, int depth,
+ 	int error);
+ BIO *bio_err=NULL;
+ BIO *bio_stdout=NULL;
+ BIO_METHOD *BIO_s_rtcp();
+ 
+ static char *cipher=NULL;
+ int verbose=1;
+ #ifdef FIONBIO
+ static int s_nbio=0;
+ #endif
+ #define TEST_SERVER_CERT "SSL_SERVER_CERTIFICATE"
+ /*************************************************************************/
+ struct rpc_msg {		/* Should have member alignment inhibited */
+    char channel;		/* 'A'-app data. 'R'-remote client 'G'-global */
+    char function;		/* 'G'-get, 'P'-put, 'C'-confirm, 'X'-close */
+    unsigned short int length;	/* Amount of data returned or max to return */
+    char data[4092];		/* variable data */
+ };
+ #define RPC_HDR_SIZE (sizeof(struct rpc_msg) - 4092)
+ 
+ static $DESCRIPTOR(sysnet, "SYS$NET");
+ typedef unsigned short io_channel;
+ 
+ struct io_status {
+     unsigned short status;
+     unsigned short count;
+     unsigned long stsval;
+ };
+ int doit(io_channel chan, SSL_CTX *s_ctx );
+ /*****************************************************************************/
+ /* Decnet I/O routines.
+  */
+ static int get ( io_channel chan, char *buffer, int maxlen, int *length )
+ {
+     int status;
+     struct io_status iosb;
+     status = SYS$QIOW ( 0, chan, IO$_READVBLK, &iosb, 0, 0,
+ 	buffer, maxlen, 0, 0, 0, 0 );
+     if ( (status&1) == 1 ) status = iosb.status;
+     if ( (status&1) == 1 ) *length = iosb.count;
+     return status;
+ }
+ 
+ static int put ( io_channel chan, char *buffer, int length )
+ {
+     int status;
+     struct io_status iosb;
+     status = SYS$QIOW ( 0, chan, IO$_WRITEVBLK, &iosb, 0, 0,
+ 	buffer, length, 0, 0, 0, 0 );
+     if ( (status&1) == 1 ) status = iosb.status;
+     return status;
+ }
+ /***************************************************************************/
+ /* Handle operations on the 'G' channel.
+  */
+ static int general_request ( io_channel chan, struct rpc_msg *msg, int length )
+ {
+     return 48;
+ }
+ /***************************************************************************/
+ int main ( int argc, char **argv )
+ {
+     int status, length;
+     io_channel chan;
+     struct rpc_msg msg;
+ 
+ 	char *CApath=NULL,*CAfile=NULL;
+ 	int badop=0;
+ 	int ret=1;
+ 	int client_auth=0;
+ 	int server_auth=0;
+ 	SSL_CTX *s_ctx=NULL;
+     /*
+      * Confirm logical link with initiating client.
+      */
+     LIB$INIT_TIMER();
+     status = SYS$ASSIGN ( &sysnet, &chan, 0, 0, 0 );
+     printf("status of assign to SYS$NET: %d\n", status );
+     /*
+      * Initialize standard out and error files.
+      */
+ 	if (bio_err == NULL)
+ 		if ((bio_err=BIO_new(BIO_s_file())) != NULL)
+ 			BIO_set_fp(bio_err,stderr,BIO_NOCLOSE);
+ 	if (bio_stdout == NULL)
+ 		if ((bio_stdout=BIO_new(BIO_s_file())) != NULL)
+ 			BIO_set_fp(bio_stdout,stdout,BIO_NOCLOSE);
+     /*
+      * get the preferred cipher list and other initialization
+      */
+ 	if (cipher == NULL) cipher=getenv("SSL_CIPHER");
+ 	printf("cipher list: %s\n", cipher ? cipher : "{undefined}" );
+ 
+ 	SSL_load_error_strings();
+ 
+ 	s_ctx=SSL_CTX_new();
+ 	if (s_ctx == NULL) goto end;
+ 
+ 	SSL_CTX_use_certificate_file(s_ctx,TEST_SERVER_CERT,SSL_FILETYPE_PEM);
+ 	SSL_CTX_use_RSAPrivateKey_file(s_ctx,TEST_SERVER_CERT,SSL_FILETYPE_PEM);
+ 	printf("Loaded server certificate: '%s'\n", TEST_SERVER_CERT );
+ 
+     /*
+      * Take commands from client until bad status.
+      */
+     LIB$SHOW_TIMER();
+     status = doit ( chan, s_ctx );
+     LIB$SHOW_TIMER();
+     /*
+      * do final cleanup and exit.
+      */
+ end:
+ 	if (s_ctx != NULL) SSL_CTX_free(s_ctx);
+     LIB$SHOW_TIMER();
+     return 1;
+ }
+ 
+ int doit(io_channel chan, SSL_CTX *s_ctx )
+ {
+     int status, length, link_state;
+      struct rpc_msg msg;
+ 	static char cbuf[200],sbuf[200];
+ 	SSL *s_ssl=NULL;
+ 	BIO *c_to_s=NULL;
+ 	BIO *s_to_c=NULL;
+ 	BIO *c_bio=NULL;
+ 	BIO *s_bio=NULL;
+ 	int i;
+ 	int done=0;
+ 
+ 	s_ssl=SSL_new(s_ctx);
+ 	if (s_ssl == NULL) goto err;
+ 
+ 	c_to_s=BIO_new(BIO_s_rtcp());
+ 	s_to_c=BIO_new(BIO_s_rtcp());
+ 	if ((s_to_c == NULL) || (c_to_s == NULL)) goto err;
+ 	BIO_set_fd ( c_to_s, "", chan );
+ 	BIO_set_fd ( s_to_c, "", chan );
+ 
+ 	c_bio=BIO_new(BIO_f_ssl());
+ 	s_bio=BIO_new(BIO_f_ssl());
+ 	if ((c_bio == NULL) || (s_bio == NULL)) goto err;
+ 
+ 	SSL_set_accept_state(s_ssl);
+ 	SSL_set_bio(s_ssl,c_to_s,s_to_c);
+ 	BIO_set_ssl(s_bio,s_ssl,BIO_CLOSE);
+ 
+ 	/* We can always do writes */
+ 	printf("Begin doit main loop\n");
+ 	/*
+ 	 * Link states: 0-idle, 1-read pending, 2-write pending, 3-closed.
+ 	 */
+ 	for (link_state = 0; link_state < 3; ) {
+ 	    /*
+ 	     * Wait for remote end to request data action on A channel.
+ 	     */
+ 	    while ( link_state == 0 ) {
+ 		status = get ( chan, (char *) &msg, sizeof(msg), &length );
+ 		if ( (status&1) == 0 ) {
+ 		    printf("Error in main loop get: %d\n", status );
+ 		    link_state = 3;
+ 		    break;
+ 		}
+ 	   	if ( length < RPC_HDR_SIZE ) {
+ 		    printf("Error in main loop get size: %d\n", length );
+ 		    break;
+ 		    link_state = 3;
+ 		}
+ 	   	if ( msg.channel != 'A' ) {
+ 		    printf("Error in main loop, unexpected channel: %c\n", 
+ 			msg.channel );
+ 		    break;
+ 		    link_state = 3;
+ 		}
+ 		if ( msg.function == 'G' ) {
+ 		    link_state = 1;
+ 		} else if ( msg.function == 'P' ) {
+ 		    link_state = 2;	/* write pending */
+ 		} else if ( msg.function == 'X' ) {
+ 		    link_state = 3;
+ 		} else {
+ 		    link_state = 3;
+ 		}
+ 	    }
+ 	    if ( link_state == 1 ) {
+ 		i = BIO_read ( s_bio, msg.data, msg.length );
+ 		if ( i < 0 ) link_state = 3;
+ 		else {
+ 		    msg.channel = 'A';
+ 		    msg.function = 'C';		/* confirm */
+ 		    msg.length = i;
+ 		    status = put ( chan, (char *) &msg, i+RPC_HDR_SIZE );
+ 		    if ( (status&1) == 0 ) break;
+ 		    link_state = 0;
+ 		}
+ 	    } else if ( link_state == 2 ) {
+ 		i = BIO_write ( s_bio, msg.data, msg.length );
+ 		if ( i < 0 ) link_state = 3;
+ 		else {
+ 		    msg.channel = 'A';
+ 		    msg.function = 'C';		/* confirm */
+ 		    msg.length = 0;
+ 		    status = put ( chan, (char *) &msg, RPC_HDR_SIZE );
+ 		    if ( (status&1) == 0 ) break;
+ 		    link_state = 0;
+ 		}
+ 	    }
+ 	}
+ 	fprintf(stdout,"DONE\n");
+ err:
+ 	/* We have to set the BIO's to NULL otherwise they will be
+ 	 * free()ed twice.  Once when th s_ssl is SSL_free()ed and
+ 	 * again when c_ssl is SSL_free()ed.
+ 	 * This is a hack required because s_ssl and c_ssl are sharing the same
+ 	 * BIO structure and SSL_set_bio() and SSL_free() automatically
+ 	 * BIO_free non NULL entries.
+ 	 * You should not normally do this or be required to do this */
+ 	s_ssl->rbio=NULL;
+ 	s_ssl->wbio=NULL;
+ 
+ 	if (c_to_s != NULL) BIO_free(c_to_s);
+ 	if (s_to_c != NULL) BIO_free(s_to_c);
+ 	if (c_bio != NULL) BIO_free(c_bio);
+ 	if (s_bio != NULL) BIO_free(s_bio);
+ 	return(0);
+ }
*** /var/spool/ftp/pub/Crypto/SSL/064/SSLeay-0.6.3/./ssl/ssl_trc.c	Wed Jul 24 14:27:10 1996
--- ./ssl/ssl_trc.c	Fri Aug 30 03:24:34 1996
***************
*** 70,76 ****
  {
      VAR_BDEFN(args, FILE *, fp);
      char *format;
! #if defined(THREADS) && defined(sun)
      struct tm data;
  #endif
      struct  tm	    *tm_time;
--- 70,76 ----
  {
      VAR_BDEFN(args, FILE *, fp);
      char *format;
! #if defined(THREADS)
      struct tm data;
  #endif
      struct  tm	    *tm_time;
***************
*** 84,90 ****
  	return;
  
      time_now = time ( (time_t *)0 );
! #if defined(THREADS) && defined(sun)
      tm_time = localtime_r(&time_now,&data);
  #else
      tm_time = localtime(&time_now);
--- 84,90 ----
  	return;
  
      time_now = time ( (time_t *)0 );
! #if defined(THREADS)
      tm_time = localtime_r(&time_now,&data);
  #else
      tm_time = localtime(&time_now);
*** /var/spool/ftp/pub/Crypto/SSL/064/SSLeay-0.6.3/./rsaref/Makefile.ssl	Thu Aug  8 01:54:30 1996
--- ./rsaref/Makefile.ssl	Fri Aug 30 04:41:01 1996
***************
*** 75,81 ****
  	mv -f Makefile.new $(MAKEFILE)
  
  clean:
! 	/bin/rm -f *.o *.obj lib tags core .nfs* *.old *.bak fluff
  
  errors:
  	perl $(TOP)/util/err-ins.pl $(ERR).err $(ERR).h
--- 75,81 ----
  	mv -f Makefile.new $(MAKEFILE)
  
  clean:
! 	/bin/rm -f *.o *.obj lib tags core .pure .nfs* *.old *.bak fluff
  
  errors:
  	perl $(TOP)/util/err-ins.pl $(ERR).err $(ERR).h
*** /var/spool/ftp/pub/Crypto/SSL/064/SSLeay-0.6.3/./apps/apps.c	Wed Jul 24 08:14:27 1996
--- ./apps/apps.c	Thu Aug 29 23:50:26 1996
***************
*** 83,90 ****
  	*argv=NULL;
  
  	len=(unsigned int)stbuf.st_size;
! 	if (buf != NULL) free(buf);
! 	buf=(char *)malloc(len+1);
  	if (buf == NULL) return(0);
  
  	len=fread(buf,1,len,fp);
--- 83,90 ----
  	*argv=NULL;
  
  	len=(unsigned int)stbuf.st_size;
! 	if (buf != NULL) Free(buf);
! 	buf=(char *)Malloc(len+1);
  	if (buf == NULL) return(0);
  
  	len=fread(buf,1,len,fp);
***************
*** 94,101 ****
  	i=0;
  	for (p=buf; *p; p++)
  		if (*p == '\n') i++;
! 	if (arg != NULL) free(arg);
! 	arg=(char **)malloc(sizeof(char *)*(i*2));
  
  	*argv=arg;
  	num=0;
--- 94,101 ----
  	i=0;
  	for (p=buf; *p; p++)
  		if (*p == '\n') i++;
! 	if (arg != NULL) Free(arg);
! 	arg=(char **)Malloc(sizeof(char *)*(i*2));
  
  	*argv=arg;
  	num=0;
*** /var/spool/ftp/pub/Crypto/SSL/064/SSLeay-0.6.3/./apps/apps.h	Wed Jul 24 20:12:50 1996
--- ./apps/apps.h	Thu Aug 29 23:50:26 1996
***************
*** 51,56 ****
--- 51,57 ----
  #include "../e_os.h"
  
  #include "buffer.h"
+ #include "crypto.h"
  
  #ifdef WIN16
  BIO_METHOD *BIO_s_file();
*** /var/spool/ftp/pub/Crypto/SSL/064/SSLeay-0.6.3/./apps/asn1pars.c	Wed Jul 24 08:14:27 1996
--- ./apps/asn1pars.c	Thu Aug 29 23:50:26 1996
***************
*** 227,234 ****
  			i=0;
  		else
  			i=1;
! 		if (name != NULL) free(name);
! 		if (header != NULL) free(header);
  		if (!i)
  			{
  			ERR_print_errors(bio_err);
--- 227,234 ----
  			i=0;
  		else
  			i=1;
! 		if (name != NULL) Free(name);
! 		if (header != NULL) Free(header);
  		if (!i)
  			{
  			ERR_print_errors(bio_err);
***************
*** 250,256 ****
  	if (ret != 0)
  		ERR_print_errors(bio_err);
  	if (buf != NULL) BUF_MEM_free(buf);
! 	if (str != NULL) free(str);
  	EXIT(ret);
  	}
  
--- 250,256 ----
  	if (ret != 0)
  		ERR_print_errors(bio_err);
  	if (buf != NULL) BUF_MEM_free(buf);
! 	if (str != NULL) Free(str);
  	EXIT(ret);
  	}
  
*** /var/spool/ftp/pub/Crypto/SSL/064/SSLeay-0.6.3/./apps/ca.c	Thu Aug  1 13:48:45 1996
--- ./apps/ca.c	Fri Aug 30 03:54:05 1996
***************
*** 89,94 ****
--- 89,95 ----
  #define ENV_DEFAULT_CRL_DAYS 	"default_crl_days"
  #define ENV_DEFAULT_CRL_HOURS 	"default_crl_hours"
  #define ENV_DEFAULT_MD		"default_md"
+ #define ENV_PRESERVE		"preserve"
  #define ENV_POLICY      	"policy"
  
  #define ENV_DATABASE		"database"
***************
*** 125,130 ****
--- 126,132 ----
  " -outdir dir     - Where to put output certificates\n",
  " -infiles ....   - The last argument, requests to process\n",
  " -spkac file     - File contains DN and signed public key and challenge\n",
+ " -preserveDN     - Don't re-order the DN\n",
  NULL
  };
  
***************
*** 170,175 ****
--- 172,179 ----
  static char *key=NULL;
  static char *section=NULL;
  
+ static int preserve=0;
+ 
  int MAIN(argc, argv)
  int argc;
  char **argv;
***************
*** 207,224 ****
  	X509_CRL *crl=NULL;
  	X509_CRL_INFO *ci=NULL;
  	X509_REVOKED *r=NULL;
! 	char **pp,*p,*f;
! 	int i,j,k,n,m;
  	long l;
  	EVP_MD *dgst=NULL;
  	STACK *attribs=NULL;
  	STACK *cert_sk=NULL;
  #undef BSIZE
  #define BSIZE 256
! 	char buf[3][BSIZE];
  
  	apps_startup();
  
  	if (bio_err == NULL)
  		if ((bio_err=BIO_new(BIO_s_file())) != NULL)
  			BIO_set_fp(bio_err,stderr,BIO_NOCLOSE);
--- 211,230 ----
  	X509_CRL *crl=NULL;
  	X509_CRL_INFO *ci=NULL;
  	X509_REVOKED *r=NULL;
! 	char **pp,*f;
! 	int i,j;
  	long l;
  	EVP_MD *dgst=NULL;
  	STACK *attribs=NULL;
  	STACK *cert_sk=NULL;
+ 	BIO *hex=NULL;
  #undef BSIZE
  #define BSIZE 256
! 	MS_STATIC char buf[3][BSIZE];
  
  	apps_startup();
  
+ 	preserve=0;
  	if (bio_err == NULL)
  		if ((bio_err=BIO_new(BIO_s_file())) != NULL)
  			BIO_set_fp(bio_err,stderr,BIO_NOCLOSE);
***************
*** 287,292 ****
--- 293,300 ----
  			}
  		else if (strcmp(*argv,"-batch") == 0)
  			batch=1;
+ 		else if (strcmp(*argv,"-preserveDN") == 0)
+ 			preserve=1;
  		else if (strcmp(*argv,"-gencrl") == 0)
  			gencrl=1;
  		else if (strcmp(*argv,"-crldays") == 0)
***************
*** 424,429 ****
--- 432,441 ----
  		goto err;
  		}
  
+ 	f=CONF_get_string(conf,BASE_SECTION,ENV_PRESERVE);
+ 	if ((f != NULL) && ((*f == 'y') || (*f == 'Y')))
+ 		preserve=1;
+ 
  	/*****************************************************************/
  	/* lookup where to write new certificates */
  	if ((outdir == NULL) && (req))
***************
*** 541,546 ****
--- 553,573 ----
  		}
  
  	/*****************************************************************/
+ 	if (req || gencrl)
+ 		{
+ 		if (outfile != NULL)
+ 			{
+ 
+ 			if (BIO_write_filename(Sout,outfile) <= 0)
+ 				{
+ 				perror(outfile);
+ 				goto err;
+ 				}
+ 			}
+ 		else
+ 			BIO_set_fp(Sout,stdout,BIO_NOCLOSE);
+ 		}
+ 
  	if (req)
  		{
  		if ((md == NULL) && ((md=CONF_get_string(conf,
***************
*** 593,599 ****
  			{
  			if ((f=BN_bn2ascii(serial)) == NULL) goto err;
  			fprintf(stderr,"next serial number is %s\n",f);
! 			free(f);
  			}
  
  		if ((attribs=CONF_get_section(conf,policy)) == NULL)
--- 620,626 ----
  			{
  			if ((f=BN_bn2ascii(serial)) == NULL) goto err;
  			fprintf(stderr,"next serial number is %s\n",f);
! 			Free(f);
  			}
  
  		if ((attribs=CONF_get_section(conf,policy)) == NULL)
***************
*** 602,622 ****
  			goto err;
  			}
  
- 		if (outfile != NULL)
- 			{
- 
- 			if (BIO_write_filename(Sout,outfile) <= 0)
- 				{
- 				perror(outfile);
- 				goto err;
- 				}
- 			}
- 		else
- 			BIO_set_fp(Sout,stdout,BIO_NOCLOSE);
- 
  		if ((cert_sk=sk_new_null()) == NULL)
  			{
! 			fprintf(stderr,"malloc failure\n");
  			goto err;
  			}
  		if (spkac_file != NULL)
--- 629,637 ----
  			goto err;
  			}
  
  		if ((cert_sk=sk_new_null()) == NULL)
  			{
! 			fprintf(stderr,"Malloc failure\n");
  			goto err;
  			}
  		if (spkac_file != NULL)
***************
*** 632,638 ****
  				if (!BN_add_word(serial,1)) goto err;
  				if (!sk_push(cert_sk,(char *)x))
  					{
! 					fprintf(stderr,"malloc failure\n");
  					goto err;
  					}
  				if (outfile)
--- 647,653 ----
  				if (!BN_add_word(serial,1)) goto err;
  				if (!sk_push(cert_sk,(char *)x))
  					{
! 					fprintf(stderr,"Malloc failure\n");
  					goto err;
  					}
  				if (outfile)
***************
*** 655,661 ****
  				if (!BN_add_word(serial,1)) goto err;
  				if (!sk_push(cert_sk,(char *)x))
  					{
! 					fprintf(stderr,"malloc failure\n");
  					goto err;
  					}
  				}
--- 670,676 ----
  				if (!BN_add_word(serial,1)) goto err;
  				if (!sk_push(cert_sk,(char *)x))
  					{
! 					fprintf(stderr,"Malloc failure\n");
  					goto err;
  					}
  				}
***************
*** 673,679 ****
  				if (!BN_add_word(serial,1)) goto err;
  				if (!sk_push(cert_sk,(char *)x))
  					{
! 					fprintf(stderr,"malloc failure\n");
  					goto err;
  					}
  				}
--- 688,694 ----
  				if (!BN_add_word(serial,1)) goto err;
  				if (!sk_push(cert_sk,(char *)x))
  					{
! 					fprintf(stderr,"Malloc failure\n");
  					goto err;
  					}
  				}
***************
*** 810,815 ****
--- 825,832 ----
  		{
  		EVP_PKEY pkey;
  
+ 		if ((hex=BIO_new(BIO_s_mem())) == NULL) goto err;
+ 
  		if (!crldays && !crlhours)
  			{
  			crldays=CONF_get_number(conf,section,
***************
*** 840,872 ****
  				{
  				if ((r=X509_REVOKED_new()) == NULL) goto err;
  				strcpy(r->revocationDate,pp[DB_rev_date]);
! 				j=(int)strlen(pp[DB_serial])/2;
! 				if ((p=(char *)malloc(j+1)) == NULL)
! 					{
! 					fprintf(stderr,"malloc failure\n");
  					goto err;
! 					}
! 				r->serialNumber->length=j;
! 				r->serialNumber->data=(unsigned char *)p;
! 				f=pp[DB_serial];
! 				for (; j; j--)
! 					{
! 					m=0;
! 					for (k=0; k<2; k++)
! 						{
! 						n= *(f++);
! 						if ((n >= '0') && (n <= '9'))
! 							n-='0';
! 						else if ((n >= 'a')
! 							&& (n <= 'z'))
! 							n=n-'a'+10;
! 						else if ((n >= 'A')
! 							&& (n <= 'Z'))
! 							n=n-'A'+10;
! 						m=(m<<4)|n;
! 						}
! 					*(p++)=m;
! 					}
  				sk_push(ci->revoked,(char *)r);
  				}
  			}
--- 857,869 ----
  				{
  				if ((r=X509_REVOKED_new()) == NULL) goto err;
  				strcpy(r->revocationDate,pp[DB_rev_date]);
! 
! 				BIO_reset(hex);
! 				if (!BIO_puts(hex,pp[DB_serial]))
  					goto err;
! 				if (!a2i_ASN1_INTEGER(hex,r->serialNumber,
! 					buf[0],BSIZE)) goto err;
! 
  				sk_push(ci->revoked,(char *)r);
  				}
  			}
***************
*** 900,905 ****
--- 897,903 ----
  	/*****************************************************************/
  	ret=0;
  err:
+ 	if (hex != NULL) BIO_free(hex);
  	if (Cout != NULL) BIO_free(Cout);
  	if (Sout != NULL) BIO_free(Sout);
  	if (out != NULL) BIO_free(out);
***************
*** 1205,1211 ****
  	/* Ok, now we check the 'policy' stuff. */
  	if ((subject=sk_new_null()) == NULL)
  		{
! 		fprintf(stderr,"malloc failure\n");
  		goto err;
  		}
  
--- 1203,1209 ----
  	/* Ok, now we check the 'policy' stuff. */
  	if ((subject=sk_new_null()) == NULL)
  		{
! 		fprintf(stderr,"Malloc failure\n");
  		goto err;
  		}
  
***************
*** 1282,1288 ****
  				{
  				if (push != NULL)
  					X509_NAME_ENTRY_free(push);
! 				fprintf(stderr,"malloc failure\n");
  				goto err;
  				}
  			}
--- 1280,1286 ----
  				{
  				if (push != NULL)
  					X509_NAME_ENTRY_free(push);
! 				fprintf(stderr,"Malloc failure\n");
  				goto err;
  				}
  			}
***************
*** 1296,1301 ****
--- 1294,1305 ----
  		ne->set=i;
  		}
  
+ 	if (preserve)
+ 		{
+ 		X509_NAME_free(subject);
+ 		subject=X509_NAME_dup(req->req_info->subject);
+ 		}
+ 
  	if (verbose)
  		fprintf(stderr,"The subject name apears to be ok, checking data base for clashes\n");
  
***************
*** 1303,1309 ****
  	row[DB_serial]=BN_bn2ascii(serial);
  	if ((row[DB_name] == NULL) || (row[DB_serial] == NULL))
  		{
! 		fprintf(stderr,"malloc failure\n");
  		goto err;
  		}
  
--- 1307,1313 ----
  	row[DB_serial]=BN_bn2ascii(serial);
  	if ((row[DB_name] == NULL) || (row[DB_serial] == NULL))
  		{
! 		fprintf(stderr,"Malloc failure\n");
  		goto err;
  		}
  
***************
*** 1410,1426 ****
  		goto err;
  
  	/* We now just add it to the database */
! 	row[DB_type]=(char *)malloc(2);
  	row[DB_exp_date]=(char *)ASN1_UTCTIME_dup(ci->validity->notAfter);
  	row[DB_rev_date]=NULL;
  	/* row[DB_serial] done already */
! 	row[DB_file]=(char *)malloc(8);
  	/* row[DB_name] done already */
  
  	if ((row[DB_type] == NULL) || (row[DB_exp_date] == NULL) ||
  		(row[DB_file] == NULL))
  		{
! 		fprintf(stderr,"malloc failure\n");
  		goto err;
  		}
  	strcpy(row[DB_file],"unknown");
--- 1414,1430 ----
  		goto err;
  
  	/* We now just add it to the database */
! 	row[DB_type]=(char *)Malloc(2);
  	row[DB_exp_date]=(char *)ASN1_UTCTIME_dup(ci->validity->notAfter);
  	row[DB_rev_date]=NULL;
  	/* row[DB_serial] done already */
! 	row[DB_file]=(char *)Malloc(8);
  	/* row[DB_name] done already */
  
  	if ((row[DB_type] == NULL) || (row[DB_exp_date] == NULL) ||
  		(row[DB_file] == NULL))
  		{
! 		fprintf(stderr,"Malloc failure\n");
  		goto err;
  		}
  	strcpy(row[DB_file],"unknown");
***************
*** 1427,1435 ****
  	row[DB_type][0]='V';
  	row[DB_type][1]='\0';
  
! 	if ((irow=(char **)malloc(sizeof(char *)*(DB_NUMBER+1))) == NULL)
  		{
! 		fprintf(stderr,"malloc failure\n");
  		goto err;
  		}
  
--- 1431,1439 ----
  	row[DB_type][0]='V';
  	row[DB_type][1]='\0';
  
! 	if ((irow=(char **)Malloc(sizeof(char *)*(DB_NUMBER+1))) == NULL)
  		{
! 		fprintf(stderr,"Malloc failure\n");
  		goto err;
  		}
  
***************
*** 1449,1455 ****
  	ok=1;
  err:
  	for (i=0; i<DB_NUMBER; i++)
! 		if (row[i] != NULL) free(row[i]);
  
  	if (CAname != NULL)
  		X509_NAME_free(CAname);
--- 1453,1459 ----
  	ok=1;
  err:
  	for (i=0; i<DB_NUMBER; i++)
! 		if (row[i] != NULL) Free(row[i]);
  
  	if (CAname != NULL)
  		X509_NAME_free(CAname);
***************
*** 1494,1504 ****
  	f=X509_NAME_oneline(X509_get_issuer_name(x));
  	BIO_puts(bp,"issuer :");
  	BIO_puts(bp,f);
! 	BIO_puts(bp,"\n"); free(f);
  	f=X509_NAME_oneline(X509_get_subject_name(x));
  	BIO_puts(bp,"subject:");
  	BIO_puts(bp,f);
! 	BIO_puts(bp,"\n"); free(f);
  	BIO_puts(bp,"serial :");
  	i2a_ASN1_INTEGER(bp,x->cert_info->serialNumber);
  	BIO_puts(bp,"\n\n");
--- 1498,1508 ----
  	f=X509_NAME_oneline(X509_get_issuer_name(x));
  	BIO_puts(bp,"issuer :");
  	BIO_puts(bp,f);
! 	BIO_puts(bp,"\n"); Free(f);
  	f=X509_NAME_oneline(X509_get_subject_name(x));
  	BIO_puts(bp,"subject:");
  	BIO_puts(bp,f);
! 	BIO_puts(bp,"\n"); Free(f);
  	BIO_puts(bp,"serial :");
  	i2a_ASN1_INTEGER(bp,x->cert_info->serialNumber);
  	BIO_puts(bp,"\n\n");
***************
*** 1588,1597 ****
  			{
  			if (strcmp(type, "SPKAC") == 0)
  				{
! 				spki_der = malloc(strlen(cv->value) + 1);
  				if (spki_der == NULL)
  					{
! 					fprintf(stderr,"malloc failure\n");
  					goto err;
  					}
  				j = EVP_DecodeBlock(spki_der, (unsigned char *)cv->value,
--- 1592,1602 ----
  			{
  			if (strcmp(type, "SPKAC") == 0)
  				{
! 				spki_der=(unsigned char *)Malloc(
! 					strlen(cv->value)+1);
  				if (spki_der == NULL)
  					{
! 					fprintf(stderr,"Malloc failure\n");
  					goto err;
  					}
  				j = EVP_DecodeBlock(spki_der, (unsigned char *)cv->value,
***************
*** 1604,1610 ****
  
  				p=spki_der;
  				spki = d2i_NETSCAPE_SPKI(&spki, &p, j);
! 				free(spki_der);
  				spki_der = NULL;
  				if (spki == NULL)
  					{
--- 1609,1615 ----
  
  				p=spki_der;
  				spki = d2i_NETSCAPE_SPKI(&spki, &p, j);
! 				Free(spki_der);
  				spki_der = NULL;
  				if (spki == NULL)
  					{
***************
*** 1636,1644 ****
  
  		j = strlen(cv->value);
  		ne->value->length=j;
! 		ne->value->data=(unsigned char *)malloc(j+1);
  		if (ne->value->data == NULL)
! 			{ fprintf(stderr,"malloc failure\n"); goto err; }
  		memcpy(ne->value->data,cv->value,j+1);
  		if (!sk_push(n,(char *)ne)) goto err;
  		ne=NULL;
--- 1641,1649 ----
  
  		j = strlen(cv->value);
  		ne->value->length=j;
! 		ne->value->data=(unsigned char *)Malloc(j+1);
  		if (ne->value->data == NULL)
! 			{ fprintf(stderr,"Malloc failure\n"); goto err; }
  		memcpy(ne->value->data,cv->value,j+1);
  		if (!sk_push(n,(char *)ne)) goto err;
  		ne=NULL;
***************
*** 1683,1689 ****
  err:
  	if (req != NULL) X509_REQ_free(req);
  	if (parms != NULL) CONF_free(parms);
! 	if (spki_der != NULL) free(spki_der);
  	if (spki != NULL) NETSCAPE_SPKI_free(spki);
  	if (ne != NULL) X509_NAME_ENTRY_free(ne);
  
--- 1688,1694 ----
  err:
  	if (req != NULL) X509_REQ_free(req);
  	if (parms != NULL) CONF_free(parms);
! 	if (spki_der != NULL) Free(spki_der);
  	if (spki != NULL) NETSCAPE_SPKI_free(spki);
  	if (ne != NULL) X509_NAME_ENTRY_free(ne);
  
*** /dev/null	Fri Aug 30 04:16:48 1996
--- ./apps/ciphers.c	Thu Aug 29 23:50:26 1996
***************
*** 0 ****
--- 1,144 ----
+ /* apps/ciphers.c */
+ /* Copyright (C) 1995-1996 Eric Young (eay@mincom.oz.au)
+  * All rights reserved.
+  * 
+  * This file is part of an SSL implementation written
+  * by Eric Young (eay@mincom.oz.au).
+  * The implementation was written so as to conform with Netscapes SSL
+  * specification.  This library and applications are
+  * FREE FOR COMMERCIAL AND NON-COMMERCIAL USE
+  * as long as the following conditions are aheared to.
+  * 
+  * Copyright remains Eric Young's, and as such any Copyright notices in
+  * the code are not to be removed.  If this code is used in a product,
+  * Eric Young should be given attribution as the author of the parts used.
+  * This can be in the form of a textual message at program startup or
+  * in documentation (online or textual) provided with the package.
+  * 
+  * Redistribution and use in source and binary forms, with or without
+  * modification, are permitted provided that the following conditions
+  * are met:
+  * 1. Redistributions of source code must retain the copyright
+  *    notice, this list of conditions and the following disclaimer.
+  * 2. Redistributions in binary form must reproduce the above copyright
+  *    notice, this list of conditions and the following disclaimer in the
+  *    documentation and/or other materials provided with the distribution.
+  * 3. All advertising materials mentioning features or use of this software
+  *    must display the following acknowledgement:
+  *    This product includes software developed by Eric Young (eay@mincom.oz.au)
+  * 
+  * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND
+  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+  * SUCH DAMAGE.
+  * 
+  * The licence and distribution terms for any publically available version or
+  * derivative of this code cannot be changed.  i.e. this code cannot simply be
+  * copied and put under another distribution licence
+  * [including the GNU Public Licence.]
+  */
+ 
+ #include <stdio.h>
+ #include <stdlib.h>
+ #include <string.h>
+ #include "apps.h"
+ #include "ssl.h"
+ 
+ #undef PROG
+ #define PROG	ciphers_main
+ 
+ static char *ciphers_usage[]={
+ "usage: ciphers args\n",
+ " -v          - verbose mode, a textual listing of the ciphers in SSLeay\n",
+ NULL
+ };
+ 
+ int MAIN(argc, argv)
+ int argc;
+ char **argv;
+ 	{
+ 	int ret=1,i;
+ 	int verbose=0;
+ 	char **pp,*p;
+ 	int badops=0;
+ 
+ 	apps_startup();
+ 
+ 	argc--;
+ 	argv++;
+ 	while (argc >= 1)
+ 		{
+ 		if (strcmp(*argv,"-v") == 0)
+ 			verbose=1;
+ 		else
+ 			{
+ 			fprintf(stderr,"unknown option %s\n",*argv);
+ 			badops=1;
+ 			break;
+ 			}
+ 		argc--;
+ 		argv++;
+ 		}
+ 
+ 	if (badops)
+ 		{
+ 		for (pp=ciphers_usage; (*pp != NULL); pp++)
+ 			fprintf(stderr,*pp);
+ 		goto end;
+ 		}
+ 
+ 	if (verbose)
+ 		{
+ 		fprintf(stdout,"%-16s: No encryption with a MD5 MAC\n",
+ 			SSL_TXT_NULL_WITH_MD5);
+ #ifndef NO_RC4
+ 		fprintf(stdout,"%-16s: 128 bit RC4 encryption with a MD5 MAC\n",
+ 			SSL_TXT_RC4_128_WITH_MD5);
+ 		fprintf(stdout,"%-16s:  40 bit RC4 encryption with a MD5 MAC\n",
+ 			SSL_TXT_RC4_128_EXPORT40_WITH_MD5);
+ #endif
+ #ifndef NO_RC2
+ 		fprintf(stdout,"%-16s: 128 bit RC2 encryption with a MD5 MAC\n",
+ 			SSL_TXT_RC2_128_CBC_WITH_MD5);
+ 		fprintf(stdout,"%-16s:  40 bit RC2 encryption with a MD5 MAC\n",
+ 			SSL_TXT_RC2_128_CBC_EXPORT40_WITH_MD5);
+ #endif
+ #ifndef NO_IDEA
+ 		fprintf(stdout,"%-16s: 128 bit IDEA encryption with a MD5 MAC\n",
+ 			SSL_TXT_IDEA_128_CBC_WITH_MD5);
+ #endif
+ 		fprintf(stdout,"%-16s:  56 bit DES encryption with a MD5 MAC\n",
+ 			SSL_TXT_DES_64_CBC_WITH_MD5);
+ 		fprintf(stdout,"%-16s:  56 bit DES encryption with a SHA MAC\n",
+ 			SSL_TXT_DES_64_CBC_WITH_SHA);
+ 		fprintf(stdout,"%-16s: 192 bit EDE3 DES encryption with a MD5 MAC\n",
+ 			SSL_TXT_DES_192_EDE3_CBC_WITH_MD5);
+ 		fprintf(stdout,"%-16s: 192 bit EDE3 DES encryption with a SHA MAC\n",
+ 			SSL_TXT_DES_192_EDE3_CBC_WITH_SHA);
+ 		fprintf(stdout,"%-16s:  56 bit CFB64 DES encryption with a one byte MD5 MAC\n",
+ 			SSL_TXT_DES_64_CFB64_WITH_MD5_1);
+ 		}
+ 
+ 	if (!verbose)
+ 		{
+ 		for (i=0; ; i++)
+ 			{
+ 			p=SSL_get_cipher_list(NULL,i);
+ 			if (p == NULL) break;
+ 			if (i != 0) printf(":");
+ 			printf("%s",p);
+ 			}
+ 		printf("\n");
+ 		}
+ 	ret=0;
+ end:
+ 	EXIT(ret);
+ 	}
+ 
*** /var/spool/ftp/pub/Crypto/SSL/064/SSLeay-0.6.3/./apps/crl.c	Wed Jul 24 08:14:27 1996
--- ./apps/crl.c	Thu Aug 29 23:50:26 1996
***************
*** 160,165 ****
--- 160,173 ----
  		argv++;
  		}
  
+ 	if (outformat == FORMAT_TEXT)
+ 		{
+ 		num=0;
+ 		issuer= ++num;
+ 		lastupdate= ++num;
+ 		nextupdate= ++num;
+ 		}
+ 
  	if (badops)
  		{
  bad:
***************
*** 186,192 ****
  					goto end;
  					}
  				fprintf(stdout,"issuer= %s\n",str);
! 				free(str);
  				}
  
  			if (hash == i)
--- 194,200 ----
  					goto end;
  					}
  				fprintf(stdout,"issuer= %s\n",str);
! 				Free(str);
  				}
  
  			if (hash == i)
***************
*** 231,237 ****
  		i=(int)i2d_X509_CRL_bio(out,x);
  	else if (outformat == FORMAT_PEM)
  		i=PEM_write_bio_X509_CRL(out,x);
! 	else	{
  		fprintf(stderr,"bad output format specified for outfile\n");
  		goto end;
  		}
--- 239,258 ----
  		i=(int)i2d_X509_CRL_bio(out,x);
  	else if (outformat == FORMAT_PEM)
  		i=PEM_write_bio_X509_CRL(out,x);
! 	else if (outformat == FORMAT_TEXT)
! 		{
! 		X509_REVOKED *r;
! 
! 		while ((r=(X509_REVOKED *)sk_pop(x->crl->revoked)) != NULL)
! 			{
! 			fprintf(stdout,"revoked: serialNumber=");
! 			i2a_ASN1_INTEGER(out,r->serialNumber);
! 			fprintf(stdout,"revocationDate=%s\n",r->revocationDate);
! 			}
! 		i=1;
! 		}
! 	else	
! 		{
  		fprintf(stderr,"bad output format specified for outfile\n");
  		goto end;
  		}
*** /var/spool/ftp/pub/Crypto/SSL/064/SSLeay-0.6.3/./apps/crl2p7.c	Wed Jul 24 08:14:27 1996
--- ./apps/crl2p7.c	Thu Aug 29 23:50:26 1996
***************
*** 201,207 ****
  	if ((crl_stack=sk_new(NULL)) == NULL) goto end;
  	p7s->crl=crl_stack;
  	sk_push(crl_stack,(char *)crl);
! 	crl=NULL; /* now part of p7 for freeing */
  
  	if ((cert_stack=sk_new(NULL)) == NULL) goto end;
  	p7s->cert=cert_stack;
--- 201,207 ----
  	if ((crl_stack=sk_new(NULL)) == NULL) goto end;
  	p7s->crl=crl_stack;
  	sk_push(crl_stack,(char *)crl);
! 	crl=NULL; /* now part of p7 for Freeing */
  
  	if ((cert_stack=sk_new(NULL)) == NULL) goto end;
  	p7s->cert=cert_stack;
***************
*** 304,310 ****
  
  	ret=count;
  end:
!  	/* never need to free x */
  	if (in != NULL) BIO_free(in);
  	if (sk != NULL) sk_free(sk);
  	return(ret);
--- 304,310 ----
  
  	ret=count;
  end:
!  	/* never need to Free x */
  	if (in != NULL) BIO_free(in);
  	if (sk != NULL) sk_free(sk);
  	return(ret);
*** /dev/null	Fri Aug 30 04:16:48 1996
--- ./apps/demoCA/cacert.pem	Thu Aug 29 23:50:28 1996
***************
*** 0 ****
--- 1,14 ----
+ subject=/C=AU/SOP=QLD/O=Mincom Pty. Ltd./OU=CS/CN=SSLeay demo server
+ issuer= /C=AU/SOP=QLD/O=Mincom Pty. Ltd./OU=CS/CN=CA
+ -----BEGIN X509 CERTIFICATE-----
+ 
+ MIIBgjCCASwCAQQwDQYJKoZIhvcNAQEEBQAwODELMAkGA1UEBhMCQVUxDDAKBgNV
+ BAgTA1FMRDEbMBkGA1UEAxMSU1NMZWF5L3JzYSB0ZXN0IENBMB4XDTk1MTAwOTIz
+ MzIwNVoXDTk4MDcwNTIzMzIwNVowYDELMAkGA1UEBhMCQVUxDDAKBgNVBAgTA1FM
+ RDEZMBcGA1UEChMQTWluY29tIFB0eS4gTHRkLjELMAkGA1UECxMCQ1MxGzAZBgNV
+ BAMTElNTTGVheSBkZW1vIHNlcnZlcjBcMA0GCSqGSIb3DQEBAQUAA0sAMEgCQQC3
+ LCXcScWua0PFLkHBLm2VejqpA1F4RQ8q0VjRiPafjx/Z/aWH3ipdMVvuJGa/wFXb
+ /nDFLDlfWp+oCPwhBtVPAgMBAAEwDQYJKoZIhvcNAQEEBQADQQArNFsihWIjBzb0
+ DCsU0BvL2bvSwJrPEqFlkDq3F4M6EGutL9axEcANWgbbEdAvNJD1dmEmoWny27Pn
+ IMs6ZOZB
+ -----END X509 CERTIFICATE-----
*** /dev/null	Fri Aug 30 04:16:48 1996
--- ./apps/demoCA/index.txt	Thu Aug 29 23:50:28 1996
***************
*** 0 ****
--- 1,31 ----
+ R	980705233205Z	951009233205Z	01	certs/00000001	/CN=Eric Young
+ E	951009233205Z		02	certs/00000002	/CN=Duncan Young
+ R	980705233205Z	951201010000Z	03	certs/00000003	/CN=Tim Hudson
+ V	980705233205Z		04	certs/00000004	/CN=Eric Young4
+ V	980705233205Z		05	certs/00000004	/CN=Eric Young5
+ V	980705233205Z		06	certs/00000004	/CN=Eric Young6
+ V	980705233205Z		07	certs/00000004	/CN=Eric Young7
+ V	980705233205Z		08	certs/00000004	/CN=Eric Young8
+ V	980705233205Z		09	certs/00000004	/CN=Eric Young9
+ V	980705233205Z		0A	certs/00000004	/CN=Eric YoungA
+ V	980705233205Z		0B	certs/00000004	/CN=Eric YoungB
+ V	980705233205Z		0C	certs/00000004	/CN=Eric YoungC
+ V	980705233205Z		0D	certs/00000004	/CN=Eric YoungD
+ V	980705233205Z		0E	certs/00000004	/CN=Eric YoungE
+ V	980705233205Z		0F	certs/00000004	/CN=Eric YoungF
+ V	980705233205Z		10	certs/00000004	/CN=Eric Young10
+ V	980705233205Z		11	certs/00000004	/CN=Eric Young11
+ V	980705233205Z		12	certs/00000004	/CN=Eric Young12
+ V	980705233205Z		13	certs/00000004	/CN=Eric Young13
+ V	980705233205Z		14	certs/00000004	/CN=Eric Young14
+ V	980705233205Z		15	certs/00000004	/CN=Eric Young15
+ V	980705233205Z		16	certs/00000004	/CN=Eric Young16
+ V	980705233205Z		17	certs/00000004	/CN=Eric Young17
+ V	961206150305Z		010C	unknown	/C=AU/SP=QLD/O=Mincom Pty. Ltd./OU=MTR/CN=Eric Young/Email=eay@mincom.oz.au
+ V	961206153245Z		010D	unknown	/C=AU/SP=Queensland/O=Mincom Pty Ltd/OU=MTR/CN=Eric Young/Email=eay@mincom.oz.au
+ V	970322074816Z		010E	unknown	/CN=Eric Young/Email=eay@mincom.oz.au
+ V	970322075152Z		010F	unknown	/CN=Eric Young
+ V	970322075906Z		0110	unknown	/CN=Eric Youngg
+ V	970324092238Z		0111	unknown	/C=AU/SP=Queensland/CN=Eric Young
+ V	970324221931Z		0112	unknown	/CN=Fred
+ V	970324224934Z		0113	unknown	/C=AU/CN=eay
*** /dev/null	Fri Aug 30 04:16:48 1996
--- ./apps/demoCA/new_certs/0104	Sat Jun  1 00:18:12 1996
***************
*** 0 ****
--- 1,43 ----
+ issuer :/C=AU/SP=QLD/CN=SSLeay/rsa test CA
+ subject:/C=AU/SP=QLD/O=Mincom Pty. Ltd./OU=MTR/CN=Eric Young/Email=eay@mincom.oz.au
+ serial :0104
+ 
+ Certificate:
+     Data:
+         Version: 0 (0x0)
+         Serial Number: 260 (0x104)
+         Signature Algorithm: md5withRSAEncryption
+         Issuer: C=AU, SP=QLD, CN=SSLeay, rsa test CA
+         Validity
+             Not Before: Dec  6 22:03:08 1995
+             Not After : Dec  5 22:03:08 1996
+         Subject:C=AU, SP=QLD, O=Mincom Pty. Ltd., OU=MTR, CN=Eric Young, 
+                 Email=eay@mincom.oz.au
+         Subject Public Key Info:
+             Public Key Algorithm: rsaEncryption
+             Public Key: (511 bit)
+                 Modulus:
+                     00:7a:31:96:56:29:af:c2:7e:82:59:08:a1:81:80:
+                     c6:ca:48:32:2b:5d:f6:84:e2:07:9b:8e:d1:7e:80:
+                     d1:86:02:38:ab:26:10:eb:a2:50:7c:94:2a:7f:74:
+                     bc:09:c1:ac:54:79:6c:62:6c:dd:af:e7:40:99:dc:
+                     0a:a9:7e:c5
+                 Exponent: 65537 (0x10001)
+     Signature Algorithm: md5withRSAEncryption
+         7b:0a:b2:f4:1c:3a:02:81:21:1a:4c:fd:fa:f8:0d:c4:e8:2a:
+         ac:50:30:4d:26:a6:eb:28:58:f0:9c:41:7f:a4:4b:55:2d:09:
+         25:d1:ba:0e:b1:cc:9f:40:89:1c:9b:4b:e3:6c:50:b3:12:66:
+         bf:b3:69:7d:63:ff:4c:f4:17:18
+ 
+ -----BEGIN X509 CERTIFICATE-----
+ MIIBnDCCAUYCAgEEMA0GCSqGSIb3DQEBBAUAMDgxCzAJBgNVBAYTAkFVMQwwCgYD
+ VQQIEwNRTEQxGzAZBgNVBAMTElNTTGVheS9yc2EgdGVzdCBDQTAeFw05NTEyMDYy
+ MjAzMDhaFw05NjEyMDUyMjAzMDhaMHoxCzAJBgNVBAYTAkFVMQwwCgYDVQQIEwNR
+ TEQxGTAXBgNVBAoTEE1pbmNvbSBQdHkuIEx0ZC4xDDAKBgNVBAsTA01UUjETMBEG
+ A1UEAxMKRXJpYyBZb3VuZzEfMB0GCSqGSIb3DQEJARYQZWF5QG1pbmNvbS5vei5h
+ dTBbMA0GCSqGSIb3DQEBAQUAA0oAMEcCQHoxllYpr8J+glkIoYGAxspIMitd9oTi
+ B5uO0X6A0YYCOKsmEOuiUHyUKn90vAnBrFR5bGJs3a/nQJncCql+xWMCAwEAATAN
+ BgkqhkiG9w0BAQQFAANBAHsKsvQcOgKBIRpM/fr4DcToKqxQME0mpusoWPCcQX+k
+ S1UtCSXRug6xzJ9AiRybS+NsULMSZr+zaX1j/0z0Fxg=
+ -----END X509 CERTIFICATE-----
+ 
*** /dev/null	Fri Aug 30 04:16:48 1996
--- ./apps/demoCA/new_certs/0106	Sat Jun  1 00:18:12 1996
***************
*** 0 ****
--- 1,43 ----
+ issuer :/C=AU/SP=QLD/CN=SSLeay/rsa test CA
+ subject:/C=AU/SP=QLD/O=Mincom Pty. Ltd./OU=MTR/CN=Eric Young/Email=eay@mincom.oz.au
+ serial :0106
+ 
+ Certificate:
+     Data:
+         Version: 0 (0x0)
+         Serial Number: 262 (0x106)
+         Signature Algorithm: md5withRSAEncryption
+         Issuer: C=AU, SP=QLD, CN=SSLeay, rsa test CA
+         Validity
+             Not Before: Dec  6 22:13:14 1995
+             Not After : Dec  5 22:13:14 1996
+         Subject:C=AU, SP=QLD, O=Mincom Pty. Ltd., OU=MTR, CN=Eric Young, 
+                 Email=eay@mincom.oz.au
+         Subject Public Key Info:
+             Public Key Algorithm: rsaEncryption
+             Public Key: (511 bit)
+                 Modulus:
+                     7a:31:96:56:29:af:c2:7e:82:59:08:a1:81:80:c6:
+                     ca:48:32:2b:5d:f6:84:e2:07:9b:8e:d1:7e:80:d1:
+                     86:02:38:ab:26:10:eb:a2:50:7c:94:2a:7f:74:bc:
+                     09:c1:ac:54:79:6c:62:6c:dd:af:e7:40:99:dc:0a:
+                     a9:7e:c5:63
+                 Exponent: 65537 (0x10001)
+     Signature Algorithm: md5withRSAEncryption
+         a0:44:9b:85:70:33:8b:58:74:b7:1c:04:11:8c:de:94:21:34:
+         70:f2:66:c1:9a:4d:34:2e:e8:8f:72:81:42:88:8c:15:63:4b:
+         50:09:05:4f:79:3b:2d:49:0b:f3:bf:59:6b:a6:6a:a7:48:5d:
+         b4:b9:a1:75:f1:86:24:0c:b5:fd
+ 
+ -----BEGIN X509 CERTIFICATE-----
+ MIIBnDCCAUYCAgEGMA0GCSqGSIb3DQEBBAUAMDgxCzAJBgNVBAYTAkFVMQwwCgYD
+ VQQIEwNRTEQxGzAZBgNVBAMTElNTTGVheS9yc2EgdGVzdCBDQTAeFw05NTEyMDYy
+ MjEzMTRaFw05NjEyMDUyMjEzMTRaMHoxCzAJBgNVBAYTAkFVMQwwCgYDVQQIEwNR
+ TEQxGTAXBgNVBAoTEE1pbmNvbSBQdHkuIEx0ZC4xDDAKBgNVBAsTA01UUjETMBEG
+ A1UEAxMKRXJpYyBZb3VuZzEfMB0GCSqGSIb3DQEJARYQZWF5QG1pbmNvbS5vei5h
+ dTBbMA0GCSqGSIb3DQEBAQUAA0oAMEcCQHoxllYpr8J+glkIoYGAxspIMitd9oTi
+ B5uO0X6A0YYCOKsmEOuiUHyUKn90vAnBrFR5bGJs3a/nQJncCql+xWMCAwEAATAN
+ BgkqhkiG9w0BAQQFAANBAKBEm4VwM4tYdLccBBGM3pQhNHDyZsGaTTQu6I9ygUKI
+ jBVjS1AJBU95Oy1JC/O/WWumaqdIXbS5oXXxhiQMtf0=
+ -----END X509 CERTIFICATE-----
+ 
*** /dev/null	Fri Aug 30 04:16:48 1996
--- ./apps/demoCA/new_certs/0107	Sat Jun  1 00:18:12 1996
***************
*** 0 ****
--- 1,43 ----
+ issuer :/C=AU/SP=QLD/CN=SSLeay/rsa test CA
+ subject:/C=AU/SP=QLD/O=Mincom Pty. Ltd./OU=MTR/CN=Eric Young/Email=eay@mincom.oz.au
+ serial :0107
+ 
+ Certificate:
+     Data:
+         Version: 0 (0x0)
+         Serial Number: 263 (0x107)
+         Signature Algorithm: md5withRSAEncryption
+         Issuer: C=AU, SP=QLD, CN=SSLeay, rsa test CA
+         Validity
+             Not Before: Dec  6 22:18:28 1995
+             Not After : Dec  5 22:18:28 1996
+         Subject:C=AU, SP=QLD, O=Mincom Pty. Ltd., OU=MTR, CN=Eric Young, 
+                 Email=eay@mincom.oz.au
+         Subject Public Key Info:
+             Public Key Algorithm: rsaEncryption
+             Public Key: (511 bit)
+                 Modulus:
+                     7a:31:96:56:29:af:c2:7e:82:59:08:a1:81:80:c6:
+                     ca:48:32:2b:5d:f6:84:e2:07:9b:8e:d1:7e:80:d1:
+                     86:02:38:ab:26:10:eb:a2:50:7c:94:2a:7f:74:bc:
+                     09:c1:ac:54:79:6c:62:6c:dd:af:e7:40:99:dc:0a:
+                     a9:7e:c5:63
+                 Exponent: 65537 (0x10001)
+     Signature Algorithm: md5withRSAEncryption
+         19:3e:cd:bd:20:e2:d5:22:77:ca:13:e1:2f:e7:83:da:9e:6c:
+         06:7a:ee:ba:1f:10:dd:ce:77:a9:ce:3d:80:fa:d1:10:60:d8:
+         8a:a0:49:fc:d3:3a:30:40:d9:db:1a:d9:42:ef:31:49:de:85:
+         21:b3:19:4e:5b:a3:4e:3f:40:10
+ 
+ -----BEGIN X509 CERTIFICATE-----
+ MIIBnDCCAUYCAgEHMA0GCSqGSIb3DQEBBAUAMDgxCzAJBgNVBAYTAkFVMQwwCgYD
+ VQQIEwNRTEQxGzAZBgNVBAMTElNTTGVheS9yc2EgdGVzdCBDQTAeFw05NTEyMDYy
+ MjE4MjhaFw05NjEyMDUyMjE4MjhaMHoxCzAJBgNVBAYTAkFVMQwwCgYDVQQIEwNR
+ TEQxGTAXBgNVBAoTEE1pbmNvbSBQdHkuIEx0ZC4xDDAKBgNVBAsTA01UUjETMBEG
+ A1UEAxMKRXJpYyBZb3VuZzEfMB0GCSqGSIb3DQEJARYQZWF5QG1pbmNvbS5vei5h
+ dTBbMA0GCSqGSIb3DQEBAQUAA0oAMEcCQHoxllYpr8J+glkIoYGAxspIMitd9oTi
+ B5uO0X6A0YYCOKsmEOuiUHyUKn90vAnBrFR5bGJs3a/nQJncCql+xWMCAwEAATAN
+ BgkqhkiG9w0BAQQFAANBABk+zb0g4tUid8oT4S/ng9qebAZ67rofEN3Od6nOPYD6
+ 0RBg2IqgSfzTOjBA2dsa2ULvMUnehSGzGU5bo04/QBA=
+ -----END X509 CERTIFICATE-----
+ 
*** /dev/null	Fri Aug 30 04:16:48 1996
--- ./apps/demoCA/new_certs/0108	Sat Jun  1 00:18:12 1996
***************
*** 0 ****
--- 1,43 ----
+ issuer :/C=AU/SP=QLD/CN=SSLeay/rsa test CA
+ subject:/C=AU/SP=QLD/O=Mincom Pty. Ltd./OU=MTR/CN=Eric Young/Email=eay@mincom.oz.au
+ serial :0108
+ 
+ Certificate:
+     Data:
+         Version: 0 (0x0)
+         Serial Number: 264 (0x108)
+         Signature Algorithm: md5withRSAEncryption
+         Issuer: C=AU, SP=QLD, CN=SSLeay, rsa test CA
+         Validity
+             Not Before: Dec  6 22:27:41 1995
+             Not After : Dec  5 22:27:41 1996
+         Subject:C=AU, SP=QLD, O=Mincom Pty. Ltd., OU=MTR, CN=Eric Young, 
+                 Email=eay@mincom.oz.au
+         Subject Public Key Info:
+             Public Key Algorithm: rsaEncryption
+             Public Key: (511 bit)
+                 Modulus:
+                     7a:31:96:56:29:af:c2:7e:82:59:08:a1:81:80:c6:
+                     ca:48:32:2b:5d:f6:84:e2:07:9b:8e:d1:7e:80:d1:
+                     86:02:38:ab:26:10:eb:a2:50:7c:94:2a:7f:74:bc:
+                     09:c1:ac:54:79:6c:62:6c:dd:af:e7:40:99:dc:0a:
+                     a9:7e:c5:63
+                 Exponent: 65537 (0x10001)
+     Signature Algorithm: md5withRSAEncryption
+         65:e5:18:e6:cd:b4:64:a9:d3:b7:1b:7e:9c:8a:30:2b:ba:a4:
+         84:33:3f:2d:d5:61:87:2b:3a:e6:fd:64:af:8c:6a:a1:b0:6a:
+         6d:73:1f:63:1c:fc:79:1e:bc:68:6f:2b:6b:fd:cb:2a:83:91:
+         69:4e:27:e3:54:78:38:9e:b5:42
+ 
+ -----BEGIN X509 CERTIFICATE-----
+ MIIBnDCCAUYCAgEIMA0GCSqGSIb3DQEBBAUAMDgxCzAJBgNVBAYTAkFVMQwwCgYD
+ VQQIEwNRTEQxGzAZBgNVBAMTElNTTGVheS9yc2EgdGVzdCBDQTAeFw05NTEyMDYy
+ MjI3NDFaFw05NjEyMDUyMjI3NDFaMHoxCzAJBgNVBAYTAkFVMQwwCgYDVQQIEwNR
+ TEQxGTAXBgNVBAoTEE1pbmNvbSBQdHkuIEx0ZC4xDDAKBgNVBAsTA01UUjETMBEG
+ A1UEAxMKRXJpYyBZb3VuZzEfMB0GCSqGSIb3DQEJARYQZWF5QG1pbmNvbS5vei5h
+ dTBbMA0GCSqGSIb3DQEBAQUAA0oAMEcCQHoxllYpr8J+glkIoYGAxspIMitd9oTi
+ B5uO0X6A0YYCOKsmEOuiUHyUKn90vAnBrFR5bGJs3a/nQJncCql+xWMCAwEAATAN
+ BgkqhkiG9w0BAQQFAANBAGXlGObNtGSp07cbfpyKMCu6pIQzPy3VYYcrOub9ZK+M
+ aqGwam1zH2Mc/HkevGhvK2v9yyqDkWlOJ+NUeDietUI=
+ -----END X509 CERTIFICATE-----
+ 
*** /dev/null	Fri Aug 30 04:16:48 1996
--- ./apps/demoCA/new_certs/0109	Sat Jun  1 00:18:12 1996
***************
*** 0 ****
--- 1,43 ----
+ issuer :/C=AU/SP=QLD/CN=SSLeay/rsa test CA
+ subject:/C=AU/SP=QLD/O=Mincom Pty. Ltd./OU=MTR/CN=Eric Young/Email=eay@mincom.oz.au
+ serial :0109
+ 
+ Certificate:
+     Data:
+         Version: 0 (0x0)
+         Serial Number: 265 (0x109)
+         Signature Algorithm: md5withRSAEncryption
+         Issuer: C=AU, SP=QLD, CN=SSLeay, rsa test CA
+         Validity
+             Not Before: Dec  6 22:31:04 1995
+             Not After : Dec  5 22:31:04 1996
+         Subject:C=AU, SP=QLD, O=Mincom Pty. Ltd., OU=MTR, CN=Eric Young, 
+                 Email=eay@mincom.oz.au
+         Subject Public Key Info:
+             Public Key Algorithm: rsaEncryption
+             Public Key: (511 bit)
+                 Modulus:
+                     7a:31:96:56:29:af:c2:7e:82:59:08:a1:81:80:c6:
+                     ca:48:32:2b:5d:f6:84:e2:07:9b:8e:d1:7e:80:d1:
+                     86:02:38:ab:26:10:eb:a2:50:7c:94:2a:7f:74:bc:
+                     09:c1:ac:54:79:6c:62:6c:dd:af:e7:40:99:dc:0a:
+                     a9:7e:c5:63
+                 Exponent: 65537 (0x10001)
+     Signature Algorithm: md5withRSAEncryption
+         b0:9b:b0:85:56:78:16:03:be:70:ca:a1:d3:1b:9c:27:b2:31:
+         44:3c:ae:ee:97:d9:05:2c:46:80:b8:81:de:26:0e:50:05:b8:
+         81:c4:eb:dc:cd:c5:9c:89:78:76:e9:af:06:df:f7:66:15:9a:
+         58:26:8d:eb:94:c3:61:81:ec:29
+ 
+ -----BEGIN X509 CERTIFICATE-----
+ MIIBnDCCAUYCAgEJMA0GCSqGSIb3DQEBBAUAMDgxCzAJBgNVBAYTAkFVMQwwCgYD
+ VQQIEwNRTEQxGzAZBgNVBAMTElNTTGVheS9yc2EgdGVzdCBDQTAeFw05NTEyMDYy
+ MjMxMDRaFw05NjEyMDUyMjMxMDRaMHoxCzAJBgNVBAYTAkFVMQwwCgYDVQQIEwNR
+ TEQxGTAXBgNVBAoTEE1pbmNvbSBQdHkuIEx0ZC4xDDAKBgNVBAsTA01UUjETMBEG
+ A1UEAxMKRXJpYyBZb3VuZzEfMB0GCSqGSIb3DQEJARYQZWF5QG1pbmNvbS5vei5h
+ dTBbMA0GCSqGSIb3DQEBAQUAA0oAMEcCQHoxllYpr8J+glkIoYGAxspIMitd9oTi
+ B5uO0X6A0YYCOKsmEOuiUHyUKn90vAnBrFR5bGJs3a/nQJncCql+xWMCAwEAATAN
+ BgkqhkiG9w0BAQQFAANBALCbsIVWeBYDvnDKodMbnCeyMUQ8ru6X2QUsRoC4gd4m
+ DlAFuIHE69zNxZyJeHbprwbf92YVmlgmjeuUw2GB7Ck=
+ -----END X509 CERTIFICATE-----
+ 
*** /dev/null	Fri Aug 30 04:16:48 1996
--- ./apps/demoCA/new_certs/010a	Sat Jun  1 00:18:12 1996
***************
*** 0 ****
--- 1,43 ----
+ issuer :/C=AU/SP=QLD/CN=SSLeay/rsa test CA
+ subject:/C=AU/SP=QLD/O=Mincom Pty. Ltd./OU=MTR/CN=Eric Young/Email=eay@mincom.oz.au
+ serial :010A
+ 
+ Certificate:
+     Data:
+         Version: 0 (0x0)
+         Serial Number: 266 (0x10a)
+         Signature Algorithm: md5withRSAEncryption
+         Issuer: C=AU, SP=QLD, CN=SSLeay, rsa test CA
+         Validity
+             Not Before: Dec  6 22:39:51 1995
+             Not After : Dec  5 22:39:51 1996
+         Subject:C=AU, SP=QLD, O=Mincom Pty. Ltd., OU=MTR, CN=Eric Young, 
+                 Email=eay@mincom.oz.au
+         Subject Public Key Info:
+             Public Key Algorithm: rsaEncryption
+             Public Key: (511 bit)
+                 Modulus:
+                     7a:31:96:56:29:af:c2:7e:82:59:08:a1:81:80:c6:
+                     ca:48:32:2b:5d:f6:84:e2:07:9b:8e:d1:7e:80:d1:
+                     86:02:38:ab:26:10:eb:a2:50:7c:94:2a:7f:74:bc:
+                     09:c1:ac:54:79:6c:62:6c:dd:af:e7:40:99:dc:0a:
+                     a9:7e:c5:63
+                 Exponent: 65537 (0x10001)
+     Signature Algorithm: md5withRSAEncryption
+         71:58:4b:bb:53:ca:54:58:17:05:8b:d8:90:af:4c:f2:8d:b1:
+         bf:0d:67:c3:6f:83:4c:13:61:15:b4:33:1f:a7:94:b4:48:6a:
+         ec:26:26:6c:c0:6a:2f:21:e6:01:59:a4:fd:de:c0:00:e4:d7:
+         4c:8b:fd:31:03:a9:8f:9b:3b:ec
+ 
+ -----BEGIN X509 CERTIFICATE-----
+ MIIBnDCCAUYCAgEKMA0GCSqGSIb3DQEBBAUAMDgxCzAJBgNVBAYTAkFVMQwwCgYD
+ VQQIEwNRTEQxGzAZBgNVBAMTElNTTGVheS9yc2EgdGVzdCBDQTAeFw05NTEyMDYy
+ MjM5NTFaFw05NjEyMDUyMjM5NTFaMHoxCzAJBgNVBAYTAkFVMQwwCgYDVQQIEwNR
+ TEQxGTAXBgNVBAoTEE1pbmNvbSBQdHkuIEx0ZC4xDDAKBgNVBAsTA01UUjETMBEG
+ A1UEAxMKRXJpYyBZb3VuZzEfMB0GCSqGSIb3DQEJARYQZWF5QG1pbmNvbS5vei5h
+ dTBbMA0GCSqGSIb3DQEBAQUAA0oAMEcCQHoxllYpr8J+glkIoYGAxspIMitd9oTi
+ B5uO0X6A0YYCOKsmEOuiUHyUKn90vAnBrFR5bGJs3a/nQJncCql+xWMCAwEAATAN
+ BgkqhkiG9w0BAQQFAANBAHFYS7tTylRYFwWL2JCvTPKNsb8NZ8Nvg0wTYRW0Mx+n
+ lLRIauwmJmzAai8h5gFZpP3ewADk10yL/TEDqY+bO+w=
+ -----END X509 CERTIFICATE-----
+ 
*** /dev/null	Fri Aug 30 04:16:48 1996
--- ./apps/demoCA/new_certs/010b	Sat Jun  1 00:18:12 1996
***************
*** 0 ****
--- 1,45 ----
+ issuer :/C=AU/SP=QLD/O=Mincom Pty. Ltd./OU=CS/CN=SSLeay demo server
+ subject:/C=AU/SP=QLD/O=Mincom Pty. Ltd./OU=MTR/CN=Eric Young/Email=eay@mincom.oz.au
+ serial :010B
+ 
+ Certificate:
+     Data:
+         Version: 0 (0x0)
+         Serial Number: 267 (0x10b)
+         Signature Algorithm: md5withRSAEncryption
+         Issuer: C=AU, SP=QLD, O=Mincom Pty. Ltd., OU=CS, 
+                 CN=SSLeay demo server
+         Validity
+             Not Before: Dec  6 22:59:04 1995
+             Not After : Dec  5 22:59:04 1996
+         Subject:C=AU, SP=QLD, O=Mincom Pty. Ltd., OU=MTR, CN=Eric Young, 
+                 Email=eay@mincom.oz.au
+         Subject Public Key Info:
+             Public Key Algorithm: rsaEncryption
+             Public Key: (511 bit)
+                 Modulus:
+                     7a:31:96:56:29:af:c2:7e:82:59:08:a1:81:80:c6:
+                     ca:48:32:2b:5d:f6:84:e2:07:9b:8e:d1:7e:80:d1:
+                     86:02:38:ab:26:10:eb:a2:50:7c:94:2a:7f:74:bc:
+                     09:c1:ac:54:79:6c:62:6c:dd:af:e7:40:99:dc:0a:
+                     a9:7e:c5:63
+                 Exponent: 65537 (0x10001)
+     Signature Algorithm: md5withRSAEncryption
+         38:f0:4c:14:d4:34:9a:2a:db:9c:7e:57:d1:2b:72:e0:b3:f2:
+         c0:41:dc:ef:5b:d5:f1:bd:e6:21:02:d4:b1:cb:e4:d2:01:27:
+         3d:fe:a4:b1:6c:65:35:58:72:f1:25:e2:9c:50:23:f7:8e:53:
+         24:3b:60:4f:9d:f2:90:6d:d5:d1
+ 
+ -----BEGIN X509 CERTIFICATE-----
+ MIIBxDCCAW4CAgELMA0GCSqGSIb3DQEBBAUAMGAxCzAJBgNVBAYTAkFVMQwwCgYD
+ VQQIEwNRTEQxGTAXBgNVBAoTEE1pbmNvbSBQdHkuIEx0ZC4xCzAJBgNVBAsTAkNT
+ MRswGQYDVQQDExJTU0xlYXkgZGVtbyBzZXJ2ZXIwHhcNOTUxMjA2MjI1OTA0WhcN
+ OTYxMjA1MjI1OTA0WjB6MQswCQYDVQQGEwJBVTEMMAoGA1UECBMDUUxEMRkwFwYD
+ VQQKExBNaW5jb20gUHR5LiBMdGQuMQwwCgYDVQQLEwNNVFIxEzARBgNVBAMTCkVy
+ aWMgWW91bmcxHzAdBgkqhkiG9w0BCQEWEGVheUBtaW5jb20ub3ouYXUwWzANBgkq
+ hkiG9w0BAQEFAANKADBHAkB6MZZWKa/CfoJZCKGBgMbKSDIrXfaE4gebjtF+gNGG
+ AjirJhDrolB8lCp/dLwJwaxUeWxibN2v50CZ3AqpfsVjAgMBAAEwDQYJKoZIhvcN
+ AQEEBQADQQA48EwU1DSaKtucflfRK3Lgs/LAQdzvW9XxveYhAtSxy+TSASc9/qSx
+ bGU1WHLxJeKcUCP3jlMkO2BPnfKQbdXR
+ -----END X509 CERTIFICATE-----
+ 
*** /dev/null	Fri Aug 30 04:16:48 1996
--- ./apps/demoCA/new_certs/010c.pem	Sat Jun  1 00:18:12 1996
***************
*** 0 ****
--- 1,45 ----
+ issuer :/C=AU/SP=QLD/O=Mincom Pty. Ltd./OU=CS/CN=SSLeay demo server
+ subject:/C=AU/SP=QLD/O=Mincom Pty. Ltd./OU=MTR/CN=Eric Young/Email=eay@mincom.oz.au
+ serial :010C
+ 
+ Certificate:
+     Data:
+         Version: 0 (0x0)
+         Serial Number: 268 (0x10c)
+         Signature Algorithm: md5withRSAEncryption
+         Issuer: C=AU, SP=QLD, O=Mincom Pty. Ltd., OU=CS, 
+                 CN=SSLeay demo server
+         Validity
+             Not Before: Dec  7 15:03:05 1995
+             Not After : Dec  6 15:03:05 1996
+         Subject:C=AU, SP=QLD, O=Mincom Pty. Ltd., OU=MTR, CN=Eric Young, 
+                 Email=eay@mincom.oz.au
+         Subject Public Key Info:
+             Public Key Algorithm: rsaEncryption
+             Public Key: (512 bit)
+                 Modulus:
+                     00:af:0c:6e:1c:85:dd:52:fa:a1:f4:a2:18:31:2b:
+                     0c:0b:8e:1a:46:77:de:40:02:46:ae:08:78:44:0b:
+                     dc:c9:9e:e1:96:28:91:a6:a2:af:3e:88:6f:65:58:
+                     f1:f5:b0:2c:45:ef:5d:39:58:20:2c:06:27:d7:eb:
+                     87:f7:8d:42:61
+                 Exponent: 65537 (0x10001)
+     Signature Algorithm: md5withRSAEncryption
+         69:65:b4:7f:0a:f3:79:29:ff:cf:21:52:1a:34:1c:2d:89:96:
+         5f:72:8d:ca:1b:94:cd:ab:33:03:f5:b2:ce:97:da:67:12:89:
+         3b:51:a4:1b:64:43:5e:cb:c9:e3:3f:ee:2b:c2:0c:fd:05:c9:
+         ed:fb:35:eb:cf:1d:d8:b2:eb:98
+ 
+ -----BEGIN X509 CERTIFICATE-----
+ MIIBxTCCAW8CAgEMMA0GCSqGSIb3DQEBBAUAMGAxCzAJBgNVBAYTAkFVMQwwCgYD
+ VQQIEwNRTEQxGTAXBgNVBAoTEE1pbmNvbSBQdHkuIEx0ZC4xCzAJBgNVBAsTAkNT
+ MRswGQYDVQQDExJTU0xlYXkgZGVtbyBzZXJ2ZXIwHhcNOTUxMjA3MTUwMzA1WhcN
+ OTYxMjA2MTUwMzA1WjB6MQswCQYDVQQGEwJBVTEMMAoGA1UECBMDUUxEMRkwFwYD
+ VQQKExBNaW5jb20gUHR5LiBMdGQuMQwwCgYDVQQLEwNNVFIxEzARBgNVBAMTCkVy
+ aWMgWW91bmcxHzAdBgkqhkiG9w0BCQEWEGVheUBtaW5jb20ub3ouYXUwXDANBgkq
+ hkiG9w0BAQEFAANLADBIAkEArwxuHIXdUvqh9KIYMSsMC44aRnfeQAJGrgh4RAvc
+ yZ7hliiRpqKvPohvZVjx9bAsRe9dOVggLAYn1+uH941CYQIDAQABMA0GCSqGSIb3
+ DQEBBAUAA0EAaWW0fwrzeSn/zyFSGjQcLYmWX3KNyhuUzaszA/WyzpfaZxKJO1Gk
+ G2RDXsvJ4z/uK8IM/QXJ7fs1688d2LLrmA==
+ -----END X509 CERTIFICATE-----
+ 
*** /dev/null	Fri Aug 30 04:16:48 1996
--- ./apps/demoCA/new_certs/010d.pem	Sat Jun  1 00:18:12 1996
***************
*** 0 ****
--- 1,45 ----
+ issuer :/C=AU/SP=QLD/O=Mincom Pty. Ltd./OU=CS/CN=SSLeay demo server
+ subject:/C=AU/SP=Queensland/O=Mincom Pty Ltd/OU=MTR/CN=Eric Young/Email=eay@mincom.oz.au
+ serial :010D
+ 
+ Certificate:
+     Data:
+         Version: 0 (0x0)
+         Serial Number: 269 (0x10d)
+         Signature Algorithm: md5withRSAEncryption
+         Issuer: C=AU, SP=QLD, O=Mincom Pty. Ltd., OU=CS, 
+                 CN=SSLeay demo server
+         Validity
+             Not Before: Dec  7 15:32:45 1995
+             Not After : Dec  6 15:32:45 1996
+         Subject:C=AU, SP=Queensland, O=Mincom Pty Ltd, OU=MTR, CN=Eric Young, 
+                 Email=eay@mincom.oz.au
+         Subject Public Key Info:
+             Public Key Algorithm: rsaEncryption
+             Public Key: (512 bit)
+                 Modulus:
+                     00:be:ac:79:49:9b:49:a9:55:38:de:72:4e:34:ba:
+                     43:ae:f2:f4:33:8f:1d:04:3e:85:65:51:a5:3b:dc:
+                     d6:24:fb:bd:8a:2f:bc:3e:ce:02:2c:e4:5f:f6:07:
+                     58:dc:71:24:eb:ab:f2:51:75:06:f2:9c:1a:d5:44:
+                     82:a5:ab:c6:ff
+                 Exponent: 65537 (0x10001)
+     Signature Algorithm: md5withRSAEncryption
+         42:f7:d7:8f:05:2f:8c:5c:4c:d4:d0:95:90:f4:47:ed:3a:96:
+         62:0b:9f:fa:70:17:43:28:6f:7b:2c:60:b2:12:b6:34:d6:5c:
+         17:43:27:90:80:0f:da:87:8f:f7:37:cb:0d:27:32:24:05:52:
+         b1:04:86:eb:eb:a5:1f:c3:58:ea
+ 
+ -----BEGIN X509 CERTIFICATE-----
+ MIIByjCCAXQCAgENMA0GCSqGSIb3DQEBBAUAMGAxCzAJBgNVBAYTAkFVMQwwCgYD
+ VQQIEwNRTEQxGTAXBgNVBAoTEE1pbmNvbSBQdHkuIEx0ZC4xCzAJBgNVBAsTAkNT
+ MRswGQYDVQQDExJTU0xlYXkgZGVtbyBzZXJ2ZXIwHhcNOTUxMjA3MTUzMjQ1WhcN
+ OTYxMjA2MTUzMjQ1WjB/MQswCQYDVQQGEwJBVTETMBEGA1UECBMKUXVlZW5zbGFu
+ ZDEXMBUGA1UEChMOTWluY29tIFB0eSBMdGQxDDAKBgNVBAsTA01UUjETMBEGA1UE
+ AxMKRXJpYyBZb3VuZzEfMB0GCSqGSIb3DQEJARYQZWF5QG1pbmNvbS5vei5hdTBc
+ MA0GCSqGSIb3DQEBAQUAA0sAMEgCQQC+rHlJm0mpVTjeck40ukOu8vQzjx0EPoVl
+ UaU73NYk+72KL7w+zgIs5F/2B1jccSTrq/JRdQbynBrVRIKlq8b/AgMBAAEwDQYJ
+ KoZIhvcNAQEEBQADQQBC99ePBS+MXEzU0JWQ9EftOpZiC5/6cBdDKG97LGCyErY0
+ 1lwXQyeQgA/ah4/3N8sNJzIkBVKxBIbr66Ufw1jq
+ -----END X509 CERTIFICATE-----
+ 
*** /dev/null	Fri Aug 30 04:16:48 1996
--- ./apps/demoCA/new_certs/010E.pem	Sat Jun  1 00:18:12 1996
***************
*** 0 ****
--- 1,43 ----
+ issuer :/C=AU/SP=QLD/O=Mincom Pty. Ltd./OU=CS/CN=SSLeay demo server
+ subject:/CN=Eric Young/Email=eay@mincom.oz.au
+ serial :010E
+ 
+ Certificate:
+     Data:
+         Version: 0 (0x0)
+         Serial Number: 270 (0x10e)
+         Signature Algorithm: md5withRSAEncryption
+         Issuer: C=AU, SP=QLD, O=Mincom Pty. Ltd., OU=CS, 
+                 CN=SSLeay demo server
+         Validity
+             Not Before: Mar 22 07:48:16 1996
+             Not After : Mar 22 07:48:16 1997
+         Subject:CN=Eric Young, Email=eay@mincom.oz.au
+         Subject Public Key Info:
+             Public Key Algorithm: rsaEncryption
+             Public Key: (512 bit)
+                 Modulus:
+                     00:b2:6e:4c:4e:53:3d:d7:35:d8:fe:6e:97:c6:ea:
+                     f6:66:a6:70:8c:e2:2f:67:f9:a3:b0:f9:00:fa:dc:
+                     cd:bb:ab:21:1c:ae:ae:73:d6:a8:a4:e2:a6:6b:7f:
+                     8c:be:e0:90:11:22:05:63:de:ae:b7:91:d6:01:c5:
+                     f5:df:bb:c2:77
+                 Exponent: 65537 (0x10001)
+     Signature Algorithm: md5withRSAEncryption
+         95:cc:29:e3:90:4c:88:0e:6e:e1:47:a2:dd:8d:5a:79:57:e7:
+         ee:c7:eb:ad:87:76:3f:d3:ca:58:49:30:1f:79:1b:41:95:07:
+         11:67:71:94:f5:2e:32:e9:5f:49:64:89:0c:7a:44:4b:f6:f5:
+         81:5d:9e:3f:bc:58:f8:25:d9:6c
+ 
+ -----BEGIN X509 CERTIFICATE-----
+ MIIBgTCCASsCAgEOMA0GCSqGSIb3DQEBBAUAMGAxCzAJBgNVBAYTAkFVMQwwCgYD
+ VQQIEwNRTEQxGTAXBgNVBAoTEE1pbmNvbSBQdHkuIEx0ZC4xCzAJBgNVBAsTAkNT
+ MRswGQYDVQQDExJTU0xlYXkgZGVtbyBzZXJ2ZXIwHhcNOTYwMzIyMDc0ODE2WhcN
+ OTcwMzIyMDc0ODE2WjA2MRMwEQYDVQQDEwpFcmljIFlvdW5nMR8wHQYJKoZIhvcN
+ AQkBFhBlYXlAbWluY29tLm96LmF1MFwwDQYJKoZIhvcNAQEBBQADSwAwSAJBALJu
+ TE5TPdc12P5ul8bq9mamcIziL2f5o7D5APrczburIRyurnPWqKTipmt/jL7gkBEi
+ BWPerreR1gHF9d+7wncCAwEAATANBgkqhkiG9w0BAQQFAANBAJXMKeOQTIgObuFH
+ ot2NWnlX5+7H662Hdj/TylhJMB95G0GVBxFncZT1LjLpX0lkiQx6REv29YFdnj+8
+ WPgl2Ww=
+ -----END X509 CERTIFICATE-----
+ 
*** /dev/null	Fri Aug 30 04:16:48 1996
--- ./apps/demoCA/new_certs/010F.pem	Sat Jun  1 00:18:12 1996
***************
*** 0 ****
--- 1,42 ----
+ issuer :/C=AU/SP=QLD/O=Mincom Pty. Ltd./OU=CS/CN=SSLeay demo server
+ subject:/CN=Eric Young
+ serial :010F
+ 
+ Certificate:
+     Data:
+         Version: 0 (0x0)
+         Serial Number: 271 (0x10f)
+         Signature Algorithm: md5withRSAEncryption
+         Issuer: C=AU, SP=QLD, O=Mincom Pty. Ltd., OU=CS, 
+                 CN=SSLeay demo server
+         Validity
+             Not Before: Mar 22 07:51:52 1996
+             Not After : Mar 22 07:51:52 1997
+         Subject:CN=Eric Young
+         Subject Public Key Info:
+             Public Key Algorithm: rsaEncryption
+             Public Key: (512 bit)
+                 Modulus:
+                     00:c2:40:8f:3d:ff:4f:43:0e:d1:2e:97:f1:88:47:
+                     7e:0d:b7:6e:80:32:90:42:a4:d5:23:0a:e2:fb:cb:
+                     82:d4:ae:86:11:3a:b6:b1:e6:e3:e3:54:33:40:be:
+                     63:42:e8:bd:5e:f3:84:0f:5e:ac:0f:c0:85:26:e7:
+                     b0:3b:33:39:99
+                 Exponent: 65537 (0x10001)
+     Signature Algorithm: md5withRSAEncryption
+         af:02:96:c3:21:56:f5:40:bc:75:1c:dd:ec:fb:0f:a7:67:56:
+         69:4d:75:06:af:e9:20:28:37:f2:f3:03:b8:02:c0:70:f2:a1:
+         e7:f7:63:11:c4:cf:cb:e3:01:5f:13:be:48:10:e4:aa:a1:24:
+         94:59:51:81:15:ae:5b:9e:46:18
+ 
+ -----BEGIN X509 CERTIFICATE-----
+ MIIBYDCCAQoCAgEPMA0GCSqGSIb3DQEBBAUAMGAxCzAJBgNVBAYTAkFVMQwwCgYD
+ VQQIEwNRTEQxGTAXBgNVBAoTEE1pbmNvbSBQdHkuIEx0ZC4xCzAJBgNVBAsTAkNT
+ MRswGQYDVQQDExJTU0xlYXkgZGVtbyBzZXJ2ZXIwHhcNOTYwMzIyMDc1MTUyWhcN
+ OTcwMzIyMDc1MTUyWjAVMRMwEQYDVQQDEwpFcmljIFlvdW5nMFwwDQYJKoZIhvcN
+ AQEBBQADSwAwSAJBAMJAjz3/T0MO0S6X8YhHfg23boAykEKk1SMK4vvLgtSuhhE6
+ trHm4+NUM0C+Y0LovV7zhA9erA/AhSbnsDszOZkCAwEAATANBgkqhkiG9w0BAQQF
+ AANBAK8ClsMhVvVAvHUc3ez7D6dnVmlNdQav6SAoN/LzA7gCwHDyoef3YxHEz8vj
+ AV8TvkgQ5KqhJJRZUYEVrlueRhg=
+ -----END X509 CERTIFICATE-----
+ 
*** /dev/null	Fri Aug 30 04:16:48 1996
--- ./apps/demoCA/new_certs/0110.pem	Sat Jun  1 00:18:12 1996
***************
*** 0 ****
--- 1,43 ----
+ issuer :/C=AU/SP=QLD/O=Mincom Pty. Ltd./OU=CS/CN=SSLeay demo server
+ subject:/CN=Eric Youngg
+ serial :0110
+ 
+ Certificate:
+     Data:
+         Version: 2 (0x2)
+         Serial Number: 272 (0x110)
+         Signature Algorithm: md5withRSAEncryption
+         Issuer: C=AU, SP=QLD, O=Mincom Pty. Ltd., OU=CS, 
+                 CN=SSLeay demo server
+         Validity
+             Not Before: Mar 22 07:59:06 1996
+             Not After : Mar 22 07:59:06 1997
+         Subject:CN=Eric Youngg
+         Subject Public Key Info:
+             Public Key Algorithm: rsaEncryption
+             Public Key: (512 bit)
+                 Modulus:
+                     00:c2:b0:13:1c:29:e1:f0:49:e0:ad:9c:b6:f4:7d:
+                     c2:4d:62:9d:c0:55:fe:55:fd:6a:96:ff:53:42:b0:
+                     cb:d5:c5:6e:23:ac:d1:ed:51:32:c4:28:28:f2:6d:
+                     2f:69:4d:6c:76:73:b3:41:7b:d4:40:c4:0b:64:6a:
+                     1d:0d:5f:a7:75
+                 Exponent: 65537 (0x10001)
+     Signature Algorithm: md5withRSAEncryption
+         25:ba:f3:12:b4:60:8f:2d:ba:19:bd:11:50:ea:36:2e:d1:91:
+         34:4d:45:2a:25:74:36:b1:f2:45:1e:1e:15:6d:fe:b6:00:45:
+         cf:65:83:ef:ca:09:11:bd:49:c9:5a:c4:87:ea:9f:e5:8e:85:
+         06:f3:6d:24:80:f2:35:e1:42:a0
+ 
+ -----BEGIN X509 CERTIFICATE-----
+ MIIBmDCCAUKAAQICAgEQMA0GCSqGSIb3DQEBBAUAMGAxCzAJBgNVBAYTAkFVMQww
+ CgYDVQQIEwNRTEQxGTAXBgNVBAoTEE1pbmNvbSBQdHkuIEx0ZC4xCzAJBgNVBAsT
+ AkNTMRswGQYDVQQDExJTU0xlYXkgZGVtbyBzZXJ2ZXIwHhcNOTYwMzIyMDc1OTA2
+ WhcNOTcwMzIyMDc1OTA2WjAWMRQwEgYDVQQDEwtFcmljIFlvdW5nZzBcMA0GCSqG
+ SIb3DQEBAQUAA0sAMEgCQQDCsBMcKeHwSeCtnLb0fcJNYp3AVf5V/WqW/1NCsMvV
+ xW4jrNHtUTLEKCjybS9pTWx2c7NBe9RAxAtkah0NX6d1AgMBAAGjMjAwMBEGCSqG
+ SIb3DQEJBxMEdGVzdDAbBgkqhkiG9w0BCQIWDk1pbmNvbSBQdHkgTHRkMA0GCSqG
+ SIb3DQEBBAUAA0EAJbrzErRgjy26Gb0RUOo2LtGRNE1FKiV0NrHyRR4eFW3+tgBF
+ z2WD78oJEb1JyVrEh+qf5Y6FBvNtJIDyNeFCoA==
+ -----END X509 CERTIFICATE-----
+ 
*** /dev/null	Fri Aug 30 04:16:48 1996
--- ./apps/demoCA/new_certs/0111.pem	Sat Jun  1 00:18:12 1996
***************
*** 0 ****
--- 1,44 ----
+ issuer :/C=AU/SP=QLD/O=Mincom Pty. Ltd./OU=CS/CN=SSLeay demo server
+ subject:/C=AU/SP=Queensland/CN=Eric Young
+ serial :0111
+ 
+ Certificate:
+     Data:
+         Version: 2 (0x2)
+         Serial Number: 273 (0x111)
+         Signature Algorithm: md5withRSAEncryption
+         Issuer: C=AU, SP=QLD, O=Mincom Pty. Ltd., OU=CS, 
+                 CN=SSLeay demo server
+         Validity
+             Not Before: Mar 24 09:22:38 1996
+             Not After : Mar 24 09:22:38 1997
+         Subject:C=AU, SP=Queensland, CN=Eric Young
+         Subject Public Key Info:
+             Public Key Algorithm: rsaEncryption
+             Public Key: (512 bit)
+                 Modulus:
+                     00:bc:95:9e:14:63:95:7c:c6:25:70:e3:e0:36:94:
+                     d4:14:99:4a:46:30:14:c5:c5:a1:22:80:22:22:56:
+                     c7:b6:bb:07:f2:f9:c2:6a:9f:2d:27:64:a0:2c:f0:
+                     21:94:94:25:1a:a2:be:4b:b5:e8:ce:b3:7b:a2:50:
+                     39:ce:8b:f7:19
+                 Exponent: 65537 (0x10001)
+     Signature Algorithm: md5withRSAEncryption
+         12:fc:03:c5:0f:62:65:b7:63:ff:53:a6:99:a8:07:1f:4e:1b:
+         b3:2c:2a:c3:50:32:9d:f6:ce:88:d7:fb:90:0f:3b:f7:76:f9:
+         46:91:70:4c:3e:0d:6f:93:86:6e:df:52:1e:cc:c9:ec:fd:ed:
+         25:57:f3:18:46:5d:29:2c:e5:cc
+ 
+ -----BEGIN X509 CERTIFICATE-----
+ MIIBuzCCAWWgAwIBAgICAREwDQYJKoZIhvcNAQEEBQAwYDELMAkGA1UEBhMCQVUx
+ DDAKBgNVBAgTA1FMRDEZMBcGA1UEChMQTWluY29tIFB0eS4gTHRkLjELMAkGA1UE
+ CxMCQ1MxGzAZBgNVBAMTElNTTGVheSBkZW1vIHNlcnZlcjAeFw05NjAzMjQwOTIy
+ MzhaFw05NzAzMjQwOTIyMzhaMDcxCzAJBgNVBAYTAkFVMRMwEQYDVQQIEwpRdWVl
+ bnNsYW5kMRMwEQYDVQQDEwpFcmljIFlvdW5nMFwwDQYJKoZIhvcNAQEBBQADSwAw
+ SAJBALyVnhRjlXzGJXDj4DaU1BSZSkYwFMXFoSKAIiJWx7a7B/L5wmqfLSdkoCzw
+ IZSUJRqivku16M6ze6JQOc6L9xkCAwEAAaMyMDAwEQYJKoZIhvcNAQkHEwR0ZXN0
+ MBsGCSqGSIb3DQEJAhYOTWluY29tIFB0eSBMdGQwDQYJKoZIhvcNAQEEBQADQQAS
+ /APFD2Jlt2P/U6aZqAcfThuzLCrDUDKd9s6I1/uQDzv3dvlGkXBMPg1vk4Zu31Ie
+ zMns/e0lV/MYRl0pLOXM
+ -----END X509 CERTIFICATE-----
+ 
*** /dev/null	Fri Aug 30 04:16:48 1996
--- ./apps/demoCA/new_certs/0112.pem	Sat Jun  1 00:18:12 1996
***************
*** 0 ****
--- 1,43 ----
+ issuer :/C=AU/SP=QLD/O=Mincom Pty. Ltd./OU=CS/CN=SSLeay demo server
+ subject:/CN=Fred
+ serial :0112
+ 
+ Certificate:
+     Data:
+         Version: 2 (0x2)
+         Serial Number: 274 (0x112)
+         Signature Algorithm: md5withRSAEncryption
+         Issuer: C=AU, SP=QLD, O=Mincom Pty. Ltd., OU=CS, 
+                 CN=SSLeay demo server
+         Validity
+             Not Before: Mar 24 22:19:31 1996
+             Not After : Mar 24 22:19:31 1997
+         Subject:CN=Fred
+         Subject Public Key Info:
+             Public Key Algorithm: rsaEncryption
+             Public Key: (512 bit)
+                 Modulus:
+                     00:c0:47:11:bd:e2:bd:8d:c4:3e:9f:ba:8d:8c:32:
+                     00:90:16:2c:31:32:09:e3:29:10:76:c4:17:a5:fa:
+                     5e:5b:9a:b6:d9:10:54:ed:d3:59:6b:e7:5b:a4:51:
+                     9e:e0:91:7f:dd:63:72:d5:da:63:cc:18:92:bf:e6:
+                     6a:74:f7:00:f7
+                 Exponent: 65537 (0x10001)
+     Signature Algorithm: md5withRSAEncryption
+         1c:e7:4c:c2:0a:a0:94:b5:40:72:31:a4:3d:41:54:09:40:fb:
+         e6:fc:33:91:3f:2c:e0:f2:1e:0b:5c:67:63:7d:ec:e9:30:3d:
+         86:56:6f:09:e1:03:12:6a:fe:2b:32:d1:74:4e:1d:00:49:71:
+         d6:72:a1:74:e7:9d:ec:00:e9:16
+ 
+ -----BEGIN X509 CERTIFICATE-----
+ MIIBijCCATSgAwIBAgICARIwDQYJKoZIhvcNAQEEBQAwYDELMAkGA1UEBhMCQVUx
+ DDAKBgNVBAgTA1FMRDEZMBcGA1UEChMQTWluY29tIFB0eS4gTHRkLjELMAkGA1UE
+ CxMCQ1MxGzAZBgNVBAMTElNTTGVheSBkZW1vIHNlcnZlcjAeFw05NjAzMjQyMjE5
+ MzFaFw05NzAzMjQyMjE5MzFaMA8xDTALBgNVBAMTBEZyZWQwXDANBgkqhkiG9w0B
+ AQEFAANLADBIAkEAwEcRveK9jcQ+n7qNjDIAkBYsMTIJ4ykQdsQXpfpeW5q22RBU
+ 7dNZa+dbpFGe4JF/3WNy1dpjzBiSv+ZqdPcA9wIDAQABoykwJzARBgkqhkiG9w0B
+ CQcTBHRlc3QwEgYJKoZIhvcNAQkCFgVhZ2FpbjANBgkqhkiG9w0BAQQFAANBABzn
+ TMIKoJS1QHIxpD1BVAlA++b8M5E/LODyHgtcZ2N97OkwPYZWbwnhAxJq/isy0XRO
+ HQBJcdZyoXTnnewA6RY=
+ -----END X509 CERTIFICATE-----
+ 
*** /dev/null	Fri Aug 30 04:16:48 1996
--- ./apps/demoCA/new_certs/0113.pem	Sat Jun  1 00:18:12 1996
***************
*** 0 ****
--- 1,43 ----
+ issuer :/C=AU/SP=QLD/O=Mincom Pty. Ltd./OU=CS/CN=SSLeay demo server
+ subject:/C=AU/CN=eay
+ serial :0113
+ 
+ Certificate:
+     Data:
+         Version: 2 (0x2)
+         Serial Number: 275 (0x113)
+         Signature Algorithm: md5withRSAEncryption
+         Issuer: C=AU, SP=QLD, O=Mincom Pty. Ltd., OU=CS, 
+                 CN=SSLeay demo server
+         Validity
+             Not Before: Mar 24 22:49:34 1996
+             Not After : Mar 24 22:49:34 1997
+         Subject:C=AU, CN=eay
+         Subject Public Key Info:
+             Public Key Algorithm: rsaEncryption
+             Public Key: (512 bit)
+                 Modulus:
+                     00:c9:76:54:5f:50:2a:30:d4:92:ba:9e:7b:91:3b:
+                     a4:71:2b:47:c2:ec:e9:fc:af:c2:a0:11:a0:8c:43:
+                     f8:14:02:c1:cf:8c:b8:10:33:0c:db:46:38:07:ee:
+                     90:32:bb:94:5a:58:24:65:cc:1d:68:dc:18:b8:1a:
+                     06:5c:82:79:19
+                 Exponent: 65537 (0x10001)
+     Signature Algorithm: md5withRSAEncryption
+         27:a2:a5:71:f1:7c:99:1e:de:2a:f6:f5:8f:0c:31:ca:92:d4:
+         17:af:ed:b3:33:a9:09:a3:04:68:e7:14:08:51:03:2d:4f:80:
+         43:51:ac:2f:22:eb:0f:af:f7:a1:f2:d9:73:bc:8c:60:3d:07:
+         d8:69:1f:0c:b0:74:57:da:2d:ac
+ 
+ -----BEGIN X509 CERTIFICATE-----
+ MIIBlDCCAT6gAwIBAgICARMwDQYJKoZIhvcNAQEEBQAwYDELMAkGA1UEBhMCQVUx
+ DDAKBgNVBAgTA1FMRDEZMBcGA1UEChMQTWluY29tIFB0eS4gTHRkLjELMAkGA1UE
+ CxMCQ1MxGzAZBgNVBAMTElNTTGVheSBkZW1vIHNlcnZlcjAeFw05NjAzMjQyMjQ5
+ MzRaFw05NzAzMjQyMjQ5MzRaMBsxCzAJBgNVBAYTAkFVMQwwCgYDVQQDEwNlYXkw
+ XDANBgkqhkiG9w0BAQEFAANLADBIAkEAyXZUX1AqMNSSup57kTukcStHwuzp/K/C
+ oBGgjEP4FALBz4y4EDMM20Y4B+6QMruUWlgkZcwdaNwYuBoGXIJ5GQIDAQABoycw
+ EQYJKoZIhvcNAQkHEwR0ZXN0MBIGCSqGSIb3DQEJAhYFYWdhaW4wDQYJKoZIhvcN
+ AQEEBQADQQAnoqVx8XyZHt4q9vWPDDHKktQXr+2zM6kJowRo5xQIUQMtT4BDUawv
+ IusPr/eh8tlzvIxgPQfYaR8MsHRX2i2s
+ -----END X509 CERTIFICATE-----
+ 
*** /dev/null	Fri Aug 30 04:16:48 1996
--- ./apps/demoCA/new_certs/1a5f29e6	Sat Jun  1 00:18:12 1996
***************
*** 0 ****
--- 1,14 ----
+ subject=/C=AU/SOP=QLD/O=Mincom Pty. Ltd./OU=CS/CN=SSLeay demo server
+ issuer= /C=AU/SOP=QLD/O=Mincom Pty. Ltd./OU=CS/CN=CA
+ -----BEGIN X509 CERTIFICATE-----
+ 
+ MIIBgjCCASwCAQQwDQYJKoZIhvcNAQEEBQAwODELMAkGA1UEBhMCQVUxDDAKBgNV
+ BAgTA1FMRDEbMBkGA1UEAxMSU1NMZWF5L3JzYSB0ZXN0IENBMB4XDTk1MTAwOTIz
+ MzIwNVoXDTk4MDcwNTIzMzIwNVowYDELMAkGA1UEBhMCQVUxDDAKBgNVBAgTA1FM
+ RDEZMBcGA1UEChMQTWluY29tIFB0eS4gTHRkLjELMAkGA1UECxMCQ1MxGzAZBgNV
+ BAMTElNTTGVheSBkZW1vIHNlcnZlcjBcMA0GCSqGSIb3DQEBAQUAA0sAMEgCQQC3
+ LCXcScWua0PFLkHBLm2VejqpA1F4RQ8q0VjRiPafjx/Z/aWH3ipdMVvuJGa/wFXb
+ /nDFLDlfWp+oCPwhBtVPAgMBAAEwDQYJKoZIhvcNAQEEBQADQQArNFsihWIjBzb0
+ DCsU0BvL2bvSwJrPEqFlkDq3F4M6EGutL9axEcANWgbbEdAvNJD1dmEmoWny27Pn
+ IMs6ZOZB
+ -----END X509 CERTIFICATE-----
*** /dev/null	Fri Aug 30 04:16:48 1996
--- ./apps/demoCA/private/cakey.pem	Sat Jun  1 00:18:12 1996
***************
*** 0 ****
--- 1,24 ----
+ issuer= /C=AU/SOP=QLD/O=Mincom Pty. Ltd./OU=CS/CN=CA
+ subject=/C=AU/SOP=QLD/O=Mincom Pty. Ltd./OU=CS/CN=SSLeay demo server
+ -----BEGIN X509 CERTIFICATE-----
+ 
+ MIIBgjCCASwCAQQwDQYJKoZIhvcNAQEEBQAwODELMAkGA1UEBhMCQVUxDDAKBgNV
+ BAgTA1FMRDEbMBkGA1UEAxMSU1NMZWF5L3JzYSB0ZXN0IENBMB4XDTk1MTAwOTIz
+ MzIwNVoXDTk4MDcwNTIzMzIwNVowYDELMAkGA1UEBhMCQVUxDDAKBgNVBAgTA1FM
+ RDEZMBcGA1UEChMQTWluY29tIFB0eS4gTHRkLjELMAkGA1UECxMCQ1MxGzAZBgNV
+ BAMTElNTTGVheSBkZW1vIHNlcnZlcjBcMA0GCSqGSIb3DQEBAQUAA0sAMEgCQQC3
+ LCXcScWua0PFLkHBLm2VejqpA1F4RQ8q0VjRiPafjx/Z/aWH3ipdMVvuJGa/wFXb
+ /nDFLDlfWp+oCPwhBtVPAgMBAAEwDQYJKoZIhvcNAQEEBQADQQArNFsihWIjBzb0
+ DCsU0BvL2bvSwJrPEqFlkDq3F4M6EGutL9axEcANWgbbEdAvNJD1dmEmoWny27Pn
+ IMs6ZOZB
+ -----END X509 CERTIFICATE-----
+ -----BEGIN RSA PRIVATE KEY-----
+ 
+ MIIBPAIBAAJBALcsJdxJxa5rQ8UuQcEubZV6OqkDUXhFDyrRWNGI9p+PH9n9pYfe
+ Kl0xW+4kZr/AVdv+cMUsOV9an6gI/CEG1U8CAwEAAQJAXJMBZ34ZXHd1vtgL/3hZ
+ hexKbVTx/djZO4imXO/dxPGRzG2ylYZpHmG32/T1kaHpZlCHoEPgHoSzmxYXfxjG
+ sQIhAPmZ/bQOjmRUHM/VM2X5zrjjM6z18R1P6l3ObFwt9FGdAiEAu943Yh9SqMRw
+ tL0xHGxKmM/YJueUw1gB6sLkETN71NsCIQCeT3RhoqXfrpXDoEcEU+gwzjI1bpxq
+ agiNTOLfqGoA5QIhAIQFYjgzONxex7FLrsKBm16N2SFl5pXsN9SpRqqL2n63AiEA
+ g9VNIQ3xwpw7og3IbONifeku+J9qGMGQJMKwSTwrFtI=
+ -----END RSA PRIVATE KEY-----
*** /dev/null	Fri Aug 30 04:16:48 1996
--- ./apps/demoCA/serial	Thu Aug 29 23:50:28 1996
***************
*** 0 ****
--- 1 ----
+ 0114
*** /var/spool/ftp/pub/Crypto/SSL/064/SSLeay-0.6.3/./apps/dgst.c	Wed Jul 24 08:14:27 1996
--- ./apps/dgst.c	Thu Aug 29 23:50:26 1996
***************
*** 85,91 ****
  
  	apps_startup();
  
! 	if ((buf=(unsigned char *)malloc(BUFSIZE)) == NULL)
  		{
  		fprintf(stderr,"out of memory\n");
  		goto end;
--- 85,91 ----
  
  	apps_startup();
  
! 	if ((buf=(unsigned char *)Malloc(BUFSIZE)) == NULL)
  		{
  		fprintf(stderr,"out of memory\n");
  		goto end;
***************
*** 181,187 ****
  	if (buf != NULL)
  		{
  		memset(buf,0,BUFSIZE);
! 		free(buf);
  		}
  	if (in != NULL) BIO_free(in);
  	if (bmd != NULL) BIO_free(bmd);
--- 181,187 ----
  	if (buf != NULL)
  		{
  		memset(buf,0,BUFSIZE);
! 		Free(buf);
  		}
  	if (in != NULL) BIO_free(in);
  	if (bmd != NULL) BIO_free(bmd);
*** /var/spool/ftp/pub/Crypto/SSL/064/SSLeay-0.6.3/./apps/dh.c	Wed Jul 24 08:14:27 1996
--- ./apps/dh.c	Thu Aug 29 23:50:26 1996
***************
*** 240,249 ****
  		int len,l;
  
  		len=BN_num_bytes(dh->p);
! 		data=(unsigned char *)malloc(len);
  		if (data == NULL)
  			{
! 			perror("malloc");
  			goto end;
  			}
  		l=BN_bn2bin(dh->p,data);
--- 240,249 ----
  		int len,l;
  
  		len=BN_num_bytes(dh->p);
! 		data=(unsigned char *)Malloc(len);
  		if (data == NULL)
  			{
! 			perror("Malloc");
  			goto end;
  			}
  		l=BN_bn2bin(dh->p,data);
*** /var/spool/ftp/pub/Crypto/SSL/064/SSLeay-0.6.3/./apps/enc.c	Thu Jul 25 11:16:30 1996
--- ./apps/enc.c	Thu Aug 29 23:50:26 1996
***************
*** 294,305 ****
  		if (verbose) fprintf(stderr,"bufsize=%d\n",bsize);
  		}
  
! 	strbuf=malloc(SIZE);
! 	buff=(unsigned char *)malloc(EVP_ENCODE_LENGTH(bsize));
! 	buff2=(unsigned char *)malloc(EVP_ENCODE_LENGTH(bsize));
  	if ((buff == NULL) || (buff2 == NULL) || (strbuf == NULL))
  		{
! 		fprintf(stderr,"malloc failure\n");
  		goto end;
  		}
  
--- 294,305 ----
  		if (verbose) fprintf(stderr,"bufsize=%d\n",bsize);
  		}
  
! 	strbuf=Malloc(SIZE);
! 	buff=(unsigned char *)Malloc(EVP_ENCODE_LENGTH(bsize));
! 	buff2=(unsigned char *)Malloc(EVP_ENCODE_LENGTH(bsize));
  	if ((buff == NULL) || (buff2 == NULL) || (strbuf == NULL))
  		{
! 		fprintf(stderr,"Malloc failure\n");
  		goto end;
  		}
  
***************
*** 528,536 ****
  		fprintf(stderr,"bytes written:%8d\n",num_out);
  		}
  end:
! 	if (strbuf != NULL) free(strbuf);
! 	if (buff != NULL) free(buff);
! 	if (buff2 != NULL) free(buff2);
  	if (in != NULL) BIO_free(in);
  	if (out != NULL) BIO_free(out);
  	EXIT(ret);
--- 528,536 ----
  		fprintf(stderr,"bytes written:%8d\n",num_out);
  		}
  end:
! 	if (strbuf != NULL) Free(strbuf);
! 	if (buff != NULL) Free(buff);
! 	if (buff2 != NULL) Free(buff2);
  	if (in != NULL) BIO_free(in);
  	if (out != NULL) BIO_free(out);
  	EXIT(ret);
*** /var/spool/ftp/pub/Crypto/SSL/064/SSLeay-0.6.3/./apps/Makefile.ssl	Thu Aug  8 01:54:31 1996
--- ./apps/Makefile.ssl	Fri Aug 30 04:41:01 1996
***************
*** 33,39 ****
  
  E_EXE=	verify asn1pars req dgst dh enc gendh errstr ca \
  	crl rsa x509 genrsa s_server s_client s_filter speed \
! 	hashdir s_time s_mult version pkcs7 crl2pkcs7 sess_id
  
  PROGS= $(SSLEAY).c
  
--- 33,39 ----
  
  E_EXE=	verify asn1pars req dgst dh enc gendh errstr ca \
  	crl rsa x509 genrsa s_server s_client s_filter speed \
! 	hashdir s_time s_mult version pkcs7 crl2pkcs7 sess_id ciphers
  
  PROGS= $(SSLEAY).c
  
***************
*** 45,51 ****
  E_OBJ=	verify.o asn1pars.o req.o dgst.o dh.o enc.o gendh.o errstr.o ca.o \
  	pkcs7.o crl2p7.o \
  	crl.o rsa.o x509.o genrsa.o s_server.o s_client.o s_filter.o speed.o \
! 	hashdir.o s_time.o s_mult.o $(A_OBJ) $(S_OBJ) version.o sess_id.o
  
  #	pem_mail.o
  
--- 45,52 ----
  E_OBJ=	verify.o asn1pars.o req.o dgst.o dh.o enc.o gendh.o errstr.o ca.o \
  	pkcs7.o crl2p7.o \
  	crl.o rsa.o x509.o genrsa.o s_server.o s_client.o s_filter.o speed.o \
! 	hashdir.o s_time.o s_mult.o $(A_OBJ) $(S_OBJ) version.o sess_id.o \
! 	ciphers.o
  
  #	pem_mail.o
  
***************
*** 52,58 ****
  E_SRC=	verify.c asn1pars.c req.c dgst.c dh.c enc.c gendh.c errstr.c ca.c \
  	pkcs7.c crl2p7.c \
  	crl.c rsa.c x509.c genrsa.c s_server.c s_client.c s_filter.c speed.c \
! 	hashdir.c s_time.c s_mult.c $(A_SRC) $(S_SRC) version.c sess_id.c
  
  #	pem_mail.c
  
--- 53,60 ----
  E_SRC=	verify.c asn1pars.c req.c dgst.c dh.c enc.c gendh.c errstr.c ca.c \
  	pkcs7.c crl2p7.c \
  	crl.c rsa.c x509.c genrsa.c s_server.c s_client.c s_filter.c speed.c \
! 	hashdir.c s_time.c s_mult.c $(A_SRC) $(S_SRC) version.c sess_id.c \
! 	ciphers.c
  
  #	pem_mail.c
  
***************
*** 110,116 ****
  errors:
  
  clean:
! 	/bin/rm -f *.o *.obj lib tags core .nfs* *.old *.bak fluff $(EXE)
  
  $(DLIBSSL):
  	(cd ../ssl; $(MAKE))
--- 112,118 ----
  errors:
  
  clean:
! 	/bin/rm -f *.o *.obj lib tags core .pure .nfs* *.old *.bak fluff $(EXE)
  
  $(DLIBSSL):
  	(cd ../ssl; $(MAKE))
*** /var/spool/ftp/pub/Crypto/SSL/064/SSLeay-0.6.3/./apps/mklinks	Fri Aug  2 16:15:48 1996
--- ./apps/mklinks	Thu Aug 29 23:50:26 1996
***************
*** 1,5 ****
  #!/bin/sh
! for i in verify asn1parse req dgst dh enc gendh errstr ca crl rsa x509 genrsa s_server s_client s_filter speed hashdir s_time s_mult version pkcs7 crl2pkcs7 sess_id md2 md5 sha sha1 base64 des des3 desx idea rc4 rc2 des-ecb des-ede des-ede3 des-cbc des-ede-cbc des-ede3-cbc des-cfb des-ede-cfb des-ede3-cfb des-ofb des-ede-ofb des-ede3-ofb idea-cbc idea-ecb idea-cfb idea-ofb rc2-cbc rc2-ecb rc2-cfb rc2-ofb 
  do
  echo making symlink for $i
  /bin/rm -f $i
--- 1,5 ----
  #!/bin/sh
! for i in verify asn1parse req dgst dh enc gendh errstr ca crl rsa x509 genrsa s_server s_client s_filter speed hashdir s_time s_mult version pkcs7 crl2pkcs7 sess_id ciphers md2 md5 sha sha1 base64 des des3 desx idea rc4 rc2 des-ecb des-ede des-ede3 des-cbc des-ede-cbc des-ede3-cbc des-cfb des-ede-cfb des-ede3-cfb des-ofb des-ede-ofb des-ede3-ofb idea-cbc idea-ecb idea-cfb idea-ofb rc2-cbc rc2-ecb rc2-cfb rc2-ofb 
  do
  echo making symlink for $i
  /bin/rm -f $i
*** /var/spool/ftp/pub/Crypto/SSL/064/SSLeay-0.6.3/./apps/pkcs7.c	Wed Jul 24 08:14:27 1996
--- ./apps/pkcs7.c	Thu Aug 29 23:50:26 1996
***************
*** 238,250 ****
  				a=X509_NAME_oneline(X509_get_subject_name(x));
  				BIO_puts(out,"subject=");
  				BIO_puts(out,a);
! 				free(a);
  
  				a=X509_NAME_oneline(X509_get_issuer_name(x));
  				BIO_puts(out,"\nissuer= ");
  				BIO_puts(out,a);
  				BIO_puts(out,"\n");
! 				free(a);
  
  				PEM_write_bio_X509(out,x);
  				BIO_puts(out,"\n");
--- 238,250 ----
  				a=X509_NAME_oneline(X509_get_subject_name(x));
  				BIO_puts(out,"subject=");
  				BIO_puts(out,a);
! 				Free(a);
  
  				a=X509_NAME_oneline(X509_get_issuer_name(x));
  				BIO_puts(out,"\nissuer= ");
  				BIO_puts(out,a);
  				BIO_puts(out,"\n");
! 				Free(a);
  
  				PEM_write_bio_X509(out,x);
  				BIO_puts(out,"\n");
***************
*** 262,268 ****
  				a=X509_NAME_oneline(crl->crl->issuer);
  				BIO_puts(out,"issuer= ");
  				BIO_puts(out,a);
! 				free(a);
  
  				BIO_puts(out,"\nlast update=");
  				ASN1_UTCTIME_print(out,crl->crl->lastUpdate);
--- 262,268 ----
  				a=X509_NAME_oneline(crl->crl->issuer);
  				BIO_puts(out,"issuer= ");
  				BIO_puts(out,a);
! 				Free(a);
  
  				BIO_puts(out,"\nlast update=");
  				ASN1_UTCTIME_print(out,crl->crl->lastUpdate);
*** /var/spool/ftp/pub/Crypto/SSL/064/SSLeay-0.6.3/./apps/progs.h	Fri Aug  2 16:15:48 1996
--- ./apps/progs.h	Thu Aug 29 23:50:26 1996
***************
*** 23,28 ****
--- 23,29 ----
  extern int pkcs7_main(int argc,char *argv[]);
  extern int crl2pkcs7_main(int argc,char *argv[]);
  extern int sess_id_main(int argc,char *argv[]);
+ extern int ciphers_main(int argc,char *argv[]);
  #else
  extern int verify_main();
  extern int asn1parse_main();
***************
*** 48,53 ****
--- 49,55 ----
  extern int pkcs7_main();
  extern int crl2pkcs7_main();
  extern int sess_id_main();
+ extern int ciphers_main();
  #endif
  
  #define FUNC_TYPE_GENERAL	1
***************
*** 95,100 ****
--- 97,103 ----
  	{FUNC_TYPE_GENERAL,"pkcs7",pkcs7_main},
  	{FUNC_TYPE_GENERAL,"crl2pkcs7",crl2pkcs7_main},
  	{FUNC_TYPE_GENERAL,"sess_id",sess_id_main},
+ 	{FUNC_TYPE_GENERAL,"ciphers",ciphers_main},
  	{FUNC_TYPE_MD,"md2",dgst_main},
  	{FUNC_TYPE_MD,"md5",dgst_main},
  	{FUNC_TYPE_MD,"sha",dgst_main},
*** /var/spool/ftp/pub/Crypto/SSL/064/SSLeay-0.6.3/./apps/req.c	Wed Jul 24 08:14:27 1996
--- ./apps/req.c	Thu Aug 29 23:50:26 1996
***************
*** 797,806 ****
  
  	/* The public key */
  	i=i2d_RSAPublicKey(rsa,NULL);
! 	s=(unsigned char *)malloc((unsigned int)i+1);
  	if (s == NULL)
  		{
! 		fprintf(stderr,"malloc failure\n");
  		goto err;
  		}
  	p=s;
--- 797,806 ----
  
  	/* The public key */
  	i=i2d_RSAPublicKey(rsa,NULL);
! 	s=(unsigned char *)Malloc((unsigned int)i+1);
  	if (s == NULL)
  		{
! 		fprintf(stderr,"Malloc failure\n");
  		goto err;
  		}
  	p=s;
***************
*** 807,813 ****
  	i2d_RSAPublicKey(rsa,&p);
  	ri->pubkey->public_key->length=i;
  	if (ri->pubkey->public_key->data != NULL)
! 		free(ri->pubkey->public_key->data);
  	ri->pubkey->public_key->data=s;
  
  	ret=1;
--- 807,813 ----
  	i2d_RSAPublicKey(rsa,&p);
  	ri->pubkey->public_key->length=i;
  	if (ri->pubkey->public_key->data != NULL)
! 		Free(ri->pubkey->public_key->data);
  	ri->pubkey->public_key->data=s;
  
  	ret=1;
***************
*** 887,895 ****
  		}
  
  	ne->value->length=i;
! 	ne->value->data=(unsigned char *)malloc(i+1);
  	if (ne->value->data == NULL)
! 		{ fprintf(stderr,"malloc failure\n"); goto err; }
  	memcpy(ne->value->data,buf,i+1);
  	if (!sk_push(n,(char *)ne)) goto err;
  	return(1);
--- 887,895 ----
  		}
  
  	ne->value->length=i;
! 	ne->value->data=(unsigned char *)Malloc(i+1);
  	if (ne->value->data == NULL)
! 		{ fprintf(stderr,"Malloc failure\n"); goto err; }
  	memcpy(ne->value->data,buf,i+1);
  	if (!sk_push(n,(char *)ne)) goto err;
  	return(1);
***************
*** 971,979 ****
  		}
  
  	bs->length=i;
! 	bs->data=(unsigned char *)malloc(i+1);
  	if (bs->data == NULL)
! 		{ fprintf(stderr,"malloc failure\n"); goto err; }
  	memcpy(bs->data,buf,i+1);
  
  	ae->value.single->type=bs->type;
--- 971,979 ----
  		}
  
  	bs->length=i;
! 	bs->data=(unsigned char *)Malloc(i+1);
  	if (bs->data == NULL)
! 		{ fprintf(stderr,"Malloc failure\n"); goto err; }
  	memcpy(bs->data,buf,i+1);
  
  	ae->value.single->type=bs->type;
*** /var/spool/ftp/pub/Crypto/SSL/064/SSLeay-0.6.3/./apps/rmlinks	Fri Aug  2 16:15:48 1996
--- ./apps/rmlinks	Thu Aug 29 23:50:26 1996
***************
*** 1,5 ****
  #!/bin/sh
! for i in verify asn1parse req dgst dh enc gendh errstr ca crl rsa x509 genrsa s_server s_client s_filter speed hashdir s_time s_mult version pkcs7 crl2pkcs7 sess_id md2 md5 sha sha1 base64 des des3 desx idea rc4 rc2 des-ecb des-ede des-ede3 des-cbc des-ede-cbc des-ede3-cbc des-cfb des-ede-cfb des-ede3-cfb des-ofb des-ede-ofb des-ede3-ofb idea-cbc idea-ecb idea-cfb idea-ofb rc2-cbc rc2-ecb rc2-cfb rc2-ofb 
  do
  echo removing $i
  /bin/rm -f $i
--- 1,5 ----
  #!/bin/sh
! for i in verify asn1parse req dgst dh enc gendh errstr ca crl rsa x509 genrsa s_server s_client s_filter speed hashdir s_time s_mult version pkcs7 crl2pkcs7 sess_id ciphers md2 md5 sha sha1 base64 des des3 desx idea rc4 rc2 des-ecb des-ede des-ede3 des-cbc des-ede-cbc des-ede3-cbc des-cfb des-ede-cfb des-ede3-cfb des-ofb des-ede-ofb des-ede3-ofb idea-cbc idea-ecb idea-cfb idea-ofb rc2-cbc rc2-ecb rc2-cfb rc2-ofb 
  do
  echo removing $i
  /bin/rm -f $i
*** /var/spool/ftp/pub/Crypto/SSL/064/SSLeay-0.6.3/./apps/rsa.c	Tue Aug  6 15:23:14 1996
--- ./apps/rsa.c	Thu Aug 29 23:50:26 1996
***************
*** 267,281 ****
  
  		i=1;
  		size=i2d_Netscape_RSA(rsa,NULL,NULL);
! 		if ((p=(unsigned char *)malloc(size)) == NULL)
  			{
! 			fprintf(stderr,"malloc failure\n");
  			goto end;
  			}
  		pp=p;
  		i2d_Netscape_RSA(rsa,&p,NULL);
  		BIO_write(out,(char *)pp,size);
! 		free(pp);
  		}
  #endif
  	else if (outformat == FORMAT_PEM)
--- 267,281 ----
  
  		i=1;
  		size=i2d_Netscape_RSA(rsa,NULL,NULL);
! 		if ((p=(unsigned char *)Malloc(size)) == NULL)
  			{
! 			fprintf(stderr,"Malloc failure\n");
  			goto end;
  			}
  		pp=p;
  		i2d_Netscape_RSA(rsa,&p,NULL);
  		BIO_write(out,(char *)pp,size);
! 		Free(pp);
  		}
  #endif
  	else if (outformat == FORMAT_PEM)
*** /var/spool/ftp/pub/Crypto/SSL/064/SSLeay-0.6.3/./apps/sess_id.c	Wed Aug  7 09:53:00 1996
--- ./apps/sess_id.c	Thu Aug 29 23:50:26 1996
***************
*** 1,4 ****
! /* apps/sess-id.c */
  /* Copyright (C) 1995-1996 Eric Young (eay@mincom.oz.au)
   * All rights reserved.
   * 
--- 1,4 ----
! /* apps/sess_id.c */
  /* Copyright (C) 1995-1996 Eric Young (eay@mincom.oz.au)
   * All rights reserved.
   * 
*** /var/spool/ftp/pub/Crypto/SSL/064/SSLeay-0.6.3/./apps/speed.c	Wed Jul 31 16:04:40 1996
--- ./apps/speed.c	Thu Aug 29 23:50:26 1996
***************
*** 293,299 ****
  	for (i=0; i<RSA_NUM; i++)
  		rsa_key[i]=NULL;
  
! 	if ((buf=(unsigned char *)malloc(BUFSIZE)) == NULL)
  		{
  		fprintf(stderr,"out of memory\n");
  		goto end;
--- 293,299 ----
  	for (i=0; i<RSA_NUM; i++)
  		rsa_key[i]=NULL;
  
! 	if ((buf=(unsigned char *)Malloc(BUFSIZE)) == NULL)
  		{
  		fprintf(stderr,"out of memory\n");
  		goto end;
***************
*** 418,424 ****
  	RC4_set_key(&rc4_ks,16,key16);
  #endif
  #ifndef NO_RC2
! 	RC2_set_key(&rc2_ks,16,key16);
  #endif
  
  #ifndef SIGALRM
--- 418,424 ----
  	RC4_set_key(&rc4_ks,16,key16);
  #endif
  #ifndef NO_RC2
! 	RC2_set_key(&rc2_ks,16,key16,128);
  #endif
  
  #ifndef SIGALRM
***************
*** 755,761 ****
  		}
  	ret=0;
  end:
! 	if (buf != NULL) free(buf);
  	for (i=0; i<RSA_NUM; i++)
  		if (rsa_key[i] != NULL)
  			RSA_free(rsa_key[i]);
--- 755,761 ----
  		}
  	ret=0;
  end:
! 	if (buf != NULL) Free(buf);
  	for (i=0; i<RSA_NUM; i++)
  		if (rsa_key[i] != NULL)
  			RSA_free(rsa_key[i]);
*** /var/spool/ftp/pub/Crypto/SSL/064/SSLeay-0.6.3/./apps/ssleay.c	Sat Jul 27 15:27:31 1996
--- ./apps/ssleay.c	Fri Aug 30 03:42:57 1996
***************
*** 48,53 ****
--- 48,55 ----
  #include <stdio.h>
  #include <string.h>
  #include <stdlib.h>
+ #include "buffer.h"
+ #include "crypto.h"
  #include "lhash.h"
  #include "conf.h"
  #include "x509.h"
***************
*** 63,70 ****
  
  #undef DEBUG
  
  #ifndef NOPROTO
! static int chopup(char *buf, int *argc, char **argv[]);
  static unsigned long MS_CALLBACK hash(FUNCTION *a);
  static int MS_CALLBACK cmp(FUNCTION *a,FUNCTION *b);
  static LHASH *prog_init(void );
--- 65,78 ----
  
  #undef DEBUG
  
+ typedef struct args_st
+ 	{
+ 	char **data;
+ 	int count;
+ 	} ARGS;
+ 
  #ifndef NOPROTO
! static int chopup(ARGS *arg,char *buf, int *argc, char **argv[]);
  static unsigned long MS_CALLBACK hash(FUNCTION *a);
  static int MS_CALLBACK cmp(FUNCTION *a,FUNCTION *b);
  static LHASH *prog_init(void );
***************
*** 88,93 ****
--- 96,102 ----
  int Argc;
  char *Argv[];
  	{
+ 	ARGS arg;
  #define PROG_NAME_SIZE	16
  	char pname[PROG_NAME_SIZE];
  	FUNCTION f,*fp;
***************
*** 98,103 ****
--- 107,114 ----
  	LHASH *prog=NULL;
  	long errline;
   
+ 	arg.data=NULL;
+ 	arg.count=0;
  	apps_startup();
  
  	if (bio_err == NULL)
***************
*** 104,109 ****
--- 115,122 ----
  		if ((bio_err=BIO_new(BIO_s_file())) != NULL)
  			BIO_set_fp(bio_err,stderr,BIO_NOCLOSE);
  
+ 	CRYPTO_mem_ctrl(CRYPTO_MEM_CHECK_ON);
+ 
  	ERR_load_crypto_strings();
  
  	/* Lets load up our environment a little */
***************
*** 169,175 ****
  			p+=i;
  			n-=i;
  			}
! 		if (!chopup(buf,&argc,&argv)) break;
  
  #ifdef DEBUG
  		for (i=0; i<argc; i++)
--- 182,188 ----
  			p+=i;
  			n-=i;
  			}
! 		if (!chopup(&arg,buf,&argc,&argv)) break;
  
  #ifdef DEBUG
  		for (i=0; i<argc; i++)
***************
*** 194,199 ****
--- 207,221 ----
  		config=NULL;
  		}
  	if (prog != NULL) lh_free(prog);
+ 	if (arg.data != NULL) Free(arg.data);
+ 	ERR_remove_state(0);
+ 
+ 	CRYPTO_mem_leaks(bio_err);
+ 	if (bio_err != NULL)
+ 		{
+ 		BIO_free(bio_err);
+ 		bio_err=NULL;
+ 		}
  	EXIT(ret);
  	}
  
***************
*** 261,274 ****
  	return(ret);
  	}
  
! static int chopup(buf,argc,argv)
  char *buf;
  int *argc;
  char **argv[];
  	{
  	int num,len,i;
- 	static char **arg=NULL;
- 	static int argcount=0;
  	char *p;
  
  	*argc=0;
--- 283,295 ----
  	return(ret);
  	}
  
! static int chopup(arg,buf,argc,argv)
! ARGS *arg;
  char *buf;
  int *argc;
  char **argv[];
  	{
  	int num,len,i;
  	char *p;
  
  	*argc=0;
***************
*** 276,288 ****
  
  	len=strlen(buf);
  	i=0;
! 	if (argcount == 0)
  		{
! 		argcount=20;
! 		arg=(char **)malloc(sizeof(char *)*argcount);
  		}
! 	for (i=0; i<argcount; i++)
! 		arg[i]=NULL;
  
  	num=0;
  	p=buf;
--- 297,309 ----
  
  	len=strlen(buf);
  	i=0;
! 	if (arg->count == 0)
  		{
! 		arg->count=20;
! 		arg->data=(char **)Malloc(sizeof(char *)*arg->count);
  		}
! 	for (i=0; i<arg->count; i++)
! 		arg->data[i]=NULL;
  
  	num=0;
  	p=buf;
***************
*** 295,313 ****
  		if (!*p) break;
  
  		/* The start of something good :-) */
! 		if (num >= argcount)
  			{
! 			argcount+=20;
! 			arg=(char **)realloc(arg,sizeof(char *)*argcount);
  			if (argc == 0) return(0);
  			}
! 		arg[num++]=p;
  
  		/* now look for the end of this */
  		if ((*p == '\'') || (*p == '\"')) /* scan for closing quote */
  			{
  			i= *(p++);
! 			arg[num-1]++; /* jump over quote */
  			while (*p && (*p != i))
  				p++;
  			*p='\0';
--- 316,335 ----
  		if (!*p) break;
  
  		/* The start of something good :-) */
! 		if (num >= arg->count)
  			{
! 			arg->count+=20;
! 			arg->data=(char **)Realloc(arg->data,
! 				sizeof(char *)*arg->count);
  			if (argc == 0) return(0);
  			}
! 		arg->data[num++]=p;
  
  		/* now look for the end of this */
  		if ((*p == '\'') || (*p == '\"')) /* scan for closing quote */
  			{
  			i= *(p++);
! 			arg->data[num-1]++; /* jump over quote */
  			while (*p && (*p != i))
  				p++;
  			*p='\0';
***************
*** 323,329 ****
  		p++;
  		}
  	*argc=num;
! 	*argv=arg;
  	return(1);
  	}
  
--- 345,351 ----
  		p++;
  		}
  	*argc=num;
! 	*argv=arg->data;
  	return(1);
  	}
  
*** /var/spool/ftp/pub/Crypto/SSL/064/SSLeay-0.6.3/./apps/ssleay.conf	Sun Jul 28 01:37:06 1996
--- ./apps/ssleay.conf	Thu Aug 29 23:50:26 1996
***************
*** 27,32 ****
--- 27,33 ----
  default_days	= 365			# how long to certify for
  default_crl_days= 30			# how long before next CRL
  default_md	= md5			# which md to use.
+ preserve	= no			# keep passed DN ordering
  
  # A few difference way of specifying how similar the request should look
  # For type CA, the listed attributes must be the same, and the optional
*** /var/spool/ftp/pub/Crypto/SSL/064/SSLeay-0.6.3/./apps/s_apps.h	Wed Jul 17 16:45:20 1996
--- ./apps/s_apps.h	Thu Aug 29 23:50:26 1996
***************
*** 53,59 ****
  int do_server(int port, int *ret, int (*cb) ());
  #ifdef HEADER_X509_H
  int MS_CALLBACK verify_callback(int ok, X509 *xs, X509 *xi, 
! 	int depth, int error);
  #else
  int MS_CALLBACK verify_callback(int ok, char *xs, char *xi,
  	int depth, int error);
--- 53,59 ----
  int do_server(int port, int *ret, int (*cb) ());
  #ifdef HEADER_X509_H
  int MS_CALLBACK verify_callback(int ok, X509 *xs, X509 *xi, 
! 	int depth, int error, char *arg);
  #else
  int MS_CALLBACK verify_callback(int ok, char *xs, char *xi,
  	int depth, int error);
*** /var/spool/ftp/pub/Crypto/SSL/064/SSLeay-0.6.3/./apps/s_cb.c	Wed Jul 24 08:14:27 1996
--- ./apps/s_cb.c	Thu Aug 29 23:50:26 1996
***************
*** 61,72 ****
  int verify_error=VERIFY_OK;
  
  /* should be X509 * but we can just have them as char *. */
! int MS_CALLBACK verify_callback(ok, xs, xi, depth, error)
  int ok;
  X509 *xs;
  X509 *xi;
  int depth;
  int error;
  	{
  	char *s;
  
--- 61,73 ----
  int verify_error=VERIFY_OK;
  
  /* should be X509 * but we can just have them as char *. */
! int MS_CALLBACK verify_callback(ok, xs, xi, depth, error, arg)
  int ok;
  X509 *xs;
  X509 *xi;
  int depth;
  int error;
+ char *arg;
  	{
  	char *s;
  
***************
*** 77,83 ****
  		return(0);
  		}
  	fprintf(stderr,"depth=%d %s\n",depth,s);
! 	free(s);
  	if (error == VERIFY_ERR_UNABLE_TO_GET_ISSUER)
  		{
  		s=(char *)X509_NAME_oneline(X509_get_issuer_name(xs));
--- 78,84 ----
  		return(0);
  		}
  	fprintf(stderr,"depth=%d %s\n",depth,s);
! 	Free(s);
  	if (error == VERIFY_ERR_UNABLE_TO_GET_ISSUER)
  		{
  		s=(char *)X509_NAME_oneline(X509_get_issuer_name(xs));
***************
*** 88,94 ****
  			return(0);
  			}
  		fprintf(stderr,"issuer= %s\n",s);
! 		free(s);
  		}
  	if (!ok)
  		{
--- 89,95 ----
  			return(0);
  			}
  		fprintf(stderr,"issuer= %s\n",s);
! 		Free(s);
  		}
  	if (!ok)
  		{
*** /var/spool/ftp/pub/Crypto/SSL/064/SSLeay-0.6.3/./apps/s_client.c	Wed Jul 24 08:14:27 1996
--- ./apps/s_client.c	Thu Aug 29 23:50:26 1996
***************
*** 139,145 ****
  		if ((bio_c_out=BIO_new(BIO_s_file())) != NULL)
  			BIO_set_fp(bio_c_out,stdout,BIO_NOCLOSE);
  
! 	if ((buf=malloc(BUFSIZZ)) == NULL)
  		{
  		fprintf(stderr,"out of memory\n");
  		goto end;
--- 139,145 ----
  		if ((bio_c_out=BIO_new(BIO_s_file())) != NULL)
  			BIO_set_fp(bio_c_out,stdout,BIO_NOCLOSE);
  
! 	if ((buf=Malloc(BUFSIZZ)) == NULL)
  		{
  		fprintf(stderr,"out of memory\n");
  		goto end;
***************
*** 234,240 ****
  	else
  		SSL_CTX_set_cipher_list(ctx,cipher);
  
! 	SSL_CTX_set_default_verify(ctx,verify,verify_callback);
  	if (!set_cert_stuff(ctx,cert_file,key_file))
  		goto end;
  
--- 234,240 ----
  	else
  		SSL_CTX_set_cipher_list(ctx,cipher);
  
! 	SSL_CTX_set_verify(ctx,verify,verify_callback);
  	if (!set_cert_stuff(ctx,cert_file,key_file))
  		goto end;
  
***************
*** 348,357 ****
  		PEM_write_bio_X509(bio_c_out,peer);
  		str=X509_NAME_oneline(X509_get_subject_name(peer));
  		printf("subject=%s\n",str);
! 		free(str);
  		str=X509_NAME_oneline(X509_get_issuer_name(peer));
  		printf("issuer=%s\n",str);
! 		free(str);
  		X509_free(peer);
  		}
  
--- 348,357 ----
  		PEM_write_bio_X509(bio_c_out,peer);
  		str=X509_NAME_oneline(X509_get_subject_name(peer));
  		printf("subject=%s\n",str);
! 		Free(str);
  		str=X509_NAME_oneline(X509_get_issuer_name(peer));
  		printf("issuer=%s\n",str);
! 		Free(str);
  		X509_free(peer);
  		}
  
***************
*** 473,479 ****
  	if (buf != NULL)
  		{
  		memset(buf,0,BUFSIZZ);
! 		free(buf);
  		}
  	EXIT(ret);
  	}
--- 473,484 ----
  	if (buf != NULL)
  		{
  		memset(buf,0,BUFSIZZ);
! 		Free(buf);
! 		}
! 	if (bio_c_out != NULL)
! 		{
! 		BIO_free(bio_c_out);
! 		bio_c_out=NULL;
  		}
  	EXIT(ret);
  	}
*** /var/spool/ftp/pub/Crypto/SSL/064/SSLeay-0.6.3/./apps/s_eio.c	Wed Jul 24 08:14:27 1996
--- ./apps/s_eio.c	Thu Aug 29 23:50:26 1996
***************
*** 82,92 ****
  		hp=ctx->handlers;
  		if (hp == NULL)
  			{
! 			hp=(EIO_HANDLE **)malloc(i*sizeof(EIO_HANDLE *));
  			}
  		else
  			{
! 			hp=(EIO_HANDLE **)realloc(hp,i*sizeof(EIO_HANDLE *));
  			if (hp == NULL) return(0);
  			}
  		for (j=ctx->num_handlers; j<i; j++)
--- 82,92 ----
  		hp=ctx->handlers;
  		if (hp == NULL)
  			{
! 			hp=(EIO_HANDLE **)Malloc(i*sizeof(EIO_HANDLE *));
  			}
  		else
  			{
! 			hp=(EIO_HANDLE **)Realloc(hp,i*sizeof(EIO_HANDLE *));
  			if (hp == NULL) return(0);
  			}
  		for (j=ctx->num_handlers; j<i; j++)
***************
*** 166,172 ****
  	{
  	EIO_HANDLE *ret;
  
! 	ret=(EIO_HANDLE *)malloc(sizeof(EIO_HANDLE));
  	ret->ctx=NULL;
  	ret->fd=0;
  	ret->state=0;
--- 166,172 ----
  	{
  	EIO_HANDLE *ret;
  
! 	ret=(EIO_HANDLE *)Malloc(sizeof(EIO_HANDLE));
  	ret->ctx=NULL;
  	ret->fd=0;
  	ret->state=0;
***************
*** 177,186 ****
  	return(ret);
  	}
  
! void EIO_HANDLE_free(a)
  EIO_HANDLE *a;
  	{
! 	free((char *)a);
  	}
  
  void EIO_CTX_free(a,cb)
--- 177,189 ----
  	return(ret);
  	}
  
! void EIO_HANDLE_free(a,func)
  EIO_HANDLE *a;
+ void (*func)();
  	{
! 	if ((a->data != NULL) && (func != NULL))
! 		func(a->data);
! 	Free((char *)a);
  	}
  
  void EIO_CTX_free(a,cb)
***************
*** 195,207 ****
  	for (i=0; i<a->num_handlers; i++)
  		{
  		if (hpp[i] != NULL)
! 			{
! 			if (cb != NULL) cb(hpp[i]->data);
! 			EIO_HANDLE_free(hpp[i]);
  			}
  		}
- 	free((char *)a->handlers);
- 	}
  
  #ifdef WINDOWS
  
--- 198,208 ----
  	for (i=0; i<a->num_handlers; i++)
  		{
  		if (hpp[i] != NULL)
! 			EIO_HANDLE_free(hpp[i],cb);
  		}
+ 	Free((char *)a->handlers);
+ 	Free((char *)a);
  	}
  
  #ifdef WINDOWS
  
***************
*** 246,252 ****
  	{
  	EIO_CTX *ret;
  
! 	ret=(EIO_CTX *)malloc(sizeof(EIO_CTX));
  	ret->max_fd=0;
  #ifdef WINDOWS
  	if (!mesgwin_init())
--- 247,253 ----
  	{
  	EIO_CTX *ret;
  
! 	ret=(EIO_CTX *)Malloc(sizeof(EIO_CTX));
  	ret->max_fd=0;
  #ifdef WINDOWS
  	if (!mesgwin_init())
***************
*** 262,268 ****
  
  		i=GetLastError();
  		fprintf(stderr,"CreateWindow() error %ld\n",i);
! 		free(ret);
  		return(NULL);
  		}
  #else
--- 263,269 ----
  
  		i=GetLastError();
  		fprintf(stderr,"CreateWindow() error %ld\n",i);
! 		Free(ret);
  		return(NULL);
  		}
  #else
*** /var/spool/ftp/pub/Crypto/SSL/064/SSLeay-0.6.3/./apps/s_eio.h	Wed Jul 17 16:45:21 1996
--- ./apps/s_eio.h	Thu Aug 29 23:50:26 1996
***************
*** 103,109 ****
  int EIO_get_state(EIO_HANDLE *hdl);
  void EIO_set_state(EIO_HANDLE *dhl, int state);
  EIO_HANDLE *EIO_HANDLE_new(void );
! void EIO_HANDLE_free(EIO_HANDLE *a);
  EIO_CTX *EIO_CTX_new(void );
  int EIO_loop(EIO_CTX *ctx);
  void EIO_CTX_free(EIO_CTX *a,void (*cb)());
--- 103,109 ----
  int EIO_get_state(EIO_HANDLE *hdl);
  void EIO_set_state(EIO_HANDLE *dhl, int state);
  EIO_HANDLE *EIO_HANDLE_new(void );
! void EIO_HANDLE_free(EIO_HANDLE *a,void (*func)());
  EIO_CTX *EIO_CTX_new(void );
  int EIO_loop(EIO_CTX *ctx);
  void EIO_CTX_free(EIO_CTX *a,void (*cb)());
*** /var/spool/ftp/pub/Crypto/SSL/064/SSLeay-0.6.3/./apps/s_filter.c	Wed Jul 24 08:14:27 1996
--- ./apps/s_filter.c	Thu Aug 29 23:50:26 1996
***************
*** 525,531 ****
  		if (con->fork)
  			{
  			if (fork() == 0) break;
! 			free(name);
  			close(sock);
  			continue;
  			}
--- 525,531 ----
  		if (con->fork)
  			{
  			if (fork() == 0) break;
! 			Free(name);
  			close(sock);
  			continue;
  			}
*** /var/spool/ftp/pub/Crypto/SSL/064/SSLeay-0.6.3/./apps/s_mult.c	Wed Jul 24 08:14:27 1996
--- ./apps/s_mult.c	Thu Aug 29 23:50:26 1996
***************
*** 220,226 ****
  	{
  	int ret=0;
  	int asock;
! 	EIO_CTX *dctx;
  	EIO_HANDLE *ah;
  
  	if (!init_server(&asock,port))
--- 220,226 ----
  	{
  	int ret=0;
  	int asock;
! 	EIO_CTX *dctx=NULL;
  	EIO_HANDLE *ah;
  
  	if (!init_server(&asock,port))
***************
*** 229,235 ****
  	if ((dctx=EIO_CTX_new()) == NULL)
  		{
  		fprintf(stderr,"error initalising EIO_CTX\n");
! 		return(0);
  		}
  
  	if (ssl)
--- 229,235 ----
  	if ((dctx=EIO_CTX_new()) == NULL)
  		{
  		fprintf(stderr,"error initalising EIO_CTX\n");
! 		goto err;
  		}
  
  	if (ssl)
***************
*** 272,278 ****
  err:
  	SHUTDOWN(asock);
  	sock_cleanup();
! 	EIO_CTX_free(dctx,BUF_STUFF_free);
  	return(ret);
  	}
  
--- 272,278 ----
  err:
  	SHUTDOWN(asock);
  	sock_cleanup();
! 	if (dctx != NULL) EIO_CTX_free(dctx,BUF_STUFF_free);
  	return(ret);
  	}
  
***************
*** 598,604 ****
  		return(-1);
  	else if (strncmp(buf,"q",1) == 0)
  		return(-1);
! 	else if (strncmp(buf,"stats",5) == 0)
  		{
  		fprintf(stderr,"%4ld items in the session cache\n",
  			SSL_CTX_sess_number(m_ctx));
--- 598,604 ----
  		return(-1);
  	else if (strncmp(buf,"q",1) == 0)
  		return(-1);
! 	else if ((strncmp(buf,"stats",5) == 0) && (m_ctx != NULL))
  		{
  		fprintf(stderr,"%4ld items in the session cache\n",
  			SSL_CTX_sess_number(m_ctx));
***************
*** 629,639 ****
  	{
  	BUF_STUFF *ret;
  
! 	ret=(BUF_STUFF *)malloc(sizeof(BUF_STUFF));
! 	ret->buffer=(char *)malloc(bsize);
  	ret->buffer_size=bsize;
  	ret->buffer_num_written=0;
  	ret->buffer_num=0;
  	ret->references=1;
  	return(ret);
  	}
--- 629,640 ----
  	{
  	BUF_STUFF *ret;
  
! 	ret=(BUF_STUFF *)Malloc(sizeof(BUF_STUFF));
! 	ret->buffer=(char *)Malloc(bsize);
  	ret->buffer_size=bsize;
  	ret->buffer_num_written=0;
  	ret->buffer_num=0;
+ 	ret->data=NULL;
  	ret->references=1;
  	return(ret);
  	}
***************
*** 643,652 ****
  	{
  	if (a == NULL) return;
  	if (--a->references > 0) return;
! 	if (a->data != NULL) SSL_free((SSL *)a->data);
! 	free(a->buffer);
! 	free(a);
  	}
  
  void fd_shutdown(dh)
  EIO_HANDLE *dh;
--- 644,657 ----
  	{
  	if (a == NULL) return;
  	if (--a->references > 0) return;
! 	if (a->data != NULL)
! 		{
! 		SSL_free((SSL *)a->data);
! 		a->data=NULL;
  		}
+ 	Free(a->buffer);
+ 	Free(a);
+ 	}
  
  void fd_shutdown(dh)
  EIO_HANDLE *dh;
***************
*** 654,658 ****
  	SHUTDOWN(dh->fd);
  	EIO_set_state(dh,EIO_EVENT_NOTHING);
  	EIO_remove(dh);
! 	EIO_HANDLE_free(dh);
  	}
--- 659,663 ----
  	SHUTDOWN(dh->fd);
  	EIO_set_state(dh,EIO_EVENT_NOTHING);
  	EIO_remove(dh);
! 	EIO_HANDLE_free(dh,(void (*)())BUF_STUFF_free);
  	}
*** /var/spool/ftp/pub/Crypto/SSL/064/SSLeay-0.6.3/./apps/s_server.c	Fri Aug  2 17:29:31 1996
--- ./apps/s_server.c	Thu Aug 29 23:50:26 1996
***************
*** 232,238 ****
  
  	if (cipher != NULL)
  		SSL_CTX_set_cipher_list(ctx,cipher);
! 	SSL_CTX_set_default_verify(ctx,verify,verify_callback);
  	if (!set_cert_stuff(ctx,s_cert_file,s_key_file))
  		goto end;
  	fprintf(stderr,"ACCEPT\n");
--- 232,238 ----
  
  	if (cipher != NULL)
  		SSL_CTX_set_cipher_list(ctx,cipher);
! 	SSL_CTX_set_verify(ctx,verify,verify_callback);
  	if (!set_cert_stuff(ctx,s_cert_file,s_key_file))
  		goto end;
  	fprintf(stderr,"ACCEPT\n");
***************
*** 241,246 ****
--- 241,247 ----
  	ret=0;
  end:
  	if (ctx != NULL) SSL_CTX_free(ctx);
+ 	if (bio_s_out != NULL) BIO_free(bio_s_out);
  	EXIT(ret);
  	}
  
***************
*** 271,280 ****
  	fd_set readfds;
  	int ret=1,width;
  	int k,i;
! 	static SSL *con=NULL;
  	unsigned long l=1;
  
! 	if ((buf=malloc(BUFSIZZ)) == NULL)
  		{
  		fprintf(stderr,"out of memory\n");
  		goto err;
--- 272,281 ----
  	fd_set readfds;
  	int ret=1,width;
  	int k,i;
! 	SSL *con=NULL;
  	unsigned long l=1;
  
! 	if ((buf=Malloc(BUFSIZZ)) == NULL)
  		{
  		fprintf(stderr,"out of memory\n");
  		goto err;
***************
*** 312,318 ****
  			if ((i <= 0) || (buf[0] == 'Q'))
  				{
  				fprintf(stderr,"DONE\n");
! 				shutdown(s,2);
  				close_accept_socket();
  				ret= -11;
  				goto err;
--- 313,319 ----
  			if ((i <= 0) || (buf[0] == 'Q'))
  				{
  				fprintf(stderr,"DONE\n");
! 				SHUTDOWN(s);
  				close_accept_socket();
  				ret= -11;
  				goto err;
***************
*** 389,400 ****
  			}
  		}
  err:
! /*	if (con != NULL) SSL_free(con);  */
  	fprintf(stderr,"CONNECTION CLOSED\n");
  	if (buf != NULL)
  		{
  		memset(buf,0,BUFSIZZ);
! 		free(buf);
  		}
  	if (ret >= 0)
  		fprintf(stderr,"ACCEPT\n");
--- 390,401 ----
  			}
  		}
  err:
! 	if (con != NULL) SSL_free(con);
  	fprintf(stderr,"CONNECTION CLOSED\n");
  	if (buf != NULL)
  		{
  		memset(buf,0,BUFSIZZ);
! 		Free(buf);
  		}
  	if (ret >= 0)
  		fprintf(stderr,"ACCEPT\n");
***************
*** 405,412 ****
  	{
  	fprintf(stderr,"shutdown\n");
  	if (accept_socket >= 0)
! 		shutdown(accept_socket,2);
  	}
  
  static int init_ssl_connection(con)
  SSL *con;
--- 406,415 ----
  	{
  	fprintf(stderr,"shutdown\n");
  	if (accept_socket >= 0)
! 		{
! 		SHUTDOWN(accept_socket);
  		}
+ 	}
  
  static int init_ssl_connection(con)
  SSL *con;
***************
*** 415,420 ****
--- 418,424 ----
  	char *str;
  	X509 *peer;
  	int verify_error;
+ 	MS_STATIC char buf[256];
  
  	if ((i=SSL_accept(con)) <= 0)
  		{
***************
*** 445,456 ****
  		PEM_write_bio_X509(bio_s_out,peer);
  		str=X509_NAME_oneline(X509_get_subject_name(peer));
  		printf("subject=%s\n",str);
! 		free(str);
  		str=X509_NAME_oneline(X509_get_issuer_name(peer));
  		printf("issuer=%s\n",str);
! 		free(str);
  		X509_free(peer);
  		}
  	printf("CIPHER is %s\n",SSL_get_cipher(con));
  	return(1);
  	}
--- 449,464 ----
  		PEM_write_bio_X509(bio_s_out,peer);
  		str=X509_NAME_oneline(X509_get_subject_name(peer));
  		printf("subject=%s\n",str);
! 		Free(str);
  		str=X509_NAME_oneline(X509_get_issuer_name(peer));
  		printf("issuer=%s\n",str);
! 		Free(str);
  		X509_free(peer);
  		}
+ 
+ 	if (SSL_get_shared_ciphers(con,buf,BUFSIZ) != NULL)
+ 		printf("Shared ciphers:%s\n",buf);
  	printf("CIPHER is %s\n",SSL_get_cipher(con));
+ 	if (con->hit) printf("Reused session-id\n");
  	return(1);
  	}
*** /var/spool/ftp/pub/Crypto/SSL/064/SSLeay-0.6.3/./apps/s_socket.c	Wed Jul 24 08:14:27 1996
--- ./apps/s_socket.c	Thu Aug 29 23:50:26 1996
***************
*** 175,182 ****
  			return(0);
  			}
  		i=(*cb)(name,sock);
! 		if (name != NULL) free(name);
! 		close(sock);
  		if (i < 0)
  			{
  			SHUTDOWN(accept_socket);
--- 175,182 ----
  			return(0);
  			}
  		i=(*cb)(name,sock);
! 		if (name != NULL) Free(name);
! 		SHUTDOWN(sock);
  		if (i < 0)
  			{
  			SHUTDOWN(accept_socket);
***************
*** 314,322 ****
  		}
  	else
  		{
! 		if ((*host=(char *)malloc(strlen(h1->h_name)+1)) == NULL)
  			{
! 			perror("malloc");
  			return(0);
  			}
  		strcpy(*host,h1->h_name);
--- 314,322 ----
  		}
  	else
  		{
! 		if ((*host=(char *)Malloc(strlen(h1->h_name)+1)) == NULL)
  			{
! 			perror("Malloc");
  			return(0);
  			}
  		strcpy(*host,h1->h_name);
*** /var/spool/ftp/pub/Crypto/SSL/064/SSLeay-0.6.3/./apps/s_test.c	Wed Jul 24 08:14:27 1996
--- ./apps/s_test.c	Thu Aug 29 23:50:26 1996
***************
*** 145,151 ****
  	b.buffer_num_written=0;
  	b.buffer_num=0;
  	b.buffer_size=102400;
! 	b.buffer=(char *)malloc(102400);
  
  	ctx=EIO_CTX_new();
  
--- 145,151 ----
  	b.buffer_num_written=0;
  	b.buffer_num=0;
  	b.buffer_size=102400;
! 	b.buffer=(char *)Malloc(102400);
  
  	ctx=EIO_CTX_new();
  
*** /var/spool/ftp/pub/Crypto/SSL/064/SSLeay-0.6.3/./apps/s_time.c	Fri Aug  2 17:29:47 1996
--- ./apps/s_time.c	Thu Aug 29 23:50:26 1996
***************
*** 342,367 ****
  MAIN(argc,argv)
  int argc;
  char **argv;
! {
  	double totalTime = 0.0;
  	int nConn = 0;
! 	SSL *scon, *savecon;
  	long finishtime=0;
  
  	if ((ctx=SSL_CTX_new()) == NULL) return(1);
  
  	/* parse the command line arguments */
! 	if( parseArgs( argc, argv ) < 0 ) {
! 		return 1;
! 	}
  
  	SSL_load_error_strings();
  
  	if ((!SSL_load_verify_locations(ctx,CAfile,CApath)) ||
! 		(!SSL_set_default_verify_paths(ctx))) {
  		fprintf(stderr,"error seting default verify locations\n");
  		ERR_print_errors(bio_err);
! 		EXIT(1);
  	}
  
  	if (cipher == NULL)
--- 342,368 ----
  MAIN(argc,argv)
  int argc;
  char **argv;
! 	{
  	double totalTime = 0.0;
  	int nConn = 0;
! 	SSL *scon, *savecon=NULL;
  	long finishtime=0;
+ 	int ret=1;
  
  	if ((ctx=SSL_CTX_new()) == NULL) return(1);
  
  	/* parse the command line arguments */
! 	if( parseArgs( argc, argv ) < 0 )
! 		goto end;
  
  	SSL_load_error_strings();
  
  	if ((!SSL_load_verify_locations(ctx,CAfile,CApath)) ||
! 		(!SSL_set_default_verify_paths(ctx)))
! 		{
  		fprintf(stderr,"error seting default verify locations\n");
  		ERR_print_errors(bio_err);
! 		goto end;
  		}
  
  	if (cipher == NULL)
***************
*** 382,400 ****
  		if (finishtime < time(NULL)) break;
  #ifdef WIN32_STUFF
  
! 		if( flushWinMsgs(0) == -1 ) {
! 			EXIT(1);
! 		}
  
  		if( waitingToDie || exitNow )		/* we're dead */
! 			EXIT(0);
  #endif
  
  		Time_F(START);
  		
! 		if( (scon = doConnection( NULL )) == NULL ) {
! 			EXIT(1);
! 		}
  
  		SHUTDOWN(SSL_get_fd(scon));
  		SSL_free( scon );
--- 383,399 ----
  		if (finishtime < time(NULL)) break;
  #ifdef WIN32_STUFF
  
! 		if( flushWinMsgs(0) == -1 )
! 			goto end;
  
  		if( waitingToDie || exitNow )		/* we're dead */
! 			goto end;
  #endif
  
  		Time_F(START);
  		
! 		if( (scon = doConnection( NULL )) == NULL )
! 			goto end;
  
  		SHUTDOWN(SSL_get_fd(scon));
  		SSL_free( scon );
***************
*** 414,422 ****
  	printf( "\n\nNow timing with session id reuse.\n" );
  
  	/* Get an SSL object so we can reuse the session id */
! 	if( (savecon = doConnection( NULL )) == NULL ) {
  		fprintf( stderr, "Unable to get connection\n" );
! 		EXIT(1);
  	}
  	nConn = 0;
  	totalTime = 0.0;
--- 413,422 ----
  	printf( "\n\nNow timing with session id reuse.\n" );
  
  	/* Get an SSL object so we can reuse the session id */
! 	if( (savecon = doConnection( NULL )) == NULL )
! 		{
  		fprintf( stderr, "Unable to get connection\n" );
! 		goto end;
  		}
  	nConn = 0;
  	totalTime = 0.0;
***************
*** 428,449 ****
  		if (finishtime < time(NULL)) break;
  
  #ifdef WIN32_STUFF
! 		if( flushWinMsgs(0) == -1 ) {
! 			EXIT(1);
! 		}
  
  		if( waitingToDie || exitNow )	/* we're dead */
! 			EXIT(0);
  #endif
  
  		Time_F(START);
  		
! 	 	if( (scon = doConnection( savecon )) == NULL ) {
! 			EXIT(1);
! 		}
  
  		SHUTDOWN(SSL_get_fd(scon));
  		SSL_free( scon );
  
  	
  		totalTime += Time_F(STOP); /* Add the time for this iteration*/
--- 428,448 ----
  		if (finishtime < time(NULL)) break;
  
  #ifdef WIN32_STUFF
! 		if( flushWinMsgs(0) == -1 )
! 			goto end;
  
  		if( waitingToDie || exitNow )	/* we're dead */
! 			goto end;
  #endif
  
  		Time_F(START);
  		
! 	 	if( (scon = doConnection( savecon )) == NULL )
! 			goto end;
  
  		SHUTDOWN(SSL_get_fd(scon));
  		SSL_free( scon );
+ 		scon=NULL;
  
  	
  		totalTime += Time_F(STOP); /* Add the time for this iteration*/
***************
*** 451,457 ****
  		fputc( '#', stdout ); fflush(stdout);
  	}
  
- 	SSL_free( savecon );
  
  	printf( "\n\n%d connections in %.2fs; %.2f connections/sec\n",
  			nConn, totalTime, ((double)nConn/totalTime) );
--- 450,455 ----
***************
*** 458,465 ****
  	printf( "%d connections in %ld real seconds\n",nConn,
  		time(NULL)-finishtime+SECONDS);
  
! 	EXIT(0);
! }
  
  /***********************************************************************
   * doConnection - make a connection
--- 456,472 ----
  	printf( "%d connections in %ld real seconds\n",nConn,
  		time(NULL)-finishtime+SECONDS);
  
! 	ret=0;
! end:
! 	if (savecon != NULL) SSL_free(savecon);
! 
! 	if (ctx != NULL)
! 		{
! 		SSL_CTX_free(ctx);
! 		ctx=NULL;
! 		}
! 	EXIT(ret);
! 	}
  
  /***********************************************************************
   * doConnection - make a connection
*** /var/spool/ftp/pub/Crypto/SSL/064/SSLeay-0.6.3/./apps/verify.c	Wed Jul 24 08:14:27 1996
--- ./apps/verify.c	Thu Aug 29 23:50:26 1996
***************
*** 58,64 ****
  #define PROG	verify_main
  
  #ifndef NOPROTO
! static int MS_CALLBACK cb(int ok, X509 *xs, X509 *xi, int depth, int error);
  static int check(CERTIFICATE_CTX *ctx,char *file);
  #else
  static int MS_CALLBACK cb();
--- 58,65 ----
  #define PROG	verify_main
  
  #ifndef NOPROTO
! static int MS_CALLBACK cb(int ok, X509 *xs, X509 *xi, int depth, int error,
! 	char *arg);
  static int check(CERTIFICATE_CTX *ctx,char *file);
  #else
  static int MS_CALLBACK cb();
***************
*** 170,176 ****
  		goto end;
  		}
  	fprintf(stdout,"%s: ",(file == NULL)?"stdin":file);
! 	i=X509_cert_verify(ctx,x,cb,NULL);
  	ret=0;
  end:
  	if (i)
--- 171,177 ----
  		goto end;
  		}
  	fprintf(stdout,"%s: ",(file == NULL)?"stdin":file);
! 	i=X509_cert_verify(ctx,x,cb,NULL,NULL);
  	ret=0;
  end:
  	if (i)
***************
*** 186,197 ****
  	return(ret);
  	}
  
! static int MS_CALLBACK cb(ok, xs, xi, depth, error)
  int ok;
  X509 *xs;
  X509 *xi;
  int depth;
  int error;
  	{
  	if (!ok)
  		{
--- 187,199 ----
  	return(ret);
  	}
  
! static int MS_CALLBACK cb(ok, xs, xi, depth, error, arg)
  int ok;
  X509 *xs;
  X509 *xi;
  int depth;
  int error;
+ char *arg;
  	{
  	if (!ok)
  		{
***************
*** 204,210 ****
  			{
  			s=X509_NAME_oneline(X509_get_subject_name(xs));
  			printf("%s\n",s);
! 			free(s);
  			printf("error %d at %d depth lookup:%s\n",error,depth,
  				X509_cert_verify_error_string(error));
  			}
--- 206,212 ----
  			{
  			s=X509_NAME_oneline(X509_get_subject_name(xs));
  			printf("%s\n",s);
! 			Free(s);
  			printf("error %d at %d depth lookup:%s\n",error,depth,
  				X509_cert_verify_error_string(error));
  			}
*** /var/spool/ftp/pub/Crypto/SSL/064/SSLeay-0.6.3/./apps/x509.c	Tue Aug  6 12:50:46 1996
--- ./apps/x509.c	Thu Aug 29 23:50:26 1996
***************
*** 368,374 ****
  		
  		c=X509_NAME_oneline(req->req_info->subject);
  		fprintf(stderr,"subject=%s\n",c);
! 		free(c);
  		if ((x=X509_new()) == NULL) goto end;
  		ci=x->cert_info;
  
--- 368,374 ----
  		
  		c=X509_NAME_oneline(req->req_info->subject);
  		fprintf(stderr,"subject=%s\n",c);
! 		Free(c);
  		if ((x=X509_new()) == NULL) goto end;
  		ci=x->cert_info;
  
***************
*** 433,439 ****
  					goto end;
  					}
  				fprintf(stdout,"issuer= %s\n",str);
! 				free(str);
  				}
  
  			if (subject == i) 
--- 433,439 ----
  					goto end;
  					}
  				fprintf(stdout,"issuer= %s\n",str);
! 				Free(str);
  				}
  
  			if (subject == i) 
***************
*** 446,452 ****
  					goto end;
  					}
  				fprintf(stdout,"subject=%s\n",str);
! 				free(str);
  				}
  			if (serial == i)
  				{
--- 446,452 ----
  					goto end;
  					}
  				fprintf(stdout,"subject=%s\n",str);
! 				Free(str);
  				}
  			if (serial == i)
  				{
***************
*** 508,514 ****
  				unsigned char md[MD5_DIGEST_LENGTH];
  
  				n=i2d_X509(x,NULL);
! 				p=(unsigned char *)malloc(n);
  				if (p == NULL)
  					{
  					fprintf(stderr,"out of memory\n");
--- 508,514 ----
  				unsigned char md[MD5_DIGEST_LENGTH];
  
  				n=i2d_X509(x,NULL);
! 				p=(unsigned char *)Malloc(n);
  				if (p == NULL)
  					{
  					fprintf(stderr,"out of memory\n");
***************
*** 657,663 ****
  	BIGNUM *serial=NULL;
  	ASN1_INTEGER *bs=NULL,bs2;
  
! 	buf=(char *)malloc(EVP_PKEY_size(pkey)*2+
  		((serialfile == NULL)
  			?(strlen(CAfile)+strlen(POSTFIX)+1)
  			:(strlen(serialfile)))+1);
--- 657,663 ----
  	BIGNUM *serial=NULL;
  	ASN1_INTEGER *bs=NULL,bs2;
  
! 	buf=(char *)Malloc(EVP_PKEY_size(pkey)*2+
  		((serialfile == NULL)
  			?(strlen(CAfile)+strlen(POSTFIX)+1)
  			:(strlen(serialfile)))+1);
***************
*** 739,752 ****
  
  	/* NOTE: this certificate can/should be self signed, unless it was
  	 * a certificate request in which case it is not. */
! 	if (!reqfile && !X509_cert_verify(ctx,x,callb,NULL))
  		goto end;
  
  	X509_NAME_free(x->cert_info->issuer);
  	x->cert_info->issuer=X509_NAME_dup(xca->cert_info->subject);
  	if (x->cert_info->validity->notBefore != NULL)
! 		free(x->cert_info->validity->notBefore);
! 	if ((x->cert_info->validity->notBefore=(char *)malloc(100)) == NULL)
  		goto end;
  	ASN1_INTEGER_free(x->cert_info->serialNumber);
  	x->cert_info->serialNumber=bs;
--- 739,752 ----
  
  	/* NOTE: this certificate can/should be self signed, unless it was
  	 * a certificate request in which case it is not. */
! 	if (!reqfile && !X509_cert_verify(ctx,x,callb,NULL,NULL))
  		goto end;
  
  	X509_NAME_free(x->cert_info->issuer);
  	x->cert_info->issuer=X509_NAME_dup(xca->cert_info->subject);
  	if (x->cert_info->validity->notBefore != NULL)
! 		Free(x->cert_info->validity->notBefore);
! 	if ((x->cert_info->validity->notBefore=(char *)Malloc(100)) == NULL)
  		goto end;
  	ASN1_INTEGER_free(x->cert_info->serialNumber);
  	x->cert_info->serialNumber=bs;
***************
*** 768,774 ****
  		}
  	ret=1;
  end:
! 	if (buf != NULL) free(buf);
  	if (bs != NULL) ASN1_INTEGER_free(bs);
  	if (io != NULL)	BIO_free(io);
  	if (serial != NULL) BN_free(serial);
--- 768,774 ----
  		}
  	ret=1;
  end:
! 	if (buf != NULL) Free(buf);
  	if (bs != NULL) ASN1_INTEGER_free(bs);
  	if (io != NULL)	BIO_free(io);
  	if (serial != NULL) BN_free(serial);
***************
*** 795,801 ****
  
  		s=X509_NAME_oneline(X509_get_subject_name(xs));
  		printf("%s\n",s);
! 		free(s);
  		printf("error with certificate - error %d at depth %d\n%s\n",
  			error,depth,X509_cert_verify_error_string(error));
  		}
--- 795,801 ----
  
  		s=X509_NAME_oneline(X509_get_subject_name(xs));
  		printf("%s\n",s);
! 		Free(s);
  		printf("error with certificate - error %d at depth %d\n%s\n",
  			error,depth,X509_cert_verify_error_string(error));
  		}
***************
*** 950,957 ****
  
  	j=i2d_PublicKey(pkey,NULL);
  	if (x->cert_info->key->public_key->data != NULL)
! 		free(x->cert_info->key->public_key->data);
! 	p=x->cert_info->key->public_key->data=(unsigned char *)malloc(
  		(unsigned int)j+10);
  	if (p == NULL) { fprintf(stderr,"out of memory\n"); return(0); }
  	x->cert_info->key->public_key->length=j;
--- 950,957 ----
  
  	j=i2d_PublicKey(pkey,NULL);
  	if (x->cert_info->key->public_key->data != NULL)
! 		Free(x->cert_info->key->public_key->data);
! 	p=x->cert_info->key->public_key->data=(unsigned char *)Malloc(
  		(unsigned int)j+10);
  	if (p == NULL) { fprintf(stderr,"out of memory\n"); return(0); }
  	x->cert_info->key->public_key->length=j;
Binary files /var/spool/ftp/pub/Crypto/SSL/064/SSLeay-0.6.3/./test/.rand and ./test/.rand differ
*** /var/spool/ftp/pub/Crypto/SSL/064/SSLeay-0.6.3/./test/certCA.ss.srl	Thu Aug  8 01:21:49 1996
--- ./test/certCA.ss.srl	Fri Aug 30 04:17:20 1996
***************
*** 1 ****
! 92
--- 1 ----
! 9F
*** /var/spool/ftp/pub/Crypto/SSL/064/SSLeay-0.6.3/./test/Makefile.ssl	Thu Aug  8 01:54:31 1996
--- ./test/Makefile.ssl	Fri Aug 30 04:41:02 1996
***************
*** 75,92 ****
  tags:
  	ctags $(SRC)
  
! tests:	exe
  	@(cd ../apps; $(MAKE)  CC='${CC}' CFLAG='${CFLAG}' INSTALLTOP='${INSTALLTOP}' PEX_LIBS='${PEX_LIBS}' EX_LIBS='${EX_LIBS}' all)
  	./$(DESTEST)
  	./$(IDEATEST)
  	./$(SHATEST)
  	./$(SHA1TEST)
  	./$(MD5TEST)
  	./$(MD2TEST)
  	./$(RC2TEST)
  	./$(RC4TEST)
  	./$(RANDTEST)
  	@sh ./testenc
  	@echo test normal x509v1 certificate
  	@sh ./tx509 2>/dev/null
  	@echo test first x509v3 certificate
--- 75,117 ----
  tags:
  	ctags $(SRC)
  
! tests:	exe apps \
! 	test_des test_idea test_sha test_md5 test_md2 test_rc2 test_rc4 \
! 	test_rand test_enc test_x509 test_rsa test_crl test_sid test_req \
! 	test_pkcs7 test_bn test_verify test_dh test_reqgen test_ss test_ssl
! 
! apps:
  	@(cd ../apps; $(MAKE)  CC='${CC}' CFLAG='${CFLAG}' INSTALLTOP='${INSTALLTOP}' PEX_LIBS='${PEX_LIBS}' EX_LIBS='${EX_LIBS}' all)
+ 
+ test_des:
  	./$(DESTEST)
+ 
+ test_idea:
  	./$(IDEATEST)
+ 
+ test_sha:
  	./$(SHATEST)
  	./$(SHA1TEST)
+ 
+ test_md5:
  	./$(MD5TEST)
+ 
+ test_md2:
  	./$(MD2TEST)
+ 
+ test_rc2:
  	./$(RC2TEST)
+ 
+ test_rc4:
  	./$(RC4TEST)
+ 
+ test_rand:
  	./$(RANDTEST)
+ 
+ test_enc:
  	@sh ./testenc
+ 
+ test_x509:
  	@echo test normal x509v1 certificate
  	@sh ./tx509 2>/dev/null
  	@echo test first x509v3 certificate
***************
*** 93,119 ****
  	@sh ./tx509 v3-cert1.pem 2>/dev/null
  	@echo test second x509v3 certificate
  	@sh ./tx509 v3-cert2.pem 2>/dev/null
  	@sh ./trsa 2>/dev/null
  	@sh ./tcrl 2>/dev/null
  	@sh ./tsid 2>/dev/null
  	@sh ./treq 2>/dev/null
  	@sh ./tpkcs7 2>/dev/null
  	@sh ./tpkcs7d 2>/dev/null
  	@echo starting big number library test, could take a while...
  	@(./$(BNTEST)|bc) | awk '{ \
  if ($$0 != "0") {print "error"; exit(1); } \
  if (((NR+1)%64) == 0) print NR+1," tests done"; }'
  	@echo "The following command should have some OK's and some failures"
  	../apps/ssleay verify -CApath ../certs ../certs/*.pem
  	@echo "Generate as set or DH parameters"
  	./$(DHTEST)
  	@sh ./testgen
  	@echo "Generate and certify a test certificate"
  	./$(SSLTEST)
  	./$(SSLTEST) -server_auth -CApath ../certs
  	./$(SSLTEST) -client_auth -CApath ../certs
  	./$(SSLTEST) -server_auth -client_auth -CApath ../certs
- 	@sh ./testss
  
  lint:
  	lint -DLINT $(INCLUDES) $(SRC)>fluff
--- 118,167 ----
  	@sh ./tx509 v3-cert1.pem 2>/dev/null
  	@echo test second x509v3 certificate
  	@sh ./tx509 v3-cert2.pem 2>/dev/null
+ 
+ test_rsa:
  	@sh ./trsa 2>/dev/null
+ 
+ test_crl:
  	@sh ./tcrl 2>/dev/null
+ 
+ test_sid:
  	@sh ./tsid 2>/dev/null
+ 
+ test_req:
  	@sh ./treq 2>/dev/null
+ 
+ test_pkcs7:
  	@sh ./tpkcs7 2>/dev/null
  	@sh ./tpkcs7d 2>/dev/null
+ 
+ test_bn:
  	@echo starting big number library test, could take a while...
  	@(./$(BNTEST)|bc) | awk '{ \
  if ($$0 != "0") {print "error"; exit(1); } \
  if (((NR+1)%64) == 0) print NR+1," tests done"; }'
+ 
+ test_verify:
  	@echo "The following command should have some OK's and some failures"
  	../apps/ssleay verify -CApath ../certs ../certs/*.pem
+ 
+ test_dh:
  	@echo "Generate as set or DH parameters"
  	./$(DHTEST)
+ 
+ test_reqgen:
+ 	@echo "Generate and verify a certificate request"
  	@sh ./testgen
+ 
+ test_ss:
  	@echo "Generate and certify a test certificate"
+ 	@sh ./testss
+ 
+ test_ssl:
  	./$(SSLTEST)
  	./$(SSLTEST) -server_auth -CApath ../certs
  	./$(SSLTEST) -client_auth -CApath ../certs
  	./$(SSLTEST) -server_auth -client_auth -CApath ../certs
  
  lint:
  	lint -DLINT $(INCLUDES) $(SRC)>fluff
***************
*** 126,132 ****
  	mv -f Makefile.new $(MAKEFILE)
  
  clean:
! 	/bin/rm -f *.o *.obj lib tags core .nfs* *.old *.bak fluff $(EXE) *.ss
  
  $(DLIBCRYPTO):
  
--- 174,180 ----
  	mv -f Makefile.new $(MAKEFILE)
  
  clean:
! 	/bin/rm -f *.o *.obj lib tags core .pure .nfs* *.old *.bak fluff $(EXE) *.ss
  
  $(DLIBCRYPTO):
  
*** /var/spool/ftp/pub/Crypto/SSL/064/SSLeay-0.6.3/./test/testkey.pem	Thu Aug  8 01:21:35 1996
--- ./test/testkey.pem	Fri Aug 30 04:17:18 1996
***************
*** 1,9 ****
  -----BEGIN RSA PRIVATE KEY-----
! MIIBOgIBAAJBANZ3kLk7SMhlh8C0tBnZomUf67ZDspuoPL1xlm3ZuBeLb6LW6Szm
! Bk0pGWBpOvLQJVGb+y6OVlR7D/uH5l2TQ4cCAwEAAQJAK2LgyjguDyxK/DcSQDCA
! 48hDXQnw9gBg2UpDTlG/JjPWCVF05r/FfdLs6D1DDSZj5pIBGmQwMrUA+bH+3Shg
! oQIhAPraAcWwqFLwRZGZ//rBGI4NrS6MEKNuJh2nzo1QC6j5AiEA2t5kLRjm68DT
! GoBuhDtEQbUf466hfIvxKc7R79Wp8H8CIFhXflhIpn7O7zEfsu50Ilmkp2DFIvbr
! S7EV78AEeJbBAiEAkZnMrquYQ1Gdnk2+N71tpQCnXEH6L+6w2o054AEV8mUCIBa2
! VICXo9M0Mn1Ej52ddg2dsJ3fcODAJyVqm9Rdfg11
  -----END RSA PRIVATE KEY-----
--- 1,9 ----
  -----BEGIN RSA PRIVATE KEY-----
! MIIBOwIBAAJBAL2cIBKfOa1KEqFR1RoT+n6KTZGJCGQcLNXJCCFCJ3CBxhhFX/jP
! nxzo0HWm9/on0liAjrrNs4bQXHOhx7ySAqsCAwEAAQJAbc90l7RVT/HdNkZRV4gI
! g66PW+Dz1h6nLKz/o1tPwgy3Aw/uJrBdKQu9ZZ9KDKsc3wFJaxqXkUkCXgVZyHO6
! MQIhAOXuO5NBmIdOGjcatl82skXHoIWK8ILBeGwoQMduEn/JAiEA0xuT58WSTC93
! xRYVf/n/LHb8x4zm8hy7fOkTLkD1MNMCIB11ycJTXESx2CAJVyaZ7nuMWV/i7nAC
! c/h/q9UhoFMpAiEAvcYSxc2D4FzjjBZ4KV1xGGW2gySVD5zopjdX+MKIJ+UCIQDX
! VLXkgidoYQ/6XGf8znIyXMySjI4JzHjJkD21lmzqkQ==
  -----END RSA PRIVATE KEY-----
*** /var/spool/ftp/pub/Crypto/SSL/064/SSLeay-0.6.3/./test/testreq.pem	Thu Aug  8 01:21:35 1996
--- ./test/testreq.pem	Fri Aug 30 04:17:18 1996
***************
*** 2,9 ****
  MIIBPzCB6gIBADCBhDELMAkGA1UEBhMCQVUxEzARBgNVBAgTClF1ZWVuc2xhbmQx
  ETAPBgNVBAcTCEJyaXNiYW5lMRcwFQYDVQQKEw5NaW5jb20gUHR5IEx0ZDETMBEG
  A1UEAxMKRXJpYyBZb3VuZzEfMB0GCSqGSIb3DQEJARYQZWF5QG1pbmNvbS5vei5h
! dTBcMA0GCSqGSIb3DQEBAQUAA0sAMEgCQQDWd5C5O0jIZYfAtLQZ2aJlH+u2Q7Kb
! qDy9cZZt2bgXi2+i1uks5gZNKRlgaTry0CVRm/sujlZUew/7h+Zdk0OHAgMBAAGg
! ADANBgkqhkiG9w0BAQQFAANBAKNhXiLweiKaZBfEU7xsCs6CiaOSLGgoUk3GQDTY
! Re9N0YNfcjnLfEUAW6f7xq9FwDcvTmyBtj5qxne7qGnbZPU=
  -----END CERTIFICATE REQUEST-----
--- 2,9 ----
  MIIBPzCB6gIBADCBhDELMAkGA1UEBhMCQVUxEzARBgNVBAgTClF1ZWVuc2xhbmQx
  ETAPBgNVBAcTCEJyaXNiYW5lMRcwFQYDVQQKEw5NaW5jb20gUHR5IEx0ZDETMBEG
  A1UEAxMKRXJpYyBZb3VuZzEfMB0GCSqGSIb3DQEJARYQZWF5QG1pbmNvbS5vei5h
! dTBcMA0GCSqGSIb3DQEBAQUAA0sAMEgCQQC9nCASnzmtShKhUdUaE/p+ik2RiQhk
! HCzVyQghQidwgcYYRV/4z58c6NB1pvf6J9JYgI66zbOG0Fxzoce8kgKrAgMBAAGg
! ADANBgkqhkiG9w0BAQQFAANBACnPTBp0kbdb6gtaoCmv4ZtULNWbKJRg0CwGzS3F
! 4VU0WGVom1/kGITsA9K2/oB44n3enWBWkC8UuUKCudgd5Ys=
  -----END CERTIFICATE REQUEST-----
*** /var/spool/ftp/pub/Crypto/SSL/064/SSLeay-0.6.3/./tools/Makefile.ssl	Thu Aug  8 01:54:32 1996
--- ./tools/Makefile.ssl	Fri Aug 30 04:41:02 1996
***************
*** 47,53 ****
  	mv -f Makefile.new $(MAKEFILE)
  
  clean:
! 	/bin/rm -f *.o *.obj lib tags core .nfs* *.old *.bak fluff
  
  errors:
  
--- 47,53 ----
  	mv -f Makefile.new $(MAKEFILE)
  
  clean:
! 	/bin/rm -f *.o *.obj lib tags core .pure .nfs* *.old *.bak fluff
  
  errors:
  
*** /var/spool/ftp/pub/Crypto/SSL/064/SSLeay-0.6.3/./times/586-100.lnx	Mon Jul 22 22:59:27 1996
--- ./times/586-100.lnx	Fri Aug 30 02:01:16 1996
***************
*** 1,27 ****
  Pentium 100 - Linux 1.2.13 - gcc 2.7.0
  
! SSLeay 0.6.1 02-Jul-1996
! built on Tue Jul  2 22:37:18 EST 1996
  options:bn(64,32) md2(char) rc4(idx,int) des(idx,long) idea(int)
  C flags:gcc -DL_ENDIAN -DTERMIO -O3 -fomit-frame-pointer -m486 -Wall
  The 'numbers' are in 1000s of bytes per second processed.
  type           8 bytes     64 bytes    256 bytes   1024 bytes   8192 bytes
! md2             73.86k      205.27k      277.79k      304.83k      313.62k
! md5            781.48k     3991.16k     7318.29k     9258.38k    10020.28k
! sha            366.81k     1557.21k     2606.28k     3133.71k     3328.34k
! sha1           334.91k     1431.84k     2398.77k     2885.85k     3056.35k
! rc4           3348.37k     3809.12k     3876.79k     3901.37k     3887.13k
! des cfb        747.68k      779.95k      783.43k      784.28k      783.94k
! des cbc        771.24k      843.06k      851.84k      854.12k      851.75k
! des ede3       306.55k      317.27k      318.64k      319.07k      318.43k
! idea cfb       614.96k      636.02k      638.56k      639.15k      640.17k
! idea cbc       617.79k      673.91k      679.72k      681.20k      680.86k
! rc2 cfb        526.74k      542.86k      544.72k      545.23k      545.23k
! rc2 cbc        538.47k      571.42k      576.08k      577.10k      577.78k
  rsa  512 bits   0.024s
  rsa 1024 bits   0.120s
! rsa 2048 bits   0.756s
! rsa 4096 bits   5.485s
  
  SSLeay 0.6.0 21-Jun-1996
  rsa  512 bits   0.048s
--- 1,27 ----
  Pentium 100 - Linux 1.2.13 - gcc 2.7.0
  
! SSLeay 0.6.3 06-Aug-1996
! built on Mon Aug 19 07:53:40 EST 1996
  options:bn(64,32) md2(char) rc4(idx,int) des(idx,long) idea(int)
  C flags:gcc -DL_ENDIAN -DTERMIO -O3 -fomit-frame-pointer -m486 -Wall
  The 'numbers' are in 1000s of bytes per second processed.
  type           8 bytes     64 bytes    256 bytes   1024 bytes   8192 bytes
! md2             73.83k      205.57k      278.19k      305.49k      314.03k
! md5            773.56k     3960.85k     7289.26k     9248.43k    10018.82k
! sha            352.33k     1545.26k     2594.22k     3126.95k     3323.22k
! sha1           299.95k     1343.85k     2332.67k     2861.06k     3061.08k
! rc4           3361.05k     3741.33k     3868.76k     3897.00k     3885.74k
! des cfb        748.10k      777.24k      782.68k      784.04k      783.70k
! des cbc        771.88k      840.06k      851.11k      853.67k      854.70k
! des ede3       306.01k      316.76k      318.63k      318.81k      319.49k
! idea cfb       614.62k      636.01k      638.63k      638.98k      638.98k
! idea cbc       616.92k      673.88k      679.85k      680.96k      682.67k
! rc2 cfb        526.43k      541.91k      544.34k      544.77k      544.32k
! rc2 cbc        536.49k      571.14k      575.74k      576.51k      576.17k
  rsa  512 bits   0.024s
  rsa 1024 bits   0.120s
! rsa 2048 bits   0.747s
! rsa 4096 bits   5.325s
  
  SSLeay 0.6.0 21-Jun-1996
  rsa  512 bits   0.048s
*** /var/spool/ftp/pub/Crypto/SSL/064/SSLeay-0.6.3/./times/586-100.w31	Wed Jul 10 09:46:43 1996
--- ./times/586-100.w31	Thu Aug 29 23:50:28 1996
***************
*** 1,24 ****
  Pentium 100, Windows 3.1 DLL's, 16 bit C, 32bit assember.
  
! SSLeay 0.6.1 02-Jul-1996
! built on Tue Jul  9 22:52:54 EST 1996
  options:bn(32,32) md2(char) rc4(idx,int) des(ptr,long) idea(short)
  C flags:cl /ALw /Gx- /Gf /G2 /f- /Ocgnotb2 /W3 /WX -DL_ENDIAN /nologo -DWIN16
  The 'numbers' are in 1000s of bytes per second processed.
  type           8 bytes     64 bytes    256 bytes   1024 bytes   8192 bytes
! md2             46.81k      130.75k      176.53k      194.90k      187.25k
! md5            225.21k     1048.58k     1833.17k     2221.56k     2383.13k
! sha            106.05k      452.36k      751.13k      900.84k      954.99k
! sha1            96.16k      408.01k      672.16k      809.09k      844.26k
! rc4           1510.05k     1956.30k     2022.72k     2060.88k     2060.88k
! des cfb        314.32k      331.83k      331.83k      330.99k      331.83k
! des cbc        340.45k      372.36k      378.82k      378.82k      372.36k
! des ede3       137.39k      144.66k      144.61k      141.63k      143.77k
! idea cfb       268.04k      280.67k      284.32k      284.32k      280.67k
! idea cbc       274.21k      305.53k      309.86k      309.86k      309.86k
! rc2 cfb        262.14k      277.69k      277.11k      277.69k      277.11k
! rc2 cbc        281.27k      309.86k      313.57k      313.57k      309.86k
! rsa  512 bits   0.060s
! rsa 1024 bits   0.264s
! rsa 2048 bits   1.600s
! rsa 4096 bits  10.320s
--- 1,27 ----
  Pentium 100, Windows 3.1 DLL's, 16 bit C, 32bit assember.
  
! Running under Windows NT 4.0 Beta 2
! 
! SSLeay 0.6.4 20-Aug-1996
! built on Thu Aug 22 08:44:21 EST 1996
  options:bn(32,32) md2(char) rc4(idx,int) des(ptr,long) idea(short)
  C flags:cl /ALw /Gx- /Gf /G2 /f- /Ocgnotb2 /W3 /WX -DL_ENDIAN /nologo -DWIN16
  The 'numbers' are in 1000s of bytes per second processed.
  type           8 bytes     64 bytes    256 bytes   1024 bytes   8192 bytes
! md2             45.83k      128.82k      180.17k      194.90k      198.59k
! md5            224.82k     1038.19k     1801.68k     2175.47k     2330.17k
! sha            105.11k      448.11k      739.48k      884.13k      944.66k
! sha1            94.71k      402.99k      667.88k      795.58k      844.26k
! rc4           1614.19k     1956.30k     2022.72k     2022.72k     2022.72k
! des cfb        291.27k      318.14k      318.14k      318.14k      322.84k
! des cbc        326.86k      356.17k      362.08k      362.08k      367.15k
! des ede3       132.40k      139.57k      139.53k      139.37k      140.97k
! idea cfb       265.33k      280.67k      280.67k      277.69k      281.27k
! idea cbc       274.21k      302.01k      306.24k      306.24k      305.53k
! rc2 cfb        264.79k      274.21k      274.78k      274.21k      274.21k
! rc2 cbc        281.27k      306.24k      309.86k      305.53k      309.86k
! rsa  512 bits   0.058s
! rsa 1024 bits   0.280s
! rsa 2048 bits   1.430s
! rsa 4096 bits  10.600s
! 
*** /dev/null	Fri Aug 30 04:16:48 1996
--- ./times/586p-100.lnx	Thu Aug 29 23:50:28 1996
***************
*** 0 ****
--- 1,26 ----
+ Pentium 100 - Linux 1.2.13 - gcc 2.7.2p
+ This is the pentium specific version of gcc
+ 
+ SSLeay 0.6.4 20-Aug-1996
+ built on Thu Aug 22 08:27:58 EST 1996
+ options:bn(64,32) md2(char) rc4(idx,int) des(idx,long) idea(int)
+ C flags:gcc -DL_ENDIAN -DTERMIO -O6 -fomit-frame-pointer -mpentium -Wall
+ The 'numbers' are in 1000s of bytes per second processed.
+ type           8 bytes     64 bytes    256 bytes   1024 bytes   8192 bytes
+ md2             74.90k      208.43k      282.11k      309.59k      318.43k
+ md5            807.08k     4205.67k     7801.51k     9958.06k    10810.71k
+ sha            405.98k     1821.55k     3119.10k     3799.04k     4052.31k
+ sha1           389.13k     1699.50k     2852.78k     3437.57k     3656.36k
+ rc4           3621.15k     4130.07k     4212.74k     4228.44k     4213.42k
+ des cfb        794.39k      828.37k      831.74k      832.51k      832.85k
+ des cbc        817.68k      886.17k      894.72k      896.00k      892.93k
+ des ede3       308.83k      323.29k      324.61k      324.95k      324.95k
+ idea cfb       690.41k      715.39k      718.51k      719.19k      718.17k
+ idea cbc       696.80k      760.60k      767.32k      768.68k      770.05k
+ rc2 cfb        619.91k      639.74k      642.30k      642.73k      641.71k
+ rc2 cbc        631.99k      671.42k      676.35k      676.18k      677.21k
+ rsa  512 bits   0.025s
+ rsa 1024 bits   0.123s
+ rsa 2048 bits   0.756s
+ rsa 4096 bits   5.365s
+ 
*** /dev/null	Fri Aug 30 04:16:48 1996
--- ./times/686-100.nt	Thu Aug 29 23:50:28 1996
***************
*** 0 ****
--- 1,31 ----
+ From Andy Brown <a.brown@nexor.co.uk>
+ 
+ Windows NT Server 4.0,
+ Visual C++ 4.0
+ 
+ 
+ SSLeay 0.6.0 21-Jun-1996
+ built on Sat Jun 22 01:46:27 EST 1996
+ options:bn(64,32) md2(int) rc4(idx,int) des(idx,long) idea(int)
+ C flags:cl /W3 /WX /G5 /Ox /O2 /Ob2 /Gs0 /nologo -DWIN32 -DL_ENDIAN /MD
+ The 'numbers' are in 1000s of bytes per second processed.
+ type           8 bytes     64 bytes    256 bytes   1024 bytes   8192 bytes
+ md2            180.82k      496.84k      677.70k      743.93k      764.27k
+ md5           2123.91k    10366.54k    18616.53k    23007.70k    24789.03k
+ sha           1446.31k     6493.74k    11199.74k    13595.80k    14593.96k
+ sha1          1347.61k     6123.07k    10549.05k    12850.20k    13729.31k
+ rc4          11358.06k    13848.07k    14189.12k    14305.27k    14379.81k
+ des cfb       2637.93k     2875.96k     2908.67k     2916.76k     2916.76k
+ des cbc       2837.82k     3221.43k     3261.51k     3293.27k     3281.93k
+ des ede3      1137.04k     1191.29k     1203.16k     1207.64k     1205.87k
+ idea cfb      2446.51k     2572.56k     2604.51k     2604.51k     2611.65k
+ idea cbc      2523.04k     2949.58k     2991.66k     2999.36k     3000.22k
+ rc2 cfb       1121.11k     1160.83k     1165.99k     1167.29k     1165.99k
+ rc2 cbc       1156.99k     1214.75k     1221.69k     1221.83k     1221.83k
+ rsa  512 bits   0.016s
+ rsa 1024 bits   0.072s
+ rsa 2048 bits   0.409s
+ rsa 4096 bits   2.834s
+ 
+ ** THIS IS THE SLOW VERSION OF RSA, the number should be about 2 times
+ ** faster for SSLeay 0.6.1+
*** /var/spool/ftp/pub/Crypto/SSL/064/SSLeay-0.6.3/./times/aix.t	Wed Jul 10 09:46:43 1996
--- ./times/aix.t	Thu Aug 29 23:50:28 1996
***************
*** 1,22 ****
! SSLeay 0.6.1 02-Jul-1996
! built on Fri Jul  5 09:39:13 EST 1996
  options:bn(32,32) md2(int) rc4(ptr,char) des(idx,long) idea(int)
  C flags:cc -O -DAIX -DB_ENDIAN
  The 'numbers' are in 1000s of bytes per second processed.
  type           8 bytes     64 bytes    256 bytes   1024 bytes   8192 bytes
! md2             19.24k       52.88k       71.35k       77.74k       80.84k
! md5            215.27k      956.98k     1566.94k     1886.79k     1996.97k
! sha            114.35k      502.38k      860.94k     1056.24k     1132.34k
! sha1           105.30k      462.23k      811.70k      992.55k     1073.82k
! rc4           1113.22k     1253.32k     1277.23k     1281.73k     1271.27k
! des cfb        244.12k      256.54k      259.91k      257.38k      257.54k
! des cbc        263.24k      290.78k      297.10k      295.36k      293.93k
! des ede3       108.58k      114.78k      113.93k      116.12k      113.85k
! idea cfb       266.39k      279.45k      279.60k      281.51k      278.53k
! idea cbc       290.81k      318.38k      321.12k      322.66k      325.47k
! rc2 cfb        208.95k      215.49k      217.47k      217.51k      219.18k
! rc2 cbc        221.94k      241.18k      241.74k      245.90k      243.55k
! rsa  512 bits   0.156s
! rsa 1024 bits   0.974s
! rsa 2048 bits   7.250s
  
--- 1,35 ----
! from Paco Garcia <pgarcia@ctv.es>
! This machine is a Bull Estrella  Minitower Model MT604-100
! Processor        : PPC604 
! P.Speed          : 100Mhz 
! Data/Instr Cache :    16 K
! L2 Cache         :   256 K
! PCI BUS Speed    :    33 Mhz
! TransfRate PCI   :   132 MB/s
! Memory           :    96 MB
! 
! AIX 4.1.4
! 
! SSLeay 0.6.3 06-Aug-1996
! built on Thu Aug  8 11:13:20 DFT 1996
  options:bn(32,32) md2(int) rc4(ptr,char) des(idx,long) idea(int)
  C flags:cc -O -DAIX -DB_ENDIAN
  The 'numbers' are in 1000s of bytes per second processed.
  type           8 bytes     64 bytes    256 bytes   1024 bytes   8192 bytes
! md2             54.18k      147.35k      195.42k      215.07k      220.13k
! md5           1279.65k     5361.81k     8634.62k    10215.77k    10780.67k
! sha            283.63k     1347.86k     2362.28k     2904.96k     3100.86k
! sha1           269.21k     1250.20k     2168.75k     2658.65k     2833.18k
! rc4           4683.20k     5261.03k     5330.54k     5329.95k     5335.72k
! des cfb       1583.67k     1671.06k     1689.25k     1692.55k     1687.55k
! des cbc       1726.23k     1939.16k     1963.82k     1971.03k     1968.90k
! des ede3       720.64k      762.39k      763.56k      765.23k      760.69k
! idea cfb      1769.85k     1869.65k     1875.52k     1887.23k     1886.89k
! idea cbc      2015.58k     2313.72k     2337.68k     2352.47k     2351.10k
! rc2 cfb       1392.73k     1466.52k     1469.01k     1476.95k     1477.29k
! rc2 cbc       1490.46k     1653.70k     1670.66k     1670.04k     1668.44k
! rsa  512 bits   0.019s
! rsa 1024 bits   0.097s
! rsa 2048 bits   0.618s
! rsa 4096 bits   4.457s
  
*** /var/spool/ftp/pub/Crypto/SSL/064/SSLeay-0.6.3/./doc/apps.doc	Wed Jul 10 09:46:21 1996
--- ./doc/apps.doc	Fri Aug 30 01:12:17 1996
***************
*** 48,50 ****
--- 48,53 ----
  speed	- Benchmark the ciphers.
  verify	- Check certificates
  hashdir - under development
+ 
+ [ there a now a few more options, play with the program to see what they
+   are ]
*** /var/spool/ftp/pub/Crypto/SSL/064/SSLeay-0.6.3/./doc/bio.doc	Wed Jul 10 09:46:22 1996
--- ./doc/bio.doc	Fri Aug 30 01:13:21 1996
***************
*** 1,4 ****
! The New SSLeay IO mechanism.
  
  The aim of this stuff is to allow my library to be independant of the
  underlying IO mechanims.  This means the same function can read (or
--- 1,4 ----
! The SSLeay IO system.
  
  The aim of this stuff is to allow my library to be independant of the
  underlying IO mechanims.  This means the same function can read (or
*** /dev/null	Fri Aug 30 04:16:48 1996
--- ./doc/callback.doc	Fri Aug 30 01:22:42 1996
***************
*** 0 ****
--- 1,225 ----
+ Callback functions used in SSLeay.
+ 
+ --------------------------
+ The BIO library.  
+ 
+ Each BIO structure can have a callback defined against it.  This callback is
+ called 2 times for each BIO 'function'.  It is passed 6 parameters.
+ BIO_debug_callback() is an example callback which is defined in
+ crypto/buffer/bio_cb.c and is used in apps/dgst.c  This is intended mostly
+ for debuging or to notify the application of IO.
+ 
+ long BIO_debug_callback(BIO *bio,int cmd,char *argp,int argi,long argl,
+ 	long ret);
+ bio is the BIO being called, cmd is the type of BIO function being called.
+ Look at the BIO_CB_* defines in buffer.h.  Argp and argi are the arguments
+ passed to BIO_read(), BIO_write, BIO_gets(), BIO_puts().  In the case of
+ BIO_ctrl(), argl is also defined.  The first time the callback is called,
+ before the underlying function has been executed, 0 is passed as 'ret', and
+ if the return code from the callback is not > 0, the call is aborted
+ and the returned <= 0 value is returned.
+ The second time the callback is called, the 'cmd' value also has
+ BIO_CB_RETURN logically 'or'ed with it.  The 'ret' value is the value returned
+ from the actuall function call and whatever the callback returns is returned
+ from the BIO function.
+ 
+ BIO_set_callback(b,cb) can be used to set the callback function
+ (b is a BIO), and BIO_set_callback_arg(b,arg) can be used to
+ set the cb_arg argument in the BIO strucutre.  This field is only intended
+ to be used by application, primarily in the callback function since it is
+ accessable since the BIO is passed.
+ 
+ --------------------------
+ The PEM library.
+ 
+ The pem library only really uses one type of callback,
+ static int def_callback(char *buf, int num, int verify);
+ which is used to return a password string if required.
+ 'buf' is the buffer to put the string in.  'num' is the size of 'buf'
+ and 'verify' is used to indicate that the password should be checked.
+ This last flag is mostly used when reading a password for encryption.
+ 
+ For all of these functions, a NULL callback will call the above mentioned
+ default callback.  This default function does not work under Windows 3.1.
+ For other machines, it will use an application defined prompt string
+ (EVP_set_pw_prompt(), which defines a library wide prompt string)
+ if defined, otherwise it will use it's own PEM password prompt.
+ It will then call EVP_read_pw_string() to get a password from the console.
+ If your application wishes to use nice fancy windows to retrieve passwords,
+ replace this function.  The callback should return the number of bytes read
+ into 'buf'.  If the number of bytes <= 0, it is considered an error.
+ 
+ Functions that take this callback are listed below.  For the 'read' type
+ functions, the callback will only be required if the PEM data is encrypted.
+ 
+ For the Write functions, normally a password can be passed in 'kstr', of
+ 'klen' bytes which will be used if the 'enc' cipher is not NULL.  If
+ 'kstr' is NULL, the callback will be used to retrieve a password.
+ 
+ int PEM_do_header (EVP_CIPHER_INFO *cipher, unsigned char *data,long *len,
+ 	int (*callback)());
+ char *PEM_ASN1_read_bio(char *(*d2i)(),char *name,BIO *bp,char **x,int (*cb)());
+ char *PEM_ASN1_read(char *(*d2i)(),char *name,FILE *fp,char **x,int (*cb)());
+ int PEM_ASN1_write_bio(int (*i2d)(),char *name,BIO *bp,char *x,
+ 	EVP_CIPHER *enc,unsigned char *kstr,int klen,int (*callback)());
+ int PEM_ASN1_write(int (*i2d)(),char *name,FILE *fp,char *x,
+ 	EVP_CIPHER *enc,unsigned char *kstr,int klen,int (*callback)());
+ STACK *PEM_X509_INFO_read(FILE *fp, STACK *sk, int (*cb)());
+ STACK *PEM_X509_INFO_read_bio(BIO *fp, STACK *sk, int (*cb)());
+ 
+ #define	PEM_write_RSAPrivateKey(fp,x,enc,kstr,klen,cb)
+ #define	PEM_write_DSAPrivateKey(fp,x,enc,kstr,klen,cb)
+ #define	PEM_write_bio_RSAPrivateKey(bp,x,enc,kstr,klen,cb)
+ #define	PEM_write_bio_DSAPrivateKey(bp,x,enc,kstr,klen,cb)
+ #define	PEM_read_SSL_SESSION(fp,x,cb)
+ #define	PEM_read_X509(fp,x,cb)
+ #define	PEM_read_X509_REQ(fp,x,cb)
+ #define	PEM_read_X509_CRL(fp,x,cb)
+ #define	PEM_read_RSAPrivateKey(fp,x,cb)
+ #define	PEM_read_DSAPrivateKey(fp,x,cb)
+ #define	PEM_read_PrivateKey(fp,x,cb)
+ #define	PEM_read_PKCS7(fp,x,cb)
+ #define	PEM_read_DHparams(fp,x,cb)
+ #define	PEM_read_bio_SSL_SESSION(bp,x,cb)
+ #define	PEM_read_bio_X509(bp,x,cb)
+ #define	PEM_read_bio_X509_REQ(bp,x,cb)
+ #define	PEM_read_bio_X509_CRL(bp,x,cb)
+ #define	PEM_read_bio_RSAPrivateKey(bp,x,cb)
+ #define	PEM_read_bio_DSAPrivateKey(bp,x,cb)
+ #define	PEM_read_bio_PrivateKey(bp,x,cb)
+ #define	PEM_read_bio_PKCS7(bp,x,cb)
+ #define	PEM_read_bio_DHparams(bp,x,cb)
+ int i2d_Netscape_RSA(RSA *a, unsigned char **pp, int (*cb)());
+ RSA *d2i_Netscape_RSA(RSA **a, unsigned char **pp, long length, int (*cb)());
+ 
+ Now you will notice that macros like
+ #define PEM_write_X509(fp,x) \
+                 PEM_ASN1_write((int (*)())i2d_X509,PEM_STRING_X509,fp, \
+ 		                        (char *)x, NULL,NULL,0,NULL)
+ Don't do encryption normally.  If you want to PEM encrypt your X509 structure,
+ either just call PEM_ASN1_write directly or just define you own
+ macro variant.  As you can see, this macro just sets all encryption related
+ parameters to NULL.
+ 
+ 
+ --------------------------
+ The SSL library.
+ 
+ #define SSL_set_info_callback(ssl,cb)
+ #define SSL_CTX_set_info_callback(ctx,cb)
+ void callback(SSL *ssl,int location,int ret)
+ This callback is called each time around the SSL_connect()/SSL_accept() 
+ state machine.  So it will be called each time the SSL protocol progresses.
+ It is mostly present for use when debugging.  When SSL_connect() or
+ SSL_accept() return, the location flag is SSL_CB_ACCEPT_EXIT or
+ SSL_CB_CONNECT_EXIT and 'ret' is the value about to be returned.
+ Have a look at the SSL_CB_* defines in ssl.h.  If an info callback is defined
+ against the SSL_CTX, it is called unless there is one set against the SSL.
+ Have a look at
+ void client_info_callback() in apps/s_client() for an example.
+ 
+ Certificate verification.
+ void SSL_set_verify(SSL *s, int mode, int (*callback) ());
+ void SSL_CTX_set_verify(SSL_CTX *ctx,int mode,int (*callback)());
+ This callback is used to help verify client and server X509 certificates.
+ It is actually passed to X509_cert_verify(), along with the SSL structure
+ so you have to read about X509_cert_verify() :-).  The SSL_CTX version is used
+ if the SSL version is not defined.  X509_cert_verify() is the function used
+ by the SSL part of the library to verify certificates.  This function is
+ nearly always defined by the application.
+ 
+ void SSL_CTX_set_cert_verify_cb(SSL_CTX *ctx, int (*cb)(),char *arg);
+ int callback(char *arg,SSL *s,X509 *xs);
+ This call is used to replace the SSLeay certificate verification code.
+ The 'arg' is kept in the SSL_CTX and is passed to the callback.
+ If the callback returns 0, the certificate is rejected, otherwise it
+ is accepted.  The callback is replacing the X509_cert_verify() call.
+ This feature is not often used, but if you wished to implement
+ some totally different certificate authentication system, this 'hook' is
+ vital.
+ 
+ SSLeay keeps a cache of session-ids against each SSL_CTX.  These callbacks can
+ be used to notify the application when a SSL_SESSION is added to the cache
+ or to retrieve a SSL_SESSION that is not in the cache from the application.
+ #define SSL_CTX_sess_set_get_cb(ctx,cb)
+ SSL_SESSION *callback(SSL *s,char *session_id,int session_id_len,int *copy);
+ If defined, this callback is called to return the SESSION_ID for the
+ session-id in 'session_id', of 'session_id_len' bytes.  'copy' is set to 1
+ if the server is to 'take a copy' of the SSL_SESSION structure.  It is 0
+ if the SSL_SESSION is being 'passed in' so the SSLeay library is now
+ responsible for 'free()ing' the structure.  Basically it is used to indicate
+ if the reference count on the SSL_SESSION structure needs to be incremented.
+ 
+ #define SSL_CTX_sess_set_new_cb(ctx,cb)
+ int callback(SSL s, SSL_SESSION *sess);
+ When a new connection is established, if the SSL_SESSION is going to be added
+ to the cache, this callback is called.  Return 1 if a 'copy' is required,
+ otherwise, return 0.  This return value just causes the reference count
+ to be incremented (on return of a 1), this means the application does
+ not need to worry about incrementing the refernece count (and the
+ locking that implies in a multi-threaded application).
+ 
+ void SSL_CTX_set_default_passwd_cb(SSL_CTX *ctx,int (*cb)());
+ This sets the SSL password reading function.
+ It is mostly used for windowing applications
+ and used by PEM_read_bio_X509() and PEM_read_bio_RSAPrivateKey()
+ calls inside the SSL library.   The only reason this is present is because the
+ calls to PEM_* functions is hidden in the SSLeay library so you have to
+ pass in the callback some how.
+ 
+ --------------------------
+ The X509 library.
+ 
+ int X509_cert_verify(CERTIFICATE_CTX *ctx,X509 *xs, int (*cb)(),
+ 	int *error,char *arg);
+ int verify_callback(int ok,X509 *xs,X509 *xi,int depth,int error,char *arg);
+ 
+ X509_cert_verify() is used to authenticate X509 certificates.  The 'ctx' holds
+ the details of the various caches and files used to locate certificates.
+ 'xs' is the certificate to verify and 'cb' is the application callback (more
+ detail later).  'error' will be set to the error code and 'arg' is passed
+ to the 'cb' callback.  Look at the VERIFY_* defines in crypto/x509/x509.h
+ 
+ When ever X509_cert_verify() makes a 'negative' decision about a
+ certitificate, the callback is called.  If everything checks out, the
+ callback is called with 'VERIFY_OK' or 'VERIFY_ROOT_OK' (for a self
+ signed cert that is not the passed certificate).
+ 
+ The callback is passed the X509_cert_verify opinion of the certificate 
+ in 'ok', the certificate in 'xs', the issuer certificate in 'xi',
+ the 'depth' of the certificate in the verification 'chain', the
+ VERIFY_* code in 'error' and the argument passed to X509_cert_verify()
+ in 'arg'.
+ 
+ The callback can be used to look at the error reason, and then return 0
+ for an 'error' or '1' for ok.  This will override the X509_cert_verify()
+ opinion of the certificates validity.  Processing will continue depending on
+ the return value.  If one just wishes to use the callback for informational
+ reason, just return the 'ok' parameter.
+ 
+ --------------------------
+ The BN and DH library.
+ 
+ BIGNUM *BN_generate_prime(int bits,int strong,BIGNUM *add,
+ 	BIGNUM *rem,void (*callback)(int,int));
+ int BN_is_prime(BIGNUM *p,int nchecks,void (*callback)(int,int),
+ 
+ Read doc/bn.doc for the description of these 2.
+ 
+ DH *DH_generate_parameters(int prime_len,int generator,
+ 	void (*callback)(int,int));
+ Read doc/bn.doc for the description of the callback, since it is just passed
+ to BN_generate_prime(), except that it is also called as
+ callback(3,0) by this function.
+ 
+ --------------------------
+ The CRYPTO library.
+ 
+ void CRYPTO_set_locking_callback(void (*func)(int mode,int type,char *file,
+ 	int line));
+ void CRYPTO_set_add_lock_callback(int (*func)(int *num,int mount,
+ 	int type,char *file, int line));
+ void CRYPTO_set_id_callback(unsigned long (*func)(void));
+ 
+ Read threads.doc for info on these ones.
+ 
*** /var/spool/ftp/pub/Crypto/SSL/064/SSLeay-0.6.3/./doc/cipher.doc	Wed Jul 24 23:11:36 1996
--- ./doc/cipher.doc	Fri Aug 30 01:25:35 1996
***************
*** 1,6 ****
  The Cipher subroutines.
  
! These routines require "Cipher.h" to be included.
  
  These functions are a higher level interface to the various cipher
  routines found in this library.  As such, they allow the same code to be
--- 1,6 ----
  The Cipher subroutines.
  
! These routines require "envelope.h" to be included.
  
  These functions are a higher level interface to the various cipher
  routines found in this library.  As such, they allow the same code to be
*** /var/spool/ftp/pub/Crypto/SSL/064/SSLeay-0.6.3/./doc/conf.doc	Wed Jul 10 09:46:22 1996
--- ./doc/conf.doc	Thu Aug 29 23:50:27 1996
***************
*** 81,83 ****
--- 81,89 ----
  USER_CERT	= $HOME/\${USER}di\'r	# /home/eay/${USER}di'r
  USER_CERT	= "$HOME/${US"ER}di\'r	# $HOME/${USER}di'r
  
+ TEST		= 1234\
+ 5678\
+ 9ab					# TEST=123456789ab
+ TTT		= 1234\n\n		# TTT=1234<nl><nl>
+ 
+ 
*** /var/spool/ftp/pub/Crypto/SSL/064/SSLeay-0.6.3/./doc/digest.doc	Wed Jul 10 09:46:22 1996
--- ./doc/digest.doc	Fri Aug 30 01:26:02 1996
***************
*** 1,7 ****
  
  The Message Digest subroutines.
  
! These routines require "Digest.h" to be included.
  
  These functions are a higher level interface to the various message digest
  routines found in this library.  As such, they allow the same code to be
--- 1,7 ----
  
  The Message Digest subroutines.
  
! These routines require "envelope.h" to be included.
  
  These functions are a higher level interface to the various message digest
  routines found in this library.  As such, they allow the same code to be
*** /var/spool/ftp/pub/Crypto/SSL/064/SSLeay-0.6.3/./doc/error.doc	Wed Jul 10 09:46:23 1996
--- ./doc/error.doc	Fri Aug 30 01:31:40 1996
***************
*** 14,27 ****
  a number that is unique for that library.  Each 'library' also has a number
  for each 'error reason' that is only unique for that 'library'.
  
! Due to the way these error routines record a 'error trace', there is a
! global array that is used to store the error codes.  The various functions
! in this library are used to access and manipulate this array.
  
- The following 4 functions will probably have to be replaced for a
- multithreaded library.  It should be simple enough to implement this system
- with message queue or some such system.
- 
  void ERR_put_error(int lib, int func,int reason);
  	This routine records an error in library 'lib', function 'func'
  and reason 'reason'.  As errors get 'put' into the buffer, they wrap
--- 14,24 ----
  a number that is unique for that library.  Each 'library' also has a number
  for each 'error reason' that is only unique for that 'library'.
  
! Due to the way these error routines record a 'error trace', there is an
! array per thread that is used to store the error codes.
! The various functions in this library are used to access
! and manipulate this array.
  
  void ERR_put_error(int lib, int func,int reason);
  	This routine records an error in library 'lib', function 'func'
  and reason 'reason'.  As errors get 'put' into the buffer, they wrap
***************
*** 42,48 ****
  	This function clears the error buffer, discarding all unread
  errors.
  
- 
  While the above described error system obviously produces lots of different
  error number, a method for 'reporting' these errors in a human readable
  form is required.  To achieve this, each library has the option of
--- 39,44 ----
***************
*** 100,102 ****
--- 96,115 ----
  3) For Windows NT etc, it should be simple to replace the 'key' routines
     with code to pass error codes back to the application.
  4) I wanted the option of meaningful error text strings.
+ 
+ Late breaking news - the changes to support threads.
+ 
+ Each 'thread' has an 'ERR_STATE' state associated with it.
+ ERR_STATE *ERR_get_state(void ) will return the 'state' for the calling
+ thread/process.
+ 
+ ERR_remove_state(unsigned long pid); will 'free()' this state.  If pid == 0
+ the current 'thread/process' will have it's error state removed.
+ If you do not remove the error state of a thread, this could be considered a
+ form of memory leak, so just after 'reaping' a thread that has died,
+ call ERR_remove_state(pid).
+ 
+ Have a read of thread.doc for more details for what is required for
+ multi-threading support.  All the other error routines will
+ work correctly when using threads.
+ 
*** /dev/null	Fri Aug 30 04:16:48 1996
--- ./doc/memory.doc	Thu Aug 29 23:50:27 1996
***************
*** 0 ****
--- 1,27 ----
+ In the interests of debugging SSLeay, there is an option to compile
+ using some simple memory leak checking.
+ 
+ All malloc(), free() and realloc() calls in SSLeay now go via
+ Malloc(), Free() and Realloc() (except those in crypto/lhash).
+ 
+ If CRYPTO_MDEBUG is defined, these calls are #defined to
+ CRYPTO_malloc(), CRYPTO_free() and CRYPTO_realloc().
+ If it is not defined, they are #defined to malloc(), free() and realloc().
+ 
+ the CRYPTO_malloc() routines by default just call the underlying library
+ functons.
+ 
+ If CRYPTO_mem_ctrl(CRYPTO_MEM_CHECK_ON) is called, memory leak detection is
+ turned on.  CRYPTO_mem_ctrl(CRYPTO_MEM_CHECK_OFF) turns it off.
+ 
+ When turned on, each Malloc() or Realloc() call is recored along with the file
+ and line number from where the call was made.   (This is done using the
+ lhash library which always uses normal system malloc(3) routines).
+ 
+ void CRYPTO_mem_leaks(BIO *b);
+ void CRYPTO_mem_leaks_fp(FILE *fp);
+ These both print out the list of memory that has not been free()ed.
+ This will probably be rather hard to read, but if you look for the 'top level'
+ structure allocation, this will often give an idea as to what is not being
+ free()ed.  I don't expect people to use this stuff normally.
+ 
*** /var/spool/ftp/pub/Crypto/SSL/064/SSLeay-0.6.3/./doc/ns-ca.doc	Mon Jul 29 11:32:42 1996
--- ./doc/ns-ca.doc	Thu Aug 29 23:50:27 1996
***************
*** 74,79 ****
--- 74,83 ----
  	browser (with all the newlines and other space charaters
  	removed -- and newline escapes are NOT supported).
  
+ 	[ As of SSLeay 0.6.4, multiple lines are supported.
+ 	  Put a \ at the end of each line and it will be joined with the
+ 	  previous line with the '\n' removed - eay ]
+ 	
  	Here's a sample input file:
  
  C = US
*** /var/spool/ftp/pub/Crypto/SSL/064/SSLeay-0.6.3/./doc/rc2.doc	Wed Jul 10 09:46:24 1996
--- ./doc/rc2.doc	Thu Aug 29 23:50:27 1996
***************
*** 28,58 ****
  For all modes of the RC2 algorithm, the RC2_KEY used for
  decryption is the same one that was used for encryption.
  
! The define IDEA_ENCRYPT is passed to specify encryption for the functions
! that require an encryption/decryption flag. IDEA_DECRYPT is passed to
  specify decryption.
  
- So to encrypt you would do the following
- RC2_set_encrypt_key(key,encrypt_ks);
- idea_ecb_encrypt(...,encrypt_ks);
- idea_cbc_encrypt(....,encrypt_ks,...,IDEA_ENCRYPT);
- 
- To Decrypt
- idea_set_encrypt_key(key,encrypt_ks);
- idea_set_decrypt_key(encrypt_ks,decrypt_ks);
- idea_ecb_encrypt(...,decrypt_ks);
- idea_cbc_encrypt(....,decrypt_ks,...,IDEA_DECRYPT);
- 
  Please note that any of the encryption modes specified in my DES library
! could be used with IDEA.  I have only implemented ecb, cbc, cfb64 and
  ofb64 for the following reasons.
! - ecb is the basic IDEA encryption.
  - cbc is the normal 'chaining' form for block ciphers.
  - cfb64 can be used to encrypt single characters, therefore input and output
    do not need to be a multiple of 8.
  - ofb64 is similar to cfb64 but is more like a stream cipher, not as
    secure (not cipher feedback) but it does not have an encrypt/decrypt mode.
! - If you want triple IDEA, thats 384 bits of key and you must be totally
    obsessed with security.  Still, if you want it, it is simple enough to
    copy the function from the DES library and change the des_encrypt to
    idea_encrypt; an exercise left for the paranoid reader :-).
--- 28,47 ----
  For all modes of the RC2 algorithm, the RC2_KEY used for
  decryption is the same one that was used for encryption.
  
! The define RC2_ENCRYPT is passed to specify encryption for the functions
! that require an encryption/decryption flag. RC2_DECRYPT is passed to
  specify decryption.
  
  Please note that any of the encryption modes specified in my DES library
! could be used with RC2.  I have only implemented ecb, cbc, cfb64 and
  ofb64 for the following reasons.
! - ecb is the basic RC2 encryption.
  - cbc is the normal 'chaining' form for block ciphers.
  - cfb64 can be used to encrypt single characters, therefore input and output
    do not need to be a multiple of 8.
  - ofb64 is similar to cfb64 but is more like a stream cipher, not as
    secure (not cipher feedback) but it does not have an encrypt/decrypt mode.
! - If you want triple RC2, thats 384 bits of key and you must be totally
    obsessed with security.  Still, if you want it, it is simple enough to
    copy the function from the DES library and change the des_encrypt to
    idea_encrypt; an exercise left for the paranoid reader :-).
***************
*** 63,68 ****
--- 52,58 ----
  RC2_KEY *ks;
  int len;
  unsigned char *key;
+ int bits;
          RC2_set_key converts an 'len' byte key into a RC2_KEY.
          A 'ks' is an expanded form of the 'key' which is used to
          perform actual encryption.  It can be regenerated from the RC2 key
***************
*** 71,77 ****
          are CPU architecture dependent, 'key's are not.  RC2 is an
  	interesting cipher in that it can be used with a variable length
  	key.  'len' is the length of 'key' to be used as the key.
! 	A 'len' of 16 is recomended.
  	
  void RC2_encrypt(
  unsigned long *data,
--- 61,75 ----
          are CPU architecture dependent, 'key's are not.  RC2 is an
  	interesting cipher in that it can be used with a variable length
  	key.  'len' is the length of 'key' to be used as the key.
! 	A 'len' of 16 is recomended.  The 'bits' argument is an
! 	interesting addition which I only found out about in Aug 96.
! 	BSAFE uses this parameter to 'limit' the number of bits used
! 	for the key.  To use the 'key' unmodified, set bits to 1024.
! 	This is what old versions of my RC2 library did (SSLeay 0.6.3).
! 	RSAs BSAFE library sets this parameter to be 128 if 128 bit
! 	keys are being used.  So to be compatable with BSAFE, set it
! 	to 128, if you don't want to reduce RC2's key length, leave it
! 	at 1024.
  	
  void RC2_encrypt(
  unsigned long *data,
*** /var/spool/ftp/pub/Crypto/SSL/064/SSLeay-0.6.3/./doc/readme	Wed Jul 10 09:46:24 1996
--- ./doc/readme	Fri Aug 30 01:11:34 1996
***************
*** 1,11 ****
  In my SSL/Crypto library I have attempted to always prefix my routines
  with something that makes sense.  If the prefix is upper case, you can use
  it, if it is lower case, I would prefer you not to use it.  The exception
! to this rule is the DES and LHASH libraries which I wrote quite some time
! ago, before this current project swallowed them into the fold :-)
  Often the prefixes may not make much sense; too bad :-).
  
! The documents can be groups as follows
  
  Secret Ciphers
  D	DES	- DES cipher.
--- 1,13 ----
  In my SSL/Crypto library I have attempted to always prefix my routines
  with something that makes sense.  If the prefix is upper case, you can use
  it, if it is lower case, I would prefer you not to use it.  The exception
! to this rule is the DES, LHASH and STACK libraries which I wrote
! quite some time ago, before this current project swallowed them
! into the fold :-)
  Often the prefixes may not make much sense; too bad :-).
  
! The documents can be groups as follows [ most of this stuff is a bit out of
! date ]
  
  Secret Ciphers
  D	DES	- DES cipher.
***************
*** 16,22 ****
  Message Digests
  D	MD2	- MD2 message digest algorithm
  D	MD5	- MD5 message digest algorithm plus random number routines.
! D	SHA	- The Secure Hash Algorithm.
  
  Public Key Ciphers
  DE	BN	- The BigNum library that RSA and DH use.
--- 18,25 ----
  Message Digests
  D	MD2	- MD2 message digest algorithm
  D	MD5	- MD5 message digest algorithm plus random number routines.
! D	SHA	- The Secure Hash Algorithm 0.
! D	SHA1	- The Secure Hash Algorithm 1 - the new modified version.
  
  Public Key Ciphers
  DE	BN	- The BigNum library that RSA and DH use.
***************
*** 25,31 ****
  D	DHA	- The Digital Signature Algorithms
  	RSAref	- Routine to replay my library with RSAref.
  
! Higher Level Crypto Routines
  DE	CIPHER	- Encryption by parts.
  DE	DIGEST	- Message digesting by parts.
  DE	SIGN	- Sign a message with a private key.
--- 28,34 ----
  D	DHA	- The Digital Signature Algorithms
  	RSAref	- Routine to replay my library with RSAref.
  
! Higher Level Crypto Routines - EVP library
  DE	CIPHER	- Encryption by parts.
  DE	DIGEST	- Message digesting by parts.
  DE	SIGN	- Sign a message with a private key.
*** /var/spool/ftp/pub/Crypto/SSL/064/SSLeay-0.6.3/./doc/ref.doc	Wed Jul 10 09:46:24 1996
--- ./doc/ref.doc	Fri Aug 30 01:33:11 1996
***************
*** 1,3 ****
--- 1,7 ----
+ I have lots more references etc, and will update this list in the future,
+ 30 Aug 1996 - eay
+ 
+ 
  SSL	The SSL Protocol - from Netscapes.
  
  RC4	Newsgroups: sci.crypt
*** /var/spool/ftp/pub/Crypto/SSL/064/SSLeay-0.6.3/./doc/rsaref.doc	Wed Jul 10 09:46:24 1996
--- ./doc/rsaref.doc	Fri Aug 30 01:09:23 1996
***************
*** 1,9 ****
  This package can be compiled to use the RSAref library.
  This library is not allowed outside of the USA but inside the USA it is
! claimed by RSA to be the only RSA public key library that can be used.
  
  There are 2 files, rsaref/rsaref.c and rsaref/rsaref.h that contain the glue
! code to use RSAref.  These files have been written by looking at the PGP
  source code and seeing which routines it used to access RSAref.
  I have also been sent by some-one a copy of the RSAref header file that
  contains the library error codes.
--- 1,10 ----
  This package can be compiled to use the RSAref library.
  This library is not allowed outside of the USA but inside the USA it is
! claimed by RSA to be the only RSA public key library that can be used
! besides BSAFE..
  
  There are 2 files, rsaref/rsaref.c and rsaref/rsaref.h that contain the glue
! code to use RSAref.  These files were written by looking at the PGP
  source code and seeing which routines it used to access RSAref.
  I have also been sent by some-one a copy of the RSAref header file that
  contains the library error codes.
***************
*** 18,23 ****
--- 19,26 ----
  the programs must be linked with RSAref, add '-DRSAref' to CFLAG in the top
  level makefile and -lrsaref (or where ever you are keeping RSAref) to
  EX_LIBS.
+ 
+ To build a makefile via util/mk1mf.pl to do this, use the 'rsaref' option.
  
  The second method is to build as per normal and link applications with
  the RSAglue library.  The correct library order would be
*** /var/spool/ftp/pub/Crypto/SSL/064/SSLeay-0.6.3/./doc/session.doc	Wed Jul 10 09:46:24 1996
--- ./doc/session.doc	Fri Aug 30 01:48:35 1996
***************
*** 20,26 ****
  If SSL_SESS_CACHE_CLIENT is set, then client certificates are also added
  to the cache.
  SSL_set_session_cache_mode(ctx,mode)  will set the 'mode' and
! SSL_get_session_cache_mode(ctx) will set the cache 'mode'.
  The modes can be
  SSL_SESS_CACHE_OFF	- no caching
  SSL_SESS_CACHE_CLIENT	- only SSL_connect()
--- 20,26 ----
  If SSL_SESS_CACHE_CLIENT is set, then client certificates are also added
  to the cache.
  SSL_set_session_cache_mode(ctx,mode)  will set the 'mode' and
! SSL_get_session_cache_mode(ctx) will get the cache 'mode'.
  The modes can be
  SSL_SESS_CACHE_OFF	- no caching
  SSL_SESS_CACHE_CLIENT	- only SSL_connect()
***************
*** 27,42 ****
  SSL_SESS_CACHE_SERVER	- only SSL_accept()
  SSL_SESS_NO_CACHE_BOTH	- Either SSL_accept() or SSL_connect().
  If SSL_SESS_CACHE_NO_AUTO_CLEAR is set, old timed out sessions are
! not automatically removed each 32, SSL_connect()s or SSL_accept()s.
  
! By default, apon every 32'nd successful SSL_connect() or SSL_accepr(),
  the cache is flush.  Please note that this could be expensive on
  a heavily loaded SSL server, in which case, turn this off and
  clear the cache of old entries 'manually' (with one of the functions
  listed below) every few hours.  Perhaps I should up this number, it is hard
! to say.  Remember, the '32' new calls is just a mechanims to get called
! every now and then, in theory at most 32 new session-id's will have been
! added.
  
  int SSL_CTX_sess_hits(SSL_CTX *ctx);
  int SSL_CTX_sess_misses(SSL_CTX *ctx);
--- 27,44 ----
  SSL_SESS_CACHE_SERVER	- only SSL_accept()
  SSL_SESS_NO_CACHE_BOTH	- Either SSL_accept() or SSL_connect().
  If SSL_SESS_CACHE_NO_AUTO_CLEAR is set, old timed out sessions are
! not automatically removed each 255, SSL_connect()s or SSL_accept()s.
  
! By default, apon every 255 successful SSL_connect() or SSL_accept()s,
  the cache is flush.  Please note that this could be expensive on
  a heavily loaded SSL server, in which case, turn this off and
  clear the cache of old entries 'manually' (with one of the functions
  listed below) every few hours.  Perhaps I should up this number, it is hard
! to say.  Remember, the '255' new calls is just a mechanims to get called
! every now and then, in theory at most 255 new session-id's will have been
! added but if 100 are added every minute, you would still have
! 500 in the cache before any would start being flushed (assuming a 3 minute
! timeout)..
  
  int SSL_CTX_sess_hits(SSL_CTX *ctx);
  int SSL_CTX_sess_misses(SSL_CTX *ctx);
***************
*** 50,81 ****
  int new_session_callback(SSL_SESSION *new);
  This function, if set in the SSL_CTX structure is called whenever a new
  SSL_SESSION is added to the cache.  If the callback returns non-zero, it
! means that the application will SSL_SESSION_free() the structure (this is
  to do with the cache keeping the reference counts correct, without the
  application needing to know about it.
  
! void SSL_CTX_sess_set_new_cb(SSL_CTX *ctx,int (*cb)(SSL_SESSION *));
  to set the callback,
! int (*cb)(SSL_SESSION *) SSL_CTX_sess_get_new_cb(SSL_CTX *ctx)
  to get the callback.
  
  If the 'get session' callback is set, when a session id is looked up and
  it is not in the session-id cache, this callback is called.  The callback is
  of the form
! SSL_SESSION *get_session_callback(unsigned char *sess_id,int sess_id_len);
  
  The get_session_callback is intended to return null if no session id is found.
  The reference count on the SSL_SESSION in incremented by the SSL library,
! so after you have passed a session-id back, you can 'free' the SSL_SESSION
! if you desire.
  
  void SSL_CTX_sess_set_get_cb(ctx,cb) sets the callback and
! int (*cb)()SSL_CTX_sess_get_get_cb(ctx_) returns the callback.
  
  These callbacks are basically indended to be used by processes to
  send their session-id's to other processes.  I currently have not implemented
  non-blocking semantics for these callbacks, it is upto the appication
! to make the callbacks effiecent if their require blocking (perhaps
  by 'saving' them and then 'posting them' when control returns from
  the SSL_accept().
  
--- 52,84 ----
  int new_session_callback(SSL_SESSION *new);
  This function, if set in the SSL_CTX structure is called whenever a new
  SSL_SESSION is added to the cache.  If the callback returns non-zero, it
! means that the application will have to do a SSL_SESSION_free()
! on the structure (this is
  to do with the cache keeping the reference counts correct, without the
  application needing to know about it.
  
! void SSL_CTX_sess_set_new_cb(SSL_CTX *ctx,int (*cb)());
  to set the callback,
! int (*cb)() SSL_CTX_sess_get_new_cb(SSL_CTX *ctx)
  to get the callback.
  
  If the 'get session' callback is set, when a session id is looked up and
  it is not in the session-id cache, this callback is called.  The callback is
  of the form
! SSL_SESSION *get_session_callback(unsigned char *sess_id,int sess_id_len,
! 	int *copy);
  
  The get_session_callback is intended to return null if no session id is found.
  The reference count on the SSL_SESSION in incremented by the SSL library,
! if copy is 1.  Otherwise, the reference count is not modified.
  
  void SSL_CTX_sess_set_get_cb(ctx,cb) sets the callback and
! int (*cb)()SSL_CTX_sess_get_get_cb(ctx) returns the callback.
  
  These callbacks are basically indended to be used by processes to
  send their session-id's to other processes.  I currently have not implemented
  non-blocking semantics for these callbacks, it is upto the appication
! to make the callbacks effiecent if they require blocking (perhaps
  by 'saving' them and then 'posting them' when control returns from
  the SSL_accept().
  
***************
*** 97,103 ****
  Now as mentioned ealier, when a SSL is created, it needs a SSL_CTX.
  SSL *   SSL_new(SSL_CTX *);
  
! This stores session.  A session is secret information shared between 2
  SSL contexts.  It will only be created if both ends of the connection have
  authenticated their peer to their satisfaction.  It basically contains
  the information required to use a particular secret key cipher.
--- 100,106 ----
  Now as mentioned ealier, when a SSL is created, it needs a SSL_CTX.
  SSL *   SSL_new(SSL_CTX *);
  
! This stores a session.  A session is secret information shared between 2
  SSL contexts.  It will only be created if both ends of the connection have
  authenticated their peer to their satisfaction.  It basically contains
  the information required to use a particular secret key cipher.
***************
*** 111,123 ****
  int SSL_set_session(SSL *s, SSL_SESSION *session);
  This will set the SSL_SESSION to use for the next SSL_connect().  If you use
  this function on an already 'open' established SSL connection, 'bad things
! will happen'.  This function is meaning less when used on a ssl strucutre
  that is just about to be used in a SSL_accept() call since the
  SSL_accept() will either create a new session or retrieve one from the
  cache.
  
  SSL_SESSION *SSL_get_session(SSL *s);
! This will return the SSL_SESSION for the current socked, NULL if there is
  no session associated with the SSL structure.
  
  The SSL sessions are kept in the SSL_CTX in a hash table, to remove a
--- 114,126 ----
  int SSL_set_session(SSL *s, SSL_SESSION *session);
  This will set the SSL_SESSION to use for the next SSL_connect().  If you use
  this function on an already 'open' established SSL connection, 'bad things
! will happen'.  This function is meaning-less when used on a ssl strucutre
  that is just about to be used in a SSL_accept() call since the
  SSL_accept() will either create a new session or retrieve one from the
  cache.
  
  SSL_SESSION *SSL_get_session(SSL *s);
! This will return the SSL_SESSION for the current SSL, NULL if there is
  no session associated with the SSL structure.
  
  The SSL sessions are kept in the SSL_CTX in a hash table, to remove a
***************
*** 133,139 ****
  does not add it to the cache.  Just call SSL_add_session() if you do want the
  session added.  For a 'client' this would not normally be the case.
  SSL_add_session() is not normally ever used, except for doing 'evil' things
! which the next 2 funtions let you do.
  
  int     i2d_SSL_SESSION(SSL_SESSION *in,unsigned char **pp);
  SSL_SESSION *d2i_SSL_SESSION(SSL_SESSION **a,unsigned char **pp,long length);
--- 136,142 ----
  does not add it to the cache.  Just call SSL_add_session() if you do want the
  session added.  For a 'client' this would not normally be the case.
  SSL_add_session() is not normally ever used, except for doing 'evil' things
! which the next 2 funtions help you do.
  
  int     i2d_SSL_SESSION(SSL_SESSION *in,unsigned char **pp);
  SSL_SESSION *d2i_SSL_SESSION(SSL_SESSION **a,unsigned char **pp,long length);
***************
*** 150,161 ****
  
  long SSL_get_time(SSL_SESSION *s)
  will return the 'time' that the session
! was loaded.  The timeout is relative to this time.  This information is not
! saved when the SSL_SESSION is converted to binarary since this I consider
! this timing information to be an artifact of the cache and once you start
! passing these things around you are already doing 'evil' things anyway
! and so if this information matters to you, retireve it and pass it in
! your own format at the same time :-).
  
  long SSL_set_time(SSL_SESSION *s,long t) will set the above mentioned time.
  The time value is just the value returned from time(3), and should really
--- 153,161 ----
  
  long SSL_get_time(SSL_SESSION *s)
  will return the 'time' that the session
! was loaded.  The timeout is relative to this time.  This information is
! saved when the SSL_SESSION is converted to binarary but it is stored
! in as a unix long, which is rather OS dependant, but easy to convert back.
  
  long SSL_set_time(SSL_SESSION *s,long t) will set the above mentioned time.
  The time value is just the value returned from time(3), and should really
***************
*** 242,252 ****
  /* associated it with the ssl strucutre */
  SSL_set_fd(ssl,fd);
  
! SSL_accept(ssl); /* negoiate SSL using out cert and RSA key */
  
  /* Lets print out the session details or lets save it to a file,
   * perhaps with a secret key cipher, so that we can pass it to the FBI
!  * when they want to decode the session for them :-).  While we have RSA
   * this does not matter much but when I do SSLv3, this will allow a mechanism
   * for the server/client to record the information needed to decode
   * the traffic that went over the wire, even when using Diffie-Hellman */
--- 242,252 ----
  /* associated it with the ssl strucutre */
  SSL_set_fd(ssl,fd);
  
! SSL_accept(ssl); /* 'do' SSL using out cert and RSA key */
  
  /* Lets print out the session details or lets save it to a file,
   * perhaps with a secret key cipher, so that we can pass it to the FBI
!  * when they want to decode the session :-).  While we have RSA
   * this does not matter much but when I do SSLv3, this will allow a mechanism
   * for the server/client to record the information needed to decode
   * the traffic that went over the wire, even when using Diffie-Hellman */
***************
*** 275,281 ****
   * longer be accepted after a while.  The time and timeout are ignored except
   * by SSL_accept(). */
  
! /* Since we have had out server running for 10 weeks, and memory is getting
   * short, perhaps we should clear the session cache to remove those
   * 100000 session entries that have expired.  Some may consider this
   * a memory leak :-) */
--- 275,281 ----
   * longer be accepted after a while.  The time and timeout are ignored except
   * by SSL_accept(). */
  
! /* Since we have had our server running for 10 weeks, and memory is getting
   * short, perhaps we should clear the session cache to remove those
   * 100000 session entries that have expired.  Some may consider this
   * a memory leak :-) */
*** /var/spool/ftp/pub/Crypto/SSL/064/SSLeay-0.6.3/./doc/speed.doc	Wed Jul 10 09:46:25 1996
--- ./doc/speed.doc	Fri Aug 30 01:49:09 1996
***************
*** 12,20 ****
--- 12,23 ----
  ---
  
  These are some numbers I did comparing RSAref and SSLeay on a Pentium 100.
+ [ These numbers are all out of date, as of SSL - 0.6.1 the RSA
+ operations are about 2 times faster, so check the version number ]
  
  RSA performance.
  
+ SSLeay 0.6.0
  Pentium 100, 32meg, Windows NT Workstation 3.51
  linux - gcc v 2.7.0 -O3 -fomit-frame-pointer -m486
  and
***************
*** 37,42 ****
--- 40,46 ----
  486DX66, 32meg, Windows NT Server 3.51
  	       512bits 1024bits
  -------------------------------
+ SSLeay NT dll   0.084s	 0.495s	<- SSLeay 0.6.3
  SSLeay NT dll   0.154s   0.882s
  SSLeay W3.1 dll 0.335s   1.538s
  SSLeay MS-DOS	0.490s   2.790s
***************
*** 52,57 ****
--- 56,63 ----
  The message is, if you are stuck using RSAref, the RSA performance will be
  bad. Considering the code was compiled for a pentium, the 486DX66 number
  would indicate 'Use RSAref and turn you Pentium 100 into a 486DX66' :-). 
+ [ As of verson 0.6.1, it would be correct to say 'turn you pentium 100
+  into a 486DX33' :-) ]
  
  I won't tell people if the DLL's are using RSAref or my stuff if no-one
  asks :-).
***************
*** 70,75 ****
--- 76,83 ----
     My base library still has the advantage of being able to operate on 
     any size numbers, and is not that far from the performance from the
     leaders in the field. (-%30?)
+    [ Well as of 0.6.1 I am now the leader in the filed on x86 (we at
+      least very close :-) ]
  
     I suppose I should also mention some other numbers RSAref numbers, again
     on my Pentium.
*** /var/spool/ftp/pub/Crypto/SSL/064/SSLeay-0.6.3/./doc/ssleay.doc	Wed Jul 10 09:46:25 1996
--- ./doc/ssleay.doc	Fri Aug 30 01:53:39 1996
***************
*** 33,39 ****
  
  Ah, but here was the problem, I was not happy with the code so far.  As may
  have become obvious, I had been treating all of this as a learning
! excersize, so I have completely written the library myself.  As such, due
  to the way it had grown like a fungus, much of the library was not
  'elagent' or neat.  There were global and static variables all over the
  place, the SSL part did not even handle non-blocking IO.
--- 33,39 ----
  
  Ah, but here was the problem, I was not happy with the code so far.  As may
  have become obvious, I had been treating all of this as a learning
! exersize, so I have completely written the library myself.  As such, due
  to the way it had grown like a fungus, much of the library was not
  'elagent' or neat.  There were global and static variables all over the
  place, the SSL part did not even handle non-blocking IO.
***************
*** 210,212 ****
--- 210,213 ----
  	library number, function number (in the library) and reason
  	number.  Multiple errors can be reported so that an 'error' trace
  	is created.  The errors can be printed in numeric or textual form.
+ 
*** /var/spool/ftp/pub/Crypto/SSL/064/SSLeay-0.6.3/./doc/ssl_ctx.doc	Wed Jul 10 09:46:25 1996
--- ./doc/ssl_ctx.doc	Fri Aug 30 01:52:24 1996
***************
*** 1,3 ****
--- 1,6 ----
+ This is now a bit dated, quite a few of the SSL_ functions could be
+ SSL_CTX_ functions.  I will update this in the future. 30 Aug 1996
+ 
  From eay@orb.mincom.oz.au Mon Dec 11 21:37:08 1995
  Received: by orb.mincom.oz.au id AA00696
    (5.65c/IDA-1.4.4 for eay); Mon, 11 Dec 1995 11:37:08 +1000
*** /var/spool/ftp/pub/Crypto/SSL/064/SSLeay-0.6.3/./doc/s_mult.doc	Wed Jul 10 09:46:24 1996
--- ./doc/s_mult.doc	Fri Aug 30 01:34:30 1996
***************
*** 11,17 ****
  	type Q<cr> to quit
  
  In another window, run the following
! ssleay s_client -pause -port 8889 </etc/termcap
  
  The pause option puts in a 1 second pause in each read(2)/write(2) call
  so the other end will have read()s fail.
--- 11,17 ----
  	type Q<cr> to quit
  
  In another window, run the following
! ssleay s_client -pause </etc/termcap
  
  The pause option puts in a 1 second pause in each read(2)/write(2) call
  so the other end will have read()s fail.
*** /dev/null	Fri Aug 30 04:16:48 1996
--- ./doc/threads.doc	Fri Aug 30 01:25:01 1996
***************
*** 0 ****
--- 1,90 ----
+ How to compile SSLeay for multi-threading.
+ 
+ Well basically it is quite simple, set the compiler flags and build.
+ I have only really done much testing under Solaris and Windows NT.
+ If you library supports localtime_r() and gmtime_r() add,
+ -DTHREADS to the makefile parameters.  You can probably survive with out
+ this define unless you are going to have multiple threads generating
+ certificates at once.  It will not affect the SSL side of things.
+ 
+ The approach I have taken to doing locking is to make the application provide
+ callbacks to perform locking and so that the SSLeay library can distinguish
+ between threads (for the error state).
+ 
+ To have a look at an example program, 'cd mt; vi mttest.c'.
+ To build under solaris, sh solaris.sh, for Windows NT or Windows 95,
+ win32.bat
+ 
+ This will build mttest which will fire up 10 threads that talk SSL
+ to each other 10 times.
+ To enable everything to work, the application needs to call
+ 
+ CRYPTO_set_id_callback(id_function);
+ CRYPTO_set_locking_callback(locking_function);
+ 
+ before any multithreading is started.
+ id_function does not need to be defined under Windows NT or 95, the
+ correct function will be called if it is not.  Under unix, getpid()
+ is call if the id_callback is not defined, for solaris this is wrong
+ (since threads id's are not pid's) but under IRIX it is correct
+ (threads are just processes sharing the data segement).
+ 
+ The locking_callback is used to perform locking by the SSLeay library.
+ eg.
+ 
+ void solaris_locking_callback(mode,type,file,line)
+ int mode;
+ int type;
+ char *file;
+ int line;
+ 	{
+ 	if (mode & CRYPTO_LOCK)
+ 		mutex_lock(&(lock_cs[type]));
+ 	else
+ 		mutex_unlock(&(lock_cs[type]));
+ 	}
+ 
+ Now in this case I have used mutexes instead of read/write locks, since they
+ are faster and there are not many read locks in SSLeay, you may as well
+ always use write locks.  file and line are __FILE__ and __LINE__ from
+ the compile and can be usefull when debugging.
+ 
+ Now as you can see, 'type' can be one of a range of values, these values are
+ defined in crypto/crypto.h
+ CRYPTO_get_lock_name(type) will return a text version of what the lock is.
+ There are CRYPTO_NUM_LOCKS locks required, so under solaris, the setup
+ for multi-threading can be
+ 
+ static mutex_t lock_cs[CRYPTO_NUM_LOCKS];
+ 
+ void thread_setup()
+ 	{
+ 	int i;
+ 
+ 	for (i=0; i<CRYPTO_NUM_LOCKS; i++)
+ 		mutex_init(&(lock_cs[i]),USYNC_THREAD,NULL);
+ 	CRYPTO_set_id_callback((unsigned long (*)())solaris_thread_id);
+ 	CRYPTO_set_locking_callback((void (*)())solaris_locking_callback);
+ 	}
+ 
+ As a final note, under Windows NT or Windows 95, you have to be carefull
+ not to mix the various threaded, unthreaded and debug libraries.
+ Normally if they are mixed incorrectly, mttest will crash just after printing
+ out some usage statistics at the end.  This is because the
+ different system libraries use different malloc routines and if
+ data is malloc()ed inside crypt32.dll or ssl32.dll and then free()ed by a
+ different library malloc, things get very confused.
+ 
+ The default SSLeay DLL builds use /MD, so if you use this on your
+ application, things will work as expected.  If you use /MDd,
+ you will probably have to rebuild SSLeay using this flag.
+ I should modify util/mk1mf.pl so it does all this correctly, but 
+ this has not been done yet.
+ 
+ One last warning.  Because locking overheads are actually quite large, the
+ statistics collected against the SSL_CTX for successfull connections etc
+ are not locked when updated.  This does make it possible for these
+ values to be slightly lower than they should be, if you are
+ running multithreaded on a multi-processor box, but this does not really
+ matter much.
+ 
*** /var/spool/ftp/pub/Crypto/SSL/064/SSLeay-0.6.3/./util/crypto.num	Wed Jul 24 23:28:18 1996
--- ./util/crypto.num	Thu Aug 29 23:50:28 1996
***************
*** 585,587 ****
--- 585,595 ----
  EVP_dss1			585
  EVP_desx_cbc			586
  des_xcbc_encrypt		587
+ BIO_set				588
+ CRYPTO_malloc			589
+ CRYPTO_realloc			590
+ CRYPTO_free			591
+ CRYPTO_mem_ctrl			592
+ CRYPTO_mem_leaks		593
+ CRYPTO_mem_leaks_fp		594
+ 
*** /var/spool/ftp/pub/Crypto/SSL/064/SSLeay-0.6.3/./util/mk1mf.pl	Wed Jul 31 10:17:57 1996
--- ./util/mk1mf.pl	Thu Aug 29 23:50:28 1996
***************
*** 165,170 ****
--- 165,172 ----
  	$banner.="\t\@echo documentation for details.\n";
  	}
  
+ $INSTALLTOP =~ s|/|$o|g;
+ 
  $defs= <<"EOF";
  # This makefile has been automatically generated from the SSLeay distribution.
  # This single makefile will build the complete SSLeay distribution and
*** /var/spool/ftp/pub/Crypto/SSL/064/SSLeay-0.6.3/./util/pl/VC-16.pl	Fri Jul 12 11:03:52 1996
--- ./util/pl/VC-16.pl	Thu Aug 29 23:50:32 1996
***************
*** 108,114 ****
  	($Name=$name) =~ tr/a-z/A-Z/;
  
  	$ret.="$target: \$(${Name}OBJ)\n";
! 	$ret.="\t\$(RM) \$(O_$Name)\n";
  
  	# Due to a pathetic line length limit, I unwrap the args.
  	local($lib_names)="";
--- 108,114 ----
  	($Name=$name) =~ tr/a-z/A-Z/;
  
  	$ret.="$target: \$(${Name}OBJ)\n";
! #	$ret.="\t\$(RM) \$(O_$Name)\n";
  
  	# Due to a pathetic line length limit, I unwrap the args.
  	local($lib_names)="";
*** /var/spool/ftp/pub/Crypto/SSL/064/SSLeay-0.6.3/./util/pl/VC-32.pl	Wed Jul 10 09:47:31 1996
--- ./util/pl/VC-32.pl	Thu Aug 29 23:50:32 1996
***************
*** 45,51 ****
  
  $asm='ml /Cp /coff /c /Cx';
  $afile='/Fo';
! if ($noasm)
  	{
  	$bn_mulw_obj='';
  	$bn_mulw_src='';
--- 45,51 ----
  
  $asm='ml /Cp /coff /c /Cx';
  $afile='/Fo';
! if ($no_asm)
  	{
  	$bn_mulw_obj='';
  	$bn_mulw_src='';
***************
*** 74,80 ****
  	$ret.="$target: \$(${Name}OBJ)\n";
  	if (!$shlib)
  		{
! 		$ret.="\t\$(RM) \$(O_$Name)\n";
  		$ret.="\t\$(MKLIB) $lfile$target @<<\n  \$(${Name}OBJ)$ex\n<<\n";
  		}
  	else
--- 74,80 ----
  	$ret.="$target: \$(${Name}OBJ)\n";
  	if (!$shlib)
  		{
! #		$ret.="\t\$(RM) \$(O_$Name)\n";
  		$ret.="\t\$(MKLIB) $lfile$target @<<\n  \$(${Name}OBJ)$ex\n<<\n";
  		}
  	else
*** /var/spool/ftp/pub/Crypto/SSL/064/SSLeay-0.6.3/./util/ssl.num	Wed Jul 24 08:36:22 1996
--- ./util/ssl.num	Thu Aug 29 23:50:28 1996
***************
*** 4,10 ****
  SSL_CTX_new				4
  SSL_CTX_set_cert_verify_cb		5
  SSL_CTX_set_cipher_list			6
! SSL_CTX_set_default_verify		7
  SSL_ERR					8
  SSL_LOG					9
  SSL_SESSION_free			10
--- 4,10 ----
  SSL_CTX_new				4
  SSL_CTX_set_cert_verify_cb		5
  SSL_CTX_set_cipher_list			6
! SSL_CTX_set_verify			7
  SSL_ERR					8
  SSL_LOG					9
  SSL_SESSION_free			10
***************
*** 70,72 ****
--- 70,73 ----
  SSL_set_rfd				70
  SSL_set_wfd				71
  SSL_CTX_set_default_passwd_cb           72
+ SSL_get_cipher_bits		73
Binary files /dev/null and ./ms/.ran differ
Binary files /var/spool/ftp/pub/Crypto/SSL/064/SSLeay-0.6.3/./ms/.rand and ./ms/.rand differ
*** /var/spool/ftp/pub/Crypto/SSL/064/SSLeay-0.6.3/./ms/CERTCA.SRL	Wed Jul 24 20:52:07 1996
--- ./ms/CERTCA.SRL	Thu Aug 29 23:50:27 1996
***************
*** 1 ****
! 2A
--- 1 ----
! 2D
*** /var/spool/ftp/pub/Crypto/SSL/064/SSLeay-0.6.3/./ms/CERTCA.SS	Wed Jul 24 20:51:54 1996
--- ./ms/CERTCA.SS	Thu Aug 29 23:50:27 1996
***************
*** 1,10 ****
  -----BEGIN CERTIFICATE-----
  MIIBXDCCAQYCAQAwDQYJKoZIhvcNAQEEBQAwOTELMAkGA1UEBhMCQVUxFzAVBgNV
  BAoTDkRvZGd5IEJyb3RoZXJzMREwDwYDVQQDEwhEb2RneSBDQTAeFw03MDAxMDEx
! MjAwMDBaFw05NjA4MjMxMDQ5MThaMDkxCzAJBgNVBAYTAkFVMRcwFQYDVQQKEw5E
  b2RneSBCcm90aGVyczERMA8GA1UEAxMIRG9kZ3kgQ0EwXDANBgkqhkiG9w0BAQEF
! AANLADBIAkEAstE7YptkoiP6FfP7h/yvEiI/TMaHzlvvpt3oysyB2hdh4LxJBHk0
! Lj9KwTp/2Y7MhOazTY+lGCTjyHcy2WM4pwIDAQABMA0GCSqGSIb3DQEBBAUAA0EA
! ZCmrsrstxwLeuxv1ec1uiJfhS9qiqcwl8uIDxo/7pjV0DZ+5dN3bIt2kUIVm+DQt
! o06CdWkWssUQeKzKy15gUQ==
  -----END CERTIFICATE-----
--- 1,10 ----
  -----BEGIN CERTIFICATE-----
  MIIBXDCCAQYCAQAwDQYJKoZIhvcNAQEEBQAwOTELMAkGA1UEBhMCQVUxFzAVBgNV
  BAoTDkRvZGd5IEJyb3RoZXJzMREwDwYDVQQDEwhEb2RneSBDQTAeFw03MDAxMDEx
! MjAwMDBaFw05NjA5MjgxNTQ2MjdaMDkxCzAJBgNVBAYTAkFVMRcwFQYDVQQKEw5E
  b2RneSBCcm90aGVyczERMA8GA1UEAxMIRG9kZ3kgQ0EwXDANBgkqhkiG9w0BAQEF
! AANLADBIAkEA0DHM/gRdqIk4tIVZs1OePGtjKPkjEnGwfmo7VFejc3GkSTGA+Kc1
! GPxNffX1600zNvxBUHCbdRKMcq8gZOtOiQIDAQABMA0GCSqGSIb3DQEBBAUAA0EA
! bHiYg4QCtk7WRC4/KRrhNtnTy0Aa+/zHpFJIqe7Jy8p8qCxLqzQgpkxiiK0TVt++
! CkJ6KLGT/TqvbnjBG9z44A==
  -----END CERTIFICATE-----
*** /var/spool/ftp/pub/Crypto/SSL/064/SSLeay-0.6.3/./ms/CERTU.SS	Wed Jul 24 20:52:07 1996
--- ./ms/CERTU.SS	Thu Aug 29 23:50:27 1996
***************
*** 1,10 ****
  -----BEGIN CERTIFICATE-----
! MIIBXTCCAQcCASkwDQYJKoZIhvcNAQEEBQAwOTELMAkGA1UEBhMCQVUxFzAVBgNV
! BAoTDkRvZGd5IEJyb3RoZXJzMREwDwYDVQQDEwhEb2RneSBDQTAeFw05NjA3MjQx
! MDQ5MzFaFw05NjA4MjMxMDQ5MzFaMDoxCzAJBgNVBAYTAkFVMRcwFQYDVQQKEw5E
  b2RneSBCcm90aGVyczESMBAGA1UEAxMJQSBCcm90aGVyMFwwDQYJKoZIhvcNAQEB
! BQADSwAwSAJBANgxVmtg+5HMLTs94Jfx8b/aw1tweGtcr6qnfvngXfHaH420ib8l
! FhfK4kOoN8O9wIsDevJSa4unjUHtYLStvG0CAwEAATANBgkqhkiG9w0BAQQFAANB
! AEExW1khAtwVtA1k590bSx3ra2mPkpOPancf9hdX9NgP5WxzDbF1YSsMAlGWRZab
! /F88dlDPpqJ62llEnw4sz9E=
  -----END CERTIFICATE-----
--- 1,10 ----
  -----BEGIN CERTIFICATE-----
! MIIBXTCCAQcCASwwDQYJKoZIhvcNAQEEBQAwOTELMAkGA1UEBhMCQVUxFzAVBgNV
! BAoTDkRvZGd5IEJyb3RoZXJzMREwDwYDVQQDEwhEb2RneSBDQTAeFw05NjA4Mjkx
! NTQ2NDNaFw05NjA5MjgxNTQ2NDNaMDoxCzAJBgNVBAYTAkFVMRcwFQYDVQQKEw5E
  b2RneSBCcm90aGVyczESMBAGA1UEAxMJQSBCcm90aGVyMFwwDQYJKoZIhvcNAQEB
! BQADSwAwSAJBANYUVgbn8r6FPV1Bm2C2qdLiv0cvd6JVgIfSFTomowxHW6Tqkzgn
! EJlcmljZMI7s0Fz0G/HTJi8GAWgrO9u1OT0CAwEAATANBgkqhkiG9w0BAQQFAANB
! ADPbvnIrWYjR11RMMuW9zZ9MC9fT8gJOy1x4U7sHF3S3lAqh8/LR3GzzLFgG2k9h
! Ug/Rfbz9MkVtFfUMWz0rHgw=
  -----END CERTIFICATE-----
*** /var/spool/ftp/pub/Crypto/SSL/064/SSLeay-0.6.3/./ms/crypto16.def	Thu Aug  8 01:54:54 1996
--- ./ms/crypto16.def	Fri Aug 30 04:41:25 1996
***************
*** 62,67 ****
--- 62,68 ----
      _BIO_s_mem                          @47
      _BIO_s_null                         @48
      _BIO_s_socket                       @49
+     _BIO_set                            @588
      _BIO_write                          @50
      _BN_CTX_free                        @51
      _BN_CTX_new                         @52
***************
*** 127,137 ****
--- 128,143 ----
      _CONF_get_string                    @113
      _CONF_load                          @114
      _CRYPTO_add_lock                    @582
+     _CRYPTO_free                        @591
      _CRYPTO_get_add_lock_callback       @580
      _CRYPTO_get_id_callback             @115
      _CRYPTO_get_lock_name               @583
      _CRYPTO_get_locking_callback        @116
      _CRYPTO_lock                        @117
+     _CRYPTO_malloc                      @589
+     _CRYPTO_mem_ctrl                    @592
+     _CRYPTO_mem_leaks                   @593
+     _CRYPTO_realloc                     @590
      _CRYPTO_set_add_lock_callback       @581
      _CRYPTO_set_id_callback             @118
      _CRYPTO_set_locking_callback        @119
*** /var/spool/ftp/pub/Crypto/SSL/064/SSLeay-0.6.3/./ms/crypto32.def	Thu Aug  8 01:54:56 1996
--- ./ms/crypto32.def	Fri Aug 30 04:41:27 1996
***************
*** 56,61 ****
--- 56,62 ----
      BIO_s_mem                          @47
      BIO_s_null                         @48
      BIO_s_socket                       @49
+     BIO_set                            @588
      BIO_write                          @50
      BN_CTX_free                        @51
      BN_CTX_new                         @52
***************
*** 122,132 ****
--- 123,139 ----
      CONF_get_string                    @113
      CONF_load                          @114
      CRYPTO_add_lock                    @582
+     CRYPTO_free                        @591
      CRYPTO_get_add_lock_callback       @580
      CRYPTO_get_id_callback             @115
      CRYPTO_get_lock_name               @583
      CRYPTO_get_locking_callback        @116
      CRYPTO_lock                        @117
+     CRYPTO_malloc                      @589
+     CRYPTO_mem_ctrl                    @592
+     CRYPTO_mem_leaks                   @593
+     CRYPTO_mem_leaks_fp                @594
+     CRYPTO_realloc                     @590
      CRYPTO_set_add_lock_callback       @581
      CRYPTO_set_id_callback             @118
      CRYPTO_set_locking_callback        @119
*** /var/spool/ftp/pub/Crypto/SSL/064/SSLeay-0.6.3/./ms/KEYCA.SS	Wed Jul 24 20:51:53 1996
--- ./ms/KEYCA.SS	Thu Aug 29 23:50:27 1996
***************
*** 1,9 ****
  -----BEGIN RSA PRIVATE KEY-----
! MIIBOwIBAAJBALLRO2KbZKIj+hXz+4f8rxIiP0zGh85b76bd6MrMgdoXYeC8SQR5
! NC4/SsE6f9mOzITms02PpRgk48h3MtljOKcCAwEAAQJACnudoaA+fArj5FmTS1uS
! 39tGHrgcygo1uHCV7x2iFyjikHqpdJfdL6qn4MFTskdUt1nYcfa/oj57kVEnGGr/
! AQIhAOq1wWUjU9jV6L00PsnYTJ7eBdR5QlrUlq704PcuSFFBAiEAwwmVFLQl55Hr
! LCyNmthpSqhwrQBVLfIfnB6RAiCBJ+cCIQCX5SqUtokz4jOuBtq/rBDiG5OwTw1n
! VP9zmJziuvwoQQIgaF4yVrfoKLke/a6BwEDaZ0cntIwfCM0uOR7qPhcixjUCIQDI
! UoXzsduS4isiiuMcTV+mAJADt9595Q0U/LopxkoOug==
  -----END RSA PRIVATE KEY-----
--- 1,9 ----
  -----BEGIN RSA PRIVATE KEY-----
! MIIBPAIBAAJBANAxzP4EXaiJOLSFWbNTnjxrYyj5IxJxsH5qO1RXo3NxpEkxgPin
! NRj8TX319etNMzb8QVBwm3USjHKvIGTrTokCAwEAAQJAV1XMzHJAZ8bIhtG5w0Q8
! iNPzkOiSEdanVyBxKvxokLBEyWS/3oLMUJzVnYuk4m9rn88H/95aVQvHzb+PC/YF
! 0QIhAP4XNv4P4clodCyart5TO4LKq0oHQHVmet0o0b4I/sbPAiEA0cJMEis7it73
! 4vX2zUQ5Ck7KsQxEWngrLPvM82d16ycCIQDgeU3iAdHtB1SrGzSlwU5v6/CLhACU
! NycQP0Gc64F5zQIhAIcVBmJI/y5eiurZlZf5UHaH6VZ9XOOaMcvlWMaDoVfPAiEA
! 5yYa7HYxT3GNJX6EdJJb3J/+0VQAIrWNai0mBSrlMUk=
  -----END RSA PRIVATE KEY-----
*** /var/spool/ftp/pub/Crypto/SSL/064/SSLeay-0.6.3/./ms/KEYU.SS	Wed Jul 24 20:52:05 1996
--- ./ms/KEYU.SS	Thu Aug 29 23:50:27 1996
***************
*** 1,9 ****
  -----BEGIN RSA PRIVATE KEY-----
! MIIBOgIBAAJBANgxVmtg+5HMLTs94Jfx8b/aw1tweGtcr6qnfvngXfHaH420ib8l
! FhfK4kOoN8O9wIsDevJSa4unjUHtYLStvG0CAwEAAQJBALN5UerWmkHRJIOXvMmn
! GzBQZfmVBwLp8RNU9X5vGs5Y5VeHwNV5Q4ynnNU2hLYyE1lnXDc32WP2mGAWRtUV
! ZekCIQDs+gavonTVFIyXWHt8363cOe75ioDGJZCgSxKL7Ty4CwIhAOmMMUL9JK28
! NKiSAHGKUVOoUG9OVZm2J/UcWn4lnRBnAiAvYvvNSS4VoctPRElFOjE49Xi8+54u
! gTp/YyOtSV436wIgd7VcKrIGcubdNupfP9NeDDthvyuvxLIRmRmHaNFuyFECIFYC
! Xh61F/rOeGsh0Lc1PfoDcDQ9oUodT4ak7G4wxhQX
  -----END RSA PRIVATE KEY-----
--- 1,9 ----
  -----BEGIN RSA PRIVATE KEY-----
! MIIBOwIBAAJBANYUVgbn8r6FPV1Bm2C2qdLiv0cvd6JVgIfSFTomowxHW6Tqkzgn
! EJlcmljZMI7s0Fz0G/HTJi8GAWgrO9u1OT0CAwEAAQJBAJQMrk3KXQLLTFvRAm6J
! BLsWGuhU+GxoqyHC9PEpRTs4XmQtuGDJy+lMmHZIAnymC6ju29nAOAZDpS3Uo8wS
! wyECIQDsnvR+gJLfW/zW2nZ7MrBvpHdSnvfFuA7B7dqsKiiGWQIhAOecxX8RI1iB
! qlWfbP1ffH2OOq9fKJ0TCvPZcfZKrzWFAiAZEGVZmQj1u+q2X4G5Xw8tZEB3cftQ
! 6EQ36pgFMJoGUQIgENNhwZZkI/Tfg/Ld/xYlvBVODBl0oNyWShq83bCVQ+UCIQCF
! c60uPhGI0ycI1KVnogVBA6Avtusz3DXywjf4sdvh/A==
  -----END RSA PRIVATE KEY-----
*** /var/spool/ftp/pub/Crypto/SSL/064/SSLeay-0.6.3/./ms/msdos.mak	Thu Aug  8 01:54:50 1996
--- ./ms/msdos.mak	Fri Aug 30 04:41:21 1996
***************
*** 11,17 ****
  # The one monster makefile better suits building in non-unix
  # environments.
  
! INSTALLTOP=/usr/local/ssl
  
  # Set your compiler options
  CC=cl
--- 11,17 ----
  # The one monster makefile better suits building in non-unix
  # environments.
  
! INSTALLTOP=\usr\local\ssl
  
  # Set your compiler options
  CC=cl
***************
*** 124,204 ****
  	$(OBJ_D)\crl2p7.obj $(OBJ_D)\crl.obj $(OBJ_D)\rsa.obj \
  	$(OBJ_D)\x509.obj $(OBJ_D)\genrsa.obj $(OBJ_D)\speed.obj \
  	$(OBJ_D)\hashdir.obj $(OBJ_D)\apps.obj $(OBJ_D)\version.obj \
! 	$(OBJ_D)\sess_id.obj $(OBJ_D)\ssleay.obj
  
  CRYPTOOBJ=$(OBJ_D)\cryptlib.obj \
! 	$(OBJ_D)\md2_dgst.obj $(OBJ_D)\md5_dgst.obj $(OBJ_D)\md2_one.obj \
! 	$(OBJ_D)\md5_one.obj $(OBJ_D)\sha_dgst.obj $(OBJ_D)\sha1dgst.obj \
! 	$(OBJ_D)\sha_one.obj $(OBJ_D)\sha1_one.obj $(OBJ_D)\set_key.obj \
! 	$(OBJ_D)\ecb_enc.obj $(OBJ_D)\ede_enc.obj $(OBJ_D)\cbc_enc.obj \
! 	$(OBJ_D)\cbc3_enc.obj $(OBJ_D)\ecb3_enc.obj $(OBJ_D)\cfb64enc.obj \
! 	$(OBJ_D)\cfb64ede.obj $(OBJ_D)\cfb_enc.obj $(OBJ_D)\ofb64ede.obj \
! 	$(OBJ_D)\enc_read.obj $(OBJ_D)\enc_writ.obj $(OBJ_D)\fcrypt.obj \
! 	$(OBJ_D)\ncbc_enc.obj $(OBJ_D)\ofb64enc.obj $(OBJ_D)\ofb_enc.obj \
! 	$(OBJ_D)\str2key.obj $(OBJ_D)\pcbc_enc.obj $(OBJ_D)\qud_cksm.obj \
! 	$(OBJ_D)\rand_key.obj $(OBJ_D)\xcbc_enc.obj $(OBJ_D)\read_pwd.obj \
! 	$(OBJ_D)\rpc_enc.obj $(OBJ_D)\cbc_cksm.obj $(OBJ_D)\supp.obj \
! 	$(OBJ_D)\rc4_enc.obj $(OBJ_D)\rc2_ecb.obj $(OBJ_D)\rc2_skey.obj \
! 	$(OBJ_D)\rc2_cbc.obj $(OBJ_D)\rc2cfb64.obj $(OBJ_D)\rc2ofb64.obj \
! 	$(OBJ_D)\i_cbc.obj $(OBJ_D)\i_cfb64.obj $(OBJ_D)\i_ofb64.obj \
! 	$(OBJ_D)\i_ecb.obj $(OBJ_D)\i_skey.obj $(OBJ_D)\bn_add.obj \
! 	$(OBJ_D)\bn_div.obj $(OBJ_D)\bn_exp.obj $(OBJ_D)\bn_lib.obj \
! 	$(OBJ_D)\bn_mod.obj $(OBJ_D)\bn_mul.obj $(OBJ_D)\bn_print.obj \
! 	$(OBJ_D)\bn_rand.obj $(OBJ_D)\bn_shift.obj $(OBJ_D)\bn_sub.obj \
! 	$(OBJ_D)\bn_word.obj $(OBJ_D)\bn_gcd.obj $(OBJ_D)\bn_prime.obj \
! 	$(OBJ_D)\bn_err.obj $(OBJ_D)\bn_sqr.obj $(BN_MULW_OBJ) \
! 	$(OBJ_D)\bn_recp.obj $(OBJ_D)\bn_mont.obj $(OBJ_D)\rsa_enc.obj \
! 	$(OBJ_D)\rsa_gen.obj $(OBJ_D)\rsa_lib.obj $(OBJ_D)\rsa_sign.obj \
! 	$(OBJ_D)\rsa_err.obj $(OBJ_D)\dsa_lib.obj $(OBJ_D)\dsa_vrf.obj \
! 	$(OBJ_D)\dsa_sign.obj $(OBJ_D)\dsa_err.obj $(OBJ_D)\dh_gen.obj \
! 	$(OBJ_D)\dh_key.obj $(OBJ_D)\dh_lib.obj $(OBJ_D)\dh_check.obj \
! 	$(OBJ_D)\dh_err.obj $(OBJ_D)\buffer.obj $(OBJ_D)\bio_lib.obj \
! 	$(OBJ_D)\bio_cb.obj $(OBJ_D)\buf_err.obj $(OBJ_D)\bss_mem.obj \
! 	$(OBJ_D)\bss_null.obj $(OBJ_D)\bss_fd.obj $(OBJ_D)\bss_file.obj \
! 	$(OBJ_D)\bss_sock.obj $(OBJ_D)\bf_buff.obj $(OBJ_D)\stack.obj \
! 	$(OBJ_D)\lhash.obj $(OBJ_D)\lh_stats.obj $(OBJ_D)\md5_rand.obj \
! 	$(OBJ_D)\randfile.obj $(OBJ_D)\err.obj $(OBJ_D)\err_all.obj \
! 	$(OBJ_D)\obj_dat.obj $(OBJ_D)\obj_lib.obj $(OBJ_D)\obj_err.obj \
! 	$(OBJ_D)\encode.obj $(OBJ_D)\digest.obj $(OBJ_D)\evp_enc.obj \
! 	$(OBJ_D)\evp_key.obj $(OBJ_D)\e_ecb_d.obj $(OBJ_D)\e_cbc_d.obj \
! 	$(OBJ_D)\e_cfb_d.obj $(OBJ_D)\e_ofb_d.obj $(OBJ_D)\e_ecb_i.obj \
! 	$(OBJ_D)\e_cbc_i.obj $(OBJ_D)\e_cfb_i.obj $(OBJ_D)\e_ofb_i.obj \
! 	$(OBJ_D)\e_ecb_3d.obj $(OBJ_D)\e_cbc_3d.obj $(OBJ_D)\e_rc4.obj \
! 	$(OBJ_D)\e_names.obj $(OBJ_D)\e_cfb_3d.obj $(OBJ_D)\e_ofb_3d.obj \
! 	$(OBJ_D)\e_xcbc_d.obj $(OBJ_D)\e_ecb_r2.obj $(OBJ_D)\e_cbc_r2.obj \
! 	$(OBJ_D)\e_cfb_r2.obj $(OBJ_D)\e_ofb_r2.obj $(OBJ_D)\m_md2.obj \
! 	$(OBJ_D)\m_md5.obj $(OBJ_D)\m_sha.obj $(OBJ_D)\m_sha1.obj \
! 	$(OBJ_D)\m_dss.obj $(OBJ_D)\m_dss1.obj $(OBJ_D)\m_names.obj \
! 	$(OBJ_D)\p_open.obj $(OBJ_D)\p_seal.obj $(OBJ_D)\p_sign.obj \
! 	$(OBJ_D)\p_verify.obj $(OBJ_D)\p_lib.obj $(OBJ_D)\bio_md.obj \
! 	$(OBJ_D)\evp_err.obj $(OBJ_D)\pem_sign.obj $(OBJ_D)\pem_seal.obj \
! 	$(OBJ_D)\pem_info.obj $(OBJ_D)\pem_lib.obj $(OBJ_D)\pem_err.obj \
! 	$(OBJ_D)\x509_def.obj $(OBJ_D)\x509_r2x.obj $(OBJ_D)\x509_cmp.obj \
! 	$(OBJ_D)\x509_obj.obj $(OBJ_D)\x509_req.obj $(OBJ_D)\x509_vrf.obj \
! 	$(OBJ_D)\x509_crt.obj $(OBJ_D)\x509_ath.obj $(OBJ_D)\x509_err.obj \
! 	$(OBJ_D)\a_object.obj $(OBJ_D)\a_bitstr.obj $(OBJ_D)\a_utctm.obj \
! 	$(OBJ_D)\a_int.obj $(OBJ_D)\a_octet.obj $(OBJ_D)\a_print.obj \
! 	$(OBJ_D)\a_type.obj $(OBJ_D)\a_set.obj $(OBJ_D)\a_dup.obj \
! 	$(OBJ_D)\a_d2i_fp.obj $(OBJ_D)\a_i2d_fp.obj $(OBJ_D)\a_sign.obj \
! 	$(OBJ_D)\a_verify.obj $(OBJ_D)\x_algor.obj $(OBJ_D)\x_val.obj \
! 	$(OBJ_D)\x_pubkey.obj $(OBJ_D)\x_sig.obj $(OBJ_D)\x_req.obj \
! 	$(OBJ_D)\x_attrib.obj $(OBJ_D)\x_name.obj $(OBJ_D)\x_cinf.obj \
! 	$(OBJ_D)\x_x509.obj $(OBJ_D)\x_crl.obj $(OBJ_D)\x_info.obj \
! 	$(OBJ_D)\x_spki.obj $(OBJ_D)\d2i_r_pr.obj $(OBJ_D)\i2d_r_pr.obj \
! 	$(OBJ_D)\d2i_r_pu.obj $(OBJ_D)\i2d_r_pu.obj $(OBJ_D)\d2i_s_pr.obj \
! 	$(OBJ_D)\d2i_s_pu.obj $(OBJ_D)\d2i_pu.obj $(OBJ_D)\d2i_pr.obj \
! 	$(OBJ_D)\i2d_pu.obj $(OBJ_D)\i2d_pr.obj $(OBJ_D)\t_req.obj \
! 	$(OBJ_D)\t_x509.obj $(OBJ_D)\t_pkey.obj $(OBJ_D)\p7_i_s.obj \
! 	$(OBJ_D)\p7_signi.obj $(OBJ_D)\p7_signd.obj $(OBJ_D)\p7_recip.obj \
! 	$(OBJ_D)\p7_enc_c.obj $(OBJ_D)\p7_evp.obj $(OBJ_D)\p7_dgst.obj \
! 	$(OBJ_D)\p7_s_e.obj $(OBJ_D)\p7_enc.obj $(OBJ_D)\p7_lib.obj \
! 	$(OBJ_D)\f_int.obj $(OBJ_D)\i2d_dh.obj $(OBJ_D)\d2i_dh.obj \
! 	$(OBJ_D)\n_pkey.obj $(OBJ_D)\a_hdr.obj $(OBJ_D)\x_pkey.obj \
! 	$(OBJ_D)\a_bool.obj $(OBJ_D)\x_exten.obj $(OBJ_D)\asn1_par.obj \
! 	$(OBJ_D)\asn1_lib.obj $(OBJ_D)\asn1_err.obj $(OBJ_D)\meth_lib.obj \
! 	$(OBJ_D)\x509meth.obj $(OBJ_D)\by_file.obj $(OBJ_D)\by_dir.obj \
! 	$(OBJ_D)\meth_err.obj $(OBJ_D)\conf.obj $(OBJ_D)\conf_err.obj \
! 	$(OBJ_D)\txt_db.obj
  
  SSLOBJ=$(OBJ_D)\ssl_lib.obj \
  	$(OBJ_D)\ssl_err2.obj $(OBJ_D)\ssl_trc.obj $(OBJ_D)\ssl_cert.obj \
--- 124,204 ----
  	$(OBJ_D)\crl2p7.obj $(OBJ_D)\crl.obj $(OBJ_D)\rsa.obj \
  	$(OBJ_D)\x509.obj $(OBJ_D)\genrsa.obj $(OBJ_D)\speed.obj \
  	$(OBJ_D)\hashdir.obj $(OBJ_D)\apps.obj $(OBJ_D)\version.obj \
! 	$(OBJ_D)\sess_id.obj $(OBJ_D)\ciphers.obj $(OBJ_D)\ssleay.obj
  
  CRYPTOOBJ=$(OBJ_D)\cryptlib.obj \
! 	$(OBJ_D)\mem.obj $(OBJ_D)\md2_dgst.obj $(OBJ_D)\md5_dgst.obj \
! 	$(OBJ_D)\md2_one.obj $(OBJ_D)\md5_one.obj $(OBJ_D)\sha_dgst.obj \
! 	$(OBJ_D)\sha1dgst.obj $(OBJ_D)\sha_one.obj $(OBJ_D)\sha1_one.obj \
! 	$(OBJ_D)\set_key.obj $(OBJ_D)\ecb_enc.obj $(OBJ_D)\ede_enc.obj \
! 	$(OBJ_D)\cbc_enc.obj $(OBJ_D)\cbc3_enc.obj $(OBJ_D)\ecb3_enc.obj \
! 	$(OBJ_D)\cfb64enc.obj $(OBJ_D)\cfb64ede.obj $(OBJ_D)\cfb_enc.obj \
! 	$(OBJ_D)\ofb64ede.obj $(OBJ_D)\enc_read.obj $(OBJ_D)\enc_writ.obj \
! 	$(OBJ_D)\fcrypt.obj $(OBJ_D)\ncbc_enc.obj $(OBJ_D)\ofb64enc.obj \
! 	$(OBJ_D)\ofb_enc.obj $(OBJ_D)\str2key.obj $(OBJ_D)\pcbc_enc.obj \
! 	$(OBJ_D)\qud_cksm.obj $(OBJ_D)\rand_key.obj $(OBJ_D)\xcbc_enc.obj \
! 	$(OBJ_D)\read_pwd.obj $(OBJ_D)\rpc_enc.obj $(OBJ_D)\cbc_cksm.obj \
! 	$(OBJ_D)\supp.obj $(OBJ_D)\rc4_enc.obj $(OBJ_D)\rc2_ecb.obj \
! 	$(OBJ_D)\rc2_skey.obj $(OBJ_D)\rc2_cbc.obj $(OBJ_D)\rc2cfb64.obj \
! 	$(OBJ_D)\rc2ofb64.obj $(OBJ_D)\i_cbc.obj $(OBJ_D)\i_cfb64.obj \
! 	$(OBJ_D)\i_ofb64.obj $(OBJ_D)\i_ecb.obj $(OBJ_D)\i_skey.obj \
! 	$(OBJ_D)\bn_add.obj $(OBJ_D)\bn_div.obj $(OBJ_D)\bn_exp.obj \
! 	$(OBJ_D)\bn_lib.obj $(OBJ_D)\bn_mod.obj $(OBJ_D)\bn_mul.obj \
! 	$(OBJ_D)\bn_print.obj $(OBJ_D)\bn_rand.obj $(OBJ_D)\bn_shift.obj \
! 	$(OBJ_D)\bn_sub.obj $(OBJ_D)\bn_word.obj $(OBJ_D)\bn_gcd.obj \
! 	$(OBJ_D)\bn_prime.obj $(OBJ_D)\bn_err.obj $(OBJ_D)\bn_sqr.obj \
! 	$(BN_MULW_OBJ) $(OBJ_D)\bn_recp.obj $(OBJ_D)\bn_mont.obj \
! 	$(OBJ_D)\rsa_enc.obj $(OBJ_D)\rsa_gen.obj $(OBJ_D)\rsa_lib.obj \
! 	$(OBJ_D)\rsa_sign.obj $(OBJ_D)\rsa_err.obj $(OBJ_D)\dsa_lib.obj \
! 	$(OBJ_D)\dsa_vrf.obj $(OBJ_D)\dsa_sign.obj $(OBJ_D)\dsa_err.obj \
! 	$(OBJ_D)\dh_gen.obj $(OBJ_D)\dh_key.obj $(OBJ_D)\dh_lib.obj \
! 	$(OBJ_D)\dh_check.obj $(OBJ_D)\dh_err.obj $(OBJ_D)\buffer.obj \
! 	$(OBJ_D)\bio_lib.obj $(OBJ_D)\bio_cb.obj $(OBJ_D)\buf_err.obj \
! 	$(OBJ_D)\bss_mem.obj $(OBJ_D)\bss_null.obj $(OBJ_D)\bss_fd.obj \
! 	$(OBJ_D)\bss_file.obj $(OBJ_D)\bss_sock.obj $(OBJ_D)\bf_buff.obj \
! 	$(OBJ_D)\stack.obj $(OBJ_D)\lhash.obj $(OBJ_D)\lh_stats.obj \
! 	$(OBJ_D)\md5_rand.obj $(OBJ_D)\randfile.obj $(OBJ_D)\err.obj \
! 	$(OBJ_D)\err_all.obj $(OBJ_D)\obj_dat.obj $(OBJ_D)\obj_lib.obj \
! 	$(OBJ_D)\obj_err.obj $(OBJ_D)\encode.obj $(OBJ_D)\digest.obj \
! 	$(OBJ_D)\evp_enc.obj $(OBJ_D)\evp_key.obj $(OBJ_D)\e_ecb_d.obj \
! 	$(OBJ_D)\e_cbc_d.obj $(OBJ_D)\e_cfb_d.obj $(OBJ_D)\e_ofb_d.obj \
! 	$(OBJ_D)\e_ecb_i.obj $(OBJ_D)\e_cbc_i.obj $(OBJ_D)\e_cfb_i.obj \
! 	$(OBJ_D)\e_ofb_i.obj $(OBJ_D)\e_ecb_3d.obj $(OBJ_D)\e_cbc_3d.obj \
! 	$(OBJ_D)\e_rc4.obj $(OBJ_D)\e_names.obj $(OBJ_D)\e_cfb_3d.obj \
! 	$(OBJ_D)\e_ofb_3d.obj $(OBJ_D)\e_xcbc_d.obj $(OBJ_D)\e_ecb_r2.obj \
! 	$(OBJ_D)\e_cbc_r2.obj $(OBJ_D)\e_cfb_r2.obj $(OBJ_D)\e_ofb_r2.obj \
! 	$(OBJ_D)\m_md2.obj $(OBJ_D)\m_md5.obj $(OBJ_D)\m_sha.obj \
! 	$(OBJ_D)\m_sha1.obj $(OBJ_D)\m_dss.obj $(OBJ_D)\m_dss1.obj \
! 	$(OBJ_D)\m_names.obj $(OBJ_D)\p_open.obj $(OBJ_D)\p_seal.obj \
! 	$(OBJ_D)\p_sign.obj $(OBJ_D)\p_verify.obj $(OBJ_D)\p_lib.obj \
! 	$(OBJ_D)\bio_md.obj $(OBJ_D)\evp_err.obj $(OBJ_D)\pem_sign.obj \
! 	$(OBJ_D)\pem_seal.obj $(OBJ_D)\pem_info.obj $(OBJ_D)\pem_lib.obj \
! 	$(OBJ_D)\pem_err.obj $(OBJ_D)\x509_def.obj $(OBJ_D)\x509_r2x.obj \
! 	$(OBJ_D)\x509_cmp.obj $(OBJ_D)\x509_obj.obj $(OBJ_D)\x509_req.obj \
! 	$(OBJ_D)\x509_vrf.obj $(OBJ_D)\x509_crt.obj $(OBJ_D)\x509_ath.obj \
! 	$(OBJ_D)\x509_err.obj $(OBJ_D)\a_object.obj $(OBJ_D)\a_bitstr.obj \
! 	$(OBJ_D)\a_utctm.obj $(OBJ_D)\a_int.obj $(OBJ_D)\a_octet.obj \
! 	$(OBJ_D)\a_print.obj $(OBJ_D)\a_type.obj $(OBJ_D)\a_set.obj \
! 	$(OBJ_D)\a_dup.obj $(OBJ_D)\a_d2i_fp.obj $(OBJ_D)\a_i2d_fp.obj \
! 	$(OBJ_D)\a_sign.obj $(OBJ_D)\a_verify.obj $(OBJ_D)\x_algor.obj \
! 	$(OBJ_D)\x_val.obj $(OBJ_D)\x_pubkey.obj $(OBJ_D)\x_sig.obj \
! 	$(OBJ_D)\x_req.obj $(OBJ_D)\x_attrib.obj $(OBJ_D)\x_name.obj \
! 	$(OBJ_D)\x_cinf.obj $(OBJ_D)\x_x509.obj $(OBJ_D)\x_crl.obj \
! 	$(OBJ_D)\x_info.obj $(OBJ_D)\x_spki.obj $(OBJ_D)\d2i_r_pr.obj \
! 	$(OBJ_D)\i2d_r_pr.obj $(OBJ_D)\d2i_r_pu.obj $(OBJ_D)\i2d_r_pu.obj \
! 	$(OBJ_D)\d2i_s_pr.obj $(OBJ_D)\d2i_s_pu.obj $(OBJ_D)\d2i_pu.obj \
! 	$(OBJ_D)\d2i_pr.obj $(OBJ_D)\i2d_pu.obj $(OBJ_D)\i2d_pr.obj \
! 	$(OBJ_D)\t_req.obj $(OBJ_D)\t_x509.obj $(OBJ_D)\t_pkey.obj \
! 	$(OBJ_D)\p7_i_s.obj $(OBJ_D)\p7_signi.obj $(OBJ_D)\p7_signd.obj \
! 	$(OBJ_D)\p7_recip.obj $(OBJ_D)\p7_enc_c.obj $(OBJ_D)\p7_evp.obj \
! 	$(OBJ_D)\p7_dgst.obj $(OBJ_D)\p7_s_e.obj $(OBJ_D)\p7_enc.obj \
! 	$(OBJ_D)\p7_lib.obj $(OBJ_D)\f_int.obj $(OBJ_D)\i2d_dh.obj \
! 	$(OBJ_D)\d2i_dh.obj $(OBJ_D)\n_pkey.obj $(OBJ_D)\a_hdr.obj \
! 	$(OBJ_D)\x_pkey.obj $(OBJ_D)\a_bool.obj $(OBJ_D)\x_exten.obj \
! 	$(OBJ_D)\asn1_par.obj $(OBJ_D)\asn1_lib.obj $(OBJ_D)\asn1_err.obj \
! 	$(OBJ_D)\meth_lib.obj $(OBJ_D)\x509meth.obj $(OBJ_D)\by_file.obj \
! 	$(OBJ_D)\by_dir.obj $(OBJ_D)\meth_err.obj $(OBJ_D)\conf.obj \
! 	$(OBJ_D)\conf_err.obj $(OBJ_D)\txt_db.obj
  
  SSLOBJ=$(OBJ_D)\ssl_lib.obj \
  	$(OBJ_D)\ssl_err2.obj $(OBJ_D)\ssl_trc.obj $(OBJ_D)\ssl_cert.obj \
***************
*** 539,544 ****
--- 539,547 ----
  $(OBJ_D)\sess_id.obj: $(SRC_D)\apps\sess_id.c
  	$(CC) /Fo$(OBJ_D)\sess_id.obj -DMONOLITH $(APP_CFLAGS) -c $(SRC_D)\apps\sess_id.c
  
+ $(OBJ_D)\ciphers.obj: $(SRC_D)\apps\ciphers.c
+ 	$(CC) /Fo$(OBJ_D)\ciphers.obj -DMONOLITH $(APP_CFLAGS) -c $(SRC_D)\apps\ciphers.c
+ 
  $(OBJ_D)\ssleay.obj: $(SRC_D)\apps\ssleay.c
  	$(CC) /Fo$(OBJ_D)\ssleay.obj -DMONOLITH $(APP_CFLAGS) -c $(SRC_D)\apps\ssleay.c
  
***************
*** 548,553 ****
--- 551,559 ----
  $(OBJ_D)\cryptlib.obj: $(SRC_D)\crypto\cryptlib.c
  	$(CC) /Fo$(OBJ_D)\cryptlib.obj $(LIB_CFLAGS) -DCFLAGS="\"$(CC) $(CFLAG)\"" -c $(SRC_D)\crypto\cryptlib.c
  
+ $(OBJ_D)\mem.obj: $(SRC_D)\crypto\mem.c
+ 	$(CC) /Fo$(OBJ_D)\mem.obj $(LIB_CFLAGS) -c $(SRC_D)\crypto\mem.c
+ 
  $(OBJ_D)\md2_dgst.obj: $(SRC_D)\crypto\md\md2_dgst.c
  	$(CC) /Fo$(OBJ_D)\md2_dgst.obj $(LIB_CFLAGS) -c $(SRC_D)\crypto\md\md2_dgst.c
  
***************
*** 1371,1377 ****
  <<
  
  $(O_SSL): $(SSLOBJ)
- 	$(RM) $(O_SSL)
  	$(MKLIB) @<<
  $(O_SSL)
  y
--- 1377,1382 ----
***************
*** 1402,1408 ****
  <<
  
  $(O_RSAGLUE): $(RSAGLUEOBJ)
- 	$(RM) $(O_RSAGLUE)
  	$(MKLIB) @<<
  $(O_RSAGLUE)
  y
--- 1407,1412 ----
***************
*** 1413,1419 ****
  <<
  
  $(O_CRYPTO): $(CRYPTOOBJ)
- 	$(RM) $(O_CRYPTO)
  	$(MKLIB) @<<
  $(O_CRYPTO)
  y
--- 1417,1422 ----
***************
*** 1548,1553 ****
--- 1551,1557 ----
  +$(OBJ_D)\md5_dgst.obj &
  +$(OBJ_D)\md5_one.obj &
  +$(OBJ_D)\md5_rand.obj &
+ +$(OBJ_D)\mem.obj &
  +$(OBJ_D)\meth_err.obj &
  +$(OBJ_D)\meth_lib.obj &
  +$(OBJ_D)\n_pkey.obj &
***************
*** 1642,1647 ****
--- 1646,1652 ----
    $(OBJ_D)\apps.obj +
    $(OBJ_D)\asn1pars.obj +
    $(OBJ_D)\ca.obj +
+   $(OBJ_D)\ciphers.obj +
    $(OBJ_D)\crl.obj +
    $(OBJ_D)\crl2p7.obj +
    $(OBJ_D)\dgst.obj +
*** /var/spool/ftp/pub/Crypto/SSL/064/SSLeay-0.6.3/./ms/nt.mak	Thu Aug  8 01:54:52 1996
--- ./ms/nt.mak	Fri Aug 30 04:41:23 1996
***************
*** 11,17 ****
  # The one monster makefile better suits building in non-unix
  # environments.
  
! INSTALLTOP=/usr/local/ssl
  
  # Set your compiler options
  CC=cl
--- 11,17 ----
  # The one monster makefile better suits building in non-unix
  # environments.
  
! INSTALLTOP=\usr\local\ssl
  
  # Set your compiler options
  CC=cl
***************
*** 128,208 ****
  	$(OBJ_D)\hashdir.obj $(OBJ_D)\s_time.obj $(OBJ_D)\s_mult.obj \
  	$(OBJ_D)\apps.obj $(OBJ_D)\s_cb.obj $(OBJ_D)\s_socket.obj \
  	$(OBJ_D)\s_eio.obj $(OBJ_D)\version.obj $(OBJ_D)\sess_id.obj \
! 	$(OBJ_D)\ssleay.obj
  
  CRYPTOOBJ=$(OBJ_D)\cryptlib.obj \
! 	$(OBJ_D)\md2_dgst.obj $(OBJ_D)\md5_dgst.obj $(OBJ_D)\md2_one.obj \
! 	$(OBJ_D)\md5_one.obj $(OBJ_D)\sha_dgst.obj $(OBJ_D)\sha1dgst.obj \
! 	$(OBJ_D)\sha_one.obj $(OBJ_D)\sha1_one.obj $(OBJ_D)\set_key.obj \
! 	$(OBJ_D)\ecb_enc.obj $(OBJ_D)\ede_enc.obj $(OBJ_D)\cbc_enc.obj \
! 	$(OBJ_D)\cbc3_enc.obj $(OBJ_D)\ecb3_enc.obj $(OBJ_D)\cfb64enc.obj \
! 	$(OBJ_D)\cfb64ede.obj $(OBJ_D)\cfb_enc.obj $(OBJ_D)\ofb64ede.obj \
! 	$(OBJ_D)\enc_read.obj $(OBJ_D)\enc_writ.obj $(OBJ_D)\fcrypt.obj \
! 	$(OBJ_D)\ncbc_enc.obj $(OBJ_D)\ofb64enc.obj $(OBJ_D)\ofb_enc.obj \
! 	$(OBJ_D)\str2key.obj $(OBJ_D)\pcbc_enc.obj $(OBJ_D)\qud_cksm.obj \
! 	$(OBJ_D)\rand_key.obj $(OBJ_D)\xcbc_enc.obj $(OBJ_D)\read_pwd.obj \
! 	$(OBJ_D)\rpc_enc.obj $(OBJ_D)\cbc_cksm.obj $(OBJ_D)\supp.obj \
! 	$(OBJ_D)\rc4_enc.obj $(OBJ_D)\rc2_ecb.obj $(OBJ_D)\rc2_skey.obj \
! 	$(OBJ_D)\rc2_cbc.obj $(OBJ_D)\rc2cfb64.obj $(OBJ_D)\rc2ofb64.obj \
! 	$(OBJ_D)\i_cbc.obj $(OBJ_D)\i_cfb64.obj $(OBJ_D)\i_ofb64.obj \
! 	$(OBJ_D)\i_ecb.obj $(OBJ_D)\i_skey.obj $(OBJ_D)\bn_add.obj \
! 	$(OBJ_D)\bn_div.obj $(OBJ_D)\bn_exp.obj $(OBJ_D)\bn_lib.obj \
! 	$(OBJ_D)\bn_mod.obj $(OBJ_D)\bn_mul.obj $(OBJ_D)\bn_print.obj \
! 	$(OBJ_D)\bn_rand.obj $(OBJ_D)\bn_shift.obj $(OBJ_D)\bn_sub.obj \
! 	$(OBJ_D)\bn_word.obj $(OBJ_D)\bn_gcd.obj $(OBJ_D)\bn_prime.obj \
! 	$(OBJ_D)\bn_err.obj $(OBJ_D)\bn_sqr.obj $(BN_MULW_OBJ) \
! 	$(OBJ_D)\bn_recp.obj $(OBJ_D)\bn_mont.obj $(OBJ_D)\rsa_enc.obj \
! 	$(OBJ_D)\rsa_gen.obj $(OBJ_D)\rsa_lib.obj $(OBJ_D)\rsa_sign.obj \
! 	$(OBJ_D)\rsa_err.obj $(OBJ_D)\dsa_lib.obj $(OBJ_D)\dsa_vrf.obj \
! 	$(OBJ_D)\dsa_sign.obj $(OBJ_D)\dsa_err.obj $(OBJ_D)\dh_gen.obj \
! 	$(OBJ_D)\dh_key.obj $(OBJ_D)\dh_lib.obj $(OBJ_D)\dh_check.obj \
! 	$(OBJ_D)\dh_err.obj $(OBJ_D)\buffer.obj $(OBJ_D)\bio_lib.obj \
! 	$(OBJ_D)\bio_cb.obj $(OBJ_D)\buf_err.obj $(OBJ_D)\bss_mem.obj \
! 	$(OBJ_D)\bss_null.obj $(OBJ_D)\bss_fd.obj $(OBJ_D)\bss_file.obj \
! 	$(OBJ_D)\bss_sock.obj $(OBJ_D)\bf_buff.obj $(OBJ_D)\stack.obj \
! 	$(OBJ_D)\lhash.obj $(OBJ_D)\lh_stats.obj $(OBJ_D)\md5_rand.obj \
! 	$(OBJ_D)\randfile.obj $(OBJ_D)\err.obj $(OBJ_D)\err_all.obj \
! 	$(OBJ_D)\obj_dat.obj $(OBJ_D)\obj_lib.obj $(OBJ_D)\obj_err.obj \
! 	$(OBJ_D)\encode.obj $(OBJ_D)\digest.obj $(OBJ_D)\evp_enc.obj \
! 	$(OBJ_D)\evp_key.obj $(OBJ_D)\e_ecb_d.obj $(OBJ_D)\e_cbc_d.obj \
! 	$(OBJ_D)\e_cfb_d.obj $(OBJ_D)\e_ofb_d.obj $(OBJ_D)\e_ecb_i.obj \
! 	$(OBJ_D)\e_cbc_i.obj $(OBJ_D)\e_cfb_i.obj $(OBJ_D)\e_ofb_i.obj \
! 	$(OBJ_D)\e_ecb_3d.obj $(OBJ_D)\e_cbc_3d.obj $(OBJ_D)\e_rc4.obj \
! 	$(OBJ_D)\e_names.obj $(OBJ_D)\e_cfb_3d.obj $(OBJ_D)\e_ofb_3d.obj \
! 	$(OBJ_D)\e_xcbc_d.obj $(OBJ_D)\e_ecb_r2.obj $(OBJ_D)\e_cbc_r2.obj \
! 	$(OBJ_D)\e_cfb_r2.obj $(OBJ_D)\e_ofb_r2.obj $(OBJ_D)\m_md2.obj \
! 	$(OBJ_D)\m_md5.obj $(OBJ_D)\m_sha.obj $(OBJ_D)\m_sha1.obj \
! 	$(OBJ_D)\m_dss.obj $(OBJ_D)\m_dss1.obj $(OBJ_D)\m_names.obj \
! 	$(OBJ_D)\p_open.obj $(OBJ_D)\p_seal.obj $(OBJ_D)\p_sign.obj \
! 	$(OBJ_D)\p_verify.obj $(OBJ_D)\p_lib.obj $(OBJ_D)\bio_md.obj \
! 	$(OBJ_D)\evp_err.obj $(OBJ_D)\pem_sign.obj $(OBJ_D)\pem_seal.obj \
! 	$(OBJ_D)\pem_info.obj $(OBJ_D)\pem_lib.obj $(OBJ_D)\pem_err.obj \
! 	$(OBJ_D)\x509_def.obj $(OBJ_D)\x509_r2x.obj $(OBJ_D)\x509_cmp.obj \
! 	$(OBJ_D)\x509_obj.obj $(OBJ_D)\x509_req.obj $(OBJ_D)\x509_vrf.obj \
! 	$(OBJ_D)\x509_crt.obj $(OBJ_D)\x509_ath.obj $(OBJ_D)\x509_err.obj \
! 	$(OBJ_D)\a_object.obj $(OBJ_D)\a_bitstr.obj $(OBJ_D)\a_utctm.obj \
! 	$(OBJ_D)\a_int.obj $(OBJ_D)\a_octet.obj $(OBJ_D)\a_print.obj \
! 	$(OBJ_D)\a_type.obj $(OBJ_D)\a_set.obj $(OBJ_D)\a_dup.obj \
! 	$(OBJ_D)\a_d2i_fp.obj $(OBJ_D)\a_i2d_fp.obj $(OBJ_D)\a_sign.obj \
! 	$(OBJ_D)\a_verify.obj $(OBJ_D)\x_algor.obj $(OBJ_D)\x_val.obj \
! 	$(OBJ_D)\x_pubkey.obj $(OBJ_D)\x_sig.obj $(OBJ_D)\x_req.obj \
! 	$(OBJ_D)\x_attrib.obj $(OBJ_D)\x_name.obj $(OBJ_D)\x_cinf.obj \
! 	$(OBJ_D)\x_x509.obj $(OBJ_D)\x_crl.obj $(OBJ_D)\x_info.obj \
! 	$(OBJ_D)\x_spki.obj $(OBJ_D)\d2i_r_pr.obj $(OBJ_D)\i2d_r_pr.obj \
! 	$(OBJ_D)\d2i_r_pu.obj $(OBJ_D)\i2d_r_pu.obj $(OBJ_D)\d2i_s_pr.obj \
! 	$(OBJ_D)\d2i_s_pu.obj $(OBJ_D)\d2i_pu.obj $(OBJ_D)\d2i_pr.obj \
! 	$(OBJ_D)\i2d_pu.obj $(OBJ_D)\i2d_pr.obj $(OBJ_D)\t_req.obj \
! 	$(OBJ_D)\t_x509.obj $(OBJ_D)\t_pkey.obj $(OBJ_D)\p7_i_s.obj \
! 	$(OBJ_D)\p7_signi.obj $(OBJ_D)\p7_signd.obj $(OBJ_D)\p7_recip.obj \
! 	$(OBJ_D)\p7_enc_c.obj $(OBJ_D)\p7_evp.obj $(OBJ_D)\p7_dgst.obj \
! 	$(OBJ_D)\p7_s_e.obj $(OBJ_D)\p7_enc.obj $(OBJ_D)\p7_lib.obj \
! 	$(OBJ_D)\f_int.obj $(OBJ_D)\i2d_dh.obj $(OBJ_D)\d2i_dh.obj \
! 	$(OBJ_D)\n_pkey.obj $(OBJ_D)\a_hdr.obj $(OBJ_D)\x_pkey.obj \
! 	$(OBJ_D)\a_bool.obj $(OBJ_D)\x_exten.obj $(OBJ_D)\asn1_par.obj \
! 	$(OBJ_D)\asn1_lib.obj $(OBJ_D)\asn1_err.obj $(OBJ_D)\meth_lib.obj \
! 	$(OBJ_D)\x509meth.obj $(OBJ_D)\by_file.obj $(OBJ_D)\by_dir.obj \
! 	$(OBJ_D)\meth_err.obj $(OBJ_D)\conf.obj $(OBJ_D)\conf_err.obj \
! 	$(OBJ_D)\txt_db.obj
  
  SSLOBJ=$(OBJ_D)\ssl_lib.obj \
  	$(OBJ_D)\ssl_err2.obj $(OBJ_D)\ssl_trc.obj $(OBJ_D)\ssl_cert.obj \
--- 128,208 ----
  	$(OBJ_D)\hashdir.obj $(OBJ_D)\s_time.obj $(OBJ_D)\s_mult.obj \
  	$(OBJ_D)\apps.obj $(OBJ_D)\s_cb.obj $(OBJ_D)\s_socket.obj \
  	$(OBJ_D)\s_eio.obj $(OBJ_D)\version.obj $(OBJ_D)\sess_id.obj \
! 	$(OBJ_D)\ciphers.obj $(OBJ_D)\ssleay.obj
  
  CRYPTOOBJ=$(OBJ_D)\cryptlib.obj \
! 	$(OBJ_D)\mem.obj $(OBJ_D)\md2_dgst.obj $(OBJ_D)\md5_dgst.obj \
! 	$(OBJ_D)\md2_one.obj $(OBJ_D)\md5_one.obj $(OBJ_D)\sha_dgst.obj \
! 	$(OBJ_D)\sha1dgst.obj $(OBJ_D)\sha_one.obj $(OBJ_D)\sha1_one.obj \
! 	$(OBJ_D)\set_key.obj $(OBJ_D)\ecb_enc.obj $(OBJ_D)\ede_enc.obj \
! 	$(OBJ_D)\cbc_enc.obj $(OBJ_D)\cbc3_enc.obj $(OBJ_D)\ecb3_enc.obj \
! 	$(OBJ_D)\cfb64enc.obj $(OBJ_D)\cfb64ede.obj $(OBJ_D)\cfb_enc.obj \
! 	$(OBJ_D)\ofb64ede.obj $(OBJ_D)\enc_read.obj $(OBJ_D)\enc_writ.obj \
! 	$(OBJ_D)\fcrypt.obj $(OBJ_D)\ncbc_enc.obj $(OBJ_D)\ofb64enc.obj \
! 	$(OBJ_D)\ofb_enc.obj $(OBJ_D)\str2key.obj $(OBJ_D)\pcbc_enc.obj \
! 	$(OBJ_D)\qud_cksm.obj $(OBJ_D)\rand_key.obj $(OBJ_D)\xcbc_enc.obj \
! 	$(OBJ_D)\read_pwd.obj $(OBJ_D)\rpc_enc.obj $(OBJ_D)\cbc_cksm.obj \
! 	$(OBJ_D)\supp.obj $(OBJ_D)\rc4_enc.obj $(OBJ_D)\rc2_ecb.obj \
! 	$(OBJ_D)\rc2_skey.obj $(OBJ_D)\rc2_cbc.obj $(OBJ_D)\rc2cfb64.obj \
! 	$(OBJ_D)\rc2ofb64.obj $(OBJ_D)\i_cbc.obj $(OBJ_D)\i_cfb64.obj \
! 	$(OBJ_D)\i_ofb64.obj $(OBJ_D)\i_ecb.obj $(OBJ_D)\i_skey.obj \
! 	$(OBJ_D)\bn_add.obj $(OBJ_D)\bn_div.obj $(OBJ_D)\bn_exp.obj \
! 	$(OBJ_D)\bn_lib.obj $(OBJ_D)\bn_mod.obj $(OBJ_D)\bn_mul.obj \
! 	$(OBJ_D)\bn_print.obj $(OBJ_D)\bn_rand.obj $(OBJ_D)\bn_shift.obj \
! 	$(OBJ_D)\bn_sub.obj $(OBJ_D)\bn_word.obj $(OBJ_D)\bn_gcd.obj \
! 	$(OBJ_D)\bn_prime.obj $(OBJ_D)\bn_err.obj $(OBJ_D)\bn_sqr.obj \
! 	$(BN_MULW_OBJ) $(OBJ_D)\bn_recp.obj $(OBJ_D)\bn_mont.obj \
! 	$(OBJ_D)\rsa_enc.obj $(OBJ_D)\rsa_gen.obj $(OBJ_D)\rsa_lib.obj \
! 	$(OBJ_D)\rsa_sign.obj $(OBJ_D)\rsa_err.obj $(OBJ_D)\dsa_lib.obj \
! 	$(OBJ_D)\dsa_vrf.obj $(OBJ_D)\dsa_sign.obj $(OBJ_D)\dsa_err.obj \
! 	$(OBJ_D)\dh_gen.obj $(OBJ_D)\dh_key.obj $(OBJ_D)\dh_lib.obj \
! 	$(OBJ_D)\dh_check.obj $(OBJ_D)\dh_err.obj $(OBJ_D)\buffer.obj \
! 	$(OBJ_D)\bio_lib.obj $(OBJ_D)\bio_cb.obj $(OBJ_D)\buf_err.obj \
! 	$(OBJ_D)\bss_mem.obj $(OBJ_D)\bss_null.obj $(OBJ_D)\bss_fd.obj \
! 	$(OBJ_D)\bss_file.obj $(OBJ_D)\bss_sock.obj $(OBJ_D)\bf_buff.obj \
! 	$(OBJ_D)\stack.obj $(OBJ_D)\lhash.obj $(OBJ_D)\lh_stats.obj \
! 	$(OBJ_D)\md5_rand.obj $(OBJ_D)\randfile.obj $(OBJ_D)\err.obj \
! 	$(OBJ_D)\err_all.obj $(OBJ_D)\obj_dat.obj $(OBJ_D)\obj_lib.obj \
! 	$(OBJ_D)\obj_err.obj $(OBJ_D)\encode.obj $(OBJ_D)\digest.obj \
! 	$(OBJ_D)\evp_enc.obj $(OBJ_D)\evp_key.obj $(OBJ_D)\e_ecb_d.obj \
! 	$(OBJ_D)\e_cbc_d.obj $(OBJ_D)\e_cfb_d.obj $(OBJ_D)\e_ofb_d.obj \
! 	$(OBJ_D)\e_ecb_i.obj $(OBJ_D)\e_cbc_i.obj $(OBJ_D)\e_cfb_i.obj \
! 	$(OBJ_D)\e_ofb_i.obj $(OBJ_D)\e_ecb_3d.obj $(OBJ_D)\e_cbc_3d.obj \
! 	$(OBJ_D)\e_rc4.obj $(OBJ_D)\e_names.obj $(OBJ_D)\e_cfb_3d.obj \
! 	$(OBJ_D)\e_ofb_3d.obj $(OBJ_D)\e_xcbc_d.obj $(OBJ_D)\e_ecb_r2.obj \
! 	$(OBJ_D)\e_cbc_r2.obj $(OBJ_D)\e_cfb_r2.obj $(OBJ_D)\e_ofb_r2.obj \
! 	$(OBJ_D)\m_md2.obj $(OBJ_D)\m_md5.obj $(OBJ_D)\m_sha.obj \
! 	$(OBJ_D)\m_sha1.obj $(OBJ_D)\m_dss.obj $(OBJ_D)\m_dss1.obj \
! 	$(OBJ_D)\m_names.obj $(OBJ_D)\p_open.obj $(OBJ_D)\p_seal.obj \
! 	$(OBJ_D)\p_sign.obj $(OBJ_D)\p_verify.obj $(OBJ_D)\p_lib.obj \
! 	$(OBJ_D)\bio_md.obj $(OBJ_D)\evp_err.obj $(OBJ_D)\pem_sign.obj \
! 	$(OBJ_D)\pem_seal.obj $(OBJ_D)\pem_info.obj $(OBJ_D)\pem_lib.obj \
! 	$(OBJ_D)\pem_err.obj $(OBJ_D)\x509_def.obj $(OBJ_D)\x509_r2x.obj \
! 	$(OBJ_D)\x509_cmp.obj $(OBJ_D)\x509_obj.obj $(OBJ_D)\x509_req.obj \
! 	$(OBJ_D)\x509_vrf.obj $(OBJ_D)\x509_crt.obj $(OBJ_D)\x509_ath.obj \
! 	$(OBJ_D)\x509_err.obj $(OBJ_D)\a_object.obj $(OBJ_D)\a_bitstr.obj \
! 	$(OBJ_D)\a_utctm.obj $(OBJ_D)\a_int.obj $(OBJ_D)\a_octet.obj \
! 	$(OBJ_D)\a_print.obj $(OBJ_D)\a_type.obj $(OBJ_D)\a_set.obj \
! 	$(OBJ_D)\a_dup.obj $(OBJ_D)\a_d2i_fp.obj $(OBJ_D)\a_i2d_fp.obj \
! 	$(OBJ_D)\a_sign.obj $(OBJ_D)\a_verify.obj $(OBJ_D)\x_algor.obj \
! 	$(OBJ_D)\x_val.obj $(OBJ_D)\x_pubkey.obj $(OBJ_D)\x_sig.obj \
! 	$(OBJ_D)\x_req.obj $(OBJ_D)\x_attrib.obj $(OBJ_D)\x_name.obj \
! 	$(OBJ_D)\x_cinf.obj $(OBJ_D)\x_x509.obj $(OBJ_D)\x_crl.obj \
! 	$(OBJ_D)\x_info.obj $(OBJ_D)\x_spki.obj $(OBJ_D)\d2i_r_pr.obj \
! 	$(OBJ_D)\i2d_r_pr.obj $(OBJ_D)\d2i_r_pu.obj $(OBJ_D)\i2d_r_pu.obj \
! 	$(OBJ_D)\d2i_s_pr.obj $(OBJ_D)\d2i_s_pu.obj $(OBJ_D)\d2i_pu.obj \
! 	$(OBJ_D)\d2i_pr.obj $(OBJ_D)\i2d_pu.obj $(OBJ_D)\i2d_pr.obj \
! 	$(OBJ_D)\t_req.obj $(OBJ_D)\t_x509.obj $(OBJ_D)\t_pkey.obj \
! 	$(OBJ_D)\p7_i_s.obj $(OBJ_D)\p7_signi.obj $(OBJ_D)\p7_signd.obj \
! 	$(OBJ_D)\p7_recip.obj $(OBJ_D)\p7_enc_c.obj $(OBJ_D)\p7_evp.obj \
! 	$(OBJ_D)\p7_dgst.obj $(OBJ_D)\p7_s_e.obj $(OBJ_D)\p7_enc.obj \
! 	$(OBJ_D)\p7_lib.obj $(OBJ_D)\f_int.obj $(OBJ_D)\i2d_dh.obj \
! 	$(OBJ_D)\d2i_dh.obj $(OBJ_D)\n_pkey.obj $(OBJ_D)\a_hdr.obj \
! 	$(OBJ_D)\x_pkey.obj $(OBJ_D)\a_bool.obj $(OBJ_D)\x_exten.obj \
! 	$(OBJ_D)\asn1_par.obj $(OBJ_D)\asn1_lib.obj $(OBJ_D)\asn1_err.obj \
! 	$(OBJ_D)\meth_lib.obj $(OBJ_D)\x509meth.obj $(OBJ_D)\by_file.obj \
! 	$(OBJ_D)\by_dir.obj $(OBJ_D)\meth_err.obj $(OBJ_D)\conf.obj \
! 	$(OBJ_D)\conf_err.obj $(OBJ_D)\txt_db.obj
  
  SSLOBJ=$(OBJ_D)\ssl_lib.obj \
  	$(OBJ_D)\ssl_err2.obj $(OBJ_D)\ssl_trc.obj $(OBJ_D)\ssl_cert.obj \
***************
*** 569,574 ****
--- 569,577 ----
  $(OBJ_D)\sess_id.obj: $(SRC_D)\apps\sess_id.c
  	$(CC) /Fo$(OBJ_D)\sess_id.obj -DMONOLITH $(APP_CFLAGS) -c $(SRC_D)\apps\sess_id.c
  
+ $(OBJ_D)\ciphers.obj: $(SRC_D)\apps\ciphers.c
+ 	$(CC) /Fo$(OBJ_D)\ciphers.obj -DMONOLITH $(APP_CFLAGS) -c $(SRC_D)\apps\ciphers.c
+ 
  $(OBJ_D)\ssleay.obj: $(SRC_D)\apps\ssleay.c
  	$(CC) /Fo$(OBJ_D)\ssleay.obj -DMONOLITH $(APP_CFLAGS) -c $(SRC_D)\apps\ssleay.c
  
***************
*** 578,583 ****
--- 581,589 ----
  $(OBJ_D)\cryptlib.obj: $(SRC_D)\crypto\cryptlib.c
  	$(CC) /Fo$(OBJ_D)\cryptlib.obj $(LIB_CFLAGS) -DCFLAGS="\"$(CC) $(CFLAG)\"" -c $(SRC_D)\crypto\cryptlib.c
  
+ $(OBJ_D)\mem.obj: $(SRC_D)\crypto\mem.c
+ 	$(CC) /Fo$(OBJ_D)\mem.obj $(LIB_CFLAGS) -c $(SRC_D)\crypto\mem.c
+ 
  $(OBJ_D)\md2_dgst.obj: $(SRC_D)\crypto\md\md2_dgst.c
  	$(CC) /Fo$(OBJ_D)\md2_dgst.obj $(LIB_CFLAGS) -c $(SRC_D)\crypto\md\md2_dgst.c
  
***************
*** 1353,1371 ****
  <<
  
  $(O_SSL): $(SSLOBJ)
- 	$(RM) $(O_SSL)
  	$(MKLIB) /out:$(O_SSL) @<<
    $(SSLOBJ)
  <<
  
  $(O_RSAGLUE): $(RSAGLUEOBJ)
- 	$(RM) $(O_RSAGLUE)
  	$(MKLIB) /out:$(O_RSAGLUE) @<<
    $(RSAGLUEOBJ)
  <<
  
  $(O_CRYPTO): $(CRYPTOOBJ)
- 	$(RM) $(O_CRYPTO)
  	$(MKLIB) /out:$(O_CRYPTO) @<<
    $(CRYPTOOBJ)
  <<
--- 1359,1374 ----
*** /var/spool/ftp/pub/Crypto/SSL/064/SSLeay-0.6.3/./ms/ntdll.mak	Thu Aug  8 01:54:53 1996
--- ./ms/ntdll.mak	Fri Aug 30 04:41:24 1996
***************
*** 11,17 ****
  # The one monster makefile better suits building in non-unix
  # environments.
  
! INSTALLTOP=/usr/local/ssl
  
  # Set your compiler options
  CC=cl
--- 11,17 ----
  # The one monster makefile better suits building in non-unix
  # environments.
  
! INSTALLTOP=\usr\local\ssl
  
  # Set your compiler options
  CC=cl
***************
*** 128,208 ****
  	$(OBJ_D)\hashdir.obj $(OBJ_D)\s_time.obj $(OBJ_D)\s_mult.obj \
  	$(OBJ_D)\apps.obj $(OBJ_D)\s_cb.obj $(OBJ_D)\s_socket.obj \
  	$(OBJ_D)\s_eio.obj $(OBJ_D)\version.obj $(OBJ_D)\sess_id.obj \
! 	$(OBJ_D)\ssleay.obj
  
  CRYPTOOBJ=$(OBJ_D)\cryptlib.obj \
! 	$(OBJ_D)\md2_dgst.obj $(OBJ_D)\md5_dgst.obj $(OBJ_D)\md2_one.obj \
! 	$(OBJ_D)\md5_one.obj $(OBJ_D)\sha_dgst.obj $(OBJ_D)\sha1dgst.obj \
! 	$(OBJ_D)\sha_one.obj $(OBJ_D)\sha1_one.obj $(OBJ_D)\set_key.obj \
! 	$(OBJ_D)\ecb_enc.obj $(OBJ_D)\ede_enc.obj $(OBJ_D)\cbc_enc.obj \
! 	$(OBJ_D)\cbc3_enc.obj $(OBJ_D)\ecb3_enc.obj $(OBJ_D)\cfb64enc.obj \
! 	$(OBJ_D)\cfb64ede.obj $(OBJ_D)\cfb_enc.obj $(OBJ_D)\ofb64ede.obj \
! 	$(OBJ_D)\enc_read.obj $(OBJ_D)\enc_writ.obj $(OBJ_D)\fcrypt.obj \
! 	$(OBJ_D)\ncbc_enc.obj $(OBJ_D)\ofb64enc.obj $(OBJ_D)\ofb_enc.obj \
! 	$(OBJ_D)\str2key.obj $(OBJ_D)\pcbc_enc.obj $(OBJ_D)\qud_cksm.obj \
! 	$(OBJ_D)\rand_key.obj $(OBJ_D)\xcbc_enc.obj $(OBJ_D)\read_pwd.obj \
! 	$(OBJ_D)\rpc_enc.obj $(OBJ_D)\cbc_cksm.obj $(OBJ_D)\supp.obj \
! 	$(OBJ_D)\rc4_enc.obj $(OBJ_D)\rc2_ecb.obj $(OBJ_D)\rc2_skey.obj \
! 	$(OBJ_D)\rc2_cbc.obj $(OBJ_D)\rc2cfb64.obj $(OBJ_D)\rc2ofb64.obj \
! 	$(OBJ_D)\i_cbc.obj $(OBJ_D)\i_cfb64.obj $(OBJ_D)\i_ofb64.obj \
! 	$(OBJ_D)\i_ecb.obj $(OBJ_D)\i_skey.obj $(OBJ_D)\bn_add.obj \
! 	$(OBJ_D)\bn_div.obj $(OBJ_D)\bn_exp.obj $(OBJ_D)\bn_lib.obj \
! 	$(OBJ_D)\bn_mod.obj $(OBJ_D)\bn_mul.obj $(OBJ_D)\bn_print.obj \
! 	$(OBJ_D)\bn_rand.obj $(OBJ_D)\bn_shift.obj $(OBJ_D)\bn_sub.obj \
! 	$(OBJ_D)\bn_word.obj $(OBJ_D)\bn_gcd.obj $(OBJ_D)\bn_prime.obj \
! 	$(OBJ_D)\bn_err.obj $(OBJ_D)\bn_sqr.obj $(BN_MULW_OBJ) \
! 	$(OBJ_D)\bn_recp.obj $(OBJ_D)\bn_mont.obj $(OBJ_D)\rsa_enc.obj \
! 	$(OBJ_D)\rsa_gen.obj $(OBJ_D)\rsa_lib.obj $(OBJ_D)\rsa_sign.obj \
! 	$(OBJ_D)\rsa_err.obj $(OBJ_D)\dsa_lib.obj $(OBJ_D)\dsa_vrf.obj \
! 	$(OBJ_D)\dsa_sign.obj $(OBJ_D)\dsa_err.obj $(OBJ_D)\dh_gen.obj \
! 	$(OBJ_D)\dh_key.obj $(OBJ_D)\dh_lib.obj $(OBJ_D)\dh_check.obj \
! 	$(OBJ_D)\dh_err.obj $(OBJ_D)\buffer.obj $(OBJ_D)\bio_lib.obj \
! 	$(OBJ_D)\bio_cb.obj $(OBJ_D)\buf_err.obj $(OBJ_D)\bss_mem.obj \
! 	$(OBJ_D)\bss_null.obj $(OBJ_D)\bss_fd.obj $(OBJ_D)\bss_file.obj \
! 	$(OBJ_D)\bss_sock.obj $(OBJ_D)\bf_buff.obj $(OBJ_D)\stack.obj \
! 	$(OBJ_D)\lhash.obj $(OBJ_D)\lh_stats.obj $(OBJ_D)\md5_rand.obj \
! 	$(OBJ_D)\randfile.obj $(OBJ_D)\err.obj $(OBJ_D)\err_all.obj \
! 	$(OBJ_D)\obj_dat.obj $(OBJ_D)\obj_lib.obj $(OBJ_D)\obj_err.obj \
! 	$(OBJ_D)\encode.obj $(OBJ_D)\digest.obj $(OBJ_D)\evp_enc.obj \
! 	$(OBJ_D)\evp_key.obj $(OBJ_D)\e_ecb_d.obj $(OBJ_D)\e_cbc_d.obj \
! 	$(OBJ_D)\e_cfb_d.obj $(OBJ_D)\e_ofb_d.obj $(OBJ_D)\e_ecb_i.obj \
! 	$(OBJ_D)\e_cbc_i.obj $(OBJ_D)\e_cfb_i.obj $(OBJ_D)\e_ofb_i.obj \
! 	$(OBJ_D)\e_ecb_3d.obj $(OBJ_D)\e_cbc_3d.obj $(OBJ_D)\e_rc4.obj \
! 	$(OBJ_D)\e_names.obj $(OBJ_D)\e_cfb_3d.obj $(OBJ_D)\e_ofb_3d.obj \
! 	$(OBJ_D)\e_xcbc_d.obj $(OBJ_D)\e_ecb_r2.obj $(OBJ_D)\e_cbc_r2.obj \
! 	$(OBJ_D)\e_cfb_r2.obj $(OBJ_D)\e_ofb_r2.obj $(OBJ_D)\m_md2.obj \
! 	$(OBJ_D)\m_md5.obj $(OBJ_D)\m_sha.obj $(OBJ_D)\m_sha1.obj \
! 	$(OBJ_D)\m_dss.obj $(OBJ_D)\m_dss1.obj $(OBJ_D)\m_names.obj \
! 	$(OBJ_D)\p_open.obj $(OBJ_D)\p_seal.obj $(OBJ_D)\p_sign.obj \
! 	$(OBJ_D)\p_verify.obj $(OBJ_D)\p_lib.obj $(OBJ_D)\bio_md.obj \
! 	$(OBJ_D)\evp_err.obj $(OBJ_D)\pem_sign.obj $(OBJ_D)\pem_seal.obj \
! 	$(OBJ_D)\pem_info.obj $(OBJ_D)\pem_lib.obj $(OBJ_D)\pem_err.obj \
! 	$(OBJ_D)\x509_def.obj $(OBJ_D)\x509_r2x.obj $(OBJ_D)\x509_cmp.obj \
! 	$(OBJ_D)\x509_obj.obj $(OBJ_D)\x509_req.obj $(OBJ_D)\x509_vrf.obj \
! 	$(OBJ_D)\x509_crt.obj $(OBJ_D)\x509_ath.obj $(OBJ_D)\x509_err.obj \
! 	$(OBJ_D)\a_object.obj $(OBJ_D)\a_bitstr.obj $(OBJ_D)\a_utctm.obj \
! 	$(OBJ_D)\a_int.obj $(OBJ_D)\a_octet.obj $(OBJ_D)\a_print.obj \
! 	$(OBJ_D)\a_type.obj $(OBJ_D)\a_set.obj $(OBJ_D)\a_dup.obj \
! 	$(OBJ_D)\a_d2i_fp.obj $(OBJ_D)\a_i2d_fp.obj $(OBJ_D)\a_sign.obj \
! 	$(OBJ_D)\a_verify.obj $(OBJ_D)\x_algor.obj $(OBJ_D)\x_val.obj \
! 	$(OBJ_D)\x_pubkey.obj $(OBJ_D)\x_sig.obj $(OBJ_D)\x_req.obj \
! 	$(OBJ_D)\x_attrib.obj $(OBJ_D)\x_name.obj $(OBJ_D)\x_cinf.obj \
! 	$(OBJ_D)\x_x509.obj $(OBJ_D)\x_crl.obj $(OBJ_D)\x_info.obj \
! 	$(OBJ_D)\x_spki.obj $(OBJ_D)\d2i_r_pr.obj $(OBJ_D)\i2d_r_pr.obj \
! 	$(OBJ_D)\d2i_r_pu.obj $(OBJ_D)\i2d_r_pu.obj $(OBJ_D)\d2i_s_pr.obj \
! 	$(OBJ_D)\d2i_s_pu.obj $(OBJ_D)\d2i_pu.obj $(OBJ_D)\d2i_pr.obj \
! 	$(OBJ_D)\i2d_pu.obj $(OBJ_D)\i2d_pr.obj $(OBJ_D)\t_req.obj \
! 	$(OBJ_D)\t_x509.obj $(OBJ_D)\t_pkey.obj $(OBJ_D)\p7_i_s.obj \
! 	$(OBJ_D)\p7_signi.obj $(OBJ_D)\p7_signd.obj $(OBJ_D)\p7_recip.obj \
! 	$(OBJ_D)\p7_enc_c.obj $(OBJ_D)\p7_evp.obj $(OBJ_D)\p7_dgst.obj \
! 	$(OBJ_D)\p7_s_e.obj $(OBJ_D)\p7_enc.obj $(OBJ_D)\p7_lib.obj \
! 	$(OBJ_D)\f_int.obj $(OBJ_D)\i2d_dh.obj $(OBJ_D)\d2i_dh.obj \
! 	$(OBJ_D)\n_pkey.obj $(OBJ_D)\a_hdr.obj $(OBJ_D)\x_pkey.obj \
! 	$(OBJ_D)\a_bool.obj $(OBJ_D)\x_exten.obj $(OBJ_D)\asn1_par.obj \
! 	$(OBJ_D)\asn1_lib.obj $(OBJ_D)\asn1_err.obj $(OBJ_D)\meth_lib.obj \
! 	$(OBJ_D)\x509meth.obj $(OBJ_D)\by_file.obj $(OBJ_D)\by_dir.obj \
! 	$(OBJ_D)\meth_err.obj $(OBJ_D)\conf.obj $(OBJ_D)\conf_err.obj \
! 	$(OBJ_D)\txt_db.obj
  
  SSLOBJ=$(OBJ_D)\ssl_lib.obj \
  	$(OBJ_D)\ssl_err2.obj $(OBJ_D)\ssl_trc.obj $(OBJ_D)\ssl_cert.obj \
--- 128,208 ----
  	$(OBJ_D)\hashdir.obj $(OBJ_D)\s_time.obj $(OBJ_D)\s_mult.obj \
  	$(OBJ_D)\apps.obj $(OBJ_D)\s_cb.obj $(OBJ_D)\s_socket.obj \
  	$(OBJ_D)\s_eio.obj $(OBJ_D)\version.obj $(OBJ_D)\sess_id.obj \
! 	$(OBJ_D)\ciphers.obj $(OBJ_D)\ssleay.obj
  
  CRYPTOOBJ=$(OBJ_D)\cryptlib.obj \
! 	$(OBJ_D)\mem.obj $(OBJ_D)\md2_dgst.obj $(OBJ_D)\md5_dgst.obj \
! 	$(OBJ_D)\md2_one.obj $(OBJ_D)\md5_one.obj $(OBJ_D)\sha_dgst.obj \
! 	$(OBJ_D)\sha1dgst.obj $(OBJ_D)\sha_one.obj $(OBJ_D)\sha1_one.obj \
! 	$(OBJ_D)\set_key.obj $(OBJ_D)\ecb_enc.obj $(OBJ_D)\ede_enc.obj \
! 	$(OBJ_D)\cbc_enc.obj $(OBJ_D)\cbc3_enc.obj $(OBJ_D)\ecb3_enc.obj \
! 	$(OBJ_D)\cfb64enc.obj $(OBJ_D)\cfb64ede.obj $(OBJ_D)\cfb_enc.obj \
! 	$(OBJ_D)\ofb64ede.obj $(OBJ_D)\enc_read.obj $(OBJ_D)\enc_writ.obj \
! 	$(OBJ_D)\fcrypt.obj $(OBJ_D)\ncbc_enc.obj $(OBJ_D)\ofb64enc.obj \
! 	$(OBJ_D)\ofb_enc.obj $(OBJ_D)\str2key.obj $(OBJ_D)\pcbc_enc.obj \
! 	$(OBJ_D)\qud_cksm.obj $(OBJ_D)\rand_key.obj $(OBJ_D)\xcbc_enc.obj \
! 	$(OBJ_D)\read_pwd.obj $(OBJ_D)\rpc_enc.obj $(OBJ_D)\cbc_cksm.obj \
! 	$(OBJ_D)\supp.obj $(OBJ_D)\rc4_enc.obj $(OBJ_D)\rc2_ecb.obj \
! 	$(OBJ_D)\rc2_skey.obj $(OBJ_D)\rc2_cbc.obj $(OBJ_D)\rc2cfb64.obj \
! 	$(OBJ_D)\rc2ofb64.obj $(OBJ_D)\i_cbc.obj $(OBJ_D)\i_cfb64.obj \
! 	$(OBJ_D)\i_ofb64.obj $(OBJ_D)\i_ecb.obj $(OBJ_D)\i_skey.obj \
! 	$(OBJ_D)\bn_add.obj $(OBJ_D)\bn_div.obj $(OBJ_D)\bn_exp.obj \
! 	$(OBJ_D)\bn_lib.obj $(OBJ_D)\bn_mod.obj $(OBJ_D)\bn_mul.obj \
! 	$(OBJ_D)\bn_print.obj $(OBJ_D)\bn_rand.obj $(OBJ_D)\bn_shift.obj \
! 	$(OBJ_D)\bn_sub.obj $(OBJ_D)\bn_word.obj $(OBJ_D)\bn_gcd.obj \
! 	$(OBJ_D)\bn_prime.obj $(OBJ_D)\bn_err.obj $(OBJ_D)\bn_sqr.obj \
! 	$(BN_MULW_OBJ) $(OBJ_D)\bn_recp.obj $(OBJ_D)\bn_mont.obj \
! 	$(OBJ_D)\rsa_enc.obj $(OBJ_D)\rsa_gen.obj $(OBJ_D)\rsa_lib.obj \
! 	$(OBJ_D)\rsa_sign.obj $(OBJ_D)\rsa_err.obj $(OBJ_D)\dsa_lib.obj \
! 	$(OBJ_D)\dsa_vrf.obj $(OBJ_D)\dsa_sign.obj $(OBJ_D)\dsa_err.obj \
! 	$(OBJ_D)\dh_gen.obj $(OBJ_D)\dh_key.obj $(OBJ_D)\dh_lib.obj \
! 	$(OBJ_D)\dh_check.obj $(OBJ_D)\dh_err.obj $(OBJ_D)\buffer.obj \
! 	$(OBJ_D)\bio_lib.obj $(OBJ_D)\bio_cb.obj $(OBJ_D)\buf_err.obj \
! 	$(OBJ_D)\bss_mem.obj $(OBJ_D)\bss_null.obj $(OBJ_D)\bss_fd.obj \
! 	$(OBJ_D)\bss_file.obj $(OBJ_D)\bss_sock.obj $(OBJ_D)\bf_buff.obj \
! 	$(OBJ_D)\stack.obj $(OBJ_D)\lhash.obj $(OBJ_D)\lh_stats.obj \
! 	$(OBJ_D)\md5_rand.obj $(OBJ_D)\randfile.obj $(OBJ_D)\err.obj \
! 	$(OBJ_D)\err_all.obj $(OBJ_D)\obj_dat.obj $(OBJ_D)\obj_lib.obj \
! 	$(OBJ_D)\obj_err.obj $(OBJ_D)\encode.obj $(OBJ_D)\digest.obj \
! 	$(OBJ_D)\evp_enc.obj $(OBJ_D)\evp_key.obj $(OBJ_D)\e_ecb_d.obj \
! 	$(OBJ_D)\e_cbc_d.obj $(OBJ_D)\e_cfb_d.obj $(OBJ_D)\e_ofb_d.obj \
! 	$(OBJ_D)\e_ecb_i.obj $(OBJ_D)\e_cbc_i.obj $(OBJ_D)\e_cfb_i.obj \
! 	$(OBJ_D)\e_ofb_i.obj $(OBJ_D)\e_ecb_3d.obj $(OBJ_D)\e_cbc_3d.obj \
! 	$(OBJ_D)\e_rc4.obj $(OBJ_D)\e_names.obj $(OBJ_D)\e_cfb_3d.obj \
! 	$(OBJ_D)\e_ofb_3d.obj $(OBJ_D)\e_xcbc_d.obj $(OBJ_D)\e_ecb_r2.obj \
! 	$(OBJ_D)\e_cbc_r2.obj $(OBJ_D)\e_cfb_r2.obj $(OBJ_D)\e_ofb_r2.obj \
! 	$(OBJ_D)\m_md2.obj $(OBJ_D)\m_md5.obj $(OBJ_D)\m_sha.obj \
! 	$(OBJ_D)\m_sha1.obj $(OBJ_D)\m_dss.obj $(OBJ_D)\m_dss1.obj \
! 	$(OBJ_D)\m_names.obj $(OBJ_D)\p_open.obj $(OBJ_D)\p_seal.obj \
! 	$(OBJ_D)\p_sign.obj $(OBJ_D)\p_verify.obj $(OBJ_D)\p_lib.obj \
! 	$(OBJ_D)\bio_md.obj $(OBJ_D)\evp_err.obj $(OBJ_D)\pem_sign.obj \
! 	$(OBJ_D)\pem_seal.obj $(OBJ_D)\pem_info.obj $(OBJ_D)\pem_lib.obj \
! 	$(OBJ_D)\pem_err.obj $(OBJ_D)\x509_def.obj $(OBJ_D)\x509_r2x.obj \
! 	$(OBJ_D)\x509_cmp.obj $(OBJ_D)\x509_obj.obj $(OBJ_D)\x509_req.obj \
! 	$(OBJ_D)\x509_vrf.obj $(OBJ_D)\x509_crt.obj $(OBJ_D)\x509_ath.obj \
! 	$(OBJ_D)\x509_err.obj $(OBJ_D)\a_object.obj $(OBJ_D)\a_bitstr.obj \
! 	$(OBJ_D)\a_utctm.obj $(OBJ_D)\a_int.obj $(OBJ_D)\a_octet.obj \
! 	$(OBJ_D)\a_print.obj $(OBJ_D)\a_type.obj $(OBJ_D)\a_set.obj \
! 	$(OBJ_D)\a_dup.obj $(OBJ_D)\a_d2i_fp.obj $(OBJ_D)\a_i2d_fp.obj \
! 	$(OBJ_D)\a_sign.obj $(OBJ_D)\a_verify.obj $(OBJ_D)\x_algor.obj \
! 	$(OBJ_D)\x_val.obj $(OBJ_D)\x_pubkey.obj $(OBJ_D)\x_sig.obj \
! 	$(OBJ_D)\x_req.obj $(OBJ_D)\x_attrib.obj $(OBJ_D)\x_name.obj \
! 	$(OBJ_D)\x_cinf.obj $(OBJ_D)\x_x509.obj $(OBJ_D)\x_crl.obj \
! 	$(OBJ_D)\x_info.obj $(OBJ_D)\x_spki.obj $(OBJ_D)\d2i_r_pr.obj \
! 	$(OBJ_D)\i2d_r_pr.obj $(OBJ_D)\d2i_r_pu.obj $(OBJ_D)\i2d_r_pu.obj \
! 	$(OBJ_D)\d2i_s_pr.obj $(OBJ_D)\d2i_s_pu.obj $(OBJ_D)\d2i_pu.obj \
! 	$(OBJ_D)\d2i_pr.obj $(OBJ_D)\i2d_pu.obj $(OBJ_D)\i2d_pr.obj \
! 	$(OBJ_D)\t_req.obj $(OBJ_D)\t_x509.obj $(OBJ_D)\t_pkey.obj \
! 	$(OBJ_D)\p7_i_s.obj $(OBJ_D)\p7_signi.obj $(OBJ_D)\p7_signd.obj \
! 	$(OBJ_D)\p7_recip.obj $(OBJ_D)\p7_enc_c.obj $(OBJ_D)\p7_evp.obj \
! 	$(OBJ_D)\p7_dgst.obj $(OBJ_D)\p7_s_e.obj $(OBJ_D)\p7_enc.obj \
! 	$(OBJ_D)\p7_lib.obj $(OBJ_D)\f_int.obj $(OBJ_D)\i2d_dh.obj \
! 	$(OBJ_D)\d2i_dh.obj $(OBJ_D)\n_pkey.obj $(OBJ_D)\a_hdr.obj \
! 	$(OBJ_D)\x_pkey.obj $(OBJ_D)\a_bool.obj $(OBJ_D)\x_exten.obj \
! 	$(OBJ_D)\asn1_par.obj $(OBJ_D)\asn1_lib.obj $(OBJ_D)\asn1_err.obj \
! 	$(OBJ_D)\meth_lib.obj $(OBJ_D)\x509meth.obj $(OBJ_D)\by_file.obj \
! 	$(OBJ_D)\by_dir.obj $(OBJ_D)\meth_err.obj $(OBJ_D)\conf.obj \
! 	$(OBJ_D)\conf_err.obj $(OBJ_D)\txt_db.obj
  
  SSLOBJ=$(OBJ_D)\ssl_lib.obj \
  	$(OBJ_D)\ssl_err2.obj $(OBJ_D)\ssl_trc.obj $(OBJ_D)\ssl_cert.obj \
***************
*** 569,574 ****
--- 569,577 ----
  $(OBJ_D)\sess_id.obj: $(SRC_D)\apps\sess_id.c
  	$(CC) /Fo$(OBJ_D)\sess_id.obj -DMONOLITH $(APP_CFLAGS) -c $(SRC_D)\apps\sess_id.c
  
+ $(OBJ_D)\ciphers.obj: $(SRC_D)\apps\ciphers.c
+ 	$(CC) /Fo$(OBJ_D)\ciphers.obj -DMONOLITH $(APP_CFLAGS) -c $(SRC_D)\apps\ciphers.c
+ 
  $(OBJ_D)\ssleay.obj: $(SRC_D)\apps\ssleay.c
  	$(CC) /Fo$(OBJ_D)\ssleay.obj -DMONOLITH $(APP_CFLAGS) -c $(SRC_D)\apps\ssleay.c
  
***************
*** 578,583 ****
--- 581,589 ----
  $(OBJ_D)\cryptlib.obj: $(SRC_D)\crypto\cryptlib.c
  	$(CC) /Fo$(OBJ_D)\cryptlib.obj $(LIB_CFLAGS) -DCFLAGS="\"$(CC) $(CFLAG)\"" -c $(SRC_D)\crypto\cryptlib.c
  
+ $(OBJ_D)\mem.obj: $(SRC_D)\crypto\mem.c
+ 	$(CC) /Fo$(OBJ_D)\mem.obj $(LIB_CFLAGS) -c $(SRC_D)\crypto\mem.c
+ 
  $(OBJ_D)\md2_dgst.obj: $(SRC_D)\crypto\md\md2_dgst.c
  	$(CC) /Fo$(OBJ_D)\md2_dgst.obj $(LIB_CFLAGS) -c $(SRC_D)\crypto\md\md2_dgst.c
  
***************
*** 1358,1364 ****
  <<
  
  $(O_RSAGLUE): $(RSAGLUEOBJ)
- 	$(RM) $(O_RSAGLUE)
  	$(MKLIB) /out:$(O_RSAGLUE) @<<
    $(RSAGLUEOBJ)
  <<
--- 1364,1369 ----
*** /var/spool/ftp/pub/Crypto/SSL/064/SSLeay-0.6.3/./ms/REQ2CA.SS	Wed Jul 24 20:51:56 1996
--- ./ms/REQ2CA.SS	Thu Aug 29 23:50:27 1996
***************
*** 6,29 ****
              Public Key Algorithm: rsaEncryption
              Public Key: (512 bit)
                  Modulus:
!                     00:b2:d1:3b:62:9b:64:a2:23:fa:15:f3:fb:87:fc:
!                     af:12:22:3f:4c:c6:87:ce:5b:ef:a6:dd:e8:ca:cc:
!                     81:da:17:61:e0:bc:49:04:79:34:2e:3f:4a:c1:3a:
!                     7f:d9:8e:cc:84:e6:b3:4d:8f:a5:18:24:e3:c8:77:
!                     32:d9:63:38:a7
                  Exponent: 65537 (0x10001)
          Attributes:
              a0:00
      Signature Algorithm: md5withRSAEncryption
!         51:76:ee:39:87:61:8b:f5:c7:14:03:24:d0:d6:98:7b:6d:c9:
!         df:e5:ee:fd:02:5d:27:a7:4e:50:76:71:b1:b4:27:2e:9f:47:
!         1f:46:e4:24:e3:55:49:59:2d:2b:dc:ad:f0:0a:6b:50:e1:be:
!         8d:04:6c:eb:4f:01:36:8e:38:4f
  -----BEGIN CERTIFICATE REQUEST-----
  MIHxMIGcAgEAMDkxCzAJBgNVBAYTAkFVMRcwFQYDVQQKEw5Eb2RneSBCcm90aGVy
! czERMA8GA1UEAxMIRG9kZ3kgQ0EwWjALBgkqhkiG9w0BAQEDSwAwSAJBALLRO2Kb
! ZKIj+hXz+4f8rxIiP0zGh85b76bd6MrMgdoXYeC8SQR5NC4/SsE6f9mOzITms02P
! pRgk48h3MtljOKcCAwEAAaAAMA0GCSqGSIb3DQEBBAUAA0EAUXbuOYdhi/XHFAMk
! 0NaYe23J3+Xu/QJdJ6dOUHZxsbQnLp9HH0bkJONVSVktK9yt8AprUOG+jQRs608B
! No44Tw==
  -----END CERTIFICATE REQUEST-----
--- 6,29 ----
              Public Key Algorithm: rsaEncryption
              Public Key: (512 bit)
                  Modulus:
!                     00:d0:31:cc:fe:04:5d:a8:89:38:b4:85:59:b3:53:
!                     9e:3c:6b:63:28:f9:23:12:71:b0:7e:6a:3b:54:57:
!                     a3:73:71:a4:49:31:80:f8:a7:35:18:fc:4d:7d:f5:
!                     f5:eb:4d:33:36:fc:41:50:70:9b:75:12:8c:72:af:
!                     20:64:eb:4e:89
                  Exponent: 65537 (0x10001)
          Attributes:
              a0:00
      Signature Algorithm: md5withRSAEncryption
!         9b:81:6e:35:32:b5:cf:8c:49:e2:45:9f:18:dc:71:6a:df:de:
!         cf:c9:53:73:fd:82:94:cd:b6:b3:54:1a:85:06:ef:cf:0e:bd:
!         5c:35:68:f9:32:38:70:ac:a1:8b:b3:94:a2:13:32:35:60:e4:
!         a5:47:67:c1:24:50:9a:29:2a:c3
  -----BEGIN CERTIFICATE REQUEST-----
  MIHxMIGcAgEAMDkxCzAJBgNVBAYTAkFVMRcwFQYDVQQKEw5Eb2RneSBCcm90aGVy
! czERMA8GA1UEAxMIRG9kZ3kgQ0EwWjALBgkqhkiG9w0BAQEDSwAwSAJBANAxzP4E
! XaiJOLSFWbNTnjxrYyj5IxJxsH5qO1RXo3NxpEkxgPinNRj8TX319etNMzb8QVBw
! m3USjHKvIGTrTokCAwEAAaAAMA0GCSqGSIb3DQEBBAUAA0EAm4FuNTK1z4xJ4kWf
! GNxxat/ez8lTc/2ClM22s1QahQbvzw69XDVo+TI4cKyhi7OUohMyNWDkpUdnwSRQ
! mikqww==
  -----END CERTIFICATE REQUEST-----
*** /var/spool/ftp/pub/Crypto/SSL/064/SSLeay-0.6.3/./ms/REQCA.SS	Wed Jul 24 20:51:53 1996
--- ./ms/REQCA.SS	Thu Aug 29 23:50:27 1996
***************
*** 1,8 ****
  -----BEGIN CERTIFICATE REQUEST-----
  MIHzMIGeAgEAMDkxCzAJBgNVBAYTAkFVMRcwFQYDVQQKEw5Eb2RneSBCcm90aGVy
! czERMA8GA1UEAxMIRG9kZ3kgQ0EwXDANBgkqhkiG9w0BAQEFAANLADBIAkEAstE7
! YptkoiP6FfP7h/yvEiI/TMaHzlvvpt3oysyB2hdh4LxJBHk0Lj9KwTp/2Y7MhOaz
! TY+lGCTjyHcy2WM4pwIDAQABoAAwDQYJKoZIhvcNAQEEBQADQQAtz9LYedYi5mF6
! oHvR5YMUF8eYoSbyv0E2IcORmaibbI1mRBJt/KyXip3dUrD1tNWhVNcGjsnoiKgZ
! xcVZg663
  -----END CERTIFICATE REQUEST-----
--- 1,8 ----
  -----BEGIN CERTIFICATE REQUEST-----
  MIHzMIGeAgEAMDkxCzAJBgNVBAYTAkFVMRcwFQYDVQQKEw5Eb2RneSBCcm90aGVy
! czERMA8GA1UEAxMIRG9kZ3kgQ0EwXDANBgkqhkiG9w0BAQEFAANLADBIAkEA0DHM
! /gRdqIk4tIVZs1OePGtjKPkjEnGwfmo7VFejc3GkSTGA+Kc1GPxNffX1600zNvxB
! UHCbdRKMcq8gZOtOiQIDAQABoAAwDQYJKoZIhvcNAQEEBQADQQCtfqK1GtOOAnz7
! OjmzeXOhX6dCcWKeI5k55u+eS2duGOHNJIIsMkwN3Dg+FTatnGHfnik/P8aSzFXH
! 9nKLu/6n
  -----END CERTIFICATE REQUEST-----
*** /var/spool/ftp/pub/Crypto/SSL/064/SSLeay-0.6.3/./ms/REQU.SS	Wed Jul 24 20:52:05 1996
--- ./ms/REQU.SS	Thu Aug 29 23:50:27 1996
***************
*** 1,8 ****
  -----BEGIN CERTIFICATE REQUEST-----
  MIH0MIGfAgEAMDoxCzAJBgNVBAYTAkFVMRcwFQYDVQQKEw5Eb2RneSBCcm90aGVy
! czESMBAGA1UEAxMJQSBCcm90aGVyMFwwDQYJKoZIhvcNAQEBBQADSwAwSAJBANgx
! Vmtg+5HMLTs94Jfx8b/aw1tweGtcr6qnfvngXfHaH420ib8lFhfK4kOoN8O9wIsD
! evJSa4unjUHtYLStvG0CAwEAAaAAMA0GCSqGSIb3DQEBBAUAA0EApCj1prkhCwJ8
! dMjkHtA/VDnS+xf7eXDhZOxAZ66FJDgYvR5+8WR/ehv/r72ThESpf4/5pdM28TCL
! mHz2t/d+GQ==
  -----END CERTIFICATE REQUEST-----
--- 1,8 ----
  -----BEGIN CERTIFICATE REQUEST-----
  MIH0MIGfAgEAMDoxCzAJBgNVBAYTAkFVMRcwFQYDVQQKEw5Eb2RneSBCcm90aGVy
! czESMBAGA1UEAxMJQSBCcm90aGVyMFwwDQYJKoZIhvcNAQEBBQADSwAwSAJBANYU
! Vgbn8r6FPV1Bm2C2qdLiv0cvd6JVgIfSFTomowxHW6TqkzgnEJlcmljZMI7s0Fz0
! G/HTJi8GAWgrO9u1OT0CAwEAAaAAMA0GCSqGSIb3DQEBBAUAA0EARXZf67U/U3R1
! 1hLlYwAZ1yCvxAOBKWPqKQtw0ggv53QClGqAyJEiOKyIDp0lxOQwm/JfNou2D24N
! xxUszgQoZg==
  -----END CERTIFICATE REQUEST-----
*** /var/spool/ftp/pub/Crypto/SSL/064/SSLeay-0.6.3/./ms/ssl16.def	Thu Aug  8 01:54:57 1996
--- ./ms/ssl16.def	Fri Aug 30 04:41:27 1996
***************
*** 22,28 ****
      _SSL_CTX_set_cert_verify_cb         @5
      _SSL_CTX_set_cipher_list            @6
      _SSL_CTX_set_default_passwd_cb      @72
!     _SSL_CTX_set_default_verify         @7
      _SSL_CTX_use_PrivateKey             @61
      _SSL_CTX_use_PrivateKey_ASN1        @62
      _SSL_CTX_use_PrivateKey_file        @63
--- 22,28 ----
      _SSL_CTX_set_cert_verify_cb         @5
      _SSL_CTX_set_cipher_list            @6
      _SSL_CTX_set_default_passwd_cb      @72
!     _SSL_CTX_set_verify                 @7
      _SSL_CTX_use_PrivateKey             @61
      _SSL_CTX_use_PrivateKey_ASN1        @62
      _SSL_CTX_use_PrivateKey_file        @63
***************
*** 46,51 ****
--- 46,52 ----
      _SSL_flush_sessions                 @20
      _SSL_free                           @21
      _SSL_get_cipher                     @22
+     _SSL_get_cipher_bits                @73
      _SSL_get_cipher_list                @23
      _SSL_get_fd                         @24
      _SSL_get_peer_certificate           @25
*** /var/spool/ftp/pub/Crypto/SSL/064/SSLeay-0.6.3/./ms/ssl32.def	Thu Aug  8 01:54:57 1996
--- ./ms/ssl32.def	Fri Aug 30 04:41:28 1996
***************
*** 14,20 ****
      SSL_CTX_set_cert_verify_cb         @5
      SSL_CTX_set_cipher_list            @6
      SSL_CTX_set_default_passwd_cb      @72
!     SSL_CTX_set_default_verify         @7
      SSL_CTX_use_PrivateKey             @61
      SSL_CTX_use_PrivateKey_ASN1        @62
      SSL_CTX_use_PrivateKey_file        @63
--- 14,20 ----
      SSL_CTX_set_cert_verify_cb         @5
      SSL_CTX_set_cipher_list            @6
      SSL_CTX_set_default_passwd_cb      @72
!     SSL_CTX_set_verify                 @7
      SSL_CTX_use_PrivateKey             @61
      SSL_CTX_use_PrivateKey_ASN1        @62
      SSL_CTX_use_PrivateKey_file        @63
***************
*** 39,44 ****
--- 39,45 ----
      SSL_flush_sessions                 @20
      SSL_free                           @21
      SSL_get_cipher                     @22
+     SSL_get_cipher_bits                @73
      SSL_get_cipher_list                @23
      SSL_get_fd                         @24
      SSL_get_peer_certificate           @25
*** /var/spool/ftp/pub/Crypto/SSL/064/SSLeay-0.6.3/./ms/w31.mak	Thu Aug  8 01:54:51 1996
--- ./ms/w31.mak	Fri Aug 30 04:41:22 1996
***************
*** 11,17 ****
  # The one monster makefile better suits building in non-unix
  # environments.
  
! INSTALLTOP=/usr/local/ssl
  
  # Set your compiler options
  CC=cl
--- 11,17 ----
  # The one monster makefile better suits building in non-unix
  # environments.
  
! INSTALLTOP=\usr\local\ssl
  
  # Set your compiler options
  CC=cl
***************
*** 128,208 ****
  	$(OBJ_D)\hashdir.obj $(OBJ_D)\s_time.obj $(OBJ_D)\s_mult.obj \
  	$(OBJ_D)\apps.obj $(OBJ_D)\s_cb.obj $(OBJ_D)\s_socket.obj \
  	$(OBJ_D)\s_eio.obj $(OBJ_D)\version.obj $(OBJ_D)\sess_id.obj \
! 	$(OBJ_D)\ssleay.obj
  
  CRYPTOOBJ=$(OBJ_D)\cryptlib.obj \
! 	$(OBJ_D)\md2_dgst.obj $(OBJ_D)\md5_dgst.obj $(OBJ_D)\md2_one.obj \
! 	$(OBJ_D)\md5_one.obj $(OBJ_D)\sha_dgst.obj $(OBJ_D)\sha1dgst.obj \
! 	$(OBJ_D)\sha_one.obj $(OBJ_D)\sha1_one.obj $(OBJ_D)\set_key.obj \
! 	$(OBJ_D)\ecb_enc.obj $(OBJ_D)\ede_enc.obj $(OBJ_D)\cbc_enc.obj \
! 	$(OBJ_D)\cbc3_enc.obj $(OBJ_D)\ecb3_enc.obj $(OBJ_D)\cfb64enc.obj \
! 	$(OBJ_D)\cfb64ede.obj $(OBJ_D)\cfb_enc.obj $(OBJ_D)\ofb64ede.obj \
! 	$(OBJ_D)\enc_read.obj $(OBJ_D)\enc_writ.obj $(OBJ_D)\fcrypt.obj \
! 	$(OBJ_D)\ncbc_enc.obj $(OBJ_D)\ofb64enc.obj $(OBJ_D)\ofb_enc.obj \
! 	$(OBJ_D)\str2key.obj $(OBJ_D)\pcbc_enc.obj $(OBJ_D)\qud_cksm.obj \
! 	$(OBJ_D)\rand_key.obj $(OBJ_D)\xcbc_enc.obj $(OBJ_D)\read_pwd.obj \
! 	$(OBJ_D)\rpc_enc.obj $(OBJ_D)\cbc_cksm.obj $(OBJ_D)\supp.obj \
! 	$(OBJ_D)\rc4_enc.obj $(OBJ_D)\rc2_ecb.obj $(OBJ_D)\rc2_skey.obj \
! 	$(OBJ_D)\rc2_cbc.obj $(OBJ_D)\rc2cfb64.obj $(OBJ_D)\rc2ofb64.obj \
! 	$(OBJ_D)\i_cbc.obj $(OBJ_D)\i_cfb64.obj $(OBJ_D)\i_ofb64.obj \
! 	$(OBJ_D)\i_ecb.obj $(OBJ_D)\i_skey.obj $(OBJ_D)\bn_add.obj \
! 	$(OBJ_D)\bn_div.obj $(OBJ_D)\bn_exp.obj $(OBJ_D)\bn_lib.obj \
! 	$(OBJ_D)\bn_mod.obj $(OBJ_D)\bn_mul.obj $(OBJ_D)\bn_print.obj \
! 	$(OBJ_D)\bn_rand.obj $(OBJ_D)\bn_shift.obj $(OBJ_D)\bn_sub.obj \
! 	$(OBJ_D)\bn_word.obj $(OBJ_D)\bn_gcd.obj $(OBJ_D)\bn_prime.obj \
! 	$(OBJ_D)\bn_err.obj $(OBJ_D)\bn_sqr.obj $(BN_MULW_OBJ) \
! 	$(OBJ_D)\bn_recp.obj $(OBJ_D)\bn_mont.obj $(OBJ_D)\rsa_enc.obj \
! 	$(OBJ_D)\rsa_gen.obj $(OBJ_D)\rsa_lib.obj $(OBJ_D)\rsa_sign.obj \
! 	$(OBJ_D)\rsa_err.obj $(OBJ_D)\dsa_lib.obj $(OBJ_D)\dsa_vrf.obj \
! 	$(OBJ_D)\dsa_sign.obj $(OBJ_D)\dsa_err.obj $(OBJ_D)\dh_gen.obj \
! 	$(OBJ_D)\dh_key.obj $(OBJ_D)\dh_lib.obj $(OBJ_D)\dh_check.obj \
! 	$(OBJ_D)\dh_err.obj $(OBJ_D)\buffer.obj $(OBJ_D)\bio_lib.obj \
! 	$(OBJ_D)\bio_cb.obj $(OBJ_D)\buf_err.obj $(OBJ_D)\bss_mem.obj \
! 	$(OBJ_D)\bss_null.obj $(OBJ_D)\bss_fd.obj $(OBJ_D)\bss_file.obj \
! 	$(OBJ_D)\bss_sock.obj $(OBJ_D)\bf_buff.obj $(OBJ_D)\stack.obj \
! 	$(OBJ_D)\lhash.obj $(OBJ_D)\lh_stats.obj $(OBJ_D)\md5_rand.obj \
! 	$(OBJ_D)\randfile.obj $(OBJ_D)\err.obj $(OBJ_D)\err_all.obj \
! 	$(OBJ_D)\obj_dat.obj $(OBJ_D)\obj_lib.obj $(OBJ_D)\obj_err.obj \
! 	$(OBJ_D)\encode.obj $(OBJ_D)\digest.obj $(OBJ_D)\evp_enc.obj \
! 	$(OBJ_D)\evp_key.obj $(OBJ_D)\e_ecb_d.obj $(OBJ_D)\e_cbc_d.obj \
! 	$(OBJ_D)\e_cfb_d.obj $(OBJ_D)\e_ofb_d.obj $(OBJ_D)\e_ecb_i.obj \
! 	$(OBJ_D)\e_cbc_i.obj $(OBJ_D)\e_cfb_i.obj $(OBJ_D)\e_ofb_i.obj \
! 	$(OBJ_D)\e_ecb_3d.obj $(OBJ_D)\e_cbc_3d.obj $(OBJ_D)\e_rc4.obj \
! 	$(OBJ_D)\e_names.obj $(OBJ_D)\e_cfb_3d.obj $(OBJ_D)\e_ofb_3d.obj \
! 	$(OBJ_D)\e_xcbc_d.obj $(OBJ_D)\e_ecb_r2.obj $(OBJ_D)\e_cbc_r2.obj \
! 	$(OBJ_D)\e_cfb_r2.obj $(OBJ_D)\e_ofb_r2.obj $(OBJ_D)\m_md2.obj \
! 	$(OBJ_D)\m_md5.obj $(OBJ_D)\m_sha.obj $(OBJ_D)\m_sha1.obj \
! 	$(OBJ_D)\m_dss.obj $(OBJ_D)\m_dss1.obj $(OBJ_D)\m_names.obj \
! 	$(OBJ_D)\p_open.obj $(OBJ_D)\p_seal.obj $(OBJ_D)\p_sign.obj \
! 	$(OBJ_D)\p_verify.obj $(OBJ_D)\p_lib.obj $(OBJ_D)\bio_md.obj \
! 	$(OBJ_D)\evp_err.obj $(OBJ_D)\pem_sign.obj $(OBJ_D)\pem_seal.obj \
! 	$(OBJ_D)\pem_info.obj $(OBJ_D)\pem_lib.obj $(OBJ_D)\pem_err.obj \
! 	$(OBJ_D)\x509_def.obj $(OBJ_D)\x509_r2x.obj $(OBJ_D)\x509_cmp.obj \
! 	$(OBJ_D)\x509_obj.obj $(OBJ_D)\x509_req.obj $(OBJ_D)\x509_vrf.obj \
! 	$(OBJ_D)\x509_crt.obj $(OBJ_D)\x509_ath.obj $(OBJ_D)\x509_err.obj \
! 	$(OBJ_D)\a_object.obj $(OBJ_D)\a_bitstr.obj $(OBJ_D)\a_utctm.obj \
! 	$(OBJ_D)\a_int.obj $(OBJ_D)\a_octet.obj $(OBJ_D)\a_print.obj \
! 	$(OBJ_D)\a_type.obj $(OBJ_D)\a_set.obj $(OBJ_D)\a_dup.obj \
! 	$(OBJ_D)\a_d2i_fp.obj $(OBJ_D)\a_i2d_fp.obj $(OBJ_D)\a_sign.obj \
! 	$(OBJ_D)\a_verify.obj $(OBJ_D)\x_algor.obj $(OBJ_D)\x_val.obj \
! 	$(OBJ_D)\x_pubkey.obj $(OBJ_D)\x_sig.obj $(OBJ_D)\x_req.obj \
! 	$(OBJ_D)\x_attrib.obj $(OBJ_D)\x_name.obj $(OBJ_D)\x_cinf.obj \
! 	$(OBJ_D)\x_x509.obj $(OBJ_D)\x_crl.obj $(OBJ_D)\x_info.obj \
! 	$(OBJ_D)\x_spki.obj $(OBJ_D)\d2i_r_pr.obj $(OBJ_D)\i2d_r_pr.obj \
! 	$(OBJ_D)\d2i_r_pu.obj $(OBJ_D)\i2d_r_pu.obj $(OBJ_D)\d2i_s_pr.obj \
! 	$(OBJ_D)\d2i_s_pu.obj $(OBJ_D)\d2i_pu.obj $(OBJ_D)\d2i_pr.obj \
! 	$(OBJ_D)\i2d_pu.obj $(OBJ_D)\i2d_pr.obj $(OBJ_D)\t_req.obj \
! 	$(OBJ_D)\t_x509.obj $(OBJ_D)\t_pkey.obj $(OBJ_D)\p7_i_s.obj \
! 	$(OBJ_D)\p7_signi.obj $(OBJ_D)\p7_signd.obj $(OBJ_D)\p7_recip.obj \
! 	$(OBJ_D)\p7_enc_c.obj $(OBJ_D)\p7_evp.obj $(OBJ_D)\p7_dgst.obj \
! 	$(OBJ_D)\p7_s_e.obj $(OBJ_D)\p7_enc.obj $(OBJ_D)\p7_lib.obj \
! 	$(OBJ_D)\f_int.obj $(OBJ_D)\i2d_dh.obj $(OBJ_D)\d2i_dh.obj \
! 	$(OBJ_D)\n_pkey.obj $(OBJ_D)\a_hdr.obj $(OBJ_D)\x_pkey.obj \
! 	$(OBJ_D)\a_bool.obj $(OBJ_D)\x_exten.obj $(OBJ_D)\asn1_par.obj \
! 	$(OBJ_D)\asn1_lib.obj $(OBJ_D)\asn1_err.obj $(OBJ_D)\meth_lib.obj \
! 	$(OBJ_D)\x509meth.obj $(OBJ_D)\by_file.obj $(OBJ_D)\by_dir.obj \
! 	$(OBJ_D)\meth_err.obj $(OBJ_D)\conf.obj $(OBJ_D)\conf_err.obj \
! 	$(OBJ_D)\txt_db.obj
  
  SSLOBJ=$(OBJ_D)\ssl_lib.obj \
  	$(OBJ_D)\ssl_err2.obj $(OBJ_D)\ssl_trc.obj $(OBJ_D)\ssl_cert.obj \
--- 128,208 ----
  	$(OBJ_D)\hashdir.obj $(OBJ_D)\s_time.obj $(OBJ_D)\s_mult.obj \
  	$(OBJ_D)\apps.obj $(OBJ_D)\s_cb.obj $(OBJ_D)\s_socket.obj \
  	$(OBJ_D)\s_eio.obj $(OBJ_D)\version.obj $(OBJ_D)\sess_id.obj \
! 	$(OBJ_D)\ciphers.obj $(OBJ_D)\ssleay.obj
  
  CRYPTOOBJ=$(OBJ_D)\cryptlib.obj \
! 	$(OBJ_D)\mem.obj $(OBJ_D)\md2_dgst.obj $(OBJ_D)\md5_dgst.obj \
! 	$(OBJ_D)\md2_one.obj $(OBJ_D)\md5_one.obj $(OBJ_D)\sha_dgst.obj \
! 	$(OBJ_D)\sha1dgst.obj $(OBJ_D)\sha_one.obj $(OBJ_D)\sha1_one.obj \
! 	$(OBJ_D)\set_key.obj $(OBJ_D)\ecb_enc.obj $(OBJ_D)\ede_enc.obj \
! 	$(OBJ_D)\cbc_enc.obj $(OBJ_D)\cbc3_enc.obj $(OBJ_D)\ecb3_enc.obj \
! 	$(OBJ_D)\cfb64enc.obj $(OBJ_D)\cfb64ede.obj $(OBJ_D)\cfb_enc.obj \
! 	$(OBJ_D)\ofb64ede.obj $(OBJ_D)\enc_read.obj $(OBJ_D)\enc_writ.obj \
! 	$(OBJ_D)\fcrypt.obj $(OBJ_D)\ncbc_enc.obj $(OBJ_D)\ofb64enc.obj \
! 	$(OBJ_D)\ofb_enc.obj $(OBJ_D)\str2key.obj $(OBJ_D)\pcbc_enc.obj \
! 	$(OBJ_D)\qud_cksm.obj $(OBJ_D)\rand_key.obj $(OBJ_D)\xcbc_enc.obj \
! 	$(OBJ_D)\read_pwd.obj $(OBJ_D)\rpc_enc.obj $(OBJ_D)\cbc_cksm.obj \
! 	$(OBJ_D)\supp.obj $(OBJ_D)\rc4_enc.obj $(OBJ_D)\rc2_ecb.obj \
! 	$(OBJ_D)\rc2_skey.obj $(OBJ_D)\rc2_cbc.obj $(OBJ_D)\rc2cfb64.obj \
! 	$(OBJ_D)\rc2ofb64.obj $(OBJ_D)\i_cbc.obj $(OBJ_D)\i_cfb64.obj \
! 	$(OBJ_D)\i_ofb64.obj $(OBJ_D)\i_ecb.obj $(OBJ_D)\i_skey.obj \
! 	$(OBJ_D)\bn_add.obj $(OBJ_D)\bn_div.obj $(OBJ_D)\bn_exp.obj \
! 	$(OBJ_D)\bn_lib.obj $(OBJ_D)\bn_mod.obj $(OBJ_D)\bn_mul.obj \
! 	$(OBJ_D)\bn_print.obj $(OBJ_D)\bn_rand.obj $(OBJ_D)\bn_shift.obj \
! 	$(OBJ_D)\bn_sub.obj $(OBJ_D)\bn_word.obj $(OBJ_D)\bn_gcd.obj \
! 	$(OBJ_D)\bn_prime.obj $(OBJ_D)\bn_err.obj $(OBJ_D)\bn_sqr.obj \
! 	$(BN_MULW_OBJ) $(OBJ_D)\bn_recp.obj $(OBJ_D)\bn_mont.obj \
! 	$(OBJ_D)\rsa_enc.obj $(OBJ_D)\rsa_gen.obj $(OBJ_D)\rsa_lib.obj \
! 	$(OBJ_D)\rsa_sign.obj $(OBJ_D)\rsa_err.obj $(OBJ_D)\dsa_lib.obj \
! 	$(OBJ_D)\dsa_vrf.obj $(OBJ_D)\dsa_sign.obj $(OBJ_D)\dsa_err.obj \
! 	$(OBJ_D)\dh_gen.obj $(OBJ_D)\dh_key.obj $(OBJ_D)\dh_lib.obj \
! 	$(OBJ_D)\dh_check.obj $(OBJ_D)\dh_err.obj $(OBJ_D)\buffer.obj \
! 	$(OBJ_D)\bio_lib.obj $(OBJ_D)\bio_cb.obj $(OBJ_D)\buf_err.obj \
! 	$(OBJ_D)\bss_mem.obj $(OBJ_D)\bss_null.obj $(OBJ_D)\bss_fd.obj \
! 	$(OBJ_D)\bss_file.obj $(OBJ_D)\bss_sock.obj $(OBJ_D)\bf_buff.obj \
! 	$(OBJ_D)\stack.obj $(OBJ_D)\lhash.obj $(OBJ_D)\lh_stats.obj \
! 	$(OBJ_D)\md5_rand.obj $(OBJ_D)\randfile.obj $(OBJ_D)\err.obj \
! 	$(OBJ_D)\err_all.obj $(OBJ_D)\obj_dat.obj $(OBJ_D)\obj_lib.obj \
! 	$(OBJ_D)\obj_err.obj $(OBJ_D)\encode.obj $(OBJ_D)\digest.obj \
! 	$(OBJ_D)\evp_enc.obj $(OBJ_D)\evp_key.obj $(OBJ_D)\e_ecb_d.obj \
! 	$(OBJ_D)\e_cbc_d.obj $(OBJ_D)\e_cfb_d.obj $(OBJ_D)\e_ofb_d.obj \
! 	$(OBJ_D)\e_ecb_i.obj $(OBJ_D)\e_cbc_i.obj $(OBJ_D)\e_cfb_i.obj \
! 	$(OBJ_D)\e_ofb_i.obj $(OBJ_D)\e_ecb_3d.obj $(OBJ_D)\e_cbc_3d.obj \
! 	$(OBJ_D)\e_rc4.obj $(OBJ_D)\e_names.obj $(OBJ_D)\e_cfb_3d.obj \
! 	$(OBJ_D)\e_ofb_3d.obj $(OBJ_D)\e_xcbc_d.obj $(OBJ_D)\e_ecb_r2.obj \
! 	$(OBJ_D)\e_cbc_r2.obj $(OBJ_D)\e_cfb_r2.obj $(OBJ_D)\e_ofb_r2.obj \
! 	$(OBJ_D)\m_md2.obj $(OBJ_D)\m_md5.obj $(OBJ_D)\m_sha.obj \
! 	$(OBJ_D)\m_sha1.obj $(OBJ_D)\m_dss.obj $(OBJ_D)\m_dss1.obj \
! 	$(OBJ_D)\m_names.obj $(OBJ_D)\p_open.obj $(OBJ_D)\p_seal.obj \
! 	$(OBJ_D)\p_sign.obj $(OBJ_D)\p_verify.obj $(OBJ_D)\p_lib.obj \
! 	$(OBJ_D)\bio_md.obj $(OBJ_D)\evp_err.obj $(OBJ_D)\pem_sign.obj \
! 	$(OBJ_D)\pem_seal.obj $(OBJ_D)\pem_info.obj $(OBJ_D)\pem_lib.obj \
! 	$(OBJ_D)\pem_err.obj $(OBJ_D)\x509_def.obj $(OBJ_D)\x509_r2x.obj \
! 	$(OBJ_D)\x509_cmp.obj $(OBJ_D)\x509_obj.obj $(OBJ_D)\x509_req.obj \
! 	$(OBJ_D)\x509_vrf.obj $(OBJ_D)\x509_crt.obj $(OBJ_D)\x509_ath.obj \
! 	$(OBJ_D)\x509_err.obj $(OBJ_D)\a_object.obj $(OBJ_D)\a_bitstr.obj \
! 	$(OBJ_D)\a_utctm.obj $(OBJ_D)\a_int.obj $(OBJ_D)\a_octet.obj \
! 	$(OBJ_D)\a_print.obj $(OBJ_D)\a_type.obj $(OBJ_D)\a_set.obj \
! 	$(OBJ_D)\a_dup.obj $(OBJ_D)\a_d2i_fp.obj $(OBJ_D)\a_i2d_fp.obj \
! 	$(OBJ_D)\a_sign.obj $(OBJ_D)\a_verify.obj $(OBJ_D)\x_algor.obj \
! 	$(OBJ_D)\x_val.obj $(OBJ_D)\x_pubkey.obj $(OBJ_D)\x_sig.obj \
! 	$(OBJ_D)\x_req.obj $(OBJ_D)\x_attrib.obj $(OBJ_D)\x_name.obj \
! 	$(OBJ_D)\x_cinf.obj $(OBJ_D)\x_x509.obj $(OBJ_D)\x_crl.obj \
! 	$(OBJ_D)\x_info.obj $(OBJ_D)\x_spki.obj $(OBJ_D)\d2i_r_pr.obj \
! 	$(OBJ_D)\i2d_r_pr.obj $(OBJ_D)\d2i_r_pu.obj $(OBJ_D)\i2d_r_pu.obj \
! 	$(OBJ_D)\d2i_s_pr.obj $(OBJ_D)\d2i_s_pu.obj $(OBJ_D)\d2i_pu.obj \
! 	$(OBJ_D)\d2i_pr.obj $(OBJ_D)\i2d_pu.obj $(OBJ_D)\i2d_pr.obj \
! 	$(OBJ_D)\t_req.obj $(OBJ_D)\t_x509.obj $(OBJ_D)\t_pkey.obj \
! 	$(OBJ_D)\p7_i_s.obj $(OBJ_D)\p7_signi.obj $(OBJ_D)\p7_signd.obj \
! 	$(OBJ_D)\p7_recip.obj $(OBJ_D)\p7_enc_c.obj $(OBJ_D)\p7_evp.obj \
! 	$(OBJ_D)\p7_dgst.obj $(OBJ_D)\p7_s_e.obj $(OBJ_D)\p7_enc.obj \
! 	$(OBJ_D)\p7_lib.obj $(OBJ_D)\f_int.obj $(OBJ_D)\i2d_dh.obj \
! 	$(OBJ_D)\d2i_dh.obj $(OBJ_D)\n_pkey.obj $(OBJ_D)\a_hdr.obj \
! 	$(OBJ_D)\x_pkey.obj $(OBJ_D)\a_bool.obj $(OBJ_D)\x_exten.obj \
! 	$(OBJ_D)\asn1_par.obj $(OBJ_D)\asn1_lib.obj $(OBJ_D)\asn1_err.obj \
! 	$(OBJ_D)\meth_lib.obj $(OBJ_D)\x509meth.obj $(OBJ_D)\by_file.obj \
! 	$(OBJ_D)\by_dir.obj $(OBJ_D)\meth_err.obj $(OBJ_D)\conf.obj \
! 	$(OBJ_D)\conf_err.obj $(OBJ_D)\txt_db.obj
  
  SSLOBJ=$(OBJ_D)\ssl_lib.obj \
  	$(OBJ_D)\ssl_err2.obj $(OBJ_D)\ssl_trc.obj $(OBJ_D)\ssl_cert.obj \
***************
*** 573,578 ****
--- 573,581 ----
  $(OBJ_D)\sess_id.obj: $(SRC_D)\apps\sess_id.c
  	$(CC) /Fo$(OBJ_D)\sess_id.obj -DMONOLITH $(APP_CFLAGS) -c $(SRC_D)\apps\sess_id.c
  
+ $(OBJ_D)\ciphers.obj: $(SRC_D)\apps\ciphers.c
+ 	$(CC) /Fo$(OBJ_D)\ciphers.obj -DMONOLITH $(APP_CFLAGS) -c $(SRC_D)\apps\ciphers.c
+ 
  $(OBJ_D)\ssleay.obj: $(SRC_D)\apps\ssleay.c
  	$(CC) /Fo$(OBJ_D)\ssleay.obj -DMONOLITH $(APP_CFLAGS) -c $(SRC_D)\apps\ssleay.c
  
***************
*** 582,587 ****
--- 585,593 ----
  $(OBJ_D)\cryptlib.obj: $(SRC_D)\crypto\cryptlib.c
  	$(CC) /Fo$(OBJ_D)\cryptlib.obj $(LIB_CFLAGS) -DCFLAGS="\"$(CC) $(CFLAG)\"" -c $(SRC_D)\crypto\cryptlib.c
  
+ $(OBJ_D)\mem.obj: $(SRC_D)\crypto\mem.c
+ 	$(CC) /Fo$(OBJ_D)\mem.obj $(LIB_CFLAGS) -c $(SRC_D)\crypto\mem.c
+ 
  $(OBJ_D)\md2_dgst.obj: $(SRC_D)\crypto\md\md2_dgst.c
  	$(CC) /Fo$(OBJ_D)\md2_dgst.obj $(LIB_CFLAGS) -c $(SRC_D)\crypto\md\md2_dgst.c
  
***************
*** 1405,1411 ****
  <<
  
  $(O_SSL): $(SSLOBJ)
- 	$(RM) $(O_SSL)
  	$(MKLIB) @<<
  $(O_SSL)
  y
--- 1411,1416 ----
***************
*** 1436,1442 ****
  <<
  
  $(O_RSAGLUE): $(RSAGLUEOBJ)
- 	$(RM) $(O_RSAGLUE)
  	$(MKLIB) @<<
  $(O_RSAGLUE)
  y
--- 1441,1446 ----
***************
*** 1447,1453 ****
  <<
  
  $(O_CRYPTO): $(CRYPTOOBJ)
- 	$(RM) $(O_CRYPTO)
  	$(MKLIB) @<<
  $(O_CRYPTO)
  y
--- 1451,1456 ----
***************
*** 1582,1587 ****
--- 1585,1591 ----
  +$(OBJ_D)\md5_dgst.obj &
  +$(OBJ_D)\md5_one.obj &
  +$(OBJ_D)\md5_rand.obj &
+ +$(OBJ_D)\mem.obj &
  +$(OBJ_D)\meth_err.obj &
  +$(OBJ_D)\meth_lib.obj &
  +$(OBJ_D)\n_pkey.obj &
***************
*** 1676,1681 ****
--- 1680,1686 ----
    $(OBJ_D)\apps.obj +
    $(OBJ_D)\asn1pars.obj +
    $(OBJ_D)\ca.obj +
+   $(OBJ_D)\ciphers.obj +
    $(OBJ_D)\crl.obj +
    $(OBJ_D)\crl2p7.obj +
    $(OBJ_D)\dgst.obj +
*** /var/spool/ftp/pub/Crypto/SSL/064/SSLeay-0.6.3/./ms/w31dll.mak	Thu Aug  8 01:54:51 1996
--- ./ms/w31dll.mak	Fri Aug 30 04:41:23 1996
***************
*** 11,17 ****
  # The one monster makefile better suits building in non-unix
  # environments.
  
! INSTALLTOP=/usr/local/ssl
  
  # Set your compiler options
  CC=cl
--- 11,17 ----
  # The one monster makefile better suits building in non-unix
  # environments.
  
! INSTALLTOP=\usr\local\ssl
  
  # Set your compiler options
  CC=cl
***************
*** 128,208 ****
  	$(OBJ_D)\hashdir.obj $(OBJ_D)\s_time.obj $(OBJ_D)\s_mult.obj \
  	$(OBJ_D)\apps.obj $(OBJ_D)\s_cb.obj $(OBJ_D)\s_socket.obj \
  	$(OBJ_D)\s_eio.obj $(OBJ_D)\version.obj $(OBJ_D)\sess_id.obj \
! 	$(OBJ_D)\ssleay.obj
  
  CRYPTOOBJ=$(OBJ_D)\cryptlib.obj \
! 	$(OBJ_D)\md2_dgst.obj $(OBJ_D)\md5_dgst.obj $(OBJ_D)\md2_one.obj \
! 	$(OBJ_D)\md5_one.obj $(OBJ_D)\sha_dgst.obj $(OBJ_D)\sha1dgst.obj \
! 	$(OBJ_D)\sha_one.obj $(OBJ_D)\sha1_one.obj $(OBJ_D)\set_key.obj \
! 	$(OBJ_D)\ecb_enc.obj $(OBJ_D)\ede_enc.obj $(OBJ_D)\cbc_enc.obj \
! 	$(OBJ_D)\cbc3_enc.obj $(OBJ_D)\ecb3_enc.obj $(OBJ_D)\cfb64enc.obj \
! 	$(OBJ_D)\cfb64ede.obj $(OBJ_D)\cfb_enc.obj $(OBJ_D)\ofb64ede.obj \
! 	$(OBJ_D)\enc_read.obj $(OBJ_D)\enc_writ.obj $(OBJ_D)\fcrypt.obj \
! 	$(OBJ_D)\ncbc_enc.obj $(OBJ_D)\ofb64enc.obj $(OBJ_D)\ofb_enc.obj \
! 	$(OBJ_D)\str2key.obj $(OBJ_D)\pcbc_enc.obj $(OBJ_D)\qud_cksm.obj \
! 	$(OBJ_D)\rand_key.obj $(OBJ_D)\xcbc_enc.obj $(OBJ_D)\read_pwd.obj \
! 	$(OBJ_D)\rpc_enc.obj $(OBJ_D)\cbc_cksm.obj $(OBJ_D)\supp.obj \
! 	$(OBJ_D)\rc4_enc.obj $(OBJ_D)\rc2_ecb.obj $(OBJ_D)\rc2_skey.obj \
! 	$(OBJ_D)\rc2_cbc.obj $(OBJ_D)\rc2cfb64.obj $(OBJ_D)\rc2ofb64.obj \
! 	$(OBJ_D)\i_cbc.obj $(OBJ_D)\i_cfb64.obj $(OBJ_D)\i_ofb64.obj \
! 	$(OBJ_D)\i_ecb.obj $(OBJ_D)\i_skey.obj $(OBJ_D)\bn_add.obj \
! 	$(OBJ_D)\bn_div.obj $(OBJ_D)\bn_exp.obj $(OBJ_D)\bn_lib.obj \
! 	$(OBJ_D)\bn_mod.obj $(OBJ_D)\bn_mul.obj $(OBJ_D)\bn_print.obj \
! 	$(OBJ_D)\bn_rand.obj $(OBJ_D)\bn_shift.obj $(OBJ_D)\bn_sub.obj \
! 	$(OBJ_D)\bn_word.obj $(OBJ_D)\bn_gcd.obj $(OBJ_D)\bn_prime.obj \
! 	$(OBJ_D)\bn_err.obj $(OBJ_D)\bn_sqr.obj $(BN_MULW_OBJ) \
! 	$(OBJ_D)\bn_recp.obj $(OBJ_D)\bn_mont.obj $(OBJ_D)\rsa_enc.obj \
! 	$(OBJ_D)\rsa_gen.obj $(OBJ_D)\rsa_lib.obj $(OBJ_D)\rsa_sign.obj \
! 	$(OBJ_D)\rsa_err.obj $(OBJ_D)\dsa_lib.obj $(OBJ_D)\dsa_vrf.obj \
! 	$(OBJ_D)\dsa_sign.obj $(OBJ_D)\dsa_err.obj $(OBJ_D)\dh_gen.obj \
! 	$(OBJ_D)\dh_key.obj $(OBJ_D)\dh_lib.obj $(OBJ_D)\dh_check.obj \
! 	$(OBJ_D)\dh_err.obj $(OBJ_D)\buffer.obj $(OBJ_D)\bio_lib.obj \
! 	$(OBJ_D)\bio_cb.obj $(OBJ_D)\buf_err.obj $(OBJ_D)\bss_mem.obj \
! 	$(OBJ_D)\bss_null.obj $(OBJ_D)\bss_fd.obj $(OBJ_D)\bss_file.obj \
! 	$(OBJ_D)\bss_sock.obj $(OBJ_D)\bf_buff.obj $(OBJ_D)\stack.obj \
! 	$(OBJ_D)\lhash.obj $(OBJ_D)\lh_stats.obj $(OBJ_D)\md5_rand.obj \
! 	$(OBJ_D)\randfile.obj $(OBJ_D)\err.obj $(OBJ_D)\err_all.obj \
! 	$(OBJ_D)\obj_dat.obj $(OBJ_D)\obj_lib.obj $(OBJ_D)\obj_err.obj \
! 	$(OBJ_D)\encode.obj $(OBJ_D)\digest.obj $(OBJ_D)\evp_enc.obj \
! 	$(OBJ_D)\evp_key.obj $(OBJ_D)\e_ecb_d.obj $(OBJ_D)\e_cbc_d.obj \
! 	$(OBJ_D)\e_cfb_d.obj $(OBJ_D)\e_ofb_d.obj $(OBJ_D)\e_ecb_i.obj \
! 	$(OBJ_D)\e_cbc_i.obj $(OBJ_D)\e_cfb_i.obj $(OBJ_D)\e_ofb_i.obj \
! 	$(OBJ_D)\e_ecb_3d.obj $(OBJ_D)\e_cbc_3d.obj $(OBJ_D)\e_rc4.obj \
! 	$(OBJ_D)\e_names.obj $(OBJ_D)\e_cfb_3d.obj $(OBJ_D)\e_ofb_3d.obj \
! 	$(OBJ_D)\e_xcbc_d.obj $(OBJ_D)\e_ecb_r2.obj $(OBJ_D)\e_cbc_r2.obj \
! 	$(OBJ_D)\e_cfb_r2.obj $(OBJ_D)\e_ofb_r2.obj $(OBJ_D)\m_md2.obj \
! 	$(OBJ_D)\m_md5.obj $(OBJ_D)\m_sha.obj $(OBJ_D)\m_sha1.obj \
! 	$(OBJ_D)\m_dss.obj $(OBJ_D)\m_dss1.obj $(OBJ_D)\m_names.obj \
! 	$(OBJ_D)\p_open.obj $(OBJ_D)\p_seal.obj $(OBJ_D)\p_sign.obj \
! 	$(OBJ_D)\p_verify.obj $(OBJ_D)\p_lib.obj $(OBJ_D)\bio_md.obj \
! 	$(OBJ_D)\evp_err.obj $(OBJ_D)\pem_sign.obj $(OBJ_D)\pem_seal.obj \
! 	$(OBJ_D)\pem_info.obj $(OBJ_D)\pem_lib.obj $(OBJ_D)\pem_err.obj \
! 	$(OBJ_D)\x509_def.obj $(OBJ_D)\x509_r2x.obj $(OBJ_D)\x509_cmp.obj \
! 	$(OBJ_D)\x509_obj.obj $(OBJ_D)\x509_req.obj $(OBJ_D)\x509_vrf.obj \
! 	$(OBJ_D)\x509_crt.obj $(OBJ_D)\x509_ath.obj $(OBJ_D)\x509_err.obj \
! 	$(OBJ_D)\a_object.obj $(OBJ_D)\a_bitstr.obj $(OBJ_D)\a_utctm.obj \
! 	$(OBJ_D)\a_int.obj $(OBJ_D)\a_octet.obj $(OBJ_D)\a_print.obj \
! 	$(OBJ_D)\a_type.obj $(OBJ_D)\a_set.obj $(OBJ_D)\a_dup.obj \
! 	$(OBJ_D)\a_d2i_fp.obj $(OBJ_D)\a_i2d_fp.obj $(OBJ_D)\a_sign.obj \
! 	$(OBJ_D)\a_verify.obj $(OBJ_D)\x_algor.obj $(OBJ_D)\x_val.obj \
! 	$(OBJ_D)\x_pubkey.obj $(OBJ_D)\x_sig.obj $(OBJ_D)\x_req.obj \
! 	$(OBJ_D)\x_attrib.obj $(OBJ_D)\x_name.obj $(OBJ_D)\x_cinf.obj \
! 	$(OBJ_D)\x_x509.obj $(OBJ_D)\x_crl.obj $(OBJ_D)\x_info.obj \
! 	$(OBJ_D)\x_spki.obj $(OBJ_D)\d2i_r_pr.obj $(OBJ_D)\i2d_r_pr.obj \
! 	$(OBJ_D)\d2i_r_pu.obj $(OBJ_D)\i2d_r_pu.obj $(OBJ_D)\d2i_s_pr.obj \
! 	$(OBJ_D)\d2i_s_pu.obj $(OBJ_D)\d2i_pu.obj $(OBJ_D)\d2i_pr.obj \
! 	$(OBJ_D)\i2d_pu.obj $(OBJ_D)\i2d_pr.obj $(OBJ_D)\t_req.obj \
! 	$(OBJ_D)\t_x509.obj $(OBJ_D)\t_pkey.obj $(OBJ_D)\p7_i_s.obj \
! 	$(OBJ_D)\p7_signi.obj $(OBJ_D)\p7_signd.obj $(OBJ_D)\p7_recip.obj \
! 	$(OBJ_D)\p7_enc_c.obj $(OBJ_D)\p7_evp.obj $(OBJ_D)\p7_dgst.obj \
! 	$(OBJ_D)\p7_s_e.obj $(OBJ_D)\p7_enc.obj $(OBJ_D)\p7_lib.obj \
! 	$(OBJ_D)\f_int.obj $(OBJ_D)\i2d_dh.obj $(OBJ_D)\d2i_dh.obj \
! 	$(OBJ_D)\n_pkey.obj $(OBJ_D)\a_hdr.obj $(OBJ_D)\x_pkey.obj \
! 	$(OBJ_D)\a_bool.obj $(OBJ_D)\x_exten.obj $(OBJ_D)\asn1_par.obj \
! 	$(OBJ_D)\asn1_lib.obj $(OBJ_D)\asn1_err.obj $(OBJ_D)\meth_lib.obj \
! 	$(OBJ_D)\x509meth.obj $(OBJ_D)\by_file.obj $(OBJ_D)\by_dir.obj \
! 	$(OBJ_D)\meth_err.obj $(OBJ_D)\conf.obj $(OBJ_D)\conf_err.obj \
! 	$(OBJ_D)\txt_db.obj
  
  SSLOBJ=$(OBJ_D)\ssl_lib.obj \
  	$(OBJ_D)\ssl_err2.obj $(OBJ_D)\ssl_trc.obj $(OBJ_D)\ssl_cert.obj \
--- 128,208 ----
  	$(OBJ_D)\hashdir.obj $(OBJ_D)\s_time.obj $(OBJ_D)\s_mult.obj \
  	$(OBJ_D)\apps.obj $(OBJ_D)\s_cb.obj $(OBJ_D)\s_socket.obj \
  	$(OBJ_D)\s_eio.obj $(OBJ_D)\version.obj $(OBJ_D)\sess_id.obj \
! 	$(OBJ_D)\ciphers.obj $(OBJ_D)\ssleay.obj
  
  CRYPTOOBJ=$(OBJ_D)\cryptlib.obj \
! 	$(OBJ_D)\mem.obj $(OBJ_D)\md2_dgst.obj $(OBJ_D)\md5_dgst.obj \
! 	$(OBJ_D)\md2_one.obj $(OBJ_D)\md5_one.obj $(OBJ_D)\sha_dgst.obj \
! 	$(OBJ_D)\sha1dgst.obj $(OBJ_D)\sha_one.obj $(OBJ_D)\sha1_one.obj \
! 	$(OBJ_D)\set_key.obj $(OBJ_D)\ecb_enc.obj $(OBJ_D)\ede_enc.obj \
! 	$(OBJ_D)\cbc_enc.obj $(OBJ_D)\cbc3_enc.obj $(OBJ_D)\ecb3_enc.obj \
! 	$(OBJ_D)\cfb64enc.obj $(OBJ_D)\cfb64ede.obj $(OBJ_D)\cfb_enc.obj \
! 	$(OBJ_D)\ofb64ede.obj $(OBJ_D)\enc_read.obj $(OBJ_D)\enc_writ.obj \
! 	$(OBJ_D)\fcrypt.obj $(OBJ_D)\ncbc_enc.obj $(OBJ_D)\ofb64enc.obj \
! 	$(OBJ_D)\ofb_enc.obj $(OBJ_D)\str2key.obj $(OBJ_D)\pcbc_enc.obj \
! 	$(OBJ_D)\qud_cksm.obj $(OBJ_D)\rand_key.obj $(OBJ_D)\xcbc_enc.obj \
! 	$(OBJ_D)\read_pwd.obj $(OBJ_D)\rpc_enc.obj $(OBJ_D)\cbc_cksm.obj \
! 	$(OBJ_D)\supp.obj $(OBJ_D)\rc4_enc.obj $(OBJ_D)\rc2_ecb.obj \
! 	$(OBJ_D)\rc2_skey.obj $(OBJ_D)\rc2_cbc.obj $(OBJ_D)\rc2cfb64.obj \
! 	$(OBJ_D)\rc2ofb64.obj $(OBJ_D)\i_cbc.obj $(OBJ_D)\i_cfb64.obj \
! 	$(OBJ_D)\i_ofb64.obj $(OBJ_D)\i_ecb.obj $(OBJ_D)\i_skey.obj \
! 	$(OBJ_D)\bn_add.obj $(OBJ_D)\bn_div.obj $(OBJ_D)\bn_exp.obj \
! 	$(OBJ_D)\bn_lib.obj $(OBJ_D)\bn_mod.obj $(OBJ_D)\bn_mul.obj \
! 	$(OBJ_D)\bn_print.obj $(OBJ_D)\bn_rand.obj $(OBJ_D)\bn_shift.obj \
! 	$(OBJ_D)\bn_sub.obj $(OBJ_D)\bn_word.obj $(OBJ_D)\bn_gcd.obj \
! 	$(OBJ_D)\bn_prime.obj $(OBJ_D)\bn_err.obj $(OBJ_D)\bn_sqr.obj \
! 	$(BN_MULW_OBJ) $(OBJ_D)\bn_recp.obj $(OBJ_D)\bn_mont.obj \
! 	$(OBJ_D)\rsa_enc.obj $(OBJ_D)\rsa_gen.obj $(OBJ_D)\rsa_lib.obj \
! 	$(OBJ_D)\rsa_sign.obj $(OBJ_D)\rsa_err.obj $(OBJ_D)\dsa_lib.obj \
! 	$(OBJ_D)\dsa_vrf.obj $(OBJ_D)\dsa_sign.obj $(OBJ_D)\dsa_err.obj \
! 	$(OBJ_D)\dh_gen.obj $(OBJ_D)\dh_key.obj $(OBJ_D)\dh_lib.obj \
! 	$(OBJ_D)\dh_check.obj $(OBJ_D)\dh_err.obj $(OBJ_D)\buffer.obj \
! 	$(OBJ_D)\bio_lib.obj $(OBJ_D)\bio_cb.obj $(OBJ_D)\buf_err.obj \
! 	$(OBJ_D)\bss_mem.obj $(OBJ_D)\bss_null.obj $(OBJ_D)\bss_fd.obj \
! 	$(OBJ_D)\bss_file.obj $(OBJ_D)\bss_sock.obj $(OBJ_D)\bf_buff.obj \
! 	$(OBJ_D)\stack.obj $(OBJ_D)\lhash.obj $(OBJ_D)\lh_stats.obj \
! 	$(OBJ_D)\md5_rand.obj $(OBJ_D)\randfile.obj $(OBJ_D)\err.obj \
! 	$(OBJ_D)\err_all.obj $(OBJ_D)\obj_dat.obj $(OBJ_D)\obj_lib.obj \
! 	$(OBJ_D)\obj_err.obj $(OBJ_D)\encode.obj $(OBJ_D)\digest.obj \
! 	$(OBJ_D)\evp_enc.obj $(OBJ_D)\evp_key.obj $(OBJ_D)\e_ecb_d.obj \
! 	$(OBJ_D)\e_cbc_d.obj $(OBJ_D)\e_cfb_d.obj $(OBJ_D)\e_ofb_d.obj \
! 	$(OBJ_D)\e_ecb_i.obj $(OBJ_D)\e_cbc_i.obj $(OBJ_D)\e_cfb_i.obj \
! 	$(OBJ_D)\e_ofb_i.obj $(OBJ_D)\e_ecb_3d.obj $(OBJ_D)\e_cbc_3d.obj \
! 	$(OBJ_D)\e_rc4.obj $(OBJ_D)\e_names.obj $(OBJ_D)\e_cfb_3d.obj \
! 	$(OBJ_D)\e_ofb_3d.obj $(OBJ_D)\e_xcbc_d.obj $(OBJ_D)\e_ecb_r2.obj \
! 	$(OBJ_D)\e_cbc_r2.obj $(OBJ_D)\e_cfb_r2.obj $(OBJ_D)\e_ofb_r2.obj \
! 	$(OBJ_D)\m_md2.obj $(OBJ_D)\m_md5.obj $(OBJ_D)\m_sha.obj \
! 	$(OBJ_D)\m_sha1.obj $(OBJ_D)\m_dss.obj $(OBJ_D)\m_dss1.obj \
! 	$(OBJ_D)\m_names.obj $(OBJ_D)\p_open.obj $(OBJ_D)\p_seal.obj \
! 	$(OBJ_D)\p_sign.obj $(OBJ_D)\p_verify.obj $(OBJ_D)\p_lib.obj \
! 	$(OBJ_D)\bio_md.obj $(OBJ_D)\evp_err.obj $(OBJ_D)\pem_sign.obj \
! 	$(OBJ_D)\pem_seal.obj $(OBJ_D)\pem_info.obj $(OBJ_D)\pem_lib.obj \
! 	$(OBJ_D)\pem_err.obj $(OBJ_D)\x509_def.obj $(OBJ_D)\x509_r2x.obj \
! 	$(OBJ_D)\x509_cmp.obj $(OBJ_D)\x509_obj.obj $(OBJ_D)\x509_req.obj \
! 	$(OBJ_D)\x509_vrf.obj $(OBJ_D)\x509_crt.obj $(OBJ_D)\x509_ath.obj \
! 	$(OBJ_D)\x509_err.obj $(OBJ_D)\a_object.obj $(OBJ_D)\a_bitstr.obj \
! 	$(OBJ_D)\a_utctm.obj $(OBJ_D)\a_int.obj $(OBJ_D)\a_octet.obj \
! 	$(OBJ_D)\a_print.obj $(OBJ_D)\a_type.obj $(OBJ_D)\a_set.obj \
! 	$(OBJ_D)\a_dup.obj $(OBJ_D)\a_d2i_fp.obj $(OBJ_D)\a_i2d_fp.obj \
! 	$(OBJ_D)\a_sign.obj $(OBJ_D)\a_verify.obj $(OBJ_D)\x_algor.obj \
! 	$(OBJ_D)\x_val.obj $(OBJ_D)\x_pubkey.obj $(OBJ_D)\x_sig.obj \
! 	$(OBJ_D)\x_req.obj $(OBJ_D)\x_attrib.obj $(OBJ_D)\x_name.obj \
! 	$(OBJ_D)\x_cinf.obj $(OBJ_D)\x_x509.obj $(OBJ_D)\x_crl.obj \
! 	$(OBJ_D)\x_info.obj $(OBJ_D)\x_spki.obj $(OBJ_D)\d2i_r_pr.obj \
! 	$(OBJ_D)\i2d_r_pr.obj $(OBJ_D)\d2i_r_pu.obj $(OBJ_D)\i2d_r_pu.obj \
! 	$(OBJ_D)\d2i_s_pr.obj $(OBJ_D)\d2i_s_pu.obj $(OBJ_D)\d2i_pu.obj \
! 	$(OBJ_D)\d2i_pr.obj $(OBJ_D)\i2d_pu.obj $(OBJ_D)\i2d_pr.obj \
! 	$(OBJ_D)\t_req.obj $(OBJ_D)\t_x509.obj $(OBJ_D)\t_pkey.obj \
! 	$(OBJ_D)\p7_i_s.obj $(OBJ_D)\p7_signi.obj $(OBJ_D)\p7_signd.obj \
! 	$(OBJ_D)\p7_recip.obj $(OBJ_D)\p7_enc_c.obj $(OBJ_D)\p7_evp.obj \
! 	$(OBJ_D)\p7_dgst.obj $(OBJ_D)\p7_s_e.obj $(OBJ_D)\p7_enc.obj \
! 	$(OBJ_D)\p7_lib.obj $(OBJ_D)\f_int.obj $(OBJ_D)\i2d_dh.obj \
! 	$(OBJ_D)\d2i_dh.obj $(OBJ_D)\n_pkey.obj $(OBJ_D)\a_hdr.obj \
! 	$(OBJ_D)\x_pkey.obj $(OBJ_D)\a_bool.obj $(OBJ_D)\x_exten.obj \
! 	$(OBJ_D)\asn1_par.obj $(OBJ_D)\asn1_lib.obj $(OBJ_D)\asn1_err.obj \
! 	$(OBJ_D)\meth_lib.obj $(OBJ_D)\x509meth.obj $(OBJ_D)\by_file.obj \
! 	$(OBJ_D)\by_dir.obj $(OBJ_D)\meth_err.obj $(OBJ_D)\conf.obj \
! 	$(OBJ_D)\conf_err.obj $(OBJ_D)\txt_db.obj
  
  SSLOBJ=$(OBJ_D)\ssl_lib.obj \
  	$(OBJ_D)\ssl_err2.obj $(OBJ_D)\ssl_trc.obj $(OBJ_D)\ssl_cert.obj \
***************
*** 573,578 ****
--- 573,581 ----
  $(OBJ_D)\sess_id.obj: $(SRC_D)\apps\sess_id.c
  	$(CC) /Fo$(OBJ_D)\sess_id.obj -DMONOLITH $(APP_CFLAGS) -c $(SRC_D)\apps\sess_id.c
  
+ $(OBJ_D)\ciphers.obj: $(SRC_D)\apps\ciphers.c
+ 	$(CC) /Fo$(OBJ_D)\ciphers.obj -DMONOLITH $(APP_CFLAGS) -c $(SRC_D)\apps\ciphers.c
+ 
  $(OBJ_D)\ssleay.obj: $(SRC_D)\apps\ssleay.c
  	$(CC) /Fo$(OBJ_D)\ssleay.obj -DMONOLITH $(APP_CFLAGS) -c $(SRC_D)\apps\ssleay.c
  
***************
*** 582,587 ****
--- 585,593 ----
  $(OBJ_D)\cryptlib.obj: $(SRC_D)\crypto\cryptlib.c
  	$(CC) /Fo$(OBJ_D)\cryptlib.obj $(LIB_CFLAGS) -DCFLAGS="\"$(CC) $(CFLAG)\"" -c $(SRC_D)\crypto\cryptlib.c
  
+ $(OBJ_D)\mem.obj: $(SRC_D)\crypto\mem.c
+ 	$(CC) /Fo$(OBJ_D)\mem.obj $(LIB_CFLAGS) -c $(SRC_D)\crypto\mem.c
+ 
  $(OBJ_D)\md2_dgst.obj: $(SRC_D)\crypto\md\md2_dgst.c
  	$(CC) /Fo$(OBJ_D)\md2_dgst.obj $(LIB_CFLAGS) -c $(SRC_D)\crypto\md\md2_dgst.c
  
***************
*** 1405,1411 ****
  <<
  
  $(O_SSL): $(SSLOBJ)
- 	$(RM) $(O_SSL)
  	$(LINK) $(MLFLAGS) @<<
    $(SHLIB_EX_OBJ) +
    $(OBJ_D)\bio_ssl.obj +
--- 1411,1416 ----
***************
*** 1439,1445 ****
  	implib /noignorecase /nowep $(L_SSL) $(O_SSL)
  
  $(O_RSAGLUE): $(RSAGLUEOBJ)
- 	$(RM) $(O_RSAGLUE)
  	$(MKLIB) @<<
  $(O_RSAGLUE)
  y
--- 1444,1449 ----
***************
*** 1450,1456 ****
  <<
  
  $(O_CRYPTO): $(CRYPTOOBJ)
- 	$(RM) $(O_CRYPTO)
  	$(LINK) $(MLFLAGS) @<<
    $(SHLIB_EX_OBJ) +
    $(BN_MULW_OBJ) +
--- 1454,1459 ----
***************
*** 1584,1589 ****
--- 1587,1593 ----
    $(OBJ_D)\md5_dgst.obj +
    $(OBJ_D)\md5_one.obj +
    $(OBJ_D)\md5_rand.obj +
+   $(OBJ_D)\mem.obj +
    $(OBJ_D)\meth_err.obj +
    $(OBJ_D)\meth_lib.obj +
    $(OBJ_D)\n_pkey.obj +
***************
*** 1682,1687 ****
--- 1686,1692 ----
    $(OBJ_D)\apps.obj +
    $(OBJ_D)\asn1pars.obj +
    $(OBJ_D)\ca.obj +
+   $(OBJ_D)\ciphers.obj +
    $(OBJ_D)\crl.obj +
    $(OBJ_D)\crl2p7.obj +
    $(OBJ_D)\dgst.obj +
*** /var/spool/ftp/pub/Crypto/SSL/064/SSLeay-0.6.3/./shlib/linux.sh	Wed Jul 10 09:46:31 1996
--- ./shlib/linux.sh	Thu Aug 29 23:50:27 1996
***************
*** 2,7 ****
--- 2,11 ----
  
  echo "#define DATE      \"`date`\"" >crypto/date.h
  
+ major="0"
+ minor="6.4"
+ slib=libssl
+ clib=libcrypto
  CC=gcc
  FLAGS='-DTERMIO -O3 -DL_ENDIAN -fomit-frame-pointer -m486 -Wall'
  #FLAGS='-DTERMIO -g -DL_ENDIAN -m486 -Wall'
***************
*** 14,26 ****
  as -o bn_asm.o crypto/bn/asm/x86-lnx.s
  CFLAGS="$CFLAGS -DASM"
  
! echo compiling crypto
  $CC -c $CFLAGS -DCFLAGS="\"$FLAGS\"" -o crypto.o crypto/crypto.c
  
! echo building libcrypto.so
! ld -shared -o libcrypto.so crypto.o bn_asm.o
  
! echo compiling ssl
  $CC -c $CFLAGS -o ssl.o ssl/ssl.c
! echo building libssl.so
! ld -shared -o libssl.so ssl.o
--- 18,31 ----
  as -o bn_asm.o crypto/bn/asm/x86-lnx.s
  CFLAGS="$CFLAGS -DASM"
  
! echo compiling $clib
  $CC -c $CFLAGS -DCFLAGS="\"$FLAGS\"" -o crypto.o crypto/crypto.c
  
! echo linking $clib.so
! gcc -shared -Wl,-soname,$clib.so.$major -o $clib.so.$major.$minor crypto.o bn_asm.o
  
! echo compiling $slib.so
  $CC -c $CFLAGS -o ssl.o ssl/ssl.c
! 
! echo building $slib.so
! gcc -shared -Wl,-soname,$slib.so.$major -o $slib.so.$major.$minor ssl.o
*** /dev/null	Fri Aug 30 04:16:48 1996
--- ./ssl3/Makefile.ssl	Thu Aug 29 23:50:28 1996
***************
*** 0 ****
--- 1,83 ----
+ #
+ # SSLeay/ssl/Makefile
+ #
+ 
+ DIR=	ssl3
+ TOP=	..
+ CC=	cc
+ INCLUDES= -I../crypto -I../include
+ CFLAG=-g
+ INSTALLTOP=/usr/local/ssl
+ MAKE=		make -f Makefile.ssl
+ MAKEDEPEND=	makedepend -fMakefile.ssl
+ MAKEFILE=	Makefile.ssl
+ 
+ CFLAGS= $(INCLUDES) $(CFLAG)
+ 
+ ERR=ssl3
+ ERRC=ssl3_err
+ GENERAL=Makefile README
+ TEST=
+ APPS=
+ 
+ LIB=$(TOP)/libssl.a
+ LIBSRC=
+ LIBOBJ=
+ 
+ SRC= $(LIBSRC)
+ 
+ EXHEADER= ssl3.h
+ HEADER=	$(EXHEADER) ssl3locl.h
+ 
+ ALL=    $(GENERAL) $(SRC) $(HEADER)
+ 
+ top:
+ 	(cd ..; $(MAKE) DIRS=$(DIR) all)
+ 
+ all:	lib
+ 
+ lib:	$(LIBOBJ)
+ 	ar r $(LIB) $(LIBOBJ)
+ 	$(TOP)/util/ranlib.sh $(LIB)
+ 	@touch lib
+ 
+ files:
+ 	perl $(TOP)/util/files.pl Makefile.ssl >> $(TOP)/MINFO
+ 
+ links:
+ 	/bin/rm -f Makefile
+ 	$(TOP)/util/point.sh Makefile.ssl Makefile ;
+ 	$(TOP)/util/mklink.sh ../include $(EXHEADER)
+ 	$(TOP)/util/mklink.sh ../test $(TEST)
+ 	$(TOP)/util/mklink.sh ../apps $(APPS)
+ 
+ install:
+ 	@for i in $(EXHEADER) ; \
+ 	do  \
+ 	(cp $$i $(INSTALLTOP)/include/$$i; \
+ 	chmod 644 $(INSTALLTOP)/include/$$i ) \
+ 	done;
+ 
+ tags:
+ 	ctags $(SRC)
+ 
+ tests:
+ 
+ lint:
+ 	lint -DLINT $(INCLUDES) $(SRC)>fluff
+ 
+ depend:
+ 	$(MAKEDEPEND) $(INCLUDES) $(PROGS) $(LIBSRC)
+ 
+ dclean:
+ 	perl -pe 'if (/^# DO NOT DELETE THIS LINE/) {print; exit(0);}' $(MAKEFILE) >Makefile.new
+ 	mv -f Makefile.new $(MAKEFILE)
+ 
+ clean:
+ 	/bin/rm -f *.o *.obj lib tags core .pure .nfs* *.old *.bak fluff
+ 
+ errors:
+ 	perl $(TOP)/util/err-ins.pl $(ERR).err $(ERR).h
+ 	perl ../crypto/error/err_genc.pl $(ERR).h $(ERRC).c >$(ERRC).c
+ 
+ # DO NOT DELETE THIS LINE -- make depend depends on it.
*** /dev/null	Fri Aug 30 04:16:48 1996
--- ./ssl3/ssl3.h	Thu Aug 29 23:50:28 1996
***************
*** 0 ****
--- 1,34 ----
+ /* Some initial ideas.... */
+ typedef struct ssl3_session_st
+ 	{
+ 	unsigned int session_id_length;
+         unsigned char *session_id;
+ 	X509 *peer;
+ 	CIPHER3 *cipher;
+ 	COMPRESSION *compression;
+ 	unsigned char master_secret[48];
+ 	int is_resumable;
+ 	} SSL3_SESSION;
+ 
+ typedef struct ssl3_con_ctx_st
+ 	{
+ 	int random_length;
+ 	unsigned char *random;
+ 
+ 	int mac_sec_length;
+ 	unsigned char *mac_sec;
+ 
+ 	int key_length;
+ 	unsigned char *key;
+ 	} SSL3_CON_CTX;
+ 
+ typedef struct ssl3_st
+ 	{
+ 	SSL3_CON_CTX client;
+ 	SSL3_CON_CTX server;
+ 	char *iv;
+ 
+ 	unsigned long read_sequence;
+         unsigned long write_sequence;
+ 
+ 	} SSL3;
*** /dev/null	Fri Aug 30 04:16:48 1996
--- ./mt/irix.mk	Thu Aug 29 23:50:27 1996
***************
*** 0 ****
--- 1,4 ----
+ #!/bin/sh
+ /bin/rm -f mttest
+ cc -DIRIX -I../include -g mttest.c -o mttest -L.. -lssl -lcrypto
+ 
*** /dev/null	Fri Aug 30 04:16:48 1996
--- ./mt/irix.sh	Thu Aug 29 23:50:27 1996
***************
*** 0 ****
--- 1,4 ----
+ #!/bin/sh
+ /bin/rm -f mttest
+ cc -DIRIX -I../include -g mttest.c -o mttest -L.. -lssl -lcrypto
+ 
*** /dev/null	Fri Aug 30 04:16:48 1996
--- ./mt/mttest.c	Thu Aug 29 23:50:27 1996
***************
*** 0 ****
--- 1,987 ----
+ /* mt/mttest.c */
+ /* Copyright (C) 1995-1996 Eric Young (eay@mincom.oz.au)
+  * All rights reserved.
+  * 
+  * This file is part of an SSL implementation written
+  * by Eric Young (eay@mincom.oz.au).
+  * The implementation was written so as to conform with Netscapes SSL
+  * specification.  This library and applications are
+  * FREE FOR COMMERCIAL AND NON-COMMERCIAL USE
+  * as long as the following conditions are aheared to.
+  * 
+  * Copyright remains Eric Young's, and as such any Copyright notices in
+  * the code are not to be removed.  If this code is used in a product,
+  * Eric Young should be given attribution as the author of the parts used.
+  * This can be in the form of a textual message at program startup or
+  * in documentation (online or textual) provided with the package.
+  * 
+  * Redistribution and use in source and binary forms, with or without
+  * modification, are permitted provided that the following conditions
+  * are met:
+  * 1. Redistributions of source code must retain the copyright
+  *    notice, this list of conditions and the following disclaimer.
+  * 2. Redistributions in binary form must reproduce the above copyright
+  *    notice, this list of conditions and the following disclaimer in the
+  *    documentation and/or other materials provided with the distribution.
+  * 3. All advertising materials mentioning features or use of this software
+  *    must display the following acknowledgement:
+  *    This product includes software developed by Eric Young (eay@mincom.oz.au)
+  * 
+  * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND
+  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+  * SUCH DAMAGE.
+  * 
+  * The licence and distribution terms for any publically available version or
+  * derivative of this code cannot be changed.  i.e. this code cannot simply be
+  * copied and put under another distribution licence
+  * [including the GNU Public Licence.]
+  */
+ 
+ #include <stdio.h>
+ #include <stdlib.h>
+ #include <string.h>
+ #include <errno.h>
+ #ifdef LINUX
+ #include <typedefs.h>
+ #endif
+ #ifdef WIN32
+ #include <windows.h>
+ #endif
+ #ifdef SOLARIS
+ #include <synch.h>
+ #include <thread.h>
+ #endif
+ #ifdef IRIX
+ #include <ulocks.h>
+ #include <sys/prctl.h>
+ #endif
+ #include "lhash.h"
+ #include "crypto.h"
+ #include "buffer.h"
+ #include "../e_os.h"
+ #include "x509.h"
+ #include "ssl.h"
+ #include "err.h"
+ 
+ #ifdef WIN16
+ #define APPS_WIN16
+ #include "../crypto/buffer/bss_file.c"
+ #endif
+ 
+ #define TEST_SERVER_CERT "../apps/server.pem"
+ #define TEST_CLIENT_CERT "../apps/client.pem"
+ 
+ #define MAX_THREAD_NUMBER	100
+ 
+ #ifndef NOPROTO
+ int MS_CALLBACK verify_callback(int ok, X509 *xs, X509 *xi, int depth,
+ 	int error,char *arg);
+ void thread_setup(void);
+ void thread_cleanup(void);
+ void do_threads(SSL_CTX *s_ctx,SSL_CTX *c_ctx);
+ void irix_locking_callback(int mode,int type,char *file,int line);
+ void solaris_locking_callback(int mode,int type,char *file,int line);
+ void win32_locking_callback(int mode,int type,char *file,int line);
+ void linux_locking_callback(int mode,int type,char *file,int line);
+ unsigned long irix_thread_id(void );
+ unsigned long solaris_thread_id(void );
+ unsigned long linix_thread_id(void );
+ #else
+ int MS_CALLBACK verify_callback();
+ void thread_setup();
+ void thread_cleanup();
+ void do_threads();
+ void irix_locking_callback();
+ void solaris_locking_callback();
+ void win32_locking_callback();
+ void linux_locking_callback();
+ unsigned long irix_thread_id();
+ unsigned long solaris_thread_id();
+ unsigned long linix_thread_id();
+ #endif
+ 
+ BIO *bio_err=NULL;
+ BIO *bio_stdout=NULL;
+ 
+ static char *cipher=NULL;
+ int verbose=0;
+ #ifdef FIONBIO
+ static int s_nbio=0;
+ #endif
+ 
+ int thread_number=10;
+ int number_of_loops=10;
+ int reconnect=0;
+ int cache_stats=0;
+ 
+ #ifndef  NOPROTO
+ int doit(char *ctx[4]);
+ #else
+ int doit();
+ #endif
+ 
+ static void print_stats(fp,ctx)
+ FILE *fp;
+ SSL_CTX *ctx;
+ {
+ 	fprintf(fp,"%4ld items in the session cache\n",
+ 		SSL_CTX_sess_number(ctx));
+ 	fprintf(fp,"%4d client connects (SSL_connect())\n",
+ 		SSL_CTX_sess_connect(ctx));
+ 	fprintf(fp,"%4d client connects that finished\n",
+ 		SSL_CTX_sess_connect_good(ctx));
+ 	fprintf(fp,"%4d server connects (SSL_accept())\n",
+ 		SSL_CTX_sess_accept(ctx));
+ 	fprintf(fp,"%4d server connects that finished\n",
+ 		SSL_CTX_sess_accept_good(ctx));
+ 	fprintf(fp,"%4d session cache hits\n",SSL_CTX_sess_hits(ctx));
+ 	fprintf(fp,"%4d session cache misses\n",SSL_CTX_sess_misses(ctx));
+ 	fprintf(fp,"%4d session cache timeouts\n",SSL_CTX_sess_timeouts(ctx));
+ 	}
+ 
+ static void sv_usage()
+ 	{
+ 	fprintf(stderr,"usage: ssltest [args ...]\n");
+ 	fprintf(stderr,"\n");
+ 	fprintf(stderr," -server_auth  - check server certificate\n");
+ 	fprintf(stderr," -client_auth  - do client authentication\n");
+ 	fprintf(stderr," -v            - more output\n");
+ 	fprintf(stderr," -CApath arg   - PEM format directory of CA's\n");
+ 	fprintf(stderr," -CAfile arg   - PEM format file of CA's\n");
+ 	fprintf(stderr," -threads arg  - number of threads\n");
+ 	fprintf(stderr," -loops arg    - number of 'connections', per thread\n");
+ 	fprintf(stderr," -reconnect    - reuse session-id's\n");
+ 	fprintf(stderr," -stats        - server session-id cache stats\n");
+ 	fprintf(stderr," -cert arg     - server certificate/key\n");
+ 	fprintf(stderr," -ccert arg    - client certificate/key\n");
+ 
+ 	}
+ 
+ int main(argc, argv)
+ int argc;
+ char *argv[];
+ 	{
+ 	char *CApath=NULL,*CAfile=NULL;
+ 	int badop=0;
+ 	int ret=1;
+ 	int client_auth=0;
+ 	int server_auth=0;
+ 	SSL_CTX *s_ctx=NULL;
+ 	SSL_CTX *c_ctx=NULL;
+ 	char *scert=TEST_SERVER_CERT;
+ 	char *ccert=TEST_CLIENT_CERT;
+ 
+ 	if (bio_err == NULL)
+ 		if ((bio_err=BIO_new(BIO_s_file())) != NULL)
+ 			BIO_set_fp(bio_err,stderr,BIO_NOCLOSE);
+ 	if (bio_stdout == NULL)
+ 		if ((bio_stdout=BIO_new(BIO_s_file())) != NULL)
+ 			BIO_set_fp(bio_stdout,stdout,BIO_NOCLOSE);
+ 
+ 	argc--;
+ 	argv++;
+ 
+ 	while (argc >= 1)
+ 		{
+ 		if	(strcmp(*argv,"-server_auth") == 0)
+ 			server_auth=1;
+ 		else if	(strcmp(*argv,"-client_auth") == 0)
+ 			client_auth=1;
+ 		else if	(strcmp(*argv,"-reconnect") == 0)
+ 			reconnect=1;
+ 		else if	(strcmp(*argv,"-stats") == 0)
+ 			cache_stats=1;
+ 		else if	(strcmp(*argv,"-CApath") == 0)
+ 			{
+ 			if (--argc < 1) goto bad;
+ 			CApath= *(++argv);
+ 			}
+ 		else if	(strcmp(*argv,"-CAfile") == 0)
+ 			{
+ 			if (--argc < 1) goto bad;
+ 			CAfile= *(++argv);
+ 			}
+ 		else if	(strcmp(*argv,"-cert") == 0)
+ 			{
+ 			if (--argc < 1) goto bad;
+ 			scert= *(++argv);
+ 			}
+ 		else if	(strcmp(*argv,"-ccert") == 0)
+ 			{
+ 			if (--argc < 1) goto bad;
+ 			ccert= *(++argv);
+ 			}
+ 		else if	(strcmp(*argv,"-threads") == 0)
+ 			{
+ 			if (--argc < 1) goto bad;
+ 			thread_number= atoi(*(++argv));
+ 			if (thread_number == 0) thread_number=1;
+ 			if (thread_number > MAX_THREAD_NUMBER)
+ 				thread_number=MAX_THREAD_NUMBER;
+ 			}
+ 		else if	(strcmp(*argv,"-loops") == 0)
+ 			{
+ 			if (--argc < 1) goto bad;
+ 			number_of_loops= atoi(*(++argv));
+ 			if (number_of_loops == 0) number_of_loops=1;
+ 			}
+ 		else
+ 			{
+ 			fprintf(stderr,"unknown option %s\n",*argv);
+ 			badop=1;
+ 			break;
+ 			}
+ 		argc--;
+ 		argv++;
+ 		}
+ 	if (badop)
+ 		{
+ bad:
+ 		sv_usage();
+ 		goto end;
+ 		}
+ 
+ 	if (cipher == NULL) cipher=getenv("SSL_CIPHER");
+ 
+ 	SSL_load_error_strings();
+ 
+ 	c_ctx=SSL_CTX_new();
+ 	s_ctx=SSL_CTX_new();
+ 	if ((c_ctx == NULL) || (s_ctx == NULL))
+ 		goto end;
+ 
+ 	SSL_CTX_set_session_cache_mode(s_ctx,
+ 		SSL_SESS_CACHE_NO_AUTO_CLEAR|SSL_SESS_CACHE_SERVER);
+ 	SSL_CTX_set_session_cache_mode(c_ctx,
+ 		SSL_SESS_CACHE_NO_AUTO_CLEAR|SSL_SESS_CACHE_SERVER);
+ 
+ 	SSL_CTX_use_certificate_file(s_ctx,scert,SSL_FILETYPE_PEM);
+ 	SSL_CTX_use_RSAPrivateKey_file(s_ctx,scert,SSL_FILETYPE_PEM);
+ 
+ 	if (client_auth)
+ 		{
+ 		SSL_CTX_use_certificate_file(c_ctx,ccert,
+ 			SSL_FILETYPE_PEM);
+ 		SSL_CTX_use_RSAPrivateKey_file(c_ctx,ccert,
+ 			SSL_FILETYPE_PEM);
+ 		}
+ 
+ 	if (	(!SSL_load_verify_locations(s_ctx,CAfile,CApath)) ||
+ 		(!SSL_set_default_verify_paths(s_ctx)) ||
+ 		(!SSL_load_verify_locations(c_ctx,CAfile,CApath)) ||
+ 		(!SSL_set_default_verify_paths(c_ctx)))
+ 		{
+ 		fprintf(stderr,"SSL_load_verify_locations\n");
+ 		ERR_print_errors(bio_err);
+ 		goto end;
+ 		}
+ 
+ 	if (client_auth)
+ 		{
+ 		fprintf(stderr,"client authentication\n");
+ 		SSL_CTX_set_verify(s_ctx,
+ 			SSL_VERIFY_PEER|SSL_VERIFY_FAIL_IF_NO_PEER_CERT,
+ 			verify_callback);
+ 		}
+ 	if (server_auth)
+ 		{
+ 		fprintf(stderr,"server authentication\n");
+ 		SSL_CTX_set_verify(c_ctx,SSL_VERIFY_PEER,
+ 			verify_callback);
+ 		}
+ 
+ 	thread_setup();
+ 	do_threads(s_ctx,c_ctx);
+ 	thread_cleanup();
+ end:
+ 	
+ 	if (c_ctx != NULL) 
+ 		{
+ 		fprintf(stderr,"Client SSL_CTX stats then free it\n");
+ 		print_stats(stderr,c_ctx);
+ 		SSL_CTX_free(c_ctx);
+ 		}
+ 	if (s_ctx != NULL)
+ 		{
+ 		fprintf(stderr,"Server SSL_CTX stats then free it\n");
+ 		print_stats(stderr,s_ctx);
+ 		if (cache_stats)
+ 			{
+ 			fprintf(stderr,"-----\n");
+ 			lh_stats(SSL_CTX_sessions(s_ctx),stderr);
+ 			fprintf(stderr,"-----\n");
+ 		/*	lh_node_stats(SSL_CTX_sessions(s_ctx),stderr);
+ 			fprintf(stderr,"-----\n"); */
+ 			lh_node_usage_stats(SSL_CTX_sessions(s_ctx),stderr);
+ 			fprintf(stderr,"-----\n");
+ 			}
+ 		SSL_CTX_free(s_ctx);
+ 		fprintf(stderr,"done free\n");
+ 		}
+ 	exit(ret);
+ 	return(0);
+ 	}
+ 
+ #define W_READ	1
+ #define W_WRITE	2
+ #define C_DONE	1
+ #define S_DONE	2
+ 
+ int ndoit(ssl_ctx)
+ SSL_CTX *ssl_ctx[2];
+ 	{
+ 	int i;
+ 	int ret;
+ 	char *ctx[4];
+ 
+ 	ctx[0]=(char *)ssl_ctx[0];
+ 	ctx[1]=(char *)ssl_ctx[1];
+ 
+ 	if (reconnect)
+ 		{
+ 		ctx[2]=(char *)SSL_new(ssl_ctx[0]);
+ 		ctx[3]=(char *)SSL_new(ssl_ctx[1]);
+ 		}
+ 	else
+ 		{
+ 		ctx[2]=NULL;
+ 		ctx[3]=NULL;
+ 		}
+ 
+ 	fprintf(stdout,"started thread %ld\n",CRYPTO_thread_id());
+ 	for (i=0; i<number_of_loops; i++)
+ 		{
+ /*		fprintf(stderr,"%4d %2d ctx->ref (%3d,%3d)\n",
+ 			CRYPTO_thread_id(),i,
+ 			ssl_ctx[0]->references,
+ 			ssl_ctx[1]->references); */
+ 	/*	pthread_delay_np(&tm);*/
+ 
+ 		ret=doit(ctx);
+ 		if (ret != 0)
+ 			{
+ 			fprintf(stdout,"error[%d] %ld - %d\n",
+ 				i,CRYPTO_thread_id(),ret);
+ 			return(ret);
+ 			}
+ 		}
+ 	fprintf(stdout,"DONE %ld\n",CRYPTO_thread_id());
+ 	if (reconnect)
+ 		{
+ 		SSL_free((SSL *)ctx[2]);
+ 		SSL_free((SSL *)ctx[3]);
+ 		}
+ 	return(0);
+ 	}
+ 
+ int doit(ctx)
+ char *ctx[4];
+ 	{
+ 	SSL_CTX *s_ctx,*c_ctx;
+ 	static char cbuf[200],sbuf[200];
+ 	SSL *c_ssl=NULL;
+ 	SSL *s_ssl=NULL;
+ 	BIO *c_to_s=NULL;
+ 	BIO *s_to_c=NULL;
+ 	BIO *c_bio=NULL;
+ 	BIO *s_bio=NULL;
+ 	int c_r,c_w,s_r,s_w;
+ 	int c_want,s_want;
+ 	int i;
+ 	int done=0;
+ 	int c_write,s_write;
+ 	int do_server=0,do_client=0;
+ 
+ 	s_ctx=(SSL_CTX *)ctx[0];
+ 	c_ctx=(SSL_CTX *)ctx[1];
+ 
+ 	if (ctx[2] != NULL)
+ 		s_ssl=(SSL *)ctx[2];
+ 	else
+ 		s_ssl=SSL_new(s_ctx);
+ 
+ 	if (ctx[3] != NULL)
+ 		c_ssl=(SSL *)ctx[3];
+ 	else
+ 		c_ssl=SSL_new(c_ctx);
+ 
+ 	if ((s_ssl == NULL) || (c_ssl == NULL)) goto err;
+ 
+ 	c_to_s=BIO_new(BIO_s_mem());
+ 	s_to_c=BIO_new(BIO_s_mem());
+ 	if ((s_to_c == NULL) || (c_to_s == NULL)) goto err;
+ 
+ 	c_bio=BIO_new(BIO_f_ssl());
+ 	s_bio=BIO_new(BIO_f_ssl());
+ 	if ((c_bio == NULL) || (s_bio == NULL)) goto err;
+ 
+ 	SSL_set_connect_state(c_ssl);
+ 	SSL_set_bio(c_ssl,s_to_c,c_to_s);
+ 	BIO_set_ssl(c_bio,c_ssl,(ctx[2] == NULL)?BIO_CLOSE:BIO_NOCLOSE);
+ 
+ 	SSL_set_accept_state(s_ssl);
+ 	SSL_set_bio(s_ssl,c_to_s,s_to_c);
+ 	BIO_set_ssl(s_bio,s_ssl,(ctx[3] == NULL)?BIO_CLOSE:BIO_NOCLOSE);
+ 
+ 	c_r=0; s_r=1;
+ 	c_w=1; s_w=0;
+ 	c_want=W_WRITE;
+ 	s_want=0;
+ 	c_write=1,s_write=0;
+ 
+ 	/* We can always do writes */
+ 	for (;;)
+ 		{
+ 		do_server=0;
+ 		do_client=0;
+ 
+ 		i=(int)BIO_pending(s_bio);
+ 		if ((i && s_r) || s_w) do_server=1;
+ 
+ 		i=(int)BIO_pending(c_bio);
+ 		if ((i && c_r) || c_w) do_client=1;
+ 
+ 		if (do_server && verbose)
+ 			{
+ 			if (SSL_in_init(s_ssl))
+ 				printf("server waiting in SSL_accept - %s\n",
+ 					SSL_state_string_long(s_ssl));
+ 			else if (s_write)
+ 				printf("server:SSL_write()\n");
+ 			else 
+ 				printf("server:SSL_read()\n");
+ 			}
+ 
+ 		if (do_client && verbose)
+ 			{
+ 			if (SSL_in_init(c_ssl))
+ 				printf("client waiting in SSL_connect - %s\n",
+ 					SSL_state_string_long(c_ssl));
+ 			else if (c_write)
+ 				printf("client:SSL_write()\n");
+ 			else
+ 				printf("client:SSL_read()\n");
+ 			}
+ 
+ 		if (!do_client && !do_server)
+ 			{
+ 			fprintf(stdout,"ERROR IN STARTUP\n");
+ 			break;
+ 			}
+ 		if (do_client && !(done & C_DONE))
+ 			{
+ 			if (c_write)
+ 				{
+ 				i=BIO_write(c_bio,"hello from client\n",18);
+ 				if (i < 0)
+ 					{
+ 					c_r=0;
+ 					c_w=0;
+ 					if (BIO_should_retry(c_bio))
+ 						{
+ 						if (BIO_should_read(c_bio))
+ 							c_r=1;
+ 						if (BIO_should_write(c_bio))
+ 							c_w=1;
+ 						}
+ 					else
+ 						{
+ 						fprintf(stderr,"ERROR in CLIENT\n");
+ 						return(1);
+ 						}
+ 					}
+ 				else if (i == 0)
+ 					{
+ 					fprintf(stderr,"SSL CLIENT STARTUP FAILED\n");
+ 					return(1);
+ 					}
+ 				else
+ 					{
+ 					/* ok */
+ 					c_write=0;
+ 					}
+ 				}
+ 			else
+ 				{
+ 				i=BIO_read(c_bio,cbuf,100);
+ 				if (i < 0)
+ 					{
+ 					c_r=0;
+ 					c_w=0;
+ 					if (BIO_should_retry(c_bio))
+ 						{
+ 						if (BIO_should_read(c_bio))
+ 							c_r=1;
+ 						if (BIO_should_write(c_bio))
+ 							c_w=1;
+ 						}
+ 					else
+ 						{
+ 						fprintf(stderr,"ERROR in CLIENT\n");
+ 						return(1);
+ 						}
+ 					}
+ 				else if (i == 0)
+ 					{
+ 					fprintf(stderr,"SSL CLIENT STARTUP FAILED\n");
+ 					return(1);
+ 					}
+ 				else
+ 					{
+ 					done|=C_DONE;
+ #ifdef undef
+ 					fprintf(stdout,"CLIENT:from server:");
+ 					fwrite(cbuf,1,i,stdout);
+ 					fflush(stdout);
+ #endif
+ 					}
+ 				}
+ 			}
+ 
+ 		if (do_server && !(done & S_DONE))
+ 			{
+ 			if (!s_write)
+ 				{
+ 				i=BIO_read(s_bio,sbuf,100);
+ 				if (i < 0)
+ 					{
+ 					s_r=0;
+ 					s_w=0;
+ 					if (BIO_should_retry(s_bio))
+ 						{
+ 						if (BIO_should_read(s_bio))
+ 							s_r=1;
+ 						if (BIO_should_write(s_bio))
+ 							s_w=1;
+ 						}
+ 					else
+ 						{
+ 						fprintf(stderr,"ERROR in SERVER\n");
+ 						ERR_print_errors_fp(stderr);
+ 						return(1);
+ 						}
+ 					}
+ 				else if (i == 0)
+ 					{
+ 					fprintf(stderr,"SSL SERVER STARTUP FAILED\n");
+ 					return(1);
+ 					}
+ 				else
+ 					{
+ 					s_write=1;
+ 					s_w=1;
+ #ifdef undef
+ 					fprintf(stdout,"SERVER:from client:");
+ 					fwrite(sbuf,1,i,stdout);
+ 					fflush(stdout);
+ #endif
+ 					}
+ 				}
+ 			else
+ 				{
+ 				i=BIO_write(s_bio,"hello from server\n",18);
+ 				if (i < 0)
+ 					{
+ 					s_r=0;
+ 					s_w=0;
+ 					if (BIO_should_retry(s_bio))
+ 						{
+ 						if (BIO_should_read(s_bio))
+ 							s_r=1;
+ 						if (BIO_should_write(s_bio))
+ 							s_w=1;
+ 						}
+ 					else
+ 						{
+ 						fprintf(stderr,"ERROR in SERVER\n");
+ 						ERR_print_errors_fp(stderr);
+ 						return(1);
+ 						}
+ 					}
+ 				else if (i == 0)
+ 					{
+ 					fprintf(stderr,"SSL SERVER STARTUP FAILED\n");
+ 					return(1);
+ 					}
+ 				else
+ 					{
+ 					s_write=0;
+ 					s_r=1;
+ 					done|=S_DONE;
+ 					}
+ 				}
+ 			}
+ 
+ 		if ((done & S_DONE) && (done & C_DONE)) break;
+ 		}
+ 
+ #ifdef undef
+ 	fprintf(stdout,"DONE\n");
+ #endif
+ err:
+ 	/* We have to set the BIO's to NULL otherwise they will be
+ 	 * free()ed twice.  Once when th s_ssl is SSL_free()ed and
+ 	 * again when c_ssl is SSL_free()ed.
+ 	 * This is a hack required because s_ssl and c_ssl are sharing the same
+ 	 * BIO structure and SSL_set_bio() and SSL_free() automatically
+ 	 * BIO_free non NULL entries.
+ 	 * You should not normally do this or be required to do this */
+ 
+ 	if (s_ssl != NULL)
+ 		{
+ 		s_ssl->rbio=NULL;
+ 		s_ssl->wbio=NULL;
+ 		}
+ 	if (c_ssl != NULL)
+ 		{
+ 		c_ssl->rbio=NULL;
+ 		c_ssl->wbio=NULL;
+ 		}
+ 
+ 	if (c_to_s != NULL) BIO_free(c_to_s);
+ 	if (s_to_c != NULL) BIO_free(s_to_c);
+ 	if (c_bio != NULL) BIO_free(c_bio);
+ 	if (s_bio != NULL) BIO_free(s_bio);
+ 	return(0);
+ 	}
+ 
+ int MS_CALLBACK verify_callback(ok, xs, xi, depth, error, arg)
+ int ok;
+ X509 *xs;
+ X509 *xi;
+ int depth;
+ int error;
+ char *arg;
+ 	{
+ 	char *s;
+ 
+ 	if (verbose)
+ 		{
+ 		s=(char *)X509_NAME_oneline(X509_get_subject_name(xs));
+ 		if (s != NULL)
+ 			{
+ 			if (ok)
+ 				fprintf(stderr,"depth=%d %s\n",depth,s);
+ 			else
+ 				fprintf(stderr,"depth=%d error=%d %s\n",depth,error,s);
+ 			free(s);
+ 			}
+ 		}
+ 	return(ok);
+ 	}
+ 
+ #define THREAD_STACK_SIZE (16*1024)
+ 
+ #ifdef WIN32
+ 
+ static HANDLE lock_cs[CRYPTO_NUM_LOCKS];
+ 
+ void thread_setup()
+ 	{
+ 	int i;
+ 
+ 	for (i=0; i<CRYPTO_NUM_LOCKS; i++)
+ 		{
+ 		lock_cs[i]=CreateMutex(NULL,FALSE,NULL);
+ 		}
+ 
+ 	CRYPTO_set_locking_callback((void (*)(int,int,char *,int))win32_locking_callback);
+ 	/* id callback defined */
+ 	}
+ 
+ void thread_cleanup()
+ 	{
+ 	int i;
+ 
+ 	CRYPTO_set_locking_callback(NULL);
+ 	for (i=0; i<CRYPTO_NUM_LOCKS; i++)
+ 		CloseHandle(lock_cs[i]);
+ 	}
+ 
+ void win32_locking_callback(mode,type,file,line)
+ int mode;
+ int type;
+ char *file;
+ int line;
+ 	{
+ 	if (mode & CRYPTO_LOCK)
+ 		{
+ 		WaitForSingleObject(lock_cs[type],INFINITE);
+ 		}
+ 	else
+ 		{
+ 		ReleaseMutex(lock_cs[type]);
+ 		}
+ 	}
+ 
+ void do_threads(s_ctx,c_ctx)
+ SSL_CTX *s_ctx,*c_ctx;
+ 	{
+ 	double ret;
+ 	SSL_CTX *ssl_ctx[2];
+ 	DWORD thread_id[MAX_THREAD_NUMBER];
+ 	HANDLE thread_handle[MAX_THREAD_NUMBER];
+ 	int i;
+ 	SYSTEMTIME start,end;
+ 
+ 	ssl_ctx[0]=s_ctx;
+ 	ssl_ctx[1]=c_ctx;
+ 
+ 	GetSystemTime(&start);
+ 	for (i=0; i<thread_number; i++)
+ 		{
+ 		thread_handle[i]=CreateThread(NULL,
+ 			THREAD_STACK_SIZE,
+ 			(LPTHREAD_START_ROUTINE)ndoit,
+ 			(void *)ssl_ctx,
+ 			0L,
+ 			&(thread_id[i]));
+ 		}
+ 
+ 	printf("reaping\n");
+ 	for (i=0; i<thread_number; i+=50)
+ 		{
+ 		int j;
+ 
+ 		j=(thread_number < (i+50))?(thread_number-i):50;
+ 
+ 		if (WaitForMultipleObjects(j,
+ 			(CONST HANDLE *)&(thread_handle[i]),TRUE,INFINITE)
+ 			== WAIT_FAILED)
+ 			{
+ 			fprintf(stderr,"WaitForMultipleObjects failed:%d\n",GetLastError());
+ 			exit(1);
+ 			}
+ 		}
+ 	GetSystemTime(&end);
+ 
+ 	if (start.wDayOfWeek > end.wDayOfWeek) end.wDayOfWeek+=7;
+ 	ret=(end.wDayOfWeek-start.wDayOfWeek)*24;
+ 
+ 	ret=(ret+end.wHour-start.wHour)*60;
+ 	ret=(ret+end.wMinute-start.wMinute)*60;
+ 	ret=(ret+end.wSecond-start.wSecond);
+ 	ret+=(end.wMilliseconds-start.wMilliseconds)/1000.0;
+ 
+ 	printf("win32 threads done - %.3f seconds\n",ret);
+ 	}
+ 
+ #endif
+ 
+ #ifdef SOLARIS
+ 
+ static mutex_t lock_cs[CRYPTO_NUM_LOCKS];
+ /*static rwlock_t lock_cs[CRYPTO_NUM_LOCKS]; */
+ static long lock_count[CRYPTO_NUM_LOCKS];
+ 
+ void thread_setup()
+ 	{
+ 	int i;
+ 
+ 	for (i=0; i<CRYPTO_NUM_LOCKS; i++)
+ 		{
+ 		lock_count[i]=0;
+ 		/* rwlock_init(&(lock_cs[i]),USYNC_THREAD,NULL); */
+ 		mutex_init(&(lock_cs[i]),USYNC_THREAD,NULL);
+ 		}
+ 
+ 	CRYPTO_set_id_callback((unsigned long (*)())solaris_thread_id);
+ 	CRYPTO_set_locking_callback((void (*)())solaris_locking_callback);
+ 	}
+ 
+ void thread_cleanup()
+ 	{
+ 	int i;
+ 
+ 	CRYPTO_set_locking_callback(NULL);
+ fprintf(stderr,"cleanup\n");
+ 	for (i=0; i<CRYPTO_NUM_LOCKS; i++)
+ 		{
+ 		/* rwlock_destroy(&(lock_cs[i])); */
+ 		mutex_destroy(&(lock_cs[i]));
+ 		fprintf(stderr,"%8ld:%s\n",lock_count[i],CRYPTO_get_lock_name(i));
+ 		}
+ fprintf(stderr,"done cleanup\n");
+ 	}
+ 
+ void solaris_locking_callback(mode,type,file,line)
+ int mode;
+ int type;
+ char *file;
+ int line;
+ 	{
+ #ifdef undef
+ fprintf(stderr,"thread=%4d mode=%s lock=%s %s:%d\n",
+ 	CRYPTO_thread_id(),
+ 	(mode&CRYPTO_LOCK)?"l":"u",
+ 	(type&CRYPTO_READ)?"r":"w",file,line);
+ #endif
+ 
+ /*
+ if (CRYPTO_LOCK_SSL_CERT == type)
+ 	fprintf(stderr,"(t,m,f,l) %ld %d %s %d\n",
+ 		CRYPTO_thread_id(),
+ 		mode,file,line);
+ */
+ 	if (mode & CRYPTO_LOCK)
+ 		{
+ 	/*	if (mode & CRYPTO_READ)
+ 			rw_rdlock(&(lock_cs[type]));
+ 		else
+ 			rw_wrlock(&(lock_cs[type])); */
+ 
+ 		mutex_lock(&(lock_cs[type]));
+ 		lock_count[type]++;
+ 		}
+ 	else
+ 		{
+ /*		rw_unlock(&(lock_cs[type]));  */
+ 		mutex_unlock(&(lock_cs[type]));
+ 		}
+ 	}
+ 
+ void do_threads(s_ctx,c_ctx)
+ SSL_CTX *s_ctx,*c_ctx;
+ 	{
+ 	SSL_CTX *ssl_ctx[2];
+ 	thread_t thread_ctx[MAX_THREAD_NUMBER];
+ 	int i;
+ 
+ 	ssl_ctx[0]=s_ctx;
+ 	ssl_ctx[1]=c_ctx;
+ 
+ 	thr_setconcurrency(thread_number);
+ 	for (i=0; i<thread_number; i++)
+ 		{
+ 		thr_create(NULL, THREAD_STACK_SIZE,
+ 			(void *(*)())ndoit,
+ 			(void *)ssl_ctx,
+ 			0L,
+ 			&(thread_ctx[i]));
+ 		}
+ 
+ 	printf("reaping\n");
+ 	for (i=0; i<thread_number; i++)
+ 		{
+ 		thr_join(thread_ctx[i],NULL,NULL);
+ 		}
+ 
+ 	printf("solaris threads done (%d,%d)\n",
+ 		s_ctx->references,c_ctx->references);
+ 	}
+ 
+ unsigned long solaris_thread_id()
+ 	{
+ 	unsigned long ret;
+ 
+ 	ret=(unsigned long)thr_self();
+ 	return(ret);
+ 	}
+ #endif
+ 
+ #ifdef IRIX
+ 
+ 
+ static usptr_t *arena;
+ static usema_t *lock_cs[CRYPTO_NUM_LOCKS];
+ 
+ void thread_setup()
+ 	{
+ 	int i;
+ 	char filename[20];
+ 
+ 	strcpy(filename,"/tmp/mttest.XXXXXX");
+ 	mktemp(filename);
+ 
+ 	usconfig(CONF_STHREADIOOFF);
+ 	usconfig(CONF_STHREADMALLOCOFF);
+ 	usconfig(CONF_INITUSERS,100);
+ 	usconfig(CONF_LOCKTYPE,US_DEBUGPLUS);
+ 	arena=usinit(filename);
+ 	unlink(filename);
+ 
+ 	for (i=0; i<CRYPTO_NUM_LOCKS; i++)
+ 		{
+ 		lock_cs[i]=usnewsema(arena,1);
+ 		}
+ 
+ 	CRYPTO_set_id_callback((unsigned long (*)())irix_thread_id);
+ 	CRYPTO_set_locking_callback((void (*)())irix_locking_callback);
+ 	}
+ 
+ void thread_cleanup()
+ 	{
+ 	int i;
+ 
+ 	CRYPTO_set_locking_callback(NULL);
+ 	for (i=0; i<CRYPTO_NUM_LOCKS; i++)
+ 		{
+ 		char buf[10];
+ 
+ 		sprintf(buf,"%2d:",i);
+ 		usdumpsema(lock_cs[i],stdout,buf);
+ 		usfreesema(lock_cs[i],arena);
+ 		}
+ 	}
+ 
+ void irix_locking_callback(mode,type,file,line)
+ int mode;
+ int type;
+ char *file;
+ int line;
+ 	{
+ 	if (mode & CRYPTO_LOCK)
+ 		{
+ 		printf("lock %d\n",type);
+ 		uspsema(lock_cs[type]);
+ 		}
+ 	else
+ 		{
+ 		printf("unlock %d\n",type);
+ 		usvsema(lock_cs[type]);
+ 		}
+ 	}
+ 
+ void do_threads(s_ctx,c_ctx)
+ SSL_CTX *s_ctx,*c_ctx;
+ 	{
+ 	SSL_CTX *ssl_ctx[2];
+ 	int thread_ctx[MAX_THREAD_NUMBER];
+ 	int i;
+ 
+ 	ssl_ctx[0]=s_ctx;
+ 	ssl_ctx[1]=c_ctx;
+ 
+ 	for (i=0; i<thread_number; i++)
+ 		{
+ 		thread_ctx[i]=sproc((void (*)())ndoit,
+ 			PR_SADDR|PR_SFDS,(void *)ssl_ctx);
+ 		}
+ 
+ 	printf("reaping\n");
+ 	for (i=0; i<thread_number; i++)
+ 		{
+ 		wait(NULL);
+ 		}
+ 
+ 	printf("irix threads done (%d,%d)\n",
+ 		s_ctx->references,c_ctx->references);
+ 	}
+ 
+ unsigned long irix_thread_id()
+ 	{
+ 	unsigned long ret;
+ 
+ 	ret=(unsigned long)getpid();
+ 	return(ret);
+ 	}
+ #endif
+ 
*** /dev/null	Fri Aug 30 04:16:48 1996
--- ./mt/profile.mk	Thu Aug 29 23:50:27 1996
***************
*** 0 ****
--- 1,4 ----
+ #!/bin/sh
+ /bin/rm -f mttest
+ cc -p -DSOLARIS -I../include -g mttest.c -o mttest -L/usr/lib/libc -ldl -L.. -lthread  -lssl -lcrypto -lnsl -lsocket
+ 
*** /dev/null	Fri Aug 30 04:16:48 1996
--- ./mt/profile.sh	Thu Aug 29 23:50:27 1996
***************
*** 0 ****
--- 1,4 ----
+ #!/bin/sh
+ /bin/rm -f mttest
+ cc -p -DSOLARIS -I../include -g mttest.c -o mttest -L/usr/lib/libc -ldl -L.. -lthread  -lssl -lcrypto -lnsl -lsocket
+ 
*** /dev/null	Fri Aug 30 04:16:48 1996
--- ./mt/PTEST.BAT	Thu Aug 29 23:50:27 1996
***************
*** 0 ****
--- 1,4 ----
+ del mttest.exe
+ 
+ purify cl /O2 -DWIN32 /MD -I..\out mttest.c /Femttest ..\out\ssl32.lib ..\out\crypt32.lib
+ 
*** /dev/null	Fri Aug 30 04:16:48 1996
--- ./mt/purify.mk	Thu Aug 29 23:50:27 1996
***************
*** 0 ****
--- 1,4 ----
+ #!/bin/sh
+ /bin/rm -f mttest
+ purify cc -DSOLARIS -I../include -g mttest.c -o mttest -L.. -lthread  -lssl -lcrypto -lnsl -lsocket
+ 
*** /dev/null	Fri Aug 30 04:16:48 1996
--- ./mt/purify.sh	Thu Aug 29 23:50:27 1996
***************
*** 0 ****
--- 1,4 ----
+ #!/bin/sh
+ /bin/rm -f mttest
+ purify cc -DSOLARIS -I../include -g mttest.c -o mttest -L.. -lthread  -lssl -lcrypto -lnsl -lsocket
+ 
*** /dev/null	Fri Aug 30 04:16:48 1996
--- ./mt/README	Thu Aug 29 23:50:27 1996
***************
*** 0 ****
--- 1,10 ----
+ Mutithreading testing area.
+ 
+ Since this stuff is very very platorm specific, this is not part of the
+ normal build.  Have a read of doc/threads.doc.
+ 
+ mttest will do some testing and will currently build under Windows NT/95
+ and solaris.  The IRIX stuff is not finished.
+ 
+ I have tested this program on a 12 CPU ultra sparc box (solaris 2.5.1)
+ and things seem to work ok.
*** /dev/null	Fri Aug 30 04:16:48 1996
--- ./mt/solaris.mk	Thu Aug 29 23:50:27 1996
***************
*** 0 ****
--- 1,4 ----
+ #!/bin/sh
+ /bin/rm -f mttest
+ cc -DSOLARIS -I../include -g mttest.c -o mttest -L.. -lthread  -lssl -lcrypto -lnsl -lsocket
+ 
*** /dev/null	Fri Aug 30 04:16:48 1996
--- ./mt/solaris.sh	Thu Aug 29 23:50:27 1996
***************
*** 0 ****
--- 1,4 ----
+ #!/bin/sh
+ /bin/rm -f mttest
+ cc -DSOLARIS -I../include -g mttest.c -o mttest -L.. -lthread  -lssl -lcrypto -lnsl -lsocket
+ 
*** /dev/null	Fri Aug 30 04:16:48 1996
--- ./mt/TIMES	Thu Aug 29 23:50:27 1996
***************
*** 0 ****
--- 1,11 ----
+ Pentium 100, NT, DLLs times
+ 
+  1 threads 300 loops	10.184 10.214 10.225
+  2 threads 150 loops	10.405 10.546 10.485
+  3 threads 100 loops	11.436 11.466 11.686
+  4 threads  75 loops	18.317 17.805 18.166
+  5 threads  60 loops	18.246 17.946 18.447
+  6 threads  50 loops	18.086 18.446 18.406
+ 10 threads  30 loops	18.666 18.747 18.587
+ 20 threads  15 loops	20.259 20.119 20.039
+ 30 threads  10 loops	20.389 20.529 21.040
*** /dev/null	Fri Aug 30 04:16:48 1996
--- ./mt/win32.bat	Thu Aug 29 23:50:27 1996
***************
*** 0 ****
--- 1,4 ----
+ del mttest.exe
+ 
+ cl /O2 -DWIN32 /MD -I..\out mttest.c /Femttest ..\out\ssl32.lib ..\out\crypt32.lib
+ 
