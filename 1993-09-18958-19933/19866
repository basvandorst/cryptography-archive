Newsgroups: comp.security.misc,sci.crypt
Path: msuinfo!agate!doc.ic.ac.uk!uknet!festival!castle.ed.ac.uk!richard
From: richard@castle.ed.ac.uk (Richard Tobin)
Subject: Re: DES is dead...
References: <1993Sep29.092454.27428@selway.umt.edu>
Message-ID: <CE463t.n50@festival.ed.ac.uk>
Sender: news@festival.ed.ac.uk (remote news read deamon)
Organization: University of Edinburgh
Date: Wed, 29 Sep 1993 11:47:53 GMT
Lines: 113
Xref: msuinfo comp.security.misc:5374 sci.crypt:19866

In article <1993Sep29.092454.27428@selway.umt.edu> cs000rjp@selway.umt.edu (Thor's Twins) writes:
>David Sternlight <strnlght@netcom.com> wrote:
>>I believe this to be a classical beginner's statistical blunder. Key search
>>is sequential. If you change your key to a new one in the region that has
>>already been searched, it is safer than the old one which is now in a subset
>>of the search space yet unsearched.
>
>Ah, but if *you* don't know what area has been searched, how are you going
>to know what to change it to? And, if the key has already been discovered
>and you change it, the attacker is back to square one, no worse off than
>when he started except that the range has decreased by one.

I think Sternlight's point is that if

(a) Your password hasn't yet been found
(b) The attacker can't tell that you have changed your password

then changing your password takes you from a situation in which your
password will be eventually found to one in which it may not be found
in one pass through the search space (because it may be in the
already-tried set).

Suppose that an attacker tries passwords sequentially, starting again
at the beginning if he hasn't found it after trying all them all
(because you have changed it along the way).  Suppose there are N
possible passwords.  How many attempts will it take to find the
password?

If you never change the password, clearly it will take at most N
attempts, with an average of N/2.

At the opposite extreme, if you select a random password as often as
the attacker tries one, then each trial has a 1/N chance of succeeding,
and the average time will be N with no maximum.

For cases in between, it's a bit harder, so I wrote a simulation (code
included below).  For 10000 passwords, here are the results I got:

Interval between     Average time
password changes     to crack

Infinite (ie >10000) 5003
7500                 6292
5000                 7296
2500                 8443
1000                 9171
100                 10192
10                   9740
1                    9651

(The program doesn't take into account that you never re-use an old
password, but except for very small intervals this won't make much
difference.)

The average varies roughly linearly between N/2 and N as the interval
decreases.

Conclusion: changing your password can at best double the expected time
to find it by brute force.

-- Richard

#include <stdio.h>
#include <stdlib.h>

extern long random(void);

#define PASSWORDS 10000
#define REPETITIONS 1000

int crack(int change_interval);

main(int argc, char **argv)
{
    int change_interval = atoi(argv[1]);
    int rep;
    int total_trials = 0;

    for(rep=0; rep<REPETITIONS; rep++)
	total_trials += crack(change_interval);

    printf("Average time to crack: %d\n", total_trials / REPETITIONS);

    return 0;
}

int crack(int change_interval)
{
    int trials = 0, change_count = 0;
    int password = random() % PASSWORDS, guess = 0;

    while(guess != password)
    {
	trials++;

	if(++change_count == change_interval)
	{
	    password = random() % PASSWORDS;
	    change_count = 0;
	}

	if(guess++ == PASSWORDS)
	    guess = 0;
    }

    return trials;
}

-- 
"For thousands of years, [homoeopathic magic] was known to the sorcerors of
ancient India, Babylon and Egypt, as well as of Greece and Rome, and at this
day it is still resorted to by cunning and malignant savages in Australia, 
Africa and Scotland."  - J G Frazer, The Golden Bough
