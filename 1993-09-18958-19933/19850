Path: msuinfo!agate!howland.reston.ans.net!pipex!uunet!ddsw1!indep1!clifto
From: clifto@indep1.UUCP (Cliff Sharp)
Newsgroups: sci.crypt
Subject: Re: NEW State Dept FLASH
Message-ID: <2501@indep1.UUCP>
Date: 28 Sep 93 16:41:50 GMT
References: <hudCDz8ss.7pp@netcom.com> <2499@indep1.UUCP> <hudCE21G2.EyB@netcom.com>
Organization: as little as possible
Lines: 227

In article <hudCE21G2.EyB@netcom.com> hud@netcom.com (Hud Nordin) writes:
>You just pointed out that an ASCII portion of his message was not CPU
>instructions, at least not ones that make any sense. Fine. I didn't call
>his message machine language. And, you didn't call it machine language.
>
>But, they are still machine instructions.
>
>I.e., "I didn't say his ones and zeroes were 'machine language'. I said they
>were machine instructions."

   Having fleshed out a concept that I think matches your concept of "machine",
I can see what's keeping this going.
   My only remaining problem is that I see them as data.  I see a definite
division between data and instructions, and can't resolve the idea that
if his ones and zeroes are all instructions, that definite division
disappears.

   Also, note that for the remainder of this posting I'm going to make a clear
distinction between Art's message and his source code (addressed later).

>Who cares whether a CPU executes the instructions, or a huge combination of
>hardware and software?

   We still haven't defined "instructions" yet, since my telling my computer
"Don't do what I told you, do what I expected you to do!" is a verbal
instruction to the computer which most computers will happily ignore.
(Sometimes I think they're gloating...  :-)

>>   At various points, _protocol_ instructions were added to and subtracted
>>from Art's message during the transit; but these _protocol_ instructions
>>were still not machine instructions, they were instructions to a collection
>>of machine instructions (the protocol handler) somewhere to tell the
>>protocol handler "program" what was to be done with it, how to interpret
>>the data stream, etc.  Note that Art's message didn't include checksums,
>>TCP/IP/UDP/whatever headers, etc., when it showed on your screen; without
>>those, and the ACK/NAK/etc. handshaking messages, it's unlikely you would
>>have seen the same message Art typed into his computer originally.
>
>The in-band and out-band signaling, routing information, was part of his
>message. So, it could get to one final computer...

   I disagree.  They were a set of protocol instructions designed to tell
other software how to move Art's message; they were not a part of HIS
message, they were part of a superset of his message, the superset being
designed to tell other software how to get Art's message to other
computer systems.  The distinction is that Art didn't enter those protocol
instructions, but the software on his machine which handles message
interchange did.  In much the same way, the article you're reading righ
now is not YOUR message, though it includes a subset of your message (and
very well could have included the entire message); another entity wrapped
information around it and interlaced information into it for the purpose
of communication.
   In the final analysis, the message transfer software is specifically
designed to make sure that Art's message gets delivered _exactly as he
entered it_ to other machines when the process is finished; the software
can add and subtract other information to the message in between, but
since the protocol software is adding the information it's not part of Art's
message, it's part of a package that contains information on how to get
Art's message (and ONLY his message) to other machines in the form of data
files.
   Which brings me to that semantic point I can't resolve while accepting the
notion of Art's message-as-instructions; since his message existed on your
system as a data file (the output file of some news processing program),
what makes the distinction between data and instructions?  My main contention,
if I haven't been clear enough (I'm not always), is that your machine,
CPU, hardware and software all taken as a whole, is using its own means
to display a data file sent to you from Art through the Internet.
   When data become instructions, the whole thing fuzzes over in my mind;
the concepts I've learned over the past 20 or so years require a distinction
between the two.  That's why I'm having so much trouble understanding your
concept of message-as-instructions (if that indeed is what you're saying).

>>>one final computer sitting in front of me, where further hardware and
>>>software interpreted his ones and zeroes as illuminated phosphors for me
>>>to read in the form of a natural language.
>>
>>   Your computer hardware and software did the job of lighting the phosphors
>>based on what it read of his ones and zeroes (ASCII code).  Your computer
>>never executed the ones and zeroes he sent, it interpreted them, as you
>>specifically mention above.  (And it goes without saying that 'interpreted'
>>in this context has a different meaning from, say, "My BASIC interpreter
>>'interpreted' and executed my BASIC source code.")
>
>The machine (NOT the CPU, although it was involved) interpreted the
>instructions.

   Again, it took a data file and processed it in such a way that characters
were displayed on your screen.  I would have expressed that as "the machine
(NOT the CPU, although it was involved) interpreted the DATA."  And in my
concept of 'machine', I would have explicitly included mention of the
software selected to do the interpretation.  (Also note that I mean the
message, not the source code.)

>>>From the moment he sent his message on its way to the time I finally read
>>>it, it was entirely machine instructions.
>>
>>   No, it was a code, and the only way you were able to read it was through
>>the use of a machine that could "decode" that code and turn it into something
>>readable by you.  ASCII is as much a code as the Masonic code, or the stick
>>men in the Sherlock Holmes mystery; it's just the only code that many
>>computers can do much of anything with.
>
>And that code instructs the machine to do...?

   Semantics again.  I'm talking 'code' in the cryptologic sense, not in
the sense of "machine code".  On most machines, that 'code' cannot instruct
the machine to do much other than become a self-eating watermelon.  (Again,
the message/source distinction applies.)

>I didn't say his ones and zeroes were "machine language". I said they
>were machine instructions. (Am I repeating myself?)
>
>Right. The instructions are interpreted by a machine at a lower level using
>other instructions. How does that imply the instructions in the message
>are not machine instructions?

   A set of "machine instructions", in the sense of a program, operates on
data.  That means the _data_ are interpreted by a machine at a lower level
through the use of _instructions_ (which I am now assuming you consider to
be part of the "machine").

>>   Try my previously-mentioned idea.  Find a DOS machine, transfer the
>>message to the DOS machine, rename it to nerts.com, then type "nerts" at
>>[...]
>>   Or, on a unix system, just `ls -l /usr/spool/mail/sci/crypt` and see if
>>any of the files there are marked executable.
>
>You didn't mean to be condescending there, now did you?

   No, just trying to illustrate.  Please don't take anything I say throughout
this thread as being condescending or starting a flame war, as neither is
my intent.  It's a matter of illustration here; if the message constitutes
"instructions" in the sense I'm trying so hard to communicate, rather than
data as I assert, then those instructions should be able to operate as a
stand-alone executable, loaded by an operating system, given control of the
CPU and left alone to do whatever the instructions specify.  (Again, see
later regarding message vs. source.)

>>>Now, who made the mistake?
>>
>>   Until I see you execute the ASCII code he sent you on some machine
>>_as_a_program_ and not through the use of any other machine instruction
>>collection (program), I'll say you did.  (You may, of course, use the
>>standard facilities of the operating system to load and execute it.)
>>If you can demonstrate that his ones and zeroes, as sent, can be directly
>>executed (NOT interpreted) by the CPU of some machine and cause phosphors
>>to light on your machine's screen, I'll say I did.  (Note that sending it
>>to a terminal doesn't count, because that isn't the same as sending it
>>to the terminal's CPU for execution.)
>
>How gracious. Why do YOU get to specify which machine I use?

   I didn't think I did; I tried not to do so by my frequent use of the
phrase 'some machine'.  What did I say that gave you that impression?
(The 'terminal's CPU' item was added as an example, not a command.)  I
actually believed in using that phrase that I was giving you carte blanche
to use _any_ hardware, past or future.  ("Hardware" vs. "machine" again.)

>I already told you what machine I was speaking of. Do you want me to
>try it on that machine again? Be warned that I did once, and the
>machine instructions in his message illuminated those phosphors just
>fine. But, if you want to come over and see for yourself... Otherwise,
>the prosecution rests.

   Again, here's the semantic difference.  To me, the machine can accept
a program or eleventeen; to you, if I read you right, the machine _includes_
the eleventeen programs.  (An analogy; an automobile is still an automobile
even if it has no gasoline/diesel fuel, oil, transmission fluid/oil, etc;
rather useless that way, but still an automobile.  You're including the
gas/oil/etc. and specifying a _usable_ automobile; I'm specifying a machine
that needs additional "accessories" in order to do something useful.)
   So, if I read you right, what's happening is this; you're buying a box
full of hardware, installing an operating system, applications, data, etc.
and calling the entirety your machine; I'm buying a machine, adding to that
machine an operating system, applications, data, etc., and using the
combination of machine, O/S and applications software to do stuff.
   Have I pinned this down yet?

[several points of agreement on the original topic omitted solely for brevity]

>Thanks. It's been fun dueling. I guess we just disagree on what machine
>instructions are. Maybe this will help.
>
>If I may requote you:
>>   I believe this may be our point of contention.  I believe Art, in his
>>original post, meant "machine instructions" to mean "machine language", and
>>that indeed is what I took it as (and I am using the same convention).
>
>The original postings that started this thread clearly specified that
>the code in question was source code. Art, whose comment engendered my
>wry remark to which you took umbrage, has subsequently so clarified that
>it was source code to which he referred.

   Another point where we weren't communicating.  I got the impression that
you were referring in your original followup to his message, not to his (or
any) source code by itself.
   I guess I still have to disagree a little, since source code is useless
to anything but an assembler, interpreter or compiler.  However, given that
we're talking about source code and not Art's comments to the net community,
I can see a valid dichotomy here; source code is both a data file to the
assembler/whatever AND a set of instructions to the assembler/whatever 
which define the executable file to be produced.  The "little disagreement"
I have is that the source code's executability is very limited, while the
output of the assembler/etc. (final output, as in separately executable
binary) can, in general, be executed without any dependency on anything
but the (assumed) operating system itself, and possibly the existence of
any data it needs to do its task.
   I think this last point is of the essence to the matter at hand.  Source
code, which we both agree is a good learning tool for illustrating an
algorithm or process, is not directly executable by the operating system
or the CPU, and as such is different from a separately executable, loadable
module of machine code; this allows us to argue (together!  Imagine...)
that should the Gov't start squelching source code, it's very much
analogous to squelching the publication of algorithms, which seemingly
has been permitted before.
   More semantics... *sigh*

>Sorry for your confusion.

   And I for yours.  Isn't it amazing how a few little semantic differences
can cause such a spirited "disagreement" between people who are really in
agreement and don't know it?  :-)
-- 
+------------------------------------------------------------------------------+
|   Cliff Sharp  |      clifto@indep1.chi.il.us   OR  clifto@indep1.uucp       |
|     WA9PDM     |                 Use whichever one works                     |
+------------------------------------------------------------------------------+
