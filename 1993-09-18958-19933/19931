Path: msuinfo!agate!howland.reston.ans.net!spool.mu.edu!bloom-beacon.mit.edu!news.kei.com!ddsw1!indep1!clifto
From: clifto@indep1.UUCP (Cliff Sharp)
Newsgroups: sci.crypt
Subject: Re: NEW State Dept FLASH
Message-ID: <2508@indep1.UUCP>
Date: 29 Sep 93 17:12:47 GMT
References: <hudCDz8ss.7pp@netcom.com> <2499@indep1.UUCP> <289mlp$caq@nic.umass.edu>
Organization: as little as possible
Lines: 48

In article <289mlp$caq@nic.umass.edu> quilty@twain.ucs.umass.edu (Lulu of the lotus-eaters) writes:
:This discussion goes on at great length while producing much heat, and
:little light.  What Cliff Sharp seems to be doing is making a
:persistent *ontological* mistake about the supposed radical
:seperateness of machine-instructions, versus machine-data.  And it is,

   A good point.  At one time in the "ancient" world of computers, I might
well have been correct.  But the technology is changing so fast, and the
teachings, and the understandings, and the terminology, that this is
indeed reaching the world of the metaphysical.

:indeed, true that *most* popular CPU's make this distinction in their
:caches, registers, etc.  But at a basic computational level, it's all
:a distinction without a difference.  Data is really nothing but a
:special class of instructions (namely instructions about what to write
:to new registers, when operations are made on used data-registers).

   The few computer classes I took (admittedly at a school where I knew
more than most of the teachers; e.g., _they_ came to _me_ when the school
computer wasn't working, or they needed JCL written, etc.) made a very
definite and hard distinction between instructions and data; thus my
rantings.

:The proof of this at a theoretical level is so simple as to be
:childish, really.  A Turing machine consists of state-transitions,
:and a tape.  If any instruction/data distinction could be made, it
:would have to have the tape play the data role.  But in reality, any
:Turing-machine can be represented by a universal-Turing-machine, with
:the correct tape.  Hence, the instructions in the first are
:transferable to data in the second, while maintaining computational
:equivalence.  Even universal-Turing-machines, being themselves
:particular Turing-machines, are representable on the data/tape of
:other universal-Turing-machines (or on thier own tape).  There always
:have to be a few things in any machine which act as instructions, but
:which few things are instructions is variable between machines -- and
:there's no *fundamental* ontological difference twixt the two.

   As I mentioned in an earlier article, the distinction I learned was
that an instruction is that which is inputted to the CPU during the CPU's
instruction fetch cycle.  Other views exist and are (mostly, at least)
equally valid.  I based my postings on that definition, but failed to
explicitly make the distinction before doing so.  Had I made the distinction,
perhaps my articles would have been more understandable and less controversial.
-- 
+------------------------------------------------------------------------------+
|   Cliff Sharp  |      clifto@indep1.chi.il.us   OR  clifto@indep1.uucp       |
|     WA9PDM     |                 Use whichever one works                     |
+------------------------------------------------------------------------------+
