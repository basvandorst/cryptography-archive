Newsgroups: sci.crypt,sci.math
Path: msuinfo!uwm.edu!math.ohio-state.edu!howland.reston.ans.net!usc!news.service.uci.edu!unogate!mvb.saic.com!ast.saic.com!actd!agnew
From: agnew@actd.saic.com ()
Subject: Optimal Permutation algorithm
Message-ID: <1993Sep10.164522.12774@ast.saic.com>
Keywords: permutation,bit scramble, shuffle
Sender: news@ast.saic.com
Reply-To: agnew@actd.saic.com
Organization: Science Applications International Corporation
Date: Fri, 10 Sep 1993 16:45:22 GMT
Lines: 111
Xref: msuinfo sci.crypt:19205 sci.math:51932

I am cross-posting this to sci.math in the hopes that some astute
mathematician or computer scientist can shed some light on ths
problem.  I seek the fastest algorithm for shuffling a 64 bit number,
organized into 8 bytes of 8 bits each, using only cyclic left and right
shifts (rotates) and the bswap instruction. The bswap converts
"big-endian" to "little-endian". That is, ordering the 8 bytes form
0..7 with 7 being most significant, then bswap converts
(7,6,5,4,3,2,1,0) to (0,1,2,3,4,5,6,7). Another bswap and you're back
where you started. The only requirement on the bit mapping is that each
output byte contain one bit from each of the input bits. I have found that
doing (rotate left 2 bits, bswap ) eight times followed by 
(rotate right 7, bswap) eight times does the trick, but the whole thing must be
followed by a rotate right 4 bits.

for i in 1..8 loop
    rotate left 2
end loop;
for i in 1..8 loop
    rotate right 7
end loop;
rotate right 4

The inverse is just:

rotate left 4
for i in 1..8 loop
    rotate left 7
end loop;
for i in 1..8 loop
   rotate right 2
end loop;

The output of this algorithm is as follows:

43-5, 58-7,  9-1, 24-3, 39-4, 54-6,  5-0, 20-2
35-4, 50-6,  1-0, 16-2, 31-3, 46-5, 61-7, 12-1
27-3, 42-5, 57-7,  8-1, 23-2, 38-4, 53-6,  4-0
19-2, 34-4, 49-6,  0-0, 15-1, 30-3, 45-5, 60-7
11-1, 26-3, 41-5, 56-7,  7-0, 22-2, 37-4, 52-6
 3-0, 18-2, 33-4, 48-6, 63-7, 14-1, 29-3, 44-5
59-7, 10-1, 25-3, 40-5, 55-6,  6-0, 21-2, 36-4
51-6,  2-0, 17-2, 32-4, 47-5, 62-7, 13-1, 28-3

where the bits are numbered from 0 to 63, 0 being LSB and 63 being
MSB.  The second number indicates the parent byte with 7 being the most
significant byte and 0 being the least.

The question is, is there a shorter algorithm??

The particular solution I found is a little disconcerting in that the 
solution seems disproportionate to the solution that I found for 32 bit words.
Also I don't understand why the final rotation by 4 is necessary.

Is there some property of the 32 bit group which the 64 bit group does not share???

For 32 bits, there are only 4 bytes and the requirement is that each output byte
contain 2 bits from each of the 4 input bytes. I found the following algorithm

for i in 1..2 loop
    rotate left 3
end loop;
for i in 1..2 loop
    rotate right 5
end loop;

On an 80486 PC, the 32 bit shuffle takes only 11 instructions:

    mov     cl,3
    rol     eax,cl
    bswap   eax
    rol     eax,cl
    bswap   eax
    mov     cl,5
    ror     eax,cl
    bswap   eax
    ror     eax,cl

On the other hand, the 64 bit requires 96 instructions (6 instructions
repeated 16 times):

    .486

bitscram    proc    near    ; 64 bit scramble of edx:eax
                            ; destroys cl,ebx
    mov     cl,8            ; do the left 8 times
rolloop:
    mov     ebx,edx         ; the mov, shld, shld sequence
    shld    edx,eax,7       ; synthesizes a 64 bit rotate
    shld    eax,ebx,7       ; ror edx:eax,7
    bswap   eax             ; the bswap, bswap, xchg sequence
    bswap   edx             ; simulates a 64 bit bswap
    xchg    eax,edx         ; bswap edx:eax
    dec     cl              ; for i in 1..8
    jnz     short rolloop   ; loop
    mov     cl,8            ; do the right loop 8 times
rorloop:
    mov     ebx,eax         ; ror edx:eax,2
    shrd    eax,edx,2
    shrd    edx,ebx,2
    bswap   eax             ; bswap edx:eax
    bswap   edx
    xchg    eax,edx
    dec     cl              ; for i in 1..8
    jnz     short rorloop   ; loop
    mov     ebx,eax         ; ror edx:eax,4
    shrd    eax,edx,4
    shrd    edx,ebx,4
    ret
bitscram    endp

Can any one find a significantly shorter algorithm?
