Path: msuinfo!agate!spool.mu.edu!sdd.hp.com!decwrl!decwrl!hal.com!bang.hal.COM!not-for-mail
From: landman@hal.COM (Howard Landman)
Newsgroups: comp.ai.genetic,sci.math,comp.theory,sci.crypt
Subject: Re: gray code and back
Date: 3 Sep 1993 13:28:13 -0700
Organization: HaL Computer Systems, Inc.
Lines: 53
Distribution: comp
Message-ID: <2689ctINN181@bang.hal.COM>
References: <sfleisch.745710436@hydra> <265v0fINN10p@bang.hal.COM>
NNTP-Posting-Host: bang.hal.com
Summary: shift by 32 or more may not do what you expect
Keywords: gray code binary
Xref: msuinfo comp.ai.genetic:1259 sci.math:51417 comp.theory:7811 sci.crypt:19053

In article <265v0fINN10p@bang.hal.COM> landman@hal.COM (Howard Landman) writes:
>DATA ungray(x)
>DATA x;
>{
>DATA n;
>    for (n = 1; LEGALSHIFT(n); n <<= 1)
>    {
>        x ^= x >> n;
>    }
>    return x;
>}

John Tromp sent me email pointing out that the loop might be written as:

    for (n = 1; x >> n; n <<= 1)
	    x ^= x >> n;

which is simpler, easier to understand, and has the side advantage of
terminating early for small x.  However, on many machines, this won't
work, because x>>n is not guaranteed to be zero for n>=32.  In fact,
on my SPARC IPX, it appears that x>>n is implemented as x>>(n%32), so
only the low-order 5 bits of n count:

	x>>0 = -1
	x>>1 = 2147483647
	x>>2 = 1073741823
	x>>3 = 536870911
	...
	x>>29 = 7
	x>>30 = 3
	x>>31 = 1
	x>>32 = -1
	x>>33 = 2147483647
	x>>34 = 1073741823
	x>>35 = 536870911

That's why I had to implement a LEGALSHIFT check.

John also pointed out that the loop could be unrolled (on a 32-bit
machine) to:

	x ^= x >> 1;
	x ^= x >> 2;
	x ^= x >> 4;
	x ^= x >> 8;
	x ^= x >> 16;

which is faster due to elimination of the loop overhead.  A really
smart compiler *might* do this with my code, but I wouldn't count
on it.

	Howard A. Landman
	landman@hal.com
