Path: msuinfo!agate!howland.reston.ans.net!europa.eng.gtefsd.com!uunet!world!decwrl!hal.com!bang.hal.COM!not-for-mail
From: landman@hal.COM (Howard Landman)
Newsgroups: comp.ai.genetic,sci.math,comp.theory,sci.crypt
Subject: Re: gray code and back
Date: 2 Sep 1993 16:18:39 -0700
Organization: HaL Computer Systems, Inc.
Lines: 104
Distribution: comp
Message-ID: <265v0fINN10p@bang.hal.COM>
References: <sfleisch.745710436@hydra>
NNTP-Posting-Host: bang.hal.com
Keywords: gray code binary
Xref: msuinfo comp.ai.genetic:1253 sci.math:51350 comp.theory:7806 sci.crypt:19029

In article <sfleisch.745710436@hydra> sfleisch@convex.com (Steve Fleischman) writes:
>A while back a number of people responded with a relatively
>simple way to generate gray code numbers from binary:
>
>x^(x>>1)
>
>Is there an equivalent way to get the binary bit pattern back from the
>gray code without using a table.  I want to be able to use fairly large
>numbers and not store them in a table.

Well, perhaps not quite so efficient, but doable.  Consider two approaches:

1. You can pick off the first (high-order) bit by noting that it is the
   same in x and x^(x>>1).  This means you can reduce the problem by
   one bit by XORing the upper 2 bits with 2 copies of the upper bit
   (00 or 11), then iterate.  This takes run time proportional to n (the
   number of bits) (counting ^ and >> as taking constant time), or to
   the square of n (counting ^ and >> as taking linear time in the number
   of bits).  In hardware, you could build this with 2n XOR gates and
   very little routing (it's similar to a ripple-carry adder).

2. Define f(x,n) = x^(x>>n).  Then if y = x^(x>>1) = f(x,1):

	f(y,1) = y^(y>>1)
	       = x^(x>>1)^(x>>1)^(x>>2)
	       = x^(x>>2)
   
   Now the upper *2* bits are the same as x.  Repeat:

	f(f(y,1),2) = x^(x>>2)^(x>>2)^(x>>4)
	            = x^(x>>4)

	f(f(f(y,1),2),4) = x^(x>>4)^(x>>4)^(x>>8)
	                 = x^(x>>8)

	f(f(f(f(y,1),2),4),8) = x^(x>>8)^(x>>8)^(x>>16)
	                 = x^(x>>16)

   And so on until n exceeds the number of bits in your representation.
   This method takes run time proportional to log(n) or n*log(n) (same
   pair of assumptions as above).  But in hardware, a straightforward
   implementation might take nearly n*log(n) XOR gates and require some
   moderately long wires.

In K&R C, I coded approach 2 as:

------------------ 8< CUT HERE >8------------------------------------------
/* Gray-code-to-binary conversion, Howard A. Landman, Sept. 1st 1993 */
/* Comments and corrections to landman@hal.com */
#include    <stdio.h> 
extern void     exit();
#define DATA    unsigned
#define MAX     ((DATA)0xFFFFFFFF)
/* On many machines, a shift by larger than the wordsize gives no shift. */  
/* This is of course not what we want here ... */  
#define LEGALSHIFT(n)   ((n)<32)
    
DATA gray(x)     
DATA x;
{
        return x^(x>>1);
}

DATA ungray(x)
DATA x;
{
DATA n;
    for (n = 1; LEGALSHIFT(n); n <<= 1)
    {
        x ^= x >> n;
    }
    return x;
}

main()
{
DATA x;
    for (x = MAX; x; x--)
    {
        if (ungray(gray(x)) != x)
        {
            (void) fprintf(stderr,"Compare failed for x = %d, gray(x) = %d, ungray(gray(x)) = %d\n",
                x, gray(x), ungray(gray(x)));
            return -1;
        }
    }    
    (void) fprintf(stderr,"All tests from 1 to %d passed\n",MAX);
    return 0;
}

/* Note: This runs 4 billion test cases (all 32 bit numbers except 0)
 * and takes about an hour and a quarter on a SPARCstation IPX.  If you
 * have a slower or 16-bit machine, you might want to redefine MAX and DATA.
 * For arbitrary-precision arithmetic, LEGALSHIFT will have to be changed
 * to cover enough bits for the word at hand.
 */
------------------ 8< CUT HERE >8------------------------------------------

By the way, I made both of these up on the spur of the moment; didn't see
them in a book.  Does anyone know whether they are original or not?  The
second one in particular seems satisfyingly elegant, perhaps even optimal.

	Howard A. Landman
	landman@hal.com
