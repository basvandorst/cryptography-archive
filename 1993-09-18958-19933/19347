Path: msuinfo!agate!howland.reston.ans.net!darwin.sura.net!haven.umd.edu!news.umbc.edu!olson
From: olson@umbc.edu (Bryan G. Olson)
Newsgroups: sci.crypt
Subject: Re: Layered Encrytpion Schemes
Date: 16 Sep 1993 15:21:28 -0400
Organization: University of Maryland, Baltimore County Campus
Lines: 77
Sender: olson@umbc.edu (Mr. Bryan G. Olson; CMSC (G))
Distribution: world
Message-ID: <27aeboINNnr0@umbc7.umbc.edu>
References: <1993Sep16.152746.5732@ast.saic.com> <1993Sep16.153546.7541@ast.saic.com>
NNTP-Posting-Host: umbc7.umbc.edu



In article <1993Sep14.152938.25666@ast.saic.com>, Bob Agnew writes:
|> Wat is known about "layered" encryption schemes? 
|> I uses the term layerd to describe algorithms which may be described by:
|> 
|> x => f(x,k) where:
|> 
|> y(1) = g(x,k(1))
|> y(2) = g(y(1),k(2))
|>  
|>  
|>  
|> y(n-1) = g(y(n-2),k(n-1))
|> f(x,k) = g(y(n-1),k(n))
|> 
There is a problem with the notation.  To define f(x,k) 
n needs to be quantified as some fixed number of rounds.
To use n as the induction variable to recursively define
y(n) it needs to be quantified as "for all n>2".  


Let's use the more common term "(n round) iterated cyptosystem".
Also we should make the parameters explicit:

  f(x,n,k[],g()) = x                            if n=0
                 = g( f(x,n-1,k[],g()), k[n] )  if n>0

Here is some pseudo-code:

encrypt( x, n, k[1..n], g() ) is:
  block= x
  For i=1 to n
     block= g( block, k[n] )
  return( block )
end

|> In particular, I am interested in 3 special cases of the crypto kernal function g(x,k):
|> 
|> Case 1:		g(x,k) = k xor T(P(x))
|> Case 2:		g(x,k) = T(P(x xor k))
|> Case 3:		g(x,k) = T(P(x) xor k)
|> 
|> k = {k(n), k(n-1),.....k(1))
|> 
|> where T() represents any invertible mapping of its argument and P() is a permutation.
|> Also it is assumed that both f() and its inverse are widely known and that the key, k, is secret and vulnerable to attack.
|> 

Note that it doesn't really matter whether you permute before or after
xor-ing with the key, since P(k xor x) = P(k) xor P(x).  Also, iff T is 
"any invertable mapping", then including P() in cases 1 & 2 is redundant.

T() has a role similar to the S-Boxes of DES.  It is the only
non-linear transformation in the cipher.  Note that if an 
adversary knows (x xor y) he can easilly determine
(P(x xor k) xor P(y xor k)).  If T() is not very carefully
designed, the cipher will fall to differential cryptanalysis.

|> Originally, I choose Case three for implementation because because I beleived that randomizing the arguments to T() would excite the avalanche property. However, upon
|> further reflection, it appears that not having a masking of the outer layer as in Case 1 allows the outer layer of the "onion" to be peeled back more easily.
|> 
|> 1)  Does having a large number of layers aleviate this weakness?
|> 
|> 2)  Should Case 1 be used for the outer layer in any case?
|> 
|> 

(folk theorem: )  Anything you do before the first key bits are 
used or after the last key bit are used is cryptographically 
useless.  If an adversary has plaintext and corresponding ciphertext
he can undo these non-key-dependent transforms on each end.

Bryan Olson
olson@umbc.edu


