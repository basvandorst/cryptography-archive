Newsgroups: sci.crypt
Path: msuinfo!agate!ames!news.Hawaii.Edu!wiliki.eng.hawaii.edu!newsham
From: newsham@wiliki.eng.hawaii.edu (Timothy Newsham)
Subject: DES,  parity bits
Message-ID: <CD2Kq9.9zw@news.Hawaii.Edu>
Sender: news@news.Hawaii.Edu
Organization: University of Engineering, College of Engineering
Date: Thu, 9 Sep 1993 04:34:57 GMT
Lines: 43

Hi,
  DES takes 8 bytes of key information and throws out the parity bits
leaving 7 bits per character, 8 characters = 56 bits.
Any change in the parity bits shouldnt have an effect in the output
of a DES encryption.

  crypt(3) is based on DES and used as a one way function.  Basically
it does DES(0,input), ie encrypt the block of zeros (64 bits of 0)
with the input (8 bytes, minus parity bits).

So why does the following give 2 different results?

---- test.c ---------
/* these should encrypt the same */

/* differ only in one of the parity bits,  should encrypt the same */
char string1[] = { 
  0x80, 0x79, 0x6c, 0xd9, 0xc9, 0x02, 0xd5, 0xcf,
};

char string2[] = { 
  0x00, 0x79, 0x6c, 0xd9, 0xc9, 0x02, 0xd5, 0xcf,
};

char *crypt();

main()
{
  printf("a: %s\n",crypt(string1,"aa"));
  printf("b: %s\n",crypt(string2,"aa"));
}
-------------

If the first byte of each string was changed to 0x90 and 0x10
Everything would work normally (the two output strings would match).
What is happening here?  Is something specially done for bytes that
are zero?  Both HPUX's crypt(3) function and the libufc crypt(3)
functions performed identically giving different results for
these two strings.

Email response prefered.
                               ...

