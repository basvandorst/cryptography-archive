Newsgroups: sci.crypt
Path: msuinfo!news.mtu.edu!sol.ctr.columbia.edu!usc!elroy.jpl.nasa.gov!decwrl!netcomsv!netcom.com!jkennedy
From: jkennedy@netcom.com (John Kennedy)
Subject: Re: RSA hardware
Message-ID: <jkennedyCDB1EJ.Cu0@netcom.com>
Organization: Netcom - Online Communication Services (408 241-9760 guest)
References: <jkennedyCD3IAv.Ct@netcom.com> <CD7F8B.A43@fasttech.com> <1993Sep11.204313.24090@jarvis.csri.toronto.edu>
Date: Mon, 13 Sep 1993 18:15:54 GMT
Lines: 63

In article <1993Sep11.204313.24090@jarvis.csri.toronto.edu> lewis@eecg.toronto.edu (david lewis) writes:
>In article <CD7F8B.A43@fasttech.com> zeke@fasttech.com (Bohdan Tashchuk) writes:
>>In <jkennedyCD3IAv.Ct@netcom.com> jkennedy@netcom.com (John Kennedy) writes:
>>
>>>For a 1028-bit modulus, a single exponentiation with randomly chosen operands
>>>takes approximately 550 milliseconds when using a 12 MHz clock.  We do,
>>>however, have parts that run up to 30 MHz if you're in a real hurry :-)
>
[miscellaneous stuff deleted]
>
>This is surprisingly slow for hardware. In the most recent IEEE Conf.
>on Comp. Arith. a paper [1] described an implementation of RSA using FPGAs, with
>performance of 600Kbits/sec. for 512 bit keys. Since FPGAs are slower than
>snail snot in January, most of this impressive speed is due to clever
>algorithms.  For pure software implementations, the author cited 30ms/block
>on a R3000, and 9ms/block on a DEC alpha using the same algorithms for
>1024 bit keys.
>
>Reference:
>[1] M. Shand and J. Vuillemin, "Fast Implementations of RSA
>Cryptography", Proc 11th Symp. on Comp. Arith, IEEE, July 1993
>
>David Lewis


I haven't seen that paper yet, but I would like to point out a couple of
things that may not be obvious:

1. The calculation time I cited is for a^b mod c, where a, b, and c
are randomly chosen 1028 bit numbers.  The operands do not have any
particular structure and no precomputation is done.

2. The numbers you cited were for implementing RSA.  In the RSA cryptosystem
the modulus used is bicomposite, i.e., the product of two primes.  This
allows for the use of techniques such as the Chinese Remainder Theorem where
we can do some precomputation with the prime factors to speed up the 
encryption/decryption operations later on.

3. The other trick done with RSA is to use a short exponent such as 
2^16 + 1 for one of the keys.  This does not weaken the system, but does
allow for much faster processing in either the encrypt or decrypt direction.
When spec'ing cryptosystems, always get the encrypt *and* the decrypt timings.
For a digital signature system, I would also want to know the hashing time
for various block sizes.

4. NIST's Digital Signature Algorithm can also take advantage of precomputation
and other mathematical time-savers.  Since prime moduli are used in the DSA,
you can't use Chinese Remainder, however.  The same situation happens if
you are doing a Diffie-Hellman key exchange: in general, you would be
doing calculations using a randomly chosen, unstructured prime modulus.

5. There is a lot more to building cryptogear than beating speed records.
There's that little gotcha called "cost" involved.  When building a chip,
that cost is essentially proportional to the die size.  There are also
costs associated with testing, board real estate, host processor support,
external memory requirements, etc.  A board full of FPGA's is usually
no bargain.  

6. In summary, be careful of comparing apples with oranges.


-John Kennedy
jkennedy@cylink.com
