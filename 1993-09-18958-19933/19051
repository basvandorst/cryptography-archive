Newsgroups: comp.ai.genetic,sci.math,comp.theory,sci.crypt
Path: msuinfo!agate!howland.reston.ans.net!spool.mu.edu!uwm.edu!cs.utexas.edu!csc.ti.com!tilde.csc.ti.com!ra.csc.ti.com!pocomoco!rowlands
From: rowlands@pocomoco.NoSubdomain.NoDomain (Jon Rowlands)
Subject: Re: gray code and back
Message-ID: <CCsMpy.Ky5@csc.ti.com>
Keywords: gray code binary
Sender: rowlands@pocomoco (Jon Rowlands)
Nntp-Posting-Host: pocomoco.hc.ti.com
Reply-To: rowlands@hc.ti.com (Jon Rowlands)
Organization: Texas Instruments, SPDC, DSP Technology Branch, Dallas
References: <sfleisch.745710436@hydra> <265v0fINN10p@bang.hal.COM>
Distribution: comp
Date: Fri, 3 Sep 1993 19:41:58 GMT
Lines: 98
Xref: msuinfo comp.ai.genetic:1258 sci.math:51414 comp.theory:7810 sci.crypt:19051

In article <265v0fINN10p@bang.hal.COM>, landman@hal.COM (Howard Landman)
writes:
>In article <sfleisch.745710436@hydra> sfleisch@convex.com (Steve Fleischman)
>writes:
>>A while back a number of people responded with a relatively
>>simple way to generate gray code numbers from binary:
>>
>>x^(x>>1)
>>
>>Is there an equivalent way to get the binary bit pattern back from the
>>gray code without using a table.  I want to be able to use fairly large
>>numbers and not store them in a table.
>
>Well, perhaps not quite so efficient, but doable.  Consider two approaches:
>

[interesting methods deleted]

>By the way, I made both of these up on the spur of the moment; didn't see
>them in a book.  Does anyone know whether they are original or not?  The
>second one in particular seems satisfyingly elegant, perhaps even optimal.
>
>	Howard A. Landman
>	landman@hal.com

Yep, very nice. Both of these methods are also interesting when you look
at them as using polynomials over the finite field GF(2), which is just
arithmetic modulo 2. In this case, the "xor" function is like addition,
and the "and" function is like multiplication. Also, subtraction is the
same as addition - both are "xor".

For simlicity later, I'd also like to write the algorithms in terms of
left shifts instead of right shifts. So instead of dropping the bits that
fall off to the right, keep all the bits around and just drop them at the
very end of the process. One more thing, instead of x and y being the
binary and grey code numbers I'll use B and G, because I want to keep x
for something else.

Consider the binary number B that you want to turn into gray code
representation G and back. Write B as a polynomial B(x), with each bit as
a coefficient of a power of x (the x here is unrelated to the x in the
original post). A left shift then consists of moving all the polynomial
coefficients up one power, i.e. B << 1 is like B(x)*x.

then if G = (B<<1)^B, we can write

	G(x)	= B(x)x + B(x)
		= B(x)(x + 1)

The actual grey code number you'll keep is only the top n coefficents of
G(x), if B is an n bit number.

Now it gets interesting. Given the grey code number G, you can recover
the original binary number B by dividing the polynomials:

	B(x) = G(x) / (x + 1)

This is algorithm 1. You don't have all the bits of the original G(x)
since we dropped the bottom one, but it's enough to reconstruct B.

The second algorithm makes use of the special property of GF(2) that
addition is the same as subtraction. Normally, we have the relationship
that
	(x + 1)(x - 1) = x**2 - 1.

In GF(2) we can replace subtraction by addition, so we get

	(x + 1)(x + 1) = x**2 + 1.

By doing this recursively a few times, we find a general relation

	(x + 1)**n = x**n + 1 when n = 2**m

So, to recover an 8 bit number from it's grey code form, we can multiply:

	G(x)(x+1)(x**2+1)(x**4+1)
		= B(x)(x+1)(x+1)(x**2+1)(x**4+1)
		= B(x)(x**2+1)(x**2+1)(x**4+1)
		= B(x)(x**4+1)(x**4+1)
		= B(x)(x**8+1)

and pick off B(x) from the upper 8 coefficients of the result. This is
algorithm 2.

I've been slack in leaving out the effect of dropping the lowest coefficient
of G(x) in the grey code encoding. It's not too much harder to include this
in the calculations and show that it makes no difference, but it's more
typing!

This was the first time I've seen your algorithms, Howard. It was a pleasant
surprise to see how it all fits together.

regs,
-- 
Jon Rowlands			email: rowlands@hc.ti.com
Texas Instruments		phone: +1 214 995-3436
DSP Technology Branch, SPDC	  fax: +1 214 995-6194
Dallas, Texas, USA		N'cest pas une cig
