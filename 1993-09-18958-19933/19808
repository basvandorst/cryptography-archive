Path: msuinfo!agate!howland.reston.ans.net!sol.ctr.columbia.edu!hamblin.math.byu.edu!news.byu.edu!news.mtholyoke.edu!nic.umass.edu!twain.ucs.umass.edu!quilty
From: quilty@twain.ucs.umass.edu (Lulu of the lotus-eaters)
Newsgroups: sci.crypt
Subject: Re: NEW State Dept FLASH
Date: 28 Sep 1993 15:53:29 GMT
Organization: University of Massachusetts, Amherst
Lines: 32
Message-ID: <289mlp$caq@nic.umass.edu>
References: <hudCDvI7I.3Fu@netcom.com> <2492@indep1.UUCP> <hudCDz8ss.7pp@netcom.com> <2499@indep1.UUCP>
NNTP-Posting-Host: twain.ucs.umass.edu
X-Newsreader: TIN [version 1.2 PL0]

Cliff Sharp (clifto@indep1.UUCP) wrote:
:    Art's ASCII message was no more a set of machine instructions than would
: be my vocal instruction to my machine to make my undebugged program "work
: RIGHT this time!"  Neither his ASCII code nor my voice command is sent as
: an instruction to the CPU.  Some set of machine instructions causes Art's
: message to be read by the CPU as _data_ which is to be manipulated in some
: way by the machine instructions to cause phosphors to light a certain way.

This discussion goes on at great length while producing much heat, and
little light.  What Cliff Sharp seems to be doing is making a
persistent *ontological* mistake about the supposed radical
seperateness of machine-instructions, versus machine-data.  And it is,
indeed, true that *most* popular CPU's make this distinction in their
caches, registers, etc.  But at a basic computational level, it's all
a distinction without a difference.  Data is really nothing but a
special class of instructions (namely instructions about what to write
to new registers, when operations are made on used data-registers).
The proof of this at a theoretical level is so simple as to be
childish, really.  A Turing machine consists of state-transitions,
and a tape.  If any instruction/data distinction could be made, it
would have to have the tape play the data role.  But in reality, any
Turing-machine can be represented by a universal-Turing-machine, with
the correct tape.  Hence, the instructions in the first are
transferable to data in the second, while maintaining computational
equivalence.  Even universal-Turing-machines, being themselves
particular Turing-machines, are representable on the data/tape of
other universal-Turing-machines (or on thier own tape).  There always
have to be a few things in any machine which act as instructions, but
which few things are instructions is variable between machines -- and
there's no *fundamental* ontological difference twixt the two.

Yours, Lulu...
