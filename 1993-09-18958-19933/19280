Newsgroups: sci.crypt,sci.math
Path: msuinfo!news.mtu.edu!sol.ctr.columbia.edu!math.ohio-state.edu!darwin.sura.net!seismo!esosun.css.gov!mvb.saic.com!ast.saic.com!actd!agnew
From: agnew@actd.saic.com ()
Subject: Re: Optimal Permutation algorithm
Message-ID: <1993Sep13.180912.4957@ast.saic.com>
Sender: news@ast.saic.com
Reply-To: agnew@actd.saic.com
Organization: Science Applications International Corporation
References: <1993Sep10.164522.12774@ast.saic.com>
Date: Mon, 13 Sep 1993 18:09:12 GMT
Lines: 118
Xref: msuinfo sci.crypt:19280 sci.math:52204


In article 12774@ast.saic.com, I erroneously described a permutation 
algorithm. It should have read:

for i in 1..8 loop
    rotate left 2
    bswap
end loop;
for i in 1..8 loop
    rotate right 7
    bswap
end loop;
rotate right 4

The inverse is just:

rotate left 4
for i in 1..8 loop
    bswap
    rotate left 7
end loop;
for i in 1..8 loop
   bswap
   rotate right 2
end loop;

I had inadvertly left out the bswaps (little/big endian). I use the 
shorthand for this permutation (2,2,2,2,2,2,2,2,-7,-7,-7,-7,-7,-7,-7,-7)
where by convention, right shifts are negative. Numbering the bytes with
a..h with the least significant being a, the output bytes are:

f3, h2, b1, d0, e7, g6, a5, c4
e3, g2, a1, c0, d7, f6, h5, b4
d3, f2, h1, b0, c7, e6, g5, a4
c3, e2, g1, a0, b7, d6, f5, h4
b3, d2, f1, h0, a7, c6, e5, g4
a3, c2, e1, g0, h7, b6, d5, f4
h3, b2, d1, f0, g7, a6, c5, e4
g3, a2, c1, e0, f7, h6, b5, d4


The most significant byte is listed first (f3..c4) and the msb is on the right.
The number is the bit number (0..7) in the parent byte, the letter indicates the
parent byte. This mapping has the desired property that each output byte contains
exactly one bit from each of the input bytes.

I posted soem 80486 code for this shuffle which Ian Ameline kindly provided the
timing analysis for in article 19930910.130428.321@almaden.ibm.com which was 
230 clock cycles. I have found a significantly faster algorithm. The 32 bit shuffle
(3,3,-5,-5) produces 4 bytes, each of which has two bits from each of the original
bytes. Labeling the input bytes as a..d with a least significant, that algorithm 
produces:

a3, a2, c1, c0, b7, d6, d5, b4
d3, d2, b1, b0, a7, c6, c5, a4
c3, c2, a1, a0, d7, b6, b5, d4
b3, b2, d1, d0, c7, a6, a5, c4

The timing for that algorithm is 12 clock cycles. The new algorithm proceeds
by performing the (3,3,-5,-5) algorithm on each 32 bit half of the 64 bit word.
Assume that the 64 bit word is originally in edx:eax. eac contains dcba and edx
contains hgfe. I use U to denote any one of the upper bytes e,f,g,h and V to
denote any one of the lower bytes a,b,c,d. After the two 32 bit shuffles, the
edx:eax is of the form UUUUVVVV. We can interleave the bytes to obtain UVUVUVUV
by doing:

xchg ax,dx	3 cycles
ror eax,8	2 cycles
ror edx,8	2 cycles

Each of the bytes has the bit order xxyywzzw. We can see in the table
above that in the msb byte we have x=a,y=c,w=b and z=d. In the lsb
byte, x=b,y=d,w=c, and z=a. It is only important to note that the x's
are of the same type in each byte and not what particular byte they
correspond to. 

We define the "type" of a bit to mean its parent byte
letter a..g. We say that a nibble is "complete" when each of its 4 bits
are of a different type. A byte is complete when each of its 8 bits are
of a different type. The goal is to permute the 8 input bytes so that
each of the output bytes are "complete" in this sense. 

We now provide a mapping which reorders the bits in each byte so that
there are two nibbles, (4 bit group) each of which contains one bit from
each of the input bytes (either U or V but same in each byte). I used the
mapping (7,6,5,4,3,2,1,0) => (25074361) which maps the above table to:

d6, c1, b4, a3, c0, b7, a2, d5
c6, b1, a4, d3, b0, a7, d2, c5
b6, a1, d4, c3, a0, d7, c2, b5
a6, d1, c4, b3, d0, c7, b2, a5

We note that each nibble is now complete in that the upper nibble has one
each of a,b,c,d and so does the lower. After mapping each of the eight bytes
in edx:eax and denoting a complete upper nibble by "u" and a complete lower
nibble by "v" the edx:eax is of the form uuvvuuvvuuvvuuvv. Simply rotating the 
eax by four bit and the edx by four bits produces:

uvvuuvvuuvvuuvvu

Thus each byte contains an complete upper nibble and a complete lower nibble
and so each byte is complete which was the desired transformation.


The timing is as follows :

operation	# ops	cycles per op	total cycles
______________________________________________________________
32 bit shuffle	   2	      12	     24
byte interleave	   1	       7	      7
Table Lookup	   8           2             16
rotates		   8	       2	     16
_________________________________________________________
					     63 cycles

This is about 4 times faster the previous algorithm. Assembler code
is available from agnew@actd.saic.com

