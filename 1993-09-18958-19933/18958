Newsgroups: comp.arch,sci.crypt
Path: msuinfo!agate!howland.reston.ans.net!europa.eng.gtefsd.com!uunet!munnari.oz.au!metro!basser.cs.su.oz.au!news
From: mrj@moria.cs.su.oz.au (Mark James)
Subject: Putting Copy Protection in the CPU
Reply-To: mrj@cs.su.oz.au (Mark James)
Organization: Basser Dept of Computer Science, University of Sydney, Australia
Date: Tue, 31 Aug 1993 11:42:42 GMT
Message-ID: <1993Aug31.114242.933@cs.su.oz.au>
Sender: news@cs.su.oz.au (News)
Lines: 69
Xref: msuinfo comp.arch:43481 sci.crypt:18958

One way to robustly implement protection against illegal copying
of software would be to put it into the CPU.

Software would be purchased over the phone, or at a store,
to run on a particular (individual) CPU chip (identified by an
id number).  It would be possible to purchase a second copy for
a notebook-type CPU for a small additional charge.  Of course this
would prevent the second-hand sale of software separate from its CPU,
but software prices should come down with a reduction in piracy.

The only feasible way to implement the copy protection would seem
to be encryption of the binary, either with:
  * a secret algorithm: Probably needed, but means extra security at
    premises of software delivery companies and CPU manufacturers.
  * a public algorithm with secret/secret-public keys
   (derived from public CPU id #)

The CPU would have to have a unit to decrypt an incoming instruction
stream.  Instructions would be stored in the on-chip instruction cache
in decrypted form to significantly cut down on the amount of decryption.
No plain-text version of the code is ever stored externally.

There would also be an instruction to turn encryption off and on so that
the CPU would run plain-text software (e.g. public domain software).

One way of handling people wanting to upgrade their CPU, without
making them repurchase their software, would be to allow them to
dial a phone number which gives them a code which allows the CPU
id # of their old CPU to be changed to a new number.  A confirmation
code is returned by the CPU, which can then be used to get a code
that transforms the CPU id # of the new CPU to that of the old CPU.
This allows the old software to run on the new machine while
ensuring there is not another CPU with that number in existence.

Transferring only part of the protected software to the new
machine is more tricky.  You would have to change the old CPU id #
as before, identify from partial images what software is held,
and request new copies of the software in the desired combination.
This is also a way around the second-hand software problem mentioned
above.

A broken CPU would have to be returned to a validating authority
before its code could be given to another CPU.

The questions I have are:

* Would such on-chip decryption be feasible/cost-effective with
  algorithms/keys complex enough to make cracking sufficiently hard?
  Encryption dependencies within the encrypted code would have to be
  limited to the length of a cache line (e.g. 128bits). Extra
  global parameters could also be used, plus maybe some execution
  history/serial/contextual dependencies.

* If secret algorithms/keys were put on the chip as gates or microcode,
  how easy would it be for it to be reverse-engineered by inspecting
  a die?  Can a extra non-conducting layer be added to the wafer to
  mask this part of the chip?

If feasible, such a chip would be very popular with software
companies.  They would all want to write software for it.
It would not be that popular with some potential purchasers,
although legal copies of software should be cheaper on such a CPU
than on CPUs without the protection function.

Thanks for your help,

Mark James                                   |  EMAIL : mrj@cs.su.oz.au  |
Basser Department of Computer Science, F09   |  PHONE : +61-2-692-4276   |
The University of Sydney NSW 2006 AUSTRALIA  |  FAX   : +61-2-692-3838   |
