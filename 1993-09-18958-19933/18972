Newsgroups: comp.arch,sci.crypt
Path: msuinfo!agate!spool.mu.edu!sol.ctr.columbia.edu!usc!elroy.jpl.nasa.gov!decwrl!netcomsv!netcom.com!netcomsv!metaflow!rschnapp
From: rschnapp@metaflow.com (Russ Schnapp)
Subject: Re: Putting Copy Protection in the CPU
Message-ID: <CCMtAB.LA@metaflow.com>
Keywords: decrypting microprocessor public key cryptosystems
Sender: usenet@metaflow.com
Nntp-Posting-Host: habu
Organization: Metaflow Technologies Inc.
References:  <1993Aug31.114242.933@cs.su.oz.au>
Date: Tue, 31 Aug 1993 16:18:11 GMT
Lines: 111
Xref: msuinfo comp.arch:43495 sci.crypt:18972

In article <1993Aug31.114242.933@cs.su.oz.au>, mrj@moria.cs.su.oz.au (Mark James) writes:
|> One way to robustly implement protection against illegal copying
|> of software would be to put it into the CPU.

I submitted a patent application on this concept to Burroughs
Corporation's Patent Dept in 1983.  They pursued it for awhile, but
after I left the company, they dropped it.  Clearly, if they thought it
would be valuable, they would have followed through.

|> The only feasible way to implement the copy protection would seem
|> to be encryption of the binary, either with:
|>   * a secret algorithm: Probably needed, but means extra security at
|>     premises of software delivery companies and CPU manufacturers.
|>   * a public algorithm with secret/secret-public keys
|>    (derived from public CPU id #)

I chose the latter.  Of course, in 1983, as now, there are no feasible
public key algorithms for this application.  In fact, it is difficult
to imagine a case wherein a decrypting microprocessor (which is what I
called the concept) would not impose a serious performance penalty.
Naturally, you would pipeline the process, probably using line-sized
blocks on insertion to decrypted on-chip caches.  If you made the
instruction cache large enough, you probably wouldn't see too much
performance degradation.  Encrypting data is more problematic.  You
really can't build an on-chip data cache that would be nearly large
enough.  Allowing decrypted data or code off-chip opens up the door to
code-breaking services.

|> The CPU would have to have a unit to decrypt an incoming instruction
|> stream.  Instructions would be stored in the on-chip instruction cache
|> in decrypted form to significantly cut down on the amount of decryption.
|> No plain-text version of the code is ever stored externally.

Right.

|> There would also be an instruction to turn encryption off and on so that
|> the CPU would run plain-text software (e.g. public domain software).

Actually, this would more likely be an attribute in a page descriptor.  

|> One way of handling people wanting to upgrade their CPU, without
|> making them repurchase their software, would be to allow them to
|> dial a phone number which gives them a code which allows the CPU
|> id # of their old CPU to be changed to a new number.  A confirmation
|> code is returned by the CPU, which can then be used to get a code
|> that transforms the CPU id # of the new CPU to that of the old CPU.
|> This allows the old software to run on the new machine while
|> ensuring there is not another CPU with that number in existence.

I don't know about this.  Sounds like an easy way to break the system.

|> The questions I have are:
|> 
|> * Would such on-chip decryption be feasible/cost-effective with
|>   algorithms/keys complex enough to make cracking sufficiently hard?
|>   Encryption dependencies within the encrypted code would have to be
|>   limited to the length of a cache line (e.g. 128bits). Extra
|>   global parameters could also be used, plus maybe some execution
|>   history/serial/contextual dependencies.

I don't think it is feasible at this time.  I have doubts about the
feasibility for quite awhile to come.  You will inevitably give up
significant performance for this feature, which will only
(theoretically) yield reduced software prices.  You would have to have
performance to throw away.  This doesn't seem to be the case right
now.  F'rinstance, if you could get a decrypting x86 processor that
would allow you to buy software at 1/2 street price, but ran at
80286-16 speeds, would you buy it?

|> * If secret algorithms/keys were put on the chip as gates or microcode,
|>   how easy would it be for it to be reverse-engineered by inspecting
|>   a die?  Can a extra non-conducting layer be added to the wafer to
|>   mask this part of the chip?

Secret algorithms are for the birds.  As soon as one "disgruntled
employee" leaks the algorithm, the entire system is shot.  You needn't
worry about the expense of reverse-engineering a secret algorithm.
Mention secret algorithms in sci.crypt and be prepared to be laughed
off the network.

Secret key systems are a poor risk, too.  You would either have to
compromise security of the key or compromise security of the software
to be decrypted, since someone has to know your secret key in order to
encrypt the software for you.

The elegance of the public key system is that the decryption key need
not be recorded anywhere off-chip.

It seems fairly likely that you would be able to protect the on-chip
encryption key from reverse engineering by a variety of means.
Apparently, the proposed Clipper encryption chip will employ a variety
of anti-reverse- engineering techniques.

|> If feasible, such a chip would be very popular with software
|> companies.  They would all want to write software for it.
|> It would not be that popular with some potential purchasers,
|> although legal copies of software should be cheaper on such a CPU
|> than on CPUs without the protection function.
|> 
|> Thanks for your help,
|> 
|> Mark James                                   |  EMAIL : mrj@cs.su.oz.au  |
|> Basser Department of Computer Science, F09   |  PHONE : +61-2-692-4276   |
|> The University of Sydney NSW 2006 AUSTRALIA  |  FAX   : +61-2-692-3838   |

-- 

...Russ Schnapp
Email: netcom!metaflow!rschnapp or rschnapp@Metaflow.com or rschnapp@ACM.org
Metaflow Technologies   Voice: 619/452-6608x230;  FAX: 619/452-0401
La Jolla, California    Unless otw specified, I`m speaking only for myself!
