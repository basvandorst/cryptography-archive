Newsgroups: sci.crypt
Path: msuinfo!uwm.edu!spool.mu.edu!howland.reston.ans.net!europa.eng.gtefsd.com!darwin.sura.net!seismo!esosun.css.gov!mvb.saic.com!ast.saic.com!actd!agnew
From: agnew@actd.saic.com (Bob Agnew)
Subject: Re: Layered Encrytpion Schemes
Message-ID: <1993Sep15.202434.8900@ast.saic.com>
Summary: Code Table Constraints
Sender: news@ast.saic.com
Reply-To: agnew@actd.saic.com
Organization: Science Applications International Corporation
References: <1993Sep14.152938.25666@ast.saic.com>
Date: Wed, 15 Sep 1993 20:24:34 GMT
Lines: 71

I have previously described a model of a particular class of encryption schemes
which I call layered in which each layer consists of a permutation followed
by several byte (or otherwise organized) substitutions according to the
table function T().

In article 25666@ast.saic.com, agnew@actd.saic.com () writes:
>What is known about "layered" encryption schemes? 
>I uses the term layered to describe algorithms which may be described by:
>
>x => f(x,k) where:
>
>y(1) = g(x,k(1))
>y(2) = g(y(1),k(2))
> 
> 
> 
>y(n-1) = g(y(n-2),k(n-1))
>f(x,k) = g(y(n-1),k(n))
>
>In particular, I am interested in 3 special cases of the crypto kernal function g(x,k):
>
>Case 1:		g(x,k) = k xor T(P(x))
>Case 2:		g(x,k) = T(P(x xor k))
>Case 3:		g(x,k) = T(P(x) xor k)
>
>k = {k(n), k(n-1),.....k(1))
>
>where T() represents any invertible mapping of its argument and P() is a permutation.
>Also it is assumed that both f() and its inverse are widely known and that the key, k, is secret and vulnerable to attack.
>

In the model, x is a binary vector with Dim(X) bits. g, T, and P are all
vector valued functions of the dimension of x. Furthermore the vector x may
be expressed as a vector of bytes. I overloaded g, T, and P with byte valued
functions indicated by the byte index j.

Case 1:		g(x,j,k(n)) = k(n,j) xor T(P(x,j),j)
Case 2:		g(x,j,k(n)) = T(P(x xor k(n,j),j),j)
Case 3:		g(x,j,k(n)) = T(P(x,j) xor k(n,j),j)

For the case of interest to me, x is a 64 bit bibary vector organized into
8 eight bit bytes so that j is in 0..7.

I imposed the constraint that each output byte contain
one bit from each of the input bits. I further imposed the constraint
that T(x) not map x onto itself i.e. T(x) /= x. Upon further reflection,
there is another mapping which should be avoided. One bit of each byte
of the permutation must be mapped into that same byte. It is even
possible that one bit is mapped into itself. Let the scalar function Hb(j)
denote bit position of the j'th byte that is mapped into the j'th byte and 
Hn(j) denote the bit position that it is mapped into. We then must require
that:

T(2^Hb(j),j) /= 2^Hn(j)

lest the transient cycle 2^Hb(j) <==> 2^Hn(j) recur every other layer.
It also would be desirable to avoid chains of length 3 or even more although
I expect that this would be quite difficult to check for.

I also expressed the desire that E{x(j)T(x,j)} be approximately equal to
E{x(j)}E{T(x,j)} where E{} denotes the ensemble expectaton over byte values.
I have been convinced by several of you, kind enough to reply, that this is
folly and that I should really require that individual bits be statistically
independant of their input bit. This is equivalent to requiring that the
expected nuber of bits changed in the mapping x => T{x} is one half the 
number of bits in a byte or 4 in my case. This constraint, coupled with requiring
that 1's and 0's be equiprobable in each bit position, should insure the
"avalanche" property. I have hopes that such an algorithm would map a uniformlydistributed message process into a uniformly distributed output word when regarded as an unsigned number.
I


