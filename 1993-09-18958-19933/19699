Path: msuinfo!agate!howland.reston.ans.net!europa.eng.gtefsd.com!uunet!sunic!news.funet.fi!network.cc.jyu.fi!network.cc.jyu.fi!not-for-mail
From: paasivir@network.cc.jyu.fi (Risto Paasivirta)
Newsgroups: sci.crypt
Subject: Yet another home-brew cipher
Date: 25 Sep 1993 04:25:25 +0300
Organization: University of Jyvaskyla, Finland
Lines: 257
Distribution: world
Message-ID: <2806m5$h54@tukki.cc.jyu.fi>
NNTP-Posting-Host: tukki.jyu.fi


This took one day to write and I really haven't tested it much.
Comments? If it's secure enough, I may use it to encrypt game
high-score tables and such :-)

	Risto

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of shell archive."
# Contents:  mcrypt.c
# Wrapped by paasivir@tukki on Sat Sep 25 04:21:00 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f mcrypt.c -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"mcrypt.c\"
else
echo shar: Extracting \"mcrypt.c\" \(5680 characters\)
sed "s/^X//" >mcrypt.c <<'END_OF_mcrypt.c'
X/*
X * mcrypt.c -- V1.0 simple encryption algorithm/implementation.
X * Public domain, 1993 Risto Paasivirta, paasivir@jyu.fi
X * Block length 64 bits, variable key length and number of rounds.
X * This code is not optimized. No warranty, try with your own risk.
X */
X
Xtypedef unsigned char uchar;
X
X/* key length in bytes
X */
X#define KEYLEN 8
X
X/* rounds in block encryption = number of subkeys,
X * 4 minimum, should be even.
X */
X#define ROUNDS 4
X
X/* transform function rounds, enough? what happens with different key length?
X */
X#define TROUNDS 8
X
X/* key transform rounds. less may be enough
X */
X#define KROUNDS (ROUNDS * KEYLEN)
X
X/*
X * random substitution table (from RSA security Inc. MD2 message-digest
X * algorithm)
X */
X
Xstatic const uchar S[256] = {
X	 41, 46, 67,201,162,216,124,  1, 61, 54, 84,161,236,240,  6, 19,
X	 98,167,  5,243,192,199,115,140,152,147, 43,217,188, 76,130,202,
X	 30,155, 87, 60,253,212,224, 22,103, 66,111, 24,138, 23,229, 18,
X	190, 78,196,214,218,158,222, 73,160,251,245,142,187, 47,238,122,
X	169,104,121,145, 21,178,  7, 63,148,194, 16,137, 11, 34, 95, 33,
X	128,127, 93,154, 90,144, 50, 39, 53, 62,204,231,191,247,151,  3,
X	255, 25, 48,179, 72,165,181,209,215, 94,146, 42,172, 86,170,198,
X	 79,184, 56,210,150,164,125,182,118,252,107,226,156,116,  4,241,
X	 69,157,112, 89,100,113,135, 32,134, 91,207,101,230, 45,168,  2,
X	 27, 96, 37,173,174,176,185,246, 28, 70, 97,105, 52, 64,126, 15,
X	 85, 71,163, 35,221, 81,175, 58,195, 92,249,206,186,197,234, 38,
X	 44, 83, 13,110,133, 40,132,  9,211,223,205,244, 65,129, 77, 82,
X	106,220, 55,200,108,193,171,250, 36,225,123,  8, 12,189,177, 74,
X	120,136,149,139,227, 99,232,109,233,203,213,254, 59,  0, 29, 57,
X	242,239,183, 14,102, 88,208,228,166,119,114,248,235,117, 75, 10,
X	 49, 68, 80,180,143,237, 31, 26,219,153,141, 51,159, 17,131, 20,
X};
X
X/*
X * Append half block s and subkey k, do nonlinear thingamajim and
X * xor result to other half block b. Transform function I use here is
X * crippled version of md2 transform.
X */
X
Xstatic void
Xtransform(uchar b[4], uchar s[4], uchar k[KEYLEN])
X{
X	uchar d[4 + KEYLEN], i, j, t = 0;
X	for (i = 0; i < 4; i++) { /* append half block and subkey */ 
X		d[i] = s[i];
X	}
X	for (i = 0; i < KEYLEN; i++) {
X		d[4 + i] = k[i];
X	}
X        for (j = 0; j < (TROUNDS-1); j++) { /* this does it */
X		for (i = 0;i < (4 + KEYLEN);i++)
X			t = (d[i] ^= S[t]);
X		t += j;
X	}
X	for (i = 0; i < 4; i++) { /* final transform round */
X		b[i] ^= (t = d[i] ^ S[t]); 
X	}
X}
X
X/*
X * ecb_crypt(blk, ks, encrypt) -- en/decrypt one 64-bit block in
X * electronic code book mode.
X */
X
Xvoid
Xecb_crypt(uchar b[8], uchar ks[ROUNDS][KEYLEN], uchar enc)
X{
X	uchar i = 0, t;
X
X	while(1) {
X		/* encrypt left half block with right half block */
X		transform(b, 4 + b, ks[enc ? i : (ROUNDS-1) - i]);
X		if (++i == ROUNDS)
X			break;
X		/* swap halves */
X		t = b[0]; b[0] = b[4]; b[4] = t;
X		t = b[1]; b[1] = b[5]; b[5] = t;
X		t = b[2]; b[2] = b[6]; b[6] = t;
X		t = b[3]; b[3] = b[7]; b[7] = t;
X	}
X}
X
X/*
X * cbc_block(buf, iv, len, ks, encrypt) -- en/decrypt len-byte buffer in
X * cipher block chaining mode. Len must be multiple of 8 (if it is not
X * then len % 8 last bytes are ignered.) Returns final vector in iv.
X * For each 64-bit block in buf, when encrypting xor block with iv
X * encrypt block with ecb_encrypt() and copy encrypted block to iv;
X * when decrypting, save encrypted block as iv for next block, decrypt
X * block and xor decrypted block with old iv.
X * (XXX I haven't tested this yet...)
X */
X
Xvoid
Xcbc_crypt(uchar *b, uchar iv[8], int len, uchar ks[ROUNDS][KEYLEN], uchar enc)
X{
X	uchar i;
X	if (enc) {
X		while((len -= 8) >= 0) {
X			for (i=0;i<8;i++)
X				b[i] ^= iv[i];
X			ecb_crypt(b, ks, enc);
X			for (i = 0; i < 8; i++)
X				iv[i] = b[i];
X		}
X	} else {
X		while((len -= 8) >= 0) {
X			uchar t[8];
X			for (i = 0;i < 8; i++)
X				t[i] = b[i];
X			ecb_crypt(b, ks, enc);
X			for (i = 0; i < 8; i++) {
X				b[i] ^= iv[i];
X				iv[i] = t[i];
X			}
X		}
X	}
X}
X
X/*
X * set_key(ks, key) -- expand key to subkeys for each round
X * There are many ways to do this. This is one.
X */
X
Xvoid
Xset_key(uchar ks[ROUNDS][KEYLEN], uchar key[KEYLEN])
X{
X	uchar i, j, t = 0;
X	for (i = 0; i < KEYLEN; i++)
X		ks[0][i] = key[i];
X	for(;i < (ROUNDS * KEYLEN); i++)
X		ks[0][i] = 0; /* unneccessary obfuscated */
X	for (j = 0; j < KROUNDS; j++) {
X		for (i = 0; i < (ROUNDS * KEYLEN); i++)
X			t = (ks[0][i] ^= S[t]); /* does ks[1..] too */
X		t += i;
X	}
X}
X
X#ifdef TEST
X
X#include <stdio.h>
X#include <time.h>
X
Xvoid
Xhd(uchar *p, int i)
X{
X	while(i--) {
X		putc("0123456789ABCDEF"[*p >> 4], stdout);
X		putc("0123456789ABCDEF"[*p & 15], stdout);
X		p++;
X	}
X	putc('\n',stdout);
X}
X
Xmain()
X{
X	int i;
X	uchar b[8] = {1,2,3,4,5,6,7,8};
X	uchar *key = "0123456789abcdefghijklmnopqrstuvwxyz";
X	uchar ks[ROUNDS][KEYLEN];
X
X	time_t s;
X
X	printf("key:\n");
X	hd(key, KEYLEN);
X	printf("key schedule:\n");
X	set_key(ks, key);
X	for (i = 0; i < ROUNDS; i++)
X		hd(ks[i], KEYLEN);
X
X	printf("plain:\n");
X	hd(b,8);
X	printf("encip:\n");
X	ecb_crypt(b,ks,1);
X	hd(b,8);
X	printf("decip:\n");
X	ecb_crypt(b,ks,0);
X	hd(b,8);
X
X	printf("1000 key schedules...\n");
X	s = clock();
X	for (i = 0; i < 1000; i++)
X		set_key(ks, key);
X	s = (clock() - s) * 100 / CLOCKS_PER_SEC;
X	printf("took %d.%02ds\n", s / 100, s % 100);
X
X	printf("10000 block encrypt...\n");
X	s = clock();
X	for (i = 0; i < 10000; i++)
X		ecb_crypt(b, ks, 1);
X	s = (clock() - s) * 100 / CLOCKS_PER_SEC;
X	printf("took %d.%02ds, %d bytes/s\n", s / 100, s % 100, 8000000 / s);
X
X	printf("10000 block decrypt...\n");
X	s = clock();
X	for (i = 0; i < 10000; i++)
X		ecb_crypt(b, ks, 0);
X	s = (clock() - s) * 100 / CLOCKS_PER_SEC;
X	printf("took %d.%02ds, %d bytes/s\n", s / 100, s % 100, 8000000 / s);
X	
X	hd(b,8);
X	printf("done\n");
X}
X
X#endif
X
END_OF_mcrypt.c
if test 5680 -ne `wc -c <mcrypt.c`; then
    echo shar: \"mcrypt.c\" unpacked with wrong size!
fi
# end of overwriting check
fi
echo shar: End of shell archive.
exit 0
-- 
/*paasivir@jyu.fi*/int a[3302],b=3301,*c=a,d,e,f;main(){for(e=b;--e;*c++=1);*c
=2;for(d=2001;d--;printf("%05d",f))for(c=a,e=b;e;f/=e--){f+=*c*1e5;*c++=f%e;}}
