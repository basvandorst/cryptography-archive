Path: msuinfo!agate!howland.reston.ans.net!math.ohio-state.edu!cs.utexas.edu!uunet!vnet.IBM.COM
From: ameline@vnet.IBM.COM (Ian Ameline)
Message-ID: <19930910.130428.321@almaden.ibm.com>
Date: Fri, 10 Sep 93 16:03:38 EDT
Subject: Optimal Permutation algorithm
Newsgroups: sci.crypt
References: <1993Sep10.164522.12774@ast.saic.com>
Organization: C-Set++ Development, IBM Canada Lab.
Disclaimer: This posting represents the poster's views, not those of IBM
Lines: 86

In article <1993Sep10.164522.12774@ast.saic.com>,

   I'll put in instruction timings for the following:


agnew@actd.saic.com () writes:
>On an 80486 PC, the 32 bit shuffle takes only 11 instructions:
>
>    mov     cl,3               ; 1
>    rol     eax,cl             ; 3
>    bswap   eax                ; 1
>    rol     eax,cl             ; 3
>    bswap   eax                ; 1
>    mov     cl,5               ; 1
>    ror     eax,cl             ; 3
>    bswap   eax                ; 1
>    ror     eax,cl             ; 3
>                               ; Total = 17 clocks.

If you instead use :

     rol     eax, 3             ; 2  (Yes, using an immediate saves a
     bswap   eax                ; 1   clock)
     rol     eax, 3             ; 2
     bswap   eax                ; 1
     ror     eax, 5             ; 2
     bswap   eax                ; 1
     ror     eax, 5             ; 2
                                ; Total = 11 clocks. or 2.75 per byte.
                                ; some 10 times faster than the code
                                ; below.

>On the other hand, the 64 bit requires 96 instructions (6 instructions
>repeated 16 times):
>
>    .486
>
>bitscram    proc    near    ; 64 bit scramble of edx:eax
>                            ; destroys cl,ebx
>    mov     cl,8            ; do the left 8 times             ; 1
>rolloop:
>    mov     ebx,edx         ; the mov, shld, shld sequence    ; 1 * 8
>    shld    edx,eax,7       ; synthesizes a 64 bit rotate     ; 2 * 8
>    shld    eax,ebx,7       ; ror edx:eax,7                   ; 2 * 8
>    bswap   eax             ; the bswap, bswap, xchg sequence ; 1 * 8
>    bswap   edx             ; simulates a 64 bit bswap        ; 1 * 8
>    xchg    eax,edx         ; bswap edx:eax                   ; 3 * 8
>    dec     cl              ; for i in 1..8                   ; 1 * 8
>    jnz     short rolloop   ; loop                            ;(3 * 7)+1
>    mov     cl,8            ; do the right loop 8 times       ; 1
>rorloop:                                                      ;
>    mov     ebx,eax         ; ror edx:eax,2                   ; 1 * 8
>    shrd    eax,edx,2                                         ; 2 * 8
>    shrd    edx,ebx,2                                         ; 2 * 8
>    bswap   eax             ; bswap edx:eax                   ; 1 * 8
>    bswap   edx                                               ; 1 * 8
>    xchg    eax,edx                                           ; 3 * 8
>    dec     cl              ; for i in 1..8                   ; 1 * 8
>    jnz     short rorloop   ; loop                            ;(3 * 7)+1
>    mov     ebx,eax         ; ror edx:eax,4                   ; 1
>    shrd    eax,edx,4                                         ; 2
>    shrd    edx,ebx,4                                         ; 2
>    ret                                                       ; 3
>bitscram    endp                                              ;-------
>                                                 ;     Total = 230
>Can any one find a significantly shorter algorithm?
>

   Sorry -- I looked at it, and I don't see anything obvious as far as
486 instruction usage goes. It's costing you 28.75 clocks per byte.
So theoretically, on a 33.33 Mhz 486, assuming no pipeline stalls etc,
you'll get 1159420 bytes per second through this. Realistically speaking,
with cache misses, call overhead, IO overhead, you'll likely get
between 256K/sec and 512K/sec encryption rates. That's pretty fast.

   You could unroll the loops, and save 7.75 cycles per byte, bringing
the cost down to 21.0 cycles per byte -- a worthwhile savings -- about
36%. It looks like when unrolled, you can get rid of that XCHG instr
in there too -- saving another  2.625 cycles per byte -- Bringing the
time per byte down to 18.375. A total speed up of over 50%

You can send the cheque to me at Mail station 22, 844 Don Mills road,
North York, Ont, Canada. :-) A case of beer (not American) will do.

Regards,
Ian.
