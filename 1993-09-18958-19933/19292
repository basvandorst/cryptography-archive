Path: msuinfo!uwm.edu!math.ohio-state.edu!cs.utexas.edu!uunet!utcsri!eecg.toronto.edu!lewis
Newsgroups: sci.crypt
From: lewis@eecg.toronto.edu (david lewis)
Subject: Re: RSA hardware
Message-ID: <1993Sep14.121807.17541@jarvis.csri.toronto.edu>
Organization: CSRI, University of Toronto
References: <jkennedyCD3IAv.Ct@netcom.com> <CD7F8B.A43@fasttech.com> <1993Sep11.204313.24090@jarvis.csri.toronto.edu> <jkennedyCDB1EJ.Cu0@netcom.com>
Date: 14 Sep 93 16:18:07 GMT
Lines: 93

In article <jkennedyCDB1EJ.Cu0@netcom.com> jkennedy@netcom.com (John Kennedy) writes:
>In article <1993Sep11.204313.24090@jarvis.csri.toronto.edu> lewis@eecg.toronto.edu (david lewis) writes:
>>In article <CD7F8B.A43@fasttech.com> zeke@fasttech.com (Bohdan Tashchuk) writes:
>>>In <jkennedyCD3IAv.Ct@netcom.com> jkennedy@netcom.com (John Kennedy) writes:
>>>
>>>>For a 1028-bit modulus, a single exponentiation with randomly chosen operands
>>>>takes approximately 550 milliseconds when using a 12 MHz clock.  We do,
>>>>however, have parts that run up to 30 MHz if you're in a real hurry :-)
>>
>[miscellaneous stuff deleted]
>>
>>This is surprisingly slow for hardware. In the most recent IEEE Conf.
>>on Comp. Arith. a paper [1] described an implementation of RSA using FPGAs, with
>>performance of 600Kbits/sec. for 512 bit keys. Since FPGAs are slower than
>>snail snot in January, most of this impressive speed is due to clever
>>algorithms.  For pure software implementations, the author cited 30ms/block
>>on a R3000, and 9ms/block on a DEC alpha using the same algorithms for
>>1024 bit keys.
>>
>>Reference:
>>[1] M. Shand and J. Vuillemin, "Fast Implementations of RSA
>>Cryptography", Proc 11th Symp. on Comp. Arith, IEEE, July 1993
>>
>>David Lewis
>
>
>I haven't seen that paper yet, but I would like to point out a couple of
>things that may not be obvious:
>
>1. The calculation time I cited is for a^b mod c, where a, b, and c
>are randomly chosen 1028 bit numbers.  The operands do not have any
>particular structure and no precomputation is done.

The paper I cited is for a^b mod c for 512 operands, since they are concerned
with decoding and use Chinese remaindering. This accounts for a factor
of 4. The first 16 powers of a^i are computed by the hardware.

>
>2. The numbers you cited were for implementing RSA.  In the RSA cryptosystem
>the modulus used is bicomposite, i.e., the product of two primes.  This
>allows for the use of techniques such as the Chinese Remainder Theorem where
>we can do some precomputation with the prime factors to speed up the 
>encryption/decryption operations later on.

See above; they use Chinese.
>
>3. The other trick done with RSA is to use a short exponent such as 
>2^16 + 1 for one of the keys.  This does not weaken the system, but does
>allow for much faster processing in either the encrypt or decrypt direction.
>When spec'ing cryptosystems, always get the encrypt *and* the decrypt timings.
>For a digital signature system, I would also want to know the hashing time
>for various block sizes.

The times are for decoding, so this does not apply.

>
>4. NIST's Digital Signature Algorithm can also take advantage of precomputation
>and other mathematical time-savers.  Since prime moduli are used in the DSA,
>you can't use Chinese Remainder, however.  The same situation happens if
>you are doing a Diffie-Hellman key exchange: in general, you would be
>doing calculations using a randomly chosen, unstructured prime modulus.
>

I believe that the modulus can be specified dynamically in their system.

>5. There is a lot more to building cryptogear than beating speed records.
>There's that little gotcha called "cost" involved.  When building a chip,
>that cost is essentially proportional to the die size.  There are also
>costs associated with testing, board real estate, host processor support,
>external memory requirements, etc.  A board full of FPGA's is usually
>no bargain.  
>

Any number of FPGAs is no bargain! They are not only slow, but
ridiculously expensive compared to ASICs.

The authors evaluate the complexity of their system and claim
that a 100K gate ASIC would have 1MB/s throughput.


>6. In summary, be careful of comparing apples with oranges.
>

The only apple/orange factor that I can see is the use of Chinese
remainders, which accounts only for a factor of 4.


>
>-John Kennedy
>jkennedy@cylink.com

David Lewis
lewis@eecg.toronto.edu
