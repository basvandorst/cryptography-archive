Newsgroups: sci.crypt
Path: msuinfo!uwm.edu!cs.utexas.edu!uunet!seismo!esosun.css.gov!mvb.saic.com!ast.saic.com!actd!agnew
From: agnew@actd.saic.com ()
Subject: Home Brew Crypto
Message-ID: <1993Sep9.180028.15768@ast.saic.com>
Sender: news@ast.saic.com
Reply-To: agnew@actd.saic.com
Organization: Science Applications International Corporation
Date: Thu, 9 Sep 1993 18:00:28 GMT
Lines: 52


Like many people on this group, I have had to develop my own encryption
schemes, mainly because DES was too slow in software. I use my
algorithms for generating random vectors although they might be usefull
for security -- but then they might not :-( . The algorithm maps a 64
bit unsigned integer to a 64 bit unsigned integer using 512 bits of
key. Actually, it is an eight pass algorithm, simpler than DES, with 8
64 bit sub-keys. optimized for the 80486 and use the bswap instruction
to do a bit scramble in which each of the 8 output bytes receives a bit
from each of the eight input bytes. Because of the byte translation
that follows each permutation, it is unimportant what bit scramble is
used as long as it is invertible and that each output byte is a
function of each input byte. I use this latter property extensively and have
borrowed it from linear transform theory where it is known as the
"transform averaging property". I also use this property to develop a
"Fast Encryption Transform" much like Cooley-Tukey, but that is another
subject.

I have discovered several mappings of a 32 bit integer using 2
bits from each byte which use only 4 rotates and 4 bswaps. The shortest
I could find for 64 bits however was 8 passes of rotate right / bswap,
rotate left / bswap.  There are several right-left combinations which
work, I don't have them in front of me but I think it was right 5, left
3 and vice versa or was it r7,l2.  Anyway, I have one coded up in
assembler that works.

Each scramble is followed by eight table lookups using the xlate
instruction.  There are 8 tables of 256 bytes which are used over again
in each of the eight passes except that they are rotated right one byte
so that the same table is never used twice for the same byte. These
tables correspond to the infamous s-tables except that they were
generated manually and haphazardly from Rand's table of a million
random digits.  I further processed them "randomly" to decrease the
input/output correlation coefficient and increase the number of bit
differences. The only restriction on the table is that T(i) /= i.

The eight passes are identical except that a new 64 bit subkey is xor'd
with the input word at the begining of each pass. The inverse algorithm
simply translates each byte by the inverse table and then does an
inverse scramble by replacing rotate rights with rotate lefts and
reversing the order. The pass subkey is then xor'd with the result. I
have both the assembler code and the Meridian Ada which drives them and
would be glad to post it here. The bottom line is that a 64 bit
encryption with a 512 bit key takes about 2.5 microseconds on a
household 80486 PC at 33Mhz. A fully parallel hardware implementation
using eight sets of (possibly distinct) table flash-Roms could easily
encrypt/decrypt a 64 bit word in 50 nanoseconds and perhaps less. This
is a througput of 1.28 gigabits!

How do I go about testing this algorithm? How does one perform
differential cryptoanalysis on it?  

