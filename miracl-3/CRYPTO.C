/*   Copyright (c) 1988-1993 Shamus Software Ltd. */

/* uses IDEA algorithm invented by Xuejia Lia and James Massey   *
 * See "Markov Ciphers and Differential Cryptanalysis", Advances *
 * in Cryptology 1991, EuroCrypt '91, Springer-Verlag. Also uses *
 * novel CBC-X General Block Cipher Chaining method invented by  *
 * Yours Truly - denies any Known Plaintext attack. Basically :- *

  P  = Plaintext
  C  = Ciphertext
  F  = FeedForward vector - Random Initial value 
  B  = FeedBack vector    - Random Initial value
  Ek = Encryption with key k  

  To encrypt:

  T = P Xor B
  B = Ek[T]
  C = B Xor F
  F = T

*/

#include <stdio.h>
#include <stdlib.h>
#include <mirdef.h>

#define MAXIM 65537L
#define ROUNDS 8
#define KEYSIZE 6*ROUNDS+4
#define ASM _asm

typedef unsigned short word;
typedef int bool;

static bool started=0;
static word EK[KEYSIZE],DK[KEYSIZE];
static char EPchain[8],DPchain[8],ECchain[8],DCchain[8];

static void xlat(ibuff,obuff,len)
char *ibuff,*obuff;
int len;
{ /* translate a character buffer to a word buffer  *
   * and visa versa in a portable fashion           */
    int i;
#ifdef LITTLE_ENDIAN
    for (i=0;i<len;i++) obuff[i]=ibuff[i];
#else
    swab(ibuff,obuff,len);
#endif
}

static word inv(word xin)
{ /* multiplicative inverse by GCD algorithm */ 
    long n1,n2,q,r,b1,b2,t;
    if (xin==0) b2=0L;
    else
    {
        n1=MAXIM; n2=xin; b2=1L; b1=0L;
        do
        {  r=(n1%n2); q=(n1-r)/n2;
           if (r==0L) { if (b2<0L) b2=MAXIM+b2; }
           else {n1=n2;n2=r;t=b2;b2=b1-q*b2;b1=t; }
        } while (r!=0L);
    }
    return (word)b2;
}

static void ideakey(char uskey[],word EK[],word DK[])
{ /* generate expanded keys */
    int i,j;
    register word *sptr=EK;
    xlat(uskey,(char *)EK,16);
    for (i=8;i<KEYSIZE;i++) 
    { /* generate expanded encrypting key */
        if ((i+2)%8 == 0)
            EK[i]=(EK[i-7]<<9)^(EK[i-14]>>7);
        else if ((i+1)%8==0)
            EK[i]=(EK[i-15]<<9)^(EK[i-14]>>7);
        else
            EK[i]=(EK[i-7]<<9)^(EK[i-6]>>7);
    }
    if (DK==NULL) return;
    for (j=0;j<=ROUNDS;j++)
    { /* now generate inverse decrypting key */
        i=6*(ROUNDS-j);
        DK[i]=inv(*sptr++);
        if (j==0 || j==ROUNDS)
        { 
           DK[i+1]=(-*sptr++);
           DK[i+2]=(-*sptr++);
        }
        else
        {
           DK[i+2]=(-*sptr++);
           DK[i+1]=(-*sptr++);
        }
        DK[i+3]=inv(*sptr++);
        if (j<ROUNDS)
        {
            DK[i-2]=*sptr++; 
            DK[i-1]=*sptr++;
        }
    }
}

static word mul(word a,word b)
{ /* returns a*b mod 65537 */
    word areg;
    if (a==0) 
    {
        ASM mov ax,b
        ASM neg ax
        ASM inc ax
        ASM mov areg,ax
        return areg;
    }
    if (b==0)
    {
        ASM mov ax,a
        ASM neg ax
        ASM inc ax
        ASM mov areg,ax
        return areg;
    }
    ASM mov ax,a
    ASM mul b
    ASM sub ax,dx
    ASM ja over
    ASM inc ax
over: 
    ASM mov areg,ax
    return areg;
}

static char h(char a,char b)
{ /* returns a*b mod 257 - used to frustrate Differential attack */
    char areg;
    if (a==0)
    {
        ASM mov al,b
        ASM neg al
        ASM inc al
        ASM mov areg,al
        return areg;
    }
    if (b==0)
    {
        ASM mov al,a
        ASM neg al
        ASM inc al
        ASM mov areg,al
        return areg;
    }
    ASM mov al,a
    ASM mul BYTE PTR b
    ASM sub al,ah
    ASM ja over
    ASM inc al
over:
    ASM mov areg,al
    return areg;
}

static void cip(register word *sptr,char *cblock)
{ /* main encrypt/decrypt process */
    int r;
    word x1,x2,x3,x4,t;
    word block[4];
    register word a;
    xlat(cblock,(char *)block,8);
    x1=block[0]; x2=block[1]; x3=block[2]; x4=block[3];
    for (r=0;r<ROUNDS;r++)
    { /* main loop */
        x1=mul(x1,*sptr++);
        x2=(x2+*sptr++);
        x3=(x3+*sptr++);
        x4=mul(x4,*sptr++);
        a=mul(*sptr++,(x1^x3));
        t=mul(*sptr++,(a+(x2^x4)));
        a+=t;  x1^=t;   x4^=a; 
        a^=x2; x2=x3^t; x3=a;
    }
    block[0]=mul(x1,*sptr++);
    block[1]=(x3+*sptr++);
    block[2]=(x2+*sptr++);
    block[3]=mul(x4,*sptr++);
    xlat((char *)block,cblock,8);
}

void set_pad(key1,key2,mode)
char key1[32],key2[32];
int mode;
{ /* initialise block encryption, using 64 bytes (512 bits) *
   * of key generated by key-exchange algorithm             */
    int i;
    if (mode>1)
    {
        ideakey(key1,EK,DK);
        ideakey(key2,EK,NULL);
        for (i=0;i<8;i++) 
        { /* initialise feed-forward/back vectors */
            EPchain[i]=key1[16+i];
            DPchain[i]=key2[16+i];
            ECchain[i]=key1[24+i];
            DCchain[i]=key2[24+i];
        }
    }
    else
    { 
        ideakey(key2,EK,DK);
        ideakey(key1,EK,NULL);
        for (i=0;i<8;i++) 
        {
            EPchain[i]=key2[16+i];
            DPchain[i]=key1[16+i];
            ECchain[i]=key2[24+i];
            DCchain[i]=key1[24+i];
        }
    }
    for (i=0;i<24;i++) key1[i]=key2[i]=0;
    started=1;
}

void end_pad()
{ /* finish pad */
    int i;
    started=0;
    for (i=0;i<KEYSIZE;i++) EK[i]=DK[i]=0;
    for (i=0;i<8;i++) EPchain[i]=DPchain[i]=ECchain[i]=DCchain[i]=0;
}

int encode(ibuff,len,obuff)
char *ibuff,*obuff;
int len;
{ /* encode data */
    int i,j,k;
    char block[8],hold[8];
    if (!started) 
    { /* pass data straight through */
        for (i=0;i<len;i++) obuff[i]=ibuff[i];
        return len;
    }
    for(i=0,j=0;i<len;)
    { /* encipher in blocks of 8 bytes */
        for (k=0;k<8 && i<len;k++,i++) 
            hold[k]=block[k]=(ibuff[i]^h(EPchain[k],ECchain[k]));
        if (k<8)
        { /* pad out with random data */
            get_rand(&block[k],8-k);
            for (;k<8;k++) 
                hold[k]=block[k]=(block[k]^h(EPchain[k],ECchain[k]));
        }
        cip(EK,block); 
        for (k=0;k<8;k++,j++) 
        { /* calculate feed-forward function */
            ECchain[k]=block[k];
            obuff[j]=block[k]^EPchain[k];
            EPchain[k]=hold[k];
            block[k]=hold[k]=0;
        }
    }
    return j;
}

void decode(ibuff,len,obuff)
char *ibuff,*obuff;
int len;
{ /* decode data - len must be multiple of 8 */
    int i,j,k;
    char block[8],hold[8];
    if (!started) 
    { /* pass data straight through */
        for (i=0;i<len;i++) obuff[i]=ibuff[i];
        return;
    }
    for(i=0,j=0;i<len;)
    { /* decipher in blocks of 8 */
        for (k=0;k<8 && i<len;k++,i++) 
            hold[k]=block[k]=ibuff[i]^DPchain[k];
        cip(DK,block); 
        for (k=0;k<8;k++,j++) 
        {
            obuff[j]=(block[k]^h(DPchain[k],DCchain[k]));
            DPchain[k]=block[k];
            DCchain[k]=hold[k];
            block[k]=hold[k]=0;
        }
    }
    return;
}

