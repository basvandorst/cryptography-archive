Xref: msuinfo comp.lang.c:49285 comp.os.msdos.programmer:12019 sci.crypt:7644
Path: msuinfo!caen!spool.mu.edu!wupost!darwin.sura.net!convex!seas.smu.edu!utacfd.uta.edu!trsvax!rwsys!sneaky!gordon
From: gordon@sneaky.lonestar.org (Gordon Burditt)
Newsgroups: comp.lang.c,comp.os.msdos.programmer,sci.crypt
Subject: Re: "Hiding" variables in C
Message-ID: <1992Mar11.223257.6422@sneaky.lonestar.org>
Date: 11 Mar 92 22:32:57 GMT
Article-I.D.: sneaky.1992Mar11.223257.6422
References: <1992Mar06.191513.41268@yuma.acns.colostate.edu> <1992Mar9.014950.12741@sneaky.lonestar.org> <1992Mar9.190946.28468@cl.cam.ac.uk>
Organization: Gordon Burditt
Lines: 41

>> If the disassembler hits an unconditional branch or part of the code that 
>> it's followed before, it stops following that path and starts on the
>next one.
>> When it runs out of branches, it's done.
>
>Surely this can be defeated by making the search space too big. If you believe
>that 2^60 is searchable, 70 suitable conditional jumps should do the trick.

The disassembler I proposed (and actually implemented for a z80) doesn't try 
to trace all possible sequences of execution.  It tries to identify all parts 
of the program that are executed as code by tracing code paths.  A conditional 
branch doesn't double the search space, it adds one instruction.  The 
disassembler isn't supposed to trace any code path more than once.

You could fool the disassembler into presenting data as instructions with
a code sequence like:

	subtract	r1,r1	; make sure condition code Z is set
	jumpifz		code
	... bunch of data ...

provided the disassembler isn't tracking the possible states of the
condition codes.  An even worse way of fooling it is to compute a branch
address by a complicated formula and then use it.  But merely fooling the
disassembler into presenting the code in the wrong format won't help if
the human reading the code realizes that the code is being used as data
or is being modified.  The disassembler can pick up on direct references
to the code in question provided that the direct references are in a
section identified as code.

A LOTS nastier way is to decrypt code and then use it.  However, remember
that if you do all your checking up front, and then let the program run,
that the program could be cracked by saving the entire machine state
at some time after the decrypting is done, and writing a program which
will set up that state and then let it run.  With such techniques as
running a virtual 8086 inside an 80386, or using hardware breakpoint
features of the 80386, you don't have to plant software breakpoints
that are visible to the running program.

					Gordon L. Burditt
					sneaky.lonestar.org!gordon
