Path: msuinfo!caen!spool.mu.edu!wupost!waikato.ac.nz!aukuni.ac.nz!mercury!nacjack!peter
From: pgut1@cs.aukuni.ac.nz (Peter Gutmann)
Newsgroups: sci.crypt
Subject: NSEA encryption algorithm (long)
Message-ID: <16fcf193@nacjack.gen.nz>
Date: 20 Mar 92 09:40:35 GMT
Article-I.D.: nacjack.16fcf193
Reply-To: pgut1@cs.aukuni.ac.nz
Organization: Malleus Maleficarum - Nil Mortifi Since Lucre
Lines: 1156

Peter Gutmann's Happy House Of Fun (tm)
This is a description of an encryption algorithm I've cooked up which (for
various reasons explained later) I've called NSEA.  It came to me about a year
ago as I was looking at how CRC's are calculated by table lookup.  If this
method is combined with the mechanism used by the DES (where the data is broken
into two halves and each half alternately used to encrypt the other half) this
makes a simple and fast encryption algorithm.

Derivation of the algorithm:
----------------------------

The standard way of calculating a CRC by table lookup works as follows:  For
every byte of data do:

  crc = crcTable[ ( BYTE ) crc ^ data ] ^ ( crc >> 8 );

At the end of this process we have a (hopefully unique) crc value based on
every byte of the data.  Normally the crcTable is set up using some standard
algorithm, however if we change the way the table is set up based on a
user-supplied key, the final crc value will again be (hopefully unique) based
on the initial key.  This can be used as the basis for an encryption
algorithm.  Consider initially the DES algorithm....

Two rounds of the std.DES algorithm are shown in the following diagram.  L and
R are the left and right halves of each 64-bit input block, K0...K16 are the 16
keys from the key schedule calculation, and f() is the DES f-function (the one
involving the complex mungeing of data through S-boxes which makes the
algorithm so slow when implemented in software).  The values next to each data
path are the number of bits used, and (+) is the XOR function:

    +-------------------+        +-------------------+
    |         L0        |   K0   |         R0        |
    +-------------------+   |    +-------------------+
              |32           |48            |32
              v             v       32     v
             (+)<----------f()<------------|
              |                            |
              \------------\ /-------------/
                            X
              /------------/ \-------------\
              |32                          |32
              v                            v
    +-------------------+        +-------------------+
    |      L1 = R0      |   K1   | R1 = L0 ^ f(R0,K0)|
    +-------------------+   |    +-------------------+
              |32           |48            |32
              v             v       32     v
             (+)<----------f()<------------|
              |                            |
              \------------\ /-------------/
                            X
              /------------/ \-------------\
              |32                          |32
              v                            v
    +-------------------+        +-------------------+
    |      L2 = R1      |        | R2 = L1 ^ f(R1,K1)|
    +-------------------+        +-------------------+

This can be 'unwound' (at the expense of making the labels a bit confusing) to
give:

    +-------------------+        +-------------------+
    |         L0        |  K0    |         R0        |
    +-------------------+   |    +-------------------+
              |32           |48            |32
              v             v       32     v
             (+)<----------f()<------------|
              |                            |
              v                            v
    +-------------------+        +-------------------+
    | R1 = L0 ^ f(R0,K0)|  K1    |      L1 = R0      |
    +-------------------+   |    +-------------------+
              |32           |48            |32
              v             v       32     v
              |------------f()----------->(+)
              |                            |
              v                            v
    +-------------------+        +-------------------+
    |      L2 = R1      |        | R2 = L1 ^ f(R1,K1)|
    +-------------------+        +-------------------+

In comparison, the algorithm NSEA uses is as follows:

    +-------------------+        +-------------------+
    |         L0        |        |         R0        |
    +-------------------+        +-------------------+
              |64                          |64
              v      64             8      v
             (+)<----------f()<------------|
              |                            |
              v                            v
    +-------------------+        +-------------------+
    |  L1 = L0 ^ f(R0)  |        |   R1 = R0 rol 8   |
    +-------------------+        +-------------------+
              |64                          |64
              v      8             64      v
              |------------f()----------->(+)
              |                            |
              v                            v
    +-------------------+        +-------------------+
    |   L2 = L1 rol 8   |        |  R2 = R1 ^ f(L1)  |
    +-------------------+        +-------------------+

Since only 8 bits of each block are input to the f-function, NSEA needs to run
for ( blockSize / 8 ) rounds to process a single block.  The key input K in the
DES algorithm is implicit in the f-function, which is simply a lookup table
with 256 64-bit values which are set up in a key-dependant manner as described
below.  Instead of shifts like the crc method uses we use rotates since we
can't afford to keep losing 8 bits of data in every round.

Outline:
--------

First standard S-boxes are set up using an LFSR random-number generator to
ensure they are always identical initially.  Then the key, which can be any
length (not just 56 bits like one well-known algorithm), is encrypted to give
256 blocks of random (but based on the key used) data.  The S-boxes are then
re-initialized using this key.  This is the initial phase of the encryption.

Encryption works a bit like it does in DES, by breaking the data block into two
halves and alternately encrypting the left and right sides.  After each
encryption operation the data halves are rotated by 8 bits to shift a new byte
into position for the next S-box lookup.  Decryption is simply the reverse of
this.

When used to encrypt files, the algorithm is run in CFB mode.  The IV is set to
the first 128 bits of key, encrypted with the S-boxes generated from this key.
The rest of the code implements a fairly conventional CFB encryption program.

Extending the algorithm:
------------------------

There are several ways to extend the algorithm, among them being the use of
multiple sets of S-boxes for different rounds of the encryption, and the
constant updating of S-boxes as encryption progresses (so they never remain
constant as they do at the moment).  The former requires largeish amounts of
memory, the latter largeish amounts of time, and I'm not whether they're worth
bothering with.

It's advantages over the DES are:

  - No limit on key length (the basic version has a 2K limit, with multiple
    sets of S-boxes this can be extended).
  - Easy to implement
  - FAST!
  - 128-bit block size
  - Can easily be extended to give more security
  - Comes from outside the US, so not subject to export restrictions
  - Like Ralph Merkle's Khufu, it spends a lot of time setting up its initial 
    S-boxes, which (along with the 128-bit block size) makes brute-force 
    attacks difficult.

It's disadvantages over the DES are:

  - Hasn't been subject to intense scrutiny for 15 years and may have security
    holes in it big enough to drive a bus through.

Speed:
------

This (pretty non-optimal) version when compiled with -DTIME_TRIAL using a
highly pessimizing compiler ran at just under 50K/s on a 386/25 - an
assembly-language version would probably manage one or two hundred K/s on the
same system (in comparison a highly optimized assembly-language DES
implementation (written in Moscow:-) ran at around 30K/s on the same machine).

The key setup is quite slow - the same nonoptimized version as above takes 80ms
to set up one set of S-boxes from an initial key.  Allowing for an
order-of-magnitude speedup for an assembly-language implementation (or a better
CPU:-), this allows a brute-force attack on the encryption key of about 125
attempts a second.  Thus all worst-case keys (6 chars, lowercase letters only)
could be tried by brute force in about 28 days.  Raising the minimum key length
to encourage the use of phrases as keys rather than individual words increases
this time greatly (as well as making the work of smart dictionary crackers
difficult, since the dictionary used would have to contain complete phrases,
not just individual words).  Certainly 28 days is too short - your average
group of workstations could brute-force the key in hours or even minutes.
Similarly, relying on the slow key setup for security may be dangerous - look
at what happened with the password security of a certain OS which relied on the
slow running of the DES algorithm on a PDP-11.  On the other hand virtually all
amateur cracking attempts will be along the lines of a brute-force attempt, so
an algorithm which pessimizes performance for this form of attack is a step in
the right direction.

Now what?:
----------

I'm releasing this code into the public domain - do whatever you want with it.
Since it comes from outside the US there aren't any silly restrictions on it,
so anyone should be able to use it.

For some reason it's become known as "Nonpatented Simple Encryption Algorithm"
(NSEA) - it pretty well sums up its main features :-).

As it stands the code can be used to build three seperate programs:

-DTEST_VERSION      will create an executable which generates a series of test
                    values running NSEA in CBC mode.
-DTIME_TRIAL        will create an executable which encrypts 1MB of data in CFB
                    mode for timing purposes.
-DSETUP_TRIAL       will create an executable which performs 1000 key setups
                    for timing purposes to evaluate brute-force cracking
                    attempts.
Straight compile    will create a simple file en/decryption program which uses
                    NSEA in CFB mode.

Finally, if anyone uses this algorithm for anything or knows of any way to
improve it I'd be interested to hear from them.

Test data:
----------

The following output was obtained when running NSEA in CBC mode using
-DTEST_VERSION:

Key 00000000000000000000000000000000, data 00000000000000000000000000000000:
    7D24D35461B1D0405E085BF9E3AC4FCF 545902785117455B7986ED34293079FC
    80992F7183A91F891EBD96BA9E2E4937 06B4AAABD8ECE1487E71BBFCC2D139AE

Key FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF, data FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF:
    4CF71049033FF0969A174E986AC34D05 BA38DD373D2864BE4DC5288DB650C329
    C5E30ECD503342DE94E94E312F593EB3 31014272B1B39CA8951D4B500605CA28

Key 00000000000000000000000000000001, data 00000000000000000000000000000000:
    59095A0B89B91B0F04B503B6BC7CD25F 4ADE97740C56433C4AE61C7E9428BD5F
    FB9EC5BA257F68C1B7777584610BCB97 B0832E27C027CFFD8F3FE7F5061F1C85

Key 00000000000000000000000000000000, data 00000000000000000000000000000001:
    C39E7121BF1D0EB7D231DDA3408A0C66 2E684DA42AEE37FC605A6F17E5DE4215
    E8F46D29ADBD742A454C1705B9029BE9 28470C60C10B0DCA8C4A0D0D1BDFE61E

Key 80000000000000000000000000000000, data 00000000000000000000000000000000:
    3E67BBC5C4D961E2481FB424480692ED 573F78F6DF656DCD6DB509D5D2E564D0
    FF5A73803D0774709C184A758ECAC01E 170F829E53409D8D33842115B8955126

Key 00000000000000000000000000000000, data 80000000000000000000000000000000:
    8CCDD2CFE82EFC8C307AC585B8827F9C 9B8955401B1A2930FD4BB664CF677238
    D25BB609D48DB10FC6B2B63EA1A6CD72 F249149E1AA489ADCBAB2219DAB6E05B

Key FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF, data 00000000000000000000000000000000:
    D072EA8B2CD4E67D784C92625544A389 7BE2A44CAFD7D1E40BDF820C5EACFDEF
    FED5B9C1F1E67CDC788A9596A4E5D30C 836AD5C0EF1DC8EE0B0C5D8EAA25DBD3

Key 00000000000000000000000000000000, data FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF:
    485C0937944654930C80A8AF88D5E136 CC2451F04836778D726EFF133F6ECCDA
    F097488F6316651E819F3BFFD3A379A3 9E387DE07CA9420D16F6232CDC124744

Key FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF, data 00000000000000000000000000000001:
    A12B2E0A6B564D0EAFC8DA0A0DF835EF 6E2790CC4F966096C842755B9685F369
    BCD32A32BAF6CE7551ABD23C8CB878E2 580FE0EA014284C542D5A3268E044358

Key 00000000000000000000000000000001, data FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF:
    560CAC30775F44C33850A8350E6B40DD 127680B1653AB12D7053D3770D1AA9D5
    80411DEBC592C4D0B39C951A38FED086 BEBE96B3DD94681D32954C50D47367FA

Key 01010101010101010101010101010101, data 01010101010101010101010101010101:
    E206781661B52A0AD4826D9962BD174D 32BDE1A42C3482936C063896F9731606
    D0B5ED72FF8029464710F4685D1F6BF2 54E10023401F21DA76AE66DE45203FB6

Key 80808080808080808080808080808080, data 80808080808080808080808080808080:
    0525F6DC78D1985A8A4146F17B913BF9 6668002E684124C13969573465C4EBD3
    568F9142BA46E7B2A906E40966DBF1F2 A95F283DCD91A2F589A6A75AAF497801

Key 0123456789ABCDEFFEDCBA9876543210, data 0123456789ABCDEFFEDCBA9876543210:
    F147B3D620023D404D245EE3C60868F7 433280D57C29F1BC08C7124D10B46A36
    0F78420F0B8FC878A896203E4A496D77 C7F97F433D26981A3EFDA613A47DD198

Key FEDCBA98765432100123456789ABCDEF, data FEDCBA98765432100123456789ABCDEF:
    A3BE92817E3F5698E449B03168C786C1 0ED27EA2B58A2A33662C1FAE876BA739
    BDB09D6753AD8EED73AE7B4F6D8B11ED 36216439D5B801168A57FE0ED5305063

NSEA source code:
-----------------

/* Compile options:

   -DTEST_VERSION compiles the test version, which encrypts sample data/keys.
   -DTIME_TRIAL compiles a version which encrypts 1MB of data in CFB mode for
                timing tests.
   -DSETUP_TRIAL compiles a version which performs the password/S-box setup
                 repeatedly for brute-force crack timing tests.
   -DSHOW_SBOXES displays the S-Boxes for each key */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

/* The following are system-dependant: Unsigned 8, 16, 32-bit quantities.*/

typedef unsigned char       BYTE;
typedef unsigned short      WORD;
typedef unsigned long       LONG;

/* Useful defines */

#define ERROR   -1

/* The block size (in bytes).  Use 8 bytes for a DES-a-like (64 bits),
   16 or 32 bytes for better security (128 bits) */

#define BLOCKSIZE   16

/* Prototypes for the CBC encryption/decryption routines */

void encrypt( BYTE *inData, BYTE *outData );
void decrypt( BYTE *inData, BYTE *outData );

/* Prototypes for the CFB encryption/decryption routines */

void initCFB( const char *key );
void encryptCFB( BYTE *buffer, int count );
void decryptCFB( BYTE *buffer, int count );

/* The S-Boxes used for encryption */

#define SBOX_SIZE       ( 256 * sizeof( LONG ) )    /* 256 LONG's per S-Box */

#define SBOX_SHIFT  2   /* The amount to shift a byte index by to get the
                           basic machine word size of 32 bits */

LONG *sBoxes1, *sBoxes2;    /* The S-Boxes themselves */
BYTE *tempKey;              /* The temporary key used to set up the S-Boxes */

/* Macros to handle rotation of 64-bit quantities */

LONG rotTemp;       /* Temporary value for rotations */

#define rotl(A,B)   rotTemp = A >> 24; \
                    A = ( A << 8 ) | ( B >> 24 ); \
                    B = ( B << 8 ) | rotTemp;
#define rotr(A,B)   rotTemp = B << 24; \
                    B = ( B >> 8 ) | ( A << 24 ); \
                    A = ( A >> 8 ) | rotTemp;

/* Define the following for CBC mode.  Note that CBC should not be defined
   if CFB mode is being used since the CFB encryption works as:

   buffer ^= e( CFB-iv ), CFB-iv = buffer

   which means that the CBC-iv's are simply the unencrypted buffer xor'd
   with the previous contents of the encrypted buffer.  When there are
   repeated blocks of data and the two are xor'd as part of the CBC process
   the original plaintext is recovered... */

#ifdef TEST_VERSION
  #define CBC
#endif /* TEST_VERSION */

/* The value used for cipher block chaining (since we are overlapping
   encrypts and decrypts we need two left and right values, one for
   encryption and one for decryption; in practice only one set of values
   is necessary) */

#ifdef CBC
  static LONG ivLLeft1, ivRLeft1, ivLRight1, ivRRight1;
  static LONG ivLLeft2, ivRLeft2, ivLRight2, ivRRight2;
#endif /* CBC */

/* The encryption password */

#define MAX_KEYLENGTH   64      /* Any reasonable value will do */

/* Information needed in CFB mode:  The IV, the encrypted IV, and the count
   of bytes already processed in the current block */

BYTE iv[ BLOCKSIZE ];           /* CFB initialization vector */
BYTE temp[ BLOCKSIZE ];         /* Encrypted IV */
int ivCount;                    /* Count of bytes used in block */

/* Define the following to perform two rounds of encryption for each data
   block.  This may be desirable since for one-round encryption each step of
   the process is affected by a single byte of plaintext, so it would be
   possible to work backwards from the last byte of plaintext encrypted to
   reverse-engineer the contents of the S-Boxes.

   A further enhancement to this scheme is to use multiple sets of S-Boxes,
   one set for each round of encryption (you could go to three, four, five
   etc rounds) */

#define TWO_ROUNDS

/****************************************************************************
*                                                                           *
*               NSEA Key Generation and Encryption Routines                 *
*                                                                           *
****************************************************************************/

/* The initial, standardised S-boxes are generated using a linear feedback
   shift register (LFSR).  These can be set to any pseudorandom value, as
   long as they are always the same.  An LFSR is used since it's convenient.

   From the standard set of S-boxes, a new set is generated with a far better
   pseudo-random number generator, namely NSEA encrypting the encryption key
   using the initial S-boxes.  The output from the NSEA pseudo-random number
   generator is then used to build a new set of S-boxes which are dependant
   on the encryption key used.  These replace first set as the working
   S-boxes

   This method of key setup makes encryption fast and brute-force attacks
   slow and painful.  Once the S-boxes are set up, en/decryption proceeds at
   a fairly rapid pace, however if the key is changed constantly (as it
   would be for a brute-force attack) a lot of time is spent in rebuilding
   the S-boxes after each key change.  The key setup has in fact been
   pessimized to perform badly even on high-performance systems, since it is
   non-parallelizable (each S-box permutation operation depends on all
   preceding permutation operations), and due to the constant memory
   accesses as the S-boxes are set up will run slowly even on normally fast
   RISC systems.

   When we generate random data by encrypting the key, we append a '\0' to
   the end every time we restart from the beginning to make sure the
   algorithm is also sensitive to the length of the key (otherwise for
   example the key "abc" would generate the same S-boxes as the key
   "abcabc") */

#ifdef SHOW_SBOXES

/* Show the S-Boxes */

static void showSBoxes( void )
    {
    int i, j;

    putchar( '\n' );
    for( i = 0; i < 64; i++ )
        {
        for( j = 0; j < 4; j++ )
            printf( "%08lX%08lX ", \
                    sBoxes1[ ( i * 4 ) + j ], sBoxes2[ ( i * 4 ) + j ] );
        putchar( '\n' );
        }
    }

#endif /* SHOW_SBOXES */

/* Set up the S-Boxes */

static WORD rnd( void )
    {
    static WORD number = 4027;  /* The sequence will gum up on 0 */

    if( ( ( number & 0x0001 ) << 1 ) ^ ( number & 0x0002 ) )
        number |= 0x8000;
    number >>= 1;
    number &= 0x7FFF;
    return( number );
    }

/* Set up initial S-Box to be n columns of 0..255 */

static void setInitialSBox( BYTE *sBox )
    {
    int i, j, index = 0;

    for( i = 0; i < 256; i++ )
        for( j = 0; j < sizeof( LONG ); j++ )
            {
            sBox[ index ] = ( LONG ) i;
            index++;
            }
    }

/* Permute an sBox based on the values in tempKey */

static void permuteSBox( BYTE *sBox, int tempKeyIndex )
    {
    int i, j;
    int srcIndex, destIndex;
    BYTE temp;

    for( i = 0; i < sizeof( LONG ); i++ )
        for( j = 0; j < 256; j++ )
            {
            srcIndex = ( j << SBOX_SHIFT ) + i;
            destIndex = ( tempKey[ tempKeyIndex++ ] << SBOX_SHIFT ) + i;

            temp = sBox[ srcIndex ];
            sBox[ srcIndex ] = sBox[ destIndex ];
            sBox[ destIndex ] = temp;
            }
    }

static void initSBoxes( const char *key )
    {
    BYTE *sBoxByte1 = ( BYTE * ) sBoxes1, *sBoxByte2 = ( BYTE * ) sBoxes2;
    int i, keyLength, index = 0;
#ifdef CBC
    int blockIndex;
    BYTE data[ BLOCKSIZE ];
#endif /* CBC */

    /* Set up initial sBoxes */
    setInitialSBox( sBoxByte1 );
    setInitialSBox( sBoxByte2 );

    /* Permute the S-Boxes in a pseudo-random manner */
    for( i = 0; i < SBOX_SIZE * 2; i++ )
        tempKey[ i ] = ( BYTE ) rnd();
    permuteSBox( sBoxByte1, 0 );
    permuteSBox( sBoxByte2, SBOX_SIZE );

#ifdef SHOW_SBOXES
    showSBoxes();
#endif /* SHOW_SBOXES */

    /* Encrypt the key using the standard S-Boxes */
    index = 0;
#ifdef TEST_VERSION
    keyLength = BLOCKSIZE;
#else
    keyLength = strlen( key );
#endif /* TEST_VERSION */
#ifdef CBC
    ivLLeft1 = ivRLeft1 = ivLRight1 = ivRRight1 = 0L;
    for( i = 0; i < 256 * sizeof( LONG ) * 2; i += BLOCKSIZE )
        {
        /* Extract BLOCKSIZE bytes of plaintext from the key and
           encrypt them */
        for( blockIndex = 0; blockIndex < BLOCKSIZE; blockIndex++ )
            if( index == keyLength )
                {
                data[ blockIndex ] = '\0';
                index = 0;
                }
            else
                data[ blockIndex ] = key[ index++ ];
        encrypt( data, tempKey + i );
        }
#else
    initCFB( key );
    for( i = 0; i < 256 * sizeof( LONG ) * 2; i++ )
        if( index == keyLength )
            {
            tempKey[ i ] = '\0';
            index = 0;
            }
        else
            tempKey[ i ] = key[ index++ ];
    encryptCFB( tempKey, 256 * sizeof( LONG ) * 2 );
#endif /* CBC */

    /* Reset the initial sBoxes */
    setInitialSBox( sBoxByte1 );
    setInitialSBox( sBoxByte2 );

    /* Permute the sBoxes using the encrypted key as our source of random numbers */
    permuteSBox( sBoxByte1, 0 );
    permuteSBox( sBoxByte2, SBOX_SIZE );

#ifdef SHOW_SBOXES
    showSBoxes();
#endif /* SHOW_SBOXES */
    }

/* Initialise the encryption system */

void initCrypt( void )
    {
    /* Allocate the S-Boxes and temporary key space */
    if( ( sBoxes1 = ( LONG * ) malloc( SBOX_SIZE ) ) == NULL || \
        ( sBoxes2 = ( LONG * ) malloc( SBOX_SIZE ) ) == NULL || \
        ( tempKey = ( BYTE * ) malloc( SBOX_SIZE * 2 ) ) == NULL )
        {
        puts( "Out of memory" );
        exit( -1 );
        }
    }

/* Shut down the encryption system */

void endCrypt( void )
    {
    /* Wipe any sensitive data in memory */
    memset( sBoxes1, 0, SBOX_SIZE );
    memset( sBoxes2, 0, SBOX_SIZE );
    memset( tempKey, 0, SBOX_SIZE * 2 );

    free( sBoxes1 );
    free( sBoxes2 );
    free( tempKey );
    }

/* Save and restore the current states of the encryption */

static BYTE savedIV[ BLOCKSIZE ], savedTemp[ BLOCKSIZE ];
static int savedIvCount;

#ifdef CBC
  static LONG savedIvLLeft1, savedIvRLeft1, savedIvLRight1, savedIvRRight1;
  static LONG savedIvLLeft2, savedIvRLeft2, savedIvLRight2, savedIvRRight2;
#endif /* CBC */

void saveCryptState( void )
    {
    memcpy( savedIV, iv, BLOCKSIZE );
    memcpy( savedTemp, temp, BLOCKSIZE );
    savedIvCount = ivCount;
#ifdef CBC
    savedIvLLeft1 = ivLLeft1;
    savedIvRLeft1 = ivRLeft1;
    savedIvLRight1 = ivLRight1;
    savedIvRRight1 = ivRRight1;
    savedIvLLeft2 = ivLLeft2;
    savedIvRLeft2 = ivRLeft2;
    savedIvLRight2 = ivLRight2;
    savedIvRRight2 = ivRRight2;
#endif /* CBC */
    }

void restoreCryptState( void )
    {
    memcpy( iv, savedIV, BLOCKSIZE );
    memcpy( temp, savedTemp, BLOCKSIZE );
    ivCount = savedIvCount;
#ifdef CBC
    ivLLeft1 = savedIvLLeft1;
    ivRLeft1 = savedIvRLeft1;
    ivLRight1 = savedIvLRight1;
    ivRRight1 = savedIvRRight1;
    ivLLeft2 = savedIvLLeft2;
    ivRLeft2 = savedIvRLeft2;
    ivLRight2 = savedIvLRight2;
    ivRRight2 = savedIvRRight2;
#endif /* CBC */
    }

/****************************************************************************
*                                                                           *
*                   The NSEA Encryption/Decryption Routines                 *
*                                                                           *
****************************************************************************/

/* This is the core routine used by NSEA, and is a fairly standard method
   used by, for example, the DES.  The input data is broken into two halves
   and each half is alternately used to encrypt the other half */

void encrypt( BYTE *inData, BYTE *outData )
    {
    LONG lLeft = *( ( LONG * ) inData );
    LONG rLeft = *( ( LONG * ) inData + 1 );
    LONG lRight = *( ( LONG * ) inData + 2 );
    LONG rRight = *( ( LONG * ) inData + 3 );

#ifdef CBC
    lLeft ^= ivLLeft1;
    rLeft ^= ivRLeft1;
    lRight ^= ivLRight1;
    rRight ^= ivRRight1;
#endif /* CBC */

    lLeft ^= sBoxes1[ ( BYTE ) lRight ];
    rLeft ^= sBoxes2[ ( BYTE ) rRight ];
    rotl( lRight, rRight );
    lRight ^= sBoxes1[ ( BYTE ) lLeft ];
    rRight ^= sBoxes2[ ( BYTE ) rLeft ];
    rotl( lLeft, rLeft );
    lLeft ^= sBoxes1[ ( BYTE ) lRight ];
    rLeft ^= sBoxes2[ ( BYTE ) rRight ];
    rotl( lRight, rRight );
    lRight ^= sBoxes1[ ( BYTE ) lLeft ];
    rRight ^= sBoxes2[ ( BYTE ) rLeft ];
    rotl( lLeft, rLeft );
    lLeft ^= sBoxes1[ ( BYTE ) lRight ];
    rLeft ^= sBoxes2[ ( BYTE ) rRight ];
    rotl( lRight, rRight );
    lRight ^= sBoxes1[ ( BYTE ) lLeft ];
    rRight ^= sBoxes2[ ( BYTE ) rLeft ];
    rotl( lLeft, rLeft );
    lLeft ^= sBoxes1[ ( BYTE ) lRight ];
    rLeft ^= sBoxes2[ ( BYTE ) rRight ];
    rotl( lRight, rRight );
    lRight ^= sBoxes1[ ( BYTE ) lLeft ];
    rRight ^= sBoxes2[ ( BYTE ) rLeft ];
    rotl( lLeft, rLeft );
#ifdef TWO_ROUNDS
    lLeft ^= sBoxes1[ ( BYTE ) lRight ];
    rLeft ^= sBoxes2[ ( BYTE ) rRight ];
    rotl( lRight, rRight );
    lRight ^= sBoxes1[ ( BYTE ) lLeft ];
    rRight ^= sBoxes2[ ( BYTE ) rLeft ];
    rotl( lLeft, rLeft );
    lLeft ^= sBoxes1[ ( BYTE ) lRight ];
    rLeft ^= sBoxes2[ ( BYTE ) rRight ];
    rotl( lRight, rRight );
    lRight ^= sBoxes1[ ( BYTE ) lLeft ];
    rRight ^= sBoxes2[ ( BYTE ) rLeft ];
    rotl( lLeft, rLeft );
    lLeft ^= sBoxes1[ ( BYTE ) lRight ];
    rLeft ^= sBoxes2[ ( BYTE ) rRight ];
    rotl( lRight, rRight );
    lRight ^= sBoxes1[ ( BYTE ) lLeft ];
    rRight ^= sBoxes2[ ( BYTE ) rLeft ];
    rotl( lLeft, rLeft );
    lLeft ^= sBoxes1[ ( BYTE ) lRight ];
    rLeft ^= sBoxes2[ ( BYTE ) rRight ];
    rotl( lRight, rRight );
    lRight ^= sBoxes1[ ( BYTE ) lLeft ];
    rRight ^= sBoxes2[ ( BYTE ) rLeft ];
    rotl( lLeft, rLeft );
#endif /* TWO_ROUNDS */

#ifdef CBC
    ivLLeft1 = lLeft;
    ivRLeft1 = rLeft;
    ivLRight1 = lRight;
    ivRRight1 = rRight;
#endif /* CBC */

    *( ( LONG * ) outData ) = lLeft;
    *( ( LONG * ) outData + 1 ) = rLeft;
    *( ( LONG * ) outData + 2 ) = lRight;
    *( ( LONG * ) outData + 3 ) = rRight;
    }

#ifdef CBC

/* Perform the decryption */

void decrypt( BYTE *inData, BYTE *outData )
    {
    LONG lLeft = *( ( LONG * ) inData );
    LONG rLeft = *( ( LONG * ) inData + 1 );
    LONG lRight = *( ( LONG * ) inData + 2 );
    LONG rRight = *( ( LONG * ) inData + 3 );

#ifdef TWO_ROUNDS
    rotr( lLeft, rLeft );
    lRight ^= sBoxes1[ ( BYTE ) lLeft ];
    rRight ^= sBoxes2[ ( BYTE ) rLeft ];
    rotr( lRight, rRight );
    lLeft ^= sBoxes1[ ( BYTE ) lRight ];
    rLeft ^= sBoxes2[ ( BYTE ) rRight ];
    rotr( lLeft, rLeft );
    lRight ^= sBoxes1[ ( BYTE ) lLeft ];
    rRight ^= sBoxes2[ ( BYTE ) rLeft ];
    rotr( lRight, rRight );
    lLeft ^= sBoxes1[ ( BYTE ) lRight ];
    rLeft ^= sBoxes2[ ( BYTE ) rRight ];
    rotr( lLeft, rLeft );
    lRight ^= sBoxes1[ ( BYTE ) lLeft ];
    rRight ^= sBoxes2[ ( BYTE ) rLeft ];
    rotr( lRight, rRight );
    lLeft ^= sBoxes1[ ( BYTE ) lRight ];
    rLeft ^= sBoxes2[ ( BYTE ) rRight ];
    rotr( lLeft, rLeft );
    lRight ^= sBoxes1[ ( BYTE ) lLeft ];
    rRight ^= sBoxes2[ ( BYTE ) rLeft ];
    rotr( lRight, rRight );
    lLeft ^= sBoxes1[ ( BYTE ) lRight ];
    rLeft ^= sBoxes2[ ( BYTE ) rRight ];
#endif /* TWO_ROUNDS */
    rotr( lLeft, rLeft );
    lRight ^= sBoxes1[ ( BYTE ) lLeft ];
    rRight ^= sBoxes2[ ( BYTE ) rLeft ];
    rotr( lRight, rRight );
    lLeft ^= sBoxes1[ ( BYTE ) lRight ];
    rLeft ^= sBoxes2[ ( BYTE ) rRight ];
    rotr( lLeft, rLeft );
    lRight ^= sBoxes1[ ( BYTE ) lLeft ];
    rRight ^= sBoxes2[ ( BYTE ) rLeft ];
    rotr( lRight, rRight );
    lLeft ^= sBoxes1[ ( BYTE ) lRight ];
    rLeft ^= sBoxes2[ ( BYTE ) rRight ];
    rotr( lLeft, rLeft );
    lRight ^= sBoxes1[ ( BYTE ) lLeft ];
    rRight ^= sBoxes2[ ( BYTE ) rLeft ];
    rotr( lRight, rRight );
    lLeft ^= sBoxes1[ ( BYTE ) lRight ];
    rLeft ^= sBoxes2[ ( BYTE ) rRight ];
    rotr( lLeft, rLeft );
    lRight ^= sBoxes1[ ( BYTE ) lLeft ];
    rRight ^= sBoxes2[ ( BYTE ) rLeft ];
    rotr( lRight, rRight );
    lLeft ^= sBoxes1[ ( BYTE ) lRight ];
    rLeft ^= sBoxes2[ ( BYTE ) rRight ];

    lLeft ^= ivLLeft2;
    rLeft ^= ivRLeft2;
    lRight ^= ivLRight2;
    rRight ^= ivRRight2;

    ivLLeft2 = *( ( LONG * ) inData );
    ivRLeft2 = *( ( LONG * ) inData + 1 );
    ivLRight2 = *( ( LONG * ) inData + 2 );
    ivRRight2 = *( ( LONG * ) inData + 3 );

    *( ( LONG * ) outData ) = lLeft;
    *( ( LONG * ) outData + 1 ) = rLeft;
    *( ( LONG * ) outData + 2 ) = lRight;
    *( ( LONG * ) outData + 3 ) = rRight;
    }
#endif /* CBC */

/****************************************************************************
*                                                                           *
*                       Cipher Feedback Mode Routines                       *
*                                                                           *
****************************************************************************/

/* Initialise the IV.  This is set to the first 128 bits of the encryption key,
   encrypted with the S-boxes it generated */

void initCFB( const char *key )
    {
    int length = strlen( key ), i = 0, j = 0;

    /* Copy BLOCKSIZE bytes of key into the IV and encrypt it */
    while( i < BLOCKSIZE )
        if( j == length )
            {
            iv[ i++ ] = '\0';
            j = 0;
            }
        else
            iv[ i++ ] = key[ j++ ];
    encrypt( iv, iv );

    ivCount = 0;
    }

/* Encrypt data in CFB mode */

void encryptCFB( BYTE *buffer, int noBytes )
    {
    int bytesToUse, i;

    if( ivCount )
        {
        /* Use any material left in the encrypted IV */
        bytesToUse = BLOCKSIZE - ivCount;
        if( noBytes < bytesToUse )
            bytesToUse = noBytes;
        for( i = 0; i < bytesToUse; i++ )
            buffer[ i ] ^= temp[ i + ivCount ];
        memcpy( iv + ivCount, buffer, bytesToUse );
        noBytes -= bytesToUse;
        buffer += bytesToUse;
        }

    while( noBytes )
        {
        ivCount = ( noBytes > BLOCKSIZE ) ? BLOCKSIZE : noBytes;

        encrypt( iv, temp );    /* Encrypt IV */

        /* XOR the buffer contents with the encrypted IV */
        for( i = 0; i < ivCount; i++ )
            buffer[ i ] ^= temp[ i ];

        /* Shift ciphertext into IV */
        memcpy( iv, buffer, ivCount );

        /* Move on to next block of data */
        noBytes -= ivCount;
        buffer += ivCount;
        }
    }

/* Encrypt data in CFB mode */

void decryptCFB( BYTE *buffer, int noBytes )
    {
    int bytesToUse, i;

    if( ivCount )
        {
        /* Use any material left in the encrypted IV */
        bytesToUse = BLOCKSIZE - ivCount;
        if( noBytes < bytesToUse )
            bytesToUse = noBytes;
        memcpy( iv + ivCount, buffer, bytesToUse );
        for( i = 0; i < bytesToUse; i++ )
            buffer[ i ] ^= temp[ i + ivCount ];
        noBytes -= bytesToUse;
        buffer += bytesToUse;
        }

    while( noBytes )
        {
        ivCount = ( noBytes > BLOCKSIZE ) ? BLOCKSIZE : noBytes;

        encrypt( iv, temp );    /* Encrypt IV */

        /* Shift ciphertext into IV */
        memcpy( iv, buffer, ivCount );

        /* XOR the buffer contents with the encrypted IV */
        for( i = 0; i < ivCount; i++ )
            buffer[ i ] ^= temp[ i ];

        /* Move on to next block of data */
        noBytes -= ivCount;
        buffer += ivCount;
        }
    }

/****************************************************************************
*                                                                           *
*       Sample Program:  File Encryption/Decryption using CFB mode          *
*                                                                           *
****************************************************************************/

#ifndef CBC

void main( const int argc, const char *argv[] )
    {
#if !defined( TIME_TRIAL ) && !defined( SETUP_TRIAL )
    FILE *inFilePtr, *outFilePtr;
#endif /* !( TIME_TRIAL || SETUP_TRIAL ) */
#ifndef SETUP_TRIAL
    BYTE buffer[ 512 ];
#endif /* !SETUP_TRIAL */
    char key[ MAX_KEYLENGTH + 1 ];
    int count = 1;

#if !defined( TIME_TRIAL ) && !defined( SETUP_TRIAL )
    if( argc == 4 )
        {
        if( ( inFilePtr = fopen( argv[ 2 ], "rb" ) ) == NULL )
            {
            perror( argv[ 1 ] );
            exit( ERROR );
            }
        if( ( outFilePtr = fopen( argv[ 3 ], "wb" ) ) == NULL )
            {
            perror( argv[ 2 ] );
            exit( ERROR );
            }
        }
    else
        {
        puts( "Usage: nsea128 e|d <infile> <outfile>" );
        puts( "               e to encrypt data" );
        puts( "               d to decrypt data" );
        exit( ERROR );
        }
#endif /* TIME_TRIAL */

    initCrypt();

    /* Set up the S-Boxes */
#if defined( TIME_TRIAL ) || defined( SETUP_TRIAL )
    strcpy( key, "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789" );
#else
    *key = '\0';
    while( strlen( key ) < 6 )
        {
        printf( "Key (6-%d chars): ", MAX_KEYLENGTH );
        fgets( key, MAX_KEYLENGTH, stdin ); /* Should use something better */
        key[ strlen( key ) - 1 ] = '\0';    /* Stomp '\n' */
        putchar( '\n' );
        }
#endif /* TIME_TRIAL || SETUP_TRIAL */
#ifdef SETUP_TRIAL
    puts( "Performing 1000 key setup operations" );
    for( count = 0; count < 1000; count++ )
        {
#endif /* SETUP_TRIAL */
    initSBoxes( key );
    initCFB( key );
#ifdef SETUP_TRIAL
        }
    puts( "Done" );
#endif /* SETUP_TRIAL */

    /* We're done with the key, zap it */
    memset( key, 0, BLOCKSIZE );

#if defined( TIME_TRIAL )
    /* Encrypt 1MB of data in 512-byte blocks */
    memset( buffer, 0, 512 );
    puts( "Encrypting 2048 x 512-byte blocks (1MB)..." );
    for( count = 0; count < 2048; count++ )
        encryptCFB( buffer, 512 );
    puts( "Done" );
#elif !defined( SETUP_TRIAL )
    /* Grovel through a file en/decrypting it */
    while( count )
        {
        /* Read in a block of chars */
        count = fread( buffer, 1, 512, inFilePtr );

        /* Encrypt/decrypt data block */
        if( *argv[ 1 ] == 'e' )
            encryptCFB( buffer, count );
        else
            decryptCFB( buffer, count );

        /* Write out block and reset counter */
        fwrite( buffer, 1, count, outFilePtr );
        }

    fclose( inFilePtr );
    fclose( outFilePtr );
#endif /* TIME_TRIAL */

    endCrypt();
    }
#endif /* !CBC */

/****************************************************************************
*                                                                           *
*               Sample Program:  Perform Test En/Decryptions                *
*                                                                           *
****************************************************************************/

#ifdef TEST_VERSION

/* Sample code to encrypt/decrypt 128-bit values.  Note that the sample
   keys are somewhat shorter than what would normally be used (128 bits
   vs about 6...MAX_KEYLENGTH bytes) */

typedef struct {
               BYTE key[ BLOCKSIZE ];       /* Sample key */
               BYTE data[ BLOCKSIZE ];      /* Sample data */
               } SAMPLE_VALUE;

SAMPLE_VALUE testValues[] = {
                    {
                        { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
                        { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
                    }, {
                        { 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
                          0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF },
                        { 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
                          0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF },
                    }, {
                        { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01 },
                        { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
                    }, {
                        { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
                        { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01 },
                    }, {
                        { 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
                        { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
                    }, {
                        { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
                        { 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
                    }, {
                        { 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
                          0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF },
                        { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
                    }, {
                        { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
                        { 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
                          0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF },
                    }, {
                        { 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
                          0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF },
                        { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01 },
                    }, {
                        { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01 },
                        { 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
                          0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF },
                    }, {
                        { 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
                          0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01 },
                        { 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
                          0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01 },
                    }, {
                        { 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                          0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80 },
                        { 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                          0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80 },
                    }, {
                        { 0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF,
                          0xFE, 0xDC, 0xBA, 0x98, 0x76, 0x54, 0x32, 0x10 },
                        { 0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF,
                          0xFE, 0xDC, 0xBA, 0x98, 0x76, 0x54, 0x32, 0x10 },
                    }, {
                        { 0xFE, 0xDC, 0xBA, 0x98, 0x76, 0x54, 0x32, 0x10,
                          0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF },
                        { 0xFE, 0xDC, 0xBA, 0x98, 0x76, 0x54, 0x32, 0x10,
                          0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF }
                    }
                };

#define NO_TEST_VALUES      14

/* Code to generate test encryption values */

void printData( BYTE *data )
    {
    int i = 0;

    while( i < BLOCKSIZE )
        printf( "%02X", data[ i++ ] );
    }

void main( void )
    {
    BYTE cipherText[ BLOCKSIZE ], result[ BLOCKSIZE ];
    char key[ MAX_KEYLENGTH + 1 ];
    int i, j;

    puts( "Beginning test run..." );

    initCrypt();

    for( i = 0; i < NO_TEST_VALUES; i++ )
        {
        /* Set up the key */
        memcpy( key, &testValues[ i ].key, BLOCKSIZE );
        initSBoxes( key );
        ivLLeft1 = ivRLeft1 = ivLRight1 = ivRRight1 = \
            ivLLeft2 = ivRLeft2 = ivLRight2 = ivRRight2 = 0L;

        printf( "Key " );
        printData( testValues[ i ].key );
        printf( ", data " );
        printData( testValues[ i ].data );
        printf( ":\n    " );

        for( j = 0; j < 4; j++ )
            {
            encrypt( testValues[ i ].data, cipherText );
            decrypt( cipherText, result );
            printData( cipherText );
            putchar( ' ' );
            if( memcmp( testValues[ i ].data, result, BLOCKSIZE ) )
                {
                printf( "\nDecrypted to " );
                printData( result );
                putchar( '\n' );
                }
            if( j == 1 )
                printf( "\n    " );
            }
        putchar( '\n' );
        }

    endCrypt();
    }
#endif /* TEST_VERSION */

--
    pgut1@cs.aukuni.ac.nz || peterg@kcbbs.gen.nz || peter@nacjack.gen.nz
                           (In order of preference)
Warning!
  Something large, scaly, and with fangs a foot long lives between <yoursite>
and <mysite>.  Every now and then it kills and eats messages.  If you don't
receive a reply within a week, try resending...
