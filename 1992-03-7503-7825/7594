Xref: msuinfo comp.lang.c:49130 comp.os.msdos.programmer:11903 sci.crypt:7594
Path: msuinfo!netnews.upenn.edu!jvnc.net!darwin.sura.net!europa.asd.contel.com!uunet!seas.smu.edu!utacfd.uta.edu!trsvax!rwsys!sneaky!gordon
From: gordon@sneaky.lonestar.org (Gordon Burditt)
Newsgroups: comp.lang.c,comp.os.msdos.programmer,sci.crypt
Subject: Re: "Hiding" variables in C
Message-ID: <1992Mar9.014950.12741@sneaky.lonestar.org>
Date: 9 Mar 92 01:49:50 GMT
References: <hr8fd90@sgi.sgi.com> <1992Mar06.191513.41268@yuma.acns.colostate.edu>
Organization: Gordon Burditt
Lines: 41

>Machines to not perform a sequential scans, but rather interpret instructions
>to which they have been dispatched.  Dissassemblers (and I presume decompilers)
>can be tripped up when machine instructions don't start immediately after a
>jump or branch instruction.  If you have a sequence:
>    code-ending-in-jump-or-branch
>    funny-stuff
>    more-code
>it's non-obvious where more-code starts.  You might find the first jump
>target in more-code (unless the jump target is dynamically created in
>the code (through some indexing or look-up operation)), but the analysis
>is difficult and likely to be absent in a decompiler.  If you can
>have mixed code&r/w data, "funny-stuff" can contain variables as well
>as hidden code.  You can also hide variables in the space created for
>alignments.

It isn't that difficult to write a disassembler that follows code paths.
The disassembler does a first pass that starts at a known entry point, 
marking instruction beginnings and noting the actions of instructions.  
The targets of conditional branches are noted as additional paths to follow.  
If the disassembler hits an unconditional branch or part of the code that 
it's followed before, it stops following that path and starts on the next one.
When it runs out of branches, it's done.  Code not identified as instructions
is presumed to be data, and examination of the data can generate some
reasonable guesses as to text strings vs. integers.  Relocation information
from an object file can also be used here.  Along the way, it can 
note locations that are called, jumped to, read or written as a {byte, word,
longword} variable, and note these on the listing when it makes one on
the second pass, making simple self-modifying code evident.  I wrote
one of these for a z80 processor, and it worked quite well.  One blind
spot was "branch tables".  Code generated for a C "switch" construct or
using function pointers used a variable-address branch which it didn't
understand, so some of the code got listed as data.  I added some commands
for "here is a branch table", along with provisions to supply meaningful
symbols in place of the generated dummy ones.  It took a couple of passes 
to get a good disassembly sometimes, but the detail given, such as only
generating labels on instructions that were referenced, and noting
self-modifying code (on 8080-compatible code you HAD to use self-modifying
code to access a variable I/O port) was worth it.

					Gordon L. Burditt
					sneaky.lonestar.org!gordon
