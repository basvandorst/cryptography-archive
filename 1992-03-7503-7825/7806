Xref: msuinfo comp.lang.c:50026 comp.os.msdos.programmer:12494 sci.crypt:7806
Path: msuinfo!caen!uwm.edu!ogicse!das-news.harvard.edu!husc-news.harvard.edu!brauer!kubo
From: kubo@brauer.harvard.edu (Tal Kubo)
Newsgroups: comp.lang.c,comp.os.msdos.programmer,sci.crypt
Subject: Re: "Hiding" variables in C
Message-ID: <1992Mar27.193250.10351@husc3.harvard.edu>
Date: 28 Mar 92 00:32:48 GMT
Article-I.D.: husc3.1992Mar27.193250.10351
References: <hr8fd90@sgi.sgi.com> <1992Mar5.210232.3211@b11.ingr.com> <55500@cup.portal.com>
Lines: 24
Nntp-Posting-Host: brauer.harvard.edu


In article <55500@cup.portal.com> ts@cup.portal.com (Tim W Smith) writes:
>
> [on self-decrypting programs that compute CRC from their own code]
>
>This means that if you stick a breakpoint at the end of the descryption
>code so that you can look and see what the key is, you don't get the
>right value, because the breakpoint changes the CRC!  Make sure that
>the decryption algorithm loops enough times to discourage someone from
>single stepping through it.
>
I don't see how this (or any other scheme that uses only the
program data with no external key input) yields any security.

Just load the program in two places in memory, don't recompute the
instruction addresses in the second copy, and run the second copy with
a breakpoint.  Then the clone will compute the correct CRC from the first
copy.

It is a good technique to confuse novices, though.  Another way is to
use instructions that behave anomalously at page boundaries (some of the
older Intel chips had this "feature") to set certain bits as side effects.

-tal
