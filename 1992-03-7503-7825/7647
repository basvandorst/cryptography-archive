Xref: msuinfo comp.lang.c:49300 comp.os.msdos.programmer:12025 sci.crypt:7647
Path: msuinfo!caen!zaphod.mps.ohio-state.edu!rpi!news-server.csri.toronto.edu!bonnie.concordia.ca!s3!beaurega
From: beaurega@ireq.hydro.qc.ca (Denis Beauregard)
Newsgroups: comp.lang.c,comp.os.msdos.programmer,sci.crypt
Subject: Re: "Hiding" variables in C
Message-ID: <9536@s3.ireq.hydro.qc.ca>
Date: 12 Mar 92 15:26:29 GMT
References: <55500@cup.portal.com> <1992Mar9.081248.14072@actrix.gen.nz> <1992Mar11.035730.29780@uwm.edu>
Sender: usenet@s3.ireq.hydro.qc.ca
Organization: Hydro-Quebec
Lines: 44

In article <1992Mar11.035730.29780@uwm.edu> markh@csd4.csd.uwm.edu (Mark William Hopkins) writes:
>In article <1992Mar9.081248.14072@actrix.gen.nz> Kris.Heidenstrom@bbs.actrix.gen.nz writes:
>>It's the same with copy protection.
>>Your aim would be to make it as difficult and time-consuming as possible for
>>the potential cracker to crack the program to the point of being able to
>>disassemble it.  It's *impossible* to completely protect *any* program.
>
>A disassembler only takes a couple seconds to disassemble the code.  I can
>easily write one that does control-flow analysis and even some rudimentary data
>flow analysis (even deriving the run-time values of variables on different
>paths) in a couple hours, if my life or livelihood depended on it.
>
If the coding scheme is very complex, a couple hours will not be enough.
One such possible scheme could be automodifying code.  As you step
in a loop, you can change a variable value with shift instruction,
(a random number generator uses this) build an address with this, and
incrementing address value (thus, many addresses will be modified).
So, as you step more, the code already disassembled is no more
effective (because by adding <n> to JMP you get PUSHA for example).
You can write such code that will require say 10000 cycles to recode
program.  Thus, your intelligent assembler may adapt its strategy
to skip the decoding part and keeping only the final result.
Then, this final result is not enough because you initialized variables
depending on actual address and free memory while recoding.
If the disassembler change strategy to keep intermediate code and just removing 
JMPs, random change of memory will made that some code will not be correct.

In other words, I think you can write code that will need long time
to be decoded.  However, maybe you will take more time to write and
debug this code than you will take to decode it.  This is efficient
if you sale your system to many others or you make a lot of money
each time.  BTW, there are such very complex programs in Copy-protected
diskette you can buy.  On another hand, I saw a copy protection system
based on a mechanical device that was sold without any coding.  With a
debugger, you could follow the control flow and desactivate the
checking function.  Thus, you paid a lot for a mechanical device and
you get almost no protection!


-- 
Denis Beauregard        beaurega@ireq.hydro.qc.ca
Mes opinions sont personnelles, pas celles de mon employeur.
My opinions are mine, not those of my employer.
Looking for BEAUREGARD, JARRET, JAREST, VINCENT (I'm also on soc.roots)
