Xref: msuinfo comp.lang.c:49047 comp.os.msdos.programmer:11859 sci.crypt:7570
Path: msuinfo!netnews.upenn.edu!jvnc.net!yale.edu!think.com!rpi!zaphod.mps.ohio-state.edu!ncar!csn!yuma!bentson
From: bentson@CS.ColoState.EDU (Randolph Bentson)
Newsgroups: comp.lang.c,comp.os.msdos.programmer,sci.crypt
Subject: Re: "Hiding" variables in C
Message-ID: <1992Mar06.191513.41268@yuma.acns.colostate.edu>
Date: 6 Mar 92 19:15:13 GMT
References: <hr8fd90@sgi.sgi.com>
Sender: news@yuma.acns.colostate.edu (News account)
Organization: Colorado State University, Computer Science Department
Lines: 24

In article <hr8fd90@sgi.sgi.com> rpw3@rigden.wpd.sgi.com (Rob Warnock) writes:
>Consider this: If "some machine instructions can be misintrepreted when
>decompiling" then some machine instructions can be misintrepreted when
>being executed by the CPU. ...which is probably undesirable.
>
Machines to not perform a sequential scans, but rather interpret instructions
to which they have been dispatched.  Dissassemblers (and I presume decompilers)
can be tripped up when machine instructions don't start immediately after a
jump or branch instruction.  If you have a sequence:
    code-ending-in-jump-or-branch
    funny-stuff
    more-code
it's non-obvious where more-code starts.  You might find the first jump
target in more-code (unless the jump target is dynamically created in
the code (through some indexing or look-up operation)), but the analysis
is difficult and likely to be absent in a decompiler.  If you can
have mixed code&r/w data, "funny-stuff" can contain variables as well
as hidden code.  You can also hide variables in the space created for
alignments.

-- 
    Randolph Bentson                 Colorado State University
    bentson@grieg.CS.ColoState.Edu   Computer Science Department
    303/491-5792                     Ft. Collins, CO 80523
