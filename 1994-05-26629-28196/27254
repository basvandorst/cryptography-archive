Path: msuinfo!uwm.edu!spool.mu.edu!howland.reston.ans.net!europa.eng.gtefsd.com!MathWorks.Com!blanket.mitre.org!linus.mitre.org!gauss.mitre.org!bs
From: bs@gauss.mitre.org (Robert D. Silverman)
Newsgroups: sci.math,sci.crypt,alt.security,alt.security.pgp,alt.security.ripem,comp.security.misc,alt.privacy
Subject: Re: RSA-129
Date: 9 May 1994 22:05:32 GMT
Organization: Research Computer Facility, MITRE Corporation, Bedford, MA
Lines: 72
Distribution: world
Message-ID: <2qmc3c$nb3@linus.mitre.org>
References: <2qk7fv$5b3@nntp.ucs.ubc.ca> <2ql3p9$k5k@linus.mitre.org> <2qm5q4$9jf@nntp.ucs.ubc.ca>
NNTP-Posting-Host: gauss.mitre.org
Xref: msuinfo sci.math:71643 sci.crypt:27254 alt.security:16550 alt.security.pgp:12832 alt.security.ripem:923 comp.security.misc:9888 alt.privacy:15223

In article <2qm5q4$9jf@nntp.ucs.ubc.ca> unruh@physics.ubc.ca (William Unruh) writes:
>bs@gauss.mitre.org (Robert D. Silverman) writes:
>

stuff deleted....

> OK, but they used the quadratic sieve, not GNFS.
> If one solves the equation 
> 6*10^4 MIPS years = exp(C*(ln(n)^1/3 * (ln(ln(n))^2/3)
      (sic). The above should be 6*10^3,  not 6*10^4.

 
Please explain what you are doing here. You have apples on one side
and oranges on the other. 
 
L(n) gives *asymptotically* the number of arithmetic operations needed.
					  ----------
You are naiively assuming that this is equivalent to MIPS-YEARS. They
are NOT the same. There are machine-dependent scaling factors which one
must apply to translate MIPS-YEARS into arithmetic operations. What the
values of those scaling factors are, neither I nor anyone else knows.

All you can do is compare the ratio L(N')/L(N) for different N and N',
*if* you know how o(1) behaves.  To know this, you must factor MANY
numbers and see how o(1) changes.


What you have done is plug in MIPS-YEARS (and it was 6000, not 60,000)
and solve for c+o(1), for N = RSA-129.  This is meaningful only if
you know how MIPS-YEARS translates into arithmetic operations. MIPS
includes many instructions that are not arithmetic.

> for C with n=10^129 one gets C= 1.87. Ie, they did the job in a better
> time than any possible GNFS according to you. Ie, your o(1) would
 
STOP trying to evaluate L(N) at a single point and expecting it to be
meaningful.  And experiments by A. Lenstra showed that GNFS would have been
3 times faster than QS for RSA-129. 

> have to be negative  or that the technique they used was far
 
It could well be negative. It is for ECM for a while. It starts negative,
crosses the x axis then curves back and approaches 0 asymptotically.

> supperior to GNFS for the number they were factoring.
 
Explain how you reached this conclusion. I don't follow you.

You can't just naiively compute L(1/3, 1.91, N) for GNFS and compare it
with L(1/2, 1, N) for QS. The values of o(1) differ and a small change can make
a big difference in the function value. Also, the nature of the arithmetic is
different for the two algorithms, so the machine instruction mix is 
different.


>  So let us say that the QS
> is better for smaller numbers but for larger numbers ( 2^1024) the
 
Experiments by Lenstra suggest a crossover point of about 110-120 digits
if one applies all the bells and whistles to GNFS.

> GNFS is better  and that for n=2^1024 we have c=1.91 This would give the number of
 
No! No! No!.  c is  CONSTANT.  only o(1) varies with N.

Read my paper (w/ S. Wagstaff Jr.) on the analysis of ECM.

-- 
Bob Silverman
These are my opinions and not MITRE's.
Mitre Corporation, Bedford, MA 01730
"You can lead a horse's ass to knowledge, but you can't make him think"
