Path: msuinfo!agate!doc.ic.ac.uk!aixssc.uk.ibm.com!watnews.watson.ibm.com!locutus.rchland.ibm.com!wo0z.rchland.ibm.com!lwloen
From: lwloen@wo0z.rchland.ibm.com (Larry Loen)
Newsgroups: sci.crypt
Subject: Bit Endian (was Re: DES Implementation Question)
Date: 3 May 1994 03:22:30 GMT
Organization: IBM Rochester MN
Lines: 60
Distribution: world
Message-ID: <2q4g1m$fm3@locutus.rchland.ibm.com>
References: <2pve6o$dta@mojo.eng.umd.edu> <1994May2.053858.22202@mnemosyne.cs.du.edu>
Reply-To: lwloen@rchland.vnet.ibm.com
NNTP-Posting-Host: wo0z.rchland.ibm.com
Keywords: DES

In article <1994May2.053858.22202@mnemosyne.cs.du.edu>, colin@nyx10.cs.du.edu (Colin Plumb) writes:
|> In article <2pve6o$dta@mojo.eng.umd.edu>,
|> Christopher R. Bowman <crb@glue.umd.edu> wrote:
|> > I wrote some DES code myself, and I am having problems verifing its
|> > correct functioning.  I verified all the subroutines to the best
|> > of my abilities but I am still not getting the same output from
|> > my routines as I get from the SUN routines.  I am guessing that
|> > this is due to a difference in how I define the bit numbers.
|> > So here is my question.  Given say 8 bytes in memory, starting at
|> > say location 0 and ending at location 7 is there a prefered way
|> > to define where bit 1 is and so on?
|> 
|> Yes.  DES numbers its bits in big-endian order.  The most significant
|> bit of the irst byte is bit 1, and the least significant bit of the
|> last byte is bit 64.  The least significant bits of each byte are
|> the key partiy bytes (unlike every other use of parity in the world)
|> 
|> > Can someone give me, say a dozen key, input, output
|> > triplets for DES so that I can check my implementation?
|> 
|> There are some around, which someone will probably post or mail, but
|> I haven't get any handy.
|> -- 
|> 	-Colin

Just a usefully pendantic note.  There is no such thing as "big endian
bit order".  I have had cause to study byte order endian lately and it is one of
the biggest mares nests I have ever been involved in.

The only thing about it that is worse is programmer's tendency lately to
rename every bilateral reflection in sight after "endian".  Bit 
numbering is almost wholly arbitrary and even if (e.g.) a given
machine architecture contains instructions that ascendingly numbers bits from
high order to low or low or low order to high (take your pick), 
programmers can perform trivial operations such that it can be wholly
ignored.  This is exactly unlike "real endian" where the byte ordering is
often visible from the bottom of the operating system to the Visual
Basic programmer.

To underscore the point, there apparently are texts around that show
the Intel 80x86 architecture numbered with the bits right to left or left
to right.  Since no instruction whatever references things by bit
number, there is no harm whatever from either approach and, unlike real
endian, either notation may be adopted by a given application and even
different orderings by different applications that pass bit strings to each other.
Likewise, different C compilers can have their int  x : 3 kind of stuff
set up any way they like (interoperability is hell, but you were
warned by ANSI C) and within itself, it all works just fine.  None of 
this is possible with real endian.

What I'm trying to say is "don't spread the manure needlessly", because
into everyone's life some endian may fall and only a well-educated
intuition, free from false analogies, seems to save one from lotsa
dumb mistakes.

-- 
   Larry W. Loen        |  My Opinions are decidedly my own, so please
                        |  do not attribute them to my employer

   email to:  lwloen@rchland.vnet.ibm.com
