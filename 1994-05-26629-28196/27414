Path: msuinfo!netnews.upenn.edu!dsinc!newsfeed.pitt.edu!gatech!swrinde!cs.utexas.edu!usc!rand.org!jim
From: jim@rand.org (Jim Gillogly)
Newsgroups: sci.crypt
Subject: Re: Anchor Steam-driven errors in recognition groups
Date: 12 May 1994 22:54:37 GMT
Organization: Banzai Institute
Lines: 49
Message-ID: <2quc3d$t0m@rand.org>
References: <1994May10.103329.8566@chemabs.uucp>
NNTP-Posting-Host: mycroft.rand.org
Keywords: Book cipher challenge

In article <1994May10.103329.8566@chemabs.uucp>,  <jac55@cas.org> wrote:
>	For those of you trying my book cipher challenge, it
>	has been pointed that I made a mistake in the arithmetic
>	of the recognition groups.  They should be as follows:
...
>	The text used for the superencrypting running key is
>	a coherent English text.  This should therefore be
>	breakable according to David Kahn (a heavy hint 
>	in there).

Ah... <that's> what was wrong!  In that case, the keyword is PATHOS, the
running key starts "it was not the first time mrs. friedman had done this."
and the plaintext starts "her inquiries after her sister were not".

May I have the prize in Anchor Steam rather than a bottle of good wine? :)

Friedman & Callimahos in "Military Cryptanalytics II" don't quite cover
this cipher system -- they discuss the first part, called a monome-dinome
cipher, and a variation of it using a re-useable additive
superencipherment - like a periodic version of this.  Unfortunately the
later volumes of Military Cryptanalytics haven't been declassified yet --
at least not the bits that deal with monome-dinome with aperiodic additive
component (assuming there is such a section).

I gave up on spotting the recovered plaintext with digraphs, and threw
together a hash table with /usr/dict/words in it, then checked for
(possibly overlapping) words in the output.  I used Zobrist hashing, a
fine old chess and go technique, so that I didn't need to calculate the
whole hash each time.  To start off the process, you have an array of
pseudo-random numbers zob[10][128] (assuming 10-letter words maximum, and
128 for the ascii bytes you'll be looking up).  The hash of the word "baz"
is zob[0]['b'] ^ zob[1]['a'] ^ zob[2]['z'], and it looks random because
each of the longs in "zob" is pseudo-random.  Then use the appropriate
number of those bits as a starting point in the hash table, saving the
rest for a check hash (or store the whole word, if you want -- I went
the riskier but faster check hash route).

For example, if the assumed plaintext looks like "pastoreairnnvrfnsetanas",
start a pointer at the beginning and look up the hash for "pa", then
"pas", then "past", and so on for as long as you want to go.  With Zobrist
hashing, you get the hash of the next word try by XORing the hash of the
one you just looked up with the value in zob[][] of the next letter, so
the hashing is just one table lookup and an XOR... cheap stuff.  For scoring,
I gave 1 point for a 2-letter word, 2 for a 3-letter word and so on.  I
started off with an exponential: 1<<(n-2) for an n-letter word, but that
was too sensitive to hash table collisions, so I gave up on that.
-- 
	Jim Gillogly
	21 Thrimidge S.R. 1994, 22:54
