Path: msuinfo!agate!bob.eecs.berkeley.edu!spp
From: spp@bob.eecs.berkeley.edu (Steve Pope)
Newsgroups: sci.crypt
Subject: Re: 2 practical cryptography questions about a secure-drive type system
Date: 11 May 1994 17:41:04 GMT
Organization: U.C. Berkeley -- ERL
Lines: 45
Message-ID: <2qr5bg$m9e@agate.berkeley.edu>
References: <2qiu5f$9bj@vixen.cso.uiuc.edu> <2qpaln$fge@msuinfo.cl.msu.edu>
NNTP-Posting-Host: 128.32.139.6

mrr@scss3.cl.msu.edu (Anonymous) writes:

>Nicolas S Dade (nd8067@ehsn4.cen.uiuc.edu) wrote:
>
>: I am fooling around with encrypting a small partition on my harddrive. I
>: have written a device driver that decrypts and encrypts sectors ...
>: In an effort to improve the security of my device driver, I would like to
>: salt the encryption of each sector with a sector dependant salt.
>
>I would suggest using the cipher with a single key in CBC mode,
>with a new initializing vector for each sector.  The vector
>could be an encrypted form of the key+sector number or some such info.

Seems we had a discussion here a few weeks ago with the conclusion
that a random, secret IV does not increase security in 
CBC mode (only the first cipher block in the sector would
be made more difficult to decrypt by this method).

I have been thinking as well about how to improve the
security in situations where the message length is finite
and in fact short, e.g. 1 kbyte disk sectors.

One possibiity that occurred to me is the following:

Suppose E() is the available block encryption function with
64-bit input and output blocks and a k bit key.  Our goal
is to encrypt a series of 1-kbyte sectors, without changing
the key (since that is computationally expensive) but with
a different seed or initialization each time.

First create a sector-dependent 54-bit random number R.
Let N be the index of the bytes within the sector (0 <= N <= 1023).
Encrypt the N-th plaintext byte PT into a ciphertext
byte CT as follows:

         CT = PT xor M [ E(R:N) ]

Where R:N is the concatenation of R and N, and M is a masking
operation that selects an 8-bit byte from the 64-bit output of E().

This is, in effect, a stream cipher operating on a byte-stream.

Any comments?

Steve
