Path: msuinfo!agate!darkstar.UCSC.EDU!news.hal.COM!olivea!charnel.ecst.csuchico.edu!psgrain!nntp.cs.ubc.ca!newsxfer.itd.umich.edu!zip.eecs.umich.edu!yeshua.marcam.com!MathWorks.Com!zombie.ncsc.mil!golf!mizzou1.missouri.edu!C445585
From: C445585@mizzou1.missouri.edu
Newsgroups: sci.crypt
Subject: Small blocks, large blocks, and stream ciphers
Date: Thu, 05 May 94 19:54:44 CDT
Organization: University of Missouri, Columbia
Lines: 83
Message-ID: <16FAD11804S86.C445585@mizzou1.missouri.edu>
NNTP-Posting-Host: mizzou1.missouri.edu

 
   I've been conversing with Terry Ritter over the net about (among
other things) the advantages and disadvantages of larger or smaller
blocks in a block cipher.
 
Some advantages of large blocks:
 
o  It's less practical for an attacker to keep a dictionary of commonly
   occurring ciphertext patterns, if the cipher is run in ECB-mode.
 
o  The cycle-length of OFB-mode encryption is a function of block
   length.  With a 64-bit block, the average cycle length is likely
   to be about 2**32 blocks.  With a 256-bit block, it's about 2**128.
 
o  Known-plaintext versions of differential attacks (waiting for a
   specific input differential to occur by chance) become much harder.
 
o  CFB-mode encryption has a larger internal state (more previous
   ciphertext bits).
 
The advantages to small blocks:
 
o  It takes fewer operations to diffuse changes through the block.
 
o  Operations on 32-bits or less at a time are fast on conventional
   computers.
 
o  Smaller "granularity," ie you don't need to fill in quite so much
   of the block when you have plaintext that doesn't fit evenly in
   your block size.
 
o  It's easier to analyze closely the behavior of small-block systems.
   It's practical for someone with a PC to cycle through all 2**32
   possible inputs for multiple keys, and keep track of bit-change
   statistics, etc, with a 32-bit block size.
 
   Now, I've been interested in stream ciphers for a long time.
The most common kind use a pseudorandom bit string to XOR against
the message text.  However, I've been thinking about a very different
approach.  A 32-bit block cipher is easier to analyze for weaknesses
than a 64-bit block cipher.  It's also going to take fewer operations
to make a strong 32-bit block cipher than a strong 64-bit block cipher,
which means that the cipher can run faster.  However, the catch is that
32-bit blocks are too small--an attacker can build a dictionary of
ciphertext blocks, and if she knows what the corresponding plaintext
for one block was, she can decipher that plaintext again and again.
 
   My general idea was:  What if you could run a 32-bit block cipher,
but use different, pseudorandom keys for each cipher?  The pseudorandom
keys need to be well-balanced, and they can't have gaping linear
patterns in them that allow a "guess and check" approach, because
the attacker, in chosen plaintext/chosen ciphertext attacks, will
probably be able to do lots of guessing and checking.
 
   Has this sort of thing been done before?  (It seems likely that
it has, but I've never heard of it.)  This kind of scheme would
make bit-twiddling attacks harder, and would also serve to hash
down the prng output to only (miximally) 32-bits of information
about a given pseudorandom key at a time.  There's a tradeoff
between the blockcipher complexity and the PRNG complexity here,
too--with a *really* good PRNG, XOR works.  With a weaker PRNG,
some kind of nonlinear combining will be done in the block cipher.
 
   The simplest schemes that came to mind were some variations on
BLOWFISH (BLOWFISH-32, or some variants), NewDES, and LUCIFER.
 
   An 8-round BLOWFISH-32 would use 160 bits of subkey for 32 bits
of output.  Running 3 different-length AFSRs through a simple non-
linear combiner with memory would probably generate the subkey
sequence more than fast enough for practical use.  The s-boxes could
be generated once for each key, while the AFSR sequence would be
initialized with an IV many times (for some applications) per key.
This would need to be designed to be secure and fast at the same
time, since an attacker can easily insert noise into a communication
stream to force a re-synch.
 
   I'm interested in any comments you might have about this sort of
thing.  The fact that the subkeys change every block seems to justify
smaller numbers of rounds, and a block cipher could well be designed
to run optimally with 32-bit blocks.  Alternatively, perhaps schemes
such as this could drive 64-bit block ciphers, or larger ones.
 
   --John Kelsey, c445585@mizzou1.missouri.edu
