Path: msuinfo!agate!boulder!tali.hsc.colorado.edu!mnemosyne.cs.du.edu!nyx10.cs.du.edu!not-for-mail
From: colin@nyx10.cs.du.edu (Colin Plumb)
Newsgroups: sci.crypt
Subject: Re: One Time Pad from Keys?
Date: 30 May 1994 20:12:47 -0600
Organization: /usr/lib/news/organi[sz]ation
Lines: 88
Message-ID: <2se6ev$s34@nyx10.cs.du.edu>
References: <1994May26.093631.26772@bradford.ac.uk> <jgkCqFzx6.Is1@netcom.com> <richardrCqGtzy.J0M@netcom.com>
Keywords: entropy

In article <richardrCqGtzy.J0M@netcom.com>,
Richard L. Robertson <richardr@netcom.com> wrote:
>jgk@netcom.com (Joe Keane) writes:
>
>>In article <1994May26.093631.26772@bradford.ac.uk>
>>WG REDWOOD <W.G.Redwood@bradford.ac.uk> writes:
>>>Please would somebody point me in the right direction for generating
>>>a one time pad from a user defined key???
>
>>No, can't be done.

>You might consider looking at the "subtract-with-borrow" generator developed
>by George Marsaglia  ("A New Class of Randon Number Generator", G. 
>Marsaglia and Z.Zammar, The Annals of Applied Probability, 1991,
>Vol 1, Num 1, pp.462-480) as source of of generators of sequences that
>have lengths >10**200 and which pass all the the standard tests for
>for randomness.

Yes, but not cryptographic tests.  The generator only has one bit of
hidden state (the carry/borrow bit), which ie easy to guess.  This
may be an excellent PRNG for any application oblivious to its inner workings,
but it's as miserable as the rest for cryptographic applications.

A "one time pad" is exactly that: a sequence of truly random numbers
(i.e. derived from a hardware random noise source) that is used only
once.  The key is the length of the pad, and is a random bit string,
not a password or phrase easily memorable by a user.

A one time pad is provably unbreakable.

However everyone gets excited about this and thinks that they can take
shortcuts on the random bit string.  The proof of security hinges
on the complete randomness of the bit string "pad".  As soon as you
try to generate a pad with less Shannon entropy than the number of bits in
the pad, you have violated this proof.  The problem then becomes amenable
to cryptanalysis.

Generally, stream ciphers are formed by generating a random-seeming pad
and exclusive-oring it with the plaintext.  If you want to build such
a cipher, please go ahead, but do it properly and don't call it a one-time
pad.

A one-time pad is *by definition* not representable in less space than the
message it encrypts.  The security lies not in the XOR operation (which
is trivial, and could as easily be addition, multiplication mod 2^16+1
a la IDEA, or any other group operation), but in the complete, utter
and total unpredictability of the pad.  Practical applications of the
one-time pad require the most extraordinary care be taken to avoid all
bias and correlation among the pad bits.  This is what makes it difficult
to use in practice.

Any algorithmic technique of generating a random-seeming bit string does
not have this property, and is susceptible to cryptanalysis of the
algorithm used to generate it.

This resistance to cryptanalysis is where you should focus your attention.
The fact that the combining operation of the random-seeming bit string
looks like the operation used by a one-time pad is utterly irrelevant
to the security of your scheme.  It is in the generation of the pad that
such a cipher stands or falls, and thje definition of a one-time pad
starts "suppose we have a perfect pad".  Easy to say, hard to do.

Certainly no pseudo-random number generator that is conventionally used
in simulation (rand() in the C library, LFSRs, anything in Knuth, or
Marsaglia's generator) is even remotely secure.  They are designed for
good statistical properties and high speed.  But the statistical tests
are naive.  The assumption in cryptography is that the opponent is anything
but naive.

I'm sorry to go on at such length on the subject, but it seems that once
a month or more someone suggests a cipher based on exclusive-oring the
output of a random number generator with some plaintext and invokes the
aura of the one-time pad to argue why this is good.  It seems that the
point warrants some hammering:

The definition of a one-time pad supposes a *perfect* random-number generator.
Any scheme involving a *practical* random-number generator needs to prove
the perfection of that generator.  And that is an extremely difficult thing
to do indeed.  For example, any algorithmic generator that has more output
than keying material is provably imperfect.  (Trivial technique: try all
possible keys and see which generates the observed output.  If there
is mroe output than key bits, you are going to find a unique key with
very high probability.  Then you can use that to predict future bits ad
infinitum.  This may not be practical, but it's theoretically possible.)
-- 
	-Colin


