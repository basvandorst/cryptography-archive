Path: msuinfo!caen!uwm.edu!cs.utexas.edu!howland.reston.ans.net!europa.eng.gtefsd.com!news.umbc.edu!olson
From: olson@umbc.edu (Bryan G. Olson; CMSC (G))
Newsgroups: sci.crypt
Subject: Re: OFB-mode encryption and cycle length
Date: 22 May 1994 07:39:15 GMT
Organization: University of Maryland, Baltimore County
Lines: 111
Message-ID: <2rn273$36d@news.umbc.edu>
References: <16FB81269ES86.C445585@mizzou1.missouri.edu>
NNTP-Posting-Host: umbc7.umbc.edu
X-Newsreader: TIN [version 1.2 PL2]

C445585@mizzou1.missouri.edu wrote:
:  
:    Hmmm.  Bryan Olsen says that a 64-bit block cipher will have a
: 2**63 cycle length on average.

(Actually I said 1**63 + 1/2, though the difference is trivial.)

:  I don't think that's right, but I may
: be missing something.  Here's my basic logic:
:  
: 1.  Our encryption is a random mapping from input to output.

Not quite.  It's a (pseudo) random _permutation_.

: 2.  We're running in 64-bit output-feedback mode.  That means that
:  
:     X(i+1) = Encrypt(X(i))
:  

Sounds good.

: Now, suppose we used this as a pseudo-random generator of 64-bit blocks.
: About how many such blocks should we need to generate before we have
: two equal blocks?  (x(i) = x(j), i <> j)  The standard birthday paradox
: answer is 2**32, the square root of the total number of possible values.
:  
: Now, whenever you hit a value in x(i) that you've generated before, you
: are going to have a cycle, because each output value is determined by
: the previous output value.
:  
: Am I missing something?  I remember reading the 2**32 cycle length value
: somewhere, too, but it made sense to me from this.
:  

The key is that difference between a random function and a
random permutation.  The order 2**32 figure is correct if your
generator is a random function, but only a small fraction of
functions are permutations.


Call the first value to repeat x(i)=x(j), and let's say i<j
without loss of generality.  Lets call the starting value
x(1).

Now suppose i <> 1, that is the cycle didn't start from the
first value.

If you decrypt x(i) you get x(i-1) and if you decrypt x(j) you
get x(j-1), and since x(i)=x(j) we must have x(i-1)=x(j-1).

But then x(i)=x(j) can't be the first value to repeat--a
contradiction.

Block ciphers are invertible, so they form permutations, and
permutations decompose into cycles.  As you generate more
values, the only possible repeat is the value which started
the sequence.


I'll now prove my claim:

IF S is a set N elements, 
x is an an element of S, 
P is chosen at random from a uniform distribution of all
permutations on P,

THEN then expected length of the cycle containing x is
(N+1)/2.

PROOF: Let's count the number of permutations of S in which
the fixed element x is in a permutation of length n.

First we partition S into elements in the cycle containing
x, and all other.  We know x is in its own cycle, so we 
choose n-1 other elements from the N-1 elements of S-{x}.
There are  "N-1 choose n-1" 
=  (N-1)! / (N-1-(n-1))!*(n-1)! = (N-1)! / (N-n)!*(n-1)! 
ways to do this, if n is between 1 and N inclusive, 
0 if n is outside this range.

The n-1 elements in x's cycle can follow x in any of (n-1)!
different orders.

The other N-n elements of S can form there own permutation
in any of (N-n)! ways

Thus there are 
(N-1)!/(N-n)!(n-1)! * (n-1)! * (N-n)! = (N-1)!
permutations of S in which x is in a cycle of length n,
if 1<=n<=N, 0 if n<1 or n>N.

Since we choose a permutation from the uniform distribution,
the chance of x being in a cycle of length n is this number
divided by the total number of permutations of S.

The probability Q(n) that x is in a cycle of length n is:
   (N-1)!/N! = 1/N   if  1 <= n <= N
                0    otherwise.

(All possible cycle lengths are equally likely.)

The average cycle length is therefor:
   __
   >      1/N i    = 1/N (N*(N-1))/2 = (N-1)/2.
   --
   i=1..N


--Bryan Olson


