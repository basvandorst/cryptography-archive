Newsgroups: sci.crypt
Path: msuinfo!agate!ihnp4.ucsd.edu!swrinde!pipex!uknet!EU.net!uunet!news.unr.edu!jimi!ftlofaro
From: ftlofaro@unlv.edu (Frank Lofaro)
Subject: Public-key crypto dead?! (Re: New Factoring Method via Chaos?)
Message-ID: <1994May29.052822.24464@unlv.edu>
Sender: news@unlv.edu (News User)
Organization: University of Nevada, Las Vegas
References: <nagleCpACIE.G4v@netcom.com> <a_rubin.769470113@dsg4.dse.beckman.com> <27987@alice.att.com>
Distribution: inet
Date: Sun, 29 May 94 05:28:22 GMT
Lines: 44

In article <27987@alice.att.com> shor@alice.att.com (Peter Shor) writes:
>In article <a_rubin.769470113@dsg4.dse.beckman.com>, a_rubin@dsg4.dse.beckman.com (Arthur Rubin) writes:
>> In <2rgh3l$rie@news.delphi.com> edfromnj@news.delphi.com (EDFROMNJ@DELPHI.COM) writes:
>> 
>> >This week's science news has a good general article on quantum computing.
>> 
>> ...
>> 
>> >My question is - could a quantum computer be simulated in software?
>> 
>> No.
>> 
>
>
>I should try clearing up some of the misconceptions that are multiplying
>on sci.crypt on quantum computers.  So far, the only things quantum
>computers are known to do in polynomial time that cannot be done
>on regular computers are a few contrived-looking problems, factoring, and
                                                            ^^^^^^^^^
>discrete logarithms.
 ^^^^^^^^^^^^^^^^^^^

This seems to possibly be _VERY BAD_ news!
Factoring and discrete logarithms in polynomial time.
Factoring being easy destroys RSA and Rabin utterly. Discrete logarithms 
destroys ElGamal and Diffie-Hellman utterly.
Seems like all of public-key crpyto is going up in smoke.
(The NSA will be pleased)

Are there any other algorithms for public-key that do NOT depend on 
factoring or discrete logarithms? In other words:

Are there other algorithms such that one may "easily" generate P(x) and S(x) 
at the same time, and make P(S(x))=x and S(P(x))=x, have both P(x) and S(x) 
work for all values of x, and have revealing P(x) NOT reveal S(x)?

To authenticate one uses S(x), to encrypt one uses P(x).
To verify one uses P(x), to decrypt one uses S(x).
S(x) is the secret operation, P(x) is the public operation.

There would be some usefulness to an algorith that didn't support all of the
above. If S(P(x)) works it will work for encryption and if P(S(x)) works, 
it will work for authentication.

