Path: msuinfo!agate!howland.reston.ans.net!pipex!lyra.csx.cam.ac.uk!mrr
From: mrr@cl.cam.ac.uk (Michael Roe)
Newsgroups: sci.crypt
Subject: Re: DES CBC implementation
Date: 17 May 1994 16:21:17 GMT
Organization: U of Cambridge Computer Lab, UK
Lines: 57
Distribution: world
Message-ID: <2raqtt$c31@lyra.csx.cam.ac.uk>
References: <1994May17.140729.11739@fokus.gmd.de>
NNTP-Posting-Host: smew.cl.cam.ac.uk
Keywords: DES, CBC, IV

> Which of the following is secure, which are not (and why
> not, or references, if possible)?
>
> 1) Use secret IV (undesirable, since it requires distributing
>   more information).
>
> 2) Use completely random IV, in plaintext.
>
> 3) Use random IV for first packet, with subsequent
>   packets containing an IV predictable from the first
>   (in plaintext).
>
> 4) Use known IV, prefix data with random initial N bytes.


Assuming the first 64 bits of the plaintext has similar statistics to the rest,
these methods are all roughly equivalent: once you've started the block chaining
going, they're all the same and are all vulnerable to the same attacks.

The only differences I can think of are in vulnerability to known-plaintext
attacks on the first block.


Method (1) (secret IV) gives slightly better protection than method (2)
*if* the first 64 bits of plaintext is guessable by the attacker (e.g. it's a fixed
format packet header) *and* the rest of the plaintext isn't guessable. The secret 
IV scrambles the only piece of known plaintext the attacker has (by hypothesis).
If the attacker has some known plaintext further along in the message, the secret
IV doesn't help.


As far as I can see, method (3) (pseudo-random IV) is equally secure as method
(2) (plaintext IV). In both cases, the IV is known to the attacker. In both cases,
the IV changes every time so the attacker can't build up a useful dictionary of
plaintext-ciphertext pairs.

(4) is equivalent to (2). To see this, just imagine that the random IV in method
(2) is in fact generated by taking a another random number, xoring with a constant
and then encrypting; this gives you method (4).

Method (2)                  Method (4)
C[0] = IV                  C[0] = ENC(IV' ^ R)
C[1] = ENC(D[0] ^ C[0])    C[1] = ENC(D[0] ^ C[0])

By the way, the ``Internet Security Architecture'' draft RFC (currently
circulating amongst its authors in very rough draft form) contains some text
giving advice on just this issue (cipher chaining modes for real-time audio and
video). In the light of this discussion, I think what it says on this point 
could do with being expanded a bit ... I'll suggest it at the next editing
meeting...


Michael Roe
Computer Security Group
Cambridge University Computer Laboratory


