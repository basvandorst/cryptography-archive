Path: msuinfo!agate!howland.reston.ans.net!pipex!uknet!EU.net!uunet!mnemosyne.cs.du.edu!nyx10.cs.du.edu!not-for-mail
From: colin@nyx10.cs.du.edu (Colin Plumb)
Newsgroups: sci.crypt
Subject: Re: PGP and RSA implementatio
Date: 15 May 1994 12:28:55 -0600
Organization: /usr/lib/news/organi[sz]ation
Lines: 119
Message-ID: <2r5pl7$lrt@nyx10.cs.du.edu>
References: <17.14639.864.0N640CE5@almac.co.uk> <1994May8.163728.28414@mnemosyne.cs.du.edu> <2qjkiuINNbdi@flop.engr.orst.edu>

In article <2qjkiuINNbdi@flop.engr.orst.edu>,
scott johnson <johnsos@holmes.ece.orst.edu> wrote:
>In article <1994May8.163728.28414@mnemosyne.cs.du.edu>,
>Colin Plumb <colin@nyx10.cs.du.edu> wrote:
>>
>>To the best of todays knowledge, the IDEA algorithm is harder to break
>>than the RSA key sizes used in PGP.  Thus, RSA is the weak link, not
>>IDEA.
>
>Depends on what size key you use.  A 384-bit key is a toy--anyone determined
>enough to break it can.  It will keep your big brother out, but a determined
>adversary will laugh at a 384-bit key.

The estimate I saw (and warning, extrapolating factoring efforts this far is
not very reliable) equates 128-bit IDEA to 3100-bit RSA.

>A 1024 bit key, on the other hand, would be difficult for anyone to break.
>Certain groups, such as the NSA, MIGHT be able to do it, but it would cost them
>a lot of time and $$$$$$.

Oh, it is.  Just not as difficult as 128-bit IDEA.
>
>>Public-key ciphers are, by most definitions of a cipher, bad ciphers.
>
>Oh, really?  

Yes, really.

>>You have to be very careful in how you use them of they leak information,
>
>Which information do they leak?  They give you a modulus to factor, I'll agree.
>But factoring a 1024-bit modulus is, shall we say, NOT a trivial problem.

Okay, here's an example.  If you know the plaintext/ciphertext pairs
p1/c1 and p2/c2, with the same public key, then p1*p2/c1*c2 is also a
pair.  So if you want to decrypt c1 to get p1, and can generate a p2/c2
pair (if c2 doesn't matter, this is trivial; just pick a random p2 and
encrypt it), such that I'll decrypt c1*c2 into p1*p2 for you, you can
divide p1*p2 by p2 and recover p1.  This is why PGP has all that
padding inside RSA blocks, so that you can't generate a legal c1*c2
pair.  You never publish the result of decrypting a key, so that's less
important, but "signing" is essentially decrypting, and the result is
published, so the signature format is especially rigid.

There are many other problems, mostly stemming from the mathematical structure
of the algorithm, but this is the simplest.  From the latest journal of
cryptology, here's a simple key-distribution algorithm and a hole in it:

Problem: A and B wish to establish a shared session key, but only a trusted
host H has the horsepower to perform an RSA decryption.

Protocol:
A generates a random number N1, RSA-encrypts it to H, and sends it to
the host along with B's name.

H asks B for a session key to use to communicate with A.

B generates a random N2, the session key, RSA-encrypts it to H, and sends
it.

H adds N1 and N2, and sends the result to A.  (This is a one-time pad,
so it's secure without using a fancier algorithm.)

A subtracts N1 from N1+N2 to get N@, the shared key between itself and B.


Can you see the hole?  It's based on what's described above.  If two other
hosts on the network, C and D, are in cahoots (or any active eavesdropper
who can emulate them), they can get the host H to RSA-decrypt an arbitrary
number by sending it as the encrypted N2.  By multiplying in a random
confounding factor, C and D can disguise the decryption so that H cannot
detect the fact that it is "in effect" decrypting something else.

>
>>the key is much bulkier than you need to achieve that level of security,
>>and they're slow as molasses.
>
>This is the major problem right now with public key cryptography.  However, 
>this problem is a topic of much research, and performance increases are being
>reported all the time.

Really?  *Speed* increases, I keep seeing, but I haven't seen much progress
on the *size* issue.  There are plenty of public-key algorithms with much
*larger* keys than RSA, but given that factoring and the discrete log
problem are comparable in computational complexity, I don't expect much
smaller keys until someone finds a new problem to base a public-key algorithm
on.

>>The only savingg grace, and why PGP uses public-key crypto, is that it
>>has this superbly useful public-key property.  But beecause the cipher is
>>so bad in other ways, you want to use it as little as possible.
>
>Again, why is RSA so bad?  Until someone comes out with a tractable factoring
>algorithm (i.e. polynomial with respect to the number of bits in the modulus),
>or shows another way to crack RSA in reasonable time, the advantage is always
>to the crpytographer.  Doubling the key length makes the cryptanalysts job
>much harder by orders of magnitude.

Mostly for the reasons enumerated above.  The key is ridiculously large
for the security you get (like the 26! possible monoalphabetic
substitution keys, compared with the fact that you can break it with
pencil and paper), and that it leaves you open to all sorts of protocol
failures.  The multiplication attack described above is the basis of a ot
of them, but there are other chosen ciphertext attacks that will let
you factor the modulus, and the multiplication method lets you hide the
fact that you're trying them.

>>But while it can be argued that having more links is undesirable,
>>minimizing the use of straight public-key crypto is very desirable,
>>and the additional link added (IDEA, for example) is not in any danger
>>of being a weak link as far as we know.
>
>Convince me that public key is weak.  

Any cipher is presumed weak until proved strong.  I can argue (based on
published attack attempts) that IDEA is strong.  But if you can find
similar references for RSA, I'll be amazed.
-- 
	-Colin
