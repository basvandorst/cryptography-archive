Path: msuinfo!agate!howland.reston.ans.net!europa.eng.gtefsd.com!MathWorks.Com!zombie.ncsc.mil!golf!mizzou1.missouri.edu!C445585
From: C445585@mizzou1.missouri.edu
Newsgroups: sci.crypt
Subject: Re: Encryption from Hash Functions
Date: Mon, 21 Mar 94 21:41:35 CST
Organization: University of Missouri, Columbia
Lines: 32
Message-ID: <16F8013110S86.C445585@mizzou1.missouri.edu>
References: <CMvq7M.K38@hpcvsnz.cv.hp.com> <16F7ECD0AS86.C445585@mizzou1.missouri.edu> <Cn14v1.HKC@hpcvsnz.cv.hp.com>
NNTP-Posting-Host: mizzou1.missouri.edu

In article <Cn14v1.HKC@hpcvsnz.cv.hp.com>
ericb@lsid.hp.com (Eric Backus) writes:
 
[Description of the scheme I talked about previously deleted.]
>Interesting, this is a twist I hadn't thought of.  However, you have
>to be sure to never re-use the X(i), so you have to do at least one
>hash calculation for each output byte.  Building a table ahead of time
>just moves this calculation around, but does not shorten or eliminate
>it.
 
   This seems to have three traits:
 
1.  The sender has lots of work to do to encrypt.  This can be done ahead
    of time, using a pretty standard tradeoff of memory for speed.  The
    sender also seems to require a good source of random bits.  (I'm not
    entirely sure he couldn't make do with a pseudorandom source, or
    even with a non-repeating source like a long counter.  That looks a
    lot weaker, at first glance, though.)
2.  The receiver has relatively little work to do.
3.  The scheme seems to be very hard to invert.
 
>2. The encrypted message is n/m times as long as the input.  At least
>   in my mind, this is a major problem.
 
   It may be.  I think all randomized encryption schemes involve expansion
of the message.  Depending on the application, this may or may not be a
problem.
 
>                                Eric Backus
>                                ericb@lsid.hp.com
 
   --John Kelsey, c445585@mizzou1.missouri.edu
