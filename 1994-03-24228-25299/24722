Path: msuinfo!agate!howland.reston.ans.net!cs.utexas.edu!not-for-mail
From: boucher@csl.sri.com (Peter K. Boucher)
Newsgroups: sci.crypt
Subject: Re: YASR (Yet Another Secure RNG)
Date: 15 Mar 1994 14:55:21 -0600
Organization: UTexas Mail-to-News Gateway
Lines: 68
Sender: daemon@cs.utexas.edu
Message-ID: <9403152055.AA23352@redwood.csl.sri.com>
NNTP-Posting-Host: cs.utexas.edu

Here's the meat of the algorithm:

1) There's a table containing 256 permutations of the numbers 0-31.
2) There are two additive congruential generators based on the
   irreducible trinomials X**839 + X**54 + 1, and Y**719 + Y**150 + 1,
   respectively.
3) The output of the two additive congruential generators is combined
   in the following way: output = (((x<<9)^(x>>23)) + ((y<<18)^(y>>14))),
   where x comes from generator 1, and y comes from generator 2.
4) The table is used to select an ordering for 32 of the combined outputs.
5) The tables is also used to select an ordering for 32 such groups of
   32 combined outputs, giving 1024 "shuffled" outputs.

Here are the two routines used to generate the output.

====================== BEGIN SOURCE CODE FRAGMENT ======================
static unsigned long
fill_rands()
{
    register unsigned char *optr1, *optr2;
    register int i, j;
    register unsigned long x,y;
    register unsigned long *rptr;

    optr1 = otab[(indexr1 = (1103515245 * indexr1 + 12345))>>24];
    for (i=32; i--;) {
        rptr =  /* select a group of 32 outputs to fill in */
               &(rands[((unsigned int)(*(optr1++)))*32]);
        optr2 = /* select an order to fill in those 32 outputs */
               otab[(indexr2 = (1103515245 * indexr2 + 12345))>>24];
        for (j=32; j--;) {
            x = (*frnt0 += *rear0); /* generator 1 */
            y = (*frnt1 += *rear1); /* generator 2 */
            rptr[*(optr2++)] = (((x<<9)^(x>>23)) + ((y<<18)^(y>>14)));

            if(  ++frnt0  >=  end0  )  { /* update generator 1 ptrs */
                frnt0 = state0;
                ++rear0;
            } else  {
                if(  ++rear0  >=  end0  )  rear0 = state0;
            }
            if(  ++frnt1  >=  end1  )  { /* update generator 2 ptrs */
                frnt1 = state1;
                ++rear1;
            } else  {
                if(  ++rear1  >=  end1  )  rear1 = state1;
            }
        }
    }

    num_rands = 1023;
    rand_ptr = &(rands[1]);
    return( rands[0] );
}

unsigned long
rand32()
{
    return( (num_rands--) ? *(rand_ptr++) : fill_rands() );
}

======================= END SOURCE CODE FRAGMENT =======================


-- 
Peter K. Boucher
--
DISCLAIMER:  The above does not represent the opinions of my employer.
