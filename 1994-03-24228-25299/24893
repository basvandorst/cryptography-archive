Path: msuinfo!agate!library.ucla.edu!galaxy.ucr.edu!ucrengr!datadec
From: datadec@ucrengr.ucr.edu (Kevin Marcus)
Newsgroups: sci.crypt
Subject: Re: Text encryption
Date: 20 Mar 1994 20:23:01 GMT
Organization: University of California, Riverside   (College of Engineering/Computer Science)
Lines: 75
Message-ID: <2mibb5$bem@galaxy.ucr.edu>
References: <1994Mar20.074131.24538@princeton.edu>
NNTP-Posting-Host: ucrengr.ucr.edu

In article <1994Mar20.074131.24538@princeton.edu>,
Craig John Douglas Webster <cwebster@tucson.Princeton.EDU> wrote:
>Hello, everyone.
>
>Well, I read the FAQ and this doesn't appear to be on it, so here goes:
>
>I was wondering if people out there might be able to give me methods for
>simple (most important) and reasonably quick (next most important)
>reasonably secure (least important) encryption of text, preferably
>without first translating the text into numbers.  The most obvious
>method, I think, is letter substitution, sometimes with multiple letters
>substituted.  I was wondering if there is anything else more secure and
>as simple.

Letter substitution is known as a Caesar's Cipher.  These should keep
basic intruders away who don't know what they are doing, but it is not very
secure.  If there were enough multiple letter substitutions, then it
could be 'more' secure, but still relatively simple, especially if someone
knows how your data is encrypted.  (Or has a copy of the encryption 
program).

A much more simple method (which is still crackable, but not intuitively
obvious!) would be to do something like XOR/ADD/XOR/SUB or some similar
combination.  The text would need to be translated into numbers in the
sense of a computer, but you could still print things out in ASCII.

With a variable length password, and by choosing some neat permutations
of the password, you can get some interesting results far more than
necessary to keep an average hacker away.  

LET X() be an XOR
LET A() be an ADD
LET S() be a SUB.

For now, we will use bytes, but these could be made a little more
confusing by using words and swapping bytes in words.

Example: 

THIS TEXT WILL BE ENCRYPTED

with the password, say, "KEY".  
let "ct" refer to an index into the ciphertext -->
ct[0]=T X(K) A(K) X(K) S(K)
ct[1]=H X(E) A(E) X(E) S(E)
ct[2]=I X(Y) A(Y) X(Y) S(Y)
ct[3]=S X(K) A(K) X(K) S(K)  
ct[4]=  X(E) A(E) X(E) S(E)
ct[5]=T X(Y) A(Y) X(Y) S(Y)

and so forther... or you could flip the key around backwards, such that:

ct[3]=S X(Y) A(Y) X(Y) S(Y)
ct[4]=  X(E) A(E) X(E) S(E)
ct[5]=T X(K) A(K) X(K) S(K)

Throwing in some modulus division and you've got a pretty secure 
encipherer.

The decipher this text, simply perform the operations reverse --
so instead of X A X S, you would use A X S X.

Hope this helps some.
  
>Thanks.  Email would be nice, but I'll try to read this group for
>replies.

I will email you this exact reply as well.


-- 
  --=> Kevin Marcus:   datadec@ucrengr.ucr.edu,  tck@bend.ucsd.edu
  CSLD Room Monitor, Tues, Thurs 9-12p, Sat 11a-2p (909)/787-2842.
  Computer  Science  Dept.,  University of California,  Riverside.
  .oOo.oOo.oOo.     Thieves Suck.   Don't steal.     .oOo.oOo.oOo.
