Newsgroups: sci.crypt
Path: msuinfo!news.mtu.edu!sol.ctr.columbia.edu!news.kei.com!MathWorks.Com!europa.eng.gtefsd.com!howland.reston.ans.net!cs.utexas.edu!uunet!mnemosyne.cs.du.edu!nyx10!colin
From: colin@nyx10.cs.du.edu (Colin Plumb)
Subject: Re: Triple-DES in CBC mode
Message-ID: <1994Mar21.201807.18281@mnemosyne.cs.du.edu>
X-Disclaimer: Nyx is a public access Unix system run by the University
 	of Denver for the Denver community.  The University has neither
 	control over nor responsibility for the opinions of users.
Sender: usenet@mnemosyne.cs.du.edu (netnews admin account)
Organization: Nyx, Public Access Unix at U. of Denver Math/CS dept.
References: <9403170117591.davesparks.DLITE@delphi.com> <2ma2m7$8bc@transfer.stratus.com>
Date: Mon, 21 Mar 94 20:18:07 GMT
Lines: 67

In article <2ma2m7$8bc@transfer.stratus.com>,
Carl Ellison <cme@galt.sw.stratus.com> wrote:
>and I now advocate, for security,
>
>	COMPRESS|DES|PRNGXOR|TRAN|nDES|TRAN|DES
>
>where the DES steps are ECB, PRNGXOR masks plaintext repeats, TRAN transposes
>a large block of bytes (8KB in the one posted here) and nDES cycles through
>n different DES keys (using one key for each 64-bit block, then going to
>the next one).

One "smoothing" operation that I like is a scrabler polynomial, as used
by modems and telecommunications equipment worldwide.  You can do it
either bitwise, using the standard CRC tables:

word32
scramble(word32 state, unsigned char *buf, unsigned count)
{
	while (count--)
		state = state<<8 | crctable[*buf++ ^= state>>24];
	return state;
}

word32
unscramble(word32 state, unsigned char *buf, unsigned count)
{
	register unsigned char t;

	while (count--) {
		t = *buf;
		*buf++ = t ^ state>>24;
		state = state<<8 | crctable[t];
	}
	return state;
}

(That's off the top of my head; I think I got it right.)

There's also a faster word-wise variant, where you pick a trinomial
(something from Knuth's random number generator, such as 24 and 55)
and do:

cipher[i] = plain[i] + cipher[i-24] + cipher[i-55];

to scramble, and

plain[i] = cipher[i] - cipher[i-24] - cipher[i-55];

to unscramble.  In truth, you can use much smaller numbers, and keep the
whole thing in registers.  This does a decent job of rendering the
text more random.  It propagates errors infinitely far forward when
scrambling, but only requires a finite (32 bits in the first case, 55
words in the second) amount of history to recover.

It *is* a random number generator, but also data-dependent.  Thus, the
final state is a checksum of all of the data involved.  SFS uses this
technique to generate an IV for encrypting a sector, so if any bit of
the sector changes the IV changes.  (Encrypting related messages with
the same key and IV is dangerous because common prefixes are revealed.
And in a disk encryptor, there is no place to put a random IV.)

I've been trying to come up with a TRAN-like thing that doesn't
have block boundaries; rather, it just guarantees that each byte
is within a certain distance of where it "should" be.  But edge
effects (what do you do at the beginning and end) are the bogeyman.
-- 
	-Colin
