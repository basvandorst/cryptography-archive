Newsgroups: sci.crypt
Path: msuinfo!agate!usenet.ins.cwru.edu!nigel.msen.com!math.fu-berlin.de!jiri
From: jiri@kirk.chemie.fu-berlin.de (Jiri Pittner)
Subject:  Net security, another login method proposed
Message-ID: <CDGMBC9O@math.fu-berlin.de>
Keywords: public key security password
Sender: news@math.fu-berlin.de (Math Department)
Nntp-Posting-Host: kirk.chemie.fu-berlin.de
Organization: Free University of Berlin, Germany
References: <2kqv06$p29@xdm001.ccc.cranfield.ac.uk> <Feb.28.17.40.43.1994.18619@romulus.rutgers.edu>
Date: Tue, 1 Mar 1994 09:47:13 GMT
Lines: 63

wclark@romulus.rutgers.edu (Bill Clark) writes:

>aa932461@cranfield.ac.uk (N.J.DULLAWAY) writes:

>>1) Machine 1 requests access to Machine 2.
>>2) Machine 2 sends a public key and request for logon id and password.
>>3) Machine 1 sends encrypted logon and password.

>This is similar to how the Kerberos (created at MIT) works... the problem is
>that it is difficult to implement this software between different systems --
>not due to software but human conventions.  A system that didn't use
>Kerberos wouldn't be able to access one that did, and the system that does use
>it wouldn't want to even allow ones that didn't to access it.  There's no
>way to incorporate backwards compatability into the scheme without losing 
>just about all of the benefits, so people are slow to adopt it.  Pretty 
>impressive that someone who knows "little" about encryption and the protocals
>could come up with this independantly... maybe you should go work for MIT.

>bill clark
>rutgers university


The scheme described here has according to my oppinion a weakness:
there is no 'session key' - if somebody captures the data sent in step 3,
he can get access to machine 2 (until it changes its public-private keys or
until the user changes its password.) Or is there in Kerberos some 'session key'?

Also I think it should be possible to combine old 'classical logins' and new logins.
I would propose the following scheme:

1)Machine 1 sends either old login request (in telnet protocol for example)
  or new login request (to a different port? ) and its public key (P1).
2) Machine 2
   a) does not know new protocol - does not respond - user has to use option
      for old login or login can authomatically attempt old method after some
      timeout.
   b) supports new protocol: generates small truly random session key - one time pad
      or at least randomly initialized good pseudorandom session key
      Then it sends the otp session key, request for user-id and password 
      - all this encrypted by public key of machine one - P1.
3) Machine 1 decrypts the message from machine2,
   requests user for his login and password on mach.2, xors the password with the OTP
   session key and finally even encrypts all this (and some additional information
   if necessary) with public key of machine 2 (P2). 
   It would be also possible to generate larger OTP and xor it also with user-id and avoid public key encryption with P2.
4) Machine 2 decrypts message from M1 with its private key, makes xor against
   the OTP and used user-id and password to authentication like in the case
   of local login. Of course, when such work was spent to secure communication,
   the local authentication should be at triple des with long 'salt' and hidden
   encrypted passwords (like in 'trusted systems').

Also it is necessary not to forget on programs like 'passwd' to use some
secure protocol when they are used in remote login session.

Any comments and suggestions are appreciated.

Jiri Pittner
jiri@kirk.chemie.fu-berlin.de

--
Jiri Pittner

jiri@kirk.chemie.fu-berlin.de
