Path: msuinfo!agate!howland.reston.ans.net!europa.eng.gtefsd.com!MathWorks.Com!zombie.ncsc.mil!golf!mizzou1.missouri.edu!C445585
From: C445585@mizzou1.missouri.edu
Newsgroups: sci.crypt
Subject: Re: Encrypt in IDEA w/ msg's own hash
Date: Fri, 04 Mar 94 18:03:29 CST
Organization: University of Missouri, Columbia
Lines: 53
Message-ID: <16F6FFDF3S86.C445585@mizzou1.missouri.edu>
References: <2l6sch$hdl@scratchy.reed.edu>
NNTP-Posting-Host: mizzou1.missouri.edu

In article <2l6sch$hdl@scratchy.reed.edu>
dsquirre@reed.edu (Douglas Squirrel) writes:
 
>
>Given: a brief text file.
>1. Calculate its md5 hash.
>2. Use this hash as a key for IDEA and encrypt the file.
 
>My intent is to make a pass phrase verification file, so I don't occasionally
>goof when encrypting and lose data to a typo in the pass phrase.  (I hate
>typing it twice.)
>I'll apply the above to my pass phrase once and save the result as a verifi-
>cation file. Then when I want to encrypt, the program will hash what I type in
>and use that to decrypt the verification file.  If the result is the same as
>what I just typed in, I must have gotten it right.
>However, I don't want to endanger my pass phrase.
 
   Hmmm.  Let's see if I'm understanding this:
 
1.  The first time you use a new password, you store it in a file,
    calculate the md5 hash of that file, and then encrypt the file,
    using the md5 hash as the key.  This can then be used to verify
    that you got the right password typed in, since:
 
2.  When you type in your password, you hash it with md5, and then
    decrypt the password file you had written before with the md5
    hash of the currently entered password as the key.
 
    This should work OK, but I'm a bit curious:  what are you using the
    password for?  If you're using that password to encrypt a different
    file, wouldn't it make more sense to simply stick a few bytes at
    the beginning of the file, before encrypting, so that you know after
    decrypting them that you're using the right key?  For example,
    if you always generated a random 32-bit integer, P0, and then chose
    a second integer, P1, so that P0+P1 = 2**32-1, you would only have
    one file to deal with, and when you decrypted the first 64-bits,
    you'd know that the chances that your password was right were very
    good.  (Probability that you'd get P0+P1=2**32-1 from two random
    32-bit words is 1/(2**32), unless I'm goofing up the math.)
 
    If you're using this scheme to simply check a user-entered password,
    again, it sounds like it'll work, but I don't see why you don't just
    store the md5 hash somewhere.  That would allow an attacker who broke
    onto your system to get the md5 hash of someone's password, but that
    shouldn't give them any real help in finding a password that hashes to
    that value.  (Ideally, you'd also want to include a "salt," randomly
    generated each time the password was changed, so that the hash stored
    is userid:salt:md5(salt,passphrase).)
 
>Email or news responses much appreciated.
>--dsquirre@reed.edu
 
   --John Kelsey, c445585@mizzou1.missouri.edu
