Path: msuinfo!agate!howland.reston.ans.net!noc.near.net!news.delphi.com!usenet
From: kinglark@delphi.com
Newsgroups: sci.crypt
Subject: mathematically unbreakable codes and RNG
Date: Tue, 8 Mar 94 20:30:00 -0500
Organization: Delphi (info@delphi.com email, 800-695-4005 voice)
Lines: 227
Message-ID: <RYwoXno.kinglark@delphi.com>
NNTP-Posting-Host: bos1b.delphi.com

An encryption system is mathematically unbreakable if computations alone cannot
break it.  Therefore, it is harmless to assume that the codebreaker possesses
infinite resource and infinite computational power.  We also assume that the
encryption key is known only to the owner and that the codebreaker knows the
encryption algorithm and possesses all possible plaintexts and ciphertexts
actually produced by the encryption system, namely, an infinite capability to
spy.  If one has an infinite capability to spy, one needs not break anyone's
codes.  Therefore, the latter assumption is for mathematic discussion only.
Here we shall show that mathematically unbreakable encryption system exists and
it is feasible to build one as well.

If one has infinite computational power, one may try to break the system by
trying out every key.  To do so, one needs at least a block of ciphertext, C,
and its plaintext T, C=f(k,T), let's call them a sample.  If there are many k's
meeting the condition, then one needs more samples until a unique k is found.
If the number of samples exceeds, e.g., gN, where g>=0.9 and N is the number
of all possible samples, then the exhaustive trial approaches the dictionary
attack, which can break any codes.  Therefore, we can define an encryption
system mathematically unbreakable if the number of samples needed to break the
codes approaches the number of entries in the dictionary of the encryption
system.  In other words, a mathematically unbreakable encryption system is a
system in which one cannot derive data not yet known from known data.

One may argue that f(k,T) has only one parameter and hence we need only one
sample to define it.  This observation is superficial.  The key, k, may be a
parameter or an index to an array of parameters.  For example, in the DES, each
round of iteration uses eight s-boxes to convert a 32-bit block into itself.
The eight s-boxes are selected from four known s-boxes in any order and any
mixture, a total of 64k possible combinations, or an array of 64k components,
and a sixteen-bit key is assigned to select one of the combinations.  The DES
makes sixteen iterations and has, therefore, a possible one million components.
We might need one million samples to break the DES, if the components were
independent.

Let's examine the allegedly unbreakable one-time-pad encryption system.  If we
have i samples, then we can compute i keys.  If one can compute future keys
from i known keys, one breaks the system.  On the other hand, if one can build
a function to generate keys which cannot be derived from any number of already
generated keys, then one knows how to build a mathematically unbreakable
function and, hence, a mathematically unbreakable encryption system.  So why
bother with the clumsy one-time-pad.  Therefore, we may define a random number
generator or random function quantitatively as a function with more independent
parameters than the number of elements it generates.  Obviously, random number
generator and mathematically unbreakable encryption system are of the same
issue.

One of the famous random number generators is CRC and it has passed many
statistic tests.  However, CRC is functionally equivalent to the high school
mathematics of z=ax+y.  The problem has three variables and one can compute any
one of them from two known ones.  The only difference here is that CRC is
computed in a finite field and if the unknown is not in the field, then we may
not have a unique solution.  Therefore, CRC is not much of a random number
generator.  The statistic tests of randomness are mathematic jokes.

For example, if we roll a balanced dice of N faces N times, some faces may show
up more than once and some may not show up.  If we assign  binary numbers with
most 1's to those faces that appears most times and binary numbers with most
0's to those faces that do not show up,  then the sequence of these binary
numbers cannot pass the statistic tests because there are too many 1's in the
sequence.  As a result, randomness depends on how we assign numbers to events,
not on the events themselves.  That is absurd, because it is not the numbers
that are random, but the events represented by the numbers are random.

Rolling a dice of N faces N times represents a function that maps a set of N
elements one-to-one onto or into itself (invertible or otherwise).  Every
function has equal probability to show up in a rolling dice experiment.  At the
ground level, we cannot tell which function is more random than the other.
However, at the next level, we study the properties of functions.  If a
majority of functions possess a certain property, then this property probably
shows up in the function produced by rolling dice or randomly selected from all
possible functions and, hence, is more random than functions that do not have
this property.  There are two cases, one is the case of invertible functions,
which also represent permutations, and the other is non-invertible functions.
We shall discuss each case separately.

A cipher function is invertible and the interesting property is how many
samples are needed to define a cipher function.  That problem can be solved by
counting.  We may consider C=f(k,T) as a curve in a space of N points.  If the
function is completely defined by its value at any point, then we have N
functions.  If it is completely defined by no more than two points, then, at
the second point, it can take any value other than the value it has taken at
the first point because the function is invertible, namely, there are N(N-1)
possible functions and so on, and there are a total of N! functions completely
defined at no more than N-1 points.  There are N(N-1)...((1-g)N+1) functions
completely defined at no more than gN points, where g<1, e.g., g=0.9.  The
density of these functions, namely, the ratio between the number of these
functions to the number of all possible functions, is 1/(((1-g)N)!), and if
(1-g)N is much large than 1, e.g., (1-g)N>10, (if g=0.9, then N>100), then the
ratio is practically nil.  In other words, almost all the cipher functions are
mathematically unbreakable.

The above conclusion is also valid for non-invertible functions.  However, we
have a much useful property for non-invertible functions.  The inverse image
of a non-invertible function is a collection of sets, S(y)={x|y=f(x)}, some of
which are empty, some have one elements, and some have more than one elements.
This idea is similar to the idea of scattering M elements into N buckets, a
random process, a problem found in hashing.  The interesting problem is what
is the probability to find a bucket with k elements.  The problem has been
solved about a century ago in cookies experiments to find the probability that
k raisins is found in a cooky made from dough mixed with M raisins into N
cookies of equal size.  The probability distribution is Poisson distribution.
The problem in hashing and document digest can be easily solved by the above
conclusion.  For example, if we hash one million symbols (documents) into 2^64
buckets (signatures), then we have one chance in eight millions to find two or
more symbols (documents) in one bucket.  This is an important issue and should
be discussed separately.

A sequence of N numbers satisfying Poisson distribution is probably produced
by rolling a dice of N face N times.  However, we can produce it through
computations as well and there is no way to tell whether it is produced through
computations or rolling a dice.  However, if one wants more than N numbers, one
has to use a different function to produce the next N numbers.  Therefore,
there exist functions to produce a sequence of random number on a computer.

The abundance of mathematically unbreakable cipher functions does not
necessarily means that it is feasible to build one.  The feasibility of
building a mathematically unbreakable cipher function has been shown indirectly
by Persi Diaconis of Harvard University.  His analyses of card shuffling shows
that the distribution of a desk of cards shuffled more than seven times is
random.

Shuffling a desk of cards is to permute the positions of cards, namely, to put
a card at position x to position y through y=f(x), where f(x) is invertible,
the same as a cipher function.  Therefore, shuffling cards and data encryption
are identical.

Certainly, Diaconis's observation is valid only for 52 cards.  However, the
number of cards has little influence on the conclusion and the conclusion is
the direct consequence of the law of diminishing return.  Shuffling a desk of
N cards is a permutation of N symbols.  Permutations of N symbols are generated
by N-1 generators, each of which represents an independent parameter.  if we
pick a sequence of permutations arbitrarily, then the first one may contain a
number of generators, and the second one may contain a number of generators not
in the first one and so on.  Once the total number of generators reaches 90%
or more, then it becomes harder to get a new permutation that contains many new
generators and, as a result, the rate of improvement of the product of selected
permutations also diminishes rapidly, the law of diminishing return.

The number of selections needed to produce a mathematically unbreakable cipher
function depends on what is available for selections.  We produce these
elements with elementary operations and even shuffling machines have to rely
on these elementary operations as well.  The conclusion that we need seven
selections to reach our goal is very reasonable because, in the average, each
selection picks up less than 15% of the generators.  If we select elements
carefully, we may need only 3 to 4 selections, equivalent to 9 to 16 random
selections because of the theorem of random walk.

Now we need only to build seven cipher functions independently.  However, at
the current state of data encryption, we cannot do it, because there are only
two schools in data encryption, the school of Shanon based on the idea of
confusion and diffusion and the school of the DES.  To build a mathematically
unbreakable codes, we have to bring new blood into data encryption.

Data encryption is a mathematic problem, not a wheel-of-fortune-type-of-
guessing game as conventional cryptographers believe.  To understand data
encryption, we have to know at least the fundamental of mathematics.  At the
ground level, we have finite field theory and it is infeasible to produce a
mathematically unbreakable encryption system with elementary operations in the
field. A mathematically unbreakable encryption system can be produced at a
higher level, theory of groups, which deal with invertible functions.  A random
number generator can be produced with group algebra, also known as group ring.
Theory of groups and group algebra are well known subjects and should not be
discussed here.

The law prohibits export of data encryption products and data encryption
technology as well.  I do not want to get into trouble by discussing, even in
theory, how to build a mathematically unbreakable encryption here.  However,
I should like to discuss a few interesting issues.

A. A group is a set of elements closed under multiplication, * ,and inversion,
namely, if a and b are elements of the group, then a*b, b*a, a_ (the inverse
of a) are also elements of the group.  In general, a*b and b*a are distinct.
For example, a cipher function f(x) is an invertible mapping of a set or a
field one to one onto itself, y=f(x)=f( )x.  The last expression represents a
mapping as an operator in the field.  The inverse of the operator is x=f_( )y.
If g( ) and f( ) are mappings, then we define multiplication, g( )*f( ), as
substitution of variable, g( )*f( )x=g(f( )x)=g(f( ))x.  Therefore, cipher
functions form a group.  Let's call the minimum group that contains the cipher
functions of an encryption system the encryption group, which determines the
minimum mathematics needed to break the system, no matter whether the
encryption system is a group or not.  The effort to prove the DES is not a
group is a total waste.  Furthermore, the expression of data encryption as
y=f( )x reveals the essence of the problem, namely, to build codes, we compute
y=f(x), and to break the codes, we compute g(f( )), i.e., to compute the
algorithm that produce the codes.  To break an encryption system is inherently
much more difficult.

B. We have seen many claims that it takes millions of years to break a system
by trying out every key without mentioning that every key produce a distinct
cipher function.  For example, the knapsack public key algorithm has so many
keys that it is infeasible to break it by trying out every key, but Shamir has
found a way to find an equivalent key to break the system, because the system
has many functionally equivalent keys.  To make this kind of claims believable,
one has to show credible efforts have been made to assure that all keys are
probably distinct. If we generate cipher function using theory of groups, then
we can prove that all keys are distinct under certain conditions.  For example,
cipher functions, A(i, )*B(j, )*A_(k, ), are all distinct, if A(i, ) does not
belong to the normalizer of B(j, ).  Therefore, a mathematically unbreakable
encryption system is very easy to build.  In fact, we need only three selected
elements, A(i, ), B(j, ), and C(k, ), each of which needs only a few computer
instructions.

C. Cipher function A(i, )*B(k, )*A_(i, ), a conjugate of B(k, ), has the same
property as B(k, ) has.  If the latter is strong, so is the former.  If A(i, )
belongs to the encryption group of B(k, ), then the former is an element of the
encryption group, namely, B(k', )= A(i,)*B(k, )*A_(i, ), or else the new cipher
function is stronger than B(k, ).  If B(k, ) is the cipher function of the
proposed Clipper chip, an allegedly unbreakable system, then the new system is
also unbreakable, even if k is known and A(i, ) is designed by a high school
student, who is able to design y=A(i, )x=x+i.  Therefore, the Clipper chip
offers an unbreakable system to criminals and foreign agents at a bargain
price.  If NSA knew anything better, it would not propose the Clipper chip.

D. The RSA encryption system is also a group of M (=N here) elements, an
Abelian group to be exact, the simplest group.  To break the system, we have
to find prime factors of M, which determine the structure of the group, a
general property of groups (see Sylow theorems).  The encryption group for the
private-key system is generally not an Abelian group and M is generally
unknown.  To find prime factors of M, we have to find m such that
T=(f(k, )^m)T, because m-1 is a divider of M.  If M has only one prime factor,
then the group is known as a p-group and the system is always breakable.  For
a mathematically unbreakable system, the number of prime factors may exceed 10%
of all possible primes not larger than N.  After that, the codebreaker has to
have samples, a problem beyond the control of the codebreaker, and it may take
millions of years to collect sufficient samples.  The strength of a
mathematically unbreakable system is beyond the widest imagination of those who
consider the RSA system is strong.
