Path: msuinfo!agate!howland.reston.ans.net!math.ohio-state.edu!jussieu.fr!nef.ens.fr!vaudenay
From: vaudenay@dmi.ens.fr (Serge Vaudenay)
Newsgroups: sci.crypt
Subject: Re: Encryption from Hash Functions
Date: 19 Mar 1994 08:24:02 GMT
Organization: Ecole Normale Superieure, Paris, France
Lines: 69
Distribution: world
Message-ID: <2mecr2$5f5@nef.ens.fr>
References: <CMvq7M.K38@hpcvsnz.cv.hp.com>
NNTP-Posting-Host: morille.ens.fr

In article <CMvq7M.K38@hpcvsnz.cv.hp.com>, ericb@lsid.hp.com (Eric Backus) writes:
|> Due to rather stupid export laws in the US, it is illegal to export
|> encryption software.  However, it is NOT illegal to export hash
|> functions.  This got me to thinking: suppose we design an encryption
|> system that is extremely simple, and relies on a cryptographic hash
|> function for its strength?

Interesting idea! I am afraid exportation of hash functions may become
restricted in the next future :-)

|> Encryption Method
|> -----------------
|> 
|> 1.  Get a password from the user.

Let us call K = hash(password) the secret key!

|> 2.  Create a unique initial output block.
|> ...
|> 	out[1] = hash(time + hostname + pid + whatever_else)

We require it to be used only once! Let us call S = hash(K,out[1]) the session
secret key.

|> 3.  In a loop:
|> ...
|> 	out[i+1] = in[i] XOR hash(out[i] XOR hash(password))
|> 
|> Decryption is nearly the same as encryption:
|> 
|> 	out[i] = in[i+1] XOR hash(in[i] XOR hash(password))
|> 
|> That's it.  Quite simple, except for the hash function itself.

There is a slight problem here : hash functions usually reduces the size of
values. Your hash function is used as a one-way function with input of the
same size as output.

To correct it, for instance, we can decide out[i+1] = in[i+1] XOR hash(in[i],K).

Let K[i+1] be hash(in[i],K). Your scheme is a one-time pad with key K[i].
All K[i] are generated with hash used as a pseudorandom generator fed with
all previous data.

A problem is that an error in the transmission of in[i] (either in the encryp-
tion scheme, or in the decryption scheme) is fatal for the decryption. We can
not replace in[i] by C(in[i]) using the coding scheme of a linear code as we
give a way for the cryptanalyst to get a direct information about K[i+1] (like
its syndrom).

We can replace in[i] by out[i] : K[i+1] = hash(out[i],K).

Here we can notice that a key K[i+1] used several times can easily be detected
seeing identical out[i]. We can argue this occures with low probability, but we
can correct this weakness easily letting K[i+1] = hash(S,i,out[i]). We require
S to be processed first in the hash function.

|> 
|> Strength
|> --------
|> 

The requirement is that we can not get any computationnal information about
K[i+1] (that is a computable function f s.t. we know f(K[i+1]) with high proba-
bility) from all out[j] and even from all K[j+1] with j different from i.

Hope these comments will be useful!

  --Serge
