Path: msuinfo!agate!howland.reston.ans.net!gatech!udel!MathWorks.Com!blanket.mitre.org!linus.mitre.org!linus!mbunix!eachus
From: eachus@spectre.mitre.org (Robert I. Eachus)
Newsgroups: sci.crypt
Subject: Re: Hard instances
Date: 30 Mar 94 19:19:07
Organization: The Mitre Corp., Bedford, MA.
Lines: 57
Distribution: inet
Message-ID: <EACHUS.94Mar30191907@spectre.mitre.org>
References: <1994Mar28.110102.9143@martha.utcc.utk.edu> <2n7fkv$ppa@access1.digex.net>
	<EACHUS.94Mar29142111@spectre.mitre.org> <CnGzvF.D5E@dcs.ed.ac.uk>
NNTP-Posting-Host: spectre.mitre.org
In-reply-to: pdc@dcs.ed.ac.uk's message of Wed, 30 Mar 1994 09:04:26 GMT

In article <CnGzvF.D5E@dcs.ed.ac.uk> pdc@dcs.ed.ac.uk (Paul Crowley) writes:

 > There's something that worries me.  Is there a theoretical basis by
 > which I might be able to rate *instances* of a problem as "easy" or
 > "hard"?  For every instance of a problem, there is a program that finds
 > the solution in polynomial time; it consists of a large printf()
 > statement.  Most instances of factorisation are easy, so even if we
 > prove that factorisation is in ~P, we still won't know if the
 > factorisations needed to break RSA will always take exponential time.

   Bob Silverman addressed the "most instances of factorization are
easy comment, but let me talk about the more general problem in terms
of the knapsack problem.

   The general knapsack problem is to select, from a set of objects
with different weights and values, the set that fills the knapsack
with the most value subject to a weight constraint.  The specific form
used in the knapsack cipher had a shortcut.  The general problem was
hard, but it was very hard to find a problem which was not
partitionable.  For a simple example, lets say that the goal weight
is even.  Then there must be an even number of objects with odd
weights.  If the goal weight is odd, then there must be an odd number
of odd weighted objects.  Basically the "crack" of the knapsack cipher
was to find a set of such partitions such that for any given problem,
there was a high probability of getting one bit of useful information
toward a solution.

   Why didn't this help with P=NP?  The probability of finding
something useful depended on the fact that this problem was selected
to have a shortcut.  And this shortcut was a necessary part of the
private key.  Packing problems with no (known) shortcuts were not
usable in the cipher.

   The algorithms like RSA and Blum, Blum, and Shub, which depend on
factoring don't have this particular problem.  You don't need a
shortcut to factoring because you never factor.  The initial trapdoor 
is the multiplication of the large primes, and this does not have to
be reversed as part of the decryption.  (Unless you lose your secret
key!)
   
   Incidently, there is a nice proof in the Blum, Blum, and Shub paper
that there are no such shortcuts in their algorithm unless there are
shortcuts to factoring.  They do this by proving that any algorithm
for detecting non-randomness in the sequence--guess any answer to any
boolean question about the next number in the sequence with fifty per
cent plus epsilon probability of being correct--can be used to factor
numbers.  In other words if you can guess whether the next number
output from a (properly constructed, etc.) BBS generator will be odd
or even with a 51% chance of being correct, then factoring is in P.

--

					Robert I. Eachus

with Standard_Disclaimer;
use  Standard_Disclaimer;
function Message (Text: in Clever_Ideas) return Better_Ideas is...
