Newsgroups: sci.crypt
Path: msuinfo!agate!howland.reston.ans.net!europa.eng.gtefsd.com!MathWorks.Com!yeshua.marcam.com!charnel!olivea!sgigate.sgi.com!sgiblab!pacbell.com!att-out!cbnewsh!cbnewsh.cb.att.com!wcs
From: wcs@anchor.ho.att.com (Bill Stewart +1-510-484-6204)
Subject: Re: DES key encrypting itself?
Organization: AT&T Global Information Solutions, NCR's new name
Date: Sun, 27 Mar 1994 09:27:24 GMT
Message-ID: <WCS.94Mar27042724@anchor.ATT.COM>
Followup-To: sci.crypt
In-Reply-To: jgfoot@minerva.cis.yale.edu's message of Fri, 25 Mar 1994 11:15:11 -0500
References: <jgfoot-250394111511@silliman-college-kstar-node.net.yale.edu>
Sender: news@cbnewsh.cb.att.com (NetNews Administrator)
Nntp-Posting-Host: anchor.ho.att.com
Lines: 56

In article <jgfoot-250394111511@silliman-college-kstar-node.net.yale.edu> jgfoot@minerva.cis.yale.edu (Josh A. Goldfoot) writes:
   How much am I compromising security if I:
     1. Use DES to encrypt a file with a key K;  { E(F,K) }
     2. Use DES to encrypt the key with itself;  { E(K,K) }
     3. Put the encrypted key where anyone can find it, probably attached to
   the encrypted file somehow.

   My goal is to design a DES program that can tell you quickly if you type in
   the wrong key. But is storing #2 in an obvious place too much of a
   give-away?

How much you're compromising security depends partly on what kind of
threats you're trying to protect against.  You're in a different
position if you're trying to protect againstthe NSA brute-force trying
all possible keys than if you're trying to protect against someone
testing which files match the key they found on a yellow sticky-note.

In particular, it looks like you're trying to protect user-selected keys.
This is different from trying to protect randomly-generated keys,
or keys generated by hashing arbitrary user input, since users often
type short easy-to-remember keys - instead of searching a space of
2**56 keys, the attacker can often search a few million "obvious" keys.
Since your method always uses the same pattern E(K,K) to validate a key K,
it's easy to build a table of that value for the obvious keys,
so the attacker can check lots of files by table lookup instead of
calculating them every time.

An alternative method that will give you roughly the same useful
feature is to generate a random number in some recognizable form,
e.g. the last 8 bits are 0, encrypt it, and store it with the file;
when you decrypt, you can check if the number has the right form.
For the 8 0s example, choosing the wrong key is detected 255/256 times,
but an attacker searching all key values doesn't gain much from
knowing that a guessed key maay be right - he's still got to use it to
decode the message and see if it looks right, and since you pick the
number at random, building a table in advance isn't useful,
since it would need (# of randoms)*(# of keys) entries.
You could integrate this into your algorithm by using the random
number as the initialization vector for your chaining algorithm,
assuming you use CBC or CFB mode for DES.

If you're only concerned about whether the user wastes time looking at
the incorrectly-decrypted text after using a wrong key, and not about 
the time spent doing the decode with a bad key, you can get your
validity checking by appending a known or recognizable value to the
end of the plaintext before encrypting, and seeing if the value was
restored after the decrypt.  (This is obviously meaningful only if
you're using a chaining/feedback mode for DES, or if the value you use
is some kind of checksum of the plaintext, such as a CRC code.
--
# Bill Stewart       AT&T Global Information Solutions (new name for NCR!)
# 6870 Koll Center Pkwy, Pleasanton CA 94566  1-510-484-6204 fax-6399
# Email: bill.stewart@pleasantonca.ncr.com billstewart@attmail.com
# ViaCrypt PGP Key IDs 384/C2AFCD 1024/9D6465

Disclaimer: My cats are walking on my keyboard again.
