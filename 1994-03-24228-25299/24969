Path: msuinfo!harbinger.cc.monash.edu.au!yeshua.marcam.com!MathWorks.Com!europa.eng.gtefsd.com!emory!swrinde!cs.utexas.edu!not-for-mail
From: boucher@csl.sri.com (Peter K. Boucher)
Newsgroups: sci.crypt
Subject: Re: US Patent No 5_251_165
Date: 22 Mar 1994 15:43:42 -0600
Organization: UTexas Mail-to-News Gateway
Lines: 102
Sender: daemon@cs.utexas.edu
Message-ID: <9403222143.AA21437@redwood.csl.sri.com>
NNTP-Posting-Host: cs.utexas.edu

chardr@netcom.com (Richard L. Robertson) wrote:
|> In Message-ID: <9403152019.AA28731@nyx10.cs.du.edu> Colin James III (The
|> Rt Rev'd) writes:

[deletia...]

|> >Mr Robertson has demanded that I make an apology to sci.crypt.
|> >
|> >I regret wasting my time, or anyone's time on sci.crypt, by 
|> >having responded to him or his cronies.
|> >
|> 
|> I had requested that Mr. James apologize for his threats to individual
|> participants on sci.crypt.  This he *refuses* to do!  This despite
|> acknowledging individual instances where he made threats that he modified
|> into statements of non-interest once the threatened party led Mr. James by
|> the hand through a simplified explanation of the program under question. 
|> At no time did Mr. James make any apology for his earlier actions.

As much as the right reverend Colin James III has rubbed me the wrong way,
I feel that I should correct a misconception on Richard L. Robertson's
part.  The code to which the right reverend objects is Jenkins' (though
he seems incapable of explaining just how Jenkins' code infringes on his
patent).  The code to which he does not object (other than calling it ugly)
is mine.

OBCRYPTO: Apparently, some readers have cryptanalyzed Jenkins' code and
found it wanting.  My testing shows that my code has similar performance
and randomness (when compared to Jenkins' code).  I invite people to
cryptanalyze it, for my edification.  I posted a uuencoded compressed 
source file under the thread "YASR (Yet Another Secure RNG)".  Below is
a synopsis of the algorithm (from the same thread).

|> Here's the meat of the algorithm:
|> 
|> 1) There's a table containing 256 permutations of the numbers 0-31.
|> 2) There are two additive congruential generators based on the
|>    irreducible trinomials X**839 + X**54 + 1, and Y**719 + Y**150 + 1,
|>    respectively.
|> 3) The output of the two additive congruential generators is combined
|>    in the following way: output = (((x<<9)^(x>>23)) + ((y<<18)^(y>>14))),
|>    where x comes from generator 1, and y comes from generator 2.
|> 4) The table is used to select an ordering for 32 of the combined outputs.
|> 5) The table is also used to select an ordering for 32 such groups of
|>    32 combined outputs, giving 1024 "shuffled" outputs.
|> 
|> Here are the two routines used to generate the output.
|> 
|> ====================== BEGIN SOURCE CODE FRAGMENT ======================
|> static unsigned long
|> fill_rands()
|> {
|>     register unsigned char *optr1, *optr2;
|>     register int i, j;
|>     register unsigned long x,y;
|>     register unsigned long *rptr;
|> 
|>     optr1 = otab[(indexr1 = (1103515245 * indexr1 + 12345))>>24];
|>     for (i=32; i--;) {
|>         rptr =  /* select a group of 32 outputs to fill in */
|>                &(rands[((unsigned int)(*(optr1++)))*32]);
|>         optr2 = /* select an order to fill in those 32 outputs */
|>                otab[(indexr2 = (1103515245 * indexr2 + 12345))>>24];
|>         for (j=32; j--;) {
|>             x = (*frnt0 += *rear0); /* generator 1 */
|>             y = (*frnt1 += *rear1); /* generator 2 */
|>             rptr[*(optr2++)] = (((x<<9)^(x>>23)) + ((y<<18)^(y>>14)));
|> 
|>             if(  ++frnt0  >=  end0  )  { /* update generator 1 ptrs */
|>                 frnt0 = state0;
|>                 ++rear0;
|>             } else  {
|>                 if(  ++rear0  >=  end0  )  rear0 = state0;
|>             }
|>             if(  ++frnt1  >=  end1  )  { /* update generator 2 ptrs */
|>                 frnt1 = state1;
|>                 ++rear1;
|>             } else  {
|>                 if(  ++rear1  >=  end1  )  rear1 = state1;
|>             }
|>         }
|>     }
|> 
|>     num_rands = 1023;
|>     rand_ptr = &(rands[1]);
|>     return( rands[0] );
|> }
|> 
|> unsigned long
|> rand32()
|> {
|>     return( (num_rands--) ? *(rand_ptr++) : fill_rands() );
|> }
|> 
|> ======================= END SOURCE CODE FRAGMENT =======================

-- 
Peter K. Boucher
--
DISCLAIMER:  The above does not represent the opinions of my employer.


