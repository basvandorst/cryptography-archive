Path: msuinfo!agate!ucbvax!hplabs!hp-cv!hp-pcd!hpcvsnz!ericb
From: ericb@lsid.hp.com (Eric Backus)
Newsgroups: sci.crypt
Subject: Re: Encryption from Hash Functions
Message-ID: <Cn14v1.HKC@hpcvsnz.cv.hp.com>
Date: 21 Mar 94 19:30:37 GMT
References: <CMvq7M.K38@hpcvsnz.cv.hp.com> <16F7ECD0AS86.C445585@mizzou1.missouri.edu>
Sender: news@hpcvsnz.cv.hp.com (News )
Organization: Hewlett-Packard
Lines: 32
X-Newsreader: TIN [version 1.2 021193BETA PL3]

John Kelsey, c445585@mizzou1.missouri.edu wrote:
>    Another thought crossed my mind, when I was reading the section
> in Applied Cryptography about subliminal channels.  What if Alice
> and Bob agree on a shared 256-bit key, using whatever key exchange
> method strikes their fancy.  Now, the shared key is K.  When Alice
> wants to send Bob something an n-bit string, she starts generating
> 256-bit values X(i).  When she finds an X(i) such that the low n
> bits of Hash(K,X(i)) are the message she wants to send, she can send
> X(i).  When Bob gets X(i), he takes Hash(K,X(i)), and retrieves the
> message out of the low n bits of the hashed value.  Now, our usual
> eavesdropper, Eve, has to figure out K from all these X(i)'s, which
> looks like trying to invert Hash() given only the low n bits of its
> output.

Interesting, this is a twist I hadn't thought of.  However, you have
to be sure to never re-use the X(i), so you have to do at least one
hash calculation for each output byte.  Building a table ahead of time
just moves this calculation around, but does not shorten or eliminate
it.

Assume we use m bits of an n-bit hash, then:

1. We calculate the hash function n/m times as many times as in the
   method that I proposed.  For a fast hash function, maybe this is
   not such a big deal.

2. The encrypted message is n/m times as long as the input.  At least
   in my mind, this is a major problem.
-- 
				Eric Backus
				ericb@lsid.hp.com
				(206) 335-2495
