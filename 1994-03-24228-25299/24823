Newsgroups: sci.crypt
Path: msuinfo!agate!howland.reston.ans.net!vixen.cso.uiuc.edu!sdd.hp.com!decwrl!pa.dec.com!nntpd2.cxo.dec.com!solvit.enet.dec.com!page
From: page@solvit.enet.dec.com (My name is...)
Subject: Error in Bruce Schneier's Applied Cryptography
Message-ID: <1994Mar18.155512.25284@nntpd2.cxo.dec.com>
Sender: usenet@nntpd2.cxo.dec.com (USENET News System)
Organization: Digital Equipment Corporation
Date: Fri, 18 Mar 1994 15:52:48 GMT
Lines: 107



 Subj: Error in Bruce Schneier's
       "Applied Cryptography"

 On pate 352, I came across a possible error in
 Bruce Schneier's book, "Applied Cryptography":

 In talking about linear feedback shift registers (LFSR's),
 the author states:

 "Table 15.2 is a list of degrees of primitive polnimials mod2.
  For example, the listing (32,7,5,3,2,1,0) means that the following
  polynomial is primitive modulo 2:
     x^32 + x^7 + x^5 + x^3 + x^2 + x^1 + 1

  It's easy to turn this into a maximal-lenght LFSR. The first
  number is the degree and the length of the LFSR. The last number is
  always 0 and can be ignored. All the numbers, except the 0, specify
  the tap sequence.

  To continue the example, the listing (32,7,5,3,2,1,0) means that if
  you take a 32-bit shift register and generate a new bit by XORing
  the thirty-second, seventh, fifth,third, second, and first bits
  together the resultant LFSR will be maximal length; it will cycle
  through 2^32-1 values before repeating.

  The C code for this LFSR looks like:

    /* return a single pseudo-random bit */
    int LFSR ()
    {
      static unsigned long ShiftRegister = 1;
      ShiftRegister = (((  (ShiftRegister >> 7 )
		     ^ (ShiftRegister >> 5 )
		     ^ (ShiftRegister >> 3 )
		     ^ (ShiftRegister >> 2 )
		     ^ (ShiftRegister >> 1 )
		     ^ (ShiftRegister)
		     & 0x00000001)
		    < 31 )
		   | (ShiftRegister >> 1);

      return ShiftRegister & 0x1;
    }

    " (end of quote).

  There are two obivious compile errors in the code. He
  left out one '<' and one ')', so if the example compiled,
  it should resemble:

    /* return a single pseudo-random bit */
    int LFSR ()
    {
      static unsigned long ShiftRegister = 1;
      ShiftRegister = (((  (ShiftRegister >> 7 )
		     ^ (ShiftRegister >> 5 )
		     ^ (ShiftRegister >> 3 )
		     ^ (ShiftRegister >> 2 )
		     ^ (ShiftRegister >> 1 )
		     ^ (ShiftRegister))
		     & 0x00000001)
		    << 31 )
		   | (ShiftRegister >> 1);

      return ShiftRegister & 0x1;
    }

  Besides that, the example seems to be off in the
  bits it uses for the XOR. There is no bit 32
  referenced in the code. Further, if I shift
  'ShiftRegister' 7 places to the right, I am looking
  at bit 8, not bit 7. If you read the text, the
  author has defined a 32 bit register starting at
  bit 1 and ending at bit 32.

  Doesn't the author mean for (32,7,5,3,2,1,0) ?:

  /*
   * return a single pseudo-random bit
   * using the polynomial (32,7,5,3,2,1,0)
   * where ShiftRegister bits are defined as
   * follows :
   *       32 - 31 - ... - 3 - 2 - 1
   */

  int LFSR ()
  {
    static unsigned long ShiftRegister = 1;
    ShiftRegister = (((  (ShiftRegister >> 31 ) /* bit 32 */
		     ^ (ShiftRegister >>  6 )   /* bit  7 */
		     ^ (ShiftRegister >>  4 )   /* bit  5 */
		     ^ (ShiftRegister >>  2 )   /* bit  3 */
		     ^ (ShiftRegister >>  1 )   /* bit  2 */
		     ^ (ShiftRegister))         /* bit  1 */
		     & 0x00000001)
		    << 31 )
		   | (ShiftRegister >> 1);

    return ShiftRegister & 0x1;
  }

  Also, the polynomial (32,7,5,3,2,1,0) really maximal length?

...Cal

