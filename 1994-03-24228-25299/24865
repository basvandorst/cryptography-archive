Path: msuinfo!agate!usenet.ins.cwru.edu!eff!news.kei.com!MathWorks.Com!zombie.ncsc.mil!golf!mizzou1.missouri.edu!C445585
From: C445585@mizzou1.missouri.edu
Newsgroups: sci.crypt
Subject: Re: Encryption from Hash Functions
Date: Sat, 19 Mar 94 14:34:45 CST
Organization: University of Missouri, Columbia
Lines: 84
Message-ID: <16F7ECD0AS86.C445585@mizzou1.missouri.edu>
References: <CMvq7M.K38@hpcvsnz.cv.hp.com>
NNTP-Posting-Host: mizzou1.missouri.edu

 
   Another thought crossed my mind, when I was reading the section in Applied
Cryptography about subliminal channels.  What if Alice and Bob agree on a
shared 256-bit key, using whatever key exchange method strikes their fancy.
Now, the shared key is K.  When Alice wants to send Bob something an n-bit
string, she starts generating 256-bit values X(i).  When she finds an X(i)
such that the low n bits of Hash(K,X(i)) are the message she wants to send,
she can send X(i).  When Bob gets X(i), he takes Hash(K,X(i)), and retrieves
the message out of the low n bits of the hashed value.  Now, our usual
eavesdropper, Eve, has to figure out K from all these X(i)'s, which looks
like trying to invert Hash() given only the low n bits of its output.
 
   Although this is a rather expensive encryption method, it can be made
reasonable by preprocessing.  Let's put some concrete numbers in here to
make this easier to follow:
 
   Hash() is the SHA, which by default takes 512-bit blocks and outputs
160-bit hashes.  Let's let n be 8, ie we're sending an 8-bit message for
each 256-bit block.  For now, let's also assume we're using a good random
bit source to efficiently generate R(i).  R(i) is the ith random 256-bit
value.
 
   Sometime before she needs to encrypt a message, Alice's encryption
program is generating a dictionary of 256-bit strings like this:
 
   Each of the 256 possible 8-bit strings to be encoded has a list of
256-bit long strings that encode the 8-bit string.  This can be done
in a number of ways.  If you've got 1 MB of storage, you could ideally
store about 2**15 ciphertext strings, or 128 per 8-bit message string
to be enciphered.  More storage available means better general case
encryption speed.  Compression should be performed on messages before
they're sent, to balance out the use of this enciphering dictionary.
Also, obviously, the dictionary needs to be kept in some secure storage.
 
   To send a message, Alice just picks out 8-bit strings from the
dictionary, sends them along, and does whatever is needed to render
the already-used dictionary entries unreadable.  If the dictionary is
large enough, the key need never be used during encryption.  Also, if
the dictionary *is* compromised, only messages enciphered with that
dictionary are compromised.  Also, this looks like a good system for
situations where Alice is much more computationally powerful than Bob.
Maybe a scheme like this would make sense for enciphering commands to
a satelite or something.  (Of course, most possible command strings
would have to be invalid, and a digital signature or keyed hash would
be a good idea for authentication....)  Or maybe for something like
encrypted radio or television or satelite broadcasts, where the broad-
caster has lots of computational power, but the receiving devices are
probably .098 MIPS weaklings.  :)
 
   Looking at possible attacks:
 
Chosen ciphertext:
 
   Chosen ciphertext would be for Mallet (I'm stealing Bruce's characters
from Applied Crypto, again.) to send Bob some random values, and then
get Bob to show them to him.  (This is at first--if an successful attack
progressed very far, Mallet might be able to make good guesses about his
chosen ciphertext values.)
   Essentially, this means that Mallet gets to try any 256-bit string he
likes, and he gets back an 8-bit string--the last 8 bits of the hash of
his chosen value and the key.  (SHA(Key,chosen_bit_string)).  This doesn't
look too promising, but I don't see how to prove that recovering the key
from an arbitrary number of these is at least as hard as forging a message.
It looks pretty clear to me, though, that if you *could* recover the key
from this kind of attack, you'd have shown an important weakness in the
hash function.
 
   Chosen plaintext gives a sort of backwards version of this:  Mallet
*chooses* the 8-bit string, and Alice finds a random value R(i) such that
Low8Bytes(SHA(K,R(i))) = the 8-bit chosen string.  This doesn't look real
promising either, but again, I don't see how to prove that, for an
arbitrary number of chosen plaintexts, this is still as hard as forging
a message with SHA.
 
   Most attacks on hash functions have looked more like the chosen cipher-
text attack than the chosen plaintext attack.
 
   Has anything like this been written up in a paper somewhere?  I've never
seen this sort of scheme in a publication, though it's pretty closely modeled
on the idea of subliminal channels.  Can anyone see a way of proving that
chosen plaintext and/or ciphertext attacks are as hard as forging messages
with the underlying hash function?
 
   --John Kelsey, c445585@mizzou1.missouri.edu
