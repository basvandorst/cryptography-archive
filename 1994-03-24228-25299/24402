Newsgroups: sci.crypt
Path: msuinfo!agate!howland.reston.ans.net!gatech!newsxfer.itd.umich.edu!gumby!smaug!news
From: krueger@cs.hope.edu (John Krueger)
Subject: 1-time Password schemes
Message-ID: <1994Mar4.142432.10949@cs.hope.edu>
Sender: @cs.hope.edu
Reply-To: krueger@cs.hope.edu
Organization: Hope College, Holland, MI  49423
Date: Fri, 4 Mar 1994 14:24:32 GMT
Lines: 67

I posted this about 2 days ago, but I still have not seen it in the
newsgroup.  I am therefore assuming that it died somewhere en rout.
If you did see the previous post, please E-mail me so I'll know if
there is a problem to contact the local sysop about.

I have a couple of schemes for password verification that I thought
up recently.  Being a rank amature (and having read the FAQ) I
realize that (A) they have probably both been thought of, and (B)
they both probably have major defects.  I am just posting to see
what kinds of defects they would have, so hopefuly I can find some
of them before the next time I post and annoy everyone with a dumb
idea. :-)

Scheme 1:
The user and the host each have a copy of the password previously
shared by a secure channel or public key techniques.  When the host
wants to verify that the user has the correct password, it sends a
randomly generated bit string to the user.  The user appends the
bit string to the password, uses a cryptographically secure hash
function on the result, and sends the hash to the host.  The host
then does the same calculation with its own copy of the password,
and accepts the user only if the result s/he sent back was the same
as the calculated result.

This has the obvious hole of requiring the host to keep information
allowing the reconstruction of the password if an ousider was able 
to read it, but it could be useful for such things as electronic
smart cards where the host is presumably secure.

Scheme 2:
The user generates 2 prime numbers p and q and multiplies them to
get a modulus n, the same way s/he would generate a key for RSA.
The user then generates a number H such that gcd(H,phi(n))=1 and H
is composed entirely of many small factors (like 2-4 digits), and an
arbitrary number K such that K<n.  The user then sends the following
information to the host: n, K^H(mod n),H (or the prime factorization
of H if it works faster that way).

To verify the user, the host picks an unused factor F of H, and
tells the user which one was chosen.  The user then sends back
K^(H/F), and the host checks that this does indeed give k^h when
raised to the F power.  The host does of course have to be careful
of things like using an F that divides a previously used F.  When
the factors are all used up, the user may either start from scratch
with a new n, H, and K (which probably should be done as often as
changing regular RSA keys), or just pick a new K.

It may be useful to consider the special case where H is of the
form p^m where p is the smallest prime that does not divide phi(n),
and m is a number like 100, then the Fs could be p, p^2, p^3...p^m.

This scheme is loosely based on the RSA public key cryptosystem,
but since it does not actually encrypt anything the patent may not
apply to it.

Incidentally, if you know of previous refrences to either of these,
I would appreciate pointers.

---
-------------------------------------------------------------------
Disclaimer: This was written by someone who didn't know any better,
and anyway was just blowing off hot air to reduce light-headedness.
krueger@cs.hope.edu * John Krueger * and GOD said: Let there be roo
-------------------------------------------------------------------



