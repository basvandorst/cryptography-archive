Path: msuinfo!agate!ihnp4.ucsd.edu!swrinde!cs.utexas.edu!uunet!anagld!decode!system
From: System Operator <uunet!mimsy!anagld!decode!system>
Newsgroups: sci.crypt
Subject: Re: Substitution Ciphers
Message-ID: <FFL6ic1w165w@decode.UUCP>
Date: Sun, 13 Mar 94 20:17:14 EST
References: <CMFHA3.D6x@murdoch.acc.Virginia.EDU>
Organization: American Cryptogram Association
Lines: 210

rdc8a@kelvin.seas.Virginia.EDU (R. Chiappe) writes:

> only 26 possible combinations for these ciphers.  What I meant to ask
> was if anyone knew how to decode monoalphabetic substitution ciphers
> (which map each letter of the alphabet to another-or the same-letter
> of the alphabet, 26! possibilities.)

I authored the following simple BASIC program, which appeared in issue
#18 of the _Computer Supplement_, a computer adjunct publication associated
with the American Cryptogram Association.  It allows simple trial
and error of letter substitutions in a monoalphabetic cipher.
  
> I'd appreciate any help.

Many cryptography-related programs and files may be found on the
Decode BBS, +1 410 730 6734.  Also consider joining the American
Cryptogram Association, which deals, in part, with these types of ciphers.


1000 ' MONOHELP.BAS
1010 ' Assistance for solving monoalphabetic ciphers by trial and error
1020 ' Last revised 10/26/93
1030 ' Variables:
1040 '    C(,)   Cipher text, in ASCII
1050 '    P(,)   Plain text, in ASCII
1060 '    F()    Frequency counts for each of the 26 letters
1070 '    MC()   Map index of cipher to plain letters
1080 '    MP()   Map index of plain to cipher letters
1090 '    CC     Cipher character (ASCII)
1100 '    CP     Plain character (ASCII)
1110 '    IC     Index into MC() array (cipher)
1120 '    IP     Index into MP() array (plain)
1130 '    OP     Old index pointer into either array (temporary)
1140 '
1150 DIM C(6,80), P(6,80), F(26), MC(26), MP(26)
1160 '
1170 ' INITIALIZE
1180 '
1190 ' Set all letter counts and map indexes to zero
1200 FOR I=1 TO 26
1210 F(I) = 0
1220 MC(I) = 0
1230 MP(I) = 0
1240 NEXT I
1250 FOR I = 1 TO 6   ' Six lines
1260 FOR J = 1 TO 80  ' 80 characters on each line
1270 C(I,J) = 32      ' Set all cipher text to space (ASCII 32)
1280 P(I,J) = 32      ' Set all plain text to space (ASCII 32)
1290 NEXT J
1300 NEXT I
1310 '
1320 ' LOAD DATA FILE
1330 '
1340 PRINT "Filename";
1350 INPUT F$
1360 OPEN F$ FOR INPUT AS #1
1370 NL = 0
1380 '
1390 ' Read in each line of text from the file
1400 '
1410 IF EOF(1) THEN 1660
1420 LINE INPUT #1, A$
1430 NL = NL + 1
1440 NC = 0
1450 ' Examine each character in the line of text
1460 '
1470 FOR I=1 TO LEN(A$)
1480 ' We can only handle lines with 80 characters or less
1490 IF I > 80 THEN 1640
1500 C=ASC(MID$(A$,I,1))
1510 '
1520 ' If letter is lower case (ASCII between 97 and 122), make it
1530 ' uppercase by subtracting 32
1540 '
1550 IF C >= 97 AND C <= 122 THEN C = C - 32
1560 '
1570 ' If the character is an upper case letter, bump up the frequency count
1580 '
1590 IF C >= 65 AND C <= 90 THEN F(C-64) = F(C-64) + 1
1600 ' Filter out any odd characters (less than 32 ASCII)
1610 IF C < 32 THEN C = 32
1620 NC = NC + 1
1630 C(NL,NC) = C
1640 NEXT I
1650 IF NL < 6 THEN 1410
1660 CLOSE #1
1670 '
1680 CLS
1690 ' Display the frequency chart
1700 FOR I = 1 TO 26
1710 T$=STR$(F(I))
1720 PRINT CHR$(64+I);":";T$;SPACE$(6-LEN(T$));
1730 IF I = 7 THEN PRINT
1740 IF I = 14 THEN PRINT
1750 IF I = 21 THEN PRINT
1760 NEXT I
1770 PRINT
1780 ' Display the letter map index
1790 FOR I = 1 TO 26
1800 PRINT CHR$(64+I);"=";
1810 IF MC(I) = 0 THEN 1850
1820 ' Letter is mapped, so display what it maps to
1830 PRINT CHR$(64+MC(I));
1840 GOTO 1870
1850 ' Letter isn't mapped, so leave a space
1860 PRINT " ";
1870 PRINT "  ";
1880 IF I = 13 THEN PRINT
1890 NEXT I
1900 PRINT
1910 ' Display the cipher text, and the current plaintext below it
1920 FOR I = 1 TO NL
1930 PRINT
1940 FOR J=1 TO 80
1950 PRINT CHR$(C(I,J));
1960 NEXT J
1970 PRINT
1980 FOR J=1 TO 80
1990 PRINT CHR$(P(I,J));
2000 NEXT J
2010 PRINT
2020 NEXT I
2030 PRINT
2040 PRINT "Replace Cipher Letter: ";
2050 GOSUB 2740
2060 IF CK = 32 THEN 2050
2070 IF CK = 27 THEN 2830
2080 CC = CK
2090 PRINT CHR$(CC);" with Plain Letter: ";
2100 GOSUB 2740
2110 IF CK = 27 THEN 2830
2120 IF CK <> 32 THEN 2220
2130 '
2140 ' Plain letter selected was a space (ASCII 32), so remove
2150 ' any mapping information for the cipher letter
2160 IC = CC - 64
2170 IP = MC(IC)
2180 MC(IC) = 0
2190 MP(IP) = 0
2200 GOTO 2490
2210 '
2220 CP = CK
2230 PRINT CHR$(CP)
2240 '
2250 IC = CC - 64
2260 IP = CP - 64
2270 '
2280 IF MP(IP) = 0 THEN 2410
2290 ' The plaintext letter is already used
2300 PRINT CHR$(CP);" is already mapped from ";CHR$(64+MP(IP));
2310 PRINT ", move to ";CHR$(CC);" (Y/N) ? ";
2320 GOSUB 2740
2330 IF CK = 27 THEN 2830
2340 IF K$ = "N" THEN 2680
2350 IF K$ <> "Y" THEN 2320
2360 '
2370 ' Zero indexes for old mappings
2380 MC(MP(IP)) = 0
2390 MP(IP) = 0
2400 '
2410 OP = MC(IC)
2420 ' If Cipher letter is already used, clear the old plain text index
2430 IF OP > 0 THEN MP(OP) = 0
2440 MP(IP) = IC
2450 MC(IC) = IP
2460 '
2470 ' Generate plain text from cipher text and mapping array
2480 '
2490 FOR I = 1 TO NL
2500 FOR J = 1 TO 80
2510 ' Default to whatever is in the cipher position
2520 P(I,J) = C(I,J)
2530 CC = C(I,J)         ' select the cipher letter at this location
2540 ' If this character isn't an uppercase letter, skip over it
2550 IF CC < 65 OR CC > 90 THEN 2650
2560 ' assume there is no letter mapped, and make the plain letter a blank
2570 P(I,J) = 32
2580 IC = CC - 64        ' convert it to an index into the map array
2590 IF MC(IC) = 0 THEN 2650
2600 ' There is a plain letter mapped to this cipher letter, so
2610 ' replace the cipher letter with corresponding plain character
2620 IP = MC(IC)
2630 CP = IP + 64
2640 P(I,J) = CP
2650 NEXT J
2660 NEXT I
2670 '
2680 GOTO 1680
2690 '
2700 '  Get a single letter and return it, uppercase
2710 '  Allow SPACE to be returned, for undoing a mapping
2720 '  Also allow ESCape key (27 ASCII) to be returned
2730 '
2740 K$=INKEY$
2750 IF K$="" THEN 2740
2760 CK = ASC(K$)
2770 IF CK = 27 OR CK = 32 THEN 2810
2780 IF CK >= 97 AND CK <= 122 THEN CK = CK - 32
2790 IF CK < 65 OR CK > 90 THEN 2740
2800 K$ = CHR$(CK)
2810 RETURN
2820 '
2830 END
  

Dan

--
system@decode.UUCP (System Operator)
Cryptography, Security, Privacy BBS  +1 410 730 6734   Data/FAX
