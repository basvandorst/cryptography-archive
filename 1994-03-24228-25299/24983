Path: msuinfo!harbinger.cc.monash.edu.au!aggedor.rmit.EDU.AU!edna.cc.swin.edu.au!saturn!alan
From: alan@saturn.cs.swin.oz.au (Alan Christiansen)
Newsgroups: sci.crypt
Subject: Re: Encryption from Hash Functions
Date: 23 Mar 94 13:19:53 GMT
Organization: Swinburne University of Technology
Lines: 95
Message-ID: <alan.764428793@saturn>
References: <CMvq7M.K38@hpcvsnz.cv.hp.com> <16F7ECD0AS86.C445585@mizzou1.missouri.edu> <Cn14v1.HKC@hpcvsnz.cv.hp.com> <16F8013110S86.C445585@mizzou1.missouri.edu>
NNTP-Posting-Host: saturn.cs.swin.oz.au

C445585@mizzou1.missouri.edu writes:

>In article <Cn14v1.HKC@hpcvsnz.cv.hp.com>
>ericb@lsid.hp.com (Eric Backus) writes:
> 
>[Description of the scheme I talked about previously deleted.]
>>Interesting, this is a twist I hadn't thought of.  However, you have
>>to be sure to never re-use the X(i), so you have to do at least one
>>hash calculation for each output byte.  Building a table ahead of time
>>just moves this calculation around, but does not shorten or eliminate
>>it.

I hope I havnt lost the plot. There are two dissimilar schemes.

One uses uses hashes and the last sent piece of the message and a scrt key 
to generate ahash which is then xored. ( Backus wrote about this.)

Another scheme used a source of numbers/data to be hashed after combining
it with the secret key. The lower bits of this hash were then checked
with the message data when a match was found the numbers/data were 
transmitted as the cipher. Various comp sci techniques wer suggested 
to optimise the alg so that effectively the sender had to do as many
hashes as there bytes in the message. And these could be done well 
in advance.
It is this latter scheme that I am now talking about.

>   This seems to have three traits:
> 
>1.  The sender has lots of work to do to encrypt.  This can be done ahead
>    of time, using a pretty standard tradeoff of memory for speed.  The
>    sender also seems to require a good source of random bits.  (I'm not
>    entirely sure he couldn't make do with a pseudorandom source, or
>    even with a non-repeating source like a long counter.  That looks a
>    lot weaker, at first glance, though.)

I think that by building a dictionary in advance. Every hash the sender
made would eventually be used if messages were compressed and thus
all bytes had equal probability of being in the message.
I thinkt the source of rand numbers might be irrelevant and could even
be cryptanalyst(cracker) chosen without obviously weakening the scheme.

>2.  The receiver has relatively little work to do.

I think given my above poposition. they have the same amount of work.
The sender can do the work in advance if it can be stored. Or can do it
on the fly using a cache (less storage). The receiver has to do it at
decode time.


>3.  The scheme seems to be very hard to invert.
> 

>>2. The encrypted message is n/m times as long as the input.  At least
>>   in my mind, this is a major problem.
> 
>   It may be.  I think all randomized encryption schemes involve expansion
>of the message.  Depending on the application, this may or may not be a
>problem.

The scheme proposed by Backus (one  above) resulted in minimal
expansion of the data to be transmitted. 
Minimal => Message + const N bits of plainText (session key?!)

n/m is an altogether different tpye of expansion.

Both schemes have their merits.
BAckus's scheme has in my view more complications (places to look for
weakness) but does not expand messages and gets n bits per Hash.
This (another as described above) is simpler has less places to look
for holes but sends significantly more data and may be significantly
slower.

Could the original Authors please invent a name for these two beaties.

I am busy now but.....  I dont live in the states. I can write fast
code. I will implemant both of these in ansi C some time. The C will
use object orientated type of approach including ptrs to funcs
in the objects for max flexibility. THere is no point in me owning the
code so it will be pub dom.

I also have some cute ideas of my own but am basically a twit at crypto
so I expect they are useless, just cute. I can write code though.

Alan

> 
>>                                Eric Backus
>>                                ericb@lsid.hp.com
> 
>   --John Kelsey, c445585@mizzou1.missouri.edu
-- 
                           |  This space was intentionally left blank,
                           |  until some silly included a self descriptive
                           |  self referential self referential self ...
                           | ... Stack overflow. Executing cleanup rm *.*
