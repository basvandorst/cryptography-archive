
TOOLS FOR THE CONSTRUCTION OF SECRET KEY CRYPTOGRAPHIC SYSTEMS 
 
John R. Michener 
 
	Dr. Dobbs Journal has published several articles on cryptographic
systems in the last few years (August 84 and May 86).  While certain
weaknesses of the algorithm presented in "An Infinite Key Encryption
System" (August 84) were presented in "The Cryptographers Toolbox" (May
86), the algorithms presented as replacements are vulnerable to the
sophisticated statistical tools of cryptanalysis.  Since crypto
security appears to be of continuing interest in the software community
I will devote this article to a discussion of several crypto algorithms
that can be used to construct secret key crypto systems that are
relatively resistant to analysis.  Extensive discussions of public key
systems such as the RSA factoring algorithm are readily available[1, 2,
3, 4].  Such systems are far slower than secret key systems of equiva-
lent security.  They will not be discussed in this article.  The books
of Kahn[5] and Lauer[6] on historical techniques of cryptography and
cryptanalysis are very good.  There is not room in any article of this
length for a full exposition of these techniques and their respective
strengths and weaknesses.  Adequate references to books, reviews, and
original sources are provided to allow readers to obtain more detailed
expositions of the subjects discussed.
	Before discussing crypto algorithms I must say a few words about
how codes are broken.  Cryptanalysis is a form of applied mathematics
and statistics in which the cryptanalyst attempts to strip the confus-
ion supplied by the crypto process from the underlying message.  The
basic tool of the cryptographer is a through knowledge of the language
and its properties.  Written English typically has a redundancy in
excess of 75%, resulting in each character of English text transmitting
somewhat over 1 bit of information at the average.  English text
encoded as ASCII characters has a redundancy on the order of 85% (8
bits per character).  Many, if not most, computer files are far more
structured than English and are far more predictable.  This is particu-
larily true for highly structured transactions where it must be assumed
that the attacker has detailed knowledge of the message structure.  The
predictability (including the message structure) and redundancy of
source material provide cryptanalysists their starting material as well
as their checks for the accuracy of their assumptions. 	The history
of cryptographic security and common sense tells us that any builder of
cryptographic systems must expect that attackers will have a detailed
knowledge of the cryptographic system itself.  One must also assume
that the attackers will have large amounts of matched ciphertext and
plaintext available for analysis (this is called a known plaintext
attack).  No cryptographic system should be considered for use if it
cannot resist such an attack and every effort should be taken on the
part of the builder of the cryptographic system to minimize the
attackers knowledge of the structure of the message.  One of the best
ways of doing this is to reduce the redundancy of the message before it
is encrypted.  
	The scheme taken to compact the source material will typically be
dependent upon the material to be compressed[7], but it may well
involve some form of Huffmann encoding at the character or word
level[8,9], the use of dictionary compaction schemes[10], codebook
techniques for common phrases, general purpose compaction techniques-
[11,12,13,14,15], or some combination of these.  Well designed compact-
ion algorithims can reduce the the number of bits necessary to encode a
character in arbitrary English text to between 2 and 3 bits[16]. 
Compaction algorithms for highly structured messages can and should be
optimized to remove the message structure and redundancy to maximize
the difficulties faced by the cryptanalysist.  Known plaintext analyses
can be hindered with the use of compaction routines that generate
nonunique outputs.  Such routines typically map common strings or
symbols into a multiplicity of symbols, generating considerable
uncertainty for the analysist about the output of the routine.  As
would be expected, this uncertainty comes at the cost of somewhat lower
compression efficiency.  When transposition operations are applied to
compacted text, structure needed for the decompression routines is
diffused over the message, further hindering the cryptanalysist, who
must both decipher the encryption scheme and reconstruct the compressed
text. 


PSEUDO-RANDOM GENERATORS AND THEIR COMMON USES

 	Pseudo-random (PR) generators based upon recurrence relations or
feedback registers are extensively used for the generation of reproduc-
ible streams of PR numbers[17,18].  Such PR sequence generators have
been used directly for encoding of text by algebraic combination of the
generated sequence with the data stream to be encrypted[19].  While
simple applications of PRSG's can be easily solved, sophisticated
non-linear schemes involving PR sequence generator's can be far more
resistant to analysis and are still in use[20,21,22].  PR sequences
may also be used in encryption schemes as modulators of the encryption
system state during the course of encryption.  All PR sequence generat-
ors used in crypto systems must be chosen carefully to maximize the
period of the generated sequences as well as make it difficult to solve
the sequence for the contents of the generator. 
	Among the best PR sequence generator known is the word feedback
shift register discussed by Knuth: X(n) = {X(n-a) + X(n-b)}mod p, where
p is even and a>b.  With proper choice of a and b, these generators
have periods somewhere between 2^a - 1 and p^a - 1.  It has been found
that this generator is even better when multiplication is used as the
combining operation rather than addition, though it is somewhat slower
due to the relative speeds of addition and multiplication.  The table
in Figure 1 (from Knuth) provides 8 values of a and the associated b
values to construct 8 PR sequence generators with maximal length
periods when the combining operation is addition.  For the generated
sequences to have no common factors it is necessary that each generator
have a different value of a.  Use of all 8 generators requires 262
cells (if the generators use a single array for storage, the first
generator would use cells 0 to a1-1, the second generator would use
cells a1 to a1+a2-1, and so on).


---------------------------------------------------------------
Figure 1

FEEDBACK CONNECTIONS FOR RELATIVELY PRIME PERIOD PR SEQUENCE GENERATORS
		a value			allowed b values
		47				5, 14, 20, 21
		41				3, 20
		39				4, 8, 14
		35				2
		31				3, 6, 7, 13
		29				2
		23				5, 9
		17				3, 5, 6
---------------------------------------------------------------

STREAM AND BLOCK CIPHERS

	Ciphers can be classified as being either stream ciphers or block
ciphers.  Stream ciphers are so called because of the continuous,
streamlike, character of the encipherment or decipherment process.  In
such ciphers the encipherment of one character is not affected by
characters that have yet to be processed.  Examples of such ciphers are
substitution ciphers in which the characters to be transformed are
processed one after another or PR based systems in which the characters
to be enciphered are algebraically combined with a PR sequence.  Block
ciphers are ciphers in which blocks of characters are transformed
simultaneously.  In such ciphers the value of every character in the
block affects the transformation of the other characters in the block. 
The block size of such a system can range from a small fixed size such
as the 8 bytes of the Data Encryption Standard up to the length of the
message.
	If multiple messages enciphered with the same key using a stream
cipher are analyzed it is frequently possible to determine the contents
of the messages without knowledge of the encipherment key.  This is due
to the high redundancy of most communications and the locality charact-
eristic of most stream ciphers in which changes in one character
usually affect only the corresponding ciphertext character.  This
suceptibility can be reduced by the use of randomly chosen or generated
message keys that are transmitted with the message and modify the
action of the encipherment key upon the message.  Such a procedure
effectively guarantees that each message has an unique effective key. 
	Block codes do not exhibit such locality of effect and are
typically far more difficult to analyze.  While the solution of block
codes can be exceedingly difficult, it may be possible to extract
considerable information from a message enciphered directly with a
small block size block code by examination of the ciphertext alone.  An
example of this is a highly structured message with large amounts of
blank spaces.  Blocks of blank spaces will transform into the same
output blocks, allowing the analysis of the message structure.  This is
particularily  true if substantial amounts of matched plaintext /
ciphertext was available for analysis.

RIVEST "FORWARD AND BACKWARD ENCRYPTION" 

 	A particularly simple technique that improves the resistance of
certain PR sequence generator based encryption schemes to cryptanalysis
is due to Rivest[23].  In this technique two PR sequence generators
which possess multiple precursor states for any given state are
combined to hinder analysis of the generator state.  Consider the
generator X(n) = { X[n-7] * X[n-23] + X[n-37] }mod(p) (This generator
is for discussion only.  It was randomly chosen and almost certainly
does not generate a maximal length sequence.).  There exist multiple
values of X[n-7], X[n-23], and X[n-37] which result in a given value of
X(n).  Rivest's technique enciphers the message by adding the output of
one PR sequence generator mod(p) to the message starting at the
beginning of the message and incremented along the character stream to
its end.  The output of the other PR sequence generator is then added
mod(p) to the modified message starting at the end of the message and
incremented along the character stream to its beginning.  The code in
Listing 1 illustrates this technique for encipherment. 
	Decryption of the message is also straightforward and can be
performed with almost identical code.  This encipherment process is
fast, and can be viewed as a very minimal block code.  The critical
choice in the use of this technique is the choice of the PR sequence
generators.  Shift registers utilizing generalized rotor combining
operations, a topic discussed later in this article, are well suited
for this application due to their many to one inverse mapping charac-
teristics and their resistance to analysis.

THE "GENERALIZED ROTOR" CYPTOGRAPHIC OPERATOR 

 	In the 1930's encoding machines were introduced which utilized a
series of rotors (electrical scrambling units which serve as substitut-
ion lists, substituting one character for another) mounted upon a shaft
and rotated with respect to one another by gears and cams after each
character was enciphered (see Piper, Kahn, or Lauer).  The scrambling
wiring of the rotors was rarely changed due to the difficulty in
manufacturing and distributing the rotor sets used by the machines. 
The keys used for encipherment of messages were the choice of which
rotors from the rotor set would be used, their order in the machine,
their rotational setting within the machine, and the setting of various
machine parameters, if any.  These keys could be changed frequently to
make analysis of the resulting code difficult.  The relatively regular
manner in which the rotors moved with respect to one another during the
operation of the machines as well as the fixed order of the rotors
during any given encipherment session rendered electro-mechanical rotor
machines vulnerable to analysis.  Implementations of rotor techniques
on microcomputers are not constrained by the limitations imposed by
mechanical gearing on the electromechanical machines.  A linked
substitution list (rotor) technique is very resistant to analysis and
is well suited for implementation on microcomputers.  I have called
this technique the "Generalized Rotor" (GR)[24,25,26].
	In this technique a set of substitution lists (rotors) are chosen
so that each rotor is a randomly scrambled list of numbers from 0 to
p-1, where p is the list length (rotor size), with each element
appearing only once.  No relationships or correlations should exist
between the various rotors in the rotor set or between elements in any
given rotor.  At the same time that the encryption rotors are determ-
ined, the decryption rotors should be chosen.  The decryption rotors
are the inverse of the encryption rotors, and are calculated from them,
but need to be available as a separate rotor set.  The code in Listing
2 provides a means of generating a set of encryption and decryption
rotors given a sufficiently long stream of random bytes.   In the
descriptions that follow p and the number of rotors in the rotor set
will be taken to be 256 because of the calculational convenience of
this choice.  Other choices could easily be made.  If ASCII files are
to be transformed and it is desired from an implementation point of
view to keep the rotors and other working variables within a 64K block,
it would be logical to use 128 rotors, each 128 bytes long.
	The GR operates by using the outputs of PR sequence generators to
choose the rotors to be used in the working set as well as the relative
offsets of each rotor in the working set.  After each character is
enciphered the rotors in the working set as well as their offsets are
set to the new values supplied by the PR sequence generators.  The
total change of the rotor set and offset values after each character is
processed eliminates the regularities which render mechanical rotor
systems vulnerable to analysis.  There are several "keys" in this
system: the contents of the encryption and decryption rotors, the
algorithms used in the PR sequence generators, and the starting
contents of the PR sequence generators.  The starting contents of the
PR generators, or the string from which these contents are created, is
the working key for the system and should be changed frequently.  The
rotor contents and PR sequence generator algorithms constitute the
fixed key and can be changed much more infrequently.  The c code block
in Listing 3 implements encipherment and decipherment of individual
characters utilizing GR substitution operations where the rotors are
stored as two dimensional arrays.  Use of these routines requires that
the message stream be fed through the transformations.
	The GR operator may be viewed as a very complex mixer of multiple
PR sequences with a chosen text stream.  The mixing is resistant to
analysis as well as being easy to implement.  Working implementations
should implement the encryption and decryption rotor sets as large
single arrays, minimizing the index computations necessary to perform
the operations.   The c subroutines in Listing 4 implement GR byte
substitution as well as bitwise and bytewise transposition operations
(these operations will be discussed later).
	Two PR values are needed for each rotor in the rotor set, one for
the rotor selection and one for the rotor offset.  The most secure way
of doing this is to have each value produced by a separate generator.  
The generators used should have periods that are long and should not
share common factors preventing undesired periodicities in the sequen-
ces.  A four rotor system would thus need 8 sequence generators.   	
The additive generators discussed earlier are well suited for the
generation of such sequences.  The use of GR operations rather than
addition as the combining operation in such a feedback shift register
is fast and is hard to analyze.  If the two values fed back determine
the rotor choice and rotor offset values, the resulting value may be
used as the result of the combining operation.  This is expressed in
the following expression:  X(n) = rot[X(n-a)][X(n-b)].  Such a combin-
ing operation has apparently random mapping characteristics and is not
easily inverted.  The inverse operation of determining what prior
states could have yielded a given output is many to one: for rotor sets
of 256 rotors, each 256 long, there are 256 previous states that could
have yielded a given output.  There is no theory to predict the period
lengths of the sequences produced by such generators.  The apparently
random nature of the mappings suggests that the period is likely to be
on the order of p^a -1.  The use of such sequence generators is very
fast due to the speed of memory access and appears to add considerable
difficulties to the work of the cryptanalysist, a desirable tradeoff. 
The use of GR feedback generators should give quite good results.

TRANSPOSITION CIPHERS

	In the above discussion substitution ciphers have been discussed. 
Such ciphers substitute one character for another, but they do not
change the position of the character in the message.  Transposition
ciphers do not change the values of the characters enciphered, changing
instead their positions in the message.  Since transpositions function
upon arrays of characters they may be viewed as members of the family
of block codes.  The routine of Listing 2 mentioned above for generat-
ing rotor sets from a random stream is capable of generating transposi-
tion tables if supplied with a stream from a PR generator.  The
resulting mapping is a complete one in which every point on the input
maps to some point on the output.  Such a mapping can be used as a
pointer list to allow the transposition of units (which may be bits,
bytes, or larger units such as strings) within blocks.  
	The preceding use of the GR operator made use of its ability to
rapidly generate character substitutions.  If the rotor offsets and
rotor choices are held constant while the entire rotor mapping from
input to output is determined, a complete transposition mapping will be
generated.  This block can be used for transposition of text in the
manner discussed above.  After the transposition of one block the GR
state may be incremented to generate the next transposition mapping,
thereby providing a source of continually changing transposition
mappings.  These generators of transposition tables make an effective
transposition crypto-system in which each transposition block is
distinct.
	Complete transposition mappings are identical to the input-to-
output mapping of a rotor.  As such, generation of GR transposition
tables is an excellent way to create new rotor sets from an established
rotor set.  There are several ways to utilize this property.  One of
them is to use a separate rotor generation key in addition to a fixed
rotor set.  The working rotor set would be calculated from the fixed
rotor set utilizing the rotor generation key.  Encipherment and
decipherment operations could then be performed utilizing the new rotor
set, which could be changed frequently.  If transposition tables are
calculated during crypto processing, the new transposition tables could
be used to replace rotors in the rotor set during the processing of the
text.  The crypto processing would then occur with a changing rotor
set, greatly complicating the analytical difficulties of the cryptogra-
pher at a moderate cost to the encipherment system: increased storage
space to store the original rotor set, the rotors generated during
processing, and the arrays or lists used to keep track of which rotors
are active at any given part of the processing.  If general rotor
operations are used in the PR number generators, the gradual change in
the rotor sets will cause a change in the PR generation as well as in
the general rotor operations.
	General rotor operations are quite rapid on modern microcomputers
as long as the rotor set in use (encryption or decryption) can be
stored in the working memory of the machine, which for an 8 bit GR
system occupies an array of 64K.  The table in Figure 2 lists the time,
in msec, that it took to transform a character for Intel 8088 and
Motorolla 68000 microprocessors running at 8 Mhz as a function of the
number of rotors in the working set (These tests were run with an
early, non-optimizing Computer Innovations c compiler under CPM/86 on a
Compupro system and under the CPM 68K c compiler in a Sage microcomput-
er). 
-------------------------------------------------------------
Figure 2

Transformation Time per Character (msec) 
Substitution              8088               68000 
2 rotors                   2.4                 .5 
4 rotors                   4.4                 .9 
8 rotors                   8.6                 1.7 
 
byte transposition 
2 rotors                   1.                  .23 
4 rotors                   1.5                 .4 
8 rotors                   2.6                 .7 
 
bit transposition 
2 rotors                   8.9                1.8 
4 rotors                  13                  3 
8 rotors                  22                  5.6 
------------------------------------------------------------- 

 
SUBSTITUTION-PERMUTATION BLOCK CODES

	Shannon in his studies on information theory[27] noted that strong
crypto systems could be constructed by the combination of substitution
and transposition operations despite the fact that the respective
transformations might be relatively easy to solve if considered
separately.  Sophisticated combinations of substitution and permutation
(transposition) operations are utilized in the construction of substit-
ution-permutation (SP) block codes[28,29,30,31].  Properly designed,
such codes are among the most secure codes known.  The US Government's
Data Encryption Standard is an example of a moderate sized block code.
SP block codes are typically built by repeated application of transpo-
sition at the bit level and substitution on units composed of at least
4 bits.  The substitution operations must be dependent upon the
encryption key since they serve the role of nonlinear mixer for the
system.  The transposition operations may be dependent upon the
encryption key, but this is not required, as fixed transposition tables
may be used with all the crypto security resting in the application of
the substitution operations.  The basic operation set of the block code
is the transposition operation applied to the bits in the block
followed by substitution operations applied to all the units within the
block.  These operations serve to mix information from all the charact-
ers.  By applying these operations repeatedly, the output of the block
code can be made to be dependent upon each bit in the starting block as
well as every bit in the encryption key.  
	Block codes require considerable amounts of internal key informat-
ion for control of the multiple substitution and transposition operat-
ions.  Typically this information is expanded from the supplied key by
a predetermined procedure.  This poses no problem for encipherment, but
can pose a problem for decipherment because decipherment requires the
generation of the entire internal key string and its application in
reverse order to decipher the block encryption.  This problem can be
avoided by making the key expansion symetrical with a period just equal
to the expansion length so that the key has returned to its starting
value at the end of the encipherment.  Such systems, such as the DES,
are self-inverse:  A message enciphered by one pass through the
encryption system is deciphered by a second pass through the encryption
system.  This adds considerable simplicity to the use and implementat-
ion of the resulting block code, but it weakens it considerably.
	The GR is well suited as both a substitution and a transposition
operator.  As such, very strong SP block codes can be constructed
utilizing GR operations. Consider the processing of a block of 32 bytes
- 256 bits.  If all the bytes in the block are subjected to substitu-
tion operations the regularities in the original block will be well
obscured.  After a bit transposition pass is performed the information
that was present in any particular character will be diffused over
about 8 characters.  By performing another substitution pass the bits
composing the new characters will be mixed to form a new character
string.  The repeated operations of bitwise transposition and bytewise
substitution rapidly mix the information of the different characters
together so that after a few passes the representation of the output
block is sensitive to every single bit in the input block.  A change of
any bit in the input block results in apparently random changes of
roughly half of the bits in the output of the block transformation.  By
combining bitwise transposition, bytewise substitution, and short
string transposition, it is possible to build block transformations of
very large size.  A 256 byte block size is easily obtained by using an
operational set of character transposition over the 256 byte block
followed bit transposition over the 8 subblocks of 256 bits, followed
by character substitution of all the bytes in the block.   The repeated
application of this operation set rapidly mixes all the language
structure of the input block into a output block that is sensitive to
every single bit in both the key and the input block.   
	The block codes considered here have been reversible ones in which
it is possible to decipher the transformations used to encipher the
block.  Irreversible transformations are of interest for their ability
to transform starting strings into output strings which may then be
used for such things as keys.  One application of this is the creation
of sequence generator keys for systems that utilize numbers of PR
sequences.  If it is not desirable to store these relatively large
keys, it is necessary to expand the shorter keys that are used into the
longer sequence generator contents that are needed. The expansion
technique should mix all the characters in the starting key so that a
change in any one of the starting characters will result in apparently
random changes of all the bytes in the resulting working key.  If GR
techniques are used in an encipherment system the procedure in Figure 3
will generate a 262 char array (the size needed for the previously
discussed key generator array) for initialization purposes. 








--------------------------------------------------------------
Figure 3
 Irreversible GR Key Expansion Technique 
 
1    Fill 262 char array with copies of supplied key in a predetermined
manner.  The key should be long enough and random enough that guessing
or search techniques are ineffective.  A copy of the message or block
key may also be inserted before key expansion.
 
2    Set rotors(*) and perform a byte transposition of the first 256
bytes in the array 
 
3    for each 32 byte (256 bit) sub-array in the 256 byte array: 
     a:     set rotors and perform bit transposition of sub-array 
     b:     set rotors and perform character substitution on sub-array 
 
4	repeat 2 and 3 for the last 256 bytes in the 262 byte array

5    if the number of iterations of 2 through 4 is less than 3 go to 2 

(*) set rotors => choose rotors and their offsets for the rotor set. 
For a 4 rotor set this might involve summing the contents of cells
0,4,8,..; 1,5,9,...; 2,6,10,...; and 3,7,11,...  mod 256 to yield the
rotor set values and x-oring the contents of these same cell contents
to yield the rotor offset values.  The transformation of any 32 byte
array transforms all the rotor set and offset values.
--------------------------------------------------------------- 

	Standard block codes can be used as irreversible mixers of PR
random sequences[32].  Consider a moderate sized block code that
transforms a 64 bit block under the action of a 64 bit key.  Such a
code provides an apparently random, but 1 to 1 mapping, of the input
block to the output block.  If both the key and the block to be
transformed are supplied by PR sequence generators, the mixing can not
be uniquely reversed:  there are 2^64 valid inverse mappings of any
given transformation. The output of such a mixer may be used directly
for encipherment by x-oring it with the text stream to be enciphered. 
The period of the resulting stream from the mixer will be determined by
the periods of the various PR generators that are used in the system. 
Solution of such a mixing utilizing large block codes and PR sequences
with no common factors probably exceeds the capability of any organiza-
tion for a long time to come.  



KEY MANAGEMENT

	In the above discussions of cryptographic processing I have
assumed that both corresponding parties have agreed upon the keys that
would be used and how, and when, they would be changed.  While this is
relatively straightforward between pairs of correspondents, it is far
more difficult when there are large numbers of communicating entities. 
This is one of the most difficult practical question in cryptography
and is a major reason that it took financial institutions so long to
implement their current cryptogaphic controls and standards.  The
problems faced by financial institutions and their solutions to them
are discussed by Greenlee[33] and Balenson[34].  It is in general a
good idea to minimize the amount of key information that has to be
exchanged between communicating partners, since the key exchange has to
be done in an absolutely secure manner, frequently at considerable
expense.  Historically this has been done by key expansion from a much
smaller, agreed upon key source and by key generation techniques where
an agreed upon procedure is used to generate successive keys from a set
starting state.  An interesting approach to this problem is the use of
public key cryptography (mentioned at the beginning of this article) to
encode a randomly generated key[35].  The enciphered key is then sent
to the recipient as well as the enciphered message.  The message
recipient decodes the key using the appropriate public key algorithm
(this is a slow process for secure public key encipherments) to get the
message key.  The message key is then used with the far faster secret
key algorithm to decipher the message.  Such techniques guarantee that
each message will be enciphered with a different random key, preventing
the successful cryptanalysis of one message from allowing the decrypt-
ion of other messages.  Similar techniques can be implemented with
secret key systems.  In such a system a message key would be generated
and securely enciphered using a key that is used exclusively for this
application.  The message would be enciphered using the generated
message key, using an encipherment system which could be considerably
less secure and faster than the system used to encipher the key.  It is
necessary that the cryptographic transformation used to encipher the
key be very secure, since a successful attack on this part of the
system would leave the system totally vulnerable.  If GR operations are
used, a basic rotor set and encryption key would be used to encipher
randomly chosen rotor generation and/or message keys  using a large
block transformation, yielding very high security for the keys.  GR
substitution could then be used upon the message for high encryption
speed.

CONCLUSIONS

	I have attempted in this article to review several cryptographic
techniques of potential interest to the software community.  I have
only mentioned and referred to works on data compression rather than
discuss this subject in any detail because it is an extensive field and
can not be even inadequately covered in the space available here.  For
more detailed exposition of the cryptographic techniques discussed as
well as their respective strengths and weaknesses I strongly suggest
referring to the references provided in this article.  
REFERENCES

1	Rivest, Shamir, & Adleman, "A Method for Obtaining Digital
Signatures and Public Key Cryptosystems", Proceedings of the IEEE, V67,
#3, March 1979, pp. 397 - 426

2	Martin E. Hellman, "The Mathematics of Public Key Cryptography",
Scientific American, V241, Aug. 1979, pp. 146

3	W. Diffie & M. Hellman, "New Directions in Cryptography", IEEE
Transactions on Information Theory, V IT-22, pp. 644 - 654, Nov. 1976

4	W. Diffie & M. Hellman, "Privacy and Authentication, an
Introduction to Cryptography", Proceedings of the IEEE, V67, #3, March
1977, pp 397 - 426

5	David Kahn, "The Codebreakers", MacMillan Co. N.Y., 1967

6	Rudolph F. Lauer, "Computer Simulation of Classical Substitution
Cryptographic Systems", Aegean Park Press, Laguana Hills, Ca. 1981

7	Gilbert Held, "Data Compression", John Wiley & Sons, 1983

8	Frank Rubin, "Experiments in Text File Compression",
Communications of the ACM, V19, #11, Nov 1976, pp.617 - 623

9	Eugene S. Schwartz, "A Dictionary for Minimum Redundancy
Encoding", J. of the ACM, V10, #4, Oct. 1963, pp. 423 - 439

10	Richard Tropper, "Binary Coded Text", Byte, April 1982, pp. 398 -
413

11	Jorma Rissanen, "A Universal Data Compression System", IEEE
Transactions on Information Theory, V IT-29, #5, September 1983, pp.656
- 664

12	J. Ziv & A. Lempel, "Compression of Individual Sequences via
Variable Rate Coding", IEEE Transactions on Information Theory, V
IT-24, September 78, pp. 530 - 536

13	Bruce Hahn, "A New Technique for Compression and Storage of Data",
Communications of the ACM, V17, #8, Aug. 1974, pp. 434 - 436

14	Terry A. Welch, "A Technique for High Performance Data
Compression", IEEE Computer, June 1984, pp. 8 - 19

15	Ian H. Witten, Radford M. Neal, & John G. Cleary, "Arithmetic
Coding for Data Compression", Communications of the ACM, V30, #6, pp.
520 - 540, June 1987

16	John G. Cleary & Ian H. Whitten, "Data Compression using adaptive
coding and partial string matching", IEEE Trans. Commun, COM-23, V32,
#42, pp. 396-402, April 1984

17	Donald E. Knuth, "The Art of Computer Programming, V1:
Seminumerical Algorithms, Second Edition", Chapter 3, Addison Wesley,
1981

18	Solomon W. Golomb, "Shift Register Sequences, Revised Second
Edition", Aegean Park Press, Laguna Hills, Ca. 1982

19	Henry Becker & Fredrick Piper, "Cipher Systems", John Wiley &
Sons, 1982

20	T. Siegentahler, "Correlation-Immunity of Nonlinear Combining
Functions for Cryptographic Applications", IEEE Transactions on
Information Theory, V IT-30, #5, Sept. 1984, pp. 776 - 780

21	Herbert S. Bright & Richard L. Enison, "Quasi-Random Number
Sequences From a Long-Period TLP Generator With Remarks on Application
to Cryptography", Computing Surveys, V11, #4, December 1979, pp. 357 -
370

22	T. Etzion & A. Lempel, "Algorithms For The Generation of
Full-Length Shift-Register Sequences", IEEE Transactions on Information
Theory, V IT-30, #3, May 1984, pp.480-484

23	Ronald L. Rivest, "Forwards and Backwards Encryption",
Cryptologia, V4, #1, Jan. 1980, pp. 30 - 34

24	John. R. Michener, "The 'Generalized Rotor' Cryptographic Operator
and Some of its Applications", Cryptologia, V9, #2, April 1985, pp 97 -
114

25	John R. Michener, "Application of the Generalized Rotor
Cryptographic Operator in the Construction of Substitution-Permutation
Network block Codes", V9, #3, July 1985, pp. 193 - 202

26	John. R. Michener, "The Application of Key Dependent and Variable
Rotor Sets to Generalized Rotor Cryptographic Systems", Cryptologia, in
press, V11, #3, July 1987, pp. 166 - 171

27	Claude E. Shannon, "Communication Theory of Secrecy Systems", Bell
System Technical Journal, V28, Oct. 1949, pp. 656 - 715

28	John Kam & George Davida, "Structured Design of Substitution-
Permutation Encryption Networks", IEEE Transactions on Computers, V
C-28, #10, Oct 1979, pp. 747 - 753

29	Horst Feistel, "Cryptography and Computer Privacy", Scientific
American, V228, #5, May 1973, pp. 15 - 23

30	Arthur Sorkin, "Lucifer, A Cryptographic Algorithm", Cryptologia,
V8, #1, Jan. 1984, pp. 24 - 41

31	Dov Andelman & James Reeds, "On the Cryptanalysis of Rotor
Machines and Substitution-Permutation Networks", IEEE Transactions on
Information THeory, V IT-28, #4, July 1982, pp. 578 - 584

32	John R. Michener, "The Use of Complete, Nonlinear, Block Codes for
Nonlinear, Noninvertible Mixing of Pseudo-Random Sequences",
Cryptologia, V11, #2, April 1987, pp. 108 - 112

33	M. B. Greenlee, "Requirements for Key Management Protocols in the
Wholesale Financial Services Industry", IEEE Communications Magazine,
V23, #9, Sept. 1985, pp. 22-28

34	David. M. Baleson, "Automated Distribution of Cryptographic Keys
Using the Financial Institute Key Management Standard", IEEE
Communications Magazine, V23, #9, pp.41-46

35	Christian Mueller-Schloer, "A Microprocessor-Based
Cryptoprocessor", IEEE Micro, Oct. 1983, pp. 5-15

----------------------------------------------------------


Comments on Machine and Compiler Dependencies with respect to the
Generalized Rotor


	While the other algorithms discussed in this article should
present no difficulties to the programmer, the generalized rotor does
present a few difficulties.  A full 8 bit rotor set occupies 64K bytes
of memory each for the encryption and decryption rotors.  This can
create some difficulties for compilers which want a data space smaller
than this amount.  Use of smaller rotor sets may well result in
significantly faster code on machines where local references are
significantly faster than more distant references.  Some compilers for
the 68000 do not allow local arrays to be this large, requiring the
declaration of the rotor set as a global array.

---------------- Sidebar ----------------------
Application of Encryption to Data Bases and Editors

	There appears to be some interest in data bases and editors where
much of the material is kept in enciphered form at all times.  Such
security requirements place substantial constraints upon the speed and
ease of use of the software because of the requirements for the
processor to be continually enciphering and deciphering material.  The
editor must allow arbitrary insertion and deletion of text in the
file/document being processed.  Since the effect of a insertion or
deletion must be kept local, it is advisable to use a data structure
such as a B or B* tree to store the file being processed (as is common
in data base construction, though the block size may be far larger for
an editor than would be desired for a data base).  The data block being
edited currently would be kept unenciphered and the other blocks would
be left enciphered.  If the data block being edited grows too much it
would be split, as is usually done in such tree structures.  Similar-
ity, if a block grows too small, it can be merged with a neighbor.  The
encryption technique used within a block can be whatever is desired,
but it must be very fast because the processor will be encrypting and
decrypting material all the time.  The encipherment should not be
identical from block to block.  Since the editor should not have to
keep a history of all the blocks it creates and deletes during its use,
it is a good idea to have a block key that is stored with each block.
which is used to modulate the encryption applied to the block.  While
the block key is available to attackers, it would be of limited value
without knowledge of the key used by the editor.  An example of such a
system would use the Rivest forward and backwards technique with
generalized rotor mixers as pseudo-random generators with multiple
inverse mappings.  The basic encryption key would be used to create the
contents of the pseudo-random generators.   One approach that could be
used is given in Figure 4.


------------------------------------------------------------
Figure 4

#define BLOCKSIZE N-8			/* size of block */
unsigned char x1,.....,x8;  		/* block key bytes */
unsigned char rotor[256][256];	/* rotor set */
int rnd1(),...rnd8(); /* calls to the rotor choice and rotor 		
offset pseudo-random generators */
unsigned char stream1[BLOCKSIZE];	/* mixer output */
unsigned char stream2[BLOCKSIZE];	/* mixer output */
int i, length;	/* length = # of chars in block to be encrypted */
			/* length <= BLOCKSIZE */

/* generate 2, 2 rotor mixed PR streams */
for(i=0; i<length-1; i++)
	{
stream1[i] = rotor[rotor[rnd1()][rnd2()]][rotor[rnd3()][rnd4()]];
stream2[i] = rotor[rotor[rnd5()][rnd6()]][rotor[rnd7()][rnd8()]];
	}

apply streams to block as described under Rivest Forwards and Backwards
Technique


A sample pseudo-random generator utilizing block key information to
modify the pseudo-random generator output follows.

unsigned char reg[262]	/* pseudo-random generator registers */
static int a1 = 46;	
static int b1 = 25;	
static int c1 = reg[x1];
"		"a2	"
"		"	"
"		"	"
"		"c8	"

unsigned char rnd1()
	{
	if ((++a1)==47)
		a1 = 0;

	if ((++b1)==47)
		b1 = 0;

	if ((++c1)==262)
		c1 = 0;

	reg[a1] = rotor[reg[a1]][reg[b1]];
	return(rotor[reg[a1]][reg[c1]];
	}	

unsigned char rnd2()
"			"
unsigned char rnd8()

At the beginning of each block transformation the basic key, the
contents of the feedback registers, must be set to its starting state. 
The block key bytes effect the results through their referencing into
the rotor set.  Knowledge of the block key bytes does not provide
significant information upon the internal state of the encryption
process.
------------------------------------------------------------

        