/*____________________________________________________________________________	Copyright (C) 1996-1998 Network Associates, Inc. and its affiliates.	All rights reserved.		$Id: CipherProcGlue.c,v 1.6.8.1 1998/11/12 03:05:30 heller Exp $____________________________________________________________________________*/#include "pgpMacMemory.h"#include "CipherProcGlue.h"#include "CipherProc.h"const OSType	kCipherProcPPCResType	= 'CPpc';const short		kCipherProcPPCResID		= 1000;const OSType	kCipherProc68KResType	= 'CP68';const short		kCipherProc68KResID		= 1000;	typedef struct CipherProcStruct	{	Boolean				exists;	Boolean				isPPC;	CipherProcUPP		entry;	union		{		CFragConnectionID	connectionID;		Handle				codeHandle;		};	} CipherProcStruct;inline CipherProcStruct *	RefToStruct( CipherProcRef ref )								{ return( (CipherProcStruct *)ref ); }inline CipherProcRef		StructToRef( CipherProcStruct * ref )								{ return( (CipherProcRef)ref ); }		static OSErrGetPPCCipherProc(	CipherProcUPP *		entryPoint,	CFragConnectionID *	connectionID)	{	OSErr	err	= noErr;	Handle				ppcCRHandle = nil;	CFragSymbolClass	theSymClass;			ppcCRHandle	= Get1Resource( kCipherProcPPCResType, kCipherProcPPCResID );	if( IsntNull( ppcCRHandle ) )		{		Str255	errName;		Ptr		mainAddress;		pgpAssert( HandleZone( ppcCRHandle ) == SystemZone() );				HLock(ppcCRHandle);		DetachResource(ppcCRHandle);		err = GetMemFragment(*ppcCRHandle, GetHandleSize(ppcCRHandle),				"\pPGPDiskPPC", kPrivateCFragCopy, connectionID, &mainAddress,				errName);		if ( IsntErr( err ) )			{			MacLeaks_IgnoreItem( ppcCRHandle );			err = FindSymbol( *connectionID, "\pcipherRD", (Ptr *)entryPoint,						&theSymClass);			pgpAssert( theSymClass == kDataCFragSymbol );			}		else			{			DisposeHandle( ppcCRHandle );			}		}	else		{		pgpDebugPStr( "\pGetPPCCipherProc: can't load cipher proc" );		err	= memFullErr;		}			AssertNoErr( err, "GetPPCCipherProc" );	return( err );	}					static OSErrGet68KCipherProc(	CipherProcUPP *		entryPoint,	Handle *			codeHandle)	{	OSErr				err	= noErr;	Handle				codeRes = nil;			codeRes	= Get1Resource( kCipherProc68KResType, kCipherProc68KResID );	if( IsntNull( codeRes ) )		{		pgpAssert( HandleZone( codeRes ) == SystemZone() );				HLock( codeRes );		DetachResource( codeRes );		MacLeaks_IgnoreItem( codeRes );				*codeHandle	= codeRes;		*entryPoint	= (CipherProcUPP)*codeRes;		}	else		{		pgpDebugPStr( "\pGet68KCipherProc: can't load cipher proc" );		err	= memFullErr;		}			AssertNoErr( err, "GetPPCCipherProc" );	return( err );	}					static OSErrInitCipherProc( CipherProcStruct *ref )	{	OSErr	err	= noErr;	long	architecture;		pgpClearMemory( ref, sizeof( *ref ) );		err	= Gestalt( gestaltSysArchitecture, &architecture );		if( IsntErr( err ) && architecture == gestaltPowerPC )		{		ref->isPPC	= TRUE;				err	= GetPPCCipherProc( &ref->entry, &ref->connectionID );		}	else		{		ref->isPPC	= false;				err	= Get68KCipherProc( &ref->entry, &ref->codeHandle );		}			ref->exists	= IsntErr( err );	AssertNoErr( err, "CDriver::InitCipherProc" );	return( err );	}				static voidDisposeCipherProc( CipherProcStruct *ref )	{	if ( ref->exists )		{		if ( ref->isPPC )			{			CloseConnection( &ref->connectionID );			// 3/24/97:we should dispose of the code resource here, too			// but we're about to ship in a few days so do this for next			// version.			//			}		else			{			DisposeHandle( ref->codeHandle );			}				pgpClearMemory( ref, sizeof( ref ) );		}		ref->exists	= false;	}	#pragma mark -	OSErrCipherProc_Load( CipherProcRef *resultRef )	{	OSStatus			err	= noErr;	CipherProcStruct *	ref;		ref	= (CipherProcStruct *)NewPtrSys( sizeof( CipherProcStruct ) );	if ( IsntNull( ref ) )		{		err	= InitCipherProc( ref );		if ( IsErr( err ) )			{			DisposePtr( (Ptr)ref );			}				*resultRef	= (CipherProcRef)ref;		}	else		{		err	= memFullErr;		}		return( err );	}			OSErrCipherProc_Dispose( CipherProcRef	ref )	{	OSErr	err	= noErr;		DisposeCipherProc( (CipherProcStruct *)ref );	DisposePtr( (Ptr)ref );	err	= MemError();		return( err );	}	#pragma mark -	inline voidInitAPI(	CipherProcAPIStruct *	api,	CipherOp				op,	const CipherContext *	context = nil)	{	pgpClearMemory( api, sizeof( api ) );	api->op			= op;	api->context	= context;	}			inline OSStatusMyCallCipherProc(	CipherProcStruct *		info,	CipherProcAPIStruct *	api)	{	return( CallCipherProcX( info->entry, api ) );	}			OSStatusCipherProc_CallInitContext(	CipherProcRef	ref,	CipherContext *	context,	const uchar *	keyToExpand )	{	CipherProcAPIStruct	api;	OSErr				err	= noErr;		InitAPI( &api, kCipherOp_Init, context );	api.doInit.keyToExpand	= keyToExpand;		err	= MyCallCipherProc( RefToStruct( ref ), &api );		return( err );	}				OSStatusCipherProc_CallVerify( CipherProcRef ref )	{	CipherProcAPIStruct	api;	OSErr				err	= noErr;		InitAPI( &api, kCipherOp_Verify );		err	= MyCallCipherProc( RefToStruct( ref ), &api );		return( err );	}			OSStatusCipherProc_CallEncrypt(	CipherProcRef			ref,	const CipherContext *	context,	ItemCount				startBlock,	ItemCount				numBlocks,	const void *			src,	void *					dest )	{	CipherProcAPIStruct	api;	OSErr				err	= noErr;		InitAPI( &api, kCipherOp_Encrypt, context);	api.doCipher.startBlock	= startBlock;	api.doCipher.numBlocks	= numBlocks;	api.doCipher.src		= src;	api.doCipher.dest		= dest;		err	= MyCallCipherProc( RefToStruct( ref ), &api );		return( err );	}			OSStatusCipherProc_CallDecrypt(	CipherProcRef			ref,	const CipherContext *	context,	ItemCount				startBlock,	ItemCount				numBlocks,	const void *			src,	void *					dest )	{	CipherProcAPIStruct	api;	OSErr				err	= noErr;		InitAPI( &api, kCipherOp_Decrypt, context);	api.doCipher.startBlock	= startBlock;	api.doCipher.numBlocks	= numBlocks;	api.doCipher.src		= src;	api.doCipher.dest		= dest;		err	= MyCallCipherProc( RefToStruct( ref ), &api );		return( err );	}