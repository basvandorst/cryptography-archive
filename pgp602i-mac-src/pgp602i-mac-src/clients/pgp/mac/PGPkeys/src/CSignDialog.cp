/*____________________________________________________________________________	Copyright (C) 1997 Network Associates, Inc. and its affiliates.	All rights reserved.			$Id: CSignDialog.cp,v 1.48.8.1 1998/11/12 03:08:17 heller Exp $____________________________________________________________________________*/#include <Fonts.h>#include <LCheckBox.h>#include <LPushButton.h>#include <LTextGroupBox.h>#include <LCheckBox.h>#include <LLittleArrows.h>#include <LRadioButton.h>#include <LTableView.h>#include <LTableMonoGeometry.h>#include <LTableSingleSelector.h>#include <LTableArrayStorage.h>#include <UGAColorRamp.h>#include <URegistrar.h>#include <UDesktop.h>#include <UDrawingUtils.h>#include <string.h>#include "CSignDialog.h"#include "CKeyTable.h"#include "CKeyInfoWindow.h"#include "CWarningAlert.h"#include "CGADurationEditField.h"#include "ResourceConstants.h"#include "CPGPKeys.h"#include "CSecureMemory.h"#include "pgpClientLib.h"#include "pgpUserInterface.h"#include "pgpMem.h"#include "pgpErrors.h"#include "MacStrings.h"#include "pgpClientPrefs.h"const Int16		kUserIDColumnWidth		=	220;const Int16		kFingerprintColumnWidth	=	280;const Int16		kUserIDStringLength		=	256;enum	{			kStringListID			= 1019,			kAdvancedOptionsStringID= 1,			kFewerOptionsStringID,			kNameColumnStringID,			kFingerprintColumnStringID,			kDuplicateCertID,			kEnterPassphrasePromptStringID,			kPhotographStringID,			kUnknownStringID,			kBadExpirationStringID		};class CUserIDList	:	public LTableView{public:	enum { class_ID = 'uidL' };	static CUserIDList*	CreateFromStream(LStream *inStream);								CUserIDList(LStream *inStream);	void					DrawSelf();	void					DrawCell(								const STableCell	&inCell,								const Rect			&inLocalRect);	void					HiliteCellActively(								const STableCell	&inCell,								Boolean				inHilite);	void					HiliteCellInactively(								const STableCell	&inCell,								Boolean			 	inHilite);	void					ClickSelf(								const SMouseDownEvent &inMouseDown);};class	CUserIDHeaders	:	public LPane{public:	enum { class_ID = 'uidH' };						CUserIDHeaders(LStream *inStream);	virtual				~CUserIDHeaders();	void				DrawSelf();};CSignDialog::CSignDialog(){	RegisterClass_(CUserIDList);	RegisterClass_(CUserIDHeaders);}CSignDialog::CSignDialog(LStream *inStream)	: LGADialog(inStream){	RegisterClass_(CUserIDList);	RegisterClass_(CUserIDHeaders);}CSignDialog::~CSignDialog(){	if(IsntNull(mUserIDs))		pgpFree(mUserIDs);}	voidCSignDialog::FinishCreateSelf(){	LLittleArrows	*arrowsObj;	UInt32			timeNow;	LGADialog::FinishCreateSelf();		mUserIDs = NULL;	mAdvancedMode = FALSE;	mExportCheckbox = (LCheckBox *) FindPaneByID(kExportCheckbox);	mAdvancedButton = (LPushButton *) FindPaneByID(kAdvancedButton);	mAdvancedButton->AddListener(this);	mSignButton = (LPushButton *) FindPaneByID(kSignButton);	mCancelButton = (LPushButton *) FindPaneByID(kCancelButton);	mSignTypesGroup = (LTextGroupBox *) FindPaneByID(kSignTypesGroup);	mExpireTypesGroup = (LTextGroupBox *) FindPaneByID(kExpireTypesGroup);	mSignN0Radio = (LRadioButton *) FindPaneByID(kSignTypeN0Radio);	mSignE0Radio = (LRadioButton *) FindPaneByID(kSignTypeE0Radio);	mSignE1Radio = (LRadioButton *) FindPaneByID(kSignTypeE1Radio);	mSignN2Radio = (LRadioButton *) FindPaneByID(kSignTypeN2Radio);	mNeverExpireRadio = (LRadioButton *) FindPaneByID(kNeverExpireRadio);	mExpirationRadio = (LRadioButton *) FindPaneByID(kExpirationRadio);	mScroller = (LActiveScroller *) FindPaneByID(kUserIDScroller);	mDomainEdit = (LEditText *) FindPaneByID(kDomainEdit);	SwitchTarget(mDomainEdit);		mExpirationDate = (CGADurationEditField *) FindPaneByID(kExpirationDate);	mExpirationDate->SetDurationType(kDateDurationType);	GetDateTime( &timeNow );	mExpirationDate->SetDurationValue( timeNow );	arrowsObj = (LLittleArrows *) FindPaneByID(kExpirationArrows);	mLastArrowValue = arrowsObj->GetValue();	arrowsObj->AddListener(this);}	voidCSignDialog::SetUserIDs(PGPKeyRef		signer,						KeyTableRef		*userIDs,						Int32			numUserIDs){	CUserIDList *uidList;		mSigner = signer;	mUserIDs = userIDs;	mNumUserIDs = numUserIDs;	uidList = (CUserIDList *)FindPaneByID(kUserIDList);	uidList->InsertCols(1, 1, NULL, 0, TRUE);	for(Int16 inx=0;inx<numUserIDs;inx++)	{		uidList->InsertRows(1, 32767,			&userIDs[inx],			sizeof(KeyTableRef),			true);	}	Show();}	voidCSignDialog::DrawSelf(){	Rect	frame;		LGADialog::DrawSelf();	FocusDraw();	mScroller->CalcPortFrameRect(frame);	InsetRect(&frame, -1, -1);	RGBForeColor(&UGAColorRamp::GetColor(colorRamp_Gray7));	MoveTo(frame.left, frame.bottom-1);	LineTo(frame.left, frame.top - 16);	LineTo(frame.right - 1, frame.top - 16);	RGBForeColor(&UGAColorRamp::GetColor(colorRamp_White));	MoveTo(frame.left+1, frame.bottom - 1);	LineTo(frame.right - 1, frame.bottom - 1);	LineTo(frame.right - 1, frame.top - 15);	}	PGPErrorCSignDialog::GetParams(	PGPUInt32		*trustLevel,	PGPBoolean		*exportable,	PGPUInt32		*expireDays ){	PGPError	err = kPGPError_NoErr;		*expireDays = 0;	if(mAdvancedMode)	{		if(mSignN0Radio->GetValue())		{			*trustLevel = 0;			*exportable = FALSE;		}		else if(mSignE0Radio->GetValue())		{			*trustLevel = 0;			*exportable = TRUE;		}		else if(mSignE1Radio->GetValue())		{			*trustLevel = 1;			*exportable = TRUE;		}		else if(mSignN2Radio->GetValue())		{			*trustLevel = 2;			*exportable = FALSE;		}		if( mExpirationRadio->GetValue() > 0 )		{			UInt32		expireDate,						timeNow;						expireDate = mExpirationDate->GetDurationValue();			GetDateTime(&timeNow);			if( timeNow > expireDate )			{				CWarningAlert::Display(kWAStopAlertType,									kWAOKStyle,									kStringListID,									kBadExpirationStringID);				err = kPGPError_BadParams;			}			else				*expireDays = ( ( expireDate - timeNow ) / 86400 ) + 1;		}	}	else	{		*trustLevel = 0;		if(mExportCheckbox->GetValue())			*exportable = TRUE;		else			*exportable = FALSE;	}	return err;}	voidCSignDialog::DomainToRegExp(	char		*domain,	char		*regExp ){	char 		*s = domain,				*d = regExp;		strcpy( d, "<[^>]+[@.]" );	d += strlen( d );		for( ; *s; s++ )	{		switch( *s )		{			case '*':			case '+':			case '?':			case '.':			case '^':			case '$':			case '\\':			case '[':			case ']':			case '-':				*d++ = '\\';				*d++ = *s;				break;			default:				*d++ = *s;				break;		}	}	*d++ = '>';	*d++ = '$';	*d++ = '\0';}	voidCSignDialog::Sign(){	PGPError					err;	Boolean						success = FALSE;	PGPBoolean					ksSync,								split = FALSE;	CSecureCString256			passphrase;	PGPByte						*passKey = NULL;	PGPSize						passKeySize;		Hide();	err = PGPGetPrefBoolean(gPrefRef,				kPGPPrefKeyServerSyncOnKeySign, &ksSync);	pgpAssertNoErr(err);		UDesktop::Deactivate();	{		PGPGetPassphraseSettings	signDialogFlags;		char						promptCStr[256];		Str255						promptStr;				::GetIndString(	promptStr,						kStringListID,						kEnterPassphrasePromptStringID);		PToCString(promptStr, promptCStr);		err = PGPClientSigningPassphraseDialog			(	gPGPContext,				CPGPKeys::TheApp()->GetKeySet(),				promptCStr,				kPGPGetPassphraseOptionsHideFileOptions,				0,				mSigner,				passphrase,				&signDialogFlags,				&mSigner );	}		if( err == kPGPError_KeyUnusableForSignature )	{		PGPGetKeyBoolean( mSigner, kPGPKeyPropIsSecretShared, &split );		if( split )			err = PGPReconstitutionDialog( mSigner,				CPGPKeys::TheApp()->GetKeySet(), gTLSContext,				&passKey, &passKeySize);	}	UDesktop::Activate();		if( IsntPGPError( err ) )	{		Int32			uIndex;		PGPUserIDRef	userID;		Boolean			dupeWarning = FALSE;		PGPUInt32		trustLevel,						expirationDays = 0;		Boolean			exportable,						domainRestrict = FALSE;		char			domainRegExp[256];				if( IsntPGPError(				GetParams( &trustLevel, &exportable, &expirationDays ) ) )			for(uIndex = mNumUserIDs - 1; uIndex >= 0; uIndex--) 			{				if(mUserIDs[uIndex].type == kKey)				{					err = PGPGetPrimaryUserID(mUserIDs[uIndex].u.key,												&userID);					pgpAssertNoErr(err);				}				else if(mUserIDs[uIndex].type == kUserID)					userID = mUserIDs[uIndex].u.user;				if( ( trustLevel == 1 ) && exportable )				{					Str255	domainPString;					char	domainCString[256];										mDomainEdit->GetDescriptor( domainPString );					if( domainPString[0] > 0 )					{						PToCString( domainPString, domainCString );						DomainToRegExp( domainCString, domainRegExp );						domainRestrict = TRUE;					}				}				CPGPKeys::TheApp()->GetMinimumRandomData();				err = PGPSignUserID( userID, mSigner,					PGPOExpiration( gPGPContext, expirationDays ),					PGPOExportable( gPGPContext, exportable ),					PGPOSigTrust( gPGPContext, trustLevel,									kPGPKeyTrust_Complete ),					split ?						PGPOPasskeyBuffer( gPGPContext, passKey, passKeySize ):						PGPOPassphrase( gPGPContext, passphrase ),					domainRestrict ?						PGPOSigRegularExpression( gPGPContext, domainRegExp ) :						PGPONullOption( gPGPContext ),					PGPOLastOption( gPGPContext ) );				if( err == kPGPError_DuplicateCert )				{					if( !dupeWarning )					{						CWarningAlert::Display(kWACautionAlertType,										kWAOKStyle,										kStringListID,										kDuplicateCertID);						dupeWarning = TRUE;					}				}				else				{					pgpAssertNoErr(err);					if(IsntPGPError(err))						success = TRUE;					if(ksSync && exportable)					{						err = PGPSendKeyToServer(							gPGPContext, gTLSContext,							mUserIDs[uIndex].ownerKey, NULL);						if(IsPGPError(err) &&							(err != kPGPError_UserAbort))							ReportPGPError(err);					}				}			}		if(success)		{			CPGPKeys::TheApp()->CommitDefaultKeyrings();			BroadcastMessage(kKeyTableResyncMessage, NULL);		}	}	if( IsntNull( passKey ) )		PGPFreeData( passKey );}	voidCSignDialog::ListenToMessage(	MessageT	inMessage,	void		*ioParam ){	switch(inMessage)	{		case kSignButton:			Sign();		case kCancelButton:			delete this;			break;		case kAdvancedButton:			{				Rect		windBounds;				Str255		str;								if(mAdvancedMode)				{					mSignTypesGroup->Hide();					mExpireTypesGroup->Hide();					mExportCheckbox->Show();					GetMinMaxSize(windBounds);					ResizeWindowTo(windBounds.right, windBounds.top);					GetIndString(	str,									kStringListID,									kAdvancedOptionsStringID);				}				else				{					mExportCheckbox->Hide();					mSignTypesGroup->Show();					mExpireTypesGroup->Show();					CalcStandardBounds(windBounds);					DoSetBounds(windBounds);					GetIndString(	str,									kStringListID,									kFewerOptionsStringID);				}				mAdvancedButton->SetDescriptor(str);				mAdvancedMode = !mAdvancedMode;			}			break;		case kExpirationArrows:		{			Int32	newValue = *(Int32 *)ioParam;			if(newValue < mLastArrowValue)				mExpirationDate->AdjustValue(kDownAdjust);			else				mExpirationDate->AdjustValue(kUpAdjust);			mLastArrowValue = newValue;			break;		}		default:			LGADialog::ListenToMessage( inMessage, ioParam );			break;	}}	voidCSignDialog::FindCommandStatus(	CommandT	inCommand,	Boolean		&outEnabled,	Boolean		&outUsesMark,	Char16		&outMark,	Str255		outName){	#pragma unused( inCommand, outUsesMark, outMark, outName )		outEnabled = FALSE;}CUserIDList*CUserIDList::CreateFromStream(	LStream	*inStream){	return (new CUserIDList(inStream));}CUserIDList::CUserIDList(	LStream	*inStream)		: LTableView(inStream){	mTableGeometry = new LTableMonoGeometry(this, mFrameSize.width, 18);	mTableSelector = new LTableSingleSelector(this);	mTableStorage = new LTableArrayStorage(this, sizeof(KeyTableRef));}	voidCUserIDList::DrawSelf(){	Rect frame;	::RGBForeColor(&UGAColorRamp::GetColor(colorRamp_Gray1));	::RGBBackColor(&UGAColorRamp::GetColor(colorRamp_White));	CalcLocalFrameRect(frame);	{		StDeviceLoop	devLoop(frame);				SInt16			depth;		while(devLoop.NextDepth(depth))		{			if(depth > 1)				::PaintRect(&frame);			else				::EraseRect(&frame);		}	}	LTableView::DrawSelf();}	voidCUserIDList::DrawCell(	const STableCell	&inCell,	const Rect			&inLocalRect){	StDeviceLoop	devLoop(inLocalRect);			SInt16			depth;	Uint32			dataSize = sizeof(KeyTableRef);	PGPError		err;	KeyTableRef		keyRef;	PGPUserIDRef	userID;	Str255			str;	size_t			len;	Rect			sortColumnRect;	PGPInt32		algorithm;	short			iconResID;	PGPBoolean		isAttributeID;		while(devLoop.NextDepth(depth))	{		if(depth >= 8)		{			// Draw MacOS8-like background for cells, selected column			::RGBForeColor(&UGAColorRamp::GetColor(colorRamp_Gray1));			::PaintRect(&inLocalRect);			::RGBForeColor(&UGAColorRamp::GetColor(colorRamp_Gray2));			sortColumnRect = inLocalRect;			sortColumnRect.right = inLocalRect.left + kUserIDColumnWidth;			::PaintRect(&sortColumnRect);			::RGBForeColor(&UGAColorRamp::GetColor(colorRamp_White));			::MoveTo(inLocalRect.left, inLocalRect.bottom - 1);			::LineTo(inLocalRect.right - 1, inLocalRect.bottom - 1);			::RGBForeColor(&UGAColorRamp::GetColor(colorRamp_Black));		}		else		{			::RGBForeColor(&UGAColorRamp::GetColor(colorRamp_Black));			::RGBBackColor(&UGAColorRamp::GetColor(colorRamp_White));			::EraseRect(&inLocalRect);		}		GetCellData(inCell, &keyRef, dataSize);		if(keyRef.type == kKey)		{			err = PGPGetPrimaryUserID(keyRef.u.key, &userID);			pgpAssertNoErr(err);		}		else if(keyRef.type == kUserID)			userID = keyRef.u.user;		::RGBForeColor(&UGAColorRamp::GetColor(colorRamp_Black));		::RGBBackColor(&UGAColorRamp::GetColor(colorRamp_White));				err = PGPGetUserIDBoolean( userID, kPGPUserIDPropIsAttribute,					&isAttributeID );		pgpAssertNoErr( err );				if( isAttributeID )		{			PGPInt32	attributeType;			short		strIndex;						err = PGPGetUserIDNumber( userID,					kPGPUserIDPropAttributeType, &attributeType );			pgpAssertNoErr( err );						if( attributeType == kPGPAttribute_Image )			{				strIndex 	= kPhotographStringID;				iconResID	= kPhotoUserIDIconID;			}			else			{				strIndex 	= kUnknownStringID;				iconResID	= kUnknowUserIDIconID;			}			::GetIndString(	str, kStringListID, strIndex);		}		else		{			err = PGPGetKeyNumber(keyRef.ownerKey, kPGPKeyPropAlgID,									&algorithm);			pgpAssertNoErr(err);						if( algorithm == kPGPPublicKeyAlgorithm_DSA )			{				iconResID = kDHUserIDIconID;			}			else			{				iconResID = kRSAUserIDIconID;			}			err = PGPGetUserIDStringBuffer(userID, kPGPUserIDPropName,					sizeof(Str255) - 1, (char *)&str[1], &len);			str[0] = len;		}				CKeyTable::DrawIcon(iconResID, inLocalRect, -1);		pgpAssertNoErr(err);		::TextSize(9);		::TextFont(kFontIDGeneva);		::TextFace(0);		::TruncString(	kUserIDColumnWidth - 22, str, truncMiddle);		::MoveTo(inLocalRect.left + 22, inLocalRect.bottom - 5);		::DrawString(str);		::MoveTo(	inLocalRect.left + kUserIDColumnWidth + 4,					inLocalRect.bottom -5);		CKeyInfoWindow::GetFingerprintString(str, keyRef.ownerKey);		::DrawString(str);	}}	voidCUserIDList::HiliteCellActively(	const STableCell	&inCell,	Boolean				inHilite){	#pragma unused( inCell, inHilite )}	voidCUserIDList::HiliteCellInactively(	const STableCell	&inCell,	Boolean			 	inHilite){	#pragma unused( inCell, inHilite )}	voidCUserIDList::ClickSelf(	const SMouseDownEvent &inMouseDown){	#pragma unused( inMouseDown )}CUserIDHeaders::CUserIDHeaders(LStream *inStream)		: LPane(inStream){}CUserIDHeaders::~CUserIDHeaders(){}	voidCUserIDHeaders::DrawSelf(){	Rect				frame;	Str255				title;		FocusDraw();	CalcLocalFrameRect(frame);	ApplyForeAndBackColors();	::FrameRect(&frame);	::RGBForeColor(&UGAColorRamp::GetColor(colorRamp_White));	::MoveTo(frame.left+1, frame.bottom-1);	::LineTo(frame.left+1, frame.top+1);	::LineTo(frame.right-2, frame.top+1);	::RGBForeColor(&UGAColorRamp::GetColor(colorRamp_Gray7));	::MoveTo(frame.left+2, frame.bottom-1);	::LineTo(frame.right-2, frame.bottom-1);	::LineTo(frame.right-2, frame.top+2);	::RGBForeColor(&UGAColorRamp::GetColor(colorRamp_Black));	::TextFont(kFontIDGeneva);	::TextSize(9);	::TextFace(bold);			::GetIndString(title, kStringListID, kNameColumnStringID);	::MoveTo(frame.left + 4, frame.top + 12);	::DrawString(title);	::GetIndString(title, kStringListID, kFingerprintColumnStringID);	::MoveTo(frame.left + kUserIDColumnWidth + 4, frame.top + 12);	::DrawString(title);}