Path: msuinfo!agate!howland.reston.ans.net!news.cac.psu.edu!psuvm!wvnvm!c445585
Nntp-Posting-Host: 128.206.2.2
Date: Sun, 10 Jul 1994 23:30:09 -0400
From: C445585@mizzou1.missouri.edu
Newsgroups: sci.crypt
Subject: Hiding ciphertext in ciphertext, miscalculations
Message-ID: <16FEF13CD8S86.C445585@mizzou1.missouri.edu>
Organization: University of Missouri, Columbia
Lines: 78


   *Sigh*

   I *seriously* munged just about every calculation I did in last night's
post on hiding ciphertext in ciphertext.  (There's a problem with these
10:00 PM revelations that you just have to post....)

   I'm not going to work out the correct numbers just now, because the
back of my envelope has had a rough week, but let me cover the basic
problems:

1.  The E vector with 6 bits turned on won't have as many possibilities
    as I thought it would, because I didn't account for the overlapping
    possibilities.  You can clearly get better bandwidth by sticking in
    a few E bits than a whole all-together block of 32 bits, but the
    improvement isn't going to be nearly that good.  My original calc.
    was that the first bit could take any of 64 places, the next, any
    of 63, the next, any of 62, and so on.  I worked out that 64!/58!
    was > 2**32.  Of course, this doesn't deal with the fact that I
    don't care which bit gets turned on when.  Ie, choosing bit 10,
    then bit 11 is the same as choosing bit 11, then bit 10.  Sometime
    later this week, I'll sit down and work out the numbers.  However,
    I think I'll be posting all my calculations, too, so errors are
    obvious.

2 & 3.  This was even worse.  My poor stat professor would be crying in
    his beer to see this one--I multiplied the mutually exclusive
    probabilities, instead of adding them.  Of course, this morning,
    I asked myself the obvious question--how am I getting 32 bits of
    entropy from one 8-bit insertion--and the problem was obvious.

    Let's assume straight insertion--if we insert one character somewhere,
    we'll have 8 places we can insert it, and 256 possible values inserted.
    This means 256 * 8 possibilities, or 2048 possible variations.  When
    I worked it out last night, for some inexplicable reason, I raised
    256 to the 8th power.  It sure looked good....  The 2048 possible
    variations is approximate--sometimes, there won't be a change when we
    insert a specific character--but I think it's pretty good as an
    estimate.  (Imagine inserting an "A" in "AAAAAAAA"--there is no
    change.)

    Again, I'm not going to try to work out the correct values right now.

    To anyone with their natural BS-detectors on, the problem with 2 and
3 should be easy to see--how *does* one character give you 2**32
variations.  Unfortunately, some of these numbers do get unintuitive,
and I didn't show my calculations.  **sigh**

    In an old cryptologia article, there were suggestions for breaking
up patterns of known plaintext, using things like character insertions,
substitutions, and case-shifting.  These might still be generally useful,
but I don't see any way of getting 2**32 variations with each message
without some pretty serious munging of both the real and throwaway messages.

    It looks to me like some combination of random case-shifting and
insertion of three or so random characters might get us close to what we
need in terms of the number of variant messages.  I'll work out the
math (carefully, I hope) later.  One thing that I was thinking about
was how to find these message pairs we'd need for two given keys.
One possibility:

     T(i,j) = Dec(Enc(Variation(M(i),j),K0),K1)

     Now, try to find a short string distance from T(i,j) to X(i).
Maybe this could be speed optimized, I don't know.  With some ciphers,
like DES or FEAL, the Dec(Enc()) construct can be made faster than a
separate encrypt and decrypt.  (With DES, IP-1 and IP cancel out,
with FEAL and BLOWFISH (among others), you can collapse some of the
subkey XORs together.  It looks to me like a practical scheme would
generate as many X(i) variations as possible, and then look for paths
to them.  Maybe brute-force approaches would wind up being more
efficient, though.

     I'll keep looking at this.  Meanwhile, anyone who can give me
better estimates of how many free-floating bits needed to be in E,
and how many freely-inserted characters must be inserted in X() and
M() blocks, I'd appreciate hearing from you.

   --John Kelsey, c445585@mizzou1.missouri.edu
