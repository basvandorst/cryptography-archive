Path: msuinfo!agate!dog.ee.lbl.gov!ihnp4.ucsd.edu!swrinde!howland.reston.ans.net!spool.mu.edu!bloom-beacon.mit.edu!senator-bedfellow.mit.edu!athena.mit.edu!solman
From: solman@athena.mit.edu (Jason W Solinsky)
Newsgroups: sci.crypt
Subject: Re: Non-RSA Public Key Algorithms Wanted
Date: 18 Jul 1994 18:17:23 GMT
Organization: Massachusetts Institute of Technology
Lines: 56
Distribution: world
Message-ID: <30egvj$fse@senator-bedfellow.MIT.EDU>
References: <3045uv$t28@senator-bedfellow.MIT.EDU> <304qvm$9cj@northshore.ecosoft.com> <305i63$gsg@senator-bedfellow.MIT.EDU> <grinch-180794121015@grinch.tor.hookup.net>
NNTP-Posting-Host: e51-007-3.mit.edu

In article <grinch-180794121015@grinch.tor.hookup.net>, grinch@hookup.net (Reginald Braithwaite-Lee) writes:
|> In article <305i63$gsg@senator-bedfellow.MIT.EDU>, solman@athena.mit.edu
|> (Jason W Solinsky) wrote:
|> 
|> > If for some reason you HAD to use a public key system for encryption
|> > I would suggest probabilistic encryption using a Blum Blum Shub Pseudorandom
|> > generator as mentioned in applied cryptography. Its faster. Its possible
|> > to do most of the calculation ahead of time in large netwroked situations
|> > (like a digital cash syetem) without losing security so this makes it REALLY
|> > fast.
|> 
|> I wasn't able to figure out how to construct a public key system from
|> Bruce's descriptions of either the BBS generator or probabalistic
|> encryption. Is there a paper available (pref. online) or can you/someone
|> post an explanation?

Choose two large primes, p and q that are congruent to 3 modulo 4
(i.e. p mod 4 = 3; q mod 4 = 3). Choose a random seed x. On each iteration,
x(i+1) = (x(i)^2) mod n; (n = p*q). n is your public key, p and q are your
private key. You can't get p and q from n in less than superpolynomial time
(or so it is commonly believed) so for large n you just can't get p and q.

If x is 2^n bits long, on each iteration to lowest n bits of x will be truly
random. You can find any x(i) from any other x(i) by the following formula:
x(i)=(x(0)^((2^i) mod ((p-1)(q-1)))) mod n. Of course this is not helpful
if you don't have p and q.

That is BBS number generation.

To use this as an encryption algorithm, just XOR the random bits with the
message. At the end of the message include the last value of x. Somebody
with p and q will be able to figure out the first value of x from the last,
generate the same string of random numbers and XOR them with the ciphertext
to recover the plaintext.

This is a form of probabilistic encryption. Probabilistic encryption in
general is any encryption algorithm to which a random seed is integral
to the encryption process such that for any given plaintext there are many
possible ciphertexts.

Here is a reference from cypherpunks.

>Congratulations! You've just described the Blum-GoldWasser Efficient 
>Probabilistic Public-Key Encryption Scheme, first outlined in Crypto 84.
>Nice description in Schneier, who says it's much faster and more secure
>than any other PK scheme, but can obviously only be used one-way as it's
>vulnerable to a chosen plaintext attack. It would be possible to cook up 
>a protocol to allow for signatures as well, but it'd be tricky.

I don't agree with this last statement. I've convinced myself that this
is not possible without fundamentally altering the process.
I'd be happy to be proven wrong though.

Cheers,

JWS
