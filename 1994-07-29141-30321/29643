Path: msuinfo!agate!howland.reston.ans.net!europa.eng.gtefsd.com!news.umbc.edu!olson
From: olson@umbc.edu (Bryan G. Olson; CMSC (G))
Newsgroups: sci.crypt
Subject: Re: Detecting Encrytion
Date: 13 Jul 1994 22:39:43 GMT
Organization: University of Maryland, Baltimore County
Lines: 32
Distribution: world
Message-ID: <301qff$lgh@news.umbc.edu>
References: <2vskih$155@xmission.xmission.com>
NNTP-Posting-Host: umbc7.umbc.edu
X-Newsreader: TIN [version 1.2 PL2]

Berzerk (berzerk@xmission.com) wrote:
: Here is how I would do it.

: Zero, don't include "giveaways" like "begin pgp ..." etc, and un uuencode 
: uuencoded files.

: First, take a population count.  If the number of standard deviations 
: from a random sequence is greater than some cutoff, throw it out.
: You could make hardware to do this on the sequence, and its diferential 
: easily.  I think the vast majority of files will not fit this.

: Second, do specific filters, generated from having people look at what 
: gets through the first filter, but is still a gif file, a file from an 
: instrument, or something with characteristics like that.

: This suggests that simply padding a message with lots of zeros or adding 
: non-random repetative data would escape this simple test.  Any 
: stenographic method would do, unless the data was first "un steno.exe"ed.

Or we could get elegant.  Develop as high order a Markov model of your
camouflage language as you can afford.  To encode, use the Markov
model probabilities to drive a state-dependent arithmetic decoder (use
the encrypted bit stream as if it were an arithmetic encoding based on
the Markov probabilities).  Arithmetically decode on the receiving
end.

If the camouflage language is well-approximated by the Markov model,
the fake should be very hard to detect automatically, and it should
provide about as high a rate of information as the language allows.

--Bryan

