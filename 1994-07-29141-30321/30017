Newsgroups: sci.crypt
Path: msuinfo!agate!library.ucla.edu!csulb.edu!csus.edu!netcom.com!adamt
From: adamt@netcom.com (Adam Thornton)
Subject: Free Dinner!
Message-ID: <adamtCtF9y4.4x6@netcom.com>
Organization: NETCOM On-line Communication Services (408 261-4700 guest)
Date: Sun, 24 Jul 1994 02:08:28 GMT
Lines: 118

The first time I posted this scheme, it was met with deafening silence.
Since I'd like to find out that it has a big and stupid hole in it *before*
I actually build something around it, I'd like to once again invite
comments and offer the following challenge: the first person to show me
(and first, in this case, is whoever gets to my mailbox first or the first
message that gets to netcom's news spool) why this scheme won't work gets
dinner someplace relatively nice, on me, any time we happen to both be in
the same city.


Adam


-----BEGIN PGP SIGNED MESSAGE-----

Adam Thornton						July 23, 1994 
 
A METHOD FOR STREAM CRYPTOGRAPHY USING A LARGE PUBLIC POOL OF RANDOM 
NUMBERS 
 
This scheme appears to be a variant of Maurer (cf. [Schneier 367,592]);
however, his scheme comes from an information-theoretic standpoint and does
not really address practical concerns.  Mine does, but probably is not
provably-secure.
 
First, a large pool (2**20 or more) of random bits is needed.  This pool 
can--and probably should--be public; perhaps the first few million bits 
of a binary expansion of a well-known constant, such as pi or e can be 
used, if either of those turn out to have a random bit distribution (if 
not, they can still be used, but more digits will be required for 
equivalent security [Schneier 372]).  Making the pool's source public is 
merely a convenient way to ensure that people believe that your random 
numbers truly are random.  We will assume a pool of 2**n bits, as this 
is both a convenient memory size and makes selection of one of our 
parameters easy; however, nothing in the algorithm strictly requires 
such a size. 
 
Second, a true random number source is necessary; amplifier noise--if 
it turns out to be truly random--or radioactive decay are reasonable
ways to produce random bits.  The important thing is that the random 
number generator must generate a random sequence--probably based on 
environmental phenomena--rather than a pseudorandom sequence. 
 
Third, a method of providing secure data exchange will be necessary.  
The obvious approach is to use RSA public-key algorithms to generate an 
IDEA session key, since this does not presuppose secure channels of 
communication.  Using a strong one-way hash function, voice verification 
of the hash value will provide reasonable assurance that the keys are 
not being spoofed.
 
The cryptographic technique is very simple--essentially, it rests of the 
generation of a succession of (for all practical purposes) one-time pads 
drawn from the large pool of random bits.  There will be a stream of 
plaintext bits P, which will be XOR'ed with a confusion stream C for 
transmission, and XOR'ed again at the other end with the same stream for 
decryption.  Generation of the stream C is, of course, the crux of the 
matter. 
 
Each cycle of encryption will consist of b bits.  b is determined in the 
implementation and should not be an appreciable fraction of 2**n; this 
is not expected to be a problem, since n will be at a minimum 24.
 
Once an IDEA session key has been generated and transmitted (encrypted 
with a public-key algorithm), that (random) key will be used to 
encrypt bits drawn from the random number generator, transmitted in 
blocks; each block will consist of some number (determined by the 
implementation) of offset-increment pairs.  Each pair will remain valid 
for one cycle of length b.  The offset will be n bits long and the 
increment n-1--in actuality the increment is also n bits, but its least 
significant bit is always 1. 
 
This pair will be used to encrypt the plaintext bits P0 - Pb in the 
following manner: C0 will be the bit at the address given by the offset, 
C1 will be the bit at (offset + increment) modulo 2**n, and so on 
through Cb, which gets the contents of (offset + b(increment)) modulo 
2**n.  Making the LSB of the increment 1 ensures that it is relatively 
prime to 2**n, and therefore yields a pseudo-random number generator 
with period 2**n. 
 
When b is reached, the next pair of random numbers is taken and a new 
cycle begins.
 
In a practical application, one would probably be generating new blocks 
of offset-increment pairs while the previous set was being used; after 
some number of cycles, transmission would pause while the new blocks 
were sent between the parties.  In this way, indefinitely long 
transmissions can be maintained. 
 
A naive analysis suggests that--assuming the security of the block 
exchange, which if done via properly implemented RSA and IDEA ought to 
be reasonably assured--a brute-force attack will take at most 2**(2n-1) 
attempts: the initial offset can be any of the 2**n bits in the pool, 
and the increment can be any odd number in the same range, which gives 
2**(n-1) possibilities.  Thus a brute-force attack can expect to 
succeed, on average, in 2**(2n-2) attempts.  If n is large, this should 
provide reasonable security.  An n in the neighborhood of 24 should be 
attainable cheaply, since that would require only 2MB of storage for the 
random number pool. 
 
This scheme may well have a fatal flaw; it is necessary to encourage 
extensive review before implementing it anywhere, and certainly before 
using it to encrypt real transmissions.

-----BEGIN PGP SIGNATURE-----
Version: 2.6

iQCVAgUBLjHK8zBaGipcb5htAQG91gP/VwFE0strnRqv8OGbHURUPKq+6jma04Qu
A3nRY9IbZ0zlvu+FY3aPn3PR1hThVcIn3GgF9q0mvjHJtPmc/Mw1L3CKcOgiDoj+
xlGP9TPZshhUMtIH5E3lz1Rb2tWWeEyIpRO2yNsrdyEfLq9MN4t5rEGqMR/8iHrz
g1GCmR6mMZI=
=NPGt
-----END PGP SIGNATURE-----

-- 
adam@io.com | adamt@netcom.com | adam@phoenix.princeton.edu | Viva HEGGA!
"Double integral is also the shape of lovers curled asleep" : Pynchon
64,928 | TEAM OS/2 |   "Ich habe einen Bierbauch!"   |  Linux  | Fnord
You can have my PGP passphrase when you pry it from my cold, dead brain.
