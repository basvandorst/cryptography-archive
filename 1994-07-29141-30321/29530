Path: msuinfo!agate!howland.reston.ans.net!europa.eng.gtefsd.com!news.umbc.edu!olson
From: olson@umbc.edu (Bryan G. Olson; CMSC (G))
Newsgroups: sci.crypt
Subject: Re: Hiding Ciphertext in Ciphertext
Date: 10 Jul 1994 06:02:39 GMT
Organization: University of Maryland, Baltimore County
Lines: 236
Message-ID: <2vo2tv$ll0@news.umbc.edu>
References: <2vc9j8$i22@news.umbc.edu>
NNTP-Posting-Host: umbc7.umbc.edu
X-Newsreader: TIN [version 1.2 PL2]


In <2vc9j8$i22@news.umbc.edu> I wrote:

: I will describe an encrypted file
: system which supports true plausible duress texts with little
: effect on the time or space efficiency of the system.  This is
: not security by obscurity.  No one can distinguish duress data
: from real data without breaking the cipher.

: I'll follow this up in a couple of days with the details of
: how this could be done.  The key is that all free space is

Well, only one person followed up my post on a true
cryptographic duress-code, so perhaps there is not as much
interest as I thought.  The one responder didn't really
understand what I was claiming this could do, so I'll give a
little background on how I came to this.

First, someone proposed a "hacked" method of simply hiding
ciphertext in pages marked as free.  The next step would be to
fill truly free pages with random noise, so an adversary could
never tell if they contained encrypted data, or just noise.
This is channel-stuffing for disks.

Next suppose we write an encrypted file system which can also
hide other data in free blocks, and always fills truly free
blocks with random noise.  The system would have a duress code
option; a user may or may not set up a duress code.  If the
option is in use, and you enter the true key, you see all the
files.  If you enter the duress key, you see only a subset of
the files, as the others are actually in pages which appear to
be free.  Most importantly, the data that can be decrypted
with the duress code, including all system information, is of
exactly the same form as what can be decrypted by a true key
if the duress option were _not_ in use.  The system itself
would be unable to tell if were decrypting with a duress code,
or with the master key on a disk which has no duress code.

A user who does not use the duress code feature can never
prove he does not (unless there is no free space on his disk).
His true disk could still be a duress disk, and other data
could be hidden in the apparently free pages.

Still, the mere fact that the software on the system has this
capability is a giveaway.  Why have this extra mechanism if it
goes unused ?

So instead of just two levels, master and duress, we write the
system to support duress codes within duress codes.  Every
duress code appears to be the master key, unless and until a
parent key is exposed.  Slightly more general than this
nesting is a tree of keys.  Each key could have more than one
duress code within it.  (Actually I expect the simple nesting,
in which each key has at most one duress key directly under it
would be the most used configuration, but it's a special case
of a hierarchy.)


As an example of the use of the system I wrote:

: Suppose I'm keeping my plan to overthrow Freedonia secret, and
: I keep all my data on the virtual disk.  The Freedonian secret
: police put a gun to my head and order me to tell them the pass
: phrase.  I give it to them, but when they use it to open the
: disk, they find the disk contains only my grandmother's secret
: recipe for fudge, and no duress disks are present.

: They put the gun back to my head.  

: "OK, OK," I tell them.  "The pass phrase is really ..."  They
: open the disk using this pass phrase, and now they find that
: the what they saw before was not really the master disk, but a
: duress disk within the disk they now see.  Here they also find
: bad poetry.  All this new data they can see, the poetry and
: all the directory and system bookkeeping information, is in
: pages which appeared to be free in the recipe disk.

: They pull out the gun again.

: Again I tell them a pass phrase, and this time they find the
: bad poetry disk was not the master disk, but within another
: which also contains a diary of my torrid affair with an ugly
: woman, or letters to my proctologist about some embarrassing
: condition.

: At each step the disk they look at appears to be the master
: disk.  Should I ever reveal my master pass phrase, they would
: still not be able to rule out that it too is just a duress
: disk inside other.

Note that what they see when they open a disk with the duress
code is not limited by the software refusing to show them
anything.  They see everything that can be decrypted by the
given key.

First, my (as yet unimplemented) file system needs a name.
I'll call it "Whisper", and talk about it as if it were
written.  Whisper allows multiple keys to be created, each of
which can show a different file system on the disk, which I
will call "views" of the disk.  Actually, the views form a
hierarchy, with the master view at the top.  When the user
enters his master key, all the views on the disk are opened.
The user can read from and write to any view.

The trick is that when a duress key opens the disk, Whisper
can find that view and its descendents in the hierarchy, but
that view does not even appear to have a parent.  A duress
view, when opened by the duress key, appears to be the master
view.

The only feature which distinguishes the master view is that
it is at the root of the tree of views.  But opening any
duress view only reveals the sub-tree rooted at that view.



Implementation

To implement this idea, a Whisper disk, as with most file
systems, is divided into pages.  Pages are either in use by
the file system to store user data or system bookkeeping
information, or they appear to be free.  All free pages are
filled with cryptographically generated random noise.

Each view has a system data area (like a "boot block") which 
contains:
  A crypto-checksum on the view's key,
  A map pages used by this view and it's descendants,
  A list of duress views which are children of this view, 
    along with keys to these views and pointers to their 
    systems data areas,
  A pointer to the view's root directory.

Thus a view can decrypt all its descendant views, but there is
no note of the existence of a parent view.

Note that only the master view knows what pages are really
free.  Thus the user should only write to the disk while the
master view is open.  If he opens the disk with a duress key
and writes a new page, it is likely to overwrite a page in use
by some other view.


Placement of Data

Even if the system bookkeeping information does not reveal the
presence of hidden data, the layout of the files might.  If a
file is using pages 2000 to 2010 and 2014 - 2020, while
2011-2013 are unused, there would seem to be a good chance
that pages 2011 - 2013 actually hide some other file.

There are several possible solutions, but the goal of all of
them must be that for any subset of views, the probability of
any given layout of pages is (at least nearly) independent of
the number and size of outside views.

The easiest solution would be random layout.  The placement of
each page is chosen uniformly from all free pages.  This could
be made reasonably efficient if we allocate large pages (say
128K) to views and divide these into smaller blocks (like 1K)
which are the allocation unit for files.  Thus files would
only have to be dis-contiguous when crossing a 128K boundary.
This would also decrease the size of the used and free page
map each view must keep.

If we limit ourselves to one child duress view per view, we
could adopt any allocation strategy within a view and move
pages used in higher level views when needed.

Finally, the most efficient layout is probably to have each
vies and all files within a view contiguous.  This would not
seem to expose the presence of other views, since free space
would also be in contiguous expanses.  Perhaps an incremental
de-fragmentation daemon could maintain both efficiency and
security.  It would take more work to write the software and
do the statistical analysis to show that it doesn't leak
information.


Placement of system data area

When a user opens a (view of) a disk, Whisper needs to find
the system data area.  Most other file systems (cryptographic
or not) would put such data at a fixed location, but that
would defeat master/duress ambiguity.

Instead, Whisper uses a hash function on the key to generate a
sequence of pages to try, say 20 of them.  It then searches
these for a valid checksum.  If none of the pages passes, then
it reports the pass-phrase was incorrect.  If a checksum
passes, then it has found the first page of the system data
area for that (view of) the disk.

When a view is created, Whisper does not simply take the first
of the 20 pages in the hash sequence which is free (Remember a
duress view is created within another view, and like any
operation which writes to the disk, it should only be done
while the master view is open).  Instead it finds all which
are free, and selects one of these to use at random (actually
I think it should be somewhat biased toward the far end when
many are free, and the near end when most are in use).  Thus
the fact that the system data area was found on the 20'th
probe does not reveal that the first 19 pages tried were
actually in use.


There are still a few details to be worked out, and I suppose
I really should implement the thing.  Unfortunately the
interfaces to installable file systems seem to be very poorly
documented, and I don't even have my own machine, so don't
hold your breath.

Also I'll cite one interesting alternative proposed by Michael
Maudlin and Howard Gayle (see <20hqjsINNm0q@hal.com>).  The
"Spread Spectrum File System" starts filled with random bits.
To store a file, it encrypted, expanded with (lots of) error
correction information, and stored in a pseudo-random sequence
of bit positions generated by a hash of the key and some
initialization vector.  Files stored later will over-write
some of the bits, but hopefully the error correction will
still allow its recovery.

The spread-spec system has the advantage that each key is
truly independent.  Multiple parties can use it at once.  It
has the disadvantage that it's inefficient since every file is
spread all over the disk, you can't fill it near full without
losing large amounts of data, and files "fade" till they're
lost (quite quickly in highly dynamic systems).  Still it's an
interesting idea and I think there's a paper in it for anyone
who wants to figure out how much you can store and change with
what probability of lost data.


--Bryan


