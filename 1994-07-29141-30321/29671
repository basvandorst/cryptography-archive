Path: msuinfo!agate!howland.reston.ans.net!math.ohio-state.edu!hobbes.physics.uiowa.edu!news.uiowa.edu!uunet!newsgate.watson.ibm.com!watnews.watson.ibm.com!locutus.rchland.ibm.com!wo0z.rchland.ibm.com!lwloen
From: lwloen@wo0z.rchland.ibm.com (Larry Loen)
Newsgroups: sci.crypt
Subject: Re: FAQ
Date: 14 Jul 1994 21:14:19 GMT
Organization: IBM Rochester MN
Lines: 59
Distribution: world
Message-ID: <3049rb$18le@locutus.rchland.ibm.com>
References: <CsupCJ.16C@adl33cc.adelphi.edu>
Reply-To: lwloen@rchland.vnet.ibm.com
NNTP-Posting-Host: wo0z.rchland.ibm.com

In article <CsupCJ.16C@adl33cc.adelphi.edu>, cr9825g92@auvax1.adelphi.edu writes:
|> Where can I find the FAQ's to this group.  I had them but no longer. :( 
|> Pls point me to an FTP site.  Also a question:  How would you go about attacking this system?
|> Blocks of plaintext are taken in either 256, 512 or 1024 chars per block.
|> The key is of the respective size 256, 512 or 1024 digits.  Where the key is one 
|> of the permutations of the size's factorial value.  The plainttext block is then 
|> is then arranged in the order of the permutation and shifted along the ascii alphabet
|> the value of the key digit.
|> EX:
|> PLAINTEXT:
|> This is plaintext.
|> KEY:
|> 2 5 1 4 6 3
|> CYPHERTEXT:
|> jVlwm_ qulo_g
|> you get the idea.  Im doing this from memory so i dont know the shifts of the _'s
|> Thanx
|> The Puppetmaster


1.  Let's assume the blocksize is 256 (since you only specify two other sizes,
 this only means we have 1/3 as much to talk about, so not much lost).

2.  Take the plaintext in blocsk of 256 and line them up vertically.
 Horizontally, you have the encrypted text of each original cipher block.
 Vertically, however, you have a sequence of unrelated characters from
 different blocks, but all with the same shift value.

3.  Presume (as one ordinarily would) that you know enough about what kind
 of plaintext is being sent to know or estimate the frequency count. 
 For instance, an Intenet newsgroup would be about 20% space characters,
 11% lower case 'e', etc.

5.  Find the shift value which, when you decrypt the column, best matches
 the expected frequency count.

6.  Assuming that is the correct index, un-transpose each column.  (If you have
 multiple columns with the same index, this would have to be dealt with,
 too, but probably not a big deal in practice.  The gap between the space
 character and everything else ought to help, also).  If all the column indicies
 are correct, you may read the recovered plaintext off by reading horizontally.
 If a few are wrong, it is often pretty obvious how to fix them.

Based on my experience with this sort of thing, I would expect that any
message exceeding roughly 2560 bytes would be an easy target; a simple,
brute force computer program would get at least 80% of the columns correct
and the rest could be fixed by hand.

You could rescue this system, to a degree, by having more sizes than
just 256, 512, and 1024 (which are not particularly good choices anyway).
Odd sizes like 51 may work better, but not enough to spit at.  This is
not going to be a very good system no matter how you patch it up.  This
is old, well-ploughed, and abandoned ground.

-- 
   Larry W. Loen        |  My Opinions are decidedly my own, so please
                        |  do not attribute them to my employer

   email to:  lwloen@rchland.vnet.ibm.com
