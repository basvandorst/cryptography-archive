Path: msuinfo!agate!headwall.Stanford.EDU!eillihca@drizzle.Stanford.EDU
From: eillihca@drizzle.StanFord.EDU ( Achille Hui, the Day Dreamer )
Newsgroups: sci.crypt
Subject: Re: bit switching, rearranging, and Random bit stuffing
Date: 02 Jul 94 02:53:21 GMT
Organization: Dept. of Physics, Stanford University.
Lines: 46
Message-ID: <eillihca.9407011953214034@drizzle.Stanford.EDU>
NNTP-Posting-Host: drizzle.stanford.edu
X-Transfer-Agent: nntp.stanford.edu (NNTP)

+---sehari@iastate.edu (Babak Sehari)-writes---
|
|
| ----
| One of the ideas  that I have about cryption is to use a bit shifting by a
| 80 char key that is say we have key that the first byte of it is ascii car
| 32 (space) say the first bye to be encrypted is ascii char 50 now
| we read two char of the text to be encrypted say they are
| 01101101 and 01110111 now lets say our first key char is say 00001000
| now we shift the bits between these two text chars that their corespound...
| bit on the key byte has a one in it so since in this case only the fourth
| bit of the key has a 1 in it we just swicth the 4th bit of the text char
...

Unlike other posts from you, I can barely parse the content of this. Is this
a forgery or another challenge with some hidden message ;-)

| second char of the key is ascii char 44 we stuff a 0, 44 bits after this.
| Continue this way to the end of file.  If we reach to the end of the file
| and have say 6 more bits to stuff, we just append it to the end of file.
| This way we have even chars.
| 
| What do you think about this method, if the key is up to 80 chars long?
| 

In any event, the encoding is pretty weak, it can't withstand a single
chosen plain text attack. Let's say the length of your key is n, 
0 <= Ki < 256 (i = 1..n) be the i-th character in your key and define

	Si = i + Sum{Kj, j = 1..i}	for i = 1..n.

If you encode any plain texts which consists solely of nulls, the bit-
switching and bit-rearragement phases reduce to  nil operations As a
result, the positions of the 1-bits all have the form:
	
	Si + N Sn where N is a non-negative integer.

If this plain text of nulls is long enough, you can extract Sn and hence 
the Si by inspecting the distributions of the diffeneces among these numbers. 
The probablity of failure of this attack descreses exponentially with the
size of the plain text one choose. I'm not sure whelther this encoding can
withstand attacks based on multiple known pairs of plain and secret texts.
Can anyone shine some light?
------------------------------------achille (eillihca@drizzle.stanford.edu)


