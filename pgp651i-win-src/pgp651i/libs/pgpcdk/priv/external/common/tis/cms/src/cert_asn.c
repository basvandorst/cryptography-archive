/*******************************************************************
 *
 * This file was generated by TIS/ASN1COMP Ver. 4.2, an ASN.1 compiler.
 * TIS/ASN1COMP is Copyright (c) 1998, TIS Labs at Network Associates, Inc.
 *
 * This file was AUTOMATICALLY GENERATED on Mon May 17 09:25:53 1999
 *
 ******************************************************************/


#include <string.h>

#include "cert_asn.h"

/*******************************************************************
 *
 * Code for manipulating ASN.1 DER data and structure.
 *
 *  NewXXX: Allocate the top level of a structure.
 *
 *  FreeXXX: Release all the data of an ASN structure.
 *
 *  SizeofXXX: Return the size of the DER block that would
 *               be created from the structure.
 *
 *  PackXXX: Take an ASN structure and return the DER.
 *
 *  unPackXXX: Take the DER and return an ASN structure.
 *
 ******************************************************************/


size_t PKIPackBMPString(
    PKICONTEXT *ctx,
    unsigned char *buf,
    size_t buflen,
    PKIBMPString *asnstruct,
    int *erret )
{
    return(PKIPackBMPStringInternal(ctx, buf, buflen, asnstruct, PKIID_BMPString, erret));
} /* PKIPackBMPString */

size_t PKIUnpackBMPString(
    PKICONTEXT *ctx,
    PKIBMPString **asnstruct,
    const unsigned char *buf,
    size_t buflen,
    int *erret)
{
    size_t bytesused;
    bytesused=PKIUnpackBMPStringInternal(ctx, asnstruct, buf, buflen,
                      PKIID_BMPString, erret);
    if(*erret==0 && bytesused==0)
        PKIERR(PKIErrUnpackUnderrun);
    return bytesused;
}

size_t PKIPackUTF8String(
    PKICONTEXT *ctx,
    unsigned char *buf,
    size_t buflen,
    PKIUTF8String *asnstruct,
    int *erret )
{
    return(PKIPackUTF8StringInternal(ctx, buf, buflen, asnstruct, PKIID_UTF8String, erret));
} /* PKIPackUTF8String */

size_t PKIUnpackUTF8String(
    PKICONTEXT *ctx,
    PKIUTF8String **asnstruct,
    const unsigned char *buf,
    size_t buflen,
    int *erret)
{
    size_t bytesused;
    bytesused=PKIUnpackUTF8StringInternal(ctx, asnstruct, buf, buflen,
                      PKIID_UTF8String, erret);
    if(*erret==0 && bytesused==0)
        PKIERR(PKIErrUnpackUnderrun);
    return bytesused;
}

size_t PKIPackUniversalString(
    PKICONTEXT *ctx,
    unsigned char *buf,
    size_t buflen,
    PKIUniversalString *asnstruct,
    int *erret )
{
    return(PKIPackUniversalStringInternal(ctx, buf, buflen, asnstruct, PKIID_UniversalString, erret));
} /* PKIPackUniversalString */

size_t PKIUnpackUniversalString(
    PKICONTEXT *ctx,
    PKIUniversalString **asnstruct,
    const unsigned char *buf,
    size_t buflen,
    int *erret)
{
    size_t bytesused;
    bytesused=PKIUnpackUniversalStringInternal(ctx, asnstruct, buf, buflen,
                      PKIID_UniversalString, erret);
    if(*erret==0 && bytesused==0)
        PKIERR(PKIErrUnpackUnderrun);
    return bytesused;
}

/******************************************************************
 * Routines for noticeNumbers_SEQ_OF
 ******************************************************************/

PKInoticeNumbers_SEQ_OF *PKINewnoticeNumbers_SEQ_OF(
    PKICONTEXT *ctx)
{
    PKInoticeNumbers_SEQ_OF *f;

    if (ctx == NULL)
        return NULL;

    f = (PKInoticeNumbers_SEQ_OF *)PKIAlloc(ctx->memMgr, sizeof(PKInoticeNumbers_SEQ_OF));
    if (f != NULL)
        (void)memset(f, 0, sizeof(PKInoticeNumbers_SEQ_OF));
    return (f);

} /* PKINewnoticeNumbers_SEQ_OF */

void PKIFreenoticeNumbers_SEQ_OF(
    PKICONTEXT *ctx,
    PKInoticeNumbers_SEQ_OF *f)
{
    if (ctx == NULL)
        return;

    PKIDropInPlacenoticeNumbers_SEQ_OF(ctx, f);
    if (f != NULL)
        PKIFree(ctx->memMgr, f);

} /* PKIFreenoticeNumbers_SEQ_OF */

size_t PKISizeofnoticeNumbers_SEQ_OF(
    PKICONTEXT *ctx,
    PKInoticeNumbers_SEQ_OF *asnstruct,
    int outerSizeFlag)
{
    (void)ctx; /* for future use */

    return(PKISizeofnoticeNumbers_SEQ_OFInternal(asnstruct, outerSizeFlag, PKIFALSE));
} /* PKISizeofnoticeNumbers_SEQ_OF */

size_t PKIPacknoticeNumbers_SEQ_OF(
    PKICONTEXT *ctx,
    unsigned char *buf,
    size_t buflen,
    PKInoticeNumbers_SEQ_OF *asnstruct,
    int *erret )
{
    return(PKIPacknoticeNumbers_SEQ_OFInternal(ctx, buf, buflen, asnstruct, PKIID_noticeNumbers_SEQ_OF, erret));
} /* PKIPacknoticeNumbers_SEQ_OF */

size_t PKIUnpacknoticeNumbers_SEQ_OF(
    PKICONTEXT *ctx,
    PKInoticeNumbers_SEQ_OF **asnstruct,
    const unsigned char *buf,
    size_t buflen,
    int *erret)
{
    size_t bytesused;
    bytesused=PKIUnpacknoticeNumbers_SEQ_OFInternal(ctx, asnstruct, buf, buflen,
                      PKIID_noticeNumbers_SEQ_OF, erret);
    if(*erret==0 && bytesused==0)
        PKIERR(PKIErrUnpackUnderrun);
    return bytesused;
}

/******************************************************************
 * Routines for AlgorithmIdentifier
 ******************************************************************/

PKIAlgorithmIdentifier *PKINewAlgorithmIdentifier(
    PKICONTEXT *ctx)
{
    PKIAlgorithmIdentifier *f;

    if (ctx == NULL)
        return NULL;

    f = (PKIAlgorithmIdentifier *)PKIAlloc(ctx->memMgr, sizeof(PKIAlgorithmIdentifier));
    if (f != NULL)
        (void)memset(f, 0, sizeof(PKIAlgorithmIdentifier));
    return (f);

} /* PKINewAlgorithmIdentifier */

void PKIFreeAlgorithmIdentifier(
    PKICONTEXT *ctx,
    PKIAlgorithmIdentifier *f)
{
    if (ctx == NULL)
        return;

    PKIDropInPlaceAlgorithmIdentifier(ctx, f);
    if (f != NULL)
        PKIFree(ctx->memMgr, f);

} /* PKIFreeAlgorithmIdentifier */

size_t PKISizeofAlgorithmIdentifier(
    PKICONTEXT *ctx,
    PKIAlgorithmIdentifier *asnstruct,
    int outerSizeFlag)
{
    (void)ctx; /* for future use */

    return(PKISizeofAlgorithmIdentifierInternal(asnstruct, outerSizeFlag, PKIFALSE));
} /* PKISizeofAlgorithmIdentifier */

size_t PKIPackAlgorithmIdentifier(
    PKICONTEXT *ctx,
    unsigned char *buf,
    size_t buflen,
    PKIAlgorithmIdentifier *asnstruct,
    int *erret )
{
    return(PKIPackAlgorithmIdentifierInternal(ctx, buf, buflen, asnstruct, PKIID_AlgorithmIdentifier, erret));
} /* PKIPackAlgorithmIdentifier */

size_t PKIUnpackAlgorithmIdentifier(
    PKICONTEXT *ctx,
    PKIAlgorithmIdentifier **asnstruct,
    const unsigned char *buf,
    size_t buflen,
    int *erret)
{
    size_t bytesused;
    bytesused=PKIUnpackAlgorithmIdentifierInternal(ctx, asnstruct, buf, buflen,
                      PKIID_AlgorithmIdentifier, erret);
    if(*erret==0 && bytesused==0)
        PKIERR(PKIErrUnpackUnderrun);
    return bytesused;
}

/******************************************************************
 * Routines for AnotherName
 ******************************************************************/

PKIAnotherName *PKINewAnotherName(
    PKICONTEXT *ctx)
{
    PKIAnotherName *f;

    if (ctx == NULL)
        return NULL;

    f = (PKIAnotherName *)PKIAlloc(ctx->memMgr, sizeof(PKIAnotherName));
    if (f != NULL)
        (void)memset(f, 0, sizeof(PKIAnotherName));
    return (f);

} /* PKINewAnotherName */

void PKIFreeAnotherName(
    PKICONTEXT *ctx,
    PKIAnotherName *f)
{
    if (ctx == NULL)
        return;

    PKIDropInPlaceAnotherName(ctx, f);
    if (f != NULL)
        PKIFree(ctx->memMgr, f);

} /* PKIFreeAnotherName */

size_t PKISizeofAnotherName(
    PKICONTEXT *ctx,
    PKIAnotherName *asnstruct,
    int outerSizeFlag)
{
    (void)ctx; /* for future use */

    return(PKISizeofAnotherNameInternal(asnstruct, outerSizeFlag, PKIFALSE));
} /* PKISizeofAnotherName */

size_t PKIPackAnotherName(
    PKICONTEXT *ctx,
    unsigned char *buf,
    size_t buflen,
    PKIAnotherName *asnstruct,
    int *erret )
{
    return(PKIPackAnotherNameInternal(ctx, buf, buflen, asnstruct, PKIID_AnotherName, erret));
} /* PKIPackAnotherName */

size_t PKIUnpackAnotherName(
    PKICONTEXT *ctx,
    PKIAnotherName **asnstruct,
    const unsigned char *buf,
    size_t buflen,
    int *erret)
{
    size_t bytesused;
    bytesused=PKIUnpackAnotherNameInternal(ctx, asnstruct, buf, buflen,
                      PKIID_AnotherName, erret);
    if(*erret==0 && bytesused==0)
        PKIERR(PKIErrUnpackUnderrun);
    return bytesused;
}

/******************************************************************
 * Routines for AttributeTypeAndValue
 ******************************************************************/

PKIAttributeTypeAndValue *PKINewAttributeTypeAndValue(
    PKICONTEXT *ctx)
{
    PKIAttributeTypeAndValue *f;

    if (ctx == NULL)
        return NULL;

    f = (PKIAttributeTypeAndValue *)PKIAlloc(ctx->memMgr, sizeof(PKIAttributeTypeAndValue));
    if (f != NULL)
        (void)memset(f, 0, sizeof(PKIAttributeTypeAndValue));
    return (f);

} /* PKINewAttributeTypeAndValue */

void PKIFreeAttributeTypeAndValue(
    PKICONTEXT *ctx,
    PKIAttributeTypeAndValue *f)
{
    if (ctx == NULL)
        return;

    PKIDropInPlaceAttributeTypeAndValue(ctx, f);
    if (f != NULL)
        PKIFree(ctx->memMgr, f);

} /* PKIFreeAttributeTypeAndValue */

size_t PKISizeofAttributeTypeAndValue(
    PKICONTEXT *ctx,
    PKIAttributeTypeAndValue *asnstruct,
    int outerSizeFlag)
{
    (void)ctx; /* for future use */

    return(PKISizeofAttributeTypeAndValueInternal(asnstruct, outerSizeFlag, PKIFALSE));
} /* PKISizeofAttributeTypeAndValue */

size_t PKIPackAttributeTypeAndValue(
    PKICONTEXT *ctx,
    unsigned char *buf,
    size_t buflen,
    PKIAttributeTypeAndValue *asnstruct,
    int *erret )
{
    return(PKIPackAttributeTypeAndValueInternal(ctx, buf, buflen, asnstruct, PKIID_AttributeTypeAndValue, erret));
} /* PKIPackAttributeTypeAndValue */

size_t PKIUnpackAttributeTypeAndValue(
    PKICONTEXT *ctx,
    PKIAttributeTypeAndValue **asnstruct,
    const unsigned char *buf,
    size_t buflen,
    int *erret)
{
    size_t bytesused;
    bytesused=PKIUnpackAttributeTypeAndValueInternal(ctx, asnstruct, buf, buflen,
                      PKIID_AttributeTypeAndValue, erret);
    if(*erret==0 && bytesused==0)
        PKIERR(PKIErrUnpackUnderrun);
    return bytesused;
}

/******************************************************************
 * Routines for BasicConstraints
 ******************************************************************/

PKIBasicConstraints *PKINewBasicConstraints(
    PKICONTEXT *ctx)
{
    PKIBasicConstraints *f;

    if (ctx == NULL)
        return NULL;

    f = (PKIBasicConstraints *)PKIAlloc(ctx->memMgr, sizeof(PKIBasicConstraints));
    if (f != NULL)
        (void)memset(f, 0, sizeof(PKIBasicConstraints));
    return (f);

} /* PKINewBasicConstraints */

void PKIFreeBasicConstraints(
    PKICONTEXT *ctx,
    PKIBasicConstraints *f)
{
    if (ctx == NULL)
        return;

    PKIDropInPlaceBasicConstraints(ctx, f);
    if (f != NULL)
        PKIFree(ctx->memMgr, f);

} /* PKIFreeBasicConstraints */

size_t PKISizeofBasicConstraints(
    PKICONTEXT *ctx,
    PKIBasicConstraints *asnstruct,
    int outerSizeFlag)
{
    (void)ctx; /* for future use */

    return(PKISizeofBasicConstraintsInternal(asnstruct, outerSizeFlag, PKIFALSE));
} /* PKISizeofBasicConstraints */

size_t PKIPackBasicConstraints(
    PKICONTEXT *ctx,
    unsigned char *buf,
    size_t buflen,
    PKIBasicConstraints *asnstruct,
    int *erret )
{
    return(PKIPackBasicConstraintsInternal(ctx, buf, buflen, asnstruct, PKIID_BasicConstraints, erret));
} /* PKIPackBasicConstraints */

size_t PKIUnpackBasicConstraints(
    PKICONTEXT *ctx,
    PKIBasicConstraints **asnstruct,
    const unsigned char *buf,
    size_t buflen,
    int *erret)
{
    size_t bytesused;
    bytesused=PKIUnpackBasicConstraintsInternal(ctx, asnstruct, buf, buflen,
                      PKIID_BasicConstraints, erret);
    if(*erret==0 && bytesused==0)
        PKIERR(PKIErrUnpackUnderrun);
    return bytesused;
}

/******************************************************************
 * Routines for DirectoryString
 ******************************************************************/

PKIDirectoryString *PKINewDirectoryString(
    PKICONTEXT *ctx)
{
    PKIDirectoryString *f;

    if (ctx == NULL)
        return NULL;

    f = (PKIDirectoryString *)PKIAlloc(ctx->memMgr, sizeof(PKIDirectoryString));
    if (f != NULL)
        (void)memset(f, 0, sizeof(PKIDirectoryString));
    return (f);

} /* PKINewDirectoryString */

void PKIFreeDirectoryString(
    PKICONTEXT *ctx,
    PKIDirectoryString *f)
{
    if (ctx == NULL)
        return;

    PKIDropInPlaceDirectoryString(ctx, f);
    if (f != NULL)
        PKIFree(ctx->memMgr, f);

} /* PKIFreeDirectoryString */

size_t PKISizeofDirectoryString(
    PKICONTEXT *ctx,
    PKIDirectoryString *asnstruct,
    int outerSizeFlag)
{
    (void)ctx; /* for future use */

    return(PKISizeofDirectoryStringInternal(asnstruct, outerSizeFlag, PKIFALSE));
} /* PKISizeofDirectoryString */

size_t PKIPackDirectoryString(
    PKICONTEXT *ctx,
    unsigned char *buf,
    size_t buflen,
    PKIDirectoryString *asnstruct,
    int *erret )
{
    return(PKIPackDirectoryStringInternal(ctx, buf, buflen, asnstruct, PKIID_DirectoryString, erret));
} /* PKIPackDirectoryString */

size_t PKIUnpackDirectoryString(
    PKICONTEXT *ctx,
    PKIDirectoryString **asnstruct,
    const unsigned char *buf,
    size_t buflen,
    int *erret)
{
    size_t bytesused;
    bytesused=PKIUnpackDirectoryStringInternal(ctx, asnstruct, buf, buflen,
                      PKIID_DirectoryString, erret);
    if(*erret==0 && bytesused==0)
        PKIERR(PKIErrUnpackUnderrun);
    return bytesused;
}

/******************************************************************
 * Routines for DisplayText
 ******************************************************************/

PKIDisplayText *PKINewDisplayText(
    PKICONTEXT *ctx)
{
    PKIDisplayText *f;

    if (ctx == NULL)
        return NULL;

    f = (PKIDisplayText *)PKIAlloc(ctx->memMgr, sizeof(PKIDisplayText));
    if (f != NULL)
        (void)memset(f, 0, sizeof(PKIDisplayText));
    return (f);

} /* PKINewDisplayText */

void PKIFreeDisplayText(
    PKICONTEXT *ctx,
    PKIDisplayText *f)
{
    if (ctx == NULL)
        return;

    PKIDropInPlaceDisplayText(ctx, f);
    if (f != NULL)
        PKIFree(ctx->memMgr, f);

} /* PKIFreeDisplayText */

size_t PKISizeofDisplayText(
    PKICONTEXT *ctx,
    PKIDisplayText *asnstruct,
    int outerSizeFlag)
{
    (void)ctx; /* for future use */

    return(PKISizeofDisplayTextInternal(asnstruct, outerSizeFlag, PKIFALSE));
} /* PKISizeofDisplayText */

size_t PKIPackDisplayText(
    PKICONTEXT *ctx,
    unsigned char *buf,
    size_t buflen,
    PKIDisplayText *asnstruct,
    int *erret )
{
    return(PKIPackDisplayTextInternal(ctx, buf, buflen, asnstruct, PKIID_DisplayText, erret));
} /* PKIPackDisplayText */

size_t PKIUnpackDisplayText(
    PKICONTEXT *ctx,
    PKIDisplayText **asnstruct,
    const unsigned char *buf,
    size_t buflen,
    int *erret)
{
    size_t bytesused;
    bytesused=PKIUnpackDisplayTextInternal(ctx, asnstruct, buf, buflen,
                      PKIID_DisplayText, erret);
    if(*erret==0 && bytesused==0)
        PKIERR(PKIErrUnpackUnderrun);
    return bytesused;
}

/******************************************************************
 * Routines for Dss_Parms
 ******************************************************************/

PKIDss_Parms *PKINewDss_Parms(
    PKICONTEXT *ctx)
{
    PKIDss_Parms *f;

    if (ctx == NULL)
        return NULL;

    f = (PKIDss_Parms *)PKIAlloc(ctx->memMgr, sizeof(PKIDss_Parms));
    if (f != NULL)
        (void)memset(f, 0, sizeof(PKIDss_Parms));
    return (f);

} /* PKINewDss_Parms */

void PKIFreeDss_Parms(
    PKICONTEXT *ctx,
    PKIDss_Parms *f)
{
    if (ctx == NULL)
        return;

    PKIDropInPlaceDss_Parms(ctx, f);
    if (f != NULL)
        PKIFree(ctx->memMgr, f);

} /* PKIFreeDss_Parms */

size_t PKISizeofDss_Parms(
    PKICONTEXT *ctx,
    PKIDss_Parms *asnstruct,
    int outerSizeFlag)
{
    (void)ctx; /* for future use */

    return(PKISizeofDss_ParmsInternal(asnstruct, outerSizeFlag, PKIFALSE));
} /* PKISizeofDss_Parms */

size_t PKIPackDss_Parms(
    PKICONTEXT *ctx,
    unsigned char *buf,
    size_t buflen,
    PKIDss_Parms *asnstruct,
    int *erret )
{
    return(PKIPackDss_ParmsInternal(ctx, buf, buflen, asnstruct, PKIID_Dss_Parms, erret));
} /* PKIPackDss_Parms */

size_t PKIUnpackDss_Parms(
    PKICONTEXT *ctx,
    PKIDss_Parms **asnstruct,
    const unsigned char *buf,
    size_t buflen,
    int *erret)
{
    size_t bytesused;
    bytesused=PKIUnpackDss_ParmsInternal(ctx, asnstruct, buf, buflen,
                      PKIID_Dss_Parms, erret);
    if(*erret==0 && bytesused==0)
        PKIERR(PKIErrUnpackUnderrun);
    return bytesused;
}

/******************************************************************
 * Routines for Dss_Sig_Value
 ******************************************************************/

PKIDss_Sig_Value *PKINewDss_Sig_Value(
    PKICONTEXT *ctx)
{
    PKIDss_Sig_Value *f;

    if (ctx == NULL)
        return NULL;

    f = (PKIDss_Sig_Value *)PKIAlloc(ctx->memMgr, sizeof(PKIDss_Sig_Value));
    if (f != NULL)
        (void)memset(f, 0, sizeof(PKIDss_Sig_Value));
    return (f);

} /* PKINewDss_Sig_Value */

void PKIFreeDss_Sig_Value(
    PKICONTEXT *ctx,
    PKIDss_Sig_Value *f)
{
    if (ctx == NULL)
        return;

    PKIDropInPlaceDss_Sig_Value(ctx, f);
    if (f != NULL)
        PKIFree(ctx->memMgr, f);

} /* PKIFreeDss_Sig_Value */

size_t PKISizeofDss_Sig_Value(
    PKICONTEXT *ctx,
    PKIDss_Sig_Value *asnstruct,
    int outerSizeFlag)
{
    (void)ctx; /* for future use */

    return(PKISizeofDss_Sig_ValueInternal(asnstruct, outerSizeFlag, PKIFALSE));
} /* PKISizeofDss_Sig_Value */

size_t PKIPackDss_Sig_Value(
    PKICONTEXT *ctx,
    unsigned char *buf,
    size_t buflen,
    PKIDss_Sig_Value *asnstruct,
    int *erret )
{
    return(PKIPackDss_Sig_ValueInternal(ctx, buf, buflen, asnstruct, PKIID_Dss_Sig_Value, erret));
} /* PKIPackDss_Sig_Value */

size_t PKIUnpackDss_Sig_Value(
    PKICONTEXT *ctx,
    PKIDss_Sig_Value **asnstruct,
    const unsigned char *buf,
    size_t buflen,
    int *erret)
{
    size_t bytesused;
    bytesused=PKIUnpackDss_Sig_ValueInternal(ctx, asnstruct, buf, buflen,
                      PKIID_Dss_Sig_Value, erret);
    if(*erret==0 && bytesused==0)
        PKIERR(PKIErrUnpackUnderrun);
    return bytesused;
}

/******************************************************************
 * Routines for ExtKeyUsageSyntax
 ******************************************************************/

PKIExtKeyUsageSyntax *PKINewExtKeyUsageSyntax(
    PKICONTEXT *ctx)
{
    PKIExtKeyUsageSyntax *f;

    if (ctx == NULL)
        return NULL;

    f = (PKIExtKeyUsageSyntax *)PKIAlloc(ctx->memMgr, sizeof(PKIExtKeyUsageSyntax));
    if (f != NULL)
        (void)memset(f, 0, sizeof(PKIExtKeyUsageSyntax));
    return (f);

} /* PKINewExtKeyUsageSyntax */

void PKIFreeExtKeyUsageSyntax(
    PKICONTEXT *ctx,
    PKIExtKeyUsageSyntax *f)
{
    if (ctx == NULL)
        return;

    PKIDropInPlaceExtKeyUsageSyntax(ctx, f);
    if (f != NULL)
        PKIFree(ctx->memMgr, f);

} /* PKIFreeExtKeyUsageSyntax */

size_t PKISizeofExtKeyUsageSyntax(
    PKICONTEXT *ctx,
    PKIExtKeyUsageSyntax *asnstruct,
    int outerSizeFlag)
{
    (void)ctx; /* for future use */

    return(PKISizeofExtKeyUsageSyntaxInternal(asnstruct, outerSizeFlag, PKIFALSE));
} /* PKISizeofExtKeyUsageSyntax */

size_t PKIPackExtKeyUsageSyntax(
    PKICONTEXT *ctx,
    unsigned char *buf,
    size_t buflen,
    PKIExtKeyUsageSyntax *asnstruct,
    int *erret )
{
    return(PKIPackExtKeyUsageSyntaxInternal(ctx, buf, buflen, asnstruct, PKIID_ExtKeyUsageSyntax, erret));
} /* PKIPackExtKeyUsageSyntax */

size_t PKIUnpackExtKeyUsageSyntax(
    PKICONTEXT *ctx,
    PKIExtKeyUsageSyntax **asnstruct,
    const unsigned char *buf,
    size_t buflen,
    int *erret)
{
    size_t bytesused;
    bytesused=PKIUnpackExtKeyUsageSyntaxInternal(ctx, asnstruct, buf, buflen,
                      PKIID_ExtKeyUsageSyntax, erret);
    if(*erret==0 && bytesused==0)
        PKIERR(PKIErrUnpackUnderrun);
    return bytesused;
}

/******************************************************************
 * Routines for Extension
 ******************************************************************/

PKIExtension *PKINewExtension(
    PKICONTEXT *ctx)
{
    PKIExtension *f;

    if (ctx == NULL)
        return NULL;

    f = (PKIExtension *)PKIAlloc(ctx->memMgr, sizeof(PKIExtension));
    if (f != NULL)
        (void)memset(f, 0, sizeof(PKIExtension));
    return (f);

} /* PKINewExtension */

void PKIFreeExtension(
    PKICONTEXT *ctx,
    PKIExtension *f)
{
    if (ctx == NULL)
        return;

    PKIDropInPlaceExtension(ctx, f);
    if (f != NULL)
        PKIFree(ctx->memMgr, f);

} /* PKIFreeExtension */

size_t PKISizeofExtension(
    PKICONTEXT *ctx,
    PKIExtension *asnstruct,
    int outerSizeFlag)
{
    (void)ctx; /* for future use */

    return(PKISizeofExtensionInternal(asnstruct, outerSizeFlag, PKIFALSE));
} /* PKISizeofExtension */

size_t PKIPackExtension(
    PKICONTEXT *ctx,
    unsigned char *buf,
    size_t buflen,
    PKIExtension *asnstruct,
    int *erret )
{
    return(PKIPackExtensionInternal(ctx, buf, buflen, asnstruct, PKIID_Extension, erret));
} /* PKIPackExtension */

size_t PKIUnpackExtension(
    PKICONTEXT *ctx,
    PKIExtension **asnstruct,
    const unsigned char *buf,
    size_t buflen,
    int *erret)
{
    size_t bytesused;
    bytesused=PKIUnpackExtensionInternal(ctx, asnstruct, buf, buflen,
                      PKIID_Extension, erret);
    if(*erret==0 && bytesused==0)
        PKIERR(PKIErrUnpackUnderrun);
    return bytesused;
}

/******************************************************************
 * Routines for PolicyConstraints
 ******************************************************************/

PKIPolicyConstraints *PKINewPolicyConstraints(
    PKICONTEXT *ctx)
{
    PKIPolicyConstraints *f;

    if (ctx == NULL)
        return NULL;

    f = (PKIPolicyConstraints *)PKIAlloc(ctx->memMgr, sizeof(PKIPolicyConstraints));
    if (f != NULL)
        (void)memset(f, 0, sizeof(PKIPolicyConstraints));
    return (f);

} /* PKINewPolicyConstraints */

void PKIFreePolicyConstraints(
    PKICONTEXT *ctx,
    PKIPolicyConstraints *f)
{
    if (ctx == NULL)
        return;

    PKIDropInPlacePolicyConstraints(ctx, f);
    if (f != NULL)
        PKIFree(ctx->memMgr, f);

} /* PKIFreePolicyConstraints */

size_t PKISizeofPolicyConstraints(
    PKICONTEXT *ctx,
    PKIPolicyConstraints *asnstruct,
    int outerSizeFlag)
{
    (void)ctx; /* for future use */

    return(PKISizeofPolicyConstraintsInternal(asnstruct, outerSizeFlag, PKIFALSE));
} /* PKISizeofPolicyConstraints */

size_t PKIPackPolicyConstraints(
    PKICONTEXT *ctx,
    unsigned char *buf,
    size_t buflen,
    PKIPolicyConstraints *asnstruct,
    int *erret )
{
    return(PKIPackPolicyConstraintsInternal(ctx, buf, buflen, asnstruct, PKIID_PolicyConstraints, erret));
} /* PKIPackPolicyConstraints */

size_t PKIUnpackPolicyConstraints(
    PKICONTEXT *ctx,
    PKIPolicyConstraints **asnstruct,
    const unsigned char *buf,
    size_t buflen,
    int *erret)
{
    size_t bytesused;
    bytesused=PKIUnpackPolicyConstraintsInternal(ctx, asnstruct, buf, buflen,
                      PKIID_PolicyConstraints, erret);
    if(*erret==0 && bytesused==0)
        PKIERR(PKIErrUnpackUnderrun);
    return bytesused;
}

/******************************************************************
 * Routines for PolicyMappings_SEQUENCE
 ******************************************************************/

PKIPolicyMappings_SEQUENCE *PKINewPolicyMappings_SEQUENCE(
    PKICONTEXT *ctx)
{
    PKIPolicyMappings_SEQUENCE *f;

    if (ctx == NULL)
        return NULL;

    f = (PKIPolicyMappings_SEQUENCE *)PKIAlloc(ctx->memMgr, sizeof(PKIPolicyMappings_SEQUENCE));
    if (f != NULL)
        (void)memset(f, 0, sizeof(PKIPolicyMappings_SEQUENCE));
    return (f);

} /* PKINewPolicyMappings_SEQUENCE */

void PKIFreePolicyMappings_SEQUENCE(
    PKICONTEXT *ctx,
    PKIPolicyMappings_SEQUENCE *f)
{
    if (ctx == NULL)
        return;

    PKIDropInPlacePolicyMappings_SEQUENCE(ctx, f);
    if (f != NULL)
        PKIFree(ctx->memMgr, f);

} /* PKIFreePolicyMappings_SEQUENCE */

size_t PKISizeofPolicyMappings_SEQUENCE(
    PKICONTEXT *ctx,
    PKIPolicyMappings_SEQUENCE *asnstruct,
    int outerSizeFlag)
{
    (void)ctx; /* for future use */

    return(PKISizeofPolicyMappings_SEQUENCEInternal(asnstruct, outerSizeFlag, PKIFALSE));
} /* PKISizeofPolicyMappings_SEQUENCE */

size_t PKIPackPolicyMappings_SEQUENCE(
    PKICONTEXT *ctx,
    unsigned char *buf,
    size_t buflen,
    PKIPolicyMappings_SEQUENCE *asnstruct,
    int *erret )
{
    return(PKIPackPolicyMappings_SEQUENCEInternal(ctx, buf, buflen, asnstruct, PKIID_PolicyMappings_SEQUENCE, erret));
} /* PKIPackPolicyMappings_SEQUENCE */

size_t PKIUnpackPolicyMappings_SEQUENCE(
    PKICONTEXT *ctx,
    PKIPolicyMappings_SEQUENCE **asnstruct,
    const unsigned char *buf,
    size_t buflen,
    int *erret)
{
    size_t bytesused;
    bytesused=PKIUnpackPolicyMappings_SEQUENCEInternal(ctx, asnstruct, buf, buflen,
                      PKIID_PolicyMappings_SEQUENCE, erret);
    if(*erret==0 && bytesused==0)
        PKIERR(PKIErrUnpackUnderrun);
    return bytesused;
}

/******************************************************************
 * Routines for PolicyQualifierInfo
 ******************************************************************/

PKIPolicyQualifierInfo *PKINewPolicyQualifierInfo(
    PKICONTEXT *ctx)
{
    PKIPolicyQualifierInfo *f;

    if (ctx == NULL)
        return NULL;

    f = (PKIPolicyQualifierInfo *)PKIAlloc(ctx->memMgr, sizeof(PKIPolicyQualifierInfo));
    if (f != NULL)
        (void)memset(f, 0, sizeof(PKIPolicyQualifierInfo));
    return (f);

} /* PKINewPolicyQualifierInfo */

void PKIFreePolicyQualifierInfo(
    PKICONTEXT *ctx,
    PKIPolicyQualifierInfo *f)
{
    if (ctx == NULL)
        return;

    PKIDropInPlacePolicyQualifierInfo(ctx, f);
    if (f != NULL)
        PKIFree(ctx->memMgr, f);

} /* PKIFreePolicyQualifierInfo */

size_t PKISizeofPolicyQualifierInfo(
    PKICONTEXT *ctx,
    PKIPolicyQualifierInfo *asnstruct,
    int outerSizeFlag)
{
    (void)ctx; /* for future use */

    return(PKISizeofPolicyQualifierInfoInternal(asnstruct, outerSizeFlag, PKIFALSE));
} /* PKISizeofPolicyQualifierInfo */

size_t PKIPackPolicyQualifierInfo(
    PKICONTEXT *ctx,
    unsigned char *buf,
    size_t buflen,
    PKIPolicyQualifierInfo *asnstruct,
    int *erret )
{
    return(PKIPackPolicyQualifierInfoInternal(ctx, buf, buflen, asnstruct, PKIID_PolicyQualifierInfo, erret));
} /* PKIPackPolicyQualifierInfo */

size_t PKIUnpackPolicyQualifierInfo(
    PKICONTEXT *ctx,
    PKIPolicyQualifierInfo **asnstruct,
    const unsigned char *buf,
    size_t buflen,
    int *erret)
{
    size_t bytesused;
    bytesused=PKIUnpackPolicyQualifierInfoInternal(ctx, asnstruct, buf, buflen,
                      PKIID_PolicyQualifierInfo, erret);
    if(*erret==0 && bytesused==0)
        PKIERR(PKIErrUnpackUnderrun);
    return bytesused;
}

/******************************************************************
 * Routines for PrivateKeyUsagePeriod
 ******************************************************************/

PKIPrivateKeyUsagePeriod *PKINewPrivateKeyUsagePeriod(
    PKICONTEXT *ctx)
{
    PKIPrivateKeyUsagePeriod *f;

    if (ctx == NULL)
        return NULL;

    f = (PKIPrivateKeyUsagePeriod *)PKIAlloc(ctx->memMgr, sizeof(PKIPrivateKeyUsagePeriod));
    if (f != NULL)
        (void)memset(f, 0, sizeof(PKIPrivateKeyUsagePeriod));
    return (f);

} /* PKINewPrivateKeyUsagePeriod */

void PKIFreePrivateKeyUsagePeriod(
    PKICONTEXT *ctx,
    PKIPrivateKeyUsagePeriod *f)
{
    if (ctx == NULL)
        return;

    PKIDropInPlacePrivateKeyUsagePeriod(ctx, f);
    if (f != NULL)
        PKIFree(ctx->memMgr, f);

} /* PKIFreePrivateKeyUsagePeriod */

size_t PKISizeofPrivateKeyUsagePeriod(
    PKICONTEXT *ctx,
    PKIPrivateKeyUsagePeriod *asnstruct,
    int outerSizeFlag)
{
    (void)ctx; /* for future use */

    return(PKISizeofPrivateKeyUsagePeriodInternal(asnstruct, outerSizeFlag, PKIFALSE));
} /* PKISizeofPrivateKeyUsagePeriod */

size_t PKIPackPrivateKeyUsagePeriod(
    PKICONTEXT *ctx,
    unsigned char *buf,
    size_t buflen,
    PKIPrivateKeyUsagePeriod *asnstruct,
    int *erret )
{
    return(PKIPackPrivateKeyUsagePeriodInternal(ctx, buf, buflen, asnstruct, PKIID_PrivateKeyUsagePeriod, erret));
} /* PKIPackPrivateKeyUsagePeriod */

size_t PKIUnpackPrivateKeyUsagePeriod(
    PKICONTEXT *ctx,
    PKIPrivateKeyUsagePeriod **asnstruct,
    const unsigned char *buf,
    size_t buflen,
    int *erret)
{
    size_t bytesused;
    bytesused=PKIUnpackPrivateKeyUsagePeriodInternal(ctx, asnstruct, buf, buflen,
                      PKIID_PrivateKeyUsagePeriod, erret);
    if(*erret==0 && bytesused==0)
        PKIERR(PKIErrUnpackUnderrun);
    return bytesused;
}

/******************************************************************
 * Routines for RSAKey
 ******************************************************************/

PKIRSAKey *PKINewRSAKey(
    PKICONTEXT *ctx)
{
    PKIRSAKey *f;

    if (ctx == NULL)
        return NULL;

    f = (PKIRSAKey *)PKIAlloc(ctx->memMgr, sizeof(PKIRSAKey));
    if (f != NULL)
        (void)memset(f, 0, sizeof(PKIRSAKey));
    return (f);

} /* PKINewRSAKey */

void PKIFreeRSAKey(
    PKICONTEXT *ctx,
    PKIRSAKey *f)
{
    if (ctx == NULL)
        return;

    PKIDropInPlaceRSAKey(ctx, f);
    if (f != NULL)
        PKIFree(ctx->memMgr, f);

} /* PKIFreeRSAKey */

size_t PKISizeofRSAKey(
    PKICONTEXT *ctx,
    PKIRSAKey *asnstruct,
    int outerSizeFlag)
{
    (void)ctx; /* for future use */

    return(PKISizeofRSAKeyInternal(asnstruct, outerSizeFlag, PKIFALSE));
} /* PKISizeofRSAKey */

size_t PKIPackRSAKey(
    PKICONTEXT *ctx,
    unsigned char *buf,
    size_t buflen,
    PKIRSAKey *asnstruct,
    int *erret )
{
    return(PKIPackRSAKeyInternal(ctx, buf, buflen, asnstruct, PKIID_RSAKey, erret));
} /* PKIPackRSAKey */

size_t PKIUnpackRSAKey(
    PKICONTEXT *ctx,
    PKIRSAKey **asnstruct,
    const unsigned char *buf,
    size_t buflen,
    int *erret)
{
    size_t bytesused;
    bytesused=PKIUnpackRSAKeyInternal(ctx, asnstruct, buf, buflen,
                      PKIID_RSAKey, erret);
    if(*erret==0 && bytesused==0)
        PKIERR(PKIErrUnpackUnderrun);
    return bytesused;
}

/******************************************************************
 * Routines for Time
 ******************************************************************/

PKITime *PKINewTime(
    PKICONTEXT *ctx)
{
    PKITime *f;

    if (ctx == NULL)
        return NULL;

    f = (PKITime *)PKIAlloc(ctx->memMgr, sizeof(PKITime));
    if (f != NULL)
        (void)memset(f, 0, sizeof(PKITime));
    return (f);

} /* PKINewTime */

void PKIFreeTime(
    PKICONTEXT *ctx,
    PKITime *f)
{
    if (ctx == NULL)
        return;

    PKIDropInPlaceTime(ctx, f);
    if (f != NULL)
        PKIFree(ctx->memMgr, f);

} /* PKIFreeTime */

size_t PKISizeofTime(
    PKICONTEXT *ctx,
    PKITime *asnstruct,
    int outerSizeFlag)
{
    (void)ctx; /* for future use */

    return(PKISizeofTimeInternal(asnstruct, outerSizeFlag, PKIFALSE));
} /* PKISizeofTime */

size_t PKIPackTime(
    PKICONTEXT *ctx,
    unsigned char *buf,
    size_t buflen,
    PKITime *asnstruct,
    int *erret )
{
    return(PKIPackTimeInternal(ctx, buf, buflen, asnstruct, PKIID_Time, erret));
} /* PKIPackTime */

size_t PKIUnpackTime(
    PKICONTEXT *ctx,
    PKITime **asnstruct,
    const unsigned char *buf,
    size_t buflen,
    int *erret)
{
    size_t bytesused;
    bytesused=PKIUnpackTimeInternal(ctx, asnstruct, buf, buflen,
                      PKIID_Time, erret);
    if(*erret==0 && bytesused==0)
        PKIERR(PKIErrUnpackUnderrun);
    return bytesused;
}

/******************************************************************
 * Routines for ValidationParms
 ******************************************************************/

PKIValidationParms *PKINewValidationParms(
    PKICONTEXT *ctx)
{
    PKIValidationParms *f;

    if (ctx == NULL)
        return NULL;

    f = (PKIValidationParms *)PKIAlloc(ctx->memMgr, sizeof(PKIValidationParms));
    if (f != NULL)
        (void)memset(f, 0, sizeof(PKIValidationParms));
    return (f);

} /* PKINewValidationParms */

void PKIFreeValidationParms(
    PKICONTEXT *ctx,
    PKIValidationParms *f)
{
    if (ctx == NULL)
        return;

    PKIDropInPlaceValidationParms(ctx, f);
    if (f != NULL)
        PKIFree(ctx->memMgr, f);

} /* PKIFreeValidationParms */

size_t PKISizeofValidationParms(
    PKICONTEXT *ctx,
    PKIValidationParms *asnstruct,
    int outerSizeFlag)
{
    (void)ctx; /* for future use */

    return(PKISizeofValidationParmsInternal(asnstruct, outerSizeFlag, PKIFALSE));
} /* PKISizeofValidationParms */

size_t PKIPackValidationParms(
    PKICONTEXT *ctx,
    unsigned char *buf,
    size_t buflen,
    PKIValidationParms *asnstruct,
    int *erret )
{
    return(PKIPackValidationParmsInternal(ctx, buf, buflen, asnstruct, PKIID_ValidationParms, erret));
} /* PKIPackValidationParms */

size_t PKIUnpackValidationParms(
    PKICONTEXT *ctx,
    PKIValidationParms **asnstruct,
    const unsigned char *buf,
    size_t buflen,
    int *erret)
{
    size_t bytesused;
    bytesused=PKIUnpackValidationParmsInternal(ctx, asnstruct, buf, buflen,
                      PKIID_ValidationParms, erret);
    if(*erret==0 && bytesused==0)
        PKIERR(PKIErrUnpackUnderrun);
    return bytesused;
}

/******************************************************************
 * Routines for values_SET_OF
 ******************************************************************/

PKIvalues_SET_OF *PKINewvalues_SET_OF(
    PKICONTEXT *ctx)
{
    PKIvalues_SET_OF *f;

    if (ctx == NULL)
        return NULL;

    f = (PKIvalues_SET_OF *)PKIAlloc(ctx->memMgr, sizeof(PKIvalues_SET_OF));
    if (f != NULL)
        (void)memset(f, 0, sizeof(PKIvalues_SET_OF));
    return (f);

} /* PKINewvalues_SET_OF */

void PKIFreevalues_SET_OF(
    PKICONTEXT *ctx,
    PKIvalues_SET_OF *f)
{
    if (ctx == NULL)
        return;

    PKIDropInPlacevalues_SET_OF(ctx, f);
    if (f != NULL)
        PKIFree(ctx->memMgr, f);

} /* PKIFreevalues_SET_OF */

size_t PKISizeofvalues_SET_OF(
    PKICONTEXT *ctx,
    PKIvalues_SET_OF *asnstruct,
    int outerSizeFlag)
{
    (void)ctx; /* for future use */

    return(PKISizeofvalues_SET_OFInternal(asnstruct, outerSizeFlag, PKIFALSE));
} /* PKISizeofvalues_SET_OF */

size_t PKIPackvalues_SET_OF(
    PKICONTEXT *ctx,
    unsigned char *buf,
    size_t buflen,
    PKIvalues_SET_OF *asnstruct,
    int *erret )
{
    return(PKIPackvalues_SET_OFInternal(ctx, buf, buflen, asnstruct, PKIID_values_SET_OF, erret));
} /* PKIPackvalues_SET_OF */

size_t PKIUnpackvalues_SET_OF(
    PKICONTEXT *ctx,
    PKIvalues_SET_OF **asnstruct,
    const unsigned char *buf,
    size_t buflen,
    int *erret)
{
    size_t bytesused;
    bytesused=PKIUnpackvalues_SET_OFInternal(ctx, asnstruct, buf, buflen,
                      PKIID_values_SET_OF, erret);
    if(*erret==0 && bytesused==0)
        PKIERR(PKIErrUnpackUnderrun);
    return bytesused;
}

/******************************************************************
 * Routines for Attribute
 ******************************************************************/

PKIAttribute *PKINewAttribute(
    PKICONTEXT *ctx)
{
    PKIAttribute *f;

    if (ctx == NULL)
        return NULL;

    f = (PKIAttribute *)PKIAlloc(ctx->memMgr, sizeof(PKIAttribute));
    if (f != NULL)
        (void)memset(f, 0, sizeof(PKIAttribute));
    return (f);

} /* PKINewAttribute */

void PKIFreeAttribute(
    PKICONTEXT *ctx,
    PKIAttribute *f)
{
    if (ctx == NULL)
        return;

    PKIDropInPlaceAttribute(ctx, f);
    if (f != NULL)
        PKIFree(ctx->memMgr, f);

} /* PKIFreeAttribute */

size_t PKISizeofAttribute(
    PKICONTEXT *ctx,
    PKIAttribute *asnstruct,
    int outerSizeFlag)
{
    (void)ctx; /* for future use */

    return(PKISizeofAttributeInternal(asnstruct, outerSizeFlag, PKIFALSE));
} /* PKISizeofAttribute */

size_t PKIPackAttribute(
    PKICONTEXT *ctx,
    unsigned char *buf,
    size_t buflen,
    PKIAttribute *asnstruct,
    int *erret )
{
    return(PKIPackAttributeInternal(ctx, buf, buflen, asnstruct, PKIID_Attribute, erret));
} /* PKIPackAttribute */

size_t PKIUnpackAttribute(
    PKICONTEXT *ctx,
    PKIAttribute **asnstruct,
    const unsigned char *buf,
    size_t buflen,
    int *erret)
{
    size_t bytesused;
    bytesused=PKIUnpackAttributeInternal(ctx, asnstruct, buf, buflen,
                      PKIID_Attribute, erret);
    if(*erret==0 && bytesused==0)
        PKIERR(PKIErrUnpackUnderrun);
    return bytesused;
}

/******************************************************************
 * Routines for DomainParameters
 ******************************************************************/

PKIDomainParameters *PKINewDomainParameters(
    PKICONTEXT *ctx)
{
    PKIDomainParameters *f;

    if (ctx == NULL)
        return NULL;

    f = (PKIDomainParameters *)PKIAlloc(ctx->memMgr, sizeof(PKIDomainParameters));
    if (f != NULL)
        (void)memset(f, 0, sizeof(PKIDomainParameters));
    return (f);

} /* PKINewDomainParameters */

void PKIFreeDomainParameters(
    PKICONTEXT *ctx,
    PKIDomainParameters *f)
{
    if (ctx == NULL)
        return;

    PKIDropInPlaceDomainParameters(ctx, f);
    if (f != NULL)
        PKIFree(ctx->memMgr, f);

} /* PKIFreeDomainParameters */

size_t PKISizeofDomainParameters(
    PKICONTEXT *ctx,
    PKIDomainParameters *asnstruct,
    int outerSizeFlag)
{
    (void)ctx; /* for future use */

    return(PKISizeofDomainParametersInternal(asnstruct, outerSizeFlag, PKIFALSE));
} /* PKISizeofDomainParameters */

size_t PKIPackDomainParameters(
    PKICONTEXT *ctx,
    unsigned char *buf,
    size_t buflen,
    PKIDomainParameters *asnstruct,
    int *erret )
{
    return(PKIPackDomainParametersInternal(ctx, buf, buflen, asnstruct, PKIID_DomainParameters, erret));
} /* PKIPackDomainParameters */

size_t PKIUnpackDomainParameters(
    PKICONTEXT *ctx,
    PKIDomainParameters **asnstruct,
    const unsigned char *buf,
    size_t buflen,
    int *erret)
{
    size_t bytesused;
    bytesused=PKIUnpackDomainParametersInternal(ctx, asnstruct, buf, buflen,
                      PKIID_DomainParameters, erret);
    if(*erret==0 && bytesused==0)
        PKIERR(PKIErrUnpackUnderrun);
    return bytesused;
}

/******************************************************************
 * Routines for EDIPartyName
 ******************************************************************/

PKIEDIPartyName *PKINewEDIPartyName(
    PKICONTEXT *ctx)
{
    PKIEDIPartyName *f;

    if (ctx == NULL)
        return NULL;

    f = (PKIEDIPartyName *)PKIAlloc(ctx->memMgr, sizeof(PKIEDIPartyName));
    if (f != NULL)
        (void)memset(f, 0, sizeof(PKIEDIPartyName));
    return (f);

} /* PKINewEDIPartyName */

void PKIFreeEDIPartyName(
    PKICONTEXT *ctx,
    PKIEDIPartyName *f)
{
    if (ctx == NULL)
        return;

    PKIDropInPlaceEDIPartyName(ctx, f);
    if (f != NULL)
        PKIFree(ctx->memMgr, f);

} /* PKIFreeEDIPartyName */

size_t PKISizeofEDIPartyName(
    PKICONTEXT *ctx,
    PKIEDIPartyName *asnstruct,
    int outerSizeFlag)
{
    (void)ctx; /* for future use */

    return(PKISizeofEDIPartyNameInternal(asnstruct, outerSizeFlag, PKIFALSE));
} /* PKISizeofEDIPartyName */

size_t PKIPackEDIPartyName(
    PKICONTEXT *ctx,
    unsigned char *buf,
    size_t buflen,
    PKIEDIPartyName *asnstruct,
    int *erret )
{
    return(PKIPackEDIPartyNameInternal(ctx, buf, buflen, asnstruct, PKIID_EDIPartyName, erret));
} /* PKIPackEDIPartyName */

size_t PKIUnpackEDIPartyName(
    PKICONTEXT *ctx,
    PKIEDIPartyName **asnstruct,
    const unsigned char *buf,
    size_t buflen,
    int *erret)
{
    size_t bytesused;
    bytesused=PKIUnpackEDIPartyNameInternal(ctx, asnstruct, buf, buflen,
                      PKIID_EDIPartyName, erret);
    if(*erret==0 && bytesused==0)
        PKIERR(PKIErrUnpackUnderrun);
    return bytesused;
}

/******************************************************************
 * Routines for Extensions
 ******************************************************************/

PKIExtensions *PKINewExtensions(
    PKICONTEXT *ctx)
{
    PKIExtensions *f;

    if (ctx == NULL)
        return NULL;

    f = (PKIExtensions *)PKIAlloc(ctx->memMgr, sizeof(PKIExtensions));
    if (f != NULL)
        (void)memset(f, 0, sizeof(PKIExtensions));
    return (f);

} /* PKINewExtensions */

void PKIFreeExtensions(
    PKICONTEXT *ctx,
    PKIExtensions *f)
{
    if (ctx == NULL)
        return;

    PKIDropInPlaceExtensions(ctx, f);
    if (f != NULL)
        PKIFree(ctx->memMgr, f);

} /* PKIFreeExtensions */

size_t PKISizeofExtensions(
    PKICONTEXT *ctx,
    PKIExtensions *asnstruct,
    int outerSizeFlag)
{
    (void)ctx; /* for future use */

    return(PKISizeofExtensionsInternal(asnstruct, outerSizeFlag, PKIFALSE));
} /* PKISizeofExtensions */

size_t PKIPackExtensions(
    PKICONTEXT *ctx,
    unsigned char *buf,
    size_t buflen,
    PKIExtensions *asnstruct,
    int *erret )
{
    return(PKIPackExtensionsInternal(ctx, buf, buflen, asnstruct, PKIID_Extensions, erret));
} /* PKIPackExtensions */

size_t PKIUnpackExtensions(
    PKICONTEXT *ctx,
    PKIExtensions **asnstruct,
    const unsigned char *buf,
    size_t buflen,
    int *erret)
{
    size_t bytesused;
    bytesused=PKIUnpackExtensionsInternal(ctx, asnstruct, buf, buflen,
                      PKIID_Extensions, erret);
    if(*erret==0 && bytesused==0)
        PKIERR(PKIErrUnpackUnderrun);
    return bytesused;
}

/******************************************************************
 * Routines for NoticeReference
 ******************************************************************/

PKINoticeReference *PKINewNoticeReference(
    PKICONTEXT *ctx)
{
    PKINoticeReference *f;

    if (ctx == NULL)
        return NULL;

    f = (PKINoticeReference *)PKIAlloc(ctx->memMgr, sizeof(PKINoticeReference));
    if (f != NULL)
        (void)memset(f, 0, sizeof(PKINoticeReference));
    return (f);

} /* PKINewNoticeReference */

void PKIFreeNoticeReference(
    PKICONTEXT *ctx,
    PKINoticeReference *f)
{
    if (ctx == NULL)
        return;

    PKIDropInPlaceNoticeReference(ctx, f);
    if (f != NULL)
        PKIFree(ctx->memMgr, f);

} /* PKIFreeNoticeReference */

size_t PKISizeofNoticeReference(
    PKICONTEXT *ctx,
    PKINoticeReference *asnstruct,
    int outerSizeFlag)
{
    (void)ctx; /* for future use */

    return(PKISizeofNoticeReferenceInternal(asnstruct, outerSizeFlag, PKIFALSE));
} /* PKISizeofNoticeReference */

size_t PKIPackNoticeReference(
    PKICONTEXT *ctx,
    unsigned char *buf,
    size_t buflen,
    PKINoticeReference *asnstruct,
    int *erret )
{
    return(PKIPackNoticeReferenceInternal(ctx, buf, buflen, asnstruct, PKIID_NoticeReference, erret));
} /* PKIPackNoticeReference */

size_t PKIUnpackNoticeReference(
    PKICONTEXT *ctx,
    PKINoticeReference **asnstruct,
    const unsigned char *buf,
    size_t buflen,
    int *erret)
{
    size_t bytesused;
    bytesused=PKIUnpackNoticeReferenceInternal(ctx, asnstruct, buf, buflen,
                      PKIID_NoticeReference, erret);
    if(*erret==0 && bytesused==0)
        PKIERR(PKIErrUnpackUnderrun);
    return bytesused;
}

/******************************************************************
 * Routines for PolicyMappings
 ******************************************************************/

PKIPolicyMappings *PKINewPolicyMappings(
    PKICONTEXT *ctx)
{
    PKIPolicyMappings *f;

    if (ctx == NULL)
        return NULL;

    f = (PKIPolicyMappings *)PKIAlloc(ctx->memMgr, sizeof(PKIPolicyMappings));
    if (f != NULL)
        (void)memset(f, 0, sizeof(PKIPolicyMappings));
    return (f);

} /* PKINewPolicyMappings */

void PKIFreePolicyMappings(
    PKICONTEXT *ctx,
    PKIPolicyMappings *f)
{
    if (ctx == NULL)
        return;

    PKIDropInPlacePolicyMappings(ctx, f);
    if (f != NULL)
        PKIFree(ctx->memMgr, f);

} /* PKIFreePolicyMappings */

size_t PKISizeofPolicyMappings(
    PKICONTEXT *ctx,
    PKIPolicyMappings *asnstruct,
    int outerSizeFlag)
{
    (void)ctx; /* for future use */

    return(PKISizeofPolicyMappingsInternal(asnstruct, outerSizeFlag, PKIFALSE));
} /* PKISizeofPolicyMappings */

size_t PKIPackPolicyMappings(
    PKICONTEXT *ctx,
    unsigned char *buf,
    size_t buflen,
    PKIPolicyMappings *asnstruct,
    int *erret )
{
    return(PKIPackPolicyMappingsInternal(ctx, buf, buflen, asnstruct, PKIID_PolicyMappings, erret));
} /* PKIPackPolicyMappings */

size_t PKIUnpackPolicyMappings(
    PKICONTEXT *ctx,
    PKIPolicyMappings **asnstruct,
    const unsigned char *buf,
    size_t buflen,
    int *erret)
{
    size_t bytesused;
    bytesused=PKIUnpackPolicyMappingsInternal(ctx, asnstruct, buf, buflen,
                      PKIID_PolicyMappings, erret);
    if(*erret==0 && bytesused==0)
        PKIERR(PKIErrUnpackUnderrun);
    return bytesused;
}

/******************************************************************
 * Routines for RelativeDistinguishedName
 ******************************************************************/

PKIRelativeDistinguishedName *PKINewRelativeDistinguishedName(
    PKICONTEXT *ctx)
{
    PKIRelativeDistinguishedName *f;

    if (ctx == NULL)
        return NULL;

    f = (PKIRelativeDistinguishedName *)PKIAlloc(ctx->memMgr, sizeof(PKIRelativeDistinguishedName));
    if (f != NULL)
        (void)memset(f, 0, sizeof(PKIRelativeDistinguishedName));
    return (f);

} /* PKINewRelativeDistinguishedName */

void PKIFreeRelativeDistinguishedName(
    PKICONTEXT *ctx,
    PKIRelativeDistinguishedName *f)
{
    if (ctx == NULL)
        return;

    PKIDropInPlaceRelativeDistinguishedName(ctx, f);
    if (f != NULL)
        PKIFree(ctx->memMgr, f);

} /* PKIFreeRelativeDistinguishedName */

size_t PKISizeofRelativeDistinguishedName(
    PKICONTEXT *ctx,
    PKIRelativeDistinguishedName *asnstruct,
    int outerSizeFlag)
{
    (void)ctx; /* for future use */

    return(PKISizeofRelativeDistinguishedNameInternal(asnstruct, outerSizeFlag, PKIFALSE));
} /* PKISizeofRelativeDistinguishedName */

size_t PKIPackRelativeDistinguishedName(
    PKICONTEXT *ctx,
    unsigned char *buf,
    size_t buflen,
    PKIRelativeDistinguishedName *asnstruct,
    int *erret )
{
    return(PKIPackRelativeDistinguishedNameInternal(ctx, buf, buflen, asnstruct, PKIID_RelativeDistinguishedName, erret));
} /* PKIPackRelativeDistinguishedName */

size_t PKIUnpackRelativeDistinguishedName(
    PKICONTEXT *ctx,
    PKIRelativeDistinguishedName **asnstruct,
    const unsigned char *buf,
    size_t buflen,
    int *erret)
{
    size_t bytesused;
    bytesused=PKIUnpackRelativeDistinguishedNameInternal(ctx, asnstruct, buf, buflen,
                      PKIID_RelativeDistinguishedName, erret);
    if(*erret==0 && bytesused==0)
        PKIERR(PKIErrUnpackUnderrun);
    return bytesused;
}

/******************************************************************
 * Routines for SubjectPublicKeyInfo
 ******************************************************************/

PKISubjectPublicKeyInfo *PKINewSubjectPublicKeyInfo(
    PKICONTEXT *ctx)
{
    PKISubjectPublicKeyInfo *f;

    if (ctx == NULL)
        return NULL;

    f = (PKISubjectPublicKeyInfo *)PKIAlloc(ctx->memMgr, sizeof(PKISubjectPublicKeyInfo));
    if (f != NULL)
        (void)memset(f, 0, sizeof(PKISubjectPublicKeyInfo));
    return (f);

} /* PKINewSubjectPublicKeyInfo */

void PKIFreeSubjectPublicKeyInfo(
    PKICONTEXT *ctx,
    PKISubjectPublicKeyInfo *f)
{
    if (ctx == NULL)
        return;

    PKIDropInPlaceSubjectPublicKeyInfo(ctx, f);
    if (f != NULL)
        PKIFree(ctx->memMgr, f);

} /* PKIFreeSubjectPublicKeyInfo */

size_t PKISizeofSubjectPublicKeyInfo(
    PKICONTEXT *ctx,
    PKISubjectPublicKeyInfo *asnstruct,
    int outerSizeFlag)
{
    (void)ctx; /* for future use */

    return(PKISizeofSubjectPublicKeyInfoInternal(asnstruct, outerSizeFlag, PKIFALSE));
} /* PKISizeofSubjectPublicKeyInfo */

size_t PKIPackSubjectPublicKeyInfo(
    PKICONTEXT *ctx,
    unsigned char *buf,
    size_t buflen,
    PKISubjectPublicKeyInfo *asnstruct,
    int *erret )
{
    return(PKIPackSubjectPublicKeyInfoInternal(ctx, buf, buflen, asnstruct, PKIID_SubjectPublicKeyInfo, erret));
} /* PKIPackSubjectPublicKeyInfo */

size_t PKIUnpackSubjectPublicKeyInfo(
    PKICONTEXT *ctx,
    PKISubjectPublicKeyInfo **asnstruct,
    const unsigned char *buf,
    size_t buflen,
    int *erret)
{
    size_t bytesused;
    bytesused=PKIUnpackSubjectPublicKeyInfoInternal(ctx, asnstruct, buf, buflen,
                      PKIID_SubjectPublicKeyInfo, erret);
    if(*erret==0 && bytesused==0)
        PKIERR(PKIErrUnpackUnderrun);
    return bytesused;
}

/******************************************************************
 * Routines for Validity
 ******************************************************************/

PKIValidity *PKINewValidity(
    PKICONTEXT *ctx)
{
    PKIValidity *f;

    if (ctx == NULL)
        return NULL;

    f = (PKIValidity *)PKIAlloc(ctx->memMgr, sizeof(PKIValidity));
    if (f != NULL)
        (void)memset(f, 0, sizeof(PKIValidity));
    return (f);

} /* PKINewValidity */

void PKIFreeValidity(
    PKICONTEXT *ctx,
    PKIValidity *f)
{
    if (ctx == NULL)
        return;

    PKIDropInPlaceValidity(ctx, f);
    if (f != NULL)
        PKIFree(ctx->memMgr, f);

} /* PKIFreeValidity */

size_t PKISizeofValidity(
    PKICONTEXT *ctx,
    PKIValidity *asnstruct,
    int outerSizeFlag)
{
    (void)ctx; /* for future use */

    return(PKISizeofValidityInternal(asnstruct, outerSizeFlag, PKIFALSE));
} /* PKISizeofValidity */

size_t PKIPackValidity(
    PKICONTEXT *ctx,
    unsigned char *buf,
    size_t buflen,
    PKIValidity *asnstruct,
    int *erret )
{
    return(PKIPackValidityInternal(ctx, buf, buflen, asnstruct, PKIID_Validity, erret));
} /* PKIPackValidity */

size_t PKIUnpackValidity(
    PKICONTEXT *ctx,
    PKIValidity **asnstruct,
    const unsigned char *buf,
    size_t buflen,
    int *erret)
{
    size_t bytesused;
    bytesused=PKIUnpackValidityInternal(ctx, asnstruct, buf, buflen,
                      PKIID_Validity, erret);
    if(*erret==0 && bytesused==0)
        PKIERR(PKIErrUnpackUnderrun);
    return bytesused;
}

/******************************************************************
 * Routines for XCertificate
 ******************************************************************/

PKIXCertificate *PKINewXCertificate(
    PKICONTEXT *ctx)
{
    PKIXCertificate *f;

    if (ctx == NULL)
        return NULL;

    f = (PKIXCertificate *)PKIAlloc(ctx->memMgr, sizeof(PKIXCertificate));
    if (f != NULL)
        (void)memset(f, 0, sizeof(PKIXCertificate));
    return (f);

} /* PKINewXCertificate */

void PKIFreeXCertificate(
    PKICONTEXT *ctx,
    PKIXCertificate *f)
{
    if (ctx == NULL)
        return;

    PKIDropInPlaceXCertificate(ctx, f);
    if (f != NULL)
        PKIFree(ctx->memMgr, f);

} /* PKIFreeXCertificate */

size_t PKISizeofXCertificate(
    PKICONTEXT *ctx,
    PKIXCertificate *asnstruct,
    int outerSizeFlag)
{
    (void)ctx; /* for future use */

    return(PKISizeofXCertificateInternal(asnstruct, outerSizeFlag, PKIFALSE));
} /* PKISizeofXCertificate */

size_t PKIPackXCertificate(
    PKICONTEXT *ctx,
    unsigned char *buf,
    size_t buflen,
    PKIXCertificate *asnstruct,
    int *erret )
{
    return(PKIPackXCertificateInternal(ctx, buf, buflen, asnstruct, PKIID_XCertificate, erret));
} /* PKIPackXCertificate */

size_t PKIUnpackXCertificate(
    PKICONTEXT *ctx,
    PKIXCertificate **asnstruct,
    const unsigned char *buf,
    size_t buflen,
    int *erret)
{
    size_t bytesused;
    bytesused=PKIUnpackXCertificateInternal(ctx, asnstruct, buf, buflen,
                      PKIID_XCertificate, erret);
    if(*erret==0 && bytesused==0)
        PKIERR(PKIErrUnpackUnderrun);
    return bytesused;
}

/******************************************************************
 * Routines for policyQualifiers_SEQ_OF
 ******************************************************************/

PKIpolicyQualifiers_SEQ_OF *PKINewpolicyQualifiers_SEQ_OF(
    PKICONTEXT *ctx)
{
    PKIpolicyQualifiers_SEQ_OF *f;

    if (ctx == NULL)
        return NULL;

    f = (PKIpolicyQualifiers_SEQ_OF *)PKIAlloc(ctx->memMgr, sizeof(PKIpolicyQualifiers_SEQ_OF));
    if (f != NULL)
        (void)memset(f, 0, sizeof(PKIpolicyQualifiers_SEQ_OF));
    return (f);

} /* PKINewpolicyQualifiers_SEQ_OF */

void PKIFreepolicyQualifiers_SEQ_OF(
    PKICONTEXT *ctx,
    PKIpolicyQualifiers_SEQ_OF *f)
{
    if (ctx == NULL)
        return;

    PKIDropInPlacepolicyQualifiers_SEQ_OF(ctx, f);
    if (f != NULL)
        PKIFree(ctx->memMgr, f);

} /* PKIFreepolicyQualifiers_SEQ_OF */

size_t PKISizeofpolicyQualifiers_SEQ_OF(
    PKICONTEXT *ctx,
    PKIpolicyQualifiers_SEQ_OF *asnstruct,
    int outerSizeFlag)
{
    (void)ctx; /* for future use */

    return(PKISizeofpolicyQualifiers_SEQ_OFInternal(asnstruct, outerSizeFlag, PKIFALSE));
} /* PKISizeofpolicyQualifiers_SEQ_OF */

size_t PKIPackpolicyQualifiers_SEQ_OF(
    PKICONTEXT *ctx,
    unsigned char *buf,
    size_t buflen,
    PKIpolicyQualifiers_SEQ_OF *asnstruct,
    int *erret )
{
    return(PKIPackpolicyQualifiers_SEQ_OFInternal(ctx, buf, buflen, asnstruct, PKIID_policyQualifiers_SEQ_OF, erret));
} /* PKIPackpolicyQualifiers_SEQ_OF */

size_t PKIUnpackpolicyQualifiers_SEQ_OF(
    PKICONTEXT *ctx,
    PKIpolicyQualifiers_SEQ_OF **asnstruct,
    const unsigned char *buf,
    size_t buflen,
    int *erret)
{
    size_t bytesused;
    bytesused=PKIUnpackpolicyQualifiers_SEQ_OFInternal(ctx, asnstruct, buf, buflen,
                      PKIID_policyQualifiers_SEQ_OF, erret);
    if(*erret==0 && bytesused==0)
        PKIERR(PKIErrUnpackUnderrun);
    return bytesused;
}

/******************************************************************
 * Routines for Attributes
 ******************************************************************/

PKIAttributes *PKINewAttributes(
    PKICONTEXT *ctx)
{
    PKIAttributes *f;

    if (ctx == NULL)
        return NULL;

    f = (PKIAttributes *)PKIAlloc(ctx->memMgr, sizeof(PKIAttributes));
    if (f != NULL)
        (void)memset(f, 0, sizeof(PKIAttributes));
    return (f);

} /* PKINewAttributes */

void PKIFreeAttributes(
    PKICONTEXT *ctx,
    PKIAttributes *f)
{
    if (ctx == NULL)
        return;

    PKIDropInPlaceAttributes(ctx, f);
    if (f != NULL)
        PKIFree(ctx->memMgr, f);

} /* PKIFreeAttributes */

size_t PKISizeofAttributes(
    PKICONTEXT *ctx,
    PKIAttributes *asnstruct,
    int outerSizeFlag)
{
    (void)ctx; /* for future use */

    return(PKISizeofAttributesInternal(asnstruct, outerSizeFlag, PKIFALSE));
} /* PKISizeofAttributes */

size_t PKIPackAttributes(
    PKICONTEXT *ctx,
    unsigned char *buf,
    size_t buflen,
    PKIAttributes *asnstruct,
    int *erret )
{
    return(PKIPackAttributesInternal(ctx, buf, buflen, asnstruct, PKIID_Attributes, erret));
} /* PKIPackAttributes */

size_t PKIUnpackAttributes(
    PKICONTEXT *ctx,
    PKIAttributes **asnstruct,
    const unsigned char *buf,
    size_t buflen,
    int *erret)
{
    size_t bytesused;
    bytesused=PKIUnpackAttributesInternal(ctx, asnstruct, buf, buflen,
                      PKIID_Attributes, erret);
    if(*erret==0 && bytesused==0)
        PKIERR(PKIErrUnpackUnderrun);
    return bytesused;
}

/******************************************************************
 * Routines for PolicyInformation
 ******************************************************************/

PKIPolicyInformation *PKINewPolicyInformation(
    PKICONTEXT *ctx)
{
    PKIPolicyInformation *f;

    if (ctx == NULL)
        return NULL;

    f = (PKIPolicyInformation *)PKIAlloc(ctx->memMgr, sizeof(PKIPolicyInformation));
    if (f != NULL)
        (void)memset(f, 0, sizeof(PKIPolicyInformation));
    return (f);

} /* PKINewPolicyInformation */

void PKIFreePolicyInformation(
    PKICONTEXT *ctx,
    PKIPolicyInformation *f)
{
    if (ctx == NULL)
        return;

    PKIDropInPlacePolicyInformation(ctx, f);
    if (f != NULL)
        PKIFree(ctx->memMgr, f);

} /* PKIFreePolicyInformation */

size_t PKISizeofPolicyInformation(
    PKICONTEXT *ctx,
    PKIPolicyInformation *asnstruct,
    int outerSizeFlag)
{
    (void)ctx; /* for future use */

    return(PKISizeofPolicyInformationInternal(asnstruct, outerSizeFlag, PKIFALSE));
} /* PKISizeofPolicyInformation */

size_t PKIPackPolicyInformation(
    PKICONTEXT *ctx,
    unsigned char *buf,
    size_t buflen,
    PKIPolicyInformation *asnstruct,
    int *erret )
{
    return(PKIPackPolicyInformationInternal(ctx, buf, buflen, asnstruct, PKIID_PolicyInformation, erret));
} /* PKIPackPolicyInformation */

size_t PKIUnpackPolicyInformation(
    PKICONTEXT *ctx,
    PKIPolicyInformation **asnstruct,
    const unsigned char *buf,
    size_t buflen,
    int *erret)
{
    size_t bytesused;
    bytesused=PKIUnpackPolicyInformationInternal(ctx, asnstruct, buf, buflen,
                      PKIID_PolicyInformation, erret);
    if(*erret==0 && bytesused==0)
        PKIERR(PKIErrUnpackUnderrun);
    return bytesused;
}

/******************************************************************
 * Routines for RDNSequence
 ******************************************************************/

PKIRDNSequence *PKINewRDNSequence(
    PKICONTEXT *ctx)
{
    PKIRDNSequence *f;

    if (ctx == NULL)
        return NULL;

    f = (PKIRDNSequence *)PKIAlloc(ctx->memMgr, sizeof(PKIRDNSequence));
    if (f != NULL)
        (void)memset(f, 0, sizeof(PKIRDNSequence));
    return (f);

} /* PKINewRDNSequence */

void PKIFreeRDNSequence(
    PKICONTEXT *ctx,
    PKIRDNSequence *f)
{
    if (ctx == NULL)
        return;

    PKIDropInPlaceRDNSequence(ctx, f);
    if (f != NULL)
        PKIFree(ctx->memMgr, f);

} /* PKIFreeRDNSequence */

size_t PKISizeofRDNSequence(
    PKICONTEXT *ctx,
    PKIRDNSequence *asnstruct,
    int outerSizeFlag)
{
    (void)ctx; /* for future use */

    return(PKISizeofRDNSequenceInternal(asnstruct, outerSizeFlag, PKIFALSE));
} /* PKISizeofRDNSequence */

size_t PKIPackRDNSequence(
    PKICONTEXT *ctx,
    unsigned char *buf,
    size_t buflen,
    PKIRDNSequence *asnstruct,
    int *erret )
{
    return(PKIPackRDNSequenceInternal(ctx, buf, buflen, asnstruct, PKIID_RDNSequence, erret));
} /* PKIPackRDNSequence */

size_t PKIUnpackRDNSequence(
    PKICONTEXT *ctx,
    PKIRDNSequence **asnstruct,
    const unsigned char *buf,
    size_t buflen,
    int *erret)
{
    size_t bytesused;
    bytesused=PKIUnpackRDNSequenceInternal(ctx, asnstruct, buf, buflen,
                      PKIID_RDNSequence, erret);
    if(*erret==0 && bytesused==0)
        PKIERR(PKIErrUnpackUnderrun);
    return bytesused;
}

/******************************************************************
 * Routines for RevokedCertificate
 ******************************************************************/

PKIRevokedCertificate *PKINewRevokedCertificate(
    PKICONTEXT *ctx)
{
    PKIRevokedCertificate *f;

    if (ctx == NULL)
        return NULL;

    f = (PKIRevokedCertificate *)PKIAlloc(ctx->memMgr, sizeof(PKIRevokedCertificate));
    if (f != NULL)
        (void)memset(f, 0, sizeof(PKIRevokedCertificate));
    return (f);

} /* PKINewRevokedCertificate */

void PKIFreeRevokedCertificate(
    PKICONTEXT *ctx,
    PKIRevokedCertificate *f)
{
    if (ctx == NULL)
        return;

    PKIDropInPlaceRevokedCertificate(ctx, f);
    if (f != NULL)
        PKIFree(ctx->memMgr, f);

} /* PKIFreeRevokedCertificate */

size_t PKISizeofRevokedCertificate(
    PKICONTEXT *ctx,
    PKIRevokedCertificate *asnstruct,
    int outerSizeFlag)
{
    (void)ctx; /* for future use */

    return(PKISizeofRevokedCertificateInternal(asnstruct, outerSizeFlag, PKIFALSE));
} /* PKISizeofRevokedCertificate */

size_t PKIPackRevokedCertificate(
    PKICONTEXT *ctx,
    unsigned char *buf,
    size_t buflen,
    PKIRevokedCertificate *asnstruct,
    int *erret )
{
    return(PKIPackRevokedCertificateInternal(ctx, buf, buflen, asnstruct, PKIID_RevokedCertificate, erret));
} /* PKIPackRevokedCertificate */

size_t PKIUnpackRevokedCertificate(
    PKICONTEXT *ctx,
    PKIRevokedCertificate **asnstruct,
    const unsigned char *buf,
    size_t buflen,
    int *erret)
{
    size_t bytesused;
    bytesused=PKIUnpackRevokedCertificateInternal(ctx, asnstruct, buf, buflen,
                      PKIID_RevokedCertificate, erret);
    if(*erret==0 && bytesused==0)
        PKIERR(PKIErrUnpackUnderrun);
    return bytesused;
}

/******************************************************************
 * Routines for SubjectDirectoryAttributes
 ******************************************************************/

PKISubjectDirectoryAttributes *PKINewSubjectDirectoryAttributes(
    PKICONTEXT *ctx)
{
    PKISubjectDirectoryAttributes *f;

    if (ctx == NULL)
        return NULL;

    f = (PKISubjectDirectoryAttributes *)PKIAlloc(ctx->memMgr, sizeof(PKISubjectDirectoryAttributes));
    if (f != NULL)
        (void)memset(f, 0, sizeof(PKISubjectDirectoryAttributes));
    return (f);

} /* PKINewSubjectDirectoryAttributes */

void PKIFreeSubjectDirectoryAttributes(
    PKICONTEXT *ctx,
    PKISubjectDirectoryAttributes *f)
{
    if (ctx == NULL)
        return;

    PKIDropInPlaceSubjectDirectoryAttributes(ctx, f);
    if (f != NULL)
        PKIFree(ctx->memMgr, f);

} /* PKIFreeSubjectDirectoryAttributes */

size_t PKISizeofSubjectDirectoryAttributes(
    PKICONTEXT *ctx,
    PKISubjectDirectoryAttributes *asnstruct,
    int outerSizeFlag)
{
    (void)ctx; /* for future use */

    return(PKISizeofSubjectDirectoryAttributesInternal(asnstruct, outerSizeFlag, PKIFALSE));
} /* PKISizeofSubjectDirectoryAttributes */

size_t PKIPackSubjectDirectoryAttributes(
    PKICONTEXT *ctx,
    unsigned char *buf,
    size_t buflen,
    PKISubjectDirectoryAttributes *asnstruct,
    int *erret )
{
    return(PKIPackSubjectDirectoryAttributesInternal(ctx, buf, buflen, asnstruct, PKIID_SubjectDirectoryAttributes, erret));
} /* PKIPackSubjectDirectoryAttributes */

size_t PKIUnpackSubjectDirectoryAttributes(
    PKICONTEXT *ctx,
    PKISubjectDirectoryAttributes **asnstruct,
    const unsigned char *buf,
    size_t buflen,
    int *erret)
{
    size_t bytesused;
    bytesused=PKIUnpackSubjectDirectoryAttributesInternal(ctx, asnstruct, buf, buflen,
                      PKIID_SubjectDirectoryAttributes, erret);
    if(*erret==0 && bytesused==0)
        PKIERR(PKIErrUnpackUnderrun);
    return bytesused;
}

/******************************************************************
 * Routines for UserNotice
 ******************************************************************/

PKIUserNotice *PKINewUserNotice(
    PKICONTEXT *ctx)
{
    PKIUserNotice *f;

    if (ctx == NULL)
        return NULL;

    f = (PKIUserNotice *)PKIAlloc(ctx->memMgr, sizeof(PKIUserNotice));
    if (f != NULL)
        (void)memset(f, 0, sizeof(PKIUserNotice));
    return (f);

} /* PKINewUserNotice */

void PKIFreeUserNotice(
    PKICONTEXT *ctx,
    PKIUserNotice *f)
{
    if (ctx == NULL)
        return;

    PKIDropInPlaceUserNotice(ctx, f);
    if (f != NULL)
        PKIFree(ctx->memMgr, f);

} /* PKIFreeUserNotice */

size_t PKISizeofUserNotice(
    PKICONTEXT *ctx,
    PKIUserNotice *asnstruct,
    int outerSizeFlag)
{
    (void)ctx; /* for future use */

    return(PKISizeofUserNoticeInternal(asnstruct, outerSizeFlag, PKIFALSE));
} /* PKISizeofUserNotice */

size_t PKIPackUserNotice(
    PKICONTEXT *ctx,
    unsigned char *buf,
    size_t buflen,
    PKIUserNotice *asnstruct,
    int *erret )
{
    return(PKIPackUserNoticeInternal(ctx, buf, buflen, asnstruct, PKIID_UserNotice, erret));
} /* PKIPackUserNotice */

size_t PKIUnpackUserNotice(
    PKICONTEXT *ctx,
    PKIUserNotice **asnstruct,
    const unsigned char *buf,
    size_t buflen,
    int *erret)
{
    size_t bytesused;
    bytesused=PKIUnpackUserNoticeInternal(ctx, asnstruct, buf, buflen,
                      PKIID_UserNotice, erret);
    if(*erret==0 && bytesused==0)
        PKIERR(PKIErrUnpackUnderrun);
    return bytesused;
}

/******************************************************************
 * Routines for CertificatePolicies
 ******************************************************************/

PKICertificatePolicies *PKINewCertificatePolicies(
    PKICONTEXT *ctx)
{
    PKICertificatePolicies *f;

    if (ctx == NULL)
        return NULL;

    f = (PKICertificatePolicies *)PKIAlloc(ctx->memMgr, sizeof(PKICertificatePolicies));
    if (f != NULL)
        (void)memset(f, 0, sizeof(PKICertificatePolicies));
    return (f);

} /* PKINewCertificatePolicies */

void PKIFreeCertificatePolicies(
    PKICONTEXT *ctx,
    PKICertificatePolicies *f)
{
    if (ctx == NULL)
        return;

    PKIDropInPlaceCertificatePolicies(ctx, f);
    if (f != NULL)
        PKIFree(ctx->memMgr, f);

} /* PKIFreeCertificatePolicies */

size_t PKISizeofCertificatePolicies(
    PKICONTEXT *ctx,
    PKICertificatePolicies *asnstruct,
    int outerSizeFlag)
{
    (void)ctx; /* for future use */

    return(PKISizeofCertificatePoliciesInternal(asnstruct, outerSizeFlag, PKIFALSE));
} /* PKISizeofCertificatePolicies */

size_t PKIPackCertificatePolicies(
    PKICONTEXT *ctx,
    unsigned char *buf,
    size_t buflen,
    PKICertificatePolicies *asnstruct,
    int *erret )
{
    return(PKIPackCertificatePoliciesInternal(ctx, buf, buflen, asnstruct, PKIID_CertificatePolicies, erret));
} /* PKIPackCertificatePolicies */

size_t PKIUnpackCertificatePolicies(
    PKICONTEXT *ctx,
    PKICertificatePolicies **asnstruct,
    const unsigned char *buf,
    size_t buflen,
    int *erret)
{
    size_t bytesused;
    bytesused=PKIUnpackCertificatePoliciesInternal(ctx, asnstruct, buf, buflen,
                      PKIID_CertificatePolicies, erret);
    if(*erret==0 && bytesused==0)
        PKIERR(PKIErrUnpackUnderrun);
    return bytesused;
}

/******************************************************************
 * Routines for Name
 ******************************************************************/

PKIName *PKINewName(
    PKICONTEXT *ctx)
{
    PKIName *f;

    if (ctx == NULL)
        return NULL;

    f = (PKIName *)PKIAlloc(ctx->memMgr, sizeof(PKIName));
    if (f != NULL)
        (void)memset(f, 0, sizeof(PKIName));
    return (f);

} /* PKINewName */

void PKIFreeName(
    PKICONTEXT *ctx,
    PKIName *f)
{
    if (ctx == NULL)
        return;

    PKIDropInPlaceName(ctx, f);
    if (f != NULL)
        PKIFree(ctx->memMgr, f);

} /* PKIFreeName */

size_t PKISizeofName(
    PKICONTEXT *ctx,
    PKIName *asnstruct,
    int outerSizeFlag)
{
    (void)ctx; /* for future use */

    return(PKISizeofNameInternal(asnstruct, outerSizeFlag, PKIFALSE));
} /* PKISizeofName */

size_t PKIPackName(
    PKICONTEXT *ctx,
    unsigned char *buf,
    size_t buflen,
    PKIName *asnstruct,
    int *erret )
{
    return(PKIPackNameInternal(ctx, buf, buflen, asnstruct, PKIID_Name, erret));
} /* PKIPackName */

size_t PKIUnpackName(
    PKICONTEXT *ctx,
    PKIName **asnstruct,
    const unsigned char *buf,
    size_t buflen,
    int *erret)
{
    size_t bytesused;
    bytesused=PKIUnpackNameInternal(ctx, asnstruct, buf, buflen,
                      PKIID_Name, erret);
    if(*erret==0 && bytesused==0)
        PKIERR(PKIErrUnpackUnderrun);
    return bytesused;
}

/******************************************************************
 * Routines for RevokedCertificates
 ******************************************************************/

PKIRevokedCertificates *PKINewRevokedCertificates(
    PKICONTEXT *ctx)
{
    PKIRevokedCertificates *f;

    if (ctx == NULL)
        return NULL;

    f = (PKIRevokedCertificates *)PKIAlloc(ctx->memMgr, sizeof(PKIRevokedCertificates));
    if (f != NULL)
        (void)memset(f, 0, sizeof(PKIRevokedCertificates));
    return (f);

} /* PKINewRevokedCertificates */

void PKIFreeRevokedCertificates(
    PKICONTEXT *ctx,
    PKIRevokedCertificates *f)
{
    if (ctx == NULL)
        return;

    PKIDropInPlaceRevokedCertificates(ctx, f);
    if (f != NULL)
        PKIFree(ctx->memMgr, f);

} /* PKIFreeRevokedCertificates */

size_t PKISizeofRevokedCertificates(
    PKICONTEXT *ctx,
    PKIRevokedCertificates *asnstruct,
    int outerSizeFlag)
{
    (void)ctx; /* for future use */

    return(PKISizeofRevokedCertificatesInternal(asnstruct, outerSizeFlag, PKIFALSE));
} /* PKISizeofRevokedCertificates */

size_t PKIPackRevokedCertificates(
    PKICONTEXT *ctx,
    unsigned char *buf,
    size_t buflen,
    PKIRevokedCertificates *asnstruct,
    int *erret )
{
    return(PKIPackRevokedCertificatesInternal(ctx, buf, buflen, asnstruct, PKIID_RevokedCertificates, erret));
} /* PKIPackRevokedCertificates */

size_t PKIUnpackRevokedCertificates(
    PKICONTEXT *ctx,
    PKIRevokedCertificates **asnstruct,
    const unsigned char *buf,
    size_t buflen,
    int *erret)
{
    size_t bytesused;
    bytesused=PKIUnpackRevokedCertificatesInternal(ctx, asnstruct, buf, buflen,
                      PKIID_RevokedCertificates, erret);
    if(*erret==0 && bytesused==0)
        PKIERR(PKIErrUnpackUnderrun);
    return bytesused;
}

/******************************************************************
 * Routines for CertificationRequestInfo
 ******************************************************************/

PKICertificationRequestInfo *PKINewCertificationRequestInfo(
    PKICONTEXT *ctx)
{
    PKICertificationRequestInfo *f;

    if (ctx == NULL)
        return NULL;

    f = (PKICertificationRequestInfo *)PKIAlloc(ctx->memMgr, sizeof(PKICertificationRequestInfo));
    if (f != NULL)
        (void)memset(f, 0, sizeof(PKICertificationRequestInfo));
    return (f);

} /* PKINewCertificationRequestInfo */

void PKIFreeCertificationRequestInfo(
    PKICONTEXT *ctx,
    PKICertificationRequestInfo *f)
{
    if (ctx == NULL)
        return;

    PKIDropInPlaceCertificationRequestInfo(ctx, f);
    if (f != NULL)
        PKIFree(ctx->memMgr, f);

} /* PKIFreeCertificationRequestInfo */

size_t PKISizeofCertificationRequestInfo(
    PKICONTEXT *ctx,
    PKICertificationRequestInfo *asnstruct,
    int outerSizeFlag)
{
    (void)ctx; /* for future use */

    return(PKISizeofCertificationRequestInfoInternal(asnstruct, outerSizeFlag, PKIFALSE));
} /* PKISizeofCertificationRequestInfo */

size_t PKIPackCertificationRequestInfo(
    PKICONTEXT *ctx,
    unsigned char *buf,
    size_t buflen,
    PKICertificationRequestInfo *asnstruct,
    int *erret )
{
    return(PKIPackCertificationRequestInfoInternal(ctx, buf, buflen, asnstruct, PKIID_CertificationRequestInfo, erret));
} /* PKIPackCertificationRequestInfo */

size_t PKIUnpackCertificationRequestInfo(
    PKICONTEXT *ctx,
    PKICertificationRequestInfo **asnstruct,
    const unsigned char *buf,
    size_t buflen,
    int *erret)
{
    size_t bytesused;
    bytesused=PKIUnpackCertificationRequestInfoInternal(ctx, asnstruct, buf, buflen,
                      PKIID_CertificationRequestInfo, erret);
    if(*erret==0 && bytesused==0)
        PKIERR(PKIErrUnpackUnderrun);
    return bytesused;
}

/******************************************************************
 * Routines for GeneralName
 ******************************************************************/

PKIGeneralName *PKINewGeneralName(
    PKICONTEXT *ctx)
{
    PKIGeneralName *f;

    if (ctx == NULL)
        return NULL;

    f = (PKIGeneralName *)PKIAlloc(ctx->memMgr, sizeof(PKIGeneralName));
    if (f != NULL)
        (void)memset(f, 0, sizeof(PKIGeneralName));
    return (f);

} /* PKINewGeneralName */

void PKIFreeGeneralName(
    PKICONTEXT *ctx,
    PKIGeneralName *f)
{
    if (ctx == NULL)
        return;

    PKIDropInPlaceGeneralName(ctx, f);
    if (f != NULL)
        PKIFree(ctx->memMgr, f);

} /* PKIFreeGeneralName */

size_t PKISizeofGeneralName(
    PKICONTEXT *ctx,
    PKIGeneralName *asnstruct,
    int outerSizeFlag)
{
    (void)ctx; /* for future use */

    return(PKISizeofGeneralNameInternal(asnstruct, outerSizeFlag, PKIFALSE));
} /* PKISizeofGeneralName */

size_t PKIPackGeneralName(
    PKICONTEXT *ctx,
    unsigned char *buf,
    size_t buflen,
    PKIGeneralName *asnstruct,
    int *erret )
{
    return(PKIPackGeneralNameInternal(ctx, buf, buflen, asnstruct, PKIID_GeneralName, erret));
} /* PKIPackGeneralName */

size_t PKIUnpackGeneralName(
    PKICONTEXT *ctx,
    PKIGeneralName **asnstruct,
    const unsigned char *buf,
    size_t buflen,
    int *erret)
{
    size_t bytesused;
    bytesused=PKIUnpackGeneralNameInternal(ctx, asnstruct, buf, buflen,
                      PKIID_GeneralName, erret);
    if(*erret==0 && bytesused==0)
        PKIERR(PKIErrUnpackUnderrun);
    return bytesused;
}

/******************************************************************
 * Routines for TBSCertList
 ******************************************************************/

PKITBSCertList *PKINewTBSCertList(
    PKICONTEXT *ctx)
{
    PKITBSCertList *f;

    if (ctx == NULL)
        return NULL;

    f = (PKITBSCertList *)PKIAlloc(ctx->memMgr, sizeof(PKITBSCertList));
    if (f != NULL)
        (void)memset(f, 0, sizeof(PKITBSCertList));
    return (f);

} /* PKINewTBSCertList */

void PKIFreeTBSCertList(
    PKICONTEXT *ctx,
    PKITBSCertList *f)
{
    if (ctx == NULL)
        return;

    PKIDropInPlaceTBSCertList(ctx, f);
    if (f != NULL)
        PKIFree(ctx->memMgr, f);

} /* PKIFreeTBSCertList */

size_t PKISizeofTBSCertList(
    PKICONTEXT *ctx,
    PKITBSCertList *asnstruct,
    int outerSizeFlag)
{
    (void)ctx; /* for future use */

    return(PKISizeofTBSCertListInternal(asnstruct, outerSizeFlag, PKIFALSE));
} /* PKISizeofTBSCertList */

size_t PKIPackTBSCertList(
    PKICONTEXT *ctx,
    unsigned char *buf,
    size_t buflen,
    PKITBSCertList *asnstruct,
    int *erret )
{
    return(PKIPackTBSCertListInternal(ctx, buf, buflen, asnstruct, PKIID_TBSCertList, erret));
} /* PKIPackTBSCertList */

size_t PKIUnpackTBSCertList(
    PKICONTEXT *ctx,
    PKITBSCertList **asnstruct,
    const unsigned char *buf,
    size_t buflen,
    int *erret)
{
    size_t bytesused;
    bytesused=PKIUnpackTBSCertListInternal(ctx, asnstruct, buf, buflen,
                      PKIID_TBSCertList, erret);
    if(*erret==0 && bytesused==0)
        PKIERR(PKIErrUnpackUnderrun);
    return bytesused;
}

/******************************************************************
 * Routines for TBSCertificate
 ******************************************************************/

PKITBSCertificate *PKINewTBSCertificate(
    PKICONTEXT *ctx)
{
    PKITBSCertificate *f;

    if (ctx == NULL)
        return NULL;

    f = (PKITBSCertificate *)PKIAlloc(ctx->memMgr, sizeof(PKITBSCertificate));
    if (f != NULL)
        (void)memset(f, 0, sizeof(PKITBSCertificate));
    return (f);

} /* PKINewTBSCertificate */

void PKIFreeTBSCertificate(
    PKICONTEXT *ctx,
    PKITBSCertificate *f)
{
    if (ctx == NULL)
        return;

    PKIDropInPlaceTBSCertificate(ctx, f);
    if (f != NULL)
        PKIFree(ctx->memMgr, f);

} /* PKIFreeTBSCertificate */

size_t PKISizeofTBSCertificate(
    PKICONTEXT *ctx,
    PKITBSCertificate *asnstruct,
    int outerSizeFlag)
{
    (void)ctx; /* for future use */

    return(PKISizeofTBSCertificateInternal(asnstruct, outerSizeFlag, PKIFALSE));
} /* PKISizeofTBSCertificate */

size_t PKIPackTBSCertificate(
    PKICONTEXT *ctx,
    unsigned char *buf,
    size_t buflen,
    PKITBSCertificate *asnstruct,
    int *erret )
{
    return(PKIPackTBSCertificateInternal(ctx, buf, buflen, asnstruct, PKIID_TBSCertificate, erret));
} /* PKIPackTBSCertificate */

size_t PKIUnpackTBSCertificate(
    PKICONTEXT *ctx,
    PKITBSCertificate **asnstruct,
    const unsigned char *buf,
    size_t buflen,
    int *erret)
{
    size_t bytesused;
    bytesused=PKIUnpackTBSCertificateInternal(ctx, asnstruct, buf, buflen,
                      PKIID_TBSCertificate, erret);
    if(*erret==0 && bytesused==0)
        PKIERR(PKIErrUnpackUnderrun);
    return bytesused;
}

/******************************************************************
 * Routines for AccessDescription
 ******************************************************************/

PKIAccessDescription *PKINewAccessDescription(
    PKICONTEXT *ctx)
{
    PKIAccessDescription *f;

    if (ctx == NULL)
        return NULL;

    f = (PKIAccessDescription *)PKIAlloc(ctx->memMgr, sizeof(PKIAccessDescription));
    if (f != NULL)
        (void)memset(f, 0, sizeof(PKIAccessDescription));
    return (f);

} /* PKINewAccessDescription */

void PKIFreeAccessDescription(
    PKICONTEXT *ctx,
    PKIAccessDescription *f)
{
    if (ctx == NULL)
        return;

    PKIDropInPlaceAccessDescription(ctx, f);
    if (f != NULL)
        PKIFree(ctx->memMgr, f);

} /* PKIFreeAccessDescription */

size_t PKISizeofAccessDescription(
    PKICONTEXT *ctx,
    PKIAccessDescription *asnstruct,
    int outerSizeFlag)
{
    (void)ctx; /* for future use */

    return(PKISizeofAccessDescriptionInternal(asnstruct, outerSizeFlag, PKIFALSE));
} /* PKISizeofAccessDescription */

size_t PKIPackAccessDescription(
    PKICONTEXT *ctx,
    unsigned char *buf,
    size_t buflen,
    PKIAccessDescription *asnstruct,
    int *erret )
{
    return(PKIPackAccessDescriptionInternal(ctx, buf, buflen, asnstruct, PKIID_AccessDescription, erret));
} /* PKIPackAccessDescription */

size_t PKIUnpackAccessDescription(
    PKICONTEXT *ctx,
    PKIAccessDescription **asnstruct,
    const unsigned char *buf,
    size_t buflen,
    int *erret)
{
    size_t bytesused;
    bytesused=PKIUnpackAccessDescriptionInternal(ctx, asnstruct, buf, buflen,
                      PKIID_AccessDescription, erret);
    if(*erret==0 && bytesused==0)
        PKIERR(PKIErrUnpackUnderrun);
    return bytesused;
}

/******************************************************************
 * Routines for Certificate
 ******************************************************************/

PKICertificate *PKINewCertificate(
    PKICONTEXT *ctx)
{
    PKICertificate *f;

    if (ctx == NULL)
        return NULL;

    f = (PKICertificate *)PKIAlloc(ctx->memMgr, sizeof(PKICertificate));
    if (f != NULL)
        (void)memset(f, 0, sizeof(PKICertificate));
    return (f);

} /* PKINewCertificate */

void PKIFreeCertificate(
    PKICONTEXT *ctx,
    PKICertificate *f)
{
    if (ctx == NULL)
        return;

    PKIDropInPlaceCertificate(ctx, f);
    if (f != NULL)
        PKIFree(ctx->memMgr, f);

} /* PKIFreeCertificate */

size_t PKISizeofCertificate(
    PKICONTEXT *ctx,
    PKICertificate *asnstruct,
    int outerSizeFlag)
{
    (void)ctx; /* for future use */

    return(PKISizeofCertificateInternal(asnstruct, outerSizeFlag, PKIFALSE));
} /* PKISizeofCertificate */

size_t PKIPackCertificate(
    PKICONTEXT *ctx,
    unsigned char *buf,
    size_t buflen,
    PKICertificate *asnstruct,
    int *erret )
{
    return(PKIPackCertificateInternal(ctx, buf, buflen, asnstruct, PKIID_Certificate, erret));
} /* PKIPackCertificate */

size_t PKIUnpackCertificate(
    PKICONTEXT *ctx,
    PKICertificate **asnstruct,
    const unsigned char *buf,
    size_t buflen,
    int *erret)
{
    size_t bytesused;
    bytesused=PKIUnpackCertificateInternal(ctx, asnstruct, buf, buflen,
                      PKIID_Certificate, erret);
    if(*erret==0 && bytesused==0)
        PKIERR(PKIErrUnpackUnderrun);
    return bytesused;
}

/******************************************************************
 * Routines for CertificateList
 ******************************************************************/

PKICertificateList *PKINewCertificateList(
    PKICONTEXT *ctx)
{
    PKICertificateList *f;

    if (ctx == NULL)
        return NULL;

    f = (PKICertificateList *)PKIAlloc(ctx->memMgr, sizeof(PKICertificateList));
    if (f != NULL)
        (void)memset(f, 0, sizeof(PKICertificateList));
    return (f);

} /* PKINewCertificateList */

void PKIFreeCertificateList(
    PKICONTEXT *ctx,
    PKICertificateList *f)
{
    if (ctx == NULL)
        return;

    PKIDropInPlaceCertificateList(ctx, f);
    if (f != NULL)
        PKIFree(ctx->memMgr, f);

} /* PKIFreeCertificateList */

size_t PKISizeofCertificateList(
    PKICONTEXT *ctx,
    PKICertificateList *asnstruct,
    int outerSizeFlag)
{
    (void)ctx; /* for future use */

    return(PKISizeofCertificateListInternal(asnstruct, outerSizeFlag, PKIFALSE));
} /* PKISizeofCertificateList */

size_t PKIPackCertificateList(
    PKICONTEXT *ctx,
    unsigned char *buf,
    size_t buflen,
    PKICertificateList *asnstruct,
    int *erret )
{
    return(PKIPackCertificateListInternal(ctx, buf, buflen, asnstruct, PKIID_CertificateList, erret));
} /* PKIPackCertificateList */

size_t PKIUnpackCertificateList(
    PKICONTEXT *ctx,
    PKICertificateList **asnstruct,
    const unsigned char *buf,
    size_t buflen,
    int *erret)
{
    size_t bytesused;
    bytesused=PKIUnpackCertificateListInternal(ctx, asnstruct, buf, buflen,
                      PKIID_CertificateList, erret);
    if(*erret==0 && bytesused==0)
        PKIERR(PKIErrUnpackUnderrun);
    return bytesused;
}

/******************************************************************
 * Routines for CertificationRequest
 ******************************************************************/

PKICertificationRequest *PKINewCertificationRequest(
    PKICONTEXT *ctx)
{
    PKICertificationRequest *f;

    if (ctx == NULL)
        return NULL;

    f = (PKICertificationRequest *)PKIAlloc(ctx->memMgr, sizeof(PKICertificationRequest));
    if (f != NULL)
        (void)memset(f, 0, sizeof(PKICertificationRequest));
    return (f);

} /* PKINewCertificationRequest */

void PKIFreeCertificationRequest(
    PKICONTEXT *ctx,
    PKICertificationRequest *f)
{
    if (ctx == NULL)
        return;

    PKIDropInPlaceCertificationRequest(ctx, f);
    if (f != NULL)
        PKIFree(ctx->memMgr, f);

} /* PKIFreeCertificationRequest */

size_t PKISizeofCertificationRequest(
    PKICONTEXT *ctx,
    PKICertificationRequest *asnstruct,
    int outerSizeFlag)
{
    (void)ctx; /* for future use */

    return(PKISizeofCertificationRequestInternal(asnstruct, outerSizeFlag, PKIFALSE));
} /* PKISizeofCertificationRequest */

size_t PKIPackCertificationRequest(
    PKICONTEXT *ctx,
    unsigned char *buf,
    size_t buflen,
    PKICertificationRequest *asnstruct,
    int *erret )
{
    return(PKIPackCertificationRequestInternal(ctx, buf, buflen, asnstruct, PKIID_CertificationRequest, erret));
} /* PKIPackCertificationRequest */

size_t PKIUnpackCertificationRequest(
    PKICONTEXT *ctx,
    PKICertificationRequest **asnstruct,
    const unsigned char *buf,
    size_t buflen,
    int *erret)
{
    size_t bytesused;
    bytesused=PKIUnpackCertificationRequestInternal(ctx, asnstruct, buf, buflen,
                      PKIID_CertificationRequest, erret);
    if(*erret==0 && bytesused==0)
        PKIERR(PKIErrUnpackUnderrun);
    return bytesused;
}

/******************************************************************
 * Routines for GeneralNames
 ******************************************************************/

PKIGeneralNames *PKINewGeneralNames(
    PKICONTEXT *ctx)
{
    PKIGeneralNames *f;

    if (ctx == NULL)
        return NULL;

    f = (PKIGeneralNames *)PKIAlloc(ctx->memMgr, sizeof(PKIGeneralNames));
    if (f != NULL)
        (void)memset(f, 0, sizeof(PKIGeneralNames));
    return (f);

} /* PKINewGeneralNames */

void PKIFreeGeneralNames(
    PKICONTEXT *ctx,
    PKIGeneralNames *f)
{
    if (ctx == NULL)
        return;

    PKIDropInPlaceGeneralNames(ctx, f);
    if (f != NULL)
        PKIFree(ctx->memMgr, f);

} /* PKIFreeGeneralNames */

size_t PKISizeofGeneralNames(
    PKICONTEXT *ctx,
    PKIGeneralNames *asnstruct,
    int outerSizeFlag)
{
    (void)ctx; /* for future use */

    return(PKISizeofGeneralNamesInternal(asnstruct, outerSizeFlag, PKIFALSE));
} /* PKISizeofGeneralNames */

size_t PKIPackGeneralNames(
    PKICONTEXT *ctx,
    unsigned char *buf,
    size_t buflen,
    PKIGeneralNames *asnstruct,
    int *erret )
{
    return(PKIPackGeneralNamesInternal(ctx, buf, buflen, asnstruct, PKIID_GeneralNames, erret));
} /* PKIPackGeneralNames */

size_t PKIUnpackGeneralNames(
    PKICONTEXT *ctx,
    PKIGeneralNames **asnstruct,
    const unsigned char *buf,
    size_t buflen,
    int *erret)
{
    size_t bytesused;
    bytesused=PKIUnpackGeneralNamesInternal(ctx, asnstruct, buf, buflen,
                      PKIID_GeneralNames, erret);
    if(*erret==0 && bytesused==0)
        PKIERR(PKIErrUnpackUnderrun);
    return bytesused;
}

/******************************************************************
 * Routines for GeneralSubtree
 ******************************************************************/

PKIGeneralSubtree *PKINewGeneralSubtree(
    PKICONTEXT *ctx)
{
    PKIGeneralSubtree *f;

    if (ctx == NULL)
        return NULL;

    f = (PKIGeneralSubtree *)PKIAlloc(ctx->memMgr, sizeof(PKIGeneralSubtree));
    if (f != NULL)
        (void)memset(f, 0, sizeof(PKIGeneralSubtree));
    return (f);

} /* PKINewGeneralSubtree */

void PKIFreeGeneralSubtree(
    PKICONTEXT *ctx,
    PKIGeneralSubtree *f)
{
    if (ctx == NULL)
        return;

    PKIDropInPlaceGeneralSubtree(ctx, f);
    if (f != NULL)
        PKIFree(ctx->memMgr, f);

} /* PKIFreeGeneralSubtree */

size_t PKISizeofGeneralSubtree(
    PKICONTEXT *ctx,
    PKIGeneralSubtree *asnstruct,
    int outerSizeFlag)
{
    (void)ctx; /* for future use */

    return(PKISizeofGeneralSubtreeInternal(asnstruct, outerSizeFlag, PKIFALSE));
} /* PKISizeofGeneralSubtree */

size_t PKIPackGeneralSubtree(
    PKICONTEXT *ctx,
    unsigned char *buf,
    size_t buflen,
    PKIGeneralSubtree *asnstruct,
    int *erret )
{
    return(PKIPackGeneralSubtreeInternal(ctx, buf, buflen, asnstruct, PKIID_GeneralSubtree, erret));
} /* PKIPackGeneralSubtree */

size_t PKIUnpackGeneralSubtree(
    PKICONTEXT *ctx,
    PKIGeneralSubtree **asnstruct,
    const unsigned char *buf,
    size_t buflen,
    int *erret)
{
    size_t bytesused;
    bytesused=PKIUnpackGeneralSubtreeInternal(ctx, asnstruct, buf, buflen,
                      PKIID_GeneralSubtree, erret);
    if(*erret==0 && bytesused==0)
        PKIERR(PKIErrUnpackUnderrun);
    return bytesused;
}

/******************************************************************
 * Routines for AuthorityInfoAccessSyntax
 ******************************************************************/

PKIAuthorityInfoAccessSyntax *PKINewAuthorityInfoAccessSyntax(
    PKICONTEXT *ctx)
{
    PKIAuthorityInfoAccessSyntax *f;

    if (ctx == NULL)
        return NULL;

    f = (PKIAuthorityInfoAccessSyntax *)PKIAlloc(ctx->memMgr, sizeof(PKIAuthorityInfoAccessSyntax));
    if (f != NULL)
        (void)memset(f, 0, sizeof(PKIAuthorityInfoAccessSyntax));
    return (f);

} /* PKINewAuthorityInfoAccessSyntax */

void PKIFreeAuthorityInfoAccessSyntax(
    PKICONTEXT *ctx,
    PKIAuthorityInfoAccessSyntax *f)
{
    if (ctx == NULL)
        return;

    PKIDropInPlaceAuthorityInfoAccessSyntax(ctx, f);
    if (f != NULL)
        PKIFree(ctx->memMgr, f);

} /* PKIFreeAuthorityInfoAccessSyntax */

size_t PKISizeofAuthorityInfoAccessSyntax(
    PKICONTEXT *ctx,
    PKIAuthorityInfoAccessSyntax *asnstruct,
    int outerSizeFlag)
{
    (void)ctx; /* for future use */

    return(PKISizeofAuthorityInfoAccessSyntaxInternal(asnstruct, outerSizeFlag, PKIFALSE));
} /* PKISizeofAuthorityInfoAccessSyntax */

size_t PKIPackAuthorityInfoAccessSyntax(
    PKICONTEXT *ctx,
    unsigned char *buf,
    size_t buflen,
    PKIAuthorityInfoAccessSyntax *asnstruct,
    int *erret )
{
    return(PKIPackAuthorityInfoAccessSyntaxInternal(ctx, buf, buflen, asnstruct, PKIID_AuthorityInfoAccessSyntax, erret));
} /* PKIPackAuthorityInfoAccessSyntax */

size_t PKIUnpackAuthorityInfoAccessSyntax(
    PKICONTEXT *ctx,
    PKIAuthorityInfoAccessSyntax **asnstruct,
    const unsigned char *buf,
    size_t buflen,
    int *erret)
{
    size_t bytesused;
    bytesused=PKIUnpackAuthorityInfoAccessSyntaxInternal(ctx, asnstruct, buf, buflen,
                      PKIID_AuthorityInfoAccessSyntax, erret);
    if(*erret==0 && bytesused==0)
        PKIERR(PKIErrUnpackUnderrun);
    return bytesused;
}

/******************************************************************
 * Routines for AuthorityKeyIdentifier
 ******************************************************************/

PKIAuthorityKeyIdentifier *PKINewAuthorityKeyIdentifier(
    PKICONTEXT *ctx)
{
    PKIAuthorityKeyIdentifier *f;

    if (ctx == NULL)
        return NULL;

    f = (PKIAuthorityKeyIdentifier *)PKIAlloc(ctx->memMgr, sizeof(PKIAuthorityKeyIdentifier));
    if (f != NULL)
        (void)memset(f, 0, sizeof(PKIAuthorityKeyIdentifier));
    return (f);

} /* PKINewAuthorityKeyIdentifier */

void PKIFreeAuthorityKeyIdentifier(
    PKICONTEXT *ctx,
    PKIAuthorityKeyIdentifier *f)
{
    if (ctx == NULL)
        return;

    PKIDropInPlaceAuthorityKeyIdentifier(ctx, f);
    if (f != NULL)
        PKIFree(ctx->memMgr, f);

} /* PKIFreeAuthorityKeyIdentifier */

size_t PKISizeofAuthorityKeyIdentifier(
    PKICONTEXT *ctx,
    PKIAuthorityKeyIdentifier *asnstruct,
    int outerSizeFlag)
{
    (void)ctx; /* for future use */

    return(PKISizeofAuthorityKeyIdentifierInternal(asnstruct, outerSizeFlag, PKIFALSE));
} /* PKISizeofAuthorityKeyIdentifier */

size_t PKIPackAuthorityKeyIdentifier(
    PKICONTEXT *ctx,
    unsigned char *buf,
    size_t buflen,
    PKIAuthorityKeyIdentifier *asnstruct,
    int *erret )
{
    return(PKIPackAuthorityKeyIdentifierInternal(ctx, buf, buflen, asnstruct, PKIID_AuthorityKeyIdentifier, erret));
} /* PKIPackAuthorityKeyIdentifier */

size_t PKIUnpackAuthorityKeyIdentifier(
    PKICONTEXT *ctx,
    PKIAuthorityKeyIdentifier **asnstruct,
    const unsigned char *buf,
    size_t buflen,
    int *erret)
{
    size_t bytesused;
    bytesused=PKIUnpackAuthorityKeyIdentifierInternal(ctx, asnstruct, buf, buflen,
                      PKIID_AuthorityKeyIdentifier, erret);
    if(*erret==0 && bytesused==0)
        PKIERR(PKIErrUnpackUnderrun);
    return bytesused;
}

/******************************************************************
 * Routines for DistributionPointName
 ******************************************************************/

PKIDistributionPointName *PKINewDistributionPointName(
    PKICONTEXT *ctx)
{
    PKIDistributionPointName *f;

    if (ctx == NULL)
        return NULL;

    f = (PKIDistributionPointName *)PKIAlloc(ctx->memMgr, sizeof(PKIDistributionPointName));
    if (f != NULL)
        (void)memset(f, 0, sizeof(PKIDistributionPointName));
    return (f);

} /* PKINewDistributionPointName */

void PKIFreeDistributionPointName(
    PKICONTEXT *ctx,
    PKIDistributionPointName *f)
{
    if (ctx == NULL)
        return;

    PKIDropInPlaceDistributionPointName(ctx, f);
    if (f != NULL)
        PKIFree(ctx->memMgr, f);

} /* PKIFreeDistributionPointName */

size_t PKISizeofDistributionPointName(
    PKICONTEXT *ctx,
    PKIDistributionPointName *asnstruct,
    int outerSizeFlag)
{
    (void)ctx; /* for future use */

    return(PKISizeofDistributionPointNameInternal(asnstruct, outerSizeFlag, PKIFALSE));
} /* PKISizeofDistributionPointName */

size_t PKIPackDistributionPointName(
    PKICONTEXT *ctx,
    unsigned char *buf,
    size_t buflen,
    PKIDistributionPointName *asnstruct,
    int *erret )
{
    return(PKIPackDistributionPointNameInternal(ctx, buf, buflen, asnstruct, PKIID_DistributionPointName, erret));
} /* PKIPackDistributionPointName */

size_t PKIUnpackDistributionPointName(
    PKICONTEXT *ctx,
    PKIDistributionPointName **asnstruct,
    const unsigned char *buf,
    size_t buflen,
    int *erret)
{
    size_t bytesused;
    bytesused=PKIUnpackDistributionPointNameInternal(ctx, asnstruct, buf, buflen,
                      PKIID_DistributionPointName, erret);
    if(*erret==0 && bytesused==0)
        PKIERR(PKIErrUnpackUnderrun);
    return bytesused;
}

/******************************************************************
 * Routines for GeneralSubtrees
 ******************************************************************/

PKIGeneralSubtrees *PKINewGeneralSubtrees(
    PKICONTEXT *ctx)
{
    PKIGeneralSubtrees *f;

    if (ctx == NULL)
        return NULL;

    f = (PKIGeneralSubtrees *)PKIAlloc(ctx->memMgr, sizeof(PKIGeneralSubtrees));
    if (f != NULL)
        (void)memset(f, 0, sizeof(PKIGeneralSubtrees));
    return (f);

} /* PKINewGeneralSubtrees */

void PKIFreeGeneralSubtrees(
    PKICONTEXT *ctx,
    PKIGeneralSubtrees *f)
{
    if (ctx == NULL)
        return;

    PKIDropInPlaceGeneralSubtrees(ctx, f);
    if (f != NULL)
        PKIFree(ctx->memMgr, f);

} /* PKIFreeGeneralSubtrees */

size_t PKISizeofGeneralSubtrees(
    PKICONTEXT *ctx,
    PKIGeneralSubtrees *asnstruct,
    int outerSizeFlag)
{
    (void)ctx; /* for future use */

    return(PKISizeofGeneralSubtreesInternal(asnstruct, outerSizeFlag, PKIFALSE));
} /* PKISizeofGeneralSubtrees */

size_t PKIPackGeneralSubtrees(
    PKICONTEXT *ctx,
    unsigned char *buf,
    size_t buflen,
    PKIGeneralSubtrees *asnstruct,
    int *erret )
{
    return(PKIPackGeneralSubtreesInternal(ctx, buf, buflen, asnstruct, PKIID_GeneralSubtrees, erret));
} /* PKIPackGeneralSubtrees */

size_t PKIUnpackGeneralSubtrees(
    PKICONTEXT *ctx,
    PKIGeneralSubtrees **asnstruct,
    const unsigned char *buf,
    size_t buflen,
    int *erret)
{
    size_t bytesused;
    bytesused=PKIUnpackGeneralSubtreesInternal(ctx, asnstruct, buf, buflen,
                      PKIID_GeneralSubtrees, erret);
    if(*erret==0 && bytesused==0)
        PKIERR(PKIErrUnpackUnderrun);
    return bytesused;
}

/******************************************************************
 * Routines for DistributionPoint
 ******************************************************************/

PKIDistributionPoint *PKINewDistributionPoint(
    PKICONTEXT *ctx)
{
    PKIDistributionPoint *f;

    if (ctx == NULL)
        return NULL;

    f = (PKIDistributionPoint *)PKIAlloc(ctx->memMgr, sizeof(PKIDistributionPoint));
    if (f != NULL)
        (void)memset(f, 0, sizeof(PKIDistributionPoint));
    return (f);

} /* PKINewDistributionPoint */

void PKIFreeDistributionPoint(
    PKICONTEXT *ctx,
    PKIDistributionPoint *f)
{
    if (ctx == NULL)
        return;

    PKIDropInPlaceDistributionPoint(ctx, f);
    if (f != NULL)
        PKIFree(ctx->memMgr, f);

} /* PKIFreeDistributionPoint */

size_t PKISizeofDistributionPoint(
    PKICONTEXT *ctx,
    PKIDistributionPoint *asnstruct,
    int outerSizeFlag)
{
    (void)ctx; /* for future use */

    return(PKISizeofDistributionPointInternal(asnstruct, outerSizeFlag, PKIFALSE));
} /* PKISizeofDistributionPoint */

size_t PKIPackDistributionPoint(
    PKICONTEXT *ctx,
    unsigned char *buf,
    size_t buflen,
    PKIDistributionPoint *asnstruct,
    int *erret )
{
    return(PKIPackDistributionPointInternal(ctx, buf, buflen, asnstruct, PKIID_DistributionPoint, erret));
} /* PKIPackDistributionPoint */

size_t PKIUnpackDistributionPoint(
    PKICONTEXT *ctx,
    PKIDistributionPoint **asnstruct,
    const unsigned char *buf,
    size_t buflen,
    int *erret)
{
    size_t bytesused;
    bytesused=PKIUnpackDistributionPointInternal(ctx, asnstruct, buf, buflen,
                      PKIID_DistributionPoint, erret);
    if(*erret==0 && bytesused==0)
        PKIERR(PKIErrUnpackUnderrun);
    return bytesused;
}

/******************************************************************
 * Routines for IssuingDistributionPoint
 ******************************************************************/

PKIIssuingDistributionPoint *PKINewIssuingDistributionPoint(
    PKICONTEXT *ctx)
{
    PKIIssuingDistributionPoint *f;

    if (ctx == NULL)
        return NULL;

    f = (PKIIssuingDistributionPoint *)PKIAlloc(ctx->memMgr, sizeof(PKIIssuingDistributionPoint));
    if (f != NULL)
        (void)memset(f, 0, sizeof(PKIIssuingDistributionPoint));
    return (f);

} /* PKINewIssuingDistributionPoint */

void PKIFreeIssuingDistributionPoint(
    PKICONTEXT *ctx,
    PKIIssuingDistributionPoint *f)
{
    if (ctx == NULL)
        return;

    PKIDropInPlaceIssuingDistributionPoint(ctx, f);
    if (f != NULL)
        PKIFree(ctx->memMgr, f);

} /* PKIFreeIssuingDistributionPoint */

size_t PKISizeofIssuingDistributionPoint(
    PKICONTEXT *ctx,
    PKIIssuingDistributionPoint *asnstruct,
    int outerSizeFlag)
{
    (void)ctx; /* for future use */

    return(PKISizeofIssuingDistributionPointInternal(asnstruct, outerSizeFlag, PKIFALSE));
} /* PKISizeofIssuingDistributionPoint */

size_t PKIPackIssuingDistributionPoint(
    PKICONTEXT *ctx,
    unsigned char *buf,
    size_t buflen,
    PKIIssuingDistributionPoint *asnstruct,
    int *erret )
{
    return(PKIPackIssuingDistributionPointInternal(ctx, buf, buflen, asnstruct, PKIID_IssuingDistributionPoint, erret));
} /* PKIPackIssuingDistributionPoint */

size_t PKIUnpackIssuingDistributionPoint(
    PKICONTEXT *ctx,
    PKIIssuingDistributionPoint **asnstruct,
    const unsigned char *buf,
    size_t buflen,
    int *erret)
{
    size_t bytesused;
    bytesused=PKIUnpackIssuingDistributionPointInternal(ctx, asnstruct, buf, buflen,
                      PKIID_IssuingDistributionPoint, erret);
    if(*erret==0 && bytesused==0)
        PKIERR(PKIErrUnpackUnderrun);
    return bytesused;
}

/******************************************************************
 * Routines for NameConstraints
 ******************************************************************/

PKINameConstraints *PKINewNameConstraints(
    PKICONTEXT *ctx)
{
    PKINameConstraints *f;

    if (ctx == NULL)
        return NULL;

    f = (PKINameConstraints *)PKIAlloc(ctx->memMgr, sizeof(PKINameConstraints));
    if (f != NULL)
        (void)memset(f, 0, sizeof(PKINameConstraints));
    return (f);

} /* PKINewNameConstraints */

void PKIFreeNameConstraints(
    PKICONTEXT *ctx,
    PKINameConstraints *f)
{
    if (ctx == NULL)
        return;

    PKIDropInPlaceNameConstraints(ctx, f);
    if (f != NULL)
        PKIFree(ctx->memMgr, f);

} /* PKIFreeNameConstraints */

size_t PKISizeofNameConstraints(
    PKICONTEXT *ctx,
    PKINameConstraints *asnstruct,
    int outerSizeFlag)
{
    (void)ctx; /* for future use */

    return(PKISizeofNameConstraintsInternal(asnstruct, outerSizeFlag, PKIFALSE));
} /* PKISizeofNameConstraints */

size_t PKIPackNameConstraints(
    PKICONTEXT *ctx,
    unsigned char *buf,
    size_t buflen,
    PKINameConstraints *asnstruct,
    int *erret )
{
    return(PKIPackNameConstraintsInternal(ctx, buf, buflen, asnstruct, PKIID_NameConstraints, erret));
} /* PKIPackNameConstraints */

size_t PKIUnpackNameConstraints(
    PKICONTEXT *ctx,
    PKINameConstraints **asnstruct,
    const unsigned char *buf,
    size_t buflen,
    int *erret)
{
    size_t bytesused;
    bytesused=PKIUnpackNameConstraintsInternal(ctx, asnstruct, buf, buflen,
                      PKIID_NameConstraints, erret);
    if(*erret==0 && bytesused==0)
        PKIERR(PKIErrUnpackUnderrun);
    return bytesused;
}

/******************************************************************
 * Routines for CRLDistPointsSyntax
 ******************************************************************/

PKICRLDistPointsSyntax *PKINewCRLDistPointsSyntax(
    PKICONTEXT *ctx)
{
    PKICRLDistPointsSyntax *f;

    if (ctx == NULL)
        return NULL;

    f = (PKICRLDistPointsSyntax *)PKIAlloc(ctx->memMgr, sizeof(PKICRLDistPointsSyntax));
    if (f != NULL)
        (void)memset(f, 0, sizeof(PKICRLDistPointsSyntax));
    return (f);

} /* PKINewCRLDistPointsSyntax */

void PKIFreeCRLDistPointsSyntax(
    PKICONTEXT *ctx,
    PKICRLDistPointsSyntax *f)
{
    if (ctx == NULL)
        return;

    PKIDropInPlaceCRLDistPointsSyntax(ctx, f);
    if (f != NULL)
        PKIFree(ctx->memMgr, f);

} /* PKIFreeCRLDistPointsSyntax */

size_t PKISizeofCRLDistPointsSyntax(
    PKICONTEXT *ctx,
    PKICRLDistPointsSyntax *asnstruct,
    int outerSizeFlag)
{
    (void)ctx; /* for future use */

    return(PKISizeofCRLDistPointsSyntaxInternal(asnstruct, outerSizeFlag, PKIFALSE));
} /* PKISizeofCRLDistPointsSyntax */

size_t PKIPackCRLDistPointsSyntax(
    PKICONTEXT *ctx,
    unsigned char *buf,
    size_t buflen,
    PKICRLDistPointsSyntax *asnstruct,
    int *erret )
{
    return(PKIPackCRLDistPointsSyntaxInternal(ctx, buf, buflen, asnstruct, PKIID_CRLDistPointsSyntax, erret));
} /* PKIPackCRLDistPointsSyntax */

size_t PKIUnpackCRLDistPointsSyntax(
    PKICONTEXT *ctx,
    PKICRLDistPointsSyntax **asnstruct,
    const unsigned char *buf,
    size_t buflen,
    int *erret)
{
    size_t bytesused;
    bytesused=PKIUnpackCRLDistPointsSyntaxInternal(ctx, asnstruct, buf, buflen,
                      PKIID_CRLDistPointsSyntax, erret);
    if(*erret==0 && bytesused==0)
        PKIERR(PKIErrUnpackUnderrun);
    return bytesused;
}
