Path: msuinfo!agate!spool.mu.edu!howland.reston.ans.net!vixen.cso.uiuc.edu!qualcomm.com!unix.ka9q.ampr.org!karn
From: karn@unix.ka9q.ampr.org (Phil Karn)
Newsgroups: sci.crypt
Subject: Re: Uniformly distributed random permutations? (Re: RC4: weakness?)
Date: 23 Sep 1994 07:10:07 GMT
Organization: Qualcomm, Inc
Lines: 46
Distribution: world
Message-ID: <35tv0f$8l5@qualcomm.com>
References: <35r3l6$a90@larry.rice.edu> <35st91$n9h@tukki.cc.jyu.fi>
Reply-To: karn@servo.qualcomm.com
NNTP-Posting-Host: unix.ka9q.ampr.org

In article <35st91$n9h@tukki.cc.jyu.fi>, paasivir@network.cc.jyu.fi (Risto Paasivirta) writes:
|> >for (i = 0; i < 255; ++i)
|> >  {
|> >    int r = i + random() % (256-i);
|> >    swap(perm[r], perm[i]);
|> >  }
|> 
|> And does this really generate uniformly distributed random permu-
|> tation? Remainder operation (%) is a poor choice if you need uni-
|> formly distributed random values from range. (And very poor indeed
|> if you use bad random function from C libray.) 

Isn't this a problem only if random()'s range is not much larger than
the range you want? The random() function in BSD has a 31-bit range,
as opposed to some versions of rand() that have only 16 bits of range.

Let's see how you might do it right while avoiding slow floating point
operations.  (I actually have a need for a function like this, so I
might as well write it now.) Say you have a generator that produces
random integers uniformly distributed between 0 and RAND_MAX,
inclusive. If you want a uniformly distributed random number between 0
and n-1 (with n-1 <= RAND_MAX, naturally), use a rejection method like
this:

	k = RAND_MAX - (RAND_MAX + 1) % n;
	do {
		i = random();
	} while(i > k);
	return i % n;

This should take care of the bias that would otherwise be introduced
by the incomplete "tail" at the upper end of random()'s range whenever
n does not evenly divide it.  However, for n << RAND_MAX, (that's "n
much less than RAND_MAX", not "n left shifted by RAND_MAX" :-)) the
chances of having to repeat the loop are minimal, so omitting it would
introduce little bias on the results.

On the other hand, while ignoring the tail might be good enough for a
Monte Carlo simulation, it might not be good enough for cryptography.
Even the smallest detectable statistical anomaly in a cipher is cause
for serious concern, since many have been broken that way.

Phil



