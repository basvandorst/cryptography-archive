Path: msuinfo!uchinews!vixen.cso.uiuc.edu!howland.reston.ans.net!EU.net!uknet!qmw!kaoskat
From: kaoskat@dcs.qmw.ac.uk (franklin)
Newsgroups: sci.crypt
Subject: Re: Steganography for ASCII text files
Date: 9 Sep 1994 17:42:51 GMT
Organization: Queen Mary & Westfield College, London, UK
Lines: 54
Message-ID: <34q6qr$osr@beta.qmw.ac.uk>
References: <1994Sep5.081354.1631@ifi.unizh.ch> <34kjg0$1cl1@tornews.torolab.ibm.com>
NNTP-Posting-Host: it151.dcs.qmw.ac.uk
X-Newsreader: TIN [version 1.2 PL2]

Ameline@provence.torolab.ibm.com wrote:
: (In  the message  below, I'm encoding an average of over 9 bits per line!)
:                                                                          
:    I think  you can get over 8  bits per  line by sending  justified text.
: In order to pad out a line to a  given length (using spaces),  you need to 
: pick which  places to  insert the  extra spaces.  In most lines  there are 
: many  choices  for each  space. The  information  could be encoded in  the 
: position of the spaces.

:    In   this  message, for example,  there   are over 32 bytes of   hidden 
: information!  I'll grant  that it's not  a high   bandwidth communications 
: channel, but  it'll do the job!  If you were  printing text out to a laser
: printer, you would have much finer control  of the inter letter  and inter
: word spacing, and  could encode  surprisingly large amounts of information 
: which, when you  scanned in the  document, could be extracted  without too 
: much   difficulty! This  technique   could  also  be used to place  hidden 
: identifiers  on a document,  so you could track  down the source of a leak.

:    Lets look at how the  algorithm  used for a post  like this would work. 
: To encode, we  have  the desired line  length,  and then   the actual line 
: length. The difference is how many spaces we have to insert between words.
: We  then enumerate  all the  possible  combinations  of where these spaces 
: can go. This can be a fairly small (0), or fairly large number. Who cares!
: round it down to the next lower  power  of two, take the log (base 2), and 
: peel than  many bits  of  your input  data stream. Lets say you peeled off
: 7 bits, and  lets say  (for the sake of simplicity) that these came out to 
: the number 5. You then  use the  fifth of those enumerated combinations of
: where  to put the spaces. Decoding  is left as an exercise  to the reader.
: (You  can limit  the number   of  spaces between  a pair of  words to be a 
: maximum of 3. This, along with  compressing and encrypting the data before
: this encoding, should make the text look "normal".)

IMHO, the text above does not look "normal". I think you need to use only
the "odd" spaces. (e.g. 9 words, total of 21 spaces: 2 spaces/word, with
3 odd spaces left over. Then you only get 9C3=84 combinations, or 6 bits
using truncation). You shouldn't have 3 spaces and single spaces in the
same line.

This gets somewhat "nasty" because I don't see an obvious way of forming
a bijection from the combinations to the data. Storing an enumeration
would work, but is wasteful. 

: P.S.  the input  text  has to start out   with only one space between each 
: word. These are  easy to  strip out, so this is not a problem. Looks  like 
: writing this code should keep me busy for the next weekend!

I started hacking something up today, in response to a different thread,
but I have a report deadline on Wednesday, so I decided to pause for a bit.
It's a cute concept though.

B.t.w. this is *not* a program I particularly want to write, so if something
already exists for PC (source, pref.), I'd appreciate knowing.

Dave
