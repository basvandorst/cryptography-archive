Path: msuinfo!agate!library.ucla.edu!europa.eng.gtefsd.com!MathWorks.Com!news.kei.com!eff!blanket.mitre.org!think.com!hsdndev!news.sesqui.net!rice!dougm
From: dougm@cs.rice.edu (Doug Moore)
Newsgroups: sci.crypt
Subject: RC4: weakness?
Date: 22 Sep 1994 05:11:02 GMT
Organization: Rice University, Houston, Texas
Lines: 43
Message-ID: <35r3l6$a90@larry.rice.edu>
NNTP-Posting-Host: cs.rice.edu
X-Newsreader: TIN [version 1.2 PL2]

I wish to make a minor technical, entirely apolitical, comment on the
code recently posted that may be RSA's RC4.

The essence of that code is a procedure that turns a key into a
"random" permutation, then uses that permutation thereafter in lieu of
the actual key.  To produce the "random" permutation, it mangles the
key string a symbol at a time to produce successive "random" values in
the range 0-255.  The procedure that produces the permutation is
essentially

for (i = 0; i < 256; ++i)
  {
    int r = random() % 256;
    swap(perm[r], perm[i]);
  }

where the value r is really produced as a hash of the key and other
quantities.

Given a uniformly distributed random sequence of r's between 0 and
255, this scheme does NOT produce a uniformly distributed permutation;
some permutations are more likely than others, and the effect is more
severe for larger permutations.

Since the permutations are not equiprobable, a brute force attack can
be designed that tries more likely permutations before less likely
ones.  This should reduce the time for a brute force search by a
factor in the hundreds or more, on average.

I don't suggest that this is a huge weakness, but I marvel that the
code was implemented this way, when a uniformly distributed random
permutation is perfectly easy to generate.

for (i = 0; i < 255; ++i)
  {
    int r = i + random() % (256-i);
    swap(perm[r], perm[i]);
  }

Also, FWIW, RC4 ignores key characters beyond the first 256.

Doug Moore
(dougm@cs.rice.edu)
