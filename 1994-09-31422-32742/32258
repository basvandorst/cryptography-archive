Path: msuinfo!gmi!zombie.ncsc.mil!MathWorks.Com!news2.near.net!news.delphi.com!news.delphi.com!not-for-mail
From: jmkelsey@news.delphi.com (JMKELSEY@DELPHI.COM)
Newsgroups: sci.crypt
Subject: Re: X-shaped addition-based block operations
Date: 21 Sep 1994 00:22:53 -0000
Organization: Delphi Internet Services Corporation
Lines: 28
Message-ID: <35nuct$e7n@news.delphi.com>
References: <Cw2LEM.CEp@dcs.ed.ac.uk>
NNTP-Posting-Host: news.delphi.com

pdc@dcs.ed.ac.uk (Paul Crowley) writes:

>IDEA uses a cunning X-shaped operation to allow the combination of two
>blocks to act on both blocks at once, without destroying the information
>used to make the transformation so that it can be inverted.  It works by
>XORing the left and right halves together, transforming with the key,
>and XORing *both* halves with the result.  When decrypting, this
>operation is self-inverse, since the XOR of the two halves is unchanged
>by XORing them both with the output of the transformation.

>Does anyone pull the same trick with addition?  You could build a
>transformation like this:

   This kind of trick seems to work with any operation that has an inverse--
you could even do it with modular multiplication modulo a prime (the way
IDEA uses multiplication modulo 2**16+1), but it would be computationally
demanding to come up with inverses for each application of a mixing 
operation.
	
   Can anyone think of other operations that have inverses that could be 
used in a practical cipher?  The other ways I can think of to do this 
involve doing something to the block being processed that doesn't change the
results of some operation on the block.  For example, REDOC 2 uses a byte-
addition of the block (as far as I remember) to select how to permute the
bytes in the block--which doesn't change the byte addition.
   	
   --John Kelsey, jmkelsey@delphi.com

