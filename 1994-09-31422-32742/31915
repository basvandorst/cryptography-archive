Path: msuinfo!netnews.upenn.edu!dsinc!newsfeed.pitt.edu!godot.cc.duq.edu!news.duke.edu!convex!darwin.sura.net!opusc!usceast!usceast!not-for-mail
From: suk@usceast.cs.scarolina.edu (Peter Kwangjun Suk)
Newsgroups: sci.crypt
Subject: Stream encryption using true RNGs
Date: 13 Sep 1994 17:31:39 -0400
Organization: University of South Carolina - Columbia - Computer Science
Lines: 65
Message-ID: <3555nr$va@ebony.cs.scarolina.edu>
NNTP-Posting-Host: ebony.cs.scarolina.edu
Summary: Re-use of a random book through block encryption with random keys
Keywords: random numbers stream encryption one time pad

Has this scheme been thought of before?  I'd appreciate comments, criticism,
or pointers to previous research.  I've not encountered anything quite like
this in my reading -- yet.  

	M[i]		i-th block of the plain message

	C[i]		i-th block of the cipher message

	Pad[i]		i-th block of a truly random stream of bits

	E_k(M)		A block encryption algorithm, transforming message
			block M using key k.  The function E_k() should 
			be bijective.  However, it need not be tractably 
			invertible.  

	Ks		The secret key.  Some number of the same width
			as the key for E_k().

	Km		The message key.  A randomly generated number of
			the same width as Ks and the key for E_k().

To use this system, both parties should be in possession of Ks and
Pad[].  All parties also need to be able to generate truly random
numbers.  Now, Alice, to send a message to Bob, would generate a
random Km.  Alice's encrypted message would be Km followed by:

	C[i] = M[i] ^ E_k(Pad[i])    where k = Ks ^ Km

I believe this scheme to be invulnerable to known plaintext attacks.
(Of time or space complexity less than O(2^n)) Knowing the plaintext
for any particular block gives you no information about the plaintext 
of any other block.  

Also note that bit change transmission errors in any block of the
cipher do not garble any other part of the cipher.  Omission and
inclusion of spurious bits in a given block will garble subsequent
blocks.  However, recovery of the subsequent blocks is linear to block
size.

In addition, one could construct E_k() such that E_k() is not
tractably invertible.  As an easy example, one could use a hard
Knapsack as the encryption function to encode Pad[].  (I am uncertain
that this would easily give one a bijective function.  This would also
tend to make the key size uncomfortably large and be too slow for my
taste.)

There are a variety of simple ways to optimize this scheme, such as 
always exhausting Pad[] before transmitting a new message key.  

Comments?  This scheme seems fairly straightforward.  I would be
surprised if someone hasn't already thought of or implemented this.
(I would appreciate information on previous implementations and
analysis.)

--PKS (YACN)

(P.S.  Just in case this scheme hasn't ever appreared before, I've
decided to name it the `Virtual One Time Pad.'  :)

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
       There's neither heaven nor hell -- Save that we grant ourselves.
    There's neither fairness nor justice -- Save what we grant each other.

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Peter Kwangjun Suk  --  suk@usceast.cs.scarolina.edu  --  Musician, Programmer
