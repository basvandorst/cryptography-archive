Newsgroups: sci.crypt
Path: msuinfo!gmi!zombie.ncsc.mil!MathWorks.Com!yeshua.marcam.com!charnel.ecst.csuchico.edu!csusac!csus.edu!netcom.com!mpj
From: mpj@netcom.com (Michael Paul Johnson)
Subject: Re: RC4: weakness?
Message-ID: <mpjCwuInI.FD8@netcom.com>
Organization: NETCOM On-line Communication Services (408 261-4700 guest)
References: <35r3l6$a90@larry.rice.edu>
Date: Wed, 28 Sep 1994 15:21:18 GMT
Lines: 88

>I wish to make a minor technical, entirely apolitical, comment on the
>code recently posted that may be RSA's RC4.

Thank you.

>The essence of that code is a procedure that turns a key into a
>"random" permutation, then uses that permutation thereafter in lieu of
>the actual key.  To produce the "random" permutation, it mangles the
>key string a symbol at a time to produce successive "random" values in
>the range 0-255.  The procedure that produces the permutation is
>essentially

>for (i = 0; i < 256; ++i)
>  {
>    int r = random() % 256;
>    swap(perm[r], perm[i]);
>  }

>where the value r is really produced as a hash of the key and other
>quantities.

>Given a uniformly distributed random sequence of r's between 0 and
>255, this scheme does NOT produce a uniformly distributed permutation;
>some permutations are more likely than others, and the effect is more
>severe for larger permutations.

Why not?  I claim that the permutations obtained this way are pretty 
close to equally probable.  In the case of a 256 byte input key, randomly 
generated with a uniform distribution, then all possible permutations can 
be obtained.  It is true that some permutations can be obtained with more 
than one key, since 2^256 > 256!, but this is not very likely for more 
usual sized keys (5 bytes for exportable applications, 16 for more secure 
applications).

>Since the permutations are not equiprobable, a brute force attack can
>be designed that tries more likely permutations before less likely
>ones.  This should reduce the time for a brute force search by a
>factor in the hundreds or more, on average.

How, within computationally feasible limits, do you figure out which 
permutations are more likely?  Where do you get a factor of hundreds?
I estimated that the probability of "spare keys" for 16 byte keys was a 
bit lower than winning the Colorado Lottery with one ticket purchase.

>I don't suggest that this is a huge weakness, but I marvel that the
>code was implemented this way, when a uniformly distributed random
>permutation is perfectly easy to generate.

>for (i = 0; i < 255; ++i)
>  {
>    int r = i + random() % (256-i);
>    swap(perm[r], perm[i]);
>  }

Hmmm... This avoids the problem of having a swap undo a previous swap, 
but it adds the problem that if random() is uniformly distributed, then 
random() % x is biased towards the lower numbers of the possible range.  
Over all, I think your proposed method adds more overall bias, although 
neither method is perfect.

One more uniform method of obtaining a uniform distribution between 
limits is to throw out out of range values, but this is not much 
different than allowing swaps that undo each other.

>Also, FWIW, RC4 ignores key characters beyond the first 256.

About US$0.02, I suppose...  If your pass phrase is that long, you should 
hash it with SHA or MD5, first.  There really isn't much sense in using 
keys longer than about 16 bytes, anyway, provided that they are randomly 
generated.  NIST and NSA endorse 10 bytes as being good enough to resist 
brute force attack (the key size of Skipjack).

More significant, to my way of thinking, is that with a variable length 
key algorithm, I like the length of the key itself to be part of the key, 
so that the key "aaaaa" is not the same as "aaaaaaaaaa".  This is not the 
case with alledged RC-4, but you could doctor the key you send it by 
appending the length of the key to the end of the key.

Peace to you.
                  ___________________________________________________________
                 |                                                           |
 |\  /| |        | Michael Paul Johnson  Colorado Catacombs BBS 303-772-1062 |
 | \/ |o|        | PO Box 1151, Longmont CO 80502-1151 USA   Jesus is alive! |
 |    | | /  _   | mpj@csn.org aka mpj@netcom.com m.p.johnson@ieee.org       |
 |    |||/  /_\  | ftp://ftp.csn.net/mpj/README.MPJ          CIS: 71331,2332 |
 |    |||\  (    | ftp://ftp.netcom.com/pub/mpj/README.MPJ  -. --- ----- ....|
 |    ||| \ \_/  | PGPprint=F2 5E A1 C1 A6 CF EF 71  12 1F 91 92 6A ED AE A9 |
                 |___________________________________________________________|
