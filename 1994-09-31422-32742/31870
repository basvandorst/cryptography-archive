Path: msuinfo!netnews.upenn.edu!dsinc!spool.mu.edu!howland.reston.ans.net!swrinde!cs.utexas.edu!uunet!zib-berlin.de!gs.dfn.de!tubsibr!eis.cs.tu-bs.de!telkamp
From: telkamp@eis.cs.tu-bs.de (Gerrit Telkamp)
Newsgroups: sci.crypt
Subject: Checksum in phonecards - hard nut
Date: 12 Sep 1994 19:34:55 GMT
Organization: TU Braunschweig,Informatik,EIS,West Germany
Lines: 73
Distribution: world
Message-ID: <352agv$43l@ra.ibr.cs.tu-bs.de>
NNTP-Posting-Host: ss2.eis.cs.tu-bs.de
Keywords: phonecards, checksum

Hello everyone,

a norwegian friend of mine collects phonecards. He owns really a lot of
them. Now we tried to read the contents of the chips in these cards
(ST-1000-EPROM-chip).

The EPROM-chip can be read out serially. The first 96 bits are the issuer
area and can only be written in factory. The next 160 bits is the memory for
the units : Everytime one unit is used, one bit will be burned.

But why i'm posting this in sci.crypt ? The issuer area contains a checksum,
some constant code which identifies the card as a norwegian phonecard, a
continous chip-number and - a secret 16-bit code. We did not found out
the dependecie of this code the the other 80 bits. Perheaps this is a
second checksum ? I will not beleive that these codes are generated 
randomly. We had two _identical_ cards with identical serial-numbers
(a mistake from the manufactor), and the "secret codes" were identical.
If this is a checksum, how works the arlogithm to generate the sum ? 
It seems to be a really "hard nut".
I'm not very familar with cryptology. But perheaps a crypto-professional
can see the meaning (or dependency) of the secret codes "with one eye".
Or is ther a chance to "crack" the code with tools ? Perheaps it can be done with "genetic programming" ?

Here are the codes of some _consecutively_ phone-cards with 70 units :
(all codes are in hexadecimal format)

Check Phone The card   serial  ?????  Norwegian
sum   card  has unused chip    secret phone
      code  70 units   number  code   card
[0]   [1]   [2-4]      [5-7]   [8-9]  [10-11]
----- ----- ---------- ------- ------ ---------
BC    83    107000     01081F  93F5   1130
C4    83    107000     010820  4E84   1130
BF    83    107000     010821  3B90   1130
C1    83    107000     010822  C3CA   1130
C4    83    107000     010823  00C6   1130
C3    83    107000     010824  0EB0   1130
C1    83    107000     010825  48CB   1130
C4    83    107000     010826  0550   1130
 
C0    83    107000     011344  B710   1130
C0    83    107000     011345  50B2   1130
BE    83    107000     011346  A07D   1130
BB    83    107000     011347  7C6E   1130
BE    83    107000     011348  979A   1130
C1    83    107000     011349  842A   1130
BC    83    107000     01134A  9B97   1130

BF    83    107000     012395  4349   1130
BB    83    107000     012396  7E9C   1130
BD    83    107000     012397  2AA6   1130
BC    83    107000     012398  5E75   1130
BB    83    107000     012399  DD0F   1130
BD    83    107000     01239A  05E7   1130
BF    83    107000     01239B  E048   1130
C0    83    107000     01239C  6308   1130
BD    83    107000     01239D  2CC6   1130
BA    83    107000     01239E  F572   1130
BD    83    107000     01239F  A851   1130
BB    83    107000     0123A0  BEEB   1130
C1    83    107000     0123A1  1232   1130
C1    83    107000     0123A2  9481   1130


The checksum was not too hard : it is 216-sum of all _bits_ in byte [1-11],
e.g. $83 = %10000011; the sum is 3 (3 bits).

Any ideas ?
I can send more codes if needed !

Gerrit.
-----------------------
telkamp@eis.cs.tu-bs.de
