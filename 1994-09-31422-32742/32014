Path: msuinfo!agate!howland.reston.ans.net!math.ohio-state.edu!sdd.hp.com!svc.portal.com!shell.portal.com!hfinney
From: hfinney@shell.portal.com (Hal)
Newsgroups: sci.crypt
Subject: Re: RC4 ?
Date: 16 Sep 1994 15:48:56 GMT
Organization: Portal Communications (shell)
Lines: 37
Message-ID: <35cep8$svj@news1.shell>
References: <35aeij$kdc@news1.shell>
NNTP-Posting-Host: jobe.shell.portal.com

Another thing I had noticed about the RC4 listing is a curiosity in the
key setup.  Using Bob Jenkins' notation, the algorithm is:

for (i=0; i<SIZE; ++i)
  m[i] = i;
for (i=0; i<SIZE; ++i) {
  x = m[i];
  a = (x+a+k[i])&MASK;
  y = m[a];
  m[i]=y; m[a]=x;
}

This generates a random permutation of 0..MASK based on the key vector k.
But the interesting thing is that this is very similar to the naive and
incorrect algorithm for generating a random permutation:

for (i=0; i<SIZE; ++i)
  m[i] = i;
for (i=0; i<SIZE; ++i) {
  x = m[i];
  a = random(MASK+1);  /* Generate a random number from 0..MASK */
  y = m[a];
  m[i]=y; m[a]=x;
}

The correct algorithm uses "a = random(i+1)".  So this suggests that the
permutation created by the RC4 key setup is somewhat biased.

There may be good cryptographic reasons for the setup that is used.  It
is also slightly faster since no divides are needed.  One of the results
though is that it may mix up the state array m a little less than would
be ideal.  In particular, m[0] will be equal to k[0] about 1/e of the
time, because it will get swapped just the one time.  It's not clear how
to exploit this, though.

Hal

