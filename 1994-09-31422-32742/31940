Path: msuinfo!netnews.upenn.edu!dsinc!spool.mu.edu!howland.reston.ans.net!europa.eng.gtefsd.com!news.umbc.edu!olson
From: olson@umbc.edu (Bryan G. Olson; CMSC (G))
Newsgroups: sci.crypt
Subject: Re: ** Help me Montgomery ? **
Date: 14 Sep 1994 18:01:46 GMT
Organization: University of Maryland, Baltimore County
Lines: 135
Message-ID: <357dqa$iq@news.umbc.edu>
References: <35700h$nbe@lucy.ee.und.ac.za>
NNTP-Posting-Host: umbc7.umbc.edu
X-Newsreader: TIN [version 1.2 PL2]

Jyri Hamalainen (cat@olddaisy.ee.und.ac.za) wrote:

: Could someone explain the basic logic of  
: "Montgomery modular multiplication without trial division",
: method in hardware/ software applications.

Peter Montgomery himself sometimes posts to this group, but
I'll give an introduction to Montgomery multiplication which
may be a bit easier for computer types to follow than his
paper:

   Montgomery, Peter L, "Modular Multiplication Without 
   Trial Division", _Mathematics of Computation_, Vol 44 
   #170, April 1995, pp 519-521.

To use Montgomery multiplication mod N, we define an alternate
representation of the integers (0,1,2,...N-1) We translate normal
integers to Montgomery representation, do our multiplications with
this new representation, then translate back to the normal
representation.

When computing an exponent mod N, we don't translate back to normal
representation between multiplications; we just leave the results in
Montgomery representation until all the multiplications are done.

To avoid confusion between "mod" as an operation and as notation of
equivalence classes, I'll use "x=y mod n" to mean that x is the least
residue of y mod n, and "x==y mod n" to mean that x is congruent mod n
to y.

To form the Montgomery representation, we choose some R which is
greater than N and relatively prime to N, and we want division by R to
be inexpensive.  In crypto work our modulus N usually has no small
factors, so we can choose R to be some power of 2 a little bigger than
N.  Division by any power of two is easy, since we just chop off low
order bits.

Now to represent the integers in 0..N-1, we use the Montgomery
representation

      M(x) = xR mod N

To convert from Montgomery representation to normal representation, we
find the inverse of R mod N under multiplication mod N.  I'll call it
R'. (Actually there are infinitely many inverses; I want the least
residue). Then the inverse of M(x) is

     M'(x) = xR' mod N

Since R and N are relatively prime, these functions are one to one on
{ 0,1,2,...N-1 }.  All these integers have a unique representation.

Now we find N' such that 
     0 < N' <R
and RR' - NN' = 1.

That is R' is the inverse of R under multiplication mod N, and N - N'
is the inverse of N under multiplication mod R.

Montgomery defined the procedure REDC(x) which has two uses.  The
first is to compute M'(x).  That is, it computes the normal
representation of an integer, given the Montgomery representation.

function REDC(x)             (1)
  m = (x mod R) * N' mod R   (2)
  t = (x + m*N) / R          (3)
  if t < N                   (4)
    return t                 (5)
    else return N - t        (6)

Montgomery then shows REDC is correct.  First he notes that in line 3,
we need x+mN to be divisible by R.

   mN = ((x mod R)N' mod R) N == x NN' mod R == -x mod R
   x + nM == x + -x mod R == 0 mod R

Thus R divides x+mN.  Next he notes

    x+mN == x mod N      (since it's x plus a multiple of N),  
so    tR == x mod N      (since t=(x+mN)/R )
       t == x R' mod N   (multiplying both sides by R')

Thus t is congruent mod N to the desired result.  Next, he shows that
if x < RN, then t<2N, so either t or t-N is the answer.

          m < R
     x + mN < RN + RN
   (x+mN)/R < 2N

Thus REDC(x) returns xR' mod N given 0 <= x < RN.

Note that the procedure REDC divides only by R, so all divisions can
be done by shifting out low order bits.  The time consuming part of
REDC is the two multiplications.

Now we need to look at how to multiply two integers which are in
Montgomery representation, to get an answer in Montgomery
representation.  Suppose our ordinary integers are x and y, so their
Montgomery representations are xR mod N, and yR mod N.

That is, we have, 
     xR mod N,  yR mod N
and we want,
     xyR mod N.


Since R' is the mod N inverse of R,

   xyR mod N = xRyR R' mod N = (xR mod N)(yR mod N) * R' mod N

So if we take the ordinary product of the representations, 
(xR modN)(yR mod N), and run it through REDC, we get

  REDC( (xR mod N)(yR mod N) ) = xyR mod N.

Since (xR mod N) and (yR mod N) are both less than N, their product is
less than NN which is less than RN, so it forms a legal input for
REDC.

Thus to multiply mod N, two numbers in Montgomery representation to
get an answer also in Montgomery form, we can use:

MontyMult( x, y )
  return REDC( x*y )

So to do modular exponentiation, we convert the base to the Montgomery
representation where N is the modulus, do the multiplications with
MontyMult, and convert the result back to our normal representation.
Montgomery multiplication lets avoid a division at the expense of two
multiplications (and there are some optimizations which seem to do
even better), which is usually a worthwhile trade.  Of course we also
have the overhead of the initial and final conversions to and from
Montgomery representation.

--Bryan
