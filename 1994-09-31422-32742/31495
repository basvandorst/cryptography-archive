Path: msuinfo!agate!spool.mu.edu!heifetz.msen.com!zib-berlin.de!news.rrz.uni-hamburg.de!rzdspc5.informatik.uni-hamburg.de!3moeller
From: 3moeller@rzdspc5.informatik.uni-hamburg.de (Bodo Moeller)
Newsgroups: sci.crypt
Subject: Re: What if gcd(x,n)!=1 in RSA?
Date: 1 Sep 94 14:21:36 GMT
Organization: University of Hamburg -- Germany
Lines: 73
Message-ID: <344osu$bc2@rzsun02.rrz.uni-hamburg.de>
References: <48BC0724D@iisnw.iis.nsk.su> <342u6c$ns5@news.umbc.edu>
NNTP-Posting-Host: rzdspc5.informatik.uni-hamburg.de

olson@umbc.edu (Bryan G. Olson; CMSC (G)) writes:

[...]
>:     In the RSA cryptosystem x is the plaintext and n is the key
>: modulus, being a multiple of two primes p and q.

>:     My question is: what if x accidentally becomes NOT relatively
>: prime with n? Would the system work? Maybe if would be easy to find
>: the value of x?

>Yes, it would work; x^(d*e) mod n = x even if x is not relatively
>prime to n, although finding such an x is at least as hard as
>breaking RSA.  ( I've been told the first version of the
>RSA paper did not consider this case. )
[...]
>Theorem (RS&A): for all x in 0<=x<n, 
>     x^(d*e) mod n = x, 
>where n=p*q with p and q prime, and d*e = k(p-1)(q-1)+1 for some
>positive integer k.

Actually, it is not necessary that d*e = k(p-1)(q-1) + 1.
What is needed is

    d*e mod p-1 = 1
and d*e mod q-1 = 1,

and these equations hold when

    d*e = k*lcm(p-1,q-1) + 1
        = k*(p-1)*(q-1)/gcd(p-1,q-1) + 1

for some integer k. Then, because gcd(p-1,q-1) is a divisor of both
p-1 and q-1, we have

    d*e = (p-1)*A + 1
and d*e = (q-1)*B + 1

with integers A and B, and your proof can be changed to the following:

[...]>Thus:
> 
>   x^(e*d) mod p = (x mod p)^(e*d) mod p 
                  = (x mod p)^((p-1)*A + 1) mod p
                  = ((x mod p)^(p-1))^A * x mod p
                  = 1^A * x mod p 
>                 = x mod p

>   x^(e*d) mod q = (x mod q)^(e*d) mod q
                  = (x mod q)^((q-1)*B + 1) mod q
                  = ((x mod q)^(q-1))^B * x mod q
                  = 1^B * x mod q 
>                 = x mod q

>Note the third step is justified since p can not divide x mod p unless
>p is zero, and likewise for q.

>By the Chinese remainder theorem, since p and q are relatively prime,
>for any 0<=i<p and 0<=j<q, there is exactly one integer m with
>0<=m<n=pq such that m mod p = i and m mod q = j.

>And since:

>   (x^(e*d) mod n) mod p = x mod p
>   (x^(e*d) mod n) mod q = x mod q

>It must be the case that x^(e*d) mod n = x.

>:     I understand that due to the choice of n=pq the probability of x
>: being not relatively prime with n is pretty low. Maybe it is low
>: enough to be ignored completely?

>While RSA still works if x is not relatively prime to n, finding such
>an x would factor n, since gcd(x,n) would be a factor.
