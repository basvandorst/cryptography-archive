Path: msuinfo!agate!darkstar.UCSC.EDU!news.hal.COM!olivea!charnel.ecst.csuchico.edu!yeshua.marcam.com!MathWorks.Com!zombie.ncsc.mil!cs.umd.edu!news.umbc.edu!olson
From: olson@umbc.edu (Bryan G. Olson; CMSC (G))
Newsgroups: sci.crypt
Subject: Re: What if gcd(x,n)!=1 in RSA?
Date: 31 Aug 1994 21:54:20 GMT
Organization: University of Maryland, Baltimore County
Lines: 74
Distribution: world
Message-ID: <342u6c$ns5@news.umbc.edu>
References: <48BC0724D@iisnw.iis.nsk.su>
NNTP-Posting-Host: umbc7.umbc.edu
X-Newsreader: TIN [version 1.2 PL2]

QUZM@iisnw.iis.nsk.su wrote:
:     As far as I know, the whole RSA cryptosystem is based on the
: Euler's theorem that for each x and a which are relatively prime
: (i.e. gcd(x,a)=1)

:         x^phi(n)=1 (mod n)   , where phi is the Euler's function

:     In the RSA cryptosystem x is the plaintext and n is the key
: modulus, being a multiple of two primes p and q.

:     My question is: what if x accidentally becomes NOT relatively
: prime with n? Would the system work? Maybe if would be easy to find
: the value of x?

Yes, it would work; x^(d*e) mod n = x even if x is not relatively
prime to n, although finding such an x is at least as hard as
breaking RSA.  ( I've been told the first version of the
RSA paper did not consider this case. )

The usual proof considers x mod p and x mod q separately, and use the
Chinese remainder theorem.

Theorem (RS&A): for all x in 0<=x<n, 
     x^(d*e) mod n = x, 
where n=p*q with p and q prime, and d*e = k(p-1)(q-1)+1 for some
positive integer k.

I'm adopting the computer scientists convention that mod is an
operator, rather than a description of equivalence classes.

Simple rules of modular arithmetic say for any non-neg integer 
exponent a,

    (x^a mod n) mod p = (x mod p)^a mod p
and
    (x^a mod n) mod q = (x mod p)^a mod q


RSA requires e*d = k(p-1)(q-1) + 1 for some integer k.  Thus:
 
   x^(e*d) mod p = (x mod p)^(e*d) mod p 
                 = (x mod p ^(p-1))^(k(q-1)) * x  mod p 
                 = 1^(k(p-1)) * x mod p 
                 = x mod p

   x^(e*d) mod q = (x mod q)^(e*d) mod q 
                 = (x^ mod q ^(q-1))^(k(p-1)) * x  mod q 
                 = 1^(k(q-1)) * x mod q 
                 = x mod q

Note the third step is justified since p can not divide x mod p unless
p is zero, and likewise for q.

By the Chinese remainder theorem, since p and q are relatively prime,
for any 0<=i<p and 0<=j<q, there is exactly one integer m with
0<=m<n=pq such that m mod p = i and m mod q = j.

And since:

   (x^(e*d) mod n) mod p = x mod p
   (x^(e*d) mod n) mod q = x mod q

It must be the case that x^(e*d) mod n = x.


:     I understand that due to the choice of n=pq the probability of x
: being not relatively prime with n is pretty low. Maybe it is low
: enough to be ignored completely?

While RSA still works if x is not relatively prime to n, finding such
an x would factor n, since gcd(x,n) would be a factor.

--Bryan

