Newsgroups: sci.crypt
Path: msuinfo!agate!overload.lbl.gov!lll-winken.llnl.gov!enews.sgi.com!decwrl!netcomsv!netcom.com!ppearson
From: ppearson@netcom.com (PKJS Pearson family)
Subject: Re: Speedups in posted RC4 code
Message-ID: <ppearsonCwDxK1.9Hq@netcom.com>
Keywords: RC4, swapping
Organization: NETCOM On-line Communication Services (408 261-4700 guest)
References: <35c4aa$l17@bcarh8ab.bnr.ca> <35daff$jvb@news.delphi.com> <jonadamsCwDKFK.s5@netcom.com> <jonadamsCwDLFv.1MK@netcom.com>
Date: Mon, 19 Sep 1994 16:24:00 GMT
Lines: 29

In article <jonadamsCwDLFv.1MK@netcom.com>,
Jonathan Adams <jonadams@netcom.com> wrote:
>Jonathan Adams (jonadams@netcom.com) wrote:
>: JMKELSEY@DELPHI.COM (jmkelsey@news.delphi.com) wrote:
>: : Be careful not to replace the swap with a swap macro that won't deal well
>: : with swapping a byte with itself.  About 1/256 of the swapping is done
>: : with x and y equal, thus 	
>: : #define SWAP(x,y) {x^=y;y^=x;x^=y;} 
>: : winds up giving you an internal state full of zeros.
>: No, it doesn't. Try the following C code:
>
>Here's a better thing: a proof that the above macro works:
>
>start with: x = a, y = b
>
>x ^= y		x = a^b, y = b
>y ^= x		x = a^b, y = a
>x ^= y		x = b, y = a
>
>Thus, it works for any numbers x and y.

True, but irrrelevant. The original concern was that 1/256 of the
time, RC4 would evaluate SWAP(x,x). If you consider the case, in the
above code, where x and y are the same variable, you see that the
initial exclusive OR (^=) produces a zero value from which the
original values cannot be recovered. (Is it possible you're confusing
functions with macros? Your argument is valid, for a function.)

- Peter
