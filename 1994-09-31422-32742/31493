Path: msuinfo!agate!spool.mu.edu!umn.edu!newsdist.tc.umn.edu!urvile.msus.edu!msus1.msus.edu!solar!mmorgan
Newsgroups: sci.crypt
Subject: More on Blowfish (was Re: Blowfish, speed, speed, speed.)
Message-ID: <1994Aug31.232336.1666@msus1.msus.edu>
From: mmorgan@solar.ee.stcloud.msus.edu(Michael S. Morgan)
Date: 31 Aug 94 23:23:36 -0500
Reply-To: mmorgan@solar.ee.stcloud.msus.edu
Sender: mmorgan@solar (Michael S. Morgan)
References: <1994Aug30.002309.1637@msus1.msus.edu> <340ehc$es0@news.umbc.edu>
Distribution: world
Organization: St. Cloud State University, EE Department
Nntp-Posting-Host: solar.ee.stcloud.msus.edu
Lines: 80

Note:  I had formally stated that I used 18 rounds, which
was incorrect.  I used 16 rounds.

For my c++ implementation of the blowfish encryption
algorithm, (algorithm invented by Bruce Schneir), I
have created a table.  See figure 1.  The columns 
are for the various computers I tested, and the rows
are for the various methods.  


	c0	c1	c2	c3	c4	c5
m0	2.9	94.2	163.4	198.2	198.7	298.1
m1	3.7	108.3	209.9	222.5	222.5	332.7
m2	4.8	145.6	278.1	306.7	3.6.7	460.1


Figure 1:  Benchmark for c++ blowfish on various platforms.
           All data are in Kbytes/second.

m0:  A generalized version of the blowfish algorithm.  It
is generalized in the sense that the caller of the functions
can define at run time the number of rounds used during 
encryption.  For this test, the number of rounds was defined
at run time to be the stanard number, 16.  A block of data
4096 bytes long, assumed only to be byte alligned, is 
repeadedly encrypted, 1024 times, for a total throughput
of 4Mbytes.  

m1:  An unravelled version of the blowfish algorithm.  (16 
rounds).  A block of data 4096 bytes long, assumed only to 
be byte alligned, is repeadedly encrypted, 1024 times, for 
a total throughput of 4Mbytes.  

m2:   An unravelled version of the blowfish algorithm.  (16 
rounds).  Two unsigned longs are repeatedly encrypted, 
eliminating the overhead of (long *) alligning the data,
as was necessary in m0 and m1.

Figure 2:  Row heading key.  

c0:  An old 8088.  640k ram, ran out of a ram drive.

c1:  Gateway 486DX2 50V

c2:  Dell 4100MT  486 DX4 100MHz

c3:  Packard Bell 5200, Pentium 60MHz

c4:  Packard Bell 100CD Pentium 60MHz

c5:  Packard Bell 110CDT Pentium 90MHz



Figure 3:  Column Heading key.

Compiler Notes:  The code was written in c++, with constructors to
initialize the subkey data, and destructors to wipe the subkey
data.  The code was compiled with Borland 3.0, using the 80286
code generation option, except for the c0 model, which used the
8086 code generation option.

I am sure assembly, and straight c would be faster, but I was
trying to write a re-usable module that did not require the
user to remember to delete the subkey data.

I will make the code available to all U.S resident, U.S. Citizens
who ask, especially if they send me some leads on jobs, or ask
nicely. (Electrical engineering/digital hardware design/
software engineering.)

-- 
-------------------------------------------------------------------+
Michael S. Morgan      | Not since prohibition have Alcohol        |
    User ID:  A25C69C5 | dealers settled their disputes with guns. |
Fingerprint:  1560FD25 |                                           |
              431D1014 | Why are they trying to ban milita rifles? |
              3EEAE3C3 |                                           |
              F9CDB465 | John Galt lives.                          |
-------------------------------------------------------------------+
