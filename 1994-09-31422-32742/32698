Path: msuinfo!uchinews!vixen.cso.uiuc.edu!sdd.hp.com!svc.portal.com!shell.portal.com!hfinney
From: hfinney@shell.portal.com (Hal)
Newsgroups: sci.crypt
Subject: Re: RC4: weakness?
Date: 29 Sep 1994 04:39:46 GMT
Organization: Portal Communications (shell)
Lines: 58
Message-ID: <36dgei$oag@news1.shell>
References: <35r3l6$a90@larry.rice.edu> <mpjCwuInI.FD8@netcom.com>
NNTP-Posting-Host: jobe.shell.portal.com

mpj@netcom.com (Michael Paul Johnson) writes, quoting larry.rice.edu:

>>Given a uniformly distributed random sequence of r's between 0 and
>>255, this scheme does NOT produce a uniformly distributed permutation;
>>some permutations are more likely than others, and the effect is more
>>severe for larger permutations.

>Why not?  I claim that the permutations obtained this way are pretty 
>close to equally probable.  In the case of a 256 byte input key, randomly 
>generated with a uniform distribution, then all possible permutations can 
>be obtained.  It is true that some permutations can be obtained with more 
>than one key, since 2^256 > 256!, but this is not very likely for more 
>usual sized keys (5 bytes for exportable applications, 16 for more secure 
>applications).

This was discussed here a week or two ago.  I pointed out that state[0]
has about a 1/e chance of being left equal to key[0] due to the strange
key setup.  Basically, it gets swapped with key[0] on the first swap, and
there is a 1/e chance that it will never get swapped again.  Similarly,
state[1] has about a 1/e chance of being equal to 1+key[0]+key[1].  Granted,
if key[i] is randomly distributed this does not mean much.  But if you
had a simpler implementation where key[] was guessable then this might
help you narrow down the state array possibilities.

>>I don't suggest that this is a huge weakness, but I marvel that the
>>code was implemented this way, when a uniformly distributed random
>>permutation is perfectly easy to generate.

>>for (i = 0; i < 255; ++i)
>>  {
>>    int r = i + random() % (256-i);
>>    swap(perm[r], perm[i]);
>>  }

I permute using a variation on this:
for (i=1; i<256; ++i) {
  int r = random() % (i+1);
  swap(perm[r], perm[i]);
}

(After each iteration the first i elements of the array are a random
permutation of 0..i-1, easily shown.)

So I would propose for the key setup something like

for (x=1; x<256; ++x) {
  y = (y + state[x] + key[j++]) % (x+1);
  swap(state[x], state[y]);
}
  
This way y is always in 0..x and we get closer to an ideal permutation,
I think.  You still have that state[x] + key[j] is not uniformly distributed
mod x+1, though.  It was also proposed that if you used key bytes in pairs
as a number in the range 0..65535 then you would be closer to uniform
distribution.

Hal Finney
hfinney@shell.portal.com
