Newsgroups: sci.math,sci.crypt
Path: msuinfo!gmi!zombie.ncsc.mil!MathWorks.Com!europa.eng.gtefsd.com!howland.reston.ans.net!cs.utexas.edu!uunet!newsflash.concordia.ca!CC.UMontreal.CA!IRO.UMontreal.CA!clouso.crim.ca!athena.ulaval.ca!fermat!dbernier
From: dbernier@fermat.ulaval.ca (David Bernier)
Subject: outline of encryption system (was Re: some questions on finite groups)
Message-ID: <CwFr2G.J7z@athena.ulaval.ca>
Sender: news@athena.ulaval.ca
Nntp-Posting-Host: fermat.mat.ulaval.ca
Organization: Universite Laval, Ste-Foy (Quebec), Canada
References: <Cw17oI.GHu@athena.ulaval.ca> <1994Sep16.125748.7628@dcs.warwick.ac.uk>
Date: Tue, 20 Sep 1994 15:59:03 GMT
Lines: 81
Xref: msuinfo sci.math:80893 sci.crypt:32264

[[		   OUTLINE OF ENCRYPTION SYSTEM
		   ============================

I would like to give in outline an encryption system based on group
actions on F_{2^n} , the (finite) Galois field with 2^n elements,
where n>=3 . We assume the reader is familiar with these fields.
These are described in many basic books on abstract algebra.

NOTATION:   We use GL(n,2) to denote the group of invertible n x n
	    matrices over the field F_2 . For m>1 , G(m) will denote
	    the multiplicative group modulo m, i.e. the set of
	    equivalence classes modulo m that have a multiplicative
	    inverse with multiplication as the group operation. For
	    example, G(10) = {[1], [3], [7], [9]} .

Consider the following group actions on F_{2^n} :

(a) F_{2^n} acts on itself by addition as follows :
	    let y be an element of F_{2^n}. Then we get the map
	    x -> x+y  from F_{2^n} to F_{2^n}  .

(b) GL(n,2) acts on F_{2^n} by matrix multiplication (once a basis
    for F_{2^n} over F_2 is chosen) :
    if M \in GL(n,2),	x -> Mx  gives a permutation on F_{2^n} .

(c) G(2^n -1) acts on F_{2^n} as follows:
    if [k] \in G(2^n -1) where 0<k< 2^n , then the map
	    x -> x^k   is bijective from F_{2^n} to itself.
    (note: the map given by x -> x^{-1} if x non-zero and 0 -> 0
    is the same as the map  x -> x^k  for k=2^n -2 . )

Then the maps described in (a), (b) and (c) are all permutations on
F_{2^n} , and any composition of such maps is still a permutation.
Derek Holt has shown that the group generated by (a), (b) and (c) is
in fact S_{2^n} . In other words, any permutation on F_{2^n} can be
written as a composition of permutations of the types given in (a),
(b) and (c) above . We have |S_{2^n}|= (2^n)! , which grows fast with
n. This could lead to a practical secret key encryption system. The
key is simply [in practice, a bit-string representation of] the
sequence of maps from (a) , (b) and (c) .

The operations of type (a) are easy to program efficiently. The
matrix multiplications in (b) take longer, but the computations can
be done in parallel. The exponentiations in (c) are probably the most
time-consuming. The procedure known as "exponentiation by repeated
squaring and multiplication" can be used to carry out these
exponentiations efficiently. In practice, multiplication in F_{2^n}
involves multiplying two polynomials of degree<n and taking the
remainder upon dividing by some irreducible polynomial f . One can
take n to be a power of 2 where n>=8 . If so, then , according to an
exercise in T.W. Hungerford's book _Algebra_ (in Section V.5), the
polynomial  x^n + x + 1  is irreducible over F_2 . A simple way of
representing a key as a string of bits is as follows:
(a) We represent an element of F_{2^n} by an n-bit string .
(b) We represent an element of GL(n,2) by an (n^2)-bit string .
(c) We represent an integer k such that 0<k<2^n by an n-bit string,
    i.e. the binary numeral for k with as many initial 0's as needed.
We can then represent a key by concatenating the bit-strings defined
above (assume we have j strings) , and adding in front of it j
2-bit blocks where we use the code
	    00 means type (a) operation
	    01 means type (b) operation and
	    10 means type (c) operation
If the value of n is known, then it is easy to see that any
bit-string of this type encodes at most one key.
If n=64 , as in the DES, then for each of the (2^64)! permutations,
there exists some key (oo many) that gives this permutation.
(2^64)! is "roughly"  2^(2^69.9) .

references: articles <Cw17oI.GHu@athena.ulaval.ca> and
	    <1994Sep16.125748.7628@dcs.warwick.ac.uk>  in sci.math  .

   Copyright (c) 1994 by David Bernier
   Any non-commercial use of the foregoing material by any entity is
   allowed by the author. ANY COMMERCIAL USE of the foregoing
   material by any entity IS PROHIBITED by the author .      ]]

If anyone is interested in implementing this encryption system, or
if anyone has any comments, I'd be glad to hear about it.

   David Bernier      (dbernier@mat.ulaval.ca)
