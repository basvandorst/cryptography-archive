Path: msuinfo!agate!howland.reston.ans.net!pipex!derwent.co.uk!not-for-mail
From: tim@morgoth.derwent.co.uk. (Tim Morley)
Newsgroups: sci.crypt
Subject: Re: Speedups in posted RC4 code
Date: 19 Sep 1994 14:06:37 +0100
Organization: Derwent Publications.
Lines: 38
Message-ID: <35k2ct$nlp@morgoth.derwent.co.uk>
References: <35c4aa$l17@bcarh8ab.bnr.ca> <35daff$jvb@news.delphi.com> <jonadamsCwDKFK.s5@netcom.com> <jonadamsCwDLFv.1MK@netcom.com>
NNTP-Posting-Host: morgoth.derwent.co.uk

In article <jonadamsCwDLFv.1MK@netcom.com>,
Jonathan Adams <jonadams@netcom.com> wrote:
>Jonathan Adams (jonadams@netcom.com) wrote:
>: JMKELSEY@DELPHI.COM (jmkelsey@news.delphi.com) wrote:
>
>: : Be careful not to replace the swap with a swap macro that won't deal well
>: : with swapping a byte with itself.  About 1/256 of the swapping is done
>: : with x and y equal, thus 	
>: :  
>: : #define SWAP(x,y) {x^=y;y^=x;x^=y;} 
>
>: : winds up giving you an internal state full of zeros.
>: No, it doesn't. Try the following C code:
>
>:[snip out source code]
>
>Here's a better thing: a proof that the above macro works:
>
>start with: x = a, y = b
>
>x ^= y		x = a^b, y = b
>y ^= x		x = a^b, y = a
>x ^= y		x = b, y = a
>
>Thus, it works for any numbers x and y.
>

Try it again if you are doing x=a and y=a.

x ^= y          x=0, y=0
y ^= x          x=0, y=0
x ^= y          x=0, y=0

The case where there is a problem is not when the _VALUES_ of x and y
are equal, but when x and y are the same thing eg
SWAP(array[10],array[10]). 

Tim M
