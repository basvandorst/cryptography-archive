Path: msuinfo!netnews.upenn.edu!dsinc!spool.mu.edu!agate!soda.CSUA.Berkeley.EDU!remailer
From: Peter Kwangjun Suk <suk@CS.Scarolina.EDU>
Newsgroups: sci.crypt
Subject: Re: Stream encryption using true RNGs
Date: 14 Sep 1994 21:34:08 GMT
Organization: none
Lines: 99
Distribution: world
Message-ID: <357q8g$3dj@agate.berkeley.edu>
NNTP-Posting-Host: soda.csua.berkeley.edu
Originator: remailer@soda.CSUA.Berkeley.EDU


Jim Gillogly <jim@acm.org> writes:

>In article <3555nr$va@ebony.cs.scarolina.edu>,
>Peter Kwangjun Suk <suk@usceast.cs.scarolina.edu> wrote:
>>Has this scheme been thought of before?  I'd appreciate comments, criticism,
>>	M[i]		i-th block of the plain message
>>	C[i]		i-th block of the cipher message
>>	Pad[i]		i-th block of a truly random stream of bits
>>	E_k(M)		A block encryption algorithm, transforming message
>>	Ks		The secret key.  Some number of the same width
>>	Km		The message key.  A randomly generated number of
>>
>>To use this system, both parties should be in possession of Ks and
>>Pad[].  All parties also need to be able to generate truly random
>>numbers.  Now, Alice, to send a message to Bob, would generate a
>>random Km.  Alice's encrypted message would be Km followed by:
>>
>>	C[i] = M[i] ^ E_k(Pad[i])    where k = Ks ^ Km
>>
>>I believe this scheme to be invulnerable to known plaintext attacks.

>Do you assume Pad[] is as long as the message?

No.

>If no, then the scheme depends on the strength of E_k,
>which (if weak) will expose the Pad the next time around, even with a
>new session key.  It's intractable (I won't say invulnerable for anything
>less than a true one-time pad) only if E_k is cryptographically strong,
>if I understand what you're saying.  "First we assume a cryptographically
>strong hash function..."  I must be misunderstanding something, though,
>since if your E_k() is strong, then you might as well be using consecutive
>integers instead of truly random Pad[].

The reason why I suggested using a pad of random numbers, is to insure
that no part of the sequence generated by E_k(Pad[i]) for a particular
message key is related to any other part of the sequence.  However, it
is true that the i-th block of such a sequence is somehow related to
the i-th block of all the other sequences produced with the other
message keys.

I'll have to think about that one.

Also, if one uses a counter, then this just results in a pseudorandom
sequence.  (The only arguably cryptographically strong PRNG I've read
about is the Quadratic Residue based one, though I know of two others,
one based on factoring.)  Each part of the sequence is then somehow
related to every other part of the same sequence.  With the above
scheme, each part of a sequence is completely unrelated to the rest of
the sequence.  (This is because Pad[] is truly random and E_k() is a
bijection.  In fact, it would be true even if E_k() was something as
hokey as transposition.)  Unfortunately, it's also related to the same
part of every other sequence ever encoded, which turns out to be a
huge weakness in terms of known plaintext attacks.

>Another observation: if Pad[] gets reused from one message to the next,
>there's a chance of a birthday collision on Ks^Km for anybody reusing
>Pad[], even with a different Ks.  If it ever happens, it's easily
>detectable by the cryptanalyst, and fatal to both messages.

Yes.  There should be a better way to distribute the message keys.  As
it is now, it's like a big red flag saying: `Check me against the
previous keys!'  However, with a sufficiently large key size, even the
birthday paradox would allow one to re-use Pad[] a whole lot of times.
(Though this runs smack into the birthday paradox and gets pretty
bruised.  Still, taking the nth root of (2^128) for modest n will
still give one a decently high number.)

>>(P.S.  Just in case this scheme hasn't ever appreared before, I've
>>decided to name it the `Virtual One Time Pad.'  :)

>Yeah, good thinking -- your theory is that JD is abandoning the name
>after this week's exercise?  Does this mean Pad[] really is used only
>one time?

The point is to be able to `recycle' or `expand' Pad[].  In fact, if
you used another pad of random numbers for the message keys, this
would reduce to a Vernam cipher with absurdly long keys and a more
complicated mixing function than XOR.  (Or as a PRNG with a bloated
seed and a comparatively piddly cycle length.)

Oh well.

Let's see if we can come up with a PRNG using Knapsack.
(Actually, first I'll see if it's been done.  Anyone happen to know?)

--PKS (YACN)

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
       There's neither heaven nor hell -- Save that we grant ourselves.
    There's neither fairness nor justice -- Save what we grant each other.

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Peter Kwangjun Suk  --  suk@usceast.cs.scarolina.edu  --  Musician, Programmer
--------
For information about this Usenet posting service, send mail to
remailer@soda.berkeley.edu, with Subject: remailer-info.
Please, don't throw knives.
