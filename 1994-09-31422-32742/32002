Path: msuinfo!netnews.upenn.edu!news.amherst.edu!news.mtholyoke.edu!news.byu.edu!news.kei.com!MathWorks.Com!europa.eng.gtefsd.com!howland.reston.ans.net!cs.utexas.edu!uunet!george.inhouse.compuserve.com!news.inhouse.compuserve.com!compuserve.com!news
From: Bob Jenkins <74512.261@CompuServe.COM>
Newsgroups: sci.crypt
Subject: Re: RC4 ?
Date: 16 Sep 1994 04:03:29 GMT
Organization: via CompuServe Information Service
Lines: 66
Message-ID: <35b5eh$c6v$1@mhadg.production.compuserve.com>
References: <35aeij$kdc@news1.shell>


My estimate of c/n^2 for bias was entirely empirical, and the
numbers I gave for the gap test were copied from my test outputs.
The numbers below "gap" were the number of gaps seen of length
0,1,2,3,4,5,... adjusted for their expected frequency.  The 2^22
next to ALPHA=2 is how many values I actually examined; I did
overkill to try to discern the patterns from the random fluxes.

Right, ALPHA=3 means an array of 8 terms with 3 bits per term.
Right, cycle length of 2^6 was a mistake for ALPHA=2.  Meant 2^8.

I have another data point: for ALPHA=6 the gap test fails after
seeing 2^33 results.  (a a) is too likely, (a b a) too unlikely.
Don't know why.  I'll revise my estimate to 2^43 for ALPHA=8.


Just because a sequence of results from an RNG can be obtained 
doesn't mean the internal state of the RNG can be deduced easily.
For example, for the quadratic residue generator (BBS), deducing
the internal state (even given arbitrarily many uncorrupted 
results) is as hard as factoring.  To break a stream cypher, you
need to find an attack to deduce the RNG's internal state!


So here's an attack on rc4 that's faster than testing all possible
internal states, but still not practical: the guess-and-generate 
attack.  If rc4 is

  for (i=0; i<SIZE; ++i)
  {
    x = m[i];
    a = (x+a)&MASK;
    y = m[a];
    m[i]=y; m[a]=x;
    r[i] = m[((x+y)&MASK)];
  }

then the attack is to place an arbitrary permutation in g,
make an initial guess of c, guess i correctly, then run

  for (i=0; i<SIZE; ++i)
  {
    x = g[i];
    c = (x+c)&MASK;
    y = g[c];
    g[i]=y; g[c]=x;
    for (j=0; j<SIZE; ++j) if (g[j]==r[i]) break;
    z = (x+y)&MASK;
    g[j]=g[z]; g[z]=r[i];
  }

in parallel (the attack using rc4's r's).  Eventually g and c will
converge to m and a.  Tests reveal "eventually" to be:

  SIZE    convergence    estimated cycle length (#states/2)
  2^1     2^1            2^1
  2^2     2^1..2^5       2^8
  2^3     2^5..2^13      2^20
  2^4      > 2^22        2^51

For SIZE=2^8 I imagine this attack, as is, should take 2^900 steps
or so.  It seems to succeed after examining about the square root
of all possible states.  I'm not very clear on why this attack
works; it probably has something to do with the birthday paradox.

                                      - Bob Jenkins
