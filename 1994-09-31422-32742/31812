Newsgroups: sci.crypt
Path: msuinfo!agate!howland.reston.ans.net!europa.eng.gtefsd.com!MathWorks.Com!yeshua.marcam.com!charnel.ecst.csuchico.edu!csusac!csus.edu!netcom.com!phr
From: phr@netcom.com (Paul Rubin)
Subject: Re: Virtual One-Time-Pads
Message-ID: <phrCvxJo6.7u8@netcom.com>
Organization: NETCOM On-line Communication Services (408 261-4700 guest)
References: <34q622$ht$1@mhade.inhouse.compuserve.com>
Date: Sat, 10 Sep 1994 20:02:30 GMT
Lines: 62

In article <34q622$ht$1@mhade.inhouse.compuserve.com>,
Jim Demberger  <74425.1642@CompuServe.COM> wrote:
>Everyone seems to have a hang-up on PRNGs and the fact that the long
>keys used by the VOTP program are not "truly" random.  In the case of
>the VOTP program, both Alice and Bob know three numbers ranging is
>value from 00hex to FFhex, these three numbers are secret and known
>only to A and B.

Are you saying there are only 24 bits of secret key information?
It is pathetically easy to exhaustively search such a small key space.

>These three numbers are XORed with three O-T-P
>counters that that are incremented for each file to be encrypt.  The
>result of the XOR operations are added to an offset that ranging in
>value from 00hex to 7Fhex.  These three values are used as seeds for
>the BASIC RANDOMIZE function and the RND function is used to permutate
>or shuffle three lists or arrays of the character codes from 00hex to
>FFhex.

Now the quality of this shuffling depends on the quality of the Basic
RND function, which varies from implementation to implementation and
which experience has shown to generally be pretty terrible.  In any
case it's outside your control in general.  What version of BASIC
are you using, on what machine, etc?

>Once the three arrays with the character codes in random order
>(sub-keys) have been created the program has no further need for a
>PRNG.  A random long key character code (OTP) is created by XORing one
>character code from each of the three random sub-keys; the OTP
>character code is XORed with one character code from the plain text to
>produce a cipher text character.  Repeat the operation with a cipher
>text character instead of the plain text character and you get a clear
>text character.

This is called a Vernam cipher and was broken in the 1920's.

>>The long "random" character string is not random.  Anyone who knows the
>>5124 character key can recreate it easily.  Essentially the OTP appears
>>to be a large lookup table for your real cipher, which is based on the
>>random number generator.

>I don't have any idea of what you are referring to with respect to
>"The long "random" character string" or the "the 5124 character key".
>Since you haven't run the program against a file of a million or so
>00hex character to create a physical OTP rather than a virtual OTP,
>how did you determine that the OTP keys are not random?  Unless you
>consider the three random character arrays to "tables" and an XOR
>operation to be a look-up it "is not the case".  I hope this message
>"let us (you) know why not." but you will have to run the program and
>read the documentation file to really know how instead of why.

I'm starting to understand this a little better, it sounds like
the 5124 character key refers to the arrays that are shuffled using
the 3 secret bytes.  It is quite an easy task for a fast computer
to search these 2^24=16 million possible reorderings.

>I have considered a "challenge" file but there is one problem - an
>encrypt file may and probably will have character codes from 00hex
>to FFhex.  Probably be best to convert it with UUENCODE rather than
>BIN2HEX and to PKZIP the ASCII file prior to encoding.

Yes, this sounds fine.  
