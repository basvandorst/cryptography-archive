Path: msuinfo!netnews.upenn.edu!news.amherst.edu!news.mtholyoke.edu!news.byu.edu!news.kei.com!MathWorks.Com!blanket.mitre.org!linus.mitre.org!linus!mbunix!eachus
From: eachus@spectre.mitre.org (Robert I. Eachus)
Newsgroups: sci.crypt,sci.math
Subject: Re: P = NP? (was : How safe is RSA?)
Followup-To: sci.crypt,sci.math
Date: 31 Aug 94 19:57:57
Organization: The Mitre Corp., Bedford, MA.
Lines: 99
Message-ID: <EACHUS.94Aug31195757@spectre.mitre.org>
References: <EACHUS.94Aug24191851@spectre.mitre.org> <33r2b4$qe7@news.umbc.edu>
NNTP-Posting-Host: spectre.mitre.org
In-reply-to: olson@umbc.edu's message of 28 Aug 1994 22:16:04 GMT
Xref: msuinfo sci.crypt:31466 sci.math:79335

In article <33r2b4$qe7@news.umbc.edu> olson@umbc.edu (Bryan G. Olson; CMSC (G)) writes:

  > He attempts a constructive argument, showing that if such an algorithm
  > exists, then it can be used to prove it is poly-time.  I am both
  > unconvinced of this, and poly-time alone is not sufficient.

   The important point, as you note below, is that if P=NP, then CoNP=NP.
I think most people responding missed this...

   Second, I thought I had posted a demonstration that correctness is
not at issue.  (Combining the poly-time algorithm with a known correct
non-P-time algorithm in such a way as to render the p-time part the
only open question.)

   One more for the road, the proof need not be findable, or findable
in P-time, for decidability to be disproven.

  > only style of proof I can envision for P=NP would require an example
  > algorithm, and that we prove:

  >	   the algorithm A recognizes language L
  >	   language L is NP-C
  >	   algorithm A is poly-time.

    Okay, certainly if no such algorithm exists, then P/=NP, so this
is a good starting point.

  > Now suppose we have a candidate algorithm A.  Can we come up with a
  > construction which will establish any of these 3, in the case that A
  > really is a poly-time recognizer for an NP-C language ?  The only
  > short-cut I see is defining L as the language recognized by A.

   I prefer the short cut of selecting a language known to be NPC.
Since, as I said above you can augment A so that it verifies any
solution, there is no problem.  (Back to coNP=NP from the assumptions.
If the input is rejected we solve the coNP problem, then test that
solution.)

  > Given a recognizer for an NPC language L with a know polynomial
  > reduction to 3SAT, we can construct a recognizer which will output
  > a proof that the input string is in L whenever it accepts.  Thus
  > given a candidate A, we could construct a candidate A' and a proof
  > that A' will always be correct when it accepts.

  I guess I was getting just a bit ahead of you.

  > If P=NP then NP=Co-NP, so not(L) is also NP and thus should have a
  > polynomial reduction to 3SAT.  Is it possible for there to be
  > polynomial reductions from L but none for which a proof of
  > correctness exists ?

  Hmmmm, this is a very interesting question!  I had just assumed that
the dual of a 3SAT problem was in NP, and that both the problem and
its dual could not be unsatisfiable.  (Sounds like I should scurry off
and try to verify that. Integer programming seems to give a warm
feeling on this, but I'll have to think about it.) But if your A
rejects L, and provides a solution to dual(L), can I use that to
verify that no solution to L exists?  That one sounds like a three
pipe problem.

  Ah!  Seems to me I looked at this years ago.  If you take a 3SAT
problem it can be mapped into a zero-one integer programming problem
with an objective function whose maximum is one iff you can satisfy
the 3SAT problem.  The minimum of the dual objective function is zero
iff there is no solution to the 3SAT problem.  (Also as I remember it,
there is a usually a trivial solution to the corresponding linear
programming problem, but it has fractional values for most variables.)
Since the dual can be restated as a primal problem which only has a
solution if the original primal does not, we have a clear case of
NPC=coNPC.  I'll have to verify that, but at least I remember where to
look.

  > If we have proven polynomial reductions from both L and not(L) to
  > 3SAT and candidate machines for recognizing both, we can construct
  > a recognizer which will be correct whenever it terminates.  Then
  > we just have to prove the time.

   I do see the (potential) hole above, but I don't see one with the
time.  If I go through all the hoops, then there is a problem in NP
which corrresponds to finding a problem which takes longer than (some
arbitrary--I don't need to show how to get it) polynomial measure of
running time for A.  Since NP=coNP if P=NP (and maybe even if not, see
above), I can then solve the co-problem to prove that no
counterexample exists.  I don't know the size of the problem, so I
don't know how long solving the coproblem will take, but I don't care.
I'm not trying to show the proof is in P-time, just that a proof must
exist.
  
  > Can anyone resolve the truth of (1), or am I right to leave it open ?

   I think you did show a hole that needs closing.  I'll see if I can.

--

					Robert I. Eachus

with Standard_Disclaimer;
use  Standard_Disclaimer;
function Message (Text: in Clever_Ideas) return Better_Ideas is...
