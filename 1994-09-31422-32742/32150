Path: msuinfo!agate!howland.reston.ans.net!pipex!derwent.co.uk!not-for-mail
From: tim@morgoth.derwent.co.uk. (Tim Morley)
Newsgroups: sci.crypt
Subject: Re: Speedups in posted RC4 code
Date: 19 Sep 1994 13:21:19 +0100
Organization: Derwent Publications.
Lines: 60
Message-ID: <35jvnv$nfs@morgoth.derwent.co.uk>
References: <35c4aa$l17@bcarh8ab.bnr.ca> <35daff$jvb@news.delphi.com> <jonadamsCwDKFK.s5@netcom.com>
NNTP-Posting-Host: morgoth.derwent.co.uk

In article <jonadamsCwDKFK.s5@netcom.com>,
Jonathan Adams <jonadams@netcom.com> wrote:
>JMKELSEY@DELPHI.COM (jmkelsey@news.delphi.com) wrote:
>
>: Be careful not to replace the swap with a swap macro that won't deal well
>: with swapping a byte with itself.  About 1/256 of the swapping is done
>: with x and y equal, thus 	
>:  
>: #define SWAP(x,y) {x^=y;y^=x;x^=y;} 
>
>: winds up giving you an internal state full of zeros.
>No, it doesn't. Try the following C code:
>
>#include <stdio.h>
>
>int main(void)
>{
>    int x,y,z;
>
>    for (z = 0; z < 256; z++) {
>        x = y = z;
>        x ^= y; y ^= x; x ^= y;
>        printf("x = %3i, y = %3i, z = %3i%s|",x,y,z,((z+1)%3 == 0)?"":" ");
>    }
>    return 0;
>}
>
>You'll find that the switch works for every value of x when y==x.
>

Yes this is all very well, but it doesn't show _ANYTHING_ about the
case in point. You show that (as you would expect), if x has the same
value as y then doing x ^= y; y ^= x; x ^= y;, does do what you
expect. The original point is that if you try to do this when x and y
are identical, you will always get a result of 0

e.g.
#include <stdio.h>
#define SWAP(x,y) {x^=y;y^=x;x^=y;} 

int main()
{
	int x,y;

	for (y=0;y<256;y++)
	{
		x=y;
		SWAP(x,x);
		printf("Before x=%d after SWAP(x,x) x=%d\n",y,x);
	}

	return 0;
}

This is for the simple reason that in each step of SWAP, you XOR
something with itself, which gives an answer of 0.

Tim M


