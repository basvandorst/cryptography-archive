Path: msuinfo!uchinews!vixen.cso.uiuc.edu!howland.reston.ans.net!news.cac.psu.edu!news.pop.psu.edu!psuvax1!eiffel.cse.psu.edu!so
From: so@eiffel.cse.psu.edu (Nicol C So)
Newsgroups: sci.crypt,alt.security,comp.security.misc,alt.privacy
Subject: Re: RC4 Algorithm revealed.
Date: 15 Sep 1994 15:13:33 GMT
Organization: Computer Science and Engineering, Penn State University
Lines: 31
Message-ID: <359oat$feh@psuvax1.cse.psu.edu>
References: <sternCvKL4B.Hyy@netcom.com>
NNTP-Posting-Host: eiffel.cse.psu.edu
Xref: msuinfo sci.crypt:31977 alt.security:18773 comp.security.misc:11708 alt.privacy:18888

In article <sternCvKL4B.Hyy@netcom.com> sterndark@netcom.com (David Sterndark) writes:
>I am shocked,  shocked, I tell you,  shocked, to discover
>that the cypherpunks have illegaly and criminally revealed
>a crucial RSA trade secret and harmed the security of
>America by reverse engineering the RC4 algorithm and
>publishing it to the world.

Pardon me if you are just kidding.

First of all, we don't know whether the code is the RC4 algorithm.  It is
just something allegedly computes the same function as RC4 does.  An
exponentiation algorithm is a different thing from the exponentiation
function.  By the same token, an algorithm computing an encryption function
is distinct from the function being computed.

Second, how do you know that the person who published the code has
"illegally and criminally revealed a crucial trade secret of RSA".  How
do you know that the person has violated any non-disclosure agreement
with RSA?  How do you know that the person reverse engineered the code?
Did it ever occur to you that the person could be just a good cryptanalyst
who had come up with a similar design before?  I don't know whether this
is the case, but it is always a possibility.

To say that RC4 is a "crucial RSA trade secret" is the biggest joke.  It
takes an average programmer less than 5 minutes to see that the algorithm
in the code is nothing more than a stream cipher using pseudorandom numbers
as the key stream.  The variable key-length feature is accomplished by
applying a hash function to the key to obtain an initial state for the
pseudorandom number generator.  This scheme has probably be reinvented
a thousand times.  The only thing new here is the particular pseudorandom
number generator used.
