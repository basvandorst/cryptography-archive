Newsgroups: sci.crypt
Path: msuinfo!agate!howland.reston.ans.net!EU.net!uknet!cix.compulink.co.uk!aph
From: aph@cix.compulink.co.uk ("Andrew Haley")
Subject: Re: ** Help me Montgomery ? **
Message-ID: <Cw642C.GpD@cix.compulink.co.uk>
Organization: Compulink Information eXchange
References: <35700h$nbe@lucy.ee.und.ac.za>
Date: Thu, 15 Sep 1994 11:03:47 GMT
Lines: 109

In article <35700h$nbe@lucy.ee.und.ac.za> cat@olddaisy.ee.und.ac.za (Jyri Hamalainen) writes:
>
>Could someone explain the basic logic of  
>
>"Montgomery modular multiplication without trial division",
>
>method in hardware/ software applications.
>
>Thank you 
>
>jYrI
> 

Let R be a power of the machine word size.  It needs to be greater
than the modulus N, and coprime to it.

Let

		R' = R^-1 mod N
		N' = -(N^-1) mod R

To compute TR' mod N from T of 0 <= T <= RN:

function REDC(T)
begin
	m := (T mod R) * N' mod R;
	t := (T + m * N)/R;
	if t >= N then return t-N else return t
end;

because
	
m * N == T * N' * N mod R

(N' * N == -1 mod R)

m * N == T * -1 mod R
      == -T mod R

So when we add m * N to T, the result is congruent to 0 mod R.
Therefore the result of the division, t, is an integer.  In fact, the
last line of REDC does not need to be executed if we maintain two
extra bits throughout the calculations.

Given two numbers x and y between 0 and N-1 inclusive, let z =
REDC(xy).  Then z == (xy)R^-1 mod N, so (x * R^-1)(y * R^-1) == z *
R^-1 mod N.  (This implies that there is no need to correct for the
multiplications by R^-1 during the exponentiation.)  Also, addition
and subtraction is unchanged in this form.

Also, note that the product T * N' needs only to be carried out at
half precision.

In order to use REDC, we need to convert our numbers into N-residue
form before beginning the calcualtion.  To convert an integer x into
N-residue form, compute x*R mod N.  To convert an N-residue into an
integer, multiply it by R^-1 mod N.


Multiprecision Case

Instead of computing all of m at once, we can do it a digit at a time.
This allows us to use a single digit n0', which is -N^-1 mod b instead
of -N^-1 mod R.  b is the word size of the computer.

The result will not be the same as the original algorithm, but T will
still be a multiple of R.

function REDC(T)
begin
	for i := 0 to n-1 do begin
		m := T[i] * n0' mod b;
		T := T + m * N * b^i
	end
	return T/R;	
end

Note that this is very similar to long multiplication:

begin
	for i := 0 to n-1 do begin
		T := T + A[i] * B * b^i
	end
end

This takes n^2 + n multiplications.  Effectively, the modular
multiplication has been reduced to two long multiplications.  However,
still further performance improvements can be realized by interleaving
the two phases of multiplication and reduction:

function Mont_Product(A,B)
begin
	T := 0;
	for i := to to n-1 do begin
		T := T + A[i] * B * b^i;	
		m := T[i] * n0' mod b;
		T := T + m * N * b^i;
	end;	
	return T/R;
end

This performance improvement is very valuable if using a DSP, because
multiplies are very fast, and bookkeeping overhead is to be avoided
wherever possible.  It still does as many multiplies as the separate
multiplication and reduction, however, so the performance gain will be
small on a more conventional microprocessor.

Andrew.

