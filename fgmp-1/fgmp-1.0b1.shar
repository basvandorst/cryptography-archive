#!/bin/sh
# This is a shell archive (produced by shar 3.49)
# To extract the files from this archive, save it to a file, remove
# everything above the "!/bin/sh" line above, and type "sh file_name".
#
# made 07/29/1993 20:20 UTC by henderso@netcom3
# Source directory /u35/ftp/pub/henderso/fmp/fgmp
#
# existing files will NOT be overwritten unless -c is specified
#
# This shar contains:
# length  mode       name
# ------ ---------- ------------------------------------------
#   2609 -rw------- notes
#     99 -rw------- makefile
#   3627 -rw------- gmp.h
#  33551 -rw------- gmp.c
#
# ============= notes ==============
if test -f 'notes' -a X"$1" != X"-c"; then
	echo 'x - skipping notes (File already exists)'
else
echo 'x - extracting notes (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'notes' &&
WELCOME TO FGMP.
X
This is the first BETA release. 1.0b1
X
I hearby place this file in the public domain.
X
FGMP is a public domain implementation of a subset of the GNU gmp library
with the same API. 
X
For instance, you can link the following trivial program with either 
this code, or libgmp.a and get the same results.
------------
#include <stdio.h>
#include "gmp.h"
main()
{
X    MP_INT a; MP_INT b; MP_INT c;
X
X    mpz_init_set_ui(&a,1); mpz_init_set_ui(&b,2); mpz_init(&c);
X    mpz_add(&c,&a,&b);
X    printf("\n%s\n", mpz_get_str(NULL,10,&c));
}
X
------------
X
FGMP is really in the public domain. You can do whatever you want with
it.
X
I wrote FGMP so that we would all have access to a (truly free)
implementation of this subset of the API of GNU libgmp. I encourage
everyone to distribute this as widely as possible.
X
If you need more documentation, I suggest you look at the file
gmp.texi which is included with the GNU gmp library. 
X
You can send me bug reports, implementations of missing functions, flames
and rants by Email. Any submissions of new code to be integrated into
fgmp must also be placed in the public domain.
X
Mark Henderson <markh@wimsey.bc.ca>
X
---
Some differences between gmp and fgmp
X
1. fgmp is considerably slower than gmp
2. fgmp does not implement the following:
X	all mpq_*
X	internal mpn_* functions
X	mpz_sqrt
X	mpz_sqrtrem
X	mpz_perfect_square_p
X	mpz_inp_raw, mpz_out_raw
X	mp_set_memory_functions, mpz_out_str, mpz_inp_str
3. fgmp implements the following in addition to the routines in GNU gmp.
X	int mpz_jacobi(MP_INT *a, MP_INT *b)
X	- finds the jacobi symbol (a/b)
4. mpz_sizeinbase often overestimates the exact value
X
5. To convert your gmp based program to fgmp (subject to the
above)
X
- recompile your source. Make sure to include the gmp.h file included
X  with fgmp rather than that included with gmp. (The point is to recompile
X  all files which include gmp.h)
- link with gmp.o instead of libgmp.a
X
Here's a complete sorted list of function implemented in fgmp:
X
_mpz_realloc
mpz_abs
mpz_add
mpz_add_ui
mpz_and
mpz_clear
mpz_cmp
mpz_cmp_si
mpz_cmp_ui
mpz_div
mpz_div_2exp
mpz_div_ui
mpz_divmod
mpz_divmod_ui
mpz_fac_ui
mpz_gcd
mpz_gcdext
mpz_get_si
mpz_get_str
mpz_get_ui
mpz_init
mpz_init_set
mpz_init_set_si
mpz_init_set_str
mpz_init_set_ui
mpz_jacobi
mpz_mdiv
mpz_mdiv_ui
mpz_mdivmod
mpz_mdivmod_ui
mpz_mmod
mpz_mmod_ui
mpz_mod
mpz_mod_2exp
mpz_mod_ui
mpz_mul
mpz_mul_2exp
mpz_mul_ui
mpz_neg
mpz_or
mpz_pow_ui
mpz_powm
mpz_powm_ui
mpz_probab_prime_p
mpz_random
mpz_random2
mpz_set
mpz_set_si
mpz_set_str
mpz_set_ui
mpz_size
mpz_sizeinbase
mpz_sub
mpz_sub_ui
mpz_xor
SHAR_EOF
chmod 0600 notes ||
echo 'restore of notes failed'
Wc_c="`wc -c < 'notes'`"
test 2609 -eq "$Wc_c" ||
	echo 'notes: original size 2609, current size' "$Wc_c"
fi
# ============= makefile ==============
if test -f 'makefile' -a X"$1" != X"-c"; then
	echo 'x - skipping makefile (File already exists)'
else
echo 'x - extracting makefile (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'makefile' &&
CC=gcc -I. -g
#CC=purify cc -g -Bstatic  
gmp.o: gmp.c
X	$(CC) -c -g gmp.c
clean:
X	rm -f gmp.o core
SHAR_EOF
chmod 0600 makefile ||
echo 'restore of makefile failed'
Wc_c="`wc -c < 'makefile'`"
test 99 -eq "$Wc_c" ||
	echo 'makefile: original size 99, current size' "$Wc_c"
fi
# ============= gmp.h ==============
if test -f 'gmp.h' -a X"$1" != X"-c"; then
	echo 'x - skipping gmp.h (File already exists)'
else
echo 'x - extracting gmp.h (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'gmp.h' &&
/*
X * FREE GMP - a public domain implementation of a subset of the 
X *           GNU gmp library
X *
X * I hearby place the file in the public domain.
X *
X * Do whatever you want with this code. Change it. Sell it. Claim you
X *  wrote it. 
X * Bugs, complaints, flames, rants: please send mail to 
X *    Mark Henderson <markh@wimsey.bc.ca>
X * VERSION 1.0 - beta 1
X */
X
X
#include <stdio.h>
#include <sys/types.h>
X
#ifndef NULL
#define NULL ((void *)0)
#endif
X
typedef struct mp_int {
X	long *p;
X	short sn;
X    unsigned int sz;
} MP_INT;
X
#ifdef __STDC__
#define PROTO(x) x
#else
#define PROTO(x) ()
#endif
X
void mpz_init PROTO((MP_INT *s));
void mpz_init_set PROTO((MP_INT *s, MP_INT *t));
void mpz_init_set_ui PROTO((MP_INT *s, unsigned long v));
void mpz_init_set_si PROTO((MP_INT *y, long v));
void mpz_clear PROTO((MP_INT *s));
void _mpz_realloc PROTO((MP_INT *x, long size));
void mpz_set PROTO((MP_INT *y, MP_INT *x));
void mpz_set_ui PROTO((MP_INT *y, unsigned long v));
unsigned long mpz_get_ui PROTO((MP_INT *y));
long mpz_get_si PROTO((MP_INT *y));
void mpz_set_si PROTO((MP_INT *y, long v));
int mpz_cmp PROTO((MP_INT *x, MP_INT *y));
void mpz_mul PROTO((MP_INT *ww,MP_INT *u, MP_INT *v));
void mpz_mul_2exp PROTO((MP_INT *z, MP_INT *x, unsigned long e));
void mpz_div_2exp PROTO((MP_INT *z, MP_INT *x, unsigned long e));
void mpz_mod_2exp PROTO((MP_INT *z, MP_INT *x, unsigned long e));
void mpz_add PROTO((MP_INT *zz,MP_INT *x,MP_INT *y));
void mpz_add_ui PROTO((MP_INT *x,MP_INT *y, unsigned long n));
void mpz_mul_ui PROTO((MP_INT *x,MP_INT *y, unsigned long n));
void mpz_sub PROTO((MP_INT *z,MP_INT *x, MP_INT *y));
void mpz_sub_ui PROTO((MP_INT *x,MP_INT *y, unsigned long n));
void mpz_div PROTO((MP_INT *q, MP_INT *x, MP_INT *y));
void mpz_mdiv PROTO((MP_INT *q, MP_INT *x, MP_INT *y));
void mpz_mod PROTO((MP_INT *r, MP_INT *x, MP_INT *y));
void mpz_divmod PROTO((MP_INT *q, MP_INT *r, MP_INT *x, MP_INT *y));
void mpz_mmod PROTO((MP_INT *r, MP_INT *x, MP_INT *y));
void mpz_mdivmod PROTO((MP_INT *q,MP_INT *r, MP_INT *x, MP_INT *y));
void mpz_mod_ui PROTO((MP_INT *x,MP_INT *y, unsigned long n));
void mpz_mmod_ui PROTO((MP_INT *x,MP_INT *y, unsigned long n));
void mpz_div_ui PROTO((MP_INT *x,MP_INT *y, unsigned long n));
void mpz_mdiv_ui PROTO((MP_INT *x,MP_INT *y, unsigned long n));
void mpz_divmod_ui PROTO((MP_INT *q,MP_INT *x,MP_INT *y, unsigned long n));
void mpz_mdivmod_ui PROTO((MP_INT *q,MP_INT *x,MP_INT *y, unsigned long n));
unsigned int mpz_sizeinbase PROTO((MP_INT *x, int base));
char *mpz_get_str PROTO((char *s,  int base, MP_INT *x));
int mpz_set_str PROTO((MP_INT *x, char *s, int base));
void mpz_init_set_str PROTO((MP_INT *x, char *s, int base));
void mpz_random PROTO((MP_INT *x, unsigned int size));
void mpz_random2 PROTO((MP_INT *x, unsigned int size));
size_t mpz_size PROTO((MP_INT *x));
void mpz_abs PROTO((MP_INT *, MP_INT *));
void mpz_neg PROTO((MP_INT *, MP_INT *));
void mpz_fac_ui PROTO((MP_INT *, unsigned long));
void mpz_gcd PROTO((MP_INT *, MP_INT *, MP_INT *));
void mpz_gcdext PROTO((MP_INT *, MP_INT *, MP_INT *, MP_INT *, MP_INT *));
int mpz_jacobi PROTO((MP_INT *, MP_INT *));
int mpz_cmp_ui PROTO((MP_INT *, unsigned long));
int mpz_cmp_si PROTO((MP_INT *, long));
void mpz_and PROTO((MP_INT *, MP_INT *, MP_INT *));
void mpz_or PROTO((MP_INT *, MP_INT *, MP_INT *));
void mpz_xor PROTO((MP_INT *, MP_INT *, MP_INT *));
void mpz_pow_ui PROTO((MP_INT *, MP_INT *, unsigned long));
void mpz_powm PROTO((MP_INT *, MP_INT *, MP_INT *, MP_INT *));
void mpz_powm_ui PROTO((MP_INT *, MP_INT *, unsigned long, MP_INT *));
int mpz_probab_prime_p  PROTO((MP_INT *, int));
SHAR_EOF
chmod 0600 gmp.h ||
echo 'restore of gmp.h failed'
Wc_c="`wc -c < 'gmp.h'`"
test 3627 -eq "$Wc_c" ||
	echo 'gmp.h: original size 3627, current size' "$Wc_c"
fi
# ============= gmp.c ==============
if test -f 'gmp.c' -a X"$1" != X"-c"; then
	echo 'x - skipping gmp.c (File already exists)'
else
echo 'x - extracting gmp.c (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'gmp.c' &&
/*
X * FREE GMP - a public domain implementation of a subset of the 
X *           gmp library
X *
X * I hearby place the file in the public domain.
X *
X * Do whatever you want with this code. Change it. Sell it. Claim you
X *  wrote it. 
X * Bugs, complaints, flames, rants: please send email to 
X *    Mark Henderson <markh@wimsey.bc.ca>
X * I'm already aware that fgmp is considerably slow than gmp
X * VERSION 1.0 - beta 1
X */
X
#include "gmp.h"
#ifndef NULL
#define NULL ((void *)0)
#endif
X
#define iabs(x) ((x>0) ? (x) : (-x))
#define imax(x,y) ((x>y)?x:y)
#define LONGBITS (sizeof(long) * 8)
#define DIGITBITS (LONGBITS - 2)
#define HALFDIGITBITS ((LONGBITS -2)/2)
#ifndef init
#define init(g) { g = (MP_INT *)malloc(sizeof(MP_INT));  mpz_init(g); }
#endif
#ifndef clear
#define clear(g) { mpz_clear(g); free(g); }
#endif
#ifndef even
#define even(a) (!((a)->p[0] & 1))
#endif
#ifndef odd
#define odd(a) (((a)->p[0] & 1))
#endif
X
X
/* 
X * The values below are for 32 bit machines
X * You'll need to change them, if you're using something else
X */
#define LMAX 0x3fffffff
#define LC   0xc0000000
#define OVMASK 0x2
#define CMASK (LMAX+1)
#define FC ((double)CMASK)
#define HLMAX 0x7fff
#define HCMASK (HLMAX + 1)
#define HIGH(x) (((x) & 0x3fff8000) >> 15)
#define LOW(x)  ((x) & 0x7fff)
X
X
#define hd(x,i)  (((i)>=2*(x->sz))? 0:(((i)%2) ? HIGH((x)->p[(i)/2]) : LOW((x)->p[(i)/2])))
#define dg(x,i) ((i < x->sz) ? (x->p)[i] : 0)
X
#ifdef __GNUC__
#define INLINE inline
#else
#define INLINE
#endif
X
#define lowdigit(x) (((x)->p)[0])
X
struct is {
X    int v;
X    struct is *next;
};
X
X
INLINE static void push(i,sp)
int i;struct is **sp;
{
X    struct is *tmp;
X    tmp = *sp;
X    *sp = (struct is *) malloc(sizeof(struct is));
X    (*sp)->v = i;
X    (*sp)->next=tmp;
}
X
INLINE static int pop(sp)
struct is **sp;
{
X    struct is *tmp;
X    int i;
X    if (!(*sp))
X        return (-1);
X    tmp = *sp;
X    *sp = (*sp)->next;
X    i = tmp->v;
X    tmp->v = 0;
X    free(tmp);
X    return i;
}
X
void fatal(s)
char *s;
{
X    fprintf(stderr,"%s\n",s);
X    exit(123);
}
X
void mpz_init(s)
MP_INT *s;
{
X    s->p = (long *)malloc(sizeof(long)*2);
#ifdef DEBUG
X    printf("malloc: 8 bytes, %08x\n", s->p);
#endif
X    if (!(s->p))
X        fatal("mpz_init: cannot allocate memory");
X    (s->p)[0] = 0;
X    (s->p)[1] = 0;
X    s->sn=0;
X    s->sz=2;
}
X
void mpz_init_set(s,t)
MP_INT *s,*t;
{
X    int i;
X    s->p = (long *)malloc(sizeof(long) * t->sz);
X    if (!(s->p))
X        fatal("mpz_init: cannot allocate memory");
X    for (i=0;i < t->sz ; i++)
X        (s->p)[i] = (t->p)[i];
X
X    s->sn = t->sn;
X    s->sz = t->sz;
}
X
void mpz_init_set_ui(s,v)
MP_INT *s;
unsigned long v;
{
X    s->p = (long *)malloc(sizeof(long)*2);
X    if (!(s->p))
X        fatal("mpz_init: cannot allocate memory");
X    s->p[0] = (v & LMAX);
X    s->p[1] = (v & LC);
X    if (v) 
X        s->sn = 1;
X    else
X        s->sn = 0;
X    s->sz = 2;
}
X
void mpz_init_set_si(y,v)
MP_INT *y;
long v;
{
X    y->p = (long *)malloc(sizeof(long)*2);
X    if (!(y->p))
X        fatal("mpz_init: cannot allocate memory");
X    if (v < 0) {
X        y->sn = -1;
X        y->p[0] = (-v) & LMAX;
X        y->p[1] = (-v) & LC;
X    }
X    else if (v > 0) {
X        y->sn = 1;
X        y->p[0] = v & LMAX;
X        y->p[1] = v & LC;
X    }
X    else {
X        y->sn=0;
X        y->p[0] = 0;
X        y->p[1] = 0;
X    }
X    y -> sz = 2;
}
X
X
X
void mpz_clear(s)
MP_INT *s;
{
#ifdef DEBUG
X    printf("free: %08x\n", s->p);
#endif
X    if (s->p)
X        free(s->p);
X    s->p=NULL;
X    s->sn=0;
X    s->sz=0;
}
X
/* number of leading zero bits in digit */
static int lzb(a)
long a;
{
X    long i; int j;
X    j = 0;
X    for (i = (1 << (DIGITBITS-1)); i && !(a&i) ; j++,i>>=1) 
X        ;
X    return j;
}
X
void _mpz_realloc(x,size)
MP_INT *x; long size;
{
X    if (size > 1 && x->sz < size) {
X        int i;
#ifdef DEBUG
X    printf("realloc %08x to size = %d ", x->p,size);
#endif
X
X        if (x->p) 
X            x->p=(long *)realloc(x->p,size * sizeof(long));
X        else
X            x->p=(long *)malloc(size * sizeof(long));
#ifdef DEBUG
X    printf("becomes %08x\n", x->p);
#endif
X
X        if (!(x->p))
X            fatal("_mpz_realloc: cannot allocate memory");
X        for (i=x->sz;i<size;i++)
X            (x->p)[i] = 0;
X        x->sz = size;
X    }
}
X
void dgset(x,i,n)
MP_INT *x; unsigned int i; long n;
{
X    if (n) {
X        if (i >= x->sz) {
X            _mpz_realloc(x,i+1);
X            x->sz = i+1;
X        }
X        (x->p)[i] = n;
X    }
}
X
static unsigned int digits(x)
MP_INT *x;
{
X    int i;
X    for (i = (x->sz) - 1; i>=0 && (x->p)[i] == 0 ; i--) 
X        ;
X    return i+1;
}
X        
/* y = x */
void mpz_set(y,x)
MP_INT *y; MP_INT *x; 
{
X    unsigned int i,k = x->sz;
X    if (y->sz < k) {
X        k=digits(x);
X        _mpz_realloc(y,k);
X    }
X    if (y->sz > x->sz) {
X        mpz_clear(y); mpz_init(y); _mpz_realloc(y,x->sz);
X    }
X
X    for (i=0;i < k; i++)
X        (y->p)[i] = (x->p)[i];
X
X    for (;i<y->sz;i++)
X        (y->p)[i] = 0;
X
X    y->sn = x->sn;
}
X
void mpz_set_ui(y,v)
MP_INT *y; unsigned long v; {
X    int i;
X    for (i=1;i<y->sz;i++)
X        y->p[i] = 0;
X    y->p[0] = (v & LMAX);
X    y->p[1] = (v & LC) >> (DIGITBITS);
X    if (v)
X        y->sn=1;
X    else
X        y->sn=0;
}
X
unsigned long mpz_get_ui(y) 
MP_INT *y; {
X    return (y->p[0] | (y->p[1] << DIGITBITS));
}
X
long mpz_get_si(y)
MP_INT *y; {
X    if (y->sn == 0)
X        return 0;
X    else
X        return (y->sn * (y->p[0] | (y->p[1] & 1) << DIGITBITS));
}
X        
void mpz_set_si(y,v)
MP_INT *y; long v; {
X    int i;
X    for (i=1;i<y->sz;i++)
X        y->p[i] = 0;
X    if (v < 0) {
X        y->sn = -1;
X        y->p[0] = (-v) & LMAX;
X        y->p[1] = ((-v) & LC) >> DIGITBITS;
X    }
X    else if (v > 0) {
X        y->sn = 1;
X        y->p[0] = v & LMAX;
X        y->p[1] = (v & LC) >> DIGITBITS;
X    }
X    else {
X        y->sn=0;
X        y->p[0] = 0;
X        y->p[1] = 0;
X    }
}
X
/* z = x + y, without regard for sign */
static void uadd(z,x,y)
MP_INT *z; MP_INT *x; MP_INT *y;
{
X    long c;
X    int i;
X    MP_INT *t;
X
X    if (y->sz < x->sz) {
X        t=x; x=y; y=t;
X    }
X
X    /* now y->sz >= x->sz */
X
X    _mpz_realloc(z,(y->sz)+1);
X
X    c=0;
X    for (i=0;i<x->sz;i++) {
X        if (( z->p[i] = y->p[i] + x->p[i] + c ) & CMASK) {
X            c=1; 
X            (z->p[i]) &=LMAX;
X        }
X        else 
X            c=0;
X    }
X    for (;i<y->sz;i++) {
X        if ((z->p[i] = (y->p[i] + c)) & CMASK)
X            z->p[i]=0;
X        else
X            c=0;
X    }
X    (z->p)[y->sz]=c;
}
X
/* z = y - x, ignoring sign */
/* precondition: abs(y) >= abs(x) */
static void usub(z,y,x)
MP_INT *z; MP_INT *y; MP_INT *x; 
{
X    int i;
X    long b,m;
X    _mpz_realloc(z,(y->sz));
X    b=0;
X    for (i=0;i<y->sz;i++) {
X        m=((y->p)[i]-b)-dg(x,i);
X        if (m < 0) {
X            b = 1;
X            m = LMAX + 1 + m;
X        }
X        else
X            b = 0;
X        z->p[i] = m;
X    }
}
X
/* compare abs(x) and abs(y) */
static int ucmp(y,x)
MP_INT *y;MP_INT *x;
{
X    int i;
X    for (i=imax(x->sz,y->sz);i>=0;i--) {
X        if (dg(y,i) < dg(x,i))
X            return (-1);
X        else if (dg(y,i) > dg(x,i))
X            return 1;
X    }
X    return 0;
}
X
int mpz_cmp(x,y)
MP_INT *x; MP_INT *y;
{
X    int abscmp;
X    if (x->sn < 0 && y->sn > 0)
X        return (-1);
X    if (x->sn > 0 && y->sn < 0)
X        return 1;
X    abscmp=ucmp(x,y);
X    if (x->sn >=0 && y->sn >=0)
X        return abscmp;
X    if (x->sn <=0 && y->sn <=0)
X        return (-abscmp);
}
X    
/* is abs(x) == 0 */
static int uzero(x)
MP_INT *x;
{
X    int i;
X    for (i=0; i < x->sz; i++)
X        if ((x->p)[i] != 0)
X            return 0;
X    return 1;
}
X
static void zero(x)
MP_INT *x;
{
X    int i;
X    x->sn=0;
X    for (i=0;i<x->sz;i++)
X        (x->p)[i] = 0;
}
X
X
/* w = u * v */
void mpz_mul(ww,u,v)
MP_INT *ww;MP_INT *u; MP_INT *v; {
X    int i,j;
X    long t0,t1,t2,t3;
X    long cc;
X    MP_INT *w;
X
X    w = (MP_INT *)malloc(sizeof(MP_INT));
X    mpz_init(w);
X    _mpz_realloc(w,u->sz + v->sz);
X    for (j=0; j < 2*u->sz; j++) {
X        cc = 0;
X        t3 = hd(u,j);
X            for (i=0; i < 2*v->sz; i++) {
X                t0 = t3 * hd(v,i);
X                t1 = HIGH(t0); t0 = LOW(t0);
X                if ((i+j)%2) 
X                    t2 = HIGH(w->p[(i+j)/2]);
X                else
X                    t2 = LOW(w->p[(i+j)/2]);
X                t2 += cc;
X                if (t2 & HCMASK) {
X                    cc = 1; t2&=HLMAX;
X                }
X                else
X                    cc = 0;
X                t2 += t0;
X                if (t2 & HCMASK) {
X                    cc++ ; t2&=HLMAX;
X                }
X                cc+=t1;
X                if ((i+j)%2)
X                    w->p[(i+j)/2] = LOW(w->p[(i+j)/2]) |
X                        (t2 << HALFDIGITBITS);
X                else
X                    w->p[(i+j)/2] = (HIGH(w->p[(i+j)/2]) << HALFDIGITBITS) |
X                        t2;
X                    
X            }
X        if (cc) {
X            if ((j+i)%2) 
X                w->p[(i+j)/2] += cc << HALFDIGITBITS;
X            else
X                w->p[(i+j)/2] += cc;
X        }
X    }
X    w->sn = (u->sn) * (v->sn);
X    if (w != ww) {
X        mpz_set(ww,w);
X        mpz_clear(w);
X        free(w);
X    }
}
X
/* n must be < DIGITBITS */
static void urshift(c1,a,n)
MP_INT *c1;MP_INT *a;int n;
{
X    long cc = 0;
X    if (n >= DIGITBITS)
X        fatal("urshift: n >= DIGITBITS");
X    if (n == 0)
X        mpz_set(c1,a);
X    else {
X        MP_INT c; int i;
X        long rm = ((1<<n) - 1);
X        mpz_init(&c); _mpz_realloc(&c,a->sz);
X        for (i=a->sz-1;i >= 0; i--) {
X            c.p[i] = ((a->p[i] >> n) | cc) & LMAX;
X            cc = (a->p[i] & rm) << (DIGITBITS - n);
X        }
X        mpz_set(c1,&c);
X        mpz_clear(&c);
X    }
}
X    
/* n must be < DIGITBITS */
static void ulshift(c1,a,n)
MP_INT *c1;MP_INT *a;int n;
{
X    long cc = 0;
X    if (n >= DIGITBITS)
X        fatal("ulshift: n >= DIGITBITS");
X    if (n == 0)
X        mpz_set(c1,a);
X    else {
X        MP_INT c; int i;
X        long rm = ((1<<n) - 1) << (DIGITBITS -n);
X        mpz_init(&c); _mpz_realloc(&c,a->sz + 1);
X        for (i=0;i < a->sz; i++) {
X            c.p[i] = ((a->p[i] << n) | cc) & LMAX;
X            cc = (a->p[i] & rm) >> (DIGITBITS -n);
X        }
X        c.p[i] = cc;
X        mpz_set(c1,&c);
X        mpz_clear(&c);
X    }
}
X
void mpz_div_2exp(z,x,e) 
MP_INT *z; MP_INT *x; unsigned long e;
{
X    short sn = x->sn;
X    if (e==0)
X        mpz_set(z,x);
X    else {
X        unsigned long i;
X        long digs = (e / DIGITBITS);
X        unsigned long bs = (e % 30);
X        MP_INT y; mpz_init(&y);
X        _mpz_realloc(&y,(x->sz) - digs);
X        for (i=0; i < (x->sz - digs); i++)
X            (y.p)[i] = (x->p)[i+digs];
X        if (bs) {
X            urshift(z,&y,bs);
X        }
X        else {
X            mpz_set(z,&y);
X        }
X        if (uzero(z))
X            z->sn = 0;
X        else
X            z->sn = sn;
X        mpz_clear(&y);
X    }
}
X
void mpz_mul_2exp(z,x,e) 
MP_INT *z; MP_INT *x; unsigned long e;
{
X    short sn = x->sn;
X    if (e==0)
X        mpz_set(z,x);
X    else {
X        unsigned long i;
X        long digs = (e / DIGITBITS);
X        unsigned long bs = (e % 30);
X        MP_INT y; mpz_init(&y);
X        _mpz_realloc(&y,(x->sz)+digs);
X        for (i=digs;i<((x->sz) + digs);i++)
X            (y.p)[i] = (x->p)[i - digs];
X        if (bs) {
X            ulshift(z,&y,bs);
X        }
X        else {
X            mpz_set(z,&y);
X        }
X        z->sn = sn;
X        mpz_clear(&y);
X    }
}
X
void mpz_mod_2exp(z,x,e) 
MP_INT *z; MP_INT *x; unsigned long e;
{
X    short sn = x->sn;
X    if (e==0)
X        mpz_set_ui(z,0);
X    else {
X        unsigned long i;
X        MP_INT y;
X        long digs = (e / DIGITBITS);
X        unsigned long bs = (e % 30);
X        if (digs > x->sz || (digs == (x->sz) && bs)) {
X            mpz_set(z,x);
X            return;
X        }
X            
X        mpz_init(&y);
X        if (bs)
X            _mpz_realloc(&y,digs+1);
X        else
X            _mpz_realloc(&y,digs);
X        for (i=0; i<digs; i++)
X            (y.p)[i] = (x->p)[i];
X        if (bs) {
X            (y.p)[digs] = ((x->p)[digs]) & ((1 << bs) - 1);
X        }
X        mpz_set(z,&y);
X        if (uzero(z))
X            z->sn = 0;
X        else
X            z->sn = sn;
X        mpz_clear(&y);
X    }
}
X    
X
/* internal routine to compute x/y and x%y ignoring signs */
static void udiv(qq,rr,xx,yy)
MP_INT *qq; MP_INT *rr; MP_INT *xx; MP_INT *yy;
{
X    MP_INT *q, *x, *y, *r;
X    int ns,xd,yd,j,f,i,ccc;
X    long zz,z,qhat,b,u,m;
X    ccc=0;
X
X    if (uzero(yy))
X        return;
X    q = (MP_INT *)malloc(sizeof(MP_INT));
X    r = (MP_INT *)malloc(sizeof(MP_INT));
X    x = (MP_INT *)malloc(sizeof(MP_INT)); y = (MP_INT *)malloc(sizeof(MP_INT));
X    if (!x || !y || !q || !r)
X        fatal("udiv: cannot allocate memory");
X    mpz_init(q); mpz_init(x);mpz_init(y);mpz_init(r);
X    _mpz_realloc(x,(xx->sz)+1);
X    yd = digits(yy);
X    ns = lzb(yy->p[yd-1]);
X    ulshift(x,xx,ns);
X    ulshift(y,yy,ns);
X    xd = digits(x); 
X    _mpz_realloc(q,xd);
X    xd*=2; yd*=2;
X    z = hd(y,yd-1);;
X    for (j=(xd-yd);j>=0;j--) {
#ifdef DEBUG
X    printf("y=");
X    for (i=yd-1;i>=0;i--)
X        printf(" %04x", hd(y,i));
X    printf("\n");
X    printf("x=");
X    for (i=xd-1;i>=0;i--)
X        printf(" %04x", hd(x,i));
X    printf("\n");
X    printf("z=%08x\n",z);
#endif
X        
X        if (z == LMAX)
X            qhat = hd(x,j+yd);
X        else {
X            qhat = ((hd(x,j+yd)<< HALFDIGITBITS) + hd(x,j+yd-1)) / (z+1);
X        }
#ifdef DEBUG
X    printf("qhat=%08x\n",qhat);
X    printf("hd=%04x/%04x\n",hd(x,j+yd),hd(x,j+yd-1));
#endif
X        b = 0; zz=0;
X        if (qhat) {
X            for (i=0; i < yd; i++) {
X                zz = qhat * hd(y,i);
X                u = hd(x,i+j);
X                u-=b;
X                if (u<0) {
X                    b=1; u+=HLMAX+1;
X                }
X                else
X                    b=0;
X                u-=LOW(zz);
X                if (u < 0) {
X                    b++;
X                    u+=HLMAX+1;
X                }
X                b+=HIGH(zz);
X                if ((i+j)%2) 
X                    x->p[(i+j)/2] = LOW(x->p[(i+j)/2]) | (u << HALFDIGITBITS);
X                else
X                    x->p[(i+j)/2] = (HIGH(x->p[(i+j)/2]) << HALFDIGITBITS) | u;
X            }
X            if (b) {
X                if ((j+i)%2) 
X                    x->p[(i+j)/2] -= b << HALFDIGITBITS;
X                else
X                    x->p[(i+j)/2] -= b;
X            }
X        }
#ifdef DEBUG
X        printf("x after sub=");
X        for (i=xd-1;i>=0;i--)
X            printf(" %04x", hd(x,i));
X        printf("\n");
#endif
X        for(;;zz++) {
X            f=1;
X            if (!hd(x,j+yd)) {
X                for(i=yd-1; i>=0; i--) {
X                    if (hd(x,j+i) > hd(y,i)) {
X                        f=1;
X                        break;
X                    }
X                    if (hd(x,j+i) < hd(y,i)) {
X                        f=0;
X                        break;
X                    }
X                }
X            }
X            if (!f)
X                break;
X            qhat++;
X            ccc++;
#ifdef DEBUG
X            printf("corrected qhat = %08x\n", qhat);
#endif
X            b=0;
X            for (i=0;i<yd;i++) {
X                m = hd(x,i+j)-hd(y,i)-b;
X                if (m < 0) {
X                    b = 1;
X                    m = HLMAX + 1 + m;
X                }
X                else
X                    b = 0;
X                if ((i+j)%2) 
X                    x->p[(i+j)/2] = LOW(x->p[(i+j)/2]) | (m << HALFDIGITBITS);
X                else
X                    x->p[(i+j)/2] = (HIGH(x->p[(i+j)/2]) << HALFDIGITBITS) | m;
X            }
X            if (b) {
X                if ((j+i)%2) 
X                    x->p[(i+j)/2] -= b << HALFDIGITBITS;
X                else
X                    x->p[(i+j)/2] -= b;
X            }
#ifdef DEBUG
X            printf("x after cor=");
X            for (i=2*(x->sz)-1;i>=0;i--)
X                printf(" %04x", hd(x,i));
X            printf("\n");
#endif
X        }
X        if (j%2) 
X            q->p[j/2] |= qhat << HALFDIGITBITS;
X        else
X            q->p[j/2] |= qhat;
#ifdef DEBUG
X            printf("x after cor=");
X            for (i=xd - 1;i>=0;i--)
X                printf(" %04x", hd(q,i));
X            printf("\n");
#endif
X    }
X    _mpz_realloc(r,yy->sz);
X    zero(r);
X    urshift(r,x,ns);
X    mpz_set(rr,r);
X    mpz_set(qq,q);
X    mpz_clear(x); mpz_clear(y);
X    mpz_clear(q);  mpz_clear(r);
X    free(q); free(x); free(y); free(r);
}
X
void mpz_add(zz,x,y)
MP_INT *zz;MP_INT *x;MP_INT *y;
{
X    int mg;
X    MP_INT *z;
X    if (x->sn == 0) {
X        mpz_set(zz,y);
X        return;
X    }
X    if (y->sn == 0) {
X        mpz_set(zz,x);
X        return;
X    }
X    z = (MP_INT *)malloc(sizeof(MP_INT));
X    mpz_init(z);
X
X    if (x->sn > 0 && y->sn > 0) {
X        uadd(z,x,y); z->sn = 1;
X    }
X    else if (x->sn < 0 && y->sn < 0) {
X        uadd(z,x,y); z->sn = -1;
X    }
X    else {
X        /* signs differ */
X        if ((mg = ucmp(x,y)) == 0) {
X            zero(z);
X        }
X        else if (mg > 0) {  /* abs(y) < abs(x) */
X            usub(z,x,y);    
X            z->sn = (x->sn > 0 && y->sn < 0) ? 1 : (-1);
X        }
X        else { /* abs(y) > abs(x) */
X            usub(z,y,x);    
X            z->sn = (x->sn < 0 && y->sn > 0) ? 1 : (-1);
X        }
X    }
X    mpz_set(zz,z);
X    mpz_clear(z);
X    free(z);
}
X
void mpz_add_ui(x,y,n)
MP_INT *x;MP_INT *y; unsigned long n;
{
X    MP_INT z;
X    mpz_init_set_ui(&z,n);
X    mpz_add(x,y,&z);
X    mpz_clear(&z);
}
X
int mpz_cmp_ui(x,n)
MP_INT *x; unsigned long n;
{
X    MP_INT z; int ret;
X    mpz_init_set_ui(&z,n);
X    ret=mpz_cmp(x,&z);
X    mpz_clear(&z);
X    return ret;
}
X
int mpz_cmp_si(x,n)
MP_INT *x; long n;
{
X    MP_INT z;
X    mpz_init(&z);
X    mpz_set_si(&z,n);
X    mpz_cmp(x,&z);
X    mpz_clear(&z);
}
X
X
void mpz_mul_ui(x,y,n)
MP_INT *x;MP_INT *y; unsigned long n;
{
X    MP_INT z;
X    mpz_init_set_ui(&z,n);
X    mpz_mul(x,y,&z);
X    mpz_clear(&z);
}
X    
X    
/* z = x - y  -- just use mpz_add - I'm lazy */
void mpz_sub(z,x,y)
MP_INT *z;MP_INT *x; MP_INT *y;
{
X    MP_INT u;
X    mpz_init(&u);
X    mpz_set(&u,y);
X    u.sn = -(u.sn);
X    mpz_add(z,x,&u);
X    mpz_clear(&u);
}
X
void mpz_sub_ui(x,y,n)
MP_INT *x;MP_INT *y; unsigned long n;
{
X    MP_INT z;
X    mpz_init_set_ui(&z,n);
X    mpz_sub(x,y,&z);
X    mpz_clear(&z);
}
X
void mpz_div(q,x,y)
MP_INT *q; MP_INT *x; MP_INT *y;
{
X    MP_INT r; 
X    short sn1 = x->sn, sn2 = y->sn;
X    mpz_init(&r);
X    udiv(q,&r,x,y);
X    q->sn = sn1*sn2;
X    mpz_clear(&r);
}
X
void mpz_mdiv(q,x,y)
MP_INT *q; MP_INT *x; MP_INT *y;
{
X    MP_INT r; 
X    short sn1 = x->sn, sn2 = y->sn;
X    mpz_init(&r);
X    udiv(q,&r,x,y);
X    q->sn = sn1 * sn2;
X    /* now if r != 0 and q < 0 we need to round q towards -inf */
X    if (!uzero(&r) && q->sn < 0) 
X        mpz_sub_ui(q,q,1);
X    mpz_clear(&r);
}
X
void mpz_mod(r,x,y)
MP_INT *r; MP_INT *x; MP_INT *y;
{
X    MP_INT q;
X    short sn = x->sn;
X    mpz_init(&q);
X    if (x->sn == 0) {
X        zero(r);
X        return;
X    }
X    udiv(&q,r,x,y);
X    r->sn = sn;
X    if (uzero(r))
X        r->sn = 0;
X    mpz_clear(&q);
}
X
void mpz_divmod(q,r,x,y)
MP_INT *q; MP_INT *r; MP_INT *x; MP_INT *y;
{
X    short sn1 = x->sn, sn2 = y->sn;
X    if (x->sn == 0) {
X        zero(r);
X        return;
X    }
X    udiv(q,r,x,y);
X    q->sn = sn1*sn2;
X    r->sn = sn1;
X    if (uzero(r))
X        r->sn = 0;
}
X
void mpz_mmod(r,x,y)
MP_INT *r; MP_INT *x; MP_INT *y;
{
X    MP_INT q;
X    short sn1 = x->sn, sn2 = y->sn;
X    mpz_init(&q);
X    if (sn1 == 0) {
X        zero(r);
X        return;
X    }
X    udiv(&q,r,x,y);
X    if (uzero(r)) {
X        r->sn = 0;
X        return;
X    }
X    q.sn = sn1*sn2;
X    if (q.sn > 0) 
X        r->sn = sn1;
X    else if (sn1 < 0 && sn2 > 0) {
X        r->sn = 1;
X        mpz_sub(r,y,r);
X    }
X    else {
X        r->sn = 1;
X        mpz_add(r,y,r);
X    }
}
X
void mpz_mdivmod(q,r,x,y)
MP_INT *q;MP_INT *r; MP_INT *x; MP_INT *y;
{
X    short sn1 = x->sn, sn2 = y->sn;
X    if (sn1 == 0) {
X        zero(r);
X        return;
X    }
X    udiv(q,r,x,y);
X    q->sn = sn1*sn2;
X    if (uzero(r)) {
X        r->sn = 0;
X        return;
X    }
X    if (q->sn > 0) 
X        r->sn = sn1;
X    else if (sn1 < 0 && sn2 > 0) {
X        r->sn = 1;
X        mpz_sub(r,y,r);
X    }
X    else {
X        r->sn = 1;
X        mpz_add(r,y,r);
X    }
X    /* now if r != 0 and q < 0 we need to round q towards -inf */
X    if (!uzero(r) && q->sn < 0) 
X        mpz_sub_ui(q,q,1);
}
X
void mpz_mod_ui(x,y,n)
MP_INT *x;MP_INT *y; unsigned long n;
{
X    MP_INT z;
X    mpz_init(&z);
X    mpz_set_ui(&z,n);
X    mpz_mod(x,y,&z);
X    mpz_clear(&z);
}
X
void mpz_mmod_ui(x,y,n)
MP_INT *x;MP_INT *y; unsigned long n;
{
X    MP_INT z;
X    mpz_init(&z);
X    mpz_set_ui(&z,n);
X    mpz_mmod(x,y,&z);
X    mpz_clear(&z);
}
X
void mpz_div_ui(x,y,n)
MP_INT *x;MP_INT *y; unsigned long n;
{
X    MP_INT z;
X    mpz_init_set_ui(&z,n);
X    mpz_div(x,y,&z);
X    mpz_clear(&z);
}
X
void mpz_mdiv_ui(x,y,n)
MP_INT *x;MP_INT *y; unsigned long n;
{
X    MP_INT z;
X    mpz_init_set_ui(&z,n);
X    mpz_mdiv(x,y,&z);
X    mpz_clear(&z);
}
void mpz_divmod_ui(q,x,y,n)
MP_INT *q;MP_INT *x;MP_INT *y; unsigned long n;
{
X    MP_INT z;
X    mpz_init_set_ui(&z,n);
X    mpz_divmod(q,x,y,&z);
X    mpz_clear(&z);
}
X
void mpz_mdivmod_ui(q,x,y,n)
MP_INT *q;MP_INT *x;MP_INT *y; unsigned long n;
{
X    MP_INT z;
X    mpz_init_set_ui(&z,n);
X    mpz_mdivmod(q,x,y,&z);
X    mpz_clear(&z);
}
X
X
/* 2<=base <=36 - this overestimates the optimal value, which is OK */
unsigned int mpz_sizeinbase(x,base)
MP_INT *x; int base;
{
X    int i,j;
X    int bits = digits(x) * DIGITBITS;
X    if (base < 2 || base > 36)
X        fatal("mpz_sizeinbase: invalid base");
X    for (j=0,i=1; i<=base;i*=2,j++)
X        ;
X    return ((bits)/(j-1)+1);
}
X
char *mpz_get_str(s,base,x)
char *s;  int base; MP_INT *x; {
X    MP_INT xx,q,r,bb;
X    char *p,*t,*ps;
X    int sz = mpz_sizeinbase(x,base);
X    int d;
X    if (base < 2 || base > 36)
X        return s;
X    t = (char *)malloc(sz+2);
X    if (!t) 
X        fatal("cannot allocate memory in mpz_get_str");
X    if (!s) {
X        s=(char *)malloc(sz+2);
X        if (!s) 
X            fatal("cannot allocate memory in mpz_get_str");
X    }
X    if (uzero(x)) {
X        *s='0';
X        *(s+1)='\0';
X        return s;
X    }
X    mpz_init(&xx); mpz_init(&q); mpz_init(&r); mpz_init(&bb);
X    mpz_set(&xx,x);
X    mpz_set_ui(&bb,base);
X    ps = s;
X    if (x->sn < 0) {
X        *ps++= '-';
X        xx.sn = 1;
X    }
X    p = t;
X    while (!uzero(&xx)) {
X        udiv(&xx,&r,&xx,&bb);
X        d = r.p[0];
X        if (d < 10) 
X            *p++  = (char) (r.p[0] + '0');
X        else 
X            *p++  = (char) (r.p[0] + -10 + 'a');
X    }
X
X    p--;
X    for (;p>=t;p--,ps++)
X        *ps = *p;
X    *ps='\0';
X    
X    mpz_clear(&q); mpz_clear(&r); free(t);  
X    return s;
}
X
X
int mpz_set_str(x,s,base)
MP_INT *x; char *s; int base;
{
X    int l,i;
X    int retval = 0;
X    MP_INT t,m,bb;
X    short sn;
X    unsigned int k;
X    mpz_init(&m);
X    mpz_init(&t);
X    mpz_init(&bb);
X    mpz_set_ui(&m,1);
X    zero(x);
X    while (*s==' ' || *s=='\t' || *s=='\n')
X        s++;
X    if (*s == '-') {
X        sn = -1; s++;
X    }
X    else
X        sn = 1;
X    if (base == 0) {
X        if (*s == '0') {
X            if (*(s+1) == 'x' || *(s+1) == 'X') {
X                base = 16;
X                s+=2;   /* toss 0x */
X            }
X            else {
X                base = 8;
X                s++;    /* toss 0 */
X            }
X        }
X        else
X            base=10;
X    }
X    if (base < 2 || base > 36)
X        fatal("mpz_set_str: invalid base");
X    mpz_set_ui(&bb,base);
X    l=strlen(s);
X    for (i = l-1; i>=0; i--) {
X        if (s[i]==' ' || s[i]=='\t' || s[i]=='\n') 
X            continue;
X        if (s[i] >= '0' && s[i] <= '9')
X            k = (unsigned int)s[i] - (unsigned int)'0';
X        else if (s[i] >= 'A' && s[i] <= 'Z')
X            k = (unsigned int)s[i] - (unsigned int)'A'+10;
X        else if (s[i] >= 'a' && s[i] <= 'z')
X            k = (unsigned int)s[i] - (unsigned int)'a'+10;
X        else {
X            retval = (-1);
X            break;
X        }
X        if (k >= base) {
X            retval = (-1);
X            break;
X        }
X        mpz_mul_ui(&t,&m,k);
X        mpz_add(x,x,&t);
X        mpz_mul(&m,&m,&bb);
#ifdef DEBUG
X        printf("k=%d\n",k);
X        printf("t=%s\n",mpz_get_str(NULL,10,&t));
X        printf("x=%s\n",mpz_get_str(NULL,10,x));
X        printf("m=%s\n",mpz_get_str(NULL,10,&m));
#endif
X    }
X    if (uzero(&m))
X        x->sn = 0;
X    else 
X        x->sn = sn;
X    mpz_clear(&m);
X    mpz_clear(&bb);
X    mpz_clear(&t);
X    return retval;
}
X
void mpz_init_set_str(x,s,base)
MP_INT *x; char *s; int base;
{
X    mpz_init(x); mpz_set_str(x,s,base);
}
X
#define mpz_randombyte (rand()& 0xff)
X
void mpz_random(x,size)
MP_INT *x; unsigned int size;
{
X    unsigned int bits = size * LONGBITS;
X    unsigned int digits = bits/DIGITBITS;
X    unsigned int oflow = bits % DIGITBITS;
X    unsigned int i,j;
X    long t;
X    if (oflow)
X        digits++;
X    _mpz_realloc(x,digits);
X
X    for (i=0; i<digits; i++) {
X        t = 0;
X        for (j=0; j < DIGITBITS; j+=8)
X            t = (t << 8) | mpz_randombyte; 
X        (x->p)[i] = t & LMAX;
X    }
X    if (oflow) 
X        (x->p)[digits-1] &= ((1 << oflow) - 1);
}
void mpz_random2(x,size)
MP_INT *x; unsigned int size;
{
X    unsigned int bits = size * LONGBITS;
X    unsigned int digits = bits/DIGITBITS;
X    unsigned int oflow = bits % DIGITBITS;
X    unsigned int i,j;
X    long t;
X    if (oflow)
X        digits++;
X    _mpz_realloc(x,digits);
X
X    for (i=0; i<digits; i++) {
X        t = 0;
X        for (j=0; j < DIGITBITS; j+=8)
X            t = (t << 8) | mpz_randombyte; 
X        (x->p)[i] = (t & LMAX) % 2;
X    }
X    if (oflow) 
X        (x->p)[digits-1] &= ((1 << oflow) - 1);
}
X
size_t mpz_size(x)
MP_INT *x;
{
X    int bits = (x->sz)*DIGITBITS;
X    size_t r;
X    
X    r = bits/LONGBITS;
X    if (bits % LONGBITS)
X        r++;
X    return r;
}
X
void mpz_abs(x,y)
MP_INT *x; MP_INT *y;
{
X    if (x!=y)
X        mpz_set(x,y);
X    if (uzero(x))
X        x->sn = 0;
X    else
X        x->sn = 1;
}
X
void mpz_neg(x,y)
MP_INT *x; MP_INT *y;
{
X    if (x!=y)
X        mpz_set(x,y);
X    x->sn = -(y->sn);
}
X
void mpz_fac_ui(x,n)
MP_INT *x; unsigned long n;
{
X    mpz_set_ui(x,1);
X    if (n==0 || n == 1)
X        return;
X    for (;n>1;n--)
X        mpz_mul_ui(x,x,n);
}
X
void mpz_gcd(gg,aa,bb)
MP_INT *gg;
MP_INT *aa;
MP_INT *bb;
{
X    MP_INT *g,*t,*a,*b;
X    int freeg;
X    
X    t = (MP_INT *)malloc(sizeof(MP_INT));
X    g = (MP_INT *)malloc(sizeof(MP_INT));
X    a = (MP_INT *)malloc(sizeof(MP_INT));
X    b = (MP_INT *)malloc(sizeof(MP_INT));
X    if (!a || !b || !g || !t)
X        fatal("mpz_gcd: cannot allocate memory");
X    mpz_init(g); mpz_init(t); mpz_init(a); mpz_init(b);
X    mpz_abs(a,aa); mpz_abs(b,bb); 
X
X    while (!uzero(b)) {
X        mpz_mod(t,a,b);
X        mpz_set(a,b);
X        mpz_set(b,t);
X    }
X    
X    mpz_set(gg,a);
X    mpz_clear(g); mpz_clear(t); mpz_clear(a); mpz_clear(b);
X    free(g); free(t); free(a); free(b);
}
X
void mpz_gcdext(gg,xx,yy,aa,bb)
MP_INT *gg,*xx,*yy,*aa,*bb;
{
X    MP_INT *x, *y, *g, *u, *q;
X
X    if (uzero(bb)) {
X        mpz_set(gg,aa);
X        mpz_set_ui(xx,1);
X        if (yy)
X            mpz_set_ui(yy,0);
X        return;
X    }
X    
X    g = (MP_INT *)malloc(sizeof(MP_INT)); mpz_init(g);
X    q = (MP_INT *)malloc(sizeof(MP_INT)); mpz_init(q);
X    y = (MP_INT *)malloc(sizeof(MP_INT)); mpz_init(y);
X    x = (MP_INT *)malloc(sizeof(MP_INT)); mpz_init(x);
X    u = (MP_INT *)malloc(sizeof(MP_INT)); mpz_init(u);
X
X    if (!g || !q || !y || !x || !u)
X        fatal("mpz_gcdext: cannot allocate memory");
X
X    mpz_divmod(q,u,aa,bb);
X    mpz_gcdext(g,x,y,bb,u);
X    if (yy) {
X        mpz_mul(u,q,y);
X        mpz_sub(yy,x,u);
X    }
X    mpz_set(xx,y);
X    mpz_set(gg,g);
X    mpz_clear(g); mpz_clear(q); mpz_clear(y); mpz_clear(x); mpz_clear(u);
X    free(g); free(q); free(y); free(x); free(u);
}
X
X
/*
X *    a is a quadratic residue mod b if
X *    x^2 = a mod b      has an integer solution x.
X *
X *    J(a,b) = if a==1 then 1 else
X *             if a is even then J(a/2,b) * ((-1)^(b^2-1)/8))
X *             else J(b mod a, a) * ((-1)^((a-1)*(b-1)/4)))
X *
X *  b>0  b odd
X *
X *
X */
X
int mpz_jacobi(ac,bc)
MP_INT *ac, *bc;
{
X    int sgn = 1;
X    unsigned long c;
X    MP_INT *t,*a,*b; 
X    if (bc->sn <=0)
X        fatal("mpz_jacobi call with b <= 0");
X    if (even(bc))
X        fatal("mpz_jacobi call with b even");
X
X    init(t); init(a); init(b);
X
X    /* if ac < 0, then we use the fact that 
X     *  (-1/b)= -1 if b mod 4 == 3
X     *          +1 if b mod 4 == 1
X     */
X
X    if (mpz_cmp_ui(ac,0) < 0 && (lowdigit(bc) % 4) == 3)
X        sgn=-sgn;
X
X    mpz_abs(a,ac); mpz_set(b,bc);
X
X    /* while (a > 1) { */
X    while(mpz_cmp_ui(a,1) > 0) {
X
X        if (even(a)) {
X
X            /* c = b % 8 */
X            c = lowdigit(b) & 0x07;
X
X            /* b odd, then (b^2-1)/8 is even iff (b%8 == 3,5) */
X
X            /* if b % 8 == 3 or 5 */
X            if (c == 3 || c == 5)
X                sgn = -sgn;
X
X            /* a = a / 2 */
X            mpz_div_2exp(a,a,1); 
X
X        } 
X        else {
X            /* note: (a-1)(b-1)/4 odd iff a mod 4==b mod 4==3 */
X
X            /* if a mod 4 == 3 and b mod 4 == 3 */
X            if (((lowdigit(a) & 3) == 3) && ((lowdigit(b) & 3) == 3))
X                sgn = -sgn;
X
X            /* set (a,b) = (b mod a,a) */
X            mpz_set(t,a); mpz_mmod(a,b,t); mpz_set(b,t);
X        } 
X    }
X
X    /* if a == 0 then sgn = 0 */
X    if (uzero(a))
X        sgn=0;
X
X    clear(t); clear(a); clear(b);
X    return (sgn);
}
X
void mpz_and(z,x,y) /* not the most efficient way to do this */
MP_INT *z,*x,*y;
{
X    int i,sz;
X    sz = imax(x->sz, y->sz);
X    _mpz_realloc(z,sz);
X    for (i=0; i < sz; i++)
X        (z->p)[i] = dg(x,i) & dg(y,i);
X    if (x->sn < 0 && y->sn < 0)
X        z->sn = (-1);
X    else
X        z->sn = 1;
X    if (uzero(z))
X        z->sn = 0;
}
X
void mpz_or(z,x,y)  /* not the most efficient way to do this */
MP_INT *z,*x,*y;
{
X    int i,sz;
X    sz = imax(x->sz, y->sz);
X    _mpz_realloc(z,sz);
X    for (i=0; i < sz; i++)
X        (z->p)[i] = dg(x,i) | dg(y,i);
X    if (x->sn < 0 || y->sn < 0)
X        z->sn = (-1);
X    else
X        z->sn = 1;
X    if (uzero(z))
X        z->sn = 0;
}
X
void mpz_xor(z,x,y)  /* not the most efficient way to do this */
MP_INT *z,*x,*y;
{
X    int i,sz;
X    sz = imax(x->sz, y->sz);
X    _mpz_realloc(z,sz);
X    for (i=0; i < sz; i++)
X        (z->p)[i] = dg(x,i) ^ dg(y,i);
X    if ((x->sn <= 0 && y->sn > 0) || (x->sn > 0 && y->sn <=0))
X        z->sn = (-1);
X    else
X        z->sn = 1;
X    if (uzero(z))
X        z->sn = 0;
}
void mpz_pow_ui(zz,x,e)
MP_INT *zz, *x;
unsigned long e;
{
X    MP_INT *t;
X    unsigned long mask = (1 << (LONGBITS-1));
X    
X    if (e==0) {
X        mpz_set_ui(zz,1);
X        return;
X    }
X
X    init(t);
X    mpz_set(t,x);
X    for (;!(mask &e); mask>>=1) 
X        ;
X    mask>>=1;
X    for (;mask!=0; mask>>=1) {
X        mpz_mul(t,t,t);
X        if (e & mask)
X            mpz_mul(t,t,x);
X    }
X    mpz_set(zz,t);
X    clear(t);
}
X
void mpz_powm(zz,x,ee,n)
MP_INT *zz,*x,*ee,*n;
{
X    MP_INT *t,*e;
X    struct is *stack = NULL;
X    int k,i;
X    
X    if (uzero(ee)) {
X        mpz_set_ui(zz,1);
X        return;
X    }
X
X    if (ee->sn < 0) {
X        return;
X    }
X    init(e); init(t); mpz_set(e,ee);
X
X    for (k=0;!uzero(e);k++,mpz_div_2exp(e,e,1))
X        push(lowdigit(e) & 1,&stack);
X    k--;
X    i=pop(&stack);
X
X    mpz_mod(t,x,n);  /* t=x%n */
X
X    for (i=k-1;i>=0;i--) {
X        mpz_mul(t,t,t); 
X        mpz_mod(t,t,n);  
X        if (pop(&stack)) {
X            mpz_mul(t,t,x); 
X            mpz_mod(t,t,n);
X        }
X    }
X    mpz_set(zz,t);
X    clear(t);
}
X
void mpz_powm_ui(z,x,e,n)
MP_INT *z,*x,*n; unsigned long e;
{
X    MP_INT f;
X    mpz_init(&f);
X    mpz_set_ui(&f,e);
X    mpz_powm(z,x,&f,n);
X    mpz_clear(&f);
}
X    
X    
X
/* Miller-Rabin */
static int witness(x,n)
MP_INT *x, *n;
{
X    MP_INT *t,*e, *e1;
X    struct is *stack = NULL;
X    int trivflag = 0;
X    int k,i;
X    
X    init(e1); init(e); init(t); mpz_sub_ui(e,n,1); mpz_set(e1,e);
X
X    for (k=0;!uzero(e);k++,mpz_div_2exp(e,e,1))
X        push(lowdigit(e) & 1,&stack);
X    k--;
X    i=pop(&stack);
X
X    mpz_mod(t,x,n);  /* t=x%n */
X
X    for (i=k-1;i>=0;i--) {
X        trivflag = !mpz_cmp_ui(t,1) || !mpz_cmp(t,e1);
X        mpz_mul(t,t,t); mpz_mod(t,t,n);  
X        if (!trivflag && !mpz_cmp_ui(t,1)) {
X            clear(t); clear(e); clear(e1);
X            return 1;
X        }
X            
X        if (pop(&stack)) {
X            mpz_mul(t,t,x); 
X            mpz_mod(t,t,n);
X        }
X    }
X    if (mpz_cmp_ui(t,1))  { /* t!=1 */
X        clear(t); clear(e); clear(e1);
X        return 1;
X    }
X    else {
X        clear(t); clear(e); clear(e1);
X        return 0;
X    }
}
X
unsigned int smallp[] = {2,3,5,7,11,13,17};
int mpz_probab_prime_p(nn,s)
MP_INT *nn; int s;
{   
X    MP_INT *a,*n;
X    int j,k,i;
X    long t;
X
X    if (uzero(nn))
X        return 0;
X    init(n); mpz_abs(n,nn);
X    if (!mpz_cmp_ui(n,1)) {
X        clear(n);
X        return 0;
X    }
X    init(a);
X    for (i=0;i<sizeof(smallp)/sizeof(unsigned int); i++) {
X        mpz_mod_ui(a,n,smallp[i]);
X        if (uzero(a)) {
X            clear(a); clear(n); return 0;
X        }
X    }
X    _mpz_realloc(a,n->sz);
X    for (k=0; k<s; k++) {
X
X        /* generate a "random" a */
X            for (i=0; i<n->sz; i++) {
X                t = 0;
X                for (j=0; j < DIGITBITS; j+=8)
X                    t = (t << 8) | mpz_randombyte; 
X                (a->p)[i] = t & LMAX;
X            }
X            a->sn = 1;
X            mpz_mod(a,a,n);
X
X        if (witness(a,n)) {
X            clear(a); clear(n);
X            return 0;
X        }
X    }
X    clear(a);clear(n);
X    return 1;
}   
SHAR_EOF
chmod 0600 gmp.c ||
echo 'restore of gmp.c failed'
Wc_c="`wc -c < 'gmp.c'`"
test 33551 -eq "$Wc_c" ||
	echo 'gmp.c: original size 33551, current size' "$Wc_c"
fi
exit 0
