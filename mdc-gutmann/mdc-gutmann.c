From msuinfo!caen!uwm.edu!cs.utexas.edu!uunet!comp.vuw.ac.nz!waikato.ac.nz!aukuni.ac.nz!cs18.cs.aukuni.ac.nz!pgut1 Mon Oct 26 18:42:23 1992
Path: msuinfo!caen!uwm.edu!cs.utexas.edu!uunet!comp.vuw.ac.nz!waikato.ac.nz!aukuni.ac.nz!cs18.cs.aukuni.ac.nz!pgut1
Newsgroups: sci.crypt
Subject: MDC cipher code (long)
Message-ID: <1992Oct22.063349.28189@cs.aukuni.ac.nz>
From: pgut1@cs.aukuni.ac.nz (Peter Gutmann)
Date: Thu, 22 Oct 1992 06:33:49 GMT
Organization: Computer Science Dept. University of Auckland
Organisation: HPACK Conspiracy Secret Laboratory
Lines: 1432

I posted the following code a few months ago, since then I've revised it
somewhat, cleaned it up a bit, and removed some endianness-related problems
the original code had.  It's been tested (as part of a larger encryption
program) under Aix, Irix, the Macintosh, MSDOS, OS/2, SunOS, and Ultrix, and
compiled (but not tested much) on an Amiga, Archimedes, and Atari ST.

The code is a means of turning one-way hash functions into a secret-key
cipher run in CFB mode.  The cipher runs virtually as fast as the hash
function, and is as secure as the hash function (in fact it should be more
secure - hash functions can be "broken" by finding a collision, whereas the
cipher requires the reversing of the function).

The code below uses the MD5 message digest algorithm, with the Mysterious
Constants replaced with key-dependant values (you could also use SHS/SHA if
you wanted, but regular readers of sci.crypt will probably know my opinion of
SHA vs MD5 :-).  Normally the constants are defined as:

>      In step i, the additive constant is the integer part of
>      4294967296 times abs(sin(i)), where i is in radians.

The cipher, called MDC (Message Digest Cipher), simply uses constants derived
from a user-supplied key instead.  The key setup is basically the same as
that used in my NSEA cipher code, with the Mysterious Constants being
generated by running MD5 over a buffer containing the user key, with the MD5
initial value being set to the IV.  These are then substituted for the
standard MD5 constants to create the MDC function.

I believe that using a one-way hash function in this manner makes more sense
than using a true cipher since, when used in CFB mode, the cipher is simply
acting as a hash function anyway.

I've asked Ron Rivest, the inventor of MD5, for his comments on MDC, and he
was of the opinion that changing the mysterious constants to other (random)
values would not weaken MD5, and that if both the input and output values (or
many such) are known (ie as part of a chosen plaintext attack), there isn't
any way of recovering the constants.  On the other hand he says he hasn't
thought about this option too much (MDC is a pretty strange way to use a
message digest algorithm :-).

None of the following code is patented or restricted in any way.  The MD5
code has been placed in the public domain by it's authors, and any additional
code I've added as well as the MDC support routines are also in the public
domain.  In addition, the MD5 code is *not* covered by US export restrictions
since it can't be used as general purpose-encryption code (well, until now
anyway :-).

To compile the code, you need to tell it what endianness the machine you're
running on is.  Do this with -DBIG_ENDIAN (the default), or -DLITTLE_ENDIAN.
The code can be made endianness-independant, but this results in a
significant speed penalty.  Also, the MD5Transform() routine in the MD5 code
breaks some compilers, specifically the Irix cc, TopSpeed C under MSDOS/OS2,
Norcroft C on the Archimedes, and Ultrix vcc.  To avoid this, define IRIX,
__ARC__, __TSC__. or VCC as appropriate to compile a version which has been
broken up into 4 seperate passes.  If your compiler grinds to a halt
compiling the MD5 code, you'll have to add it to the list, as well as
emailing me so I can update my copy of the code.

In addition to the default simple encryption program, the following compile
options are possible:

    TIME_TRIAL  - Encrypt 10MB of data for timing purposes
    SETUP_TRIAL - Perform 100 key setup operations for timing purposes
    TEST_VERSION- Output test encryption values.

When compiled with -DTEST_VERSION, the output of the program is:

Key 00000000000000000000000000000000, data 00000000000000000000000000000000:
    88D742CF859F94B635EF18A77FD7D4A0
Key FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF, data FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF:
    1E9285C7A8101E22ACFC714E20762139
Key 00000000000000000000000000000001, data 00000000000000000000000000000000:
    F5F8A1E03129495961C67445F2CE4CCF
Key 00000000000000000000000000000000, data 00000000000000000000000000000001:
    60B4DC803BC5BEF1DEBED86E66B8437A
Key 80000000000000000000000000000000, data 00000000000000000000000000000000:
    875C20E8494995F3E3005E086DA3EFAA
Key 00000000000000000000000000000000, data 80000000000000000000000000000000:
    A41DD80386C1808EE7711C08BF5CEA7F
Key FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF, data 00000000000000000000000000000000:
    782B37AB38DAEFF43BD6BC7D2965B4F9
Key 00000000000000000000000000000000, data FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF:
    9F564E42DACB42DBF21C57C092285896
Key FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF, data 00000000000000000000000000000001:
    5AE30BE155C55FBDA5CC4D4F17B42FCE
Key 00000000000000000000000000000001, data FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF:
    3D8A26A7EEFEF1D0030A0127D4700149
Key 01010101010101010101010101010101, data 01010101010101010101010101010101:
    1F9C8A65F2DF350CB1ADEE5BB10286E7
Key 80808080808080808080808080808080, data 80808080808080808080808080808080:
    D34C2406770463D01EB95895F74E0A75
Key 0123456789ABCDEFFEDCBA9876543210, data 0123456789ABCDEFFEDCBA9876543210:
    434EDED2A66F7171756D467B57614623
Key FEDCBA98765432100123456789ABCDEF, data FEDCBA98765432100123456789ABCDEF:
    7697FF47E42AA04CEEB1C768D9DE2786

If you get values like:

Key 00000000000000000000000000000000, data 00000000000000000000000000000000:
    FA425D688965BFF194F68135D75A32B7
Key FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF, data FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF:
    30F23F7D205842B46CF6D66CC2CB8AB0
[etc]

then the CPU endianness define has been set wrong.

These test values can be used to check things are running properly.  In
addition the MDC/MD5 output can be compared against the unmodified MD5 code
output for accuracy.

Comments, flames, etc to pgut1@cs.aukuni.ac.nz.

Oh yes, I use tabs of 4 (':set tabstop=4' in vi), pipe it through 'expand' if
this is a problem.
    ------------------------------- 8< -------------------------------
#!/bin/sh
# to extract, remove the header and type "sh filename"
if `test ! -s ./md5.h`
then
echo "writing ./md5.h"
cat > ./md5.h << '\End\Of\Shar\'
#ifndef _MD5_DEFINED

#define _MD5_DEFINED

/* Some useful defines which always end up in my code */

typedef unsigned char	BYTE;
typedef unsigned short	WORD;
typedef unsigned long	LONG;

typedef char			BOOLEAN;

#define TRUE	1
#define FALSE	0

#define ERROR	-1
#define OK		0

/****************************************************************************
*																			*
*			RSA Data Security, Inc. MD5 Message-Digest Algorithm			*
*  Created 2/17/90 RLR, revised 12/27/90 SRD,AJ,BSK,JT Reference C version	*
*	Revised (for MD5) RLR 4/27/91: G modified to have y&~z instead of y&z,	*
* FF, GG, HH modified to add in last register done, access pattern: round 2 *
*	works mod 5, round 3 works mod 3, distinct additive constant for each	*
*					step round 4 added, working mod 7						*
*																			*
****************************************************************************/

/* The size of an MD5 data block and the number of rounds in the MD5 transformation */

#define MD5_BLOCKSIZE	64
#define MD5_ROUNDS		64

/* Data structure for MD5 computation */

typedef struct {
			   LONG i[ 2 ];			/* Number of bits handled mod 2^64 */
			   LONG buf[ 4 ];		/* Scratch buffer */
			   BYTE in[ MD5_BLOCKSIZE ];	/* Input buffer */
			   BYTE digest[ 16 ];	/* Actual digest after MD5Final() call */
			   } MD5_CTX;

/* Message digest functions */

void MD5SetConst( BYTE *buffer );
void MD5Init( MD5_CTX *mdContext );
void MD5Update( MD5_CTX *mdContext, BYTE *buffer, unsigned int noBytes );
void MD5Final( MD5_CTX *mdContext );

#endif /* _MD5_DEFINED */\End\Of\Shar\
else
  echo "will not over write ./md5.h"
fi
if [ `wc -c ./md5.h | awk '{printf $1}'` -ne 1563 ]
then
echo `wc -c ./md5.h | awk '{print "Got " $1 ", Expected " 1563}'`
fi
if `test ! -s ./md5.c`
then
echo "writing ./md5.c"
cat > ./md5.c << '\End\Of\Shar\'
/****************************************************************************
*																			*
*							HPACK Multi-System Archiver						*
*							===========================						*
*																			*
*							  MD5 Message Digest Code						*
*							  MD5.C  Updated 02/10/91						*
*																			*
* This program is protected by copyright and as such any use or copying of	*
*  this code for your own purposes directly or indirectly is highly uncool	*
*  					and if you do so there will be....trubble.				*
* 				And remember: We know where your kids go to school.			*
*																			*
*			Copyright 1991  Peter C.Gutmann.  All rights reserved			*
*																			*
****************************************************************************/

#include <stdlib.h>
#include <string.h>
#include "md5.h"

/****************************************************************************
*																			*
*	Implementation RSA Data Security, Inc. MD5 Message-Digest Algorithm		*
*	Created 2/17/90 RLR, revised 1/91 SRD,AJ,BSK,JT Reference C Version		*
*	  Copyright (C) 1990, RSA Data Security, Inc. All rights reserved		*
*																			*
****************************************************************************/

/* Define the following to use the assembly-language version of MDTransform().
   This is desirable since MDTransform() uses many rotates which cannot be
   easily represented in C and must be done inefficiently via shifts */

#ifdef __MSDOS__
  #define ASM_MD5
#endif /* __MSDOS__ */

#ifdef ASM_MD5
  void MD5Transform( LONG *buf, LONG *in );
#endif /* ASM_MD5 */

/* To form the message digest for a message M, initialize a context buffer
   mdContext using MD5Init(); call MD5Update() on mdContext and M; and call
   MD5Final() on mdContext.  The message digest is now in
   mdContext->digest[ 0 ... 15 ] */

/****************************************************************************
*																			*
*							The MD5 Transformation							*
*																			*
****************************************************************************/

/* The Mysterious Constants used in the MD5 transformation */

static LONG md5const[] = { 3614090360L, 3905402710L,  606105819L, 3250441966L,
						   4118548399L, 1200080426L, 2821735955L, 4249261313L,
						   1770035416L, 2336552879L, 4294925233L, 2304563134L,
						   1804603682L, 4254626195L, 2792965006L, 1236535329L,
						   4129170786L, 3225465664L,  643717713L, 3921069994L,
						   3593408605L,   38016083L, 3634488961L, 3889429448L,
							568446438L, 3275163606L, 4107603335L, 1163531501L,
						   2850285829L, 4243563512L, 1735328473L, 2368359562L,
						   4294588738L, 2272392833L, 1839030562L, 4259657740L,
						   2763975236L, 1272893353L, 4139469664L, 3200236656L,
							681279174L, 3936430074L, 3572445317L,   76029189L,
						   3654602809L, 3873151461L,  530742520L, 3299628645L,
						   4096336452L, 1126891415L, 2878612391L, 4237533241L,
						   1700485571L, 2399980690L, 4293915773L, 2240044497L,
						   1873313359L, 4264355552L, 2734768916L, 1309151649L,
						   4149444226L, 3174756917L,  718787259L, 3951481745L };
/* Storage for the Mysterious Constants (either md5const or user-defined) */

LONG mConst[ MD5_ROUNDS ];

#ifndef ASM_MD5

/* F, G, H and I are basic MD5 functions */

#define F(X,Y,Z)	( ( X & Y ) | ( ~X & Z ) )
#define G(X,Y,Z)	( ( X & Z ) | ( Y & ~Z ) )
#define H(X,Y,Z)	( X ^ Y ^ Z )
#define I(X,Y,Z)	( Y ^ ( X | ~Z ) )

/* ROTATE_LEFT rotates x left n bits */

#define ROTATE_LEFT(x,n)	( ( x << n ) | ( x >> ( 32 - n ) ) )

/* FF, GG, HH, and II transformations for rounds 1, 2, 3, and 4.  Rotation is
   separate from addition to prevent recomputation */

#define FF(A,B,C,D,X,shiftAmt,magicConst) \
	{ \
	A += F( B, C, D ) + X + magicConst; \
	A = ROTATE_LEFT( A, shiftAmt ); \
	A += B; \
	}

#define GG(A,B,C,D,X,shiftAmt,magicConst) \
	{ \
	A += G( B, C, D ) + X + magicConst; \
	A = ROTATE_LEFT( A, shiftAmt ); \
	A += B; \
	}

#define HH(A,B,C,D,X,shiftAmt,magicConst) \
	{ \
	A += H( B, C, D ) + X + magicConst; \
	A = ROTATE_LEFT( A, shiftAmt ); \
	A += B; \
	}

#define II(A,B,C,D,X,shiftAmt,magicConst) \
	{ \
	A += I( B, C, D ) + X + magicConst; \
	A = ROTATE_LEFT( A, shiftAmt ); \
	A += B; \
	}

/* Round 1 shift amounts */

#define S11	7
#define S12	12
#define S13	17
#define S14	22

/* Round 2 shift amounts */

#define S21 5
#define S22 9
#define S23 14
#define S24 20

/* Round 3 shift amounts */

#define S31 4
#define S32 11
#define S33 16
#define S34 23

/* Round 4 shift amounts */

#define S41 6
#define S42 10
#define S43 15
#define S44 21

/* Basic MD5 step. Transforms buf based on in.  Note that if the Mysterious
   Constants are arranged backwards in little-endian order and decrypted with
   the DES they produce OCCULT MESSAGES! */

#if defined( __ARC__ ) || defined( IRIX ) || defined( __TSC__ )

/* MD5Transform is split into its component rounds since many optimizers
   choke on the grand unified version */

static void MD5TransformRound1( LONG *A, LONG *B, LONG *C, LONG *D, LONG *in )
	{
	/* Round 1 */
	FF( *A, *B, *C, *D, in[  0 ], S11, mConst[  0 ] );	/*  1 */
	FF( *D, *A, *B, *C, in[  1 ], S12, mConst[  1 ] );	/*  2 */
	FF( *C, *D, *A, *B, in[  2 ], S13, mConst[  2 ] );	/*  3 */
	FF( *B, *C, *D, *A, in[  3 ], S14, mConst[  3 ] );	/*  4 */
	FF( *A, *B, *C, *D, in[  4 ], S11, mConst[  4 ] );	/*  5 */
	FF( *D, *A, *B, *C, in[  5 ], S12, mConst[  5 ] );	/*  6 */
	FF( *C, *D, *A, *B, in[  6 ], S13, mConst[  6 ] );	/*  7 */
	FF( *B, *C, *D, *A, in[  7 ], S14, mConst[  7 ] );	/*  8 */
	FF( *A, *B, *C, *D, in[  8 ], S11, mConst[  8 ] );	/*  9 */
	FF( *D, *A, *B, *C, in[  9 ], S12, mConst[  9 ] );	/* 10 */
	FF( *C, *D, *A, *B, in[ 10 ], S13, mConst[ 10 ] );	/* 11 */
	FF( *B, *C, *D, *A, in[ 11 ], S14, mConst[ 11 ] );	/* 12 */
	FF( *A, *B, *C, *D, in[ 12 ], S11, mConst[ 12 ] );	/* 13 */
	FF( *D, *A, *B, *C, in[ 13 ], S12, mConst[ 13 ] );	/* 14 */
	FF( *C, *D, *A, *B, in[ 14 ], S13, mConst[ 14 ] );	/* 15 */
	FF( *B, *C, *D, *A, in[ 15 ], S14, mConst[ 15 ] );	/* 16 */
	}

static void MD5TransformRound2( LONG *A, LONG *B, LONG *C, LONG *D, LONG *in )
	{
	/* Round 2 */
	GG( *A, *B, *C, *D, in[  1 ], S21, mConst[ 16 ] );	/* 17 */
	GG( *D, *A, *B, *C, in[  6 ], S22, mConst[ 17 ] );	/* 18 */
	GG( *C, *D, *A, *B, in[ 11 ], S23, mConst[ 18 ] );	/* 19 */
	GG( *B, *C, *D, *A, in[  0 ], S24, mConst[ 19 ] );	/* 20 */
	GG( *A, *B, *C, *D, in[  5 ], S21, mConst[ 20 ] );	/* 21 */
	GG( *D, *A, *B, *C, in[ 10 ], S22, mConst[ 21 ] );	/* 22 */
	GG( *C, *D, *A, *B, in[ 15 ], S23, mConst[ 22 ] );	/* 23 */
	GG( *B, *C, *D, *A, in[  4 ], S24, mConst[ 23 ] );	/* 24 */
	GG( *A, *B, *C, *D, in[  9 ], S21, mConst[ 24 ] );	/* 25 */
	GG( *D, *A, *B, *C, in[ 14 ], S22, mConst[ 25 ] );	/* 26 */
	GG( *C, *D, *A, *B, in[  3 ], S23, mConst[ 26 ] );	/* 27 */
	GG( *B, *C, *D, *A, in[  8 ], S24, mConst[ 27 ] );	/* 28 */
	GG( *A, *B, *C, *D, in[ 13 ], S21, mConst[ 28 ] );	/* 29 */
	GG( *D, *A, *B, *C, in[  2 ], S22, mConst[ 29 ] );	/* 30 */
	GG( *C, *D, *A, *B, in[  7 ], S23, mConst[ 30 ] );	/* 31 */
	GG( *B, *C, *D, *A, in[ 12 ], S24, mConst[ 31 ] );	/* 32 */
	}

static void MD5TransformRound3( LONG *A, LONG *B, LONG *C, LONG *D, LONG *in )
	{
	/* Round 3 */
	HH( *A, *B, *C, *D, in[  5 ], S31, mConst[ 32 ] );	/* 33 */
	HH( *D, *A, *B, *C, in[  8 ], S32, mConst[ 33 ] );	/* 34 */
	HH( *C, *D, *A, *B, in[ 11 ], S33, mConst[ 34 ] );	/* 35 */
	HH( *B, *C, *D, *A, in[ 14 ], S34, mConst[ 35 ] );	/* 36 */
	HH( *A, *B, *C, *D, in[  1 ], S31, mConst[ 36 ] );	/* 37 */
	HH( *D, *A, *B, *C, in[  4 ], S32, mConst[ 37 ] );	/* 38 */
	HH( *C, *D, *A, *B, in[  7 ], S33, mConst[ 38 ] );	/* 39 */
	HH( *B, *C, *D, *A, in[ 10 ], S34, mConst[ 39 ] );	/* 40 */
	HH( *A, *B, *C, *D, in[ 13 ], S31, mConst[ 40 ] );	/* 41 */
	HH( *D, *A, *B, *C, in[  0 ], S32, mConst[ 41 ] );	/* 42 */
	HH( *C, *D, *A, *B, in[  3 ], S33, mConst[ 42 ] );	/* 43 */
	HH( *B, *C, *D, *A, in[  6 ], S34, mConst[ 43 ] );	/* 44 */
	HH( *A, *B, *C, *D, in[  9 ], S31, mConst[ 44 ] );	/* 45 */
	HH( *D, *A, *B, *C, in[ 12 ], S32, mConst[ 45 ] );	/* 46 */
	HH( *C, *D, *A, *B, in[ 15 ], S33, mConst[ 46 ] );	/* 47 */
	HH( *B, *C, *D, *A, in[  2 ], S34, mConst[ 47 ] );	/* 48 */
	}

static void MD5TransformRound4( LONG *A, LONG *B, LONG *C, LONG *D, LONG *in )
	{
	/* Round 4 */
	II( *A, *B, *C, *D, in[  0 ], S41, mConst[ 48 ] );	/* 49 */
	II( *D, *A, *B, *C, in[  7 ], S42, mConst[ 49 ] );	/* 50 */
	II( *C, *D, *A, *B, in[ 14 ], S43, mConst[ 50 ] );	/* 51 */
	II( *B, *C, *D, *A, in[  5 ], S44, mConst[ 51 ] );	/* 52 */
	II( *A, *B, *C, *D, in[ 12 ], S41, mConst[ 52 ] );	/* 53 */
	II( *D, *A, *B, *C, in[  3 ], S42, mConst[ 53 ] );	/* 54 */
	II( *C, *D, *A, *B, in[ 10 ], S43, mConst[ 54 ] );	/* 55 */
	II( *B, *C, *D, *A, in[  1 ], S44, mConst[ 55 ] );	/* 56 */
	II( *A, *B, *C, *D, in[  8 ], S41, mConst[ 56 ] );	/* 57 */
	II( *D, *A, *B, *C, in[ 15 ], S42, mConst[ 57 ] );	/* 58 */
	II( *C, *D, *A, *B, in[  6 ], S43, mConst[ 58 ] );	/* 59 */
	II( *B, *C, *D, *A, in[ 13 ], S44, mConst[ 59 ] );	/* 60 */
	II( *A, *B, *C, *D, in[  4 ], S41, mConst[ 60 ] );	/* 61 */
	II( *D, *A, *B, *C, in[ 11 ], S42, mConst[ 61 ] );	/* 62 */
	II( *C, *D, *A, *B, in[  2 ], S43, mConst[ 62 ] );	/* 63 */
	II( *B, *C, *D, *A, in[  9 ], S44, mConst[ 63 ] );	/* 64 */
	}

void MD5Transform( LONG *buf, LONG *in )
	{
	LONG A = buf[ 0 ], B = buf[ 1 ], C = buf[ 2 ], D = buf[ 3 ];

	MD5TransformRound1 (&A, &B, &C, &D, in);
	MD5TransformRound2 (&A, &B, &C, &D, in);
	MD5TransformRound3 (&A, &B, &C, &D, in);
	MD5TransformRound4 (&A, &B, &C, &D, in);

	buf[ 0 ] += A;
	buf[ 1 ] += B;
	buf[ 2 ] += C;
	buf[ 3 ] += D;
	}

#else

void MD5Transform( LONG *buf, LONG *in )
	{
	LONG A = buf[ 0 ], B = buf[ 1 ], C = buf[ 2 ], D = buf[ 3 ];

	/* Round 1 */
	FF( A, B, C, D, in[  0 ], S11, mConst[  0 ] );	/*  1 */
	FF( D, A, B, C, in[  1 ], S12, mConst[  1 ] );	/*  2 */
	FF( C, D, A, B, in[  2 ], S13, mConst[  2 ] );	/*  3 */
	FF( B, C, D, A, in[  3 ], S14, mConst[  3 ] );	/*  4 */
	FF( A, B, C, D, in[  4 ], S11, mConst[  4 ] );	/*  5 */
	FF( D, A, B, C, in[  5 ], S12, mConst[  5 ] );	/*  6 */
	FF( C, D, A, B, in[  6 ], S13, mConst[  6 ] );	/*  7 */
	FF( B, C, D, A, in[  7 ], S14, mConst[  7 ] );	/*  8 */
	FF( A, B, C, D, in[  8 ], S11, mConst[  8 ] );	/*  9 */
	FF( D, A, B, C, in[  9 ], S12, mConst[  9 ] );	/* 10 */
	FF( C, D, A, B, in[ 10 ], S13, mConst[ 10 ] );	/* 11 */
	FF( B, C, D, A, in[ 11 ], S14, mConst[ 11 ] );	/* 12 */
	FF( A, B, C, D, in[ 12 ], S11, mConst[ 12 ] );	/* 13 */
	FF( D, A, B, C, in[ 13 ], S12, mConst[ 13 ] );	/* 14 */
	FF( C, D, A, B, in[ 14 ], S13, mConst[ 14 ] );	/* 15 */
	FF( B, C, D, A, in[ 15 ], S14, mConst[ 15 ] );	/* 16 */

	/* Round 2 */
	GG( A, B, C, D, in[  1 ], S21, mConst[ 16 ] );	/* 17 */
	GG( D, A, B, C, in[  6 ], S22, mConst[ 17 ] );	/* 18 */
	GG( C, D, A, B, in[ 11 ], S23, mConst[ 18 ] );	/* 19 */
	GG( B, C, D, A, in[  0 ], S24, mConst[ 19 ] );	/* 20 */
	GG( A, B, C, D, in[  5 ], S21, mConst[ 20 ] );	/* 21 */
	GG( D, A, B, C, in[ 10 ], S22, mConst[ 21 ] );	/* 22 */
	GG( C, D, A, B, in[ 15 ], S23, mConst[ 22 ] );	/* 23 */
	GG( B, C, D, A, in[  4 ], S24, mConst[ 23 ] );	/* 24 */
	GG( A, B, C, D, in[  9 ], S21, mConst[ 24 ] );	/* 25 */
	GG( D, A, B, C, in[ 14 ], S22, mConst[ 25 ] );	/* 26 */
	GG( C, D, A, B, in[  3 ], S23, mConst[ 26 ] );	/* 27 */
	GG( B, C, D, A, in[  8 ], S24, mConst[ 27 ] );	/* 28 */
	GG( A, B, C, D, in[ 13 ], S21, mConst[ 28 ] );	/* 29 */
	GG( D, A, B, C, in[  2 ], S22, mConst[ 29 ] );	/* 30 */
	GG( C, D, A, B, in[  7 ], S23, mConst[ 30 ] );	/* 31 */
	GG( B, C, D, A, in[ 12 ], S24, mConst[ 31 ] );	/* 32 */

	/* Round 3 */
	HH( A, B, C, D, in[  5 ], S31, mConst[ 32 ] );	/* 33 */
	HH( D, A, B, C, in[  8 ], S32, mConst[ 33 ] );	/* 34 */
	HH( C, D, A, B, in[ 11 ], S33, mConst[ 34 ] );	/* 35 */
	HH( B, C, D, A, in[ 14 ], S34, mConst[ 35 ] );	/* 36 */
	HH( A, B, C, D, in[  1 ], S31, mConst[ 36 ] );	/* 37 */
	HH( D, A, B, C, in[  4 ], S32, mConst[ 37 ] );	/* 38 */
	HH( C, D, A, B, in[  7 ], S33, mConst[ 38 ] );	/* 39 */
	HH( B, C, D, A, in[ 10 ], S34, mConst[ 39 ] );	/* 40 */
	HH( A, B, C, D, in[ 13 ], S31, mConst[ 40 ] );	/* 41 */
	HH( D, A, B, C, in[  0 ], S32, mConst[ 41 ] );	/* 42 */
	HH( C, D, A, B, in[  3 ], S33, mConst[ 42 ] );	/* 43 */
	HH( B, C, D, A, in[  6 ], S34, mConst[ 43 ] );	/* 44 */
	HH( A, B, C, D, in[  9 ], S31, mConst[ 44 ] );	/* 45 */
	HH( D, A, B, C, in[ 12 ], S32, mConst[ 45 ] );	/* 46 */
	HH( C, D, A, B, in[ 15 ], S33, mConst[ 46 ] );	/* 47 */
	HH( B, C, D, A, in[  2 ], S34, mConst[ 47 ] );	/* 48 */

	/* Round 4 */
	II( A, B, C, D, in[  0 ], S41, mConst[ 48 ] );	/* 49 */
	II( D, A, B, C, in[  7 ], S42, mConst[ 49 ] );	/* 50 */
	II( C, D, A, B, in[ 14 ], S43, mConst[ 50 ] );	/* 51 */
	II( B, C, D, A, in[  5 ], S44, mConst[ 51 ] );	/* 52 */
	II( A, B, C, D, in[ 12 ], S41, mConst[ 52 ] );	/* 53 */
	II( D, A, B, C, in[  3 ], S42, mConst[ 53 ] );	/* 54 */
	II( C, D, A, B, in[ 10 ], S43, mConst[ 54 ] );	/* 55 */
	II( B, C, D, A, in[  1 ], S44, mConst[ 55 ] );	/* 56 */
	II( A, B, C, D, in[  8 ], S41, mConst[ 56 ] );	/* 57 */
	II( D, A, B, C, in[ 15 ], S42, mConst[ 57 ] );	/* 58 */
	II( C, D, A, B, in[  6 ], S43, mConst[ 58 ] );	/* 59 */
	II( B, C, D, A, in[ 13 ], S44, mConst[ 59 ] );	/* 60 */
	II( A, B, C, D, in[  4 ], S41, mConst[ 60 ] );	/* 61 */
	II( D, A, B, C, in[ 11 ], S42, mConst[ 61 ] );	/* 62 */
	II( C, D, A, B, in[  2 ], S43, mConst[ 62 ] );	/* 63 */
	II( B, C, D, A, in[  9 ], S44, mConst[ 63 ] );	/* 64 */

	buf[ 0 ] += A;
	buf[ 1 ] += B;
	buf[ 2 ] += C;
	buf[ 3 ] += D;
	}
#endif /* __ARC__ || IRIX || __TSC__ */

#endif /* ASM_MD5 */

/****************************************************************************
*																			*
*							MD5 Support Routines							*
*																			*
****************************************************************************/

#ifdef LITTLE_ENDIAN

#ifdef ASM_MD5
  void longReverse( LONG *buffer, int byteCount );
#else

/* When run on a little-endian CPU we need to perform byte reversal on an
   array of longwords.  It is possible to make the code endianness-
   independant by fiddling around with data at the byte level, but this
   makes for very slow code, so we rely on the user to sort out endianness
   at compile time */

void longReverse( LONG *buffer, int byteCount )
	{
	LONG value;

	byteCount /= sizeof( LONG );
	while( byteCount-- )
		{
		value = ( *buffer << 16 ) | ( *buffer >> 16 );
		*buffer++ = ( ( value & 0xFF00FF00L ) >> 8 ) | ( ( value & 0x00FF00FFL ) << 8 );
		}
	}
#endif /* ASM_MD5 */

#endif /* LITTLE_ENDIAN */

/* The external buffer for saving the Mysterious Constants.  Since the MD5/
   MDC code is dual-use, we need to save the constants whenever we switch
   from MDC to MD5 */

extern BYTE cryptBuffer[];

/* The routine MD5SetConst sets the Mysterious Constants to either the
   standard MD5 ones or to a user-defined set for MDC */

static BOOLEAN isMD5const = FALSE;

void MD5SetConst( BYTE *buffer )
	{
	if( buffer == NULL )
		{
		/* If the constants are already set up, don't bother re-setting them */
		if( !isMD5const )
			{
			memcpy( mConst, md5const, MD5_ROUNDS * sizeof( LONG ) );
			isMD5const = TRUE;
			}
		}
	else
		{
		/* Copy the values to the mConst array, with endianness conversion
		   if necessary */
		memcpy( mConst, buffer, MD5_ROUNDS * sizeof( LONG ) );
#ifdef LITTLE_ENDIAN
		longReverse( mConst, MD5_ROUNDS * sizeof( LONG ) );
#endif /* LITTLE_ENDIAN */
		isMD5const = FALSE;
		}
	}

/* The routine MD5Init initializes the message-digest context mdContext. All
   fields are set to zero */

void MD5Init( MD5_CTX *mdContext )
	{
	mdContext->i[ 0 ] = mdContext->i[ 1 ] = 0L;

	/* Load magic initialization constants */
	mdContext->buf[ 0 ] = 0x67452301L;
	mdContext->buf[ 1 ] = 0xEFCDAB89L;
	mdContext->buf[ 2 ] = 0x98BADCFEL;
	mdContext->buf[ 3 ] = 0x10325476L;

	/* Set up the Mysterious Constants if necessary */
	if( !isMD5const )
		{
		memcpy( cryptBuffer, mConst, MD5_ROUNDS * sizeof( LONG ) );
		MD5SetConst( NULL );
		}
	}

/* The routine MD5Update updates the message-digest context to account for
   the presence of each of the characters inBuf[ 0 .. inLen-1 ] in the
   message whose digest is being computed.  This is an optimized version
   which assumes that the buffer is a multiple of MD5_BLOCKSIZE bytes long */

#ifdef __MSDOS__

void MD5Update( MD5_CTX *mdContext, BYTE *buffer, unsigned int noBytes )
	{
	int bufIndex = 0;

	/* Update number of bits */
	if( ( mdContext->i[ 0 ] + ( ( LONG ) noBytes << 3 ) ) < mdContext->i[ 0 ] )
		mdContext->i[ 1 ]++;	/* Carry from low to high bitCount */
	mdContext->i[ 0 ] += ( ( LONG ) noBytes << 3 );
	mdContext->i[ 1 ] += ( ( LONG ) noBytes >> 29 );

	/* Process data in MD5_BLOCKSIZE chunks */
	while( noBytes >= MD5_BLOCKSIZE )
		{
		MD5Transform( mdContext->buf, ( LONG * ) ( buffer + bufIndex ) );
		bufIndex += MD5_BLOCKSIZE;
		noBytes -= MD5_BLOCKSIZE;
		}

	/* Handle any remaining bytes of data.  This should only happen once
	   on the final lot of data */
	memcpy( mdContext->in, buffer + bufIndex, noBytes );
	}

/* The routine MD5Final terminates the message-digest computation and ends
   with the desired message digest in mdContext->digest[ 0 ... 15 ] */

void MD5Final( MD5_CTX *mdContext )
	{
	int count;
	LONG lowBitcount = mdContext->i[ 0 ], highBitcount = mdContext->i[ 1 ];

	/* Compute number of bytes mod 64 */
	count = ( int ) ( ( lowBitcount >> 3 ) & 0x3F );

	/* Set the first char of padding to 0x80.  This is safe since there is
	   always at least one byte free */
	( ( BYTE * ) mdContext->in )[ count++ ] = 0x80;

	/* Pad out to 56 mod 64 */
	if( count > 56 )
		{
		/* Two lots of padding:  Pad the first block to 64 bytes */
		memset( ( BYTE * ) &mdContext->in + count, 0, 64 - count );
		MD5Transform( mdContext->buf, ( LONG * ) mdContext->in );

		/* Now fill the next block with 56 bytes */
		memset( &mdContext->in, 0, 56 );
		}
	else
		/* Pad block to 56 bytes */
		memset( ( BYTE * ) &mdContext->in + count, 0, 56 - count );
#if 0
	/* Compute number of bytes mod 64 */
	mdi = ( int ) ( ( mdContext->i[ 0 ] >> 3 ) & 0x3F );
	padLen = ( mdi < 56 ) ? ( 56 - mdi ) : ( 120 - mdi );

	/* Pad out to 56 mod 64 */
	if( padLen )
		{
		/* Set first char of padding to 0x80 */
		mdContext->in[ mdi ] = 0x80;

		if( mdi >= 56 )
			{
			/* Two lots of padding:  Pad first block to 64 bytes, then fill
			   next block with 56 bytes */
			memset( &mdContext->in[ mdi + 1 ], 0, 63 - mdi );
			MD5Transform( mdContext->buf, ( LONG * ) mdContext->in );
			memset( mdContext->in, 0, 56 );
			}
		else
			/* Pad block to 56 bytes */
			memset( &mdContext->in[ mdi + 1 ], 0, padLen - 1 );
		}
	if( mdi + padLen == 64 )
		MD5Transform( mdContext->buf, ( LONG * ) mdContext->in );
#endif /* 0 */

	/* Append length in bits and transform */
	( ( LONG * ) mdContext->in )[ 14 ] = lowBitcount;
	( ( LONG * ) mdContext->in )[ 15 ] = highBitcount;

	MD5Transform( mdContext->buf, ( LONG * ) mdContext->in );

	/* Store buffer in digest */
	memcpy( mdContext->digest, mdContext->buf, 16 );

	/* Restore the previous Mysterious Constants */
	memcpy( mConst, cryptBuffer, MD5_ROUNDS * sizeof( LONG ) );
	isMD5const = FALSE;
	}

#else

void MD5Update( MD5_CTX *mdContext, BYTE *inBuf, unsigned int inLen )
	{
	int mdi;
	LONG in[ 16 ];
	unsigned int i, ii;

	/* Compute number of bytes mod 64 */
	mdi = ( int ) ( ( mdContext->i[ 0 ] >> 3 ) & 0x3F );

	/* Update number of bits */
	if( ( mdContext->i[ 0 ] + ( ( LONG ) inLen << 3 ) ) < mdContext->i[ 0 ] )
		mdContext->i[ 1 ]++;	/* Carry from low to high bitCount */
	mdContext->i[ 0 ] += ( ( LONG ) inLen << 3 );
	mdContext->i[ 1 ] += ( ( LONG ) inLen >> 29 );

	while( inLen-- )
		{
		/* Add new character to buffer, increment mdi */
		mdContext->in[ mdi++ ] = *inBuf++;

		/* Transform if necessary */
		if( mdi == 0x40 )
			{
			for( i = 0, ii = 0; i < 16; i++, ii += 4 )
				in[ i ] = ( ( ( LONG ) mdContext->in[ ii + 3 ] ) << 24 ) | \
						  ( ( ( LONG ) mdContext->in[ ii + 2 ] ) << 16 ) | \
						  ( ( ( LONG ) mdContext->in[ ii + 1 ] ) << 8 ) | \
						  ( ( LONG ) mdContext->in[ ii ] );
			MD5Transform( mdContext->buf, in );
			mdi = 0;
			}
		}
	}

/* The routine MD5Final terminates the message-digest computation and ends
   with the desired message digest in mdContext->digest[ 0 ... 15 ] */

void MD5Final( MD5_CTX *mdContext )
	{
	int mdi, padLen;
	BYTE padding[ 64 ];
	unsigned int i, ii;
	LONG in[ 16 ];

	/* Save number of bits */
	in[ 14 ] = mdContext->i[ 0 ];
	in[ 15 ] = mdContext->i[ 1 ];

	/* Compute number of bytes mod 64 */
	mdi = ( int ) ( ( mdContext->i[ 0 ] >> 3 ) & 0x3F );

	/* Pad out to 56 mod 64 */
	padLen = ( mdi < 56 ) ? ( 56 - mdi ) : ( 120 - mdi );
	padding[ 0 ] = 0x80;
	memset( padding + 1, 0, padLen - 1 );
	MD5Update( mdContext, padding, padLen );

	/* Append length in bits and transform */
	for( i = 0, ii = 0; i < 14; i++, ii += 4 )
		in[ i ] = ( ( ( LONG ) mdContext->in[ ii + 3 ] ) << 24 ) | \
				  ( ( ( LONG ) mdContext->in[ ii + 2 ] ) << 16 ) | \
				  ( ( ( LONG ) mdContext->in[ ii + 1 ] ) << 8 ) | \
				  ( ( LONG ) mdContext->in[ ii ] );
	MD5Transform( mdContext->buf, in );

	/* Store buffer in digest */
	for( i = 0, ii = 0; i < 4; i++, ii += 4 )
		{
		mdContext->digest[ ii ] = ( BYTE ) ( mdContext->buf[ i ] & 0xFF );
		mdContext->digest[ ii + 1 ] = ( BYTE ) ( ( mdContext->buf[ i ] >> 8 ) & 0xFF );
		mdContext->digest[ ii + 2 ] = ( BYTE ) ( ( mdContext->buf[ i ] >> 16 ) & 0xFF );
		mdContext->digest[ ii + 3 ] = ( BYTE ) ( ( mdContext->buf[ i ] >> 24 ) & 0xFF );
		}

	/* Restore the previous Mysterious Constants */
	memcpy( mConst, cryptBuffer, MD5_ROUNDS * sizeof( LONG ) );
	isMD5const = FALSE;
	}
#endif /* !__MSDOS__ */
\End\Of\Shar\
else
  echo "will not over write ./md5.c"
fi
if [ `wc -c ./md5.c | awk '{printf $1}'` -ne 21693 ]
then
echo `wc -c ./md5.c | awk '{print "Got " $1 ", Expected " 21693}'`
fi
if `test ! -s ./mdc.h`
then
echo "writing ./mdc.h"
cat > ./mdc.h << '\End\Of\Shar\'
/****************************************************************************
*																			*
*							MDC.H - MDC interface header					*
*																			*
* 		Written by Peter Gutmann, pgut1@cs.aukuni.ac.nz, September 1992		*
*					You can use this code in any way you want,				*
*		although it'd be nice if you kept my name + contact address on it 	*
*																			*
****************************************************************************/

#include "md5.h"

/* The block size (in bytes) */

#define BLOCKSIZE	16

/* The default IV value used to seed the cipher in initKey().  Changing this
   for each file precludes the use of precomputed encrypted data for very
   fast checking against known plaintext */

#define DEFAULT_IV		( ( BYTE * ) "\0\0\0\0\0\0\0\0" )

#define IV_SIZE			8

/* Define for simple block encryption */

void MD5Transform( LONG *digest, LONG *data );

#ifdef LITTLE_ENDIAN
  #define mdcTransform(iv)	longReverse( ( LONG * ) iv, BLOCKSIZE ); \
							MD5Transform( ( LONG * ) iv, ( LONG * ) auxKey ); \
							longReverse( ( LONG * ) iv, BLOCKSIZE )
#else
  #define mdcTransform(iv)	MD5Transform( ( LONG * ) iv, ( LONG * ) auxKey )
#endif /* LITTLE_ENDIAN */

/* Prototypes for functions in MDC.C */

void initKey( BYTE *key, int keyLength, const BYTE *iv );
void encryptCFB( BYTE *buffer, int length );
void decryptCFB( BYTE *buffer, int length );
BYTE *getIV( void );
\End\Of\Shar\
else
  echo "will not over write ./mdc.h"
fi
if [ `wc -c ./mdc.h | awk '{printf $1}'` -ne 1415 ]
then
echo `wc -c ./mdc.h | awk '{print "Got " $1 ", Expected " 1415}'`
fi
if `test ! -s ./mdc.c`
then
echo "writing ./mdc.c"
cat > ./mdc.c << '\End\Of\Shar\'
/****************************************************************************
*																			*
*							MDC.C - MDC en/decryption code					*
*																			*
* 		Written by Peter Gutmann, pgut1@cs.aukuni.ac.nz, September 1992		*
*					You can use this code in any way you want,				*
*		although it'd be nice if you kept my name + contact address on it 	*
*																			*
****************************************************************************/

#include <stdlib.h>
#include <string.h>
#include <time.h>
#include "mdc.h"

/* Function to perform byte-reversal in an array of LONG's for little-endian
   CPU's */

void longReverse( LONG *buffer, int byteCount );

/* Information needed in CFB mode:  The IV and the count of bytes already
   processed in the current block */

BYTE iv[ BLOCKSIZE ];			/* CFB initialization vector */
int ivCount;					/* Count of bytes used in block */

/* A delay count for the key setup.  We repeat the key setup operation this
   many times to slow it down.  The key setup is inherently non-
   parallelizable, making it necessary to sequentially step through each
   setup operation.  The value below has been chosen to give a delay of about
   0.5s on a 10K-Dhrystone machine */

#define DELAYCOUNT		100

/****************************************************************************
*																			*
*				MDC Key Generation and Encryption Routines					*
*																			*
****************************************************************************/

/* The Mysterious Constants and IV are generated by running MD5 over a
   buffer containing the user key, with the MD5 initial value being set to
   the IV.  These are then substituted for the standard MD5 constants to
   create the MDC function.  The buffer looks as follows:

   [ Key length: 16 bits ] [ Key: 2032 bits ]

   These 2048 bits are used for the MDC constants - the IV is the MD5
   initial value.

   The transformation is in fact somewhat more complex than this, since MD5
   uses both the 'input' and 'output' data in its transformation, and reduces
   64 bytes of input to 16 bytes of output.  It works as follows:

   in[ 64 ] + out[ 16 ] -> out'[ 16 ]

   This problem is resolved by initially setting out[ 16 ] to the IV, and
   in[ 64 ] to zeroes.  Then, once the MDC constants have been set, we set
   in[ 64 ] to auxiliary key values derived from the key.  This means that
   even chosen plaintext attacks can only resolve 16 of 80 bytes of input.
   Thus the best attack possible is a 20%-chosen plaintext attack (128 bits
   known, 512 bits unknown).

   We are transforming a 640-bit input value of which 128 bits are known, to
   a 128-bit output value via the MDC tranformation, a one-way hash function
   which is controlled by a user-supplied key */

BYTE auxKey[ MD5_BLOCKSIZE ];	/* The auxiliary key in[ 64 ] */

void initKey( BYTE *key, int keyLength, const BYTE *userIV )
	{
	BYTE keyData[ MD5_ROUNDS * sizeof( LONG ) ];
	int delayCount;

	/* Copy the key information into the key data buffer */
	memset( keyData, 0, sizeof( keyData ) );
	keyData[ 0 ] = ( BYTE ) ( keyLength >> 8 );
	keyData[ 1 ] = ( BYTE ) keyLength;
	memcpy( keyData + sizeof( WORD ), key, keyLength );
	ivCount = 0;

	/* Set up the IV intermediate.  The MD5 transformation uses both the
	   source and destination value to produce the output value (ie
	   MDC( a, b ) transforms a and b to give b'), so we simply set b, the
	   temporary intermediate, to the IV, and a, the auxKey, to all zeroes */
	memcpy( iv, userIV, IV_SIZE );
	memcpy( iv + IV_SIZE, userIV, IV_SIZE );
	memset( auxKey, 0, MD5_BLOCKSIZE );

	/* Set the Mysterious Constants to the MD5 values and "encrypt" the
	   keyData with them, then set the Mysterious Constants to these values.
	   Note that the act of encryption also sets up the IV */
	MD5SetConst( NULL );
	for( delayCount = 0; delayCount < DELAYCOUNT; delayCount++ )
		{
		encryptCFB( keyData, MD5_ROUNDS * sizeof( LONG ) );
		MD5SetConst( keyData );
		}
	ivCount = 0;

	/* Now set the auxiliary key data to the Mysterious Constants encrypted
	   with themselves */
	encryptCFB( keyData, MD5_BLOCKSIZE );
	memcpy( auxKey, keyData, MD5_BLOCKSIZE );
#ifdef LITTLE_ENDIAN
	longReverse( ( LONG * ) auxKey, MD5_BLOCKSIZE );
#endif /* LITTLE_ENDIAN */
	ivCount = 0;

	/* Finally, wipe the keyData */
	memset( keyData, 0, sizeof( keyData ) );
	}

/* Save and restore the current states of the encryption */

static BYTE savedIV[ BLOCKSIZE ];
static int savedIvCount;

void saveCryptState( void )
	{
	memcpy( savedIV, iv, BLOCKSIZE );
	savedIvCount = ivCount;
	}

void restoreCryptState( void )
	{
	memcpy( iv, savedIV, BLOCKSIZE );
	ivCount = savedIvCount;
	}

/* Get the IV value.  It doesn't matter much what it is, as long as it's
   completely different for each call */

BYTE *getIV( void )
	{
	static BOOLEAN initialised = FALSE;
	static BYTE randomIV[ BLOCKSIZE ];

	if( !initialised )
		{
		/* Seed the data with a value which is guaranteed to be different
		   each time (unless the entire program is rerun more than twice a
		   second, which is doubtful) */
		MD5SetConst( NULL );
		memset( randomIV, 0, BLOCKSIZE );
		time( ( time_t * ) randomIV );
		initialised = TRUE;
		}

	/* Shuffle the bits.  It doesn't really matter whether we use MD5 or MDC
	   constants here since all we want to do is shuffle them */
	mdcTransform( randomIV );
	return( randomIV );
	}

/****************************************************************************
*																			*
*						Cipher Feedback Mode Routines						*
*																			*
****************************************************************************/

/* Encrypt data in CFB mode */

void encryptCFB( BYTE *buffer, int noBytes )
	{
	int bytesToUse, i;

	if( ivCount )
		{
		/* Use any material left in the encrypted IV */
		bytesToUse = BLOCKSIZE - ivCount;
		if( noBytes < bytesToUse )
			bytesToUse = noBytes;
		for( i = 0; i < bytesToUse; i++ )
			buffer[ i ] ^= iv[ i + ivCount ];
		memcpy( iv + ivCount, buffer, bytesToUse );
		noBytes -= bytesToUse;
		buffer += bytesToUse;
		ivCount += bytesToUse;
		}

	while( noBytes )
		{
		ivCount = ( noBytes > BLOCKSIZE ) ? BLOCKSIZE : noBytes;

		/* Encrypt the IV */
		mdcTransform( iv );

		/* XOR the buffer contents with the encrypted IV */
		for( i = 0; i < ivCount; i++ )
			buffer[ i ] ^= iv[ i ];

		/* Shift ciphertext into IV */
		memcpy( iv, buffer, ivCount );

		/* Move on to next block of data */
		noBytes -= ivCount;
		buffer += ivCount;
		}
	}

/* Decrypt data in CFB mode */

void decryptCFB( BYTE *buffer, int noBytes )
	{
	int bytesToUse, i;
	BYTE temp[ BLOCKSIZE ];

	if( ivCount )
		{
		/* Use any material left in the encrypted IV */
		bytesToUse = BLOCKSIZE - ivCount;
		if( noBytes < bytesToUse )
			bytesToUse = noBytes;
		memcpy( temp, buffer, bytesToUse );
		for( i = 0; i < bytesToUse; i++ )
			buffer[ i ] ^= iv[ i + ivCount ];
		memcpy( iv + ivCount, temp, bytesToUse );
		noBytes -= bytesToUse;
		buffer += bytesToUse;
		ivCount += bytesToUse;
		}

	while( noBytes )
		{
		ivCount = ( noBytes > BLOCKSIZE ) ? BLOCKSIZE : noBytes;

		/* Encrypt the IV */
		mdcTransform( iv );

		/* Save ciphertext */
		memcpy( temp, buffer, ivCount );

		/* XOR the buffer contents with the encrypted IV */
		for( i = 0; i < ivCount; i++ )
			buffer[ i ] ^= iv[ i ];

		/* Shift ciphertext into IV */
		memcpy( iv, temp, ivCount );

		/* Move on to next block of data */
		noBytes -= ivCount;
		buffer += ivCount;
		}
	}
\End\Of\Shar\
else
  echo "will not over write ./mdc.c"
fi
if [ `wc -c ./mdc.c | awk '{printf $1}'` -ne 7495 ]
then
echo `wc -c ./mdc.c | awk '{print "Got " $1 ", Expected " 7495}'`
fi
if `test ! -s ./mdcmain.c`
then
echo "writing ./mdcmain.c"
cat > ./mdcmain.c << '\End\Of\Shar\'
/****************************************************************************
*																			*
*							MDCMAIN.C - MDC driver code						*
*																			*
* 		Written by Peter Gutmann, pgut1@cs.aukuni.ac.nz, September 1992		*
*					You can use this code in any way you want,				*
*		although it'd be nice if you kept my name + contact address on it 	*
*																			*
****************************************************************************/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include "mdc.h"

/* The encryption password lengths.  A minimum length of 8 bytes provides a
   reasonable level of security */

#define MIN_KEYLENGTH	8
#define MAX_KEYLENGTH	80		/* Any reasonable value will do */

/* The buffer used by the MDC version of MD5 */

BYTE cryptBuffer[ 2048 ];

/****************************************************************************
*																			*
*		Sample Program:  File Encryption/Decryption using CFB mode			*
*																			*
****************************************************************************/

#ifndef TEST_VERSION

#define MDC_ID		"MDC "

void main( const int argc, const char *argv[] )
	{
#if !defined( TIME_TRIAL ) && !defined( SETUP_TRIAL )
	FILE *inFilePtr, *outFilePtr;
#endif /* !( TIME_TRIAL || SETUP_TRIAL ) */
#if defined( TIME_TRIAL ) || defined( SETUP_TRIAL )
	time_t startTime, endTime;
#endif /* TIME_TRIAL || SETUP_TRIAL */
#ifndef SETUP_TRIAL
	BYTE buffer[ 512 ];
#endif /* !SETUP_TRIAL */
	char key[ MAX_KEYLENGTH + 1 ];
	int count = 1;
	BYTE *iv;

#if !defined( TIME_TRIAL ) && !defined( SETUP_TRIAL )
	if( argc == 4 )
		{
		if( ( inFilePtr = fopen( argv[ 2 ], "rb" ) ) == NULL )
			{
			perror( argv[ 2 ] );
			exit( ERROR );
			}
		if( ( outFilePtr = fopen( argv[ 3 ], "r" ) ) != NULL )
			{
			fclose( outFilePtr );
			printf( "Won't overwrite existing file %s\n", argv[ 3 ] );
			exit( ERROR );
			}
		if( ( outFilePtr = fopen( argv[ 3 ], "wb" ) ) == NULL )
			{
			perror( argv[ 3 ] );
			exit( ERROR );
			}
		}
	else
		{
		puts( "Usage: mdc e|d <infile> <outfile>" );
		puts( "           e to encrypt data" );
		puts( "           d to decrypt data" );
		exit( ERROR );
		}
#endif /* !( TIME_TRIAL || SETUP_TRIAL ) */

#if !defined( TIME_TRIAL ) && !defined( SETUP_TRIAL )
	/* Read/write the header information */
	if( *argv[ 1 ] == 'e' )
		{
		iv = getIV();
		fwrite( MDC_ID, 1, 4, outFilePtr );
		fwrite( iv, 1, IV_SIZE, outFilePtr );
		}
	else
		{
		if( fread( buffer, 1, 4 + IV_SIZE, inFilePtr ) != 4 + IV_SIZE || \
			memcmp( buffer, MDC_ID, 4 ) )
			{
			puts( "Not an MDC-encrypted file" );
			exit( ERROR );
			}
		memcpy( iv, buffer + 4, IV_SIZE );
		}
#endif /* !( TIME_TRIAL || SETUP_TRIAL ) */

	/* Set up the S-Boxes */
#if defined( TIME_TRIAL ) || defined( SETUP_TRIAL )
	strcpy( key, "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789" );
	iv = getIV();
#else
	*key = '\0';
	while( strlen( key ) < MIN_KEYLENGTH )
		{
		printf( "Key (%d-%d chars): ", MIN_KEYLENGTH, MAX_KEYLENGTH );
		fgets( key, MAX_KEYLENGTH, stdin );	/* Should use something better */
		key[ strlen( key ) - 1 ] = '\0';	/* Stomp '\n' */
		putchar( '\n' );
		}
#endif /* TIME_TRIAL || SETUP_TRIAL */
#ifdef SETUP_TRIAL
	puts( "Performing 100 key setup operations" );
	time( &startTime );
	for( count = 0; count < 100; count++ )
		initKey( ( BYTE * ) key, strlen( key ), iv );
	time( &endTime );
	printf( "Seconds to 100 perform key setup operations: %ld\n", \
			( long ) ( endTime - startTime ) );
	printf( "Setups per second: %ld\n", \
			100 / ( endTime - startTime ) );	/* Should really use FP */
	puts( "Done" );
#else
	initKey( ( BYTE * ) key, strlen( key ), iv );
#endif /* SETUP_TRIAL */

	/* We're done with the key, zap it */
	memset( key, 0, MAX_KEYLENGTH + 1 );

#if defined( TIME_TRIAL )
	/* Encrypt 1MB of data in 512-byte blocks */
	memset( buffer, 0, 512 );
	puts( "Encrypting 20480 x 512-byte blocks (10MB)..." );
	time( &startTime );
	for( count = 0; count < 20480; count++ )
		encryptCFB( buffer, 512 );
	time( &endTime );
	printf( "Seconds to encrypt: %ld\n", ( long ) ( endTime - startTime ) );
	printf( "Bytes per second: %ld\n", 10000000L / ( endTime - startTime ) );
	puts( "Done" );
#elif !defined( SETUP_TRIAL )

	/* Grovel through a file en/decrypting it */
	while( count )
		{
		/* Read in a block of chars */
		count = fread( buffer, 1, 512, inFilePtr );

		/* Encrypt/decrypt data block */
		if( *argv[ 1 ] == 'e' )
			encryptCFB( buffer, count );
		else
			decryptCFB( buffer, count );

		/* Write out block and reset counter */
		fwrite( buffer, 1, count, outFilePtr );
		}

	fclose( inFilePtr );
	fclose( outFilePtr );
#endif /* TIME_TRIAL */
	}

#endif /* !TEST_VERSION */

/****************************************************************************
*																			*
*				Sample Program:  Perform Test En/Decryptions				*
*																			*
****************************************************************************/

#ifdef TEST_VERSION

/* Sample code to encrypt/decrypt 128-bit values.  Note that the sample
   keys are possibly somewhat shorter than what would normally be used
   (128 bits vs MIN_KEYLENGTH...MAX_KEYLENGTH bytes).  Note that the
   following code only exercises the basic MDC transformation, not the
   CFB-mode encryption, since this is stream-oriented */

typedef struct {
			   BYTE key[ BLOCKSIZE ];		/* Sample key */
			   BYTE data[ BLOCKSIZE ];		/* Sample data */
			   } SAMPLE_VALUE;

SAMPLE_VALUE testValues[] = {
					{
						{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
						  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
						{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
						  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
					}, {
						{ 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
						  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF },
						{ 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
						  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF },
					}, {
						{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
						  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01 },
						{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
						  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
					}, {
						{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
						  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
						{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
						  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01 },
					}, {
						{ 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
						  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
						{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
						  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
					}, {
						{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
						  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
						{ 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
						  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
					}, {
						{ 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
						  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF },
						{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
						  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
					}, {
						{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
						  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
						{ 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
						  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF },
					}, {
						{ 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
						  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF },
						{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
						  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01 },
					}, {
						{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
						  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01 },
						{ 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
						  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF },
					}, {
						{ 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
						  0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01 },
						{ 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
						  0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01 },
					}, {
						{ 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
						  0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80 },
						{ 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
						  0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80 },
					}, {
						{ 0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF,
						  0xFE, 0xDC, 0xBA, 0x98, 0x76, 0x54, 0x32, 0x10 },
						{ 0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF,
			  0xFE, 0xDC, 0xBA, 0x98, 0x76, 0x54, 0x32, 0x10 },
					}, {
						{ 0xFE, 0xDC, 0xBA, 0x98, 0x76, 0x54, 0x32, 0x10,
						  0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF },
						{ 0xFE, 0xDC, 0xBA, 0x98, 0x76, 0x54, 0x32, 0x10,
						  0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF }
					}
				};

#define NO_TEST_VALUES		14

/* Things internal to MDC which we normally don't need to know about but
   which are used by this test code */

void longReverse( LONG *buffer, int byteCount );
extern BYTE auxKey[ MD5_BLOCKSIZE ];

/* Code to generate test encryption values */

void printData( BYTE *data )
	{
	int i = 0;

	while( i < BLOCKSIZE )
		printf( "%02X", data[ i++ ] );
	}

void main( void )
	{
	BYTE cipherText[ BLOCKSIZE ];
	int i;

	puts( "Beginning test run..." );

	for( i = 0; i < NO_TEST_VALUES; i++ )
		{
		/* Set up the key */
		initKey( testValues[ i ].key, BLOCKSIZE, DEFAULT_IV );

		printf( "Key " );
		printData( testValues[ i ].key );
		printf( ", data " );
		printData( testValues[ i ].data );
		printf( ":\n    " );

		/* Perform test encryptions.  Note that we can't test this by
		   decrypting it like an ECB/CBC mode cipher since it's a one-way
		   transformation */
		memcpy( cipherText, testValues[ i ].data, BLOCKSIZE );
		mdcTransform( cipherText );
		printData( cipherText );
		putchar( '\n' );
		}
	}
#endif /* TEST_VERSION */
\End\Of\Shar\
else
  echo "will not over write ./mdcmain.c"
fi
if [ `wc -c ./mdcmain.c | awk '{printf $1}'` -ne 9941 ]
then
echo `wc -c ./mdcmain.c | awk '{print "Got " $1 ", Expected " 9941}'`
fi
echo "Finished archive 1 of 1"
exit


