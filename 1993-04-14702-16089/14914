Path: msuinfo!uwm.edu!cs.utexas.edu!not-for-mail
From: boucher@csl.sri.com (Peter K. Boucher)
Newsgroups: sci.crypt
Subject: Trinomial-Based PRNG
Date: 8 Apr 1993 18:55:44 -0500
Organization: UTexas Mail-to-News Gateway
Lines: 205
Sender: daemon@cs.utexas.edu
Message-ID: <9304082356.AA00755@assault.csl.sri.com>
NNTP-Posting-Host: cs.utexas.edu

Path: csl.sri.com!boucher
From: boucher@csl.sri.com (Peter K. Boucher)
Newsgroups: sci.crypt
Subject: Trinomial-Based PRNG
Distribution: world

This PRNG allows you to choose a type, when you seed it.
The type selects one of 16 trinomials to be used.  The
trinomials are all of the form X**a + X**b + 1, where a
and b are primes, and a mod b = 1.  The values of a and
b were chosen based on testing.  Can anyone tell me how
to determine if the trinomials are irreducible?

==================== CODE ==============================
/* 
 * rnd.c --
 *
 *   Pseudo-random number generator.  Based on algorithm
 *   used in the BSD Unix (tm) rand.c stdlib module.
 *   Provides 16 types of PRNG (all using polynomials of
 *   the form X**a + X**b + 1, where a and b are primes and
 *   a mod b = 1).
 *
 * Copyright 1993 Peter K. Boucher
 * Permission to use, copy, modify, and distribute this
 * software and its documentation for any purpose and without
 * fee is hereby granted, provided that the above copyright
 * notice appear in all copies.
 */


#define DEG_0 443 /* X**443 + X**17 + 1 */
#define SEP_0 17

#define DEG_1 503 /* X**503 + X + 1 */
#define SEP_1 1

#define DEG_2 577 /* X**577 + X**3 + 1 */
#define SEP_2 3

#define DEG_3 641 /* X**641 + X**5 + 1 */
#define SEP_3 5

#define DEG_4 701 /* X**701 + X**7 + 1 */
#define SEP_4 7

#define DEG_5 769 /* X**769 + X**2 + 1 */
#define SEP_5 2

#define DEG_6 839 /* X**839 + X**2 + 1 */
#define SEP_6 2

#define DEG_7 911 /* X**911 + X**13 + 1 */
#define SEP_7 13

#define DEG_8 983 /* X**983 + X + 1 */
#define SEP_8 1

#define DEG_9 1049 /* X**1049 + X**2 + 1 */
#define SEP_9 2

#define DEG_10 1109 /* X**1109 + X**2 + 1 */
#define SEP_10 2

#define DEG_11 1193 /* X**1193 + X**2 + 1 */
#define SEP_11 2

#define DEG_12 1277 /* X**1277 + X**29 + 1 */
#define SEP_12 29

#define DEG_13 1321 /* X**1321 + X**11 + 1 */
#define SEP_13 11

#define DEG_14 1429 /* X**1429 + X**17 + 1 */
#define SEP_14 17

#define DEG_15 1487 /* X**1487 + X**2 + 1 */
#define SEP_15 2

static  long		state[ DEG_15 ];
static  long		*fptr;
static  long		*rptr;
static  long		*end_ptr;

unsigned long
rnd() /* make sure to call init_rnd() before calling rnd() */
{
	register unsigned long	i;

	i = ((*fptr += *rptr) >> 1) & 0x7fffffff;
	if(  ++fptr  >=  end_ptr  )  {
	    fptr = state;
	    ++rptr;
	} else  {
	    if(  ++rptr  >=  end_ptr  )  rptr = state;
	}
	return( i );
}

void init_rnd( seed, type )
    register unsigned long seed;
    unsigned int  type;

{
	register unsigned long	i, t = type&15;
	register unsigned long	degree;

	rptr = state;
	switch( t ) {
            case 0:
		degree = DEG_0;
		end_ptr = state + DEG_0;
		fptr = state + SEP_0;
		break;
            case 1:
		degree = DEG_1;
		end_ptr = state + DEG_1;
		fptr = state + SEP_1;
		break;
            case 2:
		degree = DEG_2;
		end_ptr = state + DEG_2;
		fptr = state + SEP_2;
		break;
            case 3:
		degree = DEG_3;
		end_ptr = state + DEG_3;
		fptr = state + SEP_3;
		break;
            case 4:
		degree = DEG_4;
		end_ptr = state + DEG_4;
		fptr = state + SEP_4;
		break;
            case 5:
		degree = DEG_5;
		end_ptr = state + DEG_5;
		fptr = state + SEP_5;
		break;
            case 6:
		degree = DEG_6;
		end_ptr = state + DEG_6;
		fptr = state + SEP_6;
		break;
            case 7:
		degree = DEG_7;
		end_ptr = state + DEG_7;
		fptr = state + SEP_7;
		break;
            case 8:
		degree = DEG_8;
		end_ptr = state + DEG_8;
		fptr = state + SEP_8;
		break;
            case 9:
		degree = DEG_9;
		end_ptr = state + DEG_9;
		fptr = state + SEP_9;
		break;
            case 10:
		degree = DEG_10;
		end_ptr = state + DEG_10;
		fptr = state + SEP_10;
		break;
            case 11:
		degree = DEG_11;
		end_ptr = state + DEG_11;
		fptr = state + SEP_11;
		break;
            case 12:
		degree = DEG_12;
		end_ptr = state + DEG_12;
		fptr = state + SEP_12;
		break;
            case 13:
		degree = DEG_13;
		end_ptr = state + DEG_13;
		fptr = state + SEP_13;
		break;
            case 14:
		degree = DEG_14;
		end_ptr = state + DEG_14;
		fptr = state + SEP_14;
		break;
            case 15:
		degree = DEG_15;
		end_ptr = state + DEG_15;
		fptr = state + SEP_15;
		break;
	}
	state[ 0 ] = seed;
	for( i = 1; i < degree; i++ )  {
	    seed = (state[i] = 1103515245*seed + 12345);
	}
	degree = (10*degree) + (seed%degree);
	for( i = 0; i < degree; i++ )  rnd();
}

=========================== END CODE =====================


-- 
Peter K. Boucher
--
RIPEM public key available upon request.
