Path: msuinfo!caen!sdd.hp.com!elroy.jpl.nasa.gov!ames!olivea!tardis!tymix!altair!jdresser
From: jdresser@altair.tymnet.com (Jay Dresser)
Newsgroups: sci.crypt
Subject: encrypting to ASCII
Message-ID: <3364@tymix.Tymnet.COM>
Date: 16 Feb 93 22:06:10 GMT
Sender: usenet@tymix.Tymnet.COM
Lines: 155
Nntp-Posting-Host: altair


> I am looking for simple algorithm that will encrypt ascii text to 
> ascii text.  Essentially what I need is something like the unix crypt
> routines that take your ascii password and create an encoded ascii 
> string for in the password file.  It does not have to be unbreakable,
> just simple and result in an ascii string.  
> 
> Any suggestions?
> 
> 
> Bill Basden
> Warren & Selbert, Inc.

What I do here is scramble printable ASCII into printable ASCII.  I use
a random number from 0-95 and add it, modulo 96.  The "password" is an
ASCII string which gets "hashed" via CRC into the initial seed for a
random number generator.  It adds to encrypt and subtracts to decrypt.
Very simple, very fast.  Not unbreakable, but protects from casual
inspection.


				  /*--------======  Enc  ======--------*/

#ifdef Documentation

A simple cryptifier.

#endif

#include <stdio.h>
typedef char *charP;
typedef unsigned char byte, *byteP;
typedef unsigned long ulong, *ulongP;

#define CRC_22_MASK    (X32+X26+X23+X22+X16+X12+X11+X10+X8+X7+X5+X4+X2+1)
					   /* Ethernet */

/* 0000,0100,1100,0001,0001,1101,1011,0101 */
/* 04C11DB5 */
/* 4A544744 */

	FILE* infile;
	FILE* outfile;
	union {
		ulong ll [2];
		byte  b  [8];
	} crc;
	byte mask [] = { 0x04, 0xC1, 0x1D, 0xB5, 0x4A, 0x54, 0x47, 0x44 };

octo_crc ( b, crc, mask )
	byte b; 					/* input byte */
	byte crc [8];				/* initial value, updated */
	byte mask [8];
{
	int i, j, cond, in, bit, x;

	for ( bit = 0; bit < 8; ++bit ) {
		cond = ( crc[0] ^ b ) & 128;
		in = 0;								/* carry bit for rotate */
		for ( j = 7; j >= 0; --j ) {
			x = crc [j];
			x = (x << 1) + ( in ? 1 : 0 );
			in = x & (1<<8);
			crc [j] = x;
		}
		if ( cond ) {
			for ( j = 0; j < 8; ++j ) {
				crc [j] ^= mask [j];
			}
		}
		b <<= 1;
	}
}

clean_exit ()
{
	if ( infile )  fclose ( infile );
	if ( outfile ) fclose ( outfile );
	exit(0);
}

help ()
{
	printf ( "\n> enc -e <key> [<infile>] [<outfile>]	 ;to encode" );
	printf ( "\n> enc -d <key> [<infile>] [<outfile>]	 ;to decode" );
	printf ( "\n (uses stdin/stdout if filespec missing)\n" );
	clean_exit ();
}

#define BASE (32)				/* lowest character encrypted */
#define TOP (127)				/* highest character not encrypted */
#define MOD (TOP-BASE)

main ( argc, argv )
	int  argc;
	charP argv[];
{
	char *p;
	int i, ii;
	byte b;

	if ( argc < 3 || argc > 5 ) help ();
	if ( argv [1][0] != '-' ) help ();

/* open files */
	if ( argc < 5 ) outfile = fdopen ( 1, "w" );
	else            outfile = fopen ( argv[4], "w" );
	if ( outfile == 0 ) help ();
	if ( argc < 4 ) infile = fdopen ( 0, "r" );
	else            infile = fopen ( argv[3], "r" );
	if ( infile == 0 ) help ();

/* hash password key */
	crc.ll[0] = crc.ll[1] = 0;
	p = argv [2];
	while ( b = *p++ ) octo_crc ( b, &crc, mask );

	switch ( argv [1][1] ) {

/* encode */
	case 'e':
		while ( (ii = i = fgetc ( infile )) >= 0 ) {
			if ( i >= BASE && i < TOP ) {
				i -= BASE;
				i += crc.ll[1] % MOD;
				i %= MOD;
				i += BASE;
			}
			fputc ( i, outfile );
			octo_crc ( ii, &crc, mask );
		}
		break;

/* decode */
	case 'd':
		while ( (i = fgetc ( infile )) >= 0 ) {
			if ( i >= BASE && i < TOP ) {
				i -= BASE;
				i -= crc.ll[1] % MOD;
				i += MOD;
				i %= MOD;
				i += BASE;
			}
			fputc ( i, outfile );
			octo_crc ( i, &crc, mask );
		}
		break;

	default: help ();
	}

	clean_exit ();
}

/* end */
