Path: msuinfo!uwm.edu!spool.mu.edu!enterpoop.mit.edu!senator-bedfellow.mit.edu!athena.mit.edu!ninassup
From: ninassup@athena.mit.edu (Nikos I Nassuphis)
Newsgroups: sci.crypt
Subject: an idea
Date: 26 Feb 1993 04:05:27 GMT
Organization: Massachusetts Institute of Technology
Lines: 94
Message-ID: <1mk4u7INNota@senator-bedfellow.MIT.EDU>
References: <9302232203.AA18079@pizzabox.demon.co.uk> <1993Feb25.103557.11350@mnemosyne.cs.du.edu> <1993Feb25.144511.17815@magnus.acs.ohio-state.edu>
NNTP-Posting-Host: w20-575-107.mit.edu

A lattice gas is a digital approximation of a real, thermodynamic gas.
It works by representing particles with a single bit, which can travel
in any of eight directions (N,S,E,W,NE,SW etc) with unit speed. 
Particles are confined to discrete points on a lattice, and this is
why the simulation is called a lattice gas.

There can be up to 8 particles at a lattice site (all bits set)

The evolution of the gas is computed by continously going through
a move step, which moves all particles in thei respective directions
and a collide step which uses a look-up table to collide particles that
are on the same lattice site. The collision rules are chosen in such
a way that mass, momentum and energy is conserved.

Such a "digital gas" behaves a little bit like a real one in that 
is will rapidly "thermalized" from any initial configuration, and it
will stay thermalized thereafter.

I have been toying with the idea of using a lattice gas algorithm for
encryption purposes.

The key point is that although the gas will go to a thermalised state
(macroscopic irreversibility) the microscopic collision rules are in fact
reversible.

It works as follows:

1.
Take your message and use it as an intitial state for a gas state. Run it
through the lattice gas algorithm until it reaches equilibrium.

2.
Flip some bits in the resulting (thermalised gas)


The key is the location and number of bits that were flipped, along with
the number of steps the gas was evolved (one can even flip some bits,
simulate for some more time-steps and flip some more bits)

To decode just flip the same bits, reverse all speeds and run the simulation
for the same number of steps as it was run during the encoding.
The message will "spontaneously" appear.

A number of points:

even a single wrong bit is enough to prevent the message from decoding 
correctly. I can see no reason why a 128-bit key is any better than a 
one bit key. ( exept for the fact that u have more choices of bit 
locations with the large key. but the key size could be left to the user )

because the number of bits is conserved through the gas evolution it would be
better if the message is padded with enough FF's or 0s to make the number of
ones equal to the number of zeroes. If this is done, any random bit in
the cypher will have equal propability of being 0 or 1 no matter what the
plaintext is. When the evolution is reversed the padding will nicelly 
gather at the end of the message.

This has the added advantage of not conserving the message length.

I coded the algorithm and tried it. It seems to work. The encoded message
does not decode even if a single bit is wrong, and it looks totally random
all the time.

If a bit padding is appended, all encoded data has a .5 propability of 
having a 1 at any place (e.g. bit 4 of byte 1456) for any plaintext

I can give the code to anyone interested. (its 80x86 assembler, but ill
propably do a C version sometime)

It runs at an acceptable speed, taking less than a sec to do 1000 steps on 
a 2000 byte message. 200 steps are enough to thermalise it.


Does anybody know of anything similar ? I heard something about cryptographic
applications of cellular automata, which should be similar, but I have
never seen anything concrete.

Any comments about any obvious weakness that i overlooked ?
 
I would appreciate any pointers.


NN











