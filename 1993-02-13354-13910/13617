Newsgroups: sci.crypt
Path: msuinfo!caen!zaphod.mps.ohio-state.edu!cs.utexas.edu!asuvax!ukma!mont!mizzou1.missouri.edu!UC445585
From: UC445585@mizzou1.missouri.edu (John M. Kelsey)
Subject: Input transformations to make ciphers more secure.
Message-ID: <16B76745.UC445585@mizzou1.missouri.edu>
Sender: news@mont.cs.missouri.edu
Nntp-Posting-Host: mizzou1.missouri.edu
Organization: University of Missouri
Date: Mon, 15 Feb 93 00:31:01 CST
Lines: 61

   I've been working through a book called _Cryptography:  A Primer_ by
Alan Konheim, and when I was reading through the sections on the Hill cipher
and block ciphers (using block-chaining, and such), I came up with some
questions.
 
   The Hill cipher uses a set of linear equations to transform a block of
plaintext into a block of ciphertext, like:
 
   c0 = 13* m0 +  7 * m1 + 3 * m2
   c1 = 21* m0 + 13 * m1 + 21* m2
   c2 =  5* m0 + 11 * m1 +  9* m2
 
   This makes every output byte (or number) dependent on every input byte.
Now, this cipher in itself is pretty weak--it falls apart *fast* under a
block of known plaintext, since you can just solve the linear equations.
However, this seems like it could be used to make every byte of the output
of a cipher dependent on every input byte.  (Or, at least, it could be used
to make every output byte in a *large* block dependent on every input byte.)
 
   I was thinking that this might be used to cause a large number of 64-bit
input blocks of IDEA or DES to be related, making known- or chosen-plaintext
attacks harder in the same general way that cipher block chaining does.  I
can see that this would also have some nasty effects on dealing with trans-
mission errors (ie, any transmission error would clobber the whole message),
but my impression is that this isn't as important in a lot of applications
as is security.  (Especially if the message is also digitally signed--it may
be of questionable value anyway if it's been altered.)
 
   For example, we could block together 8 blocks of 64-bits each with an
8 x 8 matrix of 64-bit values.  This would take up 512 bytes of memory, but
I don't see that it would particularly need to be a part of the key--it could
easily be a standardized matrix.  (Would it particularly strengthen things to
make this key-generated in some way?)  There would be 8 input blocks, and
8 output blocks, each of 64 bits.  Every output block would be a function of
every input block.  Each of these output blocks would be fed to IDEA or DES.
Larger matrices would be practical in most cases, so that the whole message
might be blocked together in this way.  (When I say "matrix," I mean the
coefficients of the linear equations.)
 
   Additionally, a simple random number generator seeded in some way from the
key could be used to make chosen-plaintext attacks either impossible or very
difficult.  Simply generate some small number of blocks from your pseudorandom
source, and XOR them against a few of your message blocks.  Then use the Hill-
encipherment to make every block encrypted with IDEA/DES dependent in part on
the output from your pseudorandom number generator.
 
   This seems like a pretty simple, straightforward idea.  Is there some
problem with it that I'm not seeing?  It seems to be stronger than simply
running a block cipher in CFB mode, since *every* output byte is dependent
on every input byte.  (Of course, as far as allowing single-character-at-a-
time encryption, this scheme does nothing...)
 
   I may write some simple C program to implement the Hill cipher on large
blocks, and see what kind of performance I can get out of it.  (It would
probably be faster to deal with individual bytes in the input blocks, rather
than 64-bit blocks, and there are probably other performance issues I'll
notice.  For an N-block encryption, each output block requires N multi-
plications, and N-1 additions, assuming you just tell the system not to flag
overflows.)
 
   --John Kelsey, uc445585@mizzou1.missouri.edu
