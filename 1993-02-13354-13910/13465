Newsgroups: sci.crypt
Path: msuinfo!caen!zaphod.mps.ohio-state.edu!usc!elroy.jpl.nasa.gov!ames!pacbell.com!amdahl!netcomsv!netcom.com!kelly
From: kelly@netcom.com (Kelly Goen)
Subject: Dynamic Password schemes - a software approach "csu"
Message-ID: <1993Feb5.215525.26303@netcom.com>
Organization: Netcom Online Communications Services (408-241-9760 login: guest)
Date: Fri, 5 Feb 1993 21:55:25 GMT
Lines: 1117

 

                             Cryptographic SU
  (a secure method of network su access without network password exposure)


CSU offers a method for authentication of su authority on an individual
basis without exposure of a fixed password. CSU is presented strictly as
a secure means of granting the su privelege over a possibly hostile or
compromised network. CSU is based upon ideas presented in 
"Secure Superuser access via the Internet" by Darrel Suggs.
Within that report which was funded under DOD Contract N00421-91-C-0028
a challenge response delta password scheme was presented and pseudo-code
provided for same. As the source code was specifically NOT available to
other users(i.e. they arent releasing any copies), the decision was made to
implement the algorithm with the MD5 Cryptographic authentication Algorithm
(A public domain algorithm).

A. csu - cryptographic SU , the host program responsible for 
issuing a random challenge to the user requesting SU access.
The random challenge is based upon the time of day, cryptographically
mixed with the MD5 Algorithm and the username. The low order 8 bytes
of the MD5 output string is output as a hex-ascii challenge to the
user. At that point the user on his LOCAL host executes the repond 
program(soft-token), the challenge is typed into respond along
with the users 8 digit hex-ascii pin. respond calculates a response
to the challenge and the user enters this into the requesting CSU. If
all has gone well up to this point then the user is identified and an
su shell started on his behalf. If the user has made a mistake or does
not remember his PIN then he or she will not be granted access. The passwords
generated exhibit a 1 time property in that they cannot be recorded
and the session played back to spoof a legitimate user.

B. respond - the cryptographic software token, it accepts the users
pin along with the challenge and generates 1 unique password.



There has also been an adduser command added to ad new userid and pins
deletion is still done manually.

Scott and I are throwing this to the net in the hope that others will
find it useful it is being posted to sci.crypt initially prior
to a later release in alt.sources... its being put in sci.crypt so
that it may be examined by at least some knowledgeable about
md5.
   
    scott gustafson and myself may be reached at

p.s. yes we know there are holes, comments and suggestions for improvement
should be sent to the above e-mail addresses flames to /dev/null



    scott@cadence.com
   

    snake@cadence.com(Kelly)

    kelly@netcom.com
---- Cut Here and feed the following to sh ----
#!/bin/sh
# This is a shell archive (produced by shar 3.49)
# To extract the files from this archive, save it to a file, remove
# everything above the "!/bin/sh" line above, and type "sh file_name".
#
# made 02/05/1993 21:37 UTC by root@cds9041
# Source directory /home/snake/csu
#
# existing files will NOT be overwritten unless -c is specified
#
# This shar contains:
# length  mode       name
# ------ ---------- ------------------------------------------
#    970 -rw------- csu/Makefile
#   3067 -rw------- csu/csu.c
#    404 -rw------- csu/csu.h
#     41 -rw------- csu/csu.local
#   2131 -rw------- csu/encode.c
#    655 -rw------- csu/genstr.c
#    781 -rw------- csu/global.h
#    600 -rw------- csu/log.c
#    166 -rw------- csu/log.h
#   1898 -rw------- csu/md5-announcement.txt
#  10471 -rw------- csu/md5.c
#   1394 -rw------- csu/md5.h
#   1419 -rw------- csu/new-account.c
#   1117 -rw------- csu/respond.c
#
# ============= csu/Makefile ==============
if test ! -d 'csu'; then
    echo 'x - creating directory csu'
    mkdir 'csu'
fi
if test -f 'csu/Makefile' -a X"$1" != X"-c"; then
	echo 'x - skipping csu/Makefile (File already exists)'
else
echo 'x - extracting csu/Makefile (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'csu/Makefile' &&
X# Copyright 1993 by Scott Gustafson (scott@cadence.com)
X#
X# Symbols defined are SECURE, DEBUG, SYSLOG
X# SECURE will give you a 32 byte string to type in to csu and respond, otherwise
X#	the string is 8 bytes.  It will also give you a wider range of characters
X#	to type in.  But you can always change that in encode.c
X#
XCC	=	/usr/lang/acc
X#CFLAGS	=	-g -Xc -DDEBUG
XCFLAGS	=	-Xc -DSYSLOG
X
XOBJ	=	log.o encode.o genstr.o md5.o
X
Xall:	csu respond new-account
X
Xcsu:	csu.o csu.h $(OBJ)
X	$(CC) $(CFLAGS) -o csu csu.o $(OBJ)
X	chmod 6750 csu
X	chown root csu
X	chgrp audit csu
X
Xrespond: respond.o csu.h $(OBJ)
X	$(CC) $(CFLAGS) -o respond respond.o $(OBJ)
X
Xnew-account:	new-account.o csu.h $(OBJ)
X	$(CC) $(CFLAGS) -o new-account new-account.o $(OBJ)
X	chmod 6700 new-account
X	chown root new-account
X	chgrp audit new-account
X
Xclean:
X	rm -f csu respond new-account *.o a.out core tmp
X
Xlog.o: log.c log.h
Xmd5.o: md5.c md5.h global.h
Xencode.o: encode.c md5.o csu.h
Xgenstr.o: genstr.c csu.h
SHAR_EOF
chmod 0600 csu/Makefile ||
echo 'restore of csu/Makefile failed'
Wc_c="`wc -c < 'csu/Makefile'`"
test 970 -eq "$Wc_c" ||
	echo 'csu/Makefile: original size 970, current size' "$Wc_c"
fi
# ============= csu/csu.c ==============
if test -f 'csu/csu.c' -a X"$1" != X"-c"; then
	echo 'x - skipping csu/csu.c (File already exists)'
else
echo 'x - extracting csu/csu.c (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'csu/csu.c' &&
X/* Copyright 1993 by Scott Gustafson (scott@cadence.com) */
X
X/* This program needs to have suid root and owner root */
X
X#include "csu.h"
X#include "log.h"
X
X/* the program name is needed for sysloging information and to check that you
X * are running the program with the correct name */
X#define PGMNAME "csu"
X
X/* this is just used for the users login id.  i.e. scott */
Xchar userid[8];
X
X/* this function reads the CSUNAME file to get the users password */
Xchar *load_key(const char path[]) {
X	extern char userid[];
X	char buffer[MAX_LENGTH], temp[MAX_LENGTH]; 
X	FILE *csu_file;
X	int done = 0;
X
X	/* open the file */
X	if ((csu_file = fopen(path, "r")) == NULL)
X		error("FILE Access Denied: %s");
X
X	/* read the file line by line until done is true */
X	while ((fgets(buffer, MAX_LENGTH, csu_file) != NULL) && (done != 1)) {
X
X		/* grap the first token in the file which is the user name */
X		strcpy(temp,strtok(buffer, "\t\n "));
X
X		/* compare the token with the real userid */
X		if (strcmp(temp, userid) == 0) {
X
X			/* if they are the same, then grap the next token from
X			 * the buffer and that will be the password */
X			strcpy(temp,strtok(NULL, "\t\n "));
X			done = 1;
X		}
X	}
X	/* close the file before leaving */
X	fclose(csu_file);
X#ifdef DEBUG
X	fprintf(stdout, "User ID:%s\tKey:%s\n", userid, temp);
X#endif
X	/* return the password string*/
X	return(temp);
X}
X
Xvoid main (int argc, char **argv) {
X	struct stat buf;
X	/* string variables */
X	extern char userid[];
X	char key[MAX_LENGTH], *string, *randstr;
X	char remoteresponse[MAX_LENGTH], localresponse[MAX_LENGTH];
X
X	setuploging(PGMNAME);
X
X	string = (char *)malloc(sizeof(string) * MAX_LENGTH);
X	randstr = (char *)malloc(sizeof(randstr) * MAX_LENGTH);
X
X	/* get the userid of the caller */
X	sprintf(userid, "%s", getenv("USER"));
X
X	/* log the attempts to run the program */
X	log("Starting up. User: %s", userid);
X
X	/* verify that program was invoked with the correct name */
X	if (strcmp(PGMNAME, argv[0]) != 0 )
X		error("INVALID NAME Access Denied: %s");
X
X	/* stat secure file -check permissions, uid, gid */
X	/* this only checks the csu.local file */
X	stat(CSUNAME, &buf);
X	if (buf.st_uid !=0 || buf.st_gid != GID || buf.st_mode != MODE)
X		error("FILE MODE CORRUPT. Access denied: %s");
X
X	/* Read in the key for this userid */
X	if ((sprintf(key, "%s", load_key(CSUNAME))) == 0)
X		error("UNAUTHORIZED USER. Access denied: %s");
X
X	/* Generate a random string and crypt it */
X	randstr = genstr();
X#ifdef SECURE
X	account_encode(randstr, userid);
X#else
X	encode(randstr, userid);
X#endif /* SECURE */
X
X	/* print the Delta over time and then get the remote response */
X	printf("Delta: %s\nResponse: ", randstr);
X	scanf("%s", remoteresponse);
X
X	/* Compute expected repsonse */
X	strcpy(string, randstr);
X	strcat(string, key);
X#ifdef SECURE
X	account_encode(string, userid);
X#else
X	encode(string, userid);
X#endif /*SECURE */
X
X	if (strcmp(string,remoteresponse) == 0 ) {
X		log("SUCCESS. access granted User: %s", userid);
X		setuid((int) 0);
X		system("/bin/sh");	/* WARNING SUPER USER ACCESS */
X	}
X	else
X		error("FAILURE. User: %s");
X}
SHAR_EOF
chmod 0600 csu/csu.c ||
echo 'restore of csu/csu.c failed'
Wc_c="`wc -c < 'csu/csu.c'`"
test 3067 -eq "$Wc_c" ||
	echo 'csu/csu.c: original size 3067, current size' "$Wc_c"
fi
# ============= csu/csu.h ==============
if test -f 'csu/csu.h' -a X"$1" != X"-c"; then
	echo 'x - skipping csu/csu.h (File already exists)'
else
echo 'x - extracting csu/csu.h (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'csu/csu.h' &&
X/* Copyright 1993 by Scott Gustafson (scott@cadence.com) */
X
X#include <stdio.h>
X#include <stdlib.h>
X#include <string.h>
X#include <sys/stat.h>
X#include <sys/types.h>
X
X/* this is the password file and it's permissions */
X#define CSUNAME "/etc/csu.local"
X#define MODE 33152 /* rw------- */
X
X#define GID     9   /* put GID in the audit group */
X
X/* the maximum length of any string */
X#define MAX_LENGTH 255
SHAR_EOF
chmod 0600 csu/csu.h ||
echo 'restore of csu/csu.h failed'
Wc_c="`wc -c < 'csu/csu.h'`"
test 404 -eq "$Wc_c" ||
	echo 'csu/csu.h: original size 404, current size' "$Wc_c"
fi
# ============= csu/csu.local ==============
if test -f 'csu/csu.local' -a X"$1" != X"-c"; then
	echo 'x - skipping csu/csu.local (File already exists)'
else
echo 'x - extracting csu/csu.local (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'csu/csu.local' &&
Xscott   a1295c1a9110a584df24c12674f842c3
SHAR_EOF
chmod 0600 csu/csu.local ||
echo 'restore of csu/csu.local failed'
Wc_c="`wc -c < 'csu/csu.local'`"
test 41 -eq "$Wc_c" ||
	echo 'csu/csu.local: original size 41, current size' "$Wc_c"
fi
# ============= csu/encode.c ==============
if test -f 'csu/encode.c' -a X"$1" != X"-c"; then
	echo 'x - skipping csu/encode.c (File already exists)'
else
echo 'x - extracting csu/encode.c (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'csu/encode.c' &&
X/* Copyright 1993 by Scott Gustafson (scott@cadence.com) */
X
X#include <math.h>	/* abs() */
X
X#include "csu.h"
X#include "global.h"
X#include "md5.h"
X
X/* To change the number of characters that are possible, just add them to the
X * list here.  The functions will figure out how many are in the list */
X#ifdef SECURE
Xchar hex[] = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ!@#$%^&*()+=-[]{};:<>,.?";
X#else
Xchar hex[] = "0123456789abcdef";
X#endif /* SECURE */
X
X#ifndef SECURE
X/* The small version of the MD5 encode function */
Xvoid encode (char *password, char *userid) {
X	MD5_CTX context;
X	unsigned char digest[16];
X	unsigned int len;
X	char string[8];
X	short int i;
X	extern char hex[];
X
X	/* figure out the length of the hex string */
X	int hex_len = strlen(hex);
X
X	/* put the userid at the end of the password and calculate the length */
X	strcat(password, userid);
X	len = strlen(password);
X
X	/* MD5 the password/userid string */
X	MD5Init (&context);
X	MD5Update(&context, (unsigned char *)password, len);
X	MD5Final (digest, &context);
X
X	/* grab the low order of the last 8 bytes */
X	for(i = 8; i < 16; ++i) {
X		string[i-8] = hex[(int)digest[i]-(abs((int)digest[i]/hex_len))*hex_len];
X	}
X
X	strcpy(password, string);
X}
X#endif /* !SECURE */
X
Xvoid account_encode (char *password, char *userid) {
X        MD5_CTX context;
X        unsigned char digest[16];
X        unsigned int len;
X        char string[32];
X        short int i;
X        extern char hex[];
X
X	/* figure out the length of the hex string */
X	int hex_len = strlen(hex);
X
X	/* put the userid at the end of the password and calculate the length */
X        strcat(password, userid);
X        len = strlen(password);
X
X	/* MD5 the password/userid string */
X        MD5Init (&context);
X        MD5Update (&context, (unsigned char *)password, len);
X        MD5Final (digest, &context);
X
X	/* convert the digest into a string of bytes */
X        for(i = 0; i < 16; ++i) {
X                string[i*2] = hex[abs((int)digest[i]/hex_len)];
X                string[i*2+1] = hex[(int)digest[i]-(abs((int)digest[i]/hex_len))*hex_len];
X        }
X        strcpy(password, string);
X}
SHAR_EOF
chmod 0600 csu/encode.c ||
echo 'restore of csu/encode.c failed'
Wc_c="`wc -c < 'csu/encode.c'`"
test 2131 -eq "$Wc_c" ||
	echo 'csu/encode.c: original size 2131, current size' "$Wc_c"
fi
# ============= csu/genstr.c ==============
if test -f 'csu/genstr.c' -a X"$1" != X"-c"; then
	echo 'x - skipping csu/genstr.c (File already exists)'
else
echo 'x - extracting csu/genstr.c (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'csu/genstr.c' &&
X/* Copyright 1993 by Scott Gustafson (scott@cadence.com) */
X
X#include <time.h>	/* needed for time() */
X#include "csu.h"	/* needed for MAX_LENGTH */
X
X/* This function just gets the time and process id and converts it to a string. */
Xchar *genstr(void) {
X	char *randomstring;
X
X	/* I know that I probably don't need so much space for this string
X	 * but it doen't matter much.  If you are tight on space then change
X	 * it to something around 20 */
X
X	randomstring = malloc(sizeof(randomstring) * MAX_LENGTH);
X	sprintf(randomstring, "%d%d", (int)time(NULL), (int)getpid());
X
X#ifdef DEBUG
X	printf("String: %s\n",randomstring);
X#endif
X
X	return(randomstring);
X}
SHAR_EOF
chmod 0600 csu/genstr.c ||
echo 'restore of csu/genstr.c failed'
Wc_c="`wc -c < 'csu/genstr.c'`"
test 655 -eq "$Wc_c" ||
	echo 'csu/genstr.c: original size 655, current size' "$Wc_c"
fi
# ============= csu/global.h ==============
if test -f 'csu/global.h' -a X"$1" != X"-c"; then
	echo 'x - skipping csu/global.h (File already exists)'
else
echo 'x - extracting csu/global.h (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'csu/global.h' &&
X/* GLOBAL.H - RSAREF types and constants
X */
X
X/* PROTOTYPES should be set to one if and only if the compiler supports
X  function argument prototyping.
XThe following makes PROTOTYPES default to 0 if it has not already
X  been defined with C compiler flags.
X */
X#ifndef PROTOTYPES
X#define PROTOTYPES 1
X#endif
X
X/* POINTER defines a generic pointer type */
Xtypedef unsigned char *POINTER;
X
X/* UINT2 defines a two byte word */
Xtypedef unsigned short int UINT2;
X
X/* UINT4 defines a four byte word */
Xtypedef unsigned long int UINT4;
X
X/* PROTO_LIST is defined depending on how PROTOTYPES is defined above.
XIf using PROTOTYPES, then PROTO_LIST returns the list, otherwise it
X  returns an empty list.
X */
X#if PROTOTYPES
X#define PROTO_LIST(list) list
X#else
X#define PROTO_LIST(list) ()
X#endif
SHAR_EOF
chmod 0600 csu/global.h ||
echo 'restore of csu/global.h failed'
Wc_c="`wc -c < 'csu/global.h'`"
test 781 -eq "$Wc_c" ||
	echo 'csu/global.h: original size 781, current size' "$Wc_c"
fi
# ============= csu/log.c ==============
if test -f 'csu/log.c' -a X"$1" != X"-c"; then
	echo 'x - skipping csu/log.c (File already exists)'
else
echo 'x - extracting csu/log.c (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'csu/log.c' &&
X/* Copyright 1993 by Scott Gustafson (scott@cadence.com) */
X
X
X#include <stdio.h>	/* for fprintf() */
X#include <stdlib.h>	/* for exit() */
X#ifdef SYSLOG
X#include <syslog.h>
X#endif
X#include "log.h"
X
Xvoid setuploging(char *PGMNAME) {
X#ifdef SYSLOG
X	openlog(PGMNAME, LOG_PID & LOG_CONS, LOG_AUTH);
X#endif
X}
X
Xvoid log(char *message, char *userid) {
X#ifdef SYSLOG
X	syslog(LOG_NOTICE, message, userid);
X#endif
X	fprintf(stderr,"%s %s\n", message, userid);
X}
X
Xvoid error(char *message) {
X        extern char userid[];
X        log(message, userid);
X#ifdef SYSLOG
X        closelog();
X#endif
X        exit(-1);
X}
SHAR_EOF
chmod 0600 csu/log.c ||
echo 'restore of csu/log.c failed'
Wc_c="`wc -c < 'csu/log.c'`"
test 600 -eq "$Wc_c" ||
	echo 'csu/log.c: original size 600, current size' "$Wc_c"
fi
# ============= csu/log.h ==============
if test -f 'csu/log.h' -a X"$1" != X"-c"; then
	echo 'x - skipping csu/log.h (File already exists)'
else
echo 'x - extracting csu/log.h (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'csu/log.h' &&
X/* Copyright 1993 by Scott Gustafson (scott@cadence.com) */
X
Xvoid setuploging(char *program_name);
Xvoid log(char *message, char *user_id);
Xvoid error(char *message);
SHAR_EOF
chmod 0600 csu/log.h ||
echo 'restore of csu/log.h failed'
Wc_c="`wc -c < 'csu/log.h'`"
test 166 -eq "$Wc_c" ||
	echo 'csu/log.h: original size 166, current size' "$Wc_c"
fi
# ============= csu/md5-announcement.txt ==============
if test -f 'csu/md5-announcement.txt' -a X"$1" != X"-c"; then
	echo 'x - skipping csu/md5-announcement.txt (File already exists)'
else
echo 'x - extracting csu/md5-announcement.txt (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'csu/md5-announcement.txt' &&
X		 MD5 -- New Message Digest Algorithm
X		  (Feel free to distribute further)
X
XRSA Data Security is announcing MD5, a new message-digest algorithm.
XLike MD4, this algorithm is being placed in the public domain for free
Xgeneral use.
X
XThe MD5 algorithm is a strengthened version of MD4.  It has four
Xrounds instead of three, and incorporates other revisions based on a
Xyear's worth of collected comments on the MD4 algorithm.  For example,
Xthe input access patterns in rounds two and three have been improved,
Xand the rotation amounts have been optimized for maximum ``avalanche
Xeffect.''  The additive constants have been made unique in each step,
Xand an additional dependence of each step on the previous one has been
Xadded.
X
XThese changes cause MD5 to be somewhat slower than MD4.  We estimate
Xthat MD5 will typically run about 15-30% slower than MD4, depending on
Xthe degree to which the versions of MD4 and MD5 have been optimized.
XThe more they are both optimized, the greater the percentage
Xdifference in speed.  An optimized version of MD5 on a Sun
XSparcStation runs at about 890 Kbytes/second.
X
XWhy MD5?  While we do not know of any way to ``break'' MD4, we feel
Xthat MD4 is being pressed into service far too quickly for such an
X``aggressive'' design.  We have been surprised at the speed with which
XMD4 is being designed into products.  MD5 is ``MD4 with seatbelts''
Xand thus, as a more conservative design, is more suitable for rapid
Xdeployment.
X
XIt is the intent of RSA Data Security to use MD5 in its products and
Xstandards instead of MD4.  We recommend that our customers generally
Xdo the same, unless there is an overwhelming need for the higher speed
Xof MD4.  Copies of the MD5 algorithm, including a reference
Ximplementation in C, are available from the company.  (Over the
XInternet, you can access this documentation by anonymous FTP to
Xrsa.com and obtaining the file pub/md5.doc.)
SHAR_EOF
chmod 0600 csu/md5-announcement.txt ||
echo 'restore of csu/md5-announcement.txt failed'
Wc_c="`wc -c < 'csu/md5-announcement.txt'`"
test 1898 -eq "$Wc_c" ||
	echo 'csu/md5-announcement.txt: original size 1898, current size' "$Wc_c"
fi
# ============= csu/md5.c ==============
if test -f 'csu/md5.c' -a X"$1" != X"-c"; then
	echo 'x - skipping csu/md5.c (File already exists)'
else
echo 'x - extracting csu/md5.c (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'csu/md5.c' &&
X/* * Last edited: Jul 13 12:12 1992 (rice) */
X/* MD5C.C - RSA Data Security, Inc., MD5 message-digest algorithm
X */
X
X/* Copyright (C) 1991-2, RSA Data Security, Inc. Created 1991. All
Xrights reserved.
X
XLicense to copy and use this software is granted provided that it
Xis identified as the "RSA Data Security, Inc. MD5 Message-Digest
XAlgorithm" in all material mentioning or referencing this software
Xor this function.
X
XLicense is also granted to make and use derivative works provided
Xthat such works are identified as "derived from the RSA Data
XSecurity, Inc. MD5 Message-Digest Algorithm" in all material
Xmentioning or referencing the derived work.
X
XRSA Data Security, Inc. makes no representations concerning either
Xthe merchantability of this software or the suitability of this
Xsoftware for any particular purpose. It is provided "as is"
Xwithout express or implied warranty of any kind.
X
XThese notices must be retained in any copies of any part of this
Xdocumentation and/or software.
X */
X
X#include "global.h"
X#include "md5.h"
X
X/* Constants for MD5Transform routine.
X */
X
X#define S11 7
X#define S12 12
X#define S13 17
X#define S14 22
X#define S21 5
X#define S22 9
X#define S23 14
X#define S24 20
X#define S31 4
X#define S32 11
X#define S33 16
X#define S34 23
X#define S41 6
X#define S42 10
X#define S43 15
X#define S44 21
X
Xstatic void MD5Transform PROTO_LIST ((UINT4 [4], unsigned char [64]));
Xstatic void Encode PROTO_LIST
X  ((unsigned char *, UINT4 *, unsigned int));
Xstatic void Decode PROTO_LIST
X  ((UINT4 *, unsigned char *, unsigned int));
Xstatic void MD5_memcpy PROTO_LIST ((POINTER, POINTER, unsigned int));
Xstatic void MD5_memset PROTO_LIST ((POINTER, int, unsigned int));
X
Xstatic unsigned char PADDING[64] = {
X  0x80, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
X  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
X  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
X};
X
X/* F, G, H and I are basic MD5 functions.
X */
X#define F(x, y, z) (((x) & (y)) | ((~x) & (z)))
X#define G(x, y, z) (((x) & (z)) | ((y) & (~z)))
X#define H(x, y, z) ((x) ^ (y) ^ (z))
X#define I(x, y, z) ((y) ^ ((x) | (~z)))
X
X/* ROTATE_LEFT rotates x left n bits.
X */
X#define ROTATE_LEFT(x, n) (((x) << (n)) | ((x) >> (32-(n))))
X
X/* FF, GG, HH, and II transformations for rounds 1, 2, 3, and 4.
XRotation is separate from addition to prevent recomputation.
X */
X#define FF(a, b, c, d, x, s, ac) { \
X (a) += F ((b), (c), (d)) + (x) + (UINT4)(ac); \
X (a) = ROTATE_LEFT ((a), (s)); \
X (a) += (b); \
X  }
X#define GG(a, b, c, d, x, s, ac) { \
X (a) += G ((b), (c), (d)) + (x) + (UINT4)(ac); \
X (a) = ROTATE_LEFT ((a), (s)); \
X (a) += (b); \
X  }
X#define HH(a, b, c, d, x, s, ac) { \
X (a) += H ((b), (c), (d)) + (x) + (UINT4)(ac); \
X (a) = ROTATE_LEFT ((a), (s)); \
X (a) += (b); \
X  }
X#define II(a, b, c, d, x, s, ac) { \
X (a) += I ((b), (c), (d)) + (x) + (UINT4)(ac); \
X (a) = ROTATE_LEFT ((a), (s)); \
X (a) += (b); \
X  }
X
X/* MD5 initialization. Begins an MD5 operation, writing a new context.
X */
Xvoid MD5Init (context)
XMD5_CTX *context;                                        /* context */
X{
X  context->count[0] = context->count[1] = 0;
X  /* Load magic initialization constants.
X*/
X  context->state[0] = 0x67452301;
X  context->state[1] = 0xefcdab89;
X  context->state[2] = 0x98badcfe;
X  context->state[3] = 0x10325476;
X}
X
X/* MD5 block update operation. Continues an MD5 message-digest
X  operation, processing another message block, and updating the
X  context.
X */
Xvoid MD5Update (context, input, inputLen)
XMD5_CTX *context;                                        /* context */
Xunsigned char *input;                                /* input block */
Xunsigned int inputLen;                     /* length of input block */
X{
X  unsigned int i, index, partLen;
X
X  /* Compute number of bytes mod 64 */
X  index = (unsigned int)((context->count[0] >> 3) & 0x3F);
X
X  /* Update number of bits */
X  if ((context->count[0] += ((UINT4)inputLen << 3))
X   < ((UINT4)inputLen << 3))
X context->count[1]++;
X  context->count[1] += ((UINT4)inputLen >> 29);
X
X  partLen = 64 - index;
X
X  /* Transform as many times as possible.
X*/
X  if (inputLen >= partLen) {
X MD5_memcpy
X   ((POINTER)&context->buffer[index], (POINTER)input, partLen);
X MD5Transform (context->state, context->buffer);
X
X for (i = partLen; i + 63 < inputLen; i += 64)
X   MD5Transform (context->state, &input[i]);
X
X index = 0;
X  }
X  else
X i = 0;
X
X  /* Buffer remaining input */
X  MD5_memcpy
X ((POINTER)&context->buffer[index], (POINTER)&input[i],
X  inputLen-i);
X}
X
X/* MD5 finalization. Ends an MD5 message-digest operation, writing the
X  the message digest and zeroizing the context.
X */
Xvoid MD5Final (digest, context)
Xunsigned char digest[16];                         /* message digest */
XMD5_CTX *context;                                       /* context */
X{
X  unsigned char bits[8];
X  unsigned int index, padLen;
X
X  /* Save number of bits */
X  Encode (bits, context->count, 8);
X
X  /* Pad out to 56 mod 64.
X*/
X  index = (unsigned int)((context->count[0] >> 3) & 0x3f);
X  padLen = (index < 56) ? (56 - index) : (120 - index);
X  MD5Update (context, PADDING, padLen);
X
X  /* Append length (before padding) */
X  MD5Update (context, bits, 8);
X
X  /* Store state in digest */
X  Encode (digest, context->state, 16);
X
X  /* Zeroize sensitive information.
X*/
X  MD5_memset ((POINTER)context, 0, sizeof (*context));
X}
X
X/* MD5 basic transformation. Transforms state based on block.
X */
Xstatic void MD5Transform (state, block)
XUINT4 state[4];
Xunsigned char block[64];
X{
X  UINT4 a = state[0], b = state[1], c = state[2], d = state[3], x[16];
X
X  Decode (x, block, 64);
X
X  /* Round 1 */
X  FF (a, b, c, d, x[ 0], S11, 0xd76aa478); /* 1 */
X  FF (d, a, b, c, x[ 1], S12, 0xe8c7b756); /* 2 */
X  FF (c, d, a, b, x[ 2], S13, 0x242070db); /* 3 */
X  FF (b, c, d, a, x[ 3], S14, 0xc1bdceee); /* 4 */
X  FF (a, b, c, d, x[ 4], S11, 0xf57c0faf); /* 5 */
X  FF (d, a, b, c, x[ 5], S12, 0x4787c62a); /* 6 */
X  FF (c, d, a, b, x[ 6], S13, 0xa8304613); /* 7 */
X  FF (b, c, d, a, x[ 7], S14, 0xfd469501); /* 8 */
X  FF (a, b, c, d, x[ 8], S11, 0x698098d8); /* 9 */
X  FF (d, a, b, c, x[ 9], S12, 0x8b44f7af); /* 10 */
X  FF (c, d, a, b, x[10], S13, 0xffff5bb1); /* 11 */
X  FF (b, c, d, a, x[11], S14, 0x895cd7be); /* 12 */
X  FF (a, b, c, d, x[12], S11, 0x6b901122); /* 13 */
X  FF (d, a, b, c, x[13], S12, 0xfd987193); /* 14 */
X  FF (c, d, a, b, x[14], S13, 0xa679438e); /* 15 */
X  FF (b, c, d, a, x[15], S14, 0x49b40821); /* 16 */
X
X /* Round 2 */
X  GG (a, b, c, d, x[ 1], S21, 0xf61e2562); /* 17 */
X  GG (d, a, b, c, x[ 6], S22, 0xc040b340); /* 18 */
X  GG (c, d, a, b, x[11], S23, 0x265e5a51); /* 19 */
X  GG (b, c, d, a, x[ 0], S24, 0xe9b6c7aa); /* 20 */
X  GG (a, b, c, d, x[ 5], S21, 0xd62f105d); /* 21 */
X  GG (d, a, b, c, x[10], S22,  0x2441453); /* 22 */
X  GG (c, d, a, b, x[15], S23, 0xd8a1e681); /* 23 */
X  GG (b, c, d, a, x[ 4], S24, 0xe7d3fbc8); /* 24 */
X  GG (a, b, c, d, x[ 9], S21, 0x21e1cde6); /* 25 */
X  GG (d, a, b, c, x[14], S22, 0xc33707d6); /* 26 */
X  GG (c, d, a, b, x[ 3], S23, 0xf4d50d87); /* 27 */
X  GG (b, c, d, a, x[ 8], S24, 0x455a14ed); /* 28 */
X  GG (a, b, c, d, x[13], S21, 0xa9e3e905); /* 29 */
X  GG (d, a, b, c, x[ 2], S22, 0xfcefa3f8); /* 30 */
X  GG (c, d, a, b, x[ 7], S23, 0x676f02d9); /* 31 */
X  GG (b, c, d, a, x[12], S24, 0x8d2a4c8a); /* 32 */
X
X  /* Round 3 */
X  HH (a, b, c, d, x[ 5], S31, 0xfffa3942); /* 33 */
X  HH (d, a, b, c, x[ 8], S32, 0x8771f681); /* 34 */
X  HH (c, d, a, b, x[11], S33, 0x6d9d6122); /* 35 */
X  HH (b, c, d, a, x[14], S34, 0xfde5380c); /* 36 */
X  HH (a, b, c, d, x[ 1], S31, 0xa4beea44); /* 37 */
X  HH (d, a, b, c, x[ 4], S32, 0x4bdecfa9); /* 38 */
X  HH (c, d, a, b, x[ 7], S33, 0xf6bb4b60); /* 39 */
X  HH (b, c, d, a, x[10], S34, 0xbebfbc70); /* 40 */
X  HH (a, b, c, d, x[13], S31, 0x289b7ec6); /* 41 */
X  HH (d, a, b, c, x[ 0], S32, 0xeaa127fa); /* 42 */
X  HH (c, d, a, b, x[ 3], S33, 0xd4ef3085); /* 43 */
X  HH (b, c, d, a, x[ 6], S34,  0x4881d05); /* 44 */
X  HH (a, b, c, d, x[ 9], S31, 0xd9d4d039); /* 45 */
X  HH (d, a, b, c, x[12], S32, 0xe6db99e5); /* 46 */
X  HH (c, d, a, b, x[15], S33, 0x1fa27cf8); /* 47 */
X  HH (b, c, d, a, x[ 2], S34, 0xc4ac5665); /* 48 */
X
X  /* Round 4 */
X  II (a, b, c, d, x[ 0], S41, 0xf4292244); /* 49 */
X  II (d, a, b, c, x[ 7], S42, 0x432aff97); /* 50 */
X  II (c, d, a, b, x[14], S43, 0xab9423a7); /* 51 */
X  II (b, c, d, a, x[ 5], S44, 0xfc93a039); /* 52 */
X  II (a, b, c, d, x[12], S41, 0x655b59c3); /* 53 */
X  II (d, a, b, c, x[ 3], S42, 0x8f0ccc92); /* 54 */
X  II (c, d, a, b, x[10], S43, 0xffeff47d); /* 55 */
X  II (b, c, d, a, x[ 1], S44, 0x85845dd1); /* 56 */
X  II (a, b, c, d, x[ 8], S41, 0x6fa87e4f); /* 57 */
X  II (d, a, b, c, x[15], S42, 0xfe2ce6e0); /* 58 */
X  II (c, d, a, b, x[ 6], S43, 0xa3014314); /* 59 */
X  II (b, c, d, a, x[13], S44, 0x4e0811a1); /* 60 */
X  II (a, b, c, d, x[ 4], S41, 0xf7537e82); /* 61 */
X  II (d, a, b, c, x[11], S42, 0xbd3af235); /* 62 */
X  II (c, d, a, b, x[ 2], S43, 0x2ad7d2bb); /* 63 */
X  II (b, c, d, a, x[ 9], S44, 0xeb86d391); /* 64 */
X
X  state[0] += a;
X  state[1] += b;
X  state[2] += c;
X  state[3] += d;
X
X  /* Zeroize sensitive information.
X*/
X  MD5_memset ((POINTER)x, 0, sizeof (x));
X}
X
X/* Encodes input (UINT4) into output (unsigned char). Assumes len is
X  a multiple of 4.
X */
Xstatic void Encode (output, input, len)
Xunsigned char *output;
XUINT4 *input;
Xunsigned int len;
X{
X  unsigned int i, j;
X
X  for (i = 0, j = 0; j < len; i++, j += 4) {
X output[j] = (unsigned char)(input[i] & 0xff);
X output[j+1] = (unsigned char)((input[i] >> 8) & 0xff);
X output[j+2] = (unsigned char)((input[i] >> 16) & 0xff);
X output[j+3] = (unsigned char)((input[i] >> 24) & 0xff);
X  }
X}
X
X/* Decodes input (unsigned char) into output (UINT4). Assumes len is
X  a multiple of 4.
X */
Xstatic void Decode (output, input, len)
XUINT4 *output;
Xunsigned char *input;
Xunsigned int len;
X{
X  unsigned int i, j;
X
X  for (i = 0, j = 0; j < len; i++, j += 4)
X output[i] = ((UINT4)input[j]) | (((UINT4)input[j+1]) << 8) |
X   (((UINT4)input[j+2]) << 16) | (((UINT4)input[j+3]) << 24);
X}
X
X/* Note: Replace "for loop" with standard memcpy if possible.
X */
X
Xstatic void MD5_memcpy (output, input, len)
XPOINTER output;
XPOINTER input;
Xunsigned int len;
X{
X  unsigned int i;
X
X  for (i = 0; i < len; i++)
X output[i] = input[i];
X}
X
X/* Note: Replace "for loop" with standard memset if possible.
X */
Xstatic void MD5_memset (output, value, len)
XPOINTER output;
Xint value;
Xunsigned int len;
X{
X  unsigned int i;
X
X  for (i = 0; i < len; i++)
X ((char *)output)[i] = (char)value;
X}
SHAR_EOF
chmod 0600 csu/md5.c ||
echo 'restore of csu/md5.c failed'
Wc_c="`wc -c < 'csu/md5.c'`"
test 10471 -eq "$Wc_c" ||
	echo 'csu/md5.c: original size 10471, current size' "$Wc_c"
fi
# ============= csu/md5.h ==============
if test -f 'csu/md5.h' -a X"$1" != X"-c"; then
	echo 'x - skipping csu/md5.h (File already exists)'
else
echo 'x - extracting csu/md5.h (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'csu/md5.h' &&
X/* * Last edited: Jul 13 12:07 1992 (rice) */
X/* MD5.H - header file for MD5C.C
X */
X
X/* Copyright (C) 1991-2, RSA Data Security, Inc. Created 1991. All
Xrights reserved.
X
XLicense to copy and use this software is granted provided that it
Xis identified as the "RSA Data Security, Inc. MD5 Message-Digest
XAlgorithm" in all material mentioning or referencing this software
Xor this function.
X
XLicense is also granted to make and use derivative works provided
Xthat such works are identified as "derived from the RSA Data
XSecurity, Inc. MD5 Message-Digest Algorithm" in all material
Xmentioning or referencing the derived work.
X
XRSA Data Security, Inc. makes no representations concerning either
Xthe merchantability of this software or the suitability of this
Xsoftware for any particular purpose. It is provided "as is"
Xwithout express or implied warranty of any kind.
X
XThese notices must be retained in any copies of any part of this
Xdocumentation and/or software.
X */
X
X/* MD5 context. */
Xtypedef struct {
X  UINT4 state[4];                                   /* state (ABCD) */
X  UINT4 count[2];        /* number of bits, modulo 2^64 (lsb first) */
X  unsigned char buffer[64];                         /* input buffer */
X} MD5_CTX;
X
Xvoid MD5Init PROTO_LIST ((MD5_CTX *));
Xvoid MD5Update PROTO_LIST ((MD5_CTX *, unsigned char *, unsigned int));
Xvoid MD5Final PROTO_LIST ((unsigned char [16], MD5_CTX *));
SHAR_EOF
chmod 0600 csu/md5.h ||
echo 'restore of csu/md5.h failed'
Wc_c="`wc -c < 'csu/md5.h'`"
test 1394 -eq "$Wc_c" ||
	echo 'csu/md5.h: original size 1394, current size' "$Wc_c"
fi
# ============= csu/new-account.c ==============
if test -f 'csu/new-account.c' -a X"$1" != X"-c"; then
	echo 'x - skipping csu/new-account.c (File already exists)'
else
echo 'x - extracting csu/new-account.c (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'csu/new-account.c' &&
X/* Copyright 1993 by Scott Gustafson (scott@cadence.com) */
X
X#include "csu.h"
X#include "log.h"
X
X#define PGMNAME "new-account"
X
Xchar userid[8];
Xchar newuserid[8];
X
X/* This program is for creating password entries in the csu.local file */
Xvoid main() {
X	char *password, buffer[MAX_LENGTH], temp[MAX_LENGTH];
X	extern char userid[], newuserid[];
X	FILE *csu_file;
X	short int done = 0;
X
X	setuploging(PGMNAME);
X
X	password = (char *)malloc(sizeof(password) * MAX_LENGTH);
X
X        /* get the userid of the caller */
X        sprintf(userid, "%s", getenv("USER"));
X
X	printf("User ID(login): ");
X	fflush(stdin);
X	fscanf(stdin, "%s", newuserid);
X
X	/* check to see if the userid is already in the password file */
X
X	if((csu_file = fopen(CSUNAME, "r")) == NULL)
X		error("FILE Access Denied: %s");
X
X	while ((fgets(buffer, MAX_LENGTH, csu_file) != NULL) && (done != 1)) {
X		strcpy(temp, strtok(buffer, "\t\n "));
X
X		if (strcmp(temp, newuserid) == 0) {
X			printf("You need to manually delete the old account for user: %s\n", newuserid);
X			fclose(csu_file);
X			exit(0);
X		}
X	}
X	fclose(csu_file);
X
X	printf("Password: ");
X
X	/* it would be better to hide the password from being echoed */
X	fflush(stdin);
X	fgets(password, MAX_LENGTH, stdin);
X
X	account_encode(password, newuserid);
X
X	if ((csu_file = fopen(CSUNAME, "a")) == NULL)
X		error("FILE Access Denied: %s");
X
X	fprintf(csu_file, "%s\t%s\n", newuserid, password);
X	fclose(csu_file);
X}
SHAR_EOF
chmod 0600 csu/new-account.c ||
echo 'restore of csu/new-account.c failed'
Wc_c="`wc -c < 'csu/new-account.c'`"
test 1419 -eq "$Wc_c" ||
	echo 'csu/new-account.c: original size 1419, current size' "$Wc_c"
fi
# ============= csu/respond.c ==============
if test -f 'csu/respond.c' -a X"$1" != X"-c"; then
	echo 'x - skipping csu/respond.c (File already exists)'
else
echo 'x - extracting csu/respond.c (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'csu/respond.c' &&
X/* Copyright 1993 by Scott Gustafson (scott@cadence.com) */
X
X#include "csu.h"
X#include "log.h"
X
X#define PGMNAME "respond"
X
Xchar userid[8];
X
Xvoid main(int argc, char **argv) {
X	/* string variables */
X	char *randstr, *string, *password;
X	extern char userid[];
X
X	setuploging(PGMNAME);
X
X        randstr = (char *)malloc(sizeof(randstr) * MAX_LENGTH);
X        string = (char *)malloc(sizeof(string) * MAX_LENGTH * 2);
X	password = (char *)malloc(sizeof(password) * MAX_LENGTH);
X
X	/* get userid of caller */
X	sprintf(userid, "%s", getenv("USER"));
X
X	/* verify that program was invoked with the correct name */
X	if (strcmp(PGMNAME,argv[0]) != 0 )
X	    error("INVALID NAME Access Denied: %s");
X
X	/* get remote prompt*/
X	printf("Delta: ");
X	scanf("%s", randstr);
X
X	/* get the user's password */
X	printf("Password: ");
X	fflush(stdin);
X	fgets(password, MAX_LENGTH, stdin);
X	account_encode(password, userid);
X
X	/*   Compute local response*/
X	strcpy(string, randstr);
X	strcat(string, password);
X#ifdef SECURE
X	account_encode(string, userid);
X#else
X	encode(string, userid);
X#endif /* SECURE */
X
X	printf("Response: %s\n", string);
X}
SHAR_EOF
chmod 0600 csu/respond.c ||
echo 'restore of csu/respond.c failed'
Wc_c="`wc -c < 'csu/respond.c'`"
test 1117 -eq "$Wc_c" ||
	echo 'csu/respond.c: original size 1117, current size' "$Wc_c"
fi
exit 0
