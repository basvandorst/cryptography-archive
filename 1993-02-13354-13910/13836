Path: msuinfo!uwm.edu!rpi!gatech!darwin.sura.net!sgiblab!munnari.oz.au!yoyo.aarnet.edu.au!news.adelaide.edu.au!spam!ross
From: ross@spam.maths.adelaide.edu.au (Ross Williams)
Newsgroups: sci.crypt
Subject: Is this CRC algorithm non-stupid?
Summary: Is this CRC algorithm non-stupid?
Keywords: crc algorithm
Message-ID: <2246@spam.maths.adelaide.edu.au>
Date: 25 Feb 93 05:26:41 GMT
Sender: ross@spam.maths.adelaide.edu.au
Followup-To: sci.crypt
Distribution: world
Organization: Statistics, Pure & Applied Mathematics, University of Adelaide
Lines: 77

Crypto Netters,

In 1989, I needed a simple, fast checksum algorithm in a hurry. I
looked around and couldn't find anything obvious available (I didn't
look too hard) so I invented a simple 16-bit checksum myself. I have
been using it ever since. It is:

   checksum(m[    ]) = 0
   checksum(m[1..n]) = (3*checksum(m[1..n-1]) + m[n] + 1) mod 65536

(where m is the message, being a string of bytes each of which has a
 value in the range [0,255]).

The algorithm has the following advantages which make it very
attractive as a quick and portable checksum algorithm.

   * It is so clean and simple, it is hard not to memorize!
   * It encourages fast machine code implementations:
     - Implement the multiply with 3 add instructions.
     - Implement the mod with a mask.
   * It encourages simply high level language implementations:
     - It requires only 16 bit integers (with overflow as in C).
     - It will never overflow 32-bit integers (e.g. in Vax Pascal).

All these advantages aside, I have no idea if it is actually any good
as a checksum algorithm! I don't expect it to be a very good checksum
algorithm - it was never intended to be that. What I am interested in
finding out is whether it is a reasonable one. It would be silly if it
turns out that it is only checksumming the last 53 bytes or something
like that!

If anyone out there who knows about these things could pronounce it
"reasonable" or "silly" (with a brief explanation), I would be most
grateful. Don't go to too much bother --- I'm sure this is old stuff
and that there will be a couple of people out there who will know the
answer on sight. Please email replies to "ross@spam.adelaide.edu.au".
All replies will be treated as public.

Thanks,

Ross Williams
ross@spam.adelaide.edu.au

PS: Here is a quick and dirty implementation.

#include <stdio.h>

int error (s)
char *s;
{
 printf("%s.\n",s);
}

main(argc,argv)
int argc;
char **argv;
{
 FILE *sloth;
 unsigned long length = 0;
 unsigned long crc = 0;

 sloth = fopen("x.x","rb");
 if (sloth == NULL)
   error("error opening");
 while (1)
   {
      int ch = getc(sloth);
      if (ch == EOF) break;
      length++;
      crc = (3*crc + ((unsigned long) ch) +1  ) & 0xFFFF;
    }
 printf("Length   = %lu.\n",length);
 printf("Checksum = %lu.\n",crc);
 close(sloth);
}


