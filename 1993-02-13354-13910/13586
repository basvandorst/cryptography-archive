Path: msuinfo!caen!sdd.hp.com!cs.utexas.edu!swrinde!gatech!purdue!mentor.cc.purdue.edu!noose.ecn.purdue.edu!sparkyfs.erg.sri.com!csl.sri.com!boucher
From: boucher@csl.sri.com (Peter K. Boucher)
Newsgroups: sci.crypt
Subject: Re: What's wrong with this picture?
Date: 12 Feb 1993 17:07:04 GMT
Organization: Computer Science Lab, SRI International
Lines: 51
Distribution: world
Message-ID: <1lglfoINN2hb@roche.csl.sri.com>
References: <3598@blue.cis.pitt.edu> <1993Feb10.220507.17664@csi.uottawa.ca> <PHR.93Feb11123607@napa.telebit.com>
NNTP-Posting-Host: assault.csl.sri.com

In article <PHR.93Feb11123607@napa.telebit.com>, phr@telebit.com (Paul Rubin) writes:
|> In article <1993Feb10.220507.17664@csi.uottawa.ca> cbbrowne@csi.uottawa.ca (Christopher Browne) writes:
|>
|>    What's wrong with the system is that there still is a cycle.  If one
|>    RNG has a cycle of 10000 and the other has a cycle of 20000, then it's
|>    POSSIBLE that the joint cycle is 10000x20000, or 20,000,000.  (On the
|>    other hand, there may be some cancelling, so that the joint cycle
|>    might be a lot less).
|>
|>    The point is that the combined RNG function can probably be
|>    simplified, so that you essentially wind up with a "single" RNG.
|>
|> It's much worse than this.  Here's a method I thought up in about 2 minutes
|> last time someone asked this question (the question should go in the FAQ).
|> Maybe a better method is available.
|>
|> Let x[i] be the output of the first generator, y[i] the second, and
|> let the periods be A and B respectively.  Say you encrypt a big
|> block of zeros so the output is z[i] = x[i] ^ y[i].  Now the first
|> A+B words of output give you a very sparse system of A+B linear
|> equations in A+B unknowns, since xor is just addition mod 2.
|> (Here the x[i] and y[i] are the unknowns and the z[i] are known).
|> Look in any numerical analysis book to learn how to solve such systems.

What if you use four RNGs, and used feedback to re-seed the third
and fourth?

For example:

        output = input ^ rnd1() ^ rnd2() ^ rnd3() ^ rnd4();
        if (ENCRYPTING) {
                feedback1 = output ^ rnd4();
                feedback2 = input ^ rnd3();
        } else /* DECRYPTING */ {
                feedback1 = input ^ rnd4();
                feedback2 = output ^ rnd3();
        }
        rnd3_seed(feedback1);
        rnd4_seed(feedback2);

With a 128-bit key (four 32-bit initial seeds), brute-force would be
challenging.  1) I think the cycle is now gone, so, what's the
weakness?  2) How would your analysis change if the RNGs were all
extremely fast, but relatively weak (evenly distributed output, but
cycles under 10,000)?  3) What if rnd3 and rnd4 were fast-but-weak,
while rnd1 and rnd2 were strong?

-- 
Peter K. Boucher
--
RIPEM public key available upon request.
