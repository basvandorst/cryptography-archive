Path: msuinfo!uwm.edu!spool.mu.edu!yale.edu!ira.uka.de!math.fu-berlin.de!mailgzrz.TU-Berlin.DE!news.netmbx.de!Germany.EU.net!mcsun!sun4nl!cwi.nl!dik
From: dik@cwi.nl (Dik T. Winter)
Newsgroups: sci.crypt,sci.math
Subject: Re: "Card-shuffling" algorithms
Message-ID: <9023@charon.cwi.nl>
Date: 28 Feb 93 01:51:38 GMT
References: <1993Feb25.201917.1717@ee.eng.ohio-state.edu> <1mmhpqINNhr5@uwm.edu>
Sender: news@cwi.nl
Followup-To: sci.crypt
Organization: CWI, Amsterdam
Lines: 45
Xref: msuinfo sci.crypt:13910 sci.math:40255

In article <1mmhpqINNhr5@uwm.edu> markh@csd4.csd.uwm.edu (Mark) writes:
 > In article <1993Feb25.201917.1717@ee.eng.ohio-state.edu> butzerd@columbia.eng.ohio-state.edu (Dane C. Butzer) writes:
 > >Does anybody know of an algorithm that will randomly shuffle a deck in one
 > >pass, with one random number chosen per card, given a "good" random number
 > >generator?  Is such an algorithm even believed to be possible?
 > 
 > Impossible.  Shuffling is the inverse of sorting, which is an N log(N)
 > process.  Therefore you need log(N) passes at the very least.
Wrong.  Take the following shuffling algorithm to shuffle an array with
N entries:
   for i in 1..N
       interchange(a[i], a[random(i, N)])
where random delivers a random number (normally distributed) between its
first and its second argument.  (So random(0,1) delivers 0 or 1 with 50%
probability each.)  This gives a perfect shuffle, i.e. each permutation
has equal probability to come out.  The random number generator is used
only N times.
 > 
 > Take any comparison-based sorting algorithm at all.  Replace the comparison
 > operation:
 > Compare(A, B) = 0 if A <= B
 >                 1 if A > B
 > with the randomizer
 > Random(A, B) = 0 or 1 with equal probability.
 > The result is a shuffling algorithm.
This is not a perfect shuffle.  Doing K steps for it gives 2^K possible
outcomes.  So the permutations that it yields are not equi-probable.
(N! does not divide 2^K for all N > 2).

However, the original question is a bit ill-posed (as the writer already
did notice, see the quotation marks around the word "good").
If you start with a random number generator that yields random numbers
in a fixed range (be it fixed or floating point with finite arithmetic),
as you normally do when you try to program it, the answer is "no".
Suppose your random number generator gives numbers in the range (0,M+1)
(and suppose that M >= N).  (Floating point is just scaled integer and
I am too lazy to do M < N just now.)  In that case the expected number
of calls to the basic random number generator to get a result for the
above defined function random(A, B) [A,B <= N] is: (1-X)^-2 where
X = (M mod (B - A + 1)) / M.  I do not want to try to sum that.
But as X < 1/2 we have an expected number of calls less than 4.  So
the total number of calls is less than 4N.
-- 
dik t. winter, cwi, kruislaan 413, 1098 sj  amsterdam, nederland
home: bovenover 215, 1025 jn  amsterdam, nederland; e-mail: dik@cwi.nl
