Path: msuinfo!caen!uakari.primate.wisc.edu!ames!decwrl!hoptoad!wet!wet.UUCP
From: naga@wet.UUCP (Peter Davidson)
Newsgroups: sci.crypt
Subject: C source code for frequency analysis program
Message-ID: <3248@wet.UUCP>
Date: 19 Jan 92 09:53:11 GMT
Sender: naga@wet.UUCP
Distribution: usa
Organization: Wetware Diversions, San Francisco
Lines: 178

omeone wishing to pursue the frequency analysis studies I've been
presenting here (sci.crypt) recently requested a copy of the frequency
program.  Others may find this useful for other kinds of cryptanalytical
investigations.  Here is the program in source code form for anyone who
wishes to use it.
 
/*  MOSTFREQ.C
 *  Displays count of most-frequent bytes in a file
 *  Written by Dolphin Software
 *  Last revision: 1992-01-18
 *  Compiler: Microsoft C 6.00A
 *  Model: small
 *  Libraries: standard
 */
 
#include <STDIO.H>
#include <STDLIB.H>
#include <FCNTL.H>
#include <SYS\TYPES.H>
#include <SYS\STAT.H>
#include <IO.H>
 
#define NBUFSIZE 0xE000
#define TRUE 1
 
char *usage = "\nUse: MOSTFREQ file [n]\n"
              "This displays the frequency of\n"
              "the n most-frequent bytes in the file.\n"
              "Default value for n is 20.\n";
 
struct stat stat_buff;
unsigned char buf[NBUFSIZE];
long freq[256];
 
void main(int argc, char *argv[]);
int get_byte_distribution(unsigned char *file, long n[]);
 
void main(int argc, char *argv[])
{
long this_freq;
int result, i, n, m=0, num_diff_bytes=0;
 
if ( argc < 2 )
    {
    printf(usage);
    exit(1);
    }
 
if ( argc == 2 )
    n = 20;
else
    {
    n = atoi(argv[2]);
    if ( n < 1 || n > 256 )
        {
        printf("Invalid n parameter.\n");
        exit(2);
        }
    }
 
result = get_byte_distribution(argv[1],freq);
if ( result )
    {
    switch ( result )
        {
        case -1:
            printf("Cannot open file %s.\n",argv[1]);
            break;
        case -2:
            printf("Cannot read file %s.\n",argv[1]);
            break;
        case -4:
            printf("Some byte in %s occurs more than 2,000,000,000 times.\n",
                argv[1]);
            break;
        }
    if ( result != -4 )
        exit(result);
    }
 
/*  analyse the data  */
for ( i=0; i<256; i++ )
    num_diff_bytes += ( freq[i] != 0 );
 
/*  get file size  */
stat(argv[1],&stat_buff);
 
/*  print the results  */
printf("\nMOSTFREQ by Dolphin Software");
printf("\nFile %s contains %ld bytes and %d different byte values.\n",
    argv[1],stat_buff.st_size,num_diff_bytes);
printf("  Rank     Byte      Frequency   ASCII value\n");
while ( TRUE  )
    {
    /*  find maximum or next lower frequency  */
    this_freq = 0L;
    for ( i=0; i<256; i++ )
        {
        if ( freq[i] > this_freq )
            this_freq = freq[i];
        }
    if ( !this_freq )
        {
        printf("Remaining byte values do not occur in this file.\n");
        exit(0);
        }
    for ( i=0; i<256; i++ )
        {
        if ( freq[i] == this_freq )
            {
            printf("%5d   %3d = 0x%02X   %9ld      ",
                ++m,i,i,this_freq);
            switch ( i )
                {
                case   0: printf("null");     break;
                case   9: printf("tab");      break;
                case  10: printf("linefeed"); break;
                case  12: printf("formfeed"); break;
                case  13: printf("return");   break;
                case  32: printf("space");    break;
                default:
                    if ( i>32 && i<127 )
                        putchar(i);
                }
            printf("\n");
            if ( m == n )
                exit(0);     /*  all done  */
            freq[i] = -1L;
            }
        }
    }
}
 
int get_byte_distribution(unsigned char *file,
                          long n[])
{
int fh, result=0;
long bytes_remaining;
unsigned int bytes_to_read, bytes_read, i;
 
if ( ( fh = open(file,O_RDONLY|O_BINARY) ) == -1 )
    result = -1;
else
    {
    /*  zero the frequency array  */
    memset(n,0,256*sizeof(long));
    bytes_remaining = filelength(fh);
    bytes_to_read = NBUFSIZE;
    while ( bytes_remaining )
        {
        if ( bytes_remaining < (long)NBUFSIZE )
            bytes_to_read = (unsigned int)bytes_remaining;
        if ( ( bytes_read = read(fh,buf,bytes_to_read) ) == - 1 )
            {
            result = -2;
            break;
            }
        for ( i=0; i<bytes_read; i++ )
            {
            if ( n[buf[i]] == 2000000000L )
                result = -4;        /*  but continue anyway  */
            else
                n[buf[i]]++;
            }
        bytes_remaining -= bytes_read;
        }
    close(fh);
    }
 
return ( result );
}
 
----------------------------------------------------------------------------
|Dolphin Software publishes MS-DOS programming tools and data encryption   |
|software which is an alternative to DES.  Information about their products|
|may be obtained by writing to 48 Shattuck Square #147, Berkeley, CA 94704.|
----------------------------------------------------------------------------
 
