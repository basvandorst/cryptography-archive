Newsgroups: sci.crypt,comp.security
Path: msuinfo!agate!howland.reston.ans.net!swrinde!elroy.jpl.nasa.gov!decwrl!pacbell.com!att-out!cbnewsh!wcs
From: wcs@cbnewsh.cb.att.com (bill.stewart@pleasantonca.ncr.com)
Subject: Re: md5 as a one-way function
Organization: AT&T Global Information Solutions, Pleasanton CA Field Office
Date: Mon, 13 Jun 1994 07:17:37 GMT
Message-ID: <CrBqxF.6DG@cbnewsh.cb.att.com>
References: <grinch-090694222644@grinch.tor.hookup.net> <Cr6C9M.7BL@cbnewsh.cb.att.com> <grinch-100694103116@grinch.tor.hookup.net>
Lines: 105

In article <grinch-100694103116@grinch.tor.hookup.net> grinch@hookup.net (Reginald Braithwaite-Lee) writes:
]In article <Cr6C9M.7BL@cbnewsh.cb.att.com>, wcs@cbnewsh.cb.att.com
](bill.stewart@pleasantonca.ncr.com) wrote:
]> It's a decent strategy, if you're trying to design a modern version of
]> the Unix password system, though you should include a better salt
]> source than just the clock, since that's somewhat guessable - 
]> at minimum, include som semi-random source like a hash of the memory
]> of your machine, or the output of ps or something.
]
]Guessable? Pardon, but are you proposing that the salt be secret? I thought
]the salt was public knowlege, and used only to frustrate dictionary
]attacks. If your communication channel between the terminal and the system
]is secure, you can use a public salt as a means of securing the database of
]hashes from an attacker.

1) While I liked the good old days of readable password files with passwords,
they're probably gone, even with far better password hashes.
Only a few privileged programs really need to see it,
though obviously it still should provide reasonable protection if it gets out.

2) If the number of salts that a given password may use is small,
then the dictionary doesn't grow very much if you factor them in,
and computers keep getting faster and storage keeps getting larger.
If you know, within a few seconds, when someone changed their password
(because you know the last-change date of the password file),
the salt may only add a factor of 5 if you're using a seconds-clock.
Doesn't bother a dictionary search that much.
On the other hand, if there's other garbage affecting it,
you may have 64-128 bits or randomness, which really kills
dictionary searches.

]If the communication channel between the terminal and the system is
]insecure, then the database of passwords becomes insecure and you need
]another layer of encryption, using a private key. And where do you store
]the key securely?

One problem with current networks is that your communications systems
probably *aren't* secure against eavesdroppers, at least if you go
long-distance or use LANs in open environments like universities.
If you've got a telnet with encryption available, it can use
techniques like Diffie-Hellman (preferably with authentication)
to set up a session key.  But you're better off using a system
that does one-use passwords, since you won't always be using it
on secure networks unless you're in a special environment.

]Anyway, if you trust the security of the database of passwords, you can use
]a hash as a challenge-response mechanism. The system sends a random salt to
]the terminal, which privately calculates the hash, then sends the hash
]back. The system then checks the result. An attacker evesdropping on the
]line can compile a codebook of salts and hashes, but presuming the salt is
]never re-used, there is no benefit. I would use a counter that is never
]re-used, even by different users.

It turns out to be very difficult to do this without having some
secure data storage on both ends, and it's not credible to trust file
storage on multi-user systems, though memory can generally be protected.
If you're using a public-key system, you can get by with secure
storage at the user's end (e.g. in a hand-held authenticator), 
and you won't need it at the server end; you can store the private key
on the client end as a less-secure file encrypted with a key that the
user enters to the logon client application, but that's still somewhat risky.

Phil Karn's S/Key technique nicely avoids storing any secure information,
as long as the logon server can reliably write to the password-hash file -
it uses a fairly fast hash function iterated N-1 times, which it
compares with the trasmitted password from the last login, which is
the hash funciton iterated N times.  Obviously, you've got to reset
the password file once you get down to N=2 or so.


]> ]Why all this conversion? You can MD5 any arbitrary binary string, so I
]> ]suggest appending your salt to the plaintext password, then MD5 the result.
]> That's backwards - you need to put the salt first.  The attack you're
]> protecting against is brute-force search discovering users who have
]> wimpy passwords.  MD5 is in some sense a state machine crunching up
]> data as it goes along and representing it as a current state.
]> MD5( foo, bar ) can be calculated by storing the state at the end of "foo"
]> and continuing the calculation for "bar".  If you put the password first,
]> the cracker can store the results of calculating the million wimpiest
]> passwords as the state at the end of each one and then finish off by
]> including the high-quality random salt.  If you put the salt first,
]> the cracker needs to precompute the 2**LargeN salts, look the right
]> one up, and then try the million wimpy passwords, which is infeasible.
]
]Good point, especially if you only use one iteration. In nCrypt, we repeat
]the process 4 times, appending the salt to each result then hashing again.
]The attacker only gains on the first iteration. 

That helps some, since you're forcing the cracker to compute 4 MD5s
for each of the million wimpy passwords, but it would help more
if you included the password as well as the salt.

]Another possibility is to incorporate the salt into the hashing
]function's behaviour. 

That's not a good idea, since it means you're essentially using an
unstudied hash function (yes, I know Unix password does it,
and it makes MD5-crunching chips less useful).  If you're going
to do something like that, use at least one round of regular MD5 in addition,
to make sure you haven't weakened it too much.
-- 
# Bill Stewart       AT&T Global Information Solutions (new name for NCR!)
# 6870 Koll Center Pkwy, Pleasanton CA 94566  1-510-484-6204 fax-6399
# Email: bill.stewart@pleasantonca.ncr.com billstewart@attmail.com
# ViaCrypt PGP Key IDs 384/C2AFCD 1024/9D6465
