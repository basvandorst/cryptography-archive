Newsgroups: sci.crypt
Path: msuinfo!agate!howland.reston.ans.net!europa.eng.gtefsd.com!MathWorks.Com!news.kei.com!ddsw1!indep1!clifto
From: clifto@indep1.chi.il.us (Clifton T. Sharp)
Subject: Re: How to calculate with big numbers?
Message-ID: <CrEHyq.Kut@indep1.chi.il.us>
Organization: as little as possible
References: <2rg1oo$1do@newshost.uni-koblenz.de> <WARLORD.94May19135107@toxicwaste.mit.edu> <2tj5d8$h7g@panix2.panix.com>
Date: Tue, 14 Jun 1994 18:56:49 GMT
Lines: 27

In article <2tj5d8$h7g@panix2.panix.com> mgflax@panix.com (Marshall G. Flax) writes:
>Alternatively, you could do it yourself using the same algorithms
>they taught you in elementary school (except using base 2^16 or so).
>The large packages will do it faster and more efficiently, but doing
>it yourself first would give you a better idea what's going on.

   But one has to be cautious.  I still haven't figured out why my 48x48-bit
multiply comes up with different products (only lowest 48 bits of product
retained) than I get with an 80x87.

   I borrowed the thought from a BDS C library routine that generated random
numbers, but it was in 8-bit code and I had a 16-bit processor so instead of
converting the code I rewrote from scratch.  I sat down, did all the algebra,
implemented it and it perfectly matched the results of the BDS routine.

   Then I tried converting it to use the 80x87.  I never put much effort into
it, but I never did figure out why the differences.

   Randomness doesn't seem to be bad; every period test I could invent showed
the longest repetition in several*10^12 numbers was a string of 3, and every
file I've encrypted shows a very even statistical distribution of byte values.

-- 
				Optimists say, "The glass is half full."
   Cliff Sharp			Pessimists say, "It's half empty."
     WA9PDM			We realists say, "Before I decide,
  clifto@indep1.chi.il.us	 tell me what's in the glass."
