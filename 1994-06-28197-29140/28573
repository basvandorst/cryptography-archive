Newsgroups: sci.crypt,comp.security
Path: msuinfo!agate!ames!pacbell.com!att-out!cbnewsh!wcs
From: wcs@cbnewsh.cb.att.com (bill.stewart@pleasantonca.ncr.com)
Subject: Re: md5 as a one-way function
Organization: AT&T Global Information Solutions, Pleasanton CA Field Office
Date: Fri, 10 Jun 1994 09:12:54 GMT
Message-ID: <Cr6C9M.7BL@cbnewsh.cb.att.com>
References: <Mouse.Wed_Jun__9_10_14_51_1994@collatz.mcrcim.mcgill.edu> <grinch-090694222644@grinch.tor.hookup.net>
Lines: 71

]In article <Mouse.Wed_Jun__9_10_14_51_1994@collatz.mcrcim.mcgill.edu>,
]mouse@collatz.mcrcim.mcgill.edu (der Mouse) wrote:
]> I was considering building a password hash function around md5.
]> Specifically, I would generate a salt (nine bytes of data taken largely
]> from the clock), compute its md5 checksum, convert it to a 20-character
]> printable string by expressing it in base 94, then take the provided
]> plaintext password, concatenate it with the aforementioned 20-character
]> string, compute the md5 checksum of the result, express that as another
]> 20-character string, and then store the resulting 40 characters as the
]> password hash.  (In the environment I am considering using this in, I
]> am not constrained by the usual UNIXish limitations of a two-character
]> salt and a 13-character hash.)

It's a decent strategy, if you're trying to design a modern version of
the Unix password system, though you should include a better salt
source than just the clock, since that's somewhat guessable - 
at minimum, include som semi-random source like a hash of the memory
of your machine, or the output of ps or something.

However, you need to examine the threats your system is protecting
against - will it be used over a network?  That's always been the
major flaw of the Unix password system - wiretapping phone lines was
difficult enough that we convinced ourselves that nobody was tapping us,
but tapping LANs and watching bits flying across the Internet is easy.
Systems like Kerberos or Karn's S/Key or Bellovin & Merritt's EKE or
various public-key techniques can help, with varying amounts of convenience.

If you've got enough space to store a long public key, and the user's
on a different machine with a stored private key, you can do something
like send a random challenge, have the user sign with his public key,
and validate against the stored signature.

In article <grinch-090694222644@grinch.tor.hookup.net> grinch@hookup.net (Reginald Braithwaite-Lee) writes:
]Why all this conversion? You can MD5 any arbitrary binary string, so I
]suggest appending your salt to the plaintext password, then MD5 the result.

That's backwards - you need to put the salt first.  The attack you're
protecting against is brute-force search discovering users who have
wimpy passwords.  MD5 is in some sense a state machine crunching up
data as it goes along and representing it as a current state.
MD5( foo, bar ) can be calculated by storing the state at the end of "foo"
and continuing the calculation for "bar".  If you put the password first,
the cracker can store the results of calculating the million wimpiest
passwords as the state at the end of each one and then finish off by
including the high-quality random salt.  If you put the salt first,
the cracker needs to precompute the 2**LargeN salts, look the right
one up, and then try the million wimpy passwords, which is infeasible.

Now, maybe there's some good attack against salt-first also,
so maybe you want to append it as well :-)  *Do* make sure you allow
the user to input long passphrases, decide whether to cut off at
512-64-salt or not, and make sure your code doesn't choke if handed a
very long or empty password string.

]The length of the salt is almost completely irrelevant--the general idea is
]to (1) have more salts than passwords, ensuring that no two users get the
]same hash, even if they have the same password, and (2) to make a
]dictionary attack unfeasible. A 32-bit salt is probably enough, since it
]adds complexity on the order of 2^32 to a dictionary attack.

32 bits is probably enough, for now, but 2**32 isn't very long as
computer-speed increases go.  64 bits, on the other hand, should be
good for a *long* time, doesn't increase the cost of storage
significantly, and only increases the cost of MD5 calculation if it pushes
the password+salt over the 512-64-bit boundary.

-- 
# Bill Stewart       AT&T Global Information Solutions (new name for NCR!)
# 6870 Koll Center Pkwy, Pleasanton CA 94566  1-510-484-6204 fax-6399
# Email: bill.stewart@pleasantonca.ncr.com billstewart@attmail.com
# ViaCrypt PGP Key IDs 384/C2AFCD 1024/9D6465
