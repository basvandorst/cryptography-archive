Newsgroups: sci.crypt
Path: msuinfo!agate!ihnp4.ucsd.edu!swrinde!gatech!asuvax!netnews.asu.edu!Tux.Music.ASU.Edu!user
From: Ben.Goren@asu.edu (Ben Goren)
Subject: Re: One Time Pad from Keys?
Message-ID: <Ben.Goren-310594175232@Tux.Music.ASU.Edu>
Followup-To: sci.crypt
Sender: news@netnews.asu.edu (Netnews)
Nntp-Posting-Host: tux.fa.asu.edu
Organization: ASU School of Music
References: <1994May26.093631.26772@bradford.ac.uk> <jgkCqFzx6.Is1@netcom.com> <richardrCqGtzy.J0M@netcom.com> <2se6ev$s34@nyx10.cs.du.edu> <2sekhe$cf0@charm.magnus.acs.ohio-state.edu>
Date: Tue, 31 May 1994 17:52:32 MST
Lines: 86

-----BEGIN PGP SIGNED MESSAGE-----

I'll start with a disclaimer: I'm new to cryptography. I've recently read
Bruce Schnier's (wonderful!) book, and a number of online materials; I
don't have much, if any, real-world experience either attacking or
creating encryption methods.

Having said that, let me ask this question: what's wrong with using
irrational numbers as random number generators?

I've got in my head, and am planning on writing so long as I don't find
problems, the following stream cipher:

The key would consist of two large numbers, generated by one of two
means: a truly random source, such as mic input and user keystrokes
compressed and munged with each other, in which case the user assumes
that cryptanalysis is more likely than physical attack (keys get stored
on physical medium); or user-supplied (typed) pass phrases, where the
opposite attack is assumed.

The plaintext would be compressed before encryption; after compression,
the length of the (compressed) plaintext would somehow be factored into
the key (this is the weakest link I can think of, but, as I'll explain
below, it's the best way I can think of to ensure that each message will
be encrypted with a different key stream).

Then the first number of the key (with whatever modifications from the
text length) is raised to the inverse power of the second number of the
key (again with whatever modifications) to produce an irrational number.
The bits from this number are then xored with the plaintext, producing the
ciphertext.

Decryption would take the length of the ciphertext (which is identical to
the plaintext previously calculated), apply it to the key components, do
the same calculation, get the original keystream, and do another xor.

The security would rely on two assumptions on my part: 1) that irrational
numbers are truly random and non-repeating (I think that one's safe); and
2) that, given an arbitrary sequence of digits from an irrational number
(assume a known-plaintext attack), it is impossible to figure out how that
number was generated. That is, given, say 1236234534352403..., there is no
way, short of having a table of all possible permutations of roots in the
key space (brute-force attack), of knowing that the sequence was generated
by 756.7567 ^ (1/31.25873), and, therefore, no way of determining what the
remainder of the sequence will be.

There's plenty of room for niceties: error checking, checking for weak
keys (say, 80 and 3, which, if a message length were 1 and the length were
added to each half of the key, would produce the astoundingly random
sequence "30000000000000000..."), whatever.

The biggest hole I am aware of is the one I mentioned above--the dilemma
of how to ensure that each message gets encrypted with a different
keystream. I suggested using the length of the message, as that's one
thing that's probably already going to be known to an attacker; it seems
a poor idea to "hide" seed bits in the keystream (like /bin/passwd). A
known-plaintext attack likely would not work at all; a chosen- or
adaptive-plaintext attack might, depending on how well the original key
gets modified.

Key distribution is of a similar problem with other symmetric schemes;
I'm not suggesting anything new with that.

An implementation might very well be slow; still, it can't be as bad as
RSA. Which brings me to another query--could this idea be applied to
public-key encryption? That is, if RSA uses the hard problem of factoring
large numbers as the basis of its security, might it be possible to use
this similar hard problem? To me, it seems harder to solve than RSA's,
and quite probably much faster (generating the keystream in my plan
should be much quicker than generating large relatively prime numbers).

I plan on investigating all of this (particularly the public-key angle)
much more thoroughly, but I would most certainly welcome input that might
change the direction of my investigations.

b&

-----BEGIN PGP SIGNATURE-----
Version: 2.3a

iQCVAgUBLevpIv/B5G3tu2N5AQHuXgQAkfiZnLCC+YZnts91mWKdDEwu4w0cOWjX
aRmO9+pAfUDOr9CxTJcIKZgJtb6lY2j4aBXw6d7LZM2PEqYLv8ky+3gTPin1sPqc
K5S8XyvjYGac31OuglSTP+aqPo3uPl0n6a6C1lUgbSZ6791Cy8Y+SIYywrtvr8wm
HhjXZYwQWIQ=
=ZYxb
-----END PGP SIGNATURE-----
