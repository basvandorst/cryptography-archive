Path: msuinfo!agate!cat.cis.Brown.EDU!noc.near.net!news.delphi.com!usenet
From: padrote@delphi.com
Newsgroups: sci.crypt
Subject: Re: Cracking a scheme..
Date: Mon, 27 Jun 94 17:47:38 -0500
Organization: Delphi (info@delphi.com email, 800-695-4005 voice)
Lines: 35
Message-ID: <hE4So96.padrote@delphi.com>
References: <35ea_2e0cae53@cpubbs.cuug.ab.ca>
NNTP-Posting-Host: bos1f.delphi.com
X-To: Matthew Mastracci <Matthew.Mastracci@matrix.cpubbs.cuug.ab.ca>

Matthew Mastracci <Matthew.Mastracci@matrix.cpubbs.cuug.ab.ca> writes:
 
>     What is the easiest way for a person to encrypt data for a program, but
>still retain a high level of security against ameteur hackers?  I've tried
>creating an xor procedure, using a key of gibberish that is the smae length as
>the file, but I don't think that it is very secure.  Also, size is factor, so I
>can't really implement something around the lines of PGP...
 
You don't give much information but consider the following: the program you
distribute to users must contain both the encryption algorithm *and* the
particular keys you use with it. Thus a determined hacker could just
disassemble your program and see how it decrypts the data file. Sorry, but
no algorithm on earth can prevent this, if at some time during the running
of your program you decrypt the data. If it appears inside the machine, a
determined hacker can get at it.
 
So what do you mean by "ameteur hacker"? Someone who doesn't feel like
disassembling your program? If so, then I think xoring the file with a
random key is sufficient. The file looks like gibberish, and the only way
it can be decrypted is with the key. If you don't like the fact that you
have to store the key somewhere on the distribution disk, then use a random
number generator and make it up on the fly every time the program runs.
 
I can think of certain special cases where you *could* make your data 100%
secure, but it depends on the application. Consider, for example, a program
implementing the game "Jeopardy". The program asks questions and the user
enters the answers. You want to store the answers on disk, but you don't
want people to read them without playing the game. Here instead of storing the
answers, you could use a hash function, and store the hash of the answer. Then
you compare the hash of the player's response to the hash of the answer. Note
however that there would be no way for the player to "give up" and ask to see
the correct answer. All the program can do is tell him if he's right or
wrong.
 
John
