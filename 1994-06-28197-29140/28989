Path: msuinfo!agate!howland.reston.ans.net!xlink.net!fauern!rrze.uni-erlangen.de!not-for-mail
From: mlpeter@faui08o.informatik.uni-erlangen.de (Michael Peter)
Newsgroups: sci.crypt
Subject: ->->-> PLEASE help me ! <-<-<-
Date: Fri, 24 Jun 1994 10:55:48 +0200
Organization: Student Pool, CSD, University of Erlangen, Germany
Message-ID: <2ue72k$k2q@faui08o.informatik.uni-erlangen.de>
NNTP-Posting-Host: faui08o.informatik.uni-erlangen.de
Lines: 126
Summary: A not-easy-to-solve problem
Keywords: crypt

HI !
I'm a computer-science student in Erlangen/Germany and I got a problem to
which I cannot find a solution. I think the problem is really interesting, so
I would really appreciate if some of you might give it a look. Thanks
to whoever takes the time to help me.
                                          Michael Peter

Imagine the following situation:
Bob wants to buy a program from Alice. Since Bob wants to examine the
program first, Alice gives him two versions of the program (on a CD-ROM for
example), a demo version and a encrypted full version. Bob decides that he
likes the program and wants the full version. He calls Alice, pays (via
credit card or whatever) and she tells him the key that decrypts the program.
To prevent that Bob just gives the key (and the CD-ROM) to Carol without
paying, the key depends on a system-id that the install program determines
on Bob's computer and Bob tells Alice. Since the masterkey used to encrypt
the CD is fixed, Bob gets an encrypted key. This key decrypts only on his
computer using his system-id to the right masterkey and not on Carol's or
whoeveryoucanthinkof's.
If the system-id were hard to fake and even with the masterkey (obtained
by debugging the install program or similar technics) it were difficult to
decrypt the data without a huge amount of work, the algorithm or protocol
used to encrypt and decrypt the masterkey would be vital to the security of
the system. Because of restrictions of transmitting the key by voice over
telephone (you can hardly transmit 512bit by voice) the standard public-key
algorithms don't seem to provide an acceptable measure of security to me,
with a chiphertext length of only about 15 bytes.

Therefore I'm looking for a protocol (algorithm) that satisfies the following
needs:

        E(M,K)=C
        D(C,I)=M
        F(I,S)=K

 with:

       M: Message to be transmitted (a key for a single key algorithm)
          M should be about 64bit.
       C: Chipertext. C MUST NOT be greater than 120bit, so it can be
          transmitted via telephone.
       I: System-id of the user's computer. Generated, for example, by a
          one-way hash function of the computer's BIOS. C should be about
          32-64 bit (because it has to be transmitted, too).
       K: Key used to encrypt M. K cannot be chosen randomly, it depends
          on I.
       S: Secret information (trapdoor) that allows the computation of K
          from I. (S could be the factorisation of an integer)

       E: Encryption function. Could be kept secret.
       D: Decryption function. Public. Must not use S.
       F: A function that derives K from a given I using S.

 The protocol could certainly use additional public numbers or whatever. For
 example N is a public number and N could be the product of two large primes
 p and q, so S would be p and q.


  Step1:

     -----------             -------             ---------
     - Install - System-id I -     - System-id I -       -
     -         - ----------->- BOB - ----------->- ALICE -
     - Program -             -     -             -       -
     -----------             -------             ---------

  Step2:

     ---------
     -       -
     - ALICE - computes K=F(I,S) , and C=E(K,M)
     -       -
     ---------

  Step3:

     ---------              -------               -----------
     -       -     C        -     -      C        - Install -
     - ALICE - ------------>- BOB - ------------->-         -
     -       -              -     -               - Program -
     ---------              -------               -----------

  Step4:

     -----------
     - Install -
     -         - computes M=D(C,I) and decrypts the data
     - Program -
     -----------

 Platform  : The protocol is intended to run on average PCs (386 and up).
 Goal      : It should be very difficult and time consuming for a given I to
             find K (without knowing S).
 Time      : F and E should not take longer than a minute on a pentium/60.
             D should take no longer than a second on an average PC (say a
             386/40)
 Attackers : I think the maximum number of computer power working together
             to find S is about 1000 average PCs (anything from a 386/25 to
             a pentium/100) running about 12 hours a day a couple of weeks.
             Maybe a campus network could be used using spare cycles.
 Security  : Finding S should take at least a year given the attacker's force
             I gave above.
             Finding K with a brute-force attack should also take at least
             one year.
             Finding K from I using cryptoanalysis should take least one year

Is there a protocol that comes up with this features or something similar ?
If C is too small to give a reasonable security, how large must C be ?
Exists a protocol that uses multiple rounds that could achieve the same ?

A variant could look like this:

  Let G be a single key algorithm. Using G Alice encrypts M with key I, the
  result is C1. Using RSA and a secret Key S Alice encrypts C1 and get C2.
  Alice gives C2 to Bob. Bob enters C2 into his computer and the program
  computes C1 using a prestored public key P. Now the program gets M by using
  G with I to decrypt C1. S and P are generated before shipping the CD.
    Unfortunately RSA uses a large modulus and so C2 gets to large. :-(

I would be glad to receive any comments,ideas,references and i would be even
more glad and happy to receive protocols,source code and/or notes on
implementation. (Since I'm not a great mathematician, please keep it simple !)

Here is my e-mail address:
           mlpeter@cip.informatik.uni-erlangen.de

