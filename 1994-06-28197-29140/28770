Path: msuinfo!netnews.upenn.edu!news.amherst.edu!news.mtholyoke.edu!uhog.mit.edu!europa.eng.gtefsd.com!howland.reston.ans.net!swrinde!elroy.jpl.nasa.gov!ncar!csn!roper.uwyo.edu!mallard.uwyo.edu!jimkirk
Newsgroups: sci.crypt
Subject: Re: How to calculate with big numbers?
Message-ID: <1994Jun16.160356.2645@roper.uwyo.edu>
From: jimkirk@uwyo.edu (James Kirkpatrick)
Date: 16 Jun 94 16:03:56 MDT
Reply-To: jimkirk@uwyo.edu (James Kirkpatrick)
References: <2rg1oo$1do@newshost.uni-koblenz.de> 
 <WARLORD.94May19135107@toxicwaste.mit.edu> <2tj5d8$h7g@panix2.panix.com> <2tnc3e$r4u@news.delphi.com>
Distribution: world
Organization: University of Wyoming
Nntp-Posting-Host: mallard.uwyo.edu
Lines: 31

In article <2tnc3e$r4u@news.delphi.com>,
padrote@news.delphi.com (PADROTE@DELPHI.COM) writes:

|>... I consider my routines to be
|>correct because one of the things I did was write a routine which 
|>multiplied two random numbers together, added another random number, and 
|>then did the division to check the result. After running this for a few 
|>days (some millions of iterations) I think everything is correct.

While this is good for confidence-building, and should certainly be
done, it does not necessarily consitute a demonstration of correctness.
Picking random numbers is very unlikely to turn up strange or
pathological cases, such as divison by zero, alternating words of
all 0s and 1s, or whatever constitutes a bad case for the code
in hand.  I've done this sort of thing (not on multiple precision
math packages, but on other code), but you should also be thoroughly
aware of the algorithms and pitfalls, and exercise those cases as
well as random arguments.  It sounds like you did, but I just wanted
to make it clear to the "masses" that it takes more than just random
values to give a good performance test.

On a related topic, there were some papers a few years ago on tests
for correctness that ran much faster than, say, modular exponentiation.
For critical applications, the code would perform the operation, then
run the result through a checker at very little added cost.  As a simple
example, you write a square root routine; a cheap check would be to
square the result and do a check for equality or near-equality.  In
a multiple-precision math package, it might be interesting to include
such routines as optionally-compilable debug code.

Jim
