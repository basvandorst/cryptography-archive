Path: msuinfo!netnews.upenn.edu!news.cc.swarthmore.edu!psuvax1!news.pop.psu.edu!news.cac.psu.edu!howland.reston.ans.net!europa.eng.gtefsd.com!MathWorks.Com!solaris.cc.vt.edu!news.ans.net!sitka.wsipc.wednet.edu!connected.com!connected.com!not-for-mail
From: blh@hebron.connected.com (Brian Henry)
Newsgroups: sci.crypt
Subject: random numbers from disk drive rotation latency -- help?
Date: 6 Jun 1994 15:05:27 -0700
Organization: Connected INC -- Full Service Internet Providers(tm)
Lines: 30
Message-ID: <2t06j7$r97@hebron.connected.com>
NNTP-Posting-Host: hebron.connected.com


I'm attempting to write a program to generate random numbers from disk drive
rotation latency as discussed in Schneier's new cryptography book.  So far,
I have a C program for MS-DOS that will return a small integer representing
arbitrary time units to read a sector.  This value changes a little bit,
say it's 450 on average, varying from 448 to 455.  

What I'm looking for is an algorithm that will convert these semi-random
numbers into a good random bit stream.  Any suggestions?

I have also experimented with using the noise from the joystick port
input and the Soundblaster A-D converter input.  But so far all three sources
are too regular, or my algorithm is not good enough.  My most sophisticated
algorithm so far looks like this:

  set temp=0
  for count=1 to N  (N usually about 100)
    get semi-random number
    compare to last semi-random number
    if greater, XOR 1 with temp
  next count
  return temp

But by accumulating single-bit numbers, converting them into 16-bit integers,
and displyayng the integers in a X-Y graph, there are clear regularities.
-- 
------------------------------------------------------------------------
Brian L. Henry                                 Kirkland, Washington, USA
blh@hebron.connected.com / brianhe@atm.com     Finger for PGP public key.

