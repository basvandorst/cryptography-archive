Path: msuinfo!agate!howland.reston.ans.net!europa.eng.gtefsd.com!MathWorks.Com!zombie.ncsc.mil!golf!mizzou1.missouri.edu!C445585
From: C445585@mizzou1.missouri.edu
Newsgroups: sci.crypt
Subject: Stream ciphers from hash functions
Date: Thu, 09 Jun 94 20:10:40 CDT
Organization: University of Missouri, Columbia
Lines: 65
Message-ID: <16FD011BC0S86.C445585@mizzou1.missouri.edu>
NNTP-Posting-Host: mizzou1.missouri.edu

 
   This is the best general idea I've come up with for turning a good
crypto-strength hash into a stream cipher so far.  It's based on the
idea of a non-weakening combiner.
 
   The general scheme uses a the compression function from a one-way
hash function, 1024 bytes of memory, and three cheap PRNGs based on
additive feedback shift registers (AFSRs).
 
   Let F(K,X) take a 128-bit input for K, and a 512-bit input for X,
and return a 128-bit output.  Let A,B, and C be AFSRs, so that A(i)
is the ith output from A().  Let M() be a 1024-byte memory block.
 
   The general operation of the stream cipher is
                                           ___
                                          |M()|
                                          |___|
   __________                 1/8          ^ v
  | F()-OFB  |----->XOR-----> OMIT -----> SWAP WITH -----> output stream
  |__________|       ^          ^          MEMORY
                     |          |            ^
           A() ------+  B() ----+            |
                                  C() -------+
 
 
   To put this in notation:
 
   Each iteration of the stream cipher does the following:
 
   1.  X(i) = F(K,X(i-4)||X(i-3)||X(i-2)||X(i-1) )    || means concatenate
       (That is, X(i) is generated by running F() in OFB-mode.)
 
   2.  X(i) is 4 32-bit words.  A() is used to generate 4 32-bit words
       that are XORed into X(i).  This prevents any direct access to
       the X(i) outputs by an attacker.
 
   3.  X(i) consists of 16 bytes.  Use 3 bits at a time from C()'s
       output to decide whether to throw out the next byte.  Throwing
       the byte out has a 1/8 chance.  Throwing out some of our bytes
       will be fast in software, and will mean that an attacker
       virtually never has access to the whole input buffer used to
       generate an X(i), and never has direct access to X(i).
 
   4.  Run the remaining bytes through the shuffling-combiner as shown.
       This just means, for each byte to be input (and output),
       generate a 10-bit number Z from AFSR C().  Output the byte
       in memory location Z, ie M(Z).  Replace it with the current
       input byte.  This mixes two full F() input buffers among each
       other in a complicated way.  M's size can be increased to
       make sure we're mixing even more of the input bytes to F().
       With 1024 or more, we're also likely to have several of each
       byte value.
 
   I don't think this will ever be less secure than running F() in
OFB-mode with its IV kept as a secret key.  It will cost a little
more to run that F() in OFB-mode, or MDC, or Braitwaithe's stop-and-
go scheme, but not very much.
 
   Alternative implementations of this idea could use F() in counter
mode, for convenient re-synchs.  This sort of scheme could also be
used with a block cipher in OFB-mode, or another crypto-strength PRNG.
 
   Comments?
 
   --John Kelsey, c445585@mizzou1.missouri.edu
