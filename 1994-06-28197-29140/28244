Path: msuinfo!agate!spool.mu.edu!mnemosyne.cs.du.edu!nyx10.cs.du.edu!not-for-mail
From: colin@nyx10.cs.du.edu (Colin Plumb)
Newsgroups: sci.crypt
Subject: Re: How does one attack an easy scheme?
Date: 1 Jun 1994 01:59:35 -0600
Organization: /usr/lib/news/organi[sz]ation
Lines: 49
Message-ID: <2shf57$im3@nyx10.cs.du.edu>
References: <ZC7tWlY.tom_duda@delphi.com>

In article <ZC7tWlY.tom_duda@delphi.com>,
Thomas Duda  <tom_duda@delphi.com> wrote:
>I am, admittedly, new to cryptology. I've read the posts to this group for
>about three weeks and read the FAQ (gasp!). That's enough to tell me that
>the following encryption scheme would be easy to solve. Bearing in mind that
>cryptology is new to me and that, while I have a good understanding of the
>C language and moderate math skills, the method of attack escapes me.
> 
>   1) Get the current system time.
>   2) Use the time as a seed value for rand() /* yes, I know about rand()  */
>   3) Generate a random number.
>   4) Add the random number to the current byte of plaintext. Store the result.
>   5) Repeat steps three and four until the entire plaintext file has been
>      encrypted. Write the result to disk.
> 
>Obviously, decryption is the reverse of encryption, as long as one has the
>seed value. If, however, one does not have the seed value (which will be
>16 bits on my platform), what method would be used to attack the encrypted
>text? Brute force seems like an inelegant solution.

Well, guessing the time of encryptin will do a pretty good job.
If rand() only keeps 15 bits of state (as happens on some PCs), you
can try all 32768 possibilities easily.  If it keeps 31 (as is common on
Unix), you can try 2 billion with a bit more work.

But let's suppose that isn't desirable.  Okay, assume rand() is a standard
linear congruential generator, of the form

x[i+1] = a*x[i] + c (mod 2^n)

The nasty thing about this is that if you ignore the high bits,
it's just a generator mod 2^8.  If you have one byte of known plaintext,
you can figure out the state of the low 8 bits at that point, and work
backwards and forward from there.

Other generators are also very easy to derive the state of if you have
a string of output.  Additive congruential (as used in random(),
Marsaglia's subtract-with-borrow, and so on.

Figuring out the parameters (e.g. a and c) is also very easy.  You
basically need as many bits of output as there are bits of unknwons to
solve for.

Because of the linearieites involved, it's usually easy to reduce
the problem down to a system of equations which is trivially solvable.
If you can only guess at some bits, there are statistical techniques,
although they're rather involved to go into here.
-- 
	-Colin
