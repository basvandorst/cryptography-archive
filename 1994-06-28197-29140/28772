Path: msuinfo!agate!ames!hookup!yeshua.marcam.com!zip.eecs.umich.edu!newsxfer.itd.umich.edu!ncar!csn!roper.uwyo.edu!mallard.uwyo.edu!jimkirk
Newsgroups: sci.crypt
Subject: Re: crypt.methods
Message-ID: <1994Jun16.162349.2646@roper.uwyo.edu>
From: jimkirk@uwyo.edu (James Kirkpatrick)
Date: 16 Jun 94 16:23:49 MDT
Reply-To: jimkirk@uwyo.edu (James Kirkpatrick)
References: <2tn7bn$crk@barnacle.iol.ie>
Distribution: world
Organization: University of Wyoming
Nntp-Posting-Host: mallard.uwyo.edu
Lines: 21

In article <2tn7bn$crk@barnacle.iol.ie>, eburke@iol.ie (Eoin Burke) writes:

|>I am out of school now for the summer break. I am hoping to write
|>a good cryptic program. 

This is too good a straight line to pass up.  Most programs I have
ever seen are cryptic.  Try APL, or uncommented assembler.  Even Cobol
gave me some fun when somebody tried to negate a number by writing (more
or less, my memory on this one has faded and I don't do Cobol):
    MOVE -1 TO NEG1
      ...
    MULTIPLY SOME_FIELD BY NEG1
and wondered why it didn't do what was intended.  They claimed the compiler
was broken.  The answer was that in Cobol, if no destination is given, the
result of the multiply goes into the second argument, in this case the
"constant".  Adding a YIELDING SOME_FIELD fixed the problem.  Talk about
cryptic!

Back to cryptology, though.  As somebody else mentioned, read the FAQ.
Buy Schneier's book "Applied Cryptography".  Get a copy of the program
PGP.
