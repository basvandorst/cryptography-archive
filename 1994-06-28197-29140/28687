Path: msuinfo!agate!overload.lbl.gov!dog.ee.lbl.gov!ihnp4.ucsd.edu!swrinde!gatech!newsfeed.pitt.edu!uunet!utcsri!newsflash.concordia.ca!sifon!mcrcim.mcgill.edu!collatz.mcrcim.mcgill.edu!mouse
From: mouse@collatz.mcrcim.mcgill.edu (der Mouse)
Newsgroups: sci.crypt
Subject: Re: md5 as a one-way function
Date: 14 Jun 1994 19:54:38 GMT
Organization: McGill Research Centre for Intelligent Machines
Lines: 103
Message-ID: <Mouse.Tue_Jun_14_15_04_10_1994@collatz.mcrcim.mcgill.edu>
References: <Mouse.Wed_Jun__9_10_14_51_1994@collatz.mcrcim.mcgill.edu>
NNTP-Posting-Host: thunder.mcrcim.mcgill.edu

Many people have made helpful comments on my proposed use of md5 for
password hashing, some by email, some on the net, some both.  Thank you
all.  Based on those, here is a followup report:

First, note that I am not trying to solve any problems here except:
(1) the truncation to eight characters that's characteristic of the
    traditional tweaked-DES hash,
(2) 56 bits of input to the hash function is looking too small to me,
(3) 12 bits of salt is looking too small to me.

Specifically, I know about the problems inherent to reusable passwords,
and I am not trying to address them.  I also do not intend to address
here the human tendency to pick weak passwords; this is strictly a way
to hash once a plaintext password has been decided upon, or provided as
input to be checked.

The first problem above could be solved by computing some 56-bit hash
(not necessarily even a cryptographically strong hash) of the typed
password and using that as the key for the tweaked-DES algorithm - for
example, a 32-bit CRC together with (say) the first and last 12 bits of
the password.

The other two problems are inherent to tweaked-DES.

Several people have said that MD5 is believed to be strong against the
attack I described (given only Y, find some X such that Y=MD5(X)).
This is what I had hoped, and indicates that my basic notion is sound.

At least one person wondered about the difference between that strength
and one I described (given X, find Y!=X such that MD5(Y)=MD5(X)).
[Nomenclature interlude: call the former problem A, and the latter
problem B.]  At first blush, it appears that anyone who can attack
problem A can also attack problem B, since you just compute MD5(X) and
feed it into your attack on A.  But this isn't quite enough, because
it's conceivable that, for example, there are 2^128-1 messages each
with a distinct MD5 hash, and all the remaining infinity of messages
hash to the remaining value, and that everyone who uses MD5 happens to
pick one of the messages with a unique hash: then, an attack on problem
A gives no handle at all on problem B.  Not that I think for a moment
that this is the case - I fully expect that each hash code corresponds
to aleph-null distinct messages - but I see no a priori way to rule it
out.  And problem A is the one that concerns me, not problem B.

Someone else mentioned that one has to be careful when choosing what
one feeds to MD5: in particular, one must not simply hash the password
and then the salt, because the attacker can partially precompute a
dictionary.  One also wants to ensure that the hash is fairly expensive
to compute, so that the attacker can't afford to just hash a dictionary
for each salt in your password database.

Various people have talked about different ways of choosing salts, but
as other people have pointed out, since the salt is being stored in a
functionally cleartext way (as it must be in order for password
verification to be feasible), there is no point in finding a strong
method of choosing them, as long as (a) there are enough of them to
render dictionary searches infeasible and (b) the chance of two
passwords drawing the same salt is small enough to be ignored.  Thus,
the salt actually does not have to carry a large amount of information
in the information-theoretic sense.

Based on these comments, here's my revised algorithm.

The only difference between hashing a password the first time and
checking a password for correctness is that the first time, one has to
generate a salt, whereas later times, the salt is taken from the stored
password.  To choose a salt, I use the full system time, which
theoretically has microsecond resolution and in practice has typically
1/60 or 1/100 second resolution, plus four bytes of random() output
(for the unlikely case where two password changes occur nearly
simultaneously - and yes, I know about different processes using the
same random() sequence; this is all occurring in a single process).
This gives 12 bytes.  I feed these to MD5 and convert the resulting
128-bit number to a 20-"digit" base-94 printable string.  This is the
salt string; it is stored as part of the hashed password.  (If such a
scheme were to be widely used, I would recommend a much more
information-laden salt, to reduce inter-machine salt collisions.)

An iteration count, ROUNDS, is used below.  When hashing a password for
the first time, a compiled-in default (currently 64) is used and stored
with the hash; when checking a password, this value is obtained from
the stored string.

To hash a password, given a salt:

Initialize DATA to the plaintext password.
Repeat ROUNDS times:
	Initialize MD5.
	Feed DATA to MD5.
	Feed the 20-character salt string to MD5.
	Feed DATA to MD5.
	Feed the plaintext password to MD5.
	Feed DATA to MD5.
	Take the MD5 result, convert to base-94 printable; set DATA to
	  the resulting 20-character string.
End repeat.
Hashed password is the salt concatenated with the final value of DATA
(and is stored along with the ROUNDS value).

Anyone care to comment on this version?

					der Mouse

			    mouse@collatz.mcrcim.mcgill.edu
