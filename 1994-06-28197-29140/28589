Newsgroups: sci.crypt
Path: msuinfo!agate!dog.ee.lbl.gov!overload.lbl.gov!lll-winken.llnl.gov!ames!elroy.jpl.nasa.gov!sdd.hp.com!hp-pcd!hpcvsnz!not-for-mail
From: ericb@lsid.hp.com (Eric Backus)
Subject: Re: Stream ciphers from hash functions
Sender: news@hpcvsnz.cv.hp.com (News )
Message-ID: <Cr7E6C.AIw@hpcvsnz.cv.hp.com>
Date: Fri, 10 Jun 1994 22:51:48 GMT
References: <16FD011BC0S86.C445585@mizzou1.missouri.edu>
Organization: Hewlett-Packard
X-Newsreader: TIN [UNIX 1.3 310394BETA PL0]
Lines: 35

C445585@mizzou1.missouri.edu wrote:
>    This is the best general idea I've come up with for turning a good
> crypto-strength hash into a stream cipher so far.  It's based on the
> idea of a non-weakening combiner.
>  
>    The general scheme uses a the compression function from a one-way
> hash function, 1024 bytes of memory, and three cheap PRNGs based on
> additive feedback shift registers (AFSRs).
>  

	... actual algorithm omitted ...

You didn't mention how to initialize the 1024 bytes of memory.  These
initial values DO end up in the output stream, so this could be
important.  One way to do it would be to use F() in OFB mode.

>    I don't think this will ever be less secure than running F() in
> OFB-mode with its IV kept as a secret key.  It will cost a little
> more to run that F() in OFB-mode, or MDC, or Braitwaithe's stop-and-
> go scheme, but not very much.

I agree that this should never be less secure than F() by itself.
However, I'd feel a lot better if we could somehow demonstrate that
this is, indeed, MORE secure.

If F() has some weakness, it would be nice to find some way to
demonstrate that your method helps hide that weakness.  Suppose, for
example, that F() were simply a linear-feedback-shift-register based
PRNG, with its state determined by the K and X you pass to it.  We
know that it's quite insecure.  How much more secure is it after going
through the algorithm you describe?
-- 
				Eric Backus
				ericb@lsid.hp.com
				(206) 335-2495
