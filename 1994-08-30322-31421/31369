Path: msuinfo!news.mtu.edu!sol.ctr.columbia.edu!newsxfer.itd.umich.edu!ncar!asuvax!pitstop.mcd.mot.com!mcdphx!schbbs!mothost!mdisea!mmddvan!vanbc.wimsey.com!vanbc.wimsey.com!not-for-mail
From: markh@vanbc.wimsey.com (Mark C. Henderson)
Newsgroups: sci.crypt
Subject: Re: **VERY FAST 1024BIT RSA**
Date: 29 Aug 1994 22:55:24 -0700
Organization: Wimsey Information Services
Lines: 53
Message-ID: <33uhkc$fck@vanbc.wimsey.com>
References: <33s2f2$3p3@lucy.ee.und.ac.za>
NNTP-Posting-Host: vanbc.wimsey.com

In article <33s2f2$3p3@lucy.ee.und.ac.za>,
Jyri Hamalainen <cat@olddaisy.ee.und.ac.za> wrote:
>If:
>p,q-prime
>u  - multiplicative inverse 
>d  - secret exponent
>
>High speed decryption of 1024bit RSA is possible using the Chinese 
>Remainder Theorm assuming one knows p,q,u and d, and that 512bit 
>hardware is available for exponentiation. Are there any VERY fast 
>techniques to do a 1024bit encryption without knowing p,q,u and d.

The most important thing in implementing RSA with numbers in the 512-1024
bit range seems to be to pay careful attention to details. Especially
implement critical sections of the code in assembler for the platform
in question.

Other tricks and techniques include:
1. Observe that squaring is easier than multiplying.
2. Montgomery Multiplication. This is cool because you avoid doing
   mod/division, which is really nasty.
3. Karatsuba (although you have to be very careful with this to
   get an advantage with 1024 bit numbers).
4. exponent recoding and choosing the right patterns of/numbers of bits
   of the exponent to deal with in chunks. (e.g. look at the RSAREF
   code which deals with the exponent in 2 bit chunks-just moving to
   4 bit chunks will generally speed things-but you can do better).
5. FFT (can anyone make this an advantage over simpler methods with 
   1024 bit numbers?) 

It has been my experience that you'll usually do better implementing 
RSA with 512-1024 bit numbers with a simple algorithm and coding 
critical sections in assembler (easy with gcc), than a more involved 
algorithm written completely in portable C. 

For example, you can get a considerable speed up with the naive 
algorithm in RSAREF if you can code the operation of multiplying two 
unsigned words to get a double length unsigned word as a single 
assembler instruction. You can do this on most modern processors: 
e.g. RS6000, V8 Sparc, 80486. 

People usually just use short exponents for encryption (it helps to 
have lots of 0s in them, e.g. 65537, 17). This makes encryption 
relatively fast (faster than decryption, even with the CRT 
optimisation) so you don't have to worry too much about encryption 
performance. 

Mark
-- 
Mark Henderson markh@wimsey.bc.ca - RIPEM MD5: F1F5F0C3984CBEAF3889ADAFA2437433
ViaCrypt PGP key fingerprint: 21 F6 AF 2B 6A 8A 0B E1  A1 2A 2A 06 4A D5 92 46
low security key fingerprint: EC E7 C3 A9 2C 30 25 C6  F9 E1 25 F3 F5 AF 92 E3
cryptography archive maintainer -- anon ftp to ftp.wimsey.bc.ca:/pub/crypto
