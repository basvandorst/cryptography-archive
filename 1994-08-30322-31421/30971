Path: msuinfo!agate!darkstar.UCSC.EDU!news.hal.COM!olivea!charnel.ecst.csuchico.edu!nic-nac.CSU.net!usc!rand.org!mycroft.rand.org!not-for-mail
From: jim@mycroft.rand.org (Jim Gillogly)
Newsgroups: sci.crypt
Subject: Re: One-line one-time pads
Date: 19 Aug 1994 16:11:21 -0700
Organization: Banzai Institute
Lines: 28
Message-ID: <333e6p$e9u@mycroft.rand.org>
References: <sci.crypt.research-RFD1@uunet.uu.net> <mpjCuqpH2.AoF@netcom.com> <PCL.94Aug19134106@foo.oucs.ox.ac.uk> <33372v$gts@nyx.cs.du.edu>
NNTP-Posting-Host: mycroft.rand.org

In article <33372v$gts@nyx.cs.du.edu>,
Michael Shields <mjshield@nyx.cs.du.edu> wrote:
>In article <PCL.94Aug19134106@foo.oucs.ox.ac.uk>,
>Paul C Leyland <pcl@foo.oucs.ox.ac.uk> wrote:
>> Ah, a challenge.  Here's my solution.  Call it with a file containing
>> 
>> #include<stdio.h>
>> main(int c,char**a){FILE*p=fopen(a[1],"r");while(EOF!=(c=getchar()))putchar(c^getc(p));}

My response to Paul's challenge is 76 characters:

   main(c,a)char**a;{c=open(*++a,0);while(read(c,*a,1))putchar(**a^getchar());}

You can save two characters if you really believe it'll give you file
descriptor 3 every time.  Scribbling in the argv[] space is a bit suspect in
some architectures, but suspect doesn't stop us in the obfuscated C world.

Michael Shields changes the rules to specifying the key on the command line:

>  main(c,a)char**a;{char*k=a[1];while(-1!=(c=getchar()))putchar(c^*k++);}

Here's a 1-byte improvement:
   main(c,a)char**a;{char*k=a[1];while(0<=(c=getchar()))putchar(c^*k++);}

Stop me if I go off-topic for sci.crypt... I won't send this to *.research!
-- 
	Jim Gillogly
	27 Wedmath S.R. 1994, 23:11
