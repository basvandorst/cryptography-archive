Path: msuinfo!agate!howland.reston.ans.net!news.cac.psu.edu!news.pop.psu.edu!psuvax1!castor.cse.psu.edu!beaver
From: beaver@castor.cse.psu.edu (Don Beaver)
Newsgroups: sci.crypt
Subject: Re: Want to detect collisions without revealing extra information
Date: 30 Aug 1994 15:09:10 GMT
Organization: Penn State Computer Science
Lines: 66
Message-ID: <33vi2m$i7i@psuvax1.cse.psu.edu>
References: <33oc2r$n4l@news.kth.se> <33ok8j$kbs@agate.berkeley.edu> <CvBMzH.CxD@cogsci.ed.ac.uk>
NNTP-Posting-Host: castor.cse.psu.edu

richard@cogsci.ed.ac.uk (Richard Tobin) writes:
>spp@bob.eecs.berkeley.edu (Steve Pope) writes:
>>> A has a set of numbers from the range 0..999999999
>>> B has a set of numbers from the range 0..999999999
>
>>> How do they calculate the size of the intersection of their sets
>>> without revealing more?
>
>>Hash each number with a strong hash function, then reveal the
>>hashes?
>
>If there are only 10^9 numbers, the strength of the hash function
>won't help much.

Two answers to the original question:

1. It is impossible in an information-theoretic setting.  Some information
must be leaked.  (Getting at that information may be difficult.)

2. If A and B can each use a polynomial-time algorithm but nothing
more, then it is "possible," ie. with a negligible chance of error/leakage,
assuming factoring is hard.

((2) does not use hashing.  It is also pretty infeasible in a
practical setting, since you'd need [back-of-envelope] on the order
of 10^11 arithmetic operations modulo an RSA-sized modulus.  But
remember, we're talking about inputs that take over a meg just
to write down in the first place.  *Strongly* hashing each number
would also be pretty expensive! -- and as Richard pointed out, it
won't help anyway.)


Reasons:

(1) Consider the four cases where A has nothing or 1
and B has nothing or 1.  If they _could_ calculate the size of the
intersection, they could adapt their method to compute the AND of 
boolean inputs.  This is impossible without leaking any information:

\bibitem{bea89}
  D.\ Beaver.
  ``Perfect Privacy for Two-Party Protocols.''
  {\em Proceedings of the DIMACS Workshop on 
  Distributed Computing and Cryptography,} Princeton, NJ, October, 1989,
  J.\ Feigenbaum, M.\ Merritt (eds.).

\bibitem{ck89}
  B.\ Chor, E.\ Kushilevitz.
  ``A Zero-One Law for Boolean Privacy,''
  {\em Proceedings of the $21^{st}$ STOC,} ACM, 1989, 62--72.

(2) The problem is a special case of 2-party protocols to evaluate
circuits without revealing the inputs supplied by each party.  This
can be done using oblivious transfer, which in turn can (for example)
be based on the difficulty of factoring.  See, for example:

\bibitem{kil88}
  J.\ Kilian.
  ``Founding Cryptography on Oblivious Transfer.''
  {\em Proceedings of the $20^{th}$ STOC,} ACM, 1988, 20--29.

\bibitem{yao82} A.\ Yao. 
  ``Protocols for Secure Computations.''
  {\em Proceedings of the $23^{rd}$ FOCS,} IEEE, 1982, 160--164.

Don
