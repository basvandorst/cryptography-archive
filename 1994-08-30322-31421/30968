Path: msuinfo!netnews.upenn.edu!dsinc!spool.mu.edu!mnemosyne.cs.du.edu!nyx.cs.du.edu!not-for-mail
From: mjshield@nyx.cs.du.edu (Michael Shields)
Newsgroups: sci.crypt
Subject: One-line one-time pads
Date: 19 Aug 1994 15:09:51 -0600
Organization: Giant Tube Worm Society
Lines: 29
Message-ID: <33372v$gts@nyx.cs.du.edu>
References: <sci.crypt.research-RFD1@uunet.uu.net> <32u3jv$hc@news1.shell> <mpjCuqpH2.AoF@netcom.com> <PCL.94Aug19134106@foo.oucs.ox.ac.uk>
Reply-To: Michael Shields <mjshield@nyx.cs.du.edu>
NNTP-Posting-Host: nyx.cs.du.edu

In article <PCL.94Aug19134106@foo.oucs.ox.ac.uk>,
Paul C Leyland <pcl@foo.oucs.ox.ac.uk> wrote:
> Ah, a challenge.  Here's my solution.  Call it with a file containing
> a pad as argument, plaintext on stdin, ciphertext on stdout.  No error
> checking of argument and the pad had better be at least as long as the
> input.  Sorry I couldn't make it a one-liner, but I needed the <stdio.h>
> for FILE* and EOF
> 
> #include<stdio.h>
> main(int c,char**a){FILE*p=fopen(a[1],"r");while(EOF!=(c=getchar()))putchar(c^getc(p));}
> 
> I make that 107 characters of ANSI C; maybe someone could get it into
> a <80 char one-liner.

Clever; I like the reuse of `c'.  Refinement gets it down to 105:

#include<stdio.h>
main(c,a)char**a;{FILE*p=fopen(a[1],"r");while(-1!=(c=getchar()))putchar(c^getc(p));}

But specifying the key on the command line gets it to 72.  (This isn't a
good thing to use on UNIX, of course, since the key will be visible to
anyone who runs ps(1); but a program with zero error checking isn't good
either.)

main(c,a)char**a;{char*k=a[1];while(-1!=(c=getchar()))putchar(c^*k++);}

And not a space in it.  Can anyone improve?
-- 
Vladimir.
