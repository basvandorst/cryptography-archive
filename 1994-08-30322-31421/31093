Path: msuinfo!agate!howland.reston.ans.net!swrinde!elroy.jpl.nasa.gov!usc!nic-nac.CSU.net!ctp.org!not-for-mail
From: jomcgow@eis.calstate.edu (John S. McGowan)
Newsgroups: sci.crypt
Subject: PGP math
Date: 23 Aug 1994 19:45:08 -0700
Organization: California Technology Project of The Calif State Univ
Lines: 135
Message-ID: <33ec7k$lg0@eis.calstate.edu>
NNTP-Posting-Host: eis.calstate.edu

Over in alt.security.pgp we were having a discussion of PGP, Carmichael 
numbers, etc. and most people seem to have only seen the simple minded 
(enough to work) math for PGP based on Fermat's little Theorem 
(Phi(n))... for anyone who is interested... here is a short FAQ on the 
real math behind PGP.

Since there has been so much discussion about carmichaels and when PGP
coding decoding works, I thought I would post the math facts on it... I
will not supply the proofs.

IF x is relatively prime to n, the multiplicative order of x mod n is
defined to be the smallest positive integer, k, for which x^k=1 mod(n)

IF x is NOT relatively prime to n, then for no positive integer k is
x^k=1 mod n

x^j=x mod n if and only if either x=0 (trivial) or (j-1) is a multiple
of the multiplicative order of x mod(n/GCD(n,x)) [NOTE that this implies
that x be relatively prime to n/GCD(x,n)]

GCD=Greatest common denominator... LCM=least common multiple

IF n is square free than for all x<>0 mod n, x IS relatively prime to
n/GCD(x,n)

Lambda(n) is the LCM of the multiplicative orders of the numbers
relatively prime to n (also equal to the largest order, since
multiplication is commutative).

If m divides n then Lambda(m) divides Lambda(n)

x^j=x mod n FOR ALL x if and only if j-1 is a multiple of Lambda(n) and
n is square free. (to work, j-1 must be divisible by all the orders of
the elements... lambda(n)... but wait, it must also be divisible by the
orders of x modulo (n/GCD(n,x)) or... with m=n/GCD(n,x) we would like it
to be divisible by lambda(m)... but m divides n, so divisibility by
lambda(n) IMPLIES divisibility by lambda(m)!).

Phi(n) is the number of numbers (from 1 to n) which are relatively prime
to n.

Lambda(n) divides Phi(n).

If a,b are relatively prime, lambda(a,b)=LCM(lambda(a),lambda(b)),
Phi(ab)=Phi(a)*Phi(b)

Lambda(p^k)=Phi(p^k)=p^k*(1-1/p) for odd primes p.

Phi(2^k)=2^(k-1)

Lambda(2^k)=   1 if k=1: 2 if k=2: 2^(k-2) if k>2

(once you can factor a number n, you can then get lambda(n) and phi(n))

A number x is a Carmichael number if x-1 is a proper multiple of
lambda(x) (that is, not equal to it... if x-1=lambda(x) then x is prime)

(561 is a Carmichael number)

Carmichael numbers have no square factors (4,9,16,25,...) and have at
least three prime factors.

Application to PGP... write n=pq where p,q are  square free and
relatively prime (so n is square free)... public key = e... private key
= d where ed=1 mod(lambda(n)).

Code message x as m=x^e mod n, decode as m^d=x^(ed) mod n... as ed-1 is
divisible by lambda(n), m^d=x mod n

PGP takes ed=1 mod (p-1)(q-1) where n=pq and p,q pass the PGP prime
tests.

IF (p-1)(q-1) is a multiple of lambda(n) then ed-1 is divisible by
lambda(n) and the coding/decoding work (if n is square free, of course).

IF p,q are distinct primes, then (p-1)(q-1) = Phi(n) which is a multiple
of lambda(n).

If p,q are distinct primes, then lambda(n)=LCM(p-1,q-1) (only needed to
use this instead of phi(n)).

If p,q are relatively prime primes or carmichael numbers than
LCM(p-1,q-1) and (p-1)(q-1) are multiples of lambda(n) (p-1 is a
multiple of lambda(p), so too for q-1 and lambda(q)... so LCM(p-1,q-1)
is a multiple of both lambda(p), lambda(q) and hence their LCM which is
lambda(n)).

If you come up with some magic number, M' which is relatively prime to e
and a multiple of lambda(n) and take d so that ed=1 mod M', then ed-1 is
divisible by lambda(n) and using e,d for coding/decoding works.

------------------------------------------------------------------------

I know most discussions of PGP simply use Phi(n) (which works, being a
multiple of lambda(n)) because it suffices. But I think the above gives
pretty much the math that is *not* covered in usual discussions of PGP
(and which is necessary to consider whether or not Carmichael numbers
would work for coding/decoding). There is more one can discuss, such as
the cyclic decomposition of the multiplicative group of elements
(mod(n)) which are relatively prime to n to consider, given a magic
number that is NOT a multiple of lambda(n) (does not decode *all*
messages), precisely how many messages (relatively prime to n) *does* it
decode (I had posted that in alt.security.pgp in another thread)?

Factoring n permits one to find lambda(n) (and decode messages once one
knows the public key)... finding a magic number may permit decoding
(using exponentiation... that is decode as m^d) (factoring n gives a
"magic number" that is a multiple of lambda(n)... for with the factors,
one can get lambda(n) itself!).

The above is the *real* theory on PGP (not the simple Phi(n) version
one often finds) (though it does not discuss factoring methods).

If a Carmichael composite pops up (passing the Fermat test PGP uses) you
will never notice it (though, then, n will have smaller prime factors
than expected... these still may be too large to facilitate factoring of
n, though... however, the prime factors of the Carmichael number may
have only small prime factors, perhaps facilitating a "magic number"
or iterative attack).

The Fermat test used by PGP is fine to ensure (very reliably) that one
has either a Carmichael composite or a prime (for p,q) (throw in some
more primes in the Fermat test if you are paranoid about it)... but
other tests (Miller-Rabin) should be used to kill the Carmichael
possibility.

[Does anyone disagree with any of the above... want to see any proofs?]


--
   John S. McGowan   |    jmcgowan@bigcat.missouri.edu [COIN] (preferred)
                     |    j.mcgowan15@genie.geis.com   [GEnie]
                     |    jomcgow@eis.calstate.edu     [CORE]
   ----------------------------------------------------------------------

