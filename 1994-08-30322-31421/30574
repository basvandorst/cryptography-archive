Path: msuinfo!agate!ames!waikato!auckland.ac.nz!news
From: pgut1@cs.aukuni.ac.nz (Peter Gutmann)
Newsgroups: sci.crypt
Subject: Re: Key safeguarding/anti-duress measures in cryptosystems (Long)
Date: 7 Aug 1994 07:11:18 GMT
Organization: University of Auckland
Lines: 78
Sender: pgut1@cs.aukuni.ac.nz (Peter Gutmann)
Message-ID: <3221em$kdq@ccu2.auckland.ac.nz>
References: <3134jf$dge@ccu2.auckland.ac.nz> <317621$gkt@news.umbc.edu> <170021241ES86.C445585@mizzou1.missouri.edu> <17002121B3S86.C445585@mizzou1.missouri.edu>
NNTP-Posting-Host: cs13.cs.aukuni.ac.nz
X-Newsreader: NN version 6.5.0 #7 (NOV)


Bryan Olson <olson@umbc.edu> writes:
 
>Peter Gutmann, author of SFS (pgut1@cs.aukuni.ac.nz) wrote:
>>What follows are some thoughts on anti-duress measures for cryptosystems that
>>I've been working on whenever I have time (which means: not very often).
>
>This is not strictly true.  There is one case in which the adversary could
>tell which shares are bogus: he could get some bogus shares but enough valid
>shares to form the required quorum.  You can partially protect all the
>shareholders by giving some bogus shares, unknown even to them, so an
>adversary can not be sure they intended to vote "no".
 
This is in fact how it works, since the shareholders don't know what kind of
shares they've been issued.  A deliberate "no" vote can't be seperated from an
unintentional "no" vote resulting from returning a share which was never of any
use anyway.
 
>In my own research on a file store with duress codes, I quickly came to the
>conclusion that I could not convince an adversary of a falsehood, such as lack
>of something really present, except by security-by-obscurity sorts of tricks.
>A proof of a falsehood is a contradiction.
 
Ahh, but the point is that *they* have to prove the truth of something, rather
than you having to prove the opposite.  What the share scheme does is make it
very difficult for them to prove this.
 
>To be effective, a duress code must appear to work like a real key. This model
>would only apply if the user normally required all these shares to mount an
>encrypted volume.  This is untenable.  No one is going to believe that the
>user doesn't keep enough valid shares, and has to pester his friends every
>time he wants to mount a volume.
 
Hmm, why not?  You don't need to reassemble all the shares every time you want
to mount the volume, all you need to do is convince an opponent that they
weren't all assembled at the time the attack was mounted.  Perhaps you heard
the sound of splintering timber just in time and zapped the shares, or had
heard clicking noises every time you picked up the phone and put two and two
together and got five and decided to wipe the shares, or whatever.  Again, it
isn't up to you to disprove the fact, it's up to the opponent to prove it, and
without your cooperation they can never do that.
 
>Rather than claiming to have insufficient information to generate the key, I
>suggest achieving plausible denyability by implementing false keys, which
>appear to work but show only a subset of the files.  No third parties are
>required.
 
The problem with this is that it's a security through obscurity approach.  As
John Kelsey <c445585@mizzou1.missouri.edu> commented:
 
>I guess I don't see the value in more than one level of duress codes
>("giveaway messages".)  If you're seriously under duress, and you give up your
>giveaway key, you may be okay.  But if you give away 2 keys, how can you prove
>to the person who's extracting information from you that you've given him the
>*last* key?
 
This is the problem with this scheme:  All it does is hide the data under
multiple levels of security, and by simply forcing you to cough up the keys for
all levels an opponent can get at the data.  The same would be true of the
share-based scheme if it didn't use junk shares: An opponent could force you to
decrypt all the shares present until they either had enough to reconstruct the
secret, or could prove that there really weren't enough there to reconstruct
it.  By adding junk shares, this problem is eliminated, and the question of
whether you want to yield the secret or not is left entirely to the
shareholder.
 
The multilevel scheme also has a somewhat nasty practical difficulty:
 
>First, the system can not be implemented simply as a block driver as SFS is.
>It must be a file system.
 
which makes it somewhat difficult to do for virtually all OS's except ones like
Linux which come with full source and for which you're encouraged to poke
around in the kernel.  I'd hate to have to rewrite HPFS386 or an MSDOS
redirector or an AUFS-like system, just to add encryption (CFS will do nicely,
but that's Unix-only).
 
Peter.
