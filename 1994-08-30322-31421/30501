Path: msuinfo!agate!library.ucla.edu!europa.eng.gtefsd.com!news.umbc.edu!olson
From: olson@umbc.edu (Bryan G. Olson; CMSC (G))
Newsgroups: sci.crypt
Subject: Re: Encrypted time capsules?
Date: 4 Aug 1994 20:20:45 GMT
Organization: University of Maryland, Baltimore County
Lines: 48
Message-ID: <31riit$mtu@news.umbc.edu>
References: <1994Aug3.184148.10326@cs.brown.edu> <31p2oc$dmf@news.umbc.edu>
NNTP-Posting-Host: umbc7.umbc.edu
X-Newsreader: TIN [version 1.2 PL2]

Bryan G. Olson; CMSC (G) (olson@umbc.edu) wrote:
: Ken Basye (kjb@cs.brown.edu) wrote:
: [...]
: : develop a system in which the writer does not hold the key, but can
: : recover it at some point in the future.

I described how independent, semi-trusted servers could provide this
capability without any interaction between servers, or between users
and servers.

Each server generates a public/private key pair and...
: publishes the
: public key now, and promises to publish the private key on Jan 2,
: 2000.
[...]

: The trusted server could fail us in two ways: divulge the private key
: when it should not, or not divulge the key when it should.  We can
: mitigate both threats by using multiple independent trusted servers.
[...]
: employ an (M,N)
: threshold (secret sharing) scheme.  We build a session key and N
: shares, any M of which recover the session key.  We then encrypt each
: of the N shares under a different server's public key, and store the
: encrypted shares (destroy session key and un-encrypted shares).  Now the
: data is recoverable if and only if any M of the N servers release
: their private keys.

: N shares, each encrypted under a public-key system (which must be
: secure for some time into the future and hence use large security
: parameters) could still take a lot of storage.  Is there some way to
: reduce this without introducing small sets of failure points ?
[...]

Silly me, there's an obvious improvement.

If we use a conventional symmetric algorithm for the session key, then
we have to build the (M,M) secret share stuff for each session.

What I should do is build my own public/private key pair, and
time-lock the private key as above, but keep the public key.  The
public key can now be used over and over to time lock other data.  For
a certain release date, I only need to store N encrypted shares, no
matter how many times I time-lock messages.



--Bryan
