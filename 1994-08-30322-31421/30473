Path: msuinfo!agate!howland.reston.ans.net!europa.eng.gtefsd.com!news.umbc.edu!olson
From: olson@umbc.edu (Bryan G. Olson; CMSC (G))
Newsgroups: sci.crypt
Subject: Re: Encrypted time capsules?
Date: 3 Aug 1994 21:38:20 GMT
Organization: University of Maryland, Baltimore County
Lines: 84
Message-ID: <31p2oc$dmf@news.umbc.edu>
References: <1994Aug3.184148.10326@cs.brown.edu>
NNTP-Posting-Host: umbc7.umbc.edu
X-Newsreader: TIN [version 1.2 PL2]

Ken Basye (kjb@cs.brown.edu) wrote:
[...]
: develop a system in which the writer does not hold the key, but can
: recover it at some point in the future.
[...]
:     One scheme for doing might this use a two-keyed system, like that
: used in public key cryptography.  In this scheme, one key is used to
: encrypt the diary, while the other, which will be used for decryption,
: is somehow made unavailable until the desired time interval has
: passed.

Using public-key systems, a single trusted server with a tamper-proof
memory/clock, could provide time-release to the entire world with no
on-line communication.  A group of independent servers could do this
with good reliability.

The server has a tamper-proof memory/clock units which will spit out a
private key on, say, Jan 1, 2000.  It publishes the corresponding
public key now, and promises to publish the private key on Jan 2,
2000.

Now anyone can generate a session key, encrypt data, and encrypt the
session key with the server's public key.  They store the encrypted
data and encrypted session key and destroy the plain session key (or
they could encrypt the whole thing with the private key, but see
below).  The session key and data are recoverable when the server
releases the private key.

The trusted server could fail us in two ways: divulge the private key
when it should not, or not divulge the key when it should.  We can
mitigate both threats by using multiple independent trusted servers.

To protect against early release, the user can multiply encrypt the
session key, under the public keys of several servers.  If any server
keeps its key until the proper disclosure date, the session key will
not be decryptable before that date.

To protect against failure to release, we can store multiple
ciphertexts of the session key, encrypted under different servers
public keys.  When any server releases its public key, we can decrypt
our session key.

To guard against both, we can store several ciphertexts of the session
key, encrypted under different subsets of public keys.  The data is
recoverable when and only when all of any of the subsets of servers
release their keys.

This could take a lot of storage, so we may want to employ an (M,N)
threshold (secret sharing) scheme.  We build a session key and N
shares, any M of which recover the session key.  We then encrypt each
of the N shares under a different server's public key, and store the
encrypted shares (destroy session key and un-encrypted shares).  Now the
data is recoverable if and only if any M of the N servers release
their private keys.

Note that none of these assume any interaction between the servers.
The only communication is the servers publishing their public keys
and, years later, their private keys.

N shares, each encrypted under a public-key system (which must be
secure for some time into the future and hence use large security
parameters) could still take a lot of storage.  Is there some way to
reduce this without introducing small sets of failure points ?  We
could allow interaction between the servers, provided that no group of
less than N-M points can either deliberately or accidentally induce
either type of failure.

(For example a solution that doesn't work without non-obvious
enhancement, is for each server to hold a share from an (M,N)
threshold scheme which secures a single private key.  Someone had to
build the key and distribute the shares, which introduces a single
point of failure.)


A plug:  From earlier in the post:

:     I've been struck recently by a number of incidents of people being
: forced to produce their private diaries to investigating authorities.

I've posted a couple things on how to build a cryptographic file
system with duress codes, which would be good for this sort of thing.


--Bryan
