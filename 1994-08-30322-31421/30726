Newsgroups: sci.crypt
Path: msuinfo!agate!howland.reston.ans.net!gatech!newsxfer.itd.umich.edu!zip.eecs.umich.edu!yeshua.marcam.com!charnel.ecst.csuchico.edu!csusac!csus.edu!netcom.com!phr
From: phr@netcom.com (Paul Rubin)
Subject: Re: Broadcastable authentification algorithm needed
Message-ID: <phrCuCKBw.KKA@netcom.com>
Keywords: DSS DSA signature public key authentification zero-knowledge
Organization: NETCOM On-line Communication Services (408 261-4700 guest)
References: <CuA908.5nK@taligent.com>
Date: Thu, 11 Aug 1994 01:33:31 GMT
Lines: 38

In article <CuA908.5nK@taligent.com>,
David Engberg <snarflrd@leland.stanford.edu> wrote:
>I'm designing a GPL-able distributed DB system which needs to be able
>to resolve change requests between a large number of
>not-necessarily-trusted hosts.  This means that a host must be able to
>send out an object change which will only be carried out by others if
>the original host knows the object's secret 'key'.
>
>Due to this architecture, other constraints are implicit:
>
>1) a signed message must be verifiable by all (including non-trusted)
>   servers, whether or not they posess the key.
>2) the signature on a given change-request cannot be used verbatim by a
>   non-trusted server to sign a second message.
>3) the algorithm cannot rely on multiple-level communications back and
>forth
>   to establish validity:  need a sign-once-broadcast-out system.
>4) the algorithm used needs to be as freely-usable and -exportable as
>   possible.
>
>Obviously, public-key signatures (and public-key encryption, as a
>superset) could satisfy 1-3, but only DSS would satisfy 4, and I have
>been unable to find any published DSA implementation yet.  (anyone?
>anyone?)  In any case, threatening legal posturing by RSA makes even
>DSA seem like dangerous overkill for what should be a simpler problem.

1) there are some DSA implementations floating around, somebody will
probably point you at one.  But checking a DSA signature is very slow.

2) Is there some reason the object's secret key has to stay the same
when the object changes?  If not, why not just use a simple one-way
hash function?  I.e., create a random secret key K for each object and
store H(K) in the object.  To change the object, prove you know K by
simply sending it as part of the change request.  You also include a
new hash H(K') to be stored in the changed version of the object and
K' becomes the secret key for the next change.  Extensions for objects
having more than one owner, safeguards against active attacks,
etc. are left as exercises.
