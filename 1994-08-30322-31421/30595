Path: msuinfo!agate!howland.reston.ans.net!europa.eng.gtefsd.com!news.umbc.edu!olson
From: olson@umbc.edu (Bryan G. Olson; CMSC (G))
Newsgroups: sci.crypt
Subject: Re: Key safeguarding/anti-duress measures in cryptosystems (Long)
Date: 7 Aug 1994 19:45:32 GMT
Organization: University of Maryland, Baltimore County
Lines: 136
Message-ID: <323dks$g44@news.umbc.edu>
References: <317621$gkt@news.umbc.edu><17002121B3S86.C445585@mizzou1.missouri.edu> <3221em$kdq@ccu2.auckland.ac.nz>
NNTP-Posting-Host: umbc7.umbc.edu
X-Newsreader: TIN [version 1.2 PL2]

Peter Gutmann (pgut1@cs.aukuni.ac.nz) wrote:
: Bryan Olson <olson@umbc.edu> writes:

[Peter]
: A deliberate "no" vote can't be seperated from an
: unintentional "no" vote resulting from returning a share which was never of any
: use anyway.
:  
This still does give an adversary some information.

[Bryan]
: >In my own research on a file store with duress codes, I quickly came to the
: >conclusion that I could not convince an adversary of a falsehood, such as lack
: >of something really present, except by security-by-obscurity sorts of tricks.
: >A proof of a falsehood is a contradiction.

:  
: Ahh, but the point is that *they* have to prove the truth of something, rather
: than you having to prove the opposite.  What the share scheme does is make it
: very difficult for them to prove this.
:  

If they have to prove the data is available, I suggest "I forgot".

Perhaps I misunderstood the types of attack against which you want to
defend.  This seems to defend only against adversaries who imposes
strict limitations upon themselves, and must prove their case to a
third party.  In cases such as "show me what's there or you're
fired/divorced/dead" it doesn't help.

I am going for a stronger result than leaving the adversary unable to
prove some data is available.  I want the adversary's observations to
be independent of whether certain data exists.  I did not envision my
formulation of duress codes solely, or even primarily to help
criminals conceal evidence, although it would work well for that.

: >To be effective, a duress code must appear to work like a real key.[...]

I still believe this is fundamental to duress codes, cryptographic or
otherwise.

: You don't need to reassemble all the shares every time you want 
: to mount the volume, all you need to do is convince an opponent that they 
: weren't all assembled at the time the attack was mounted.  Perhaps you heard 
: the sound of splintering timber just in time and zapped the shares, or had 
: [...]

This defense does not require a secret-sharing scheme at all.
Just derive the crypto key from (among other things) a stored vector,
and have in place a program which will over-write the vector with
random noise.  Any shared escrow of the vector is incidental.

The user would be admitting the destruction of damaging information.

: >Rather than claiming to have insufficient information to generate the key, I
: >suggest achieving plausible denyability by implementing false keys, which
: >appear to work but show only a subset of the files.  No third parties are
: >required.
:  
: The problem with this is that it's a security through obscurity approach.  As

I want to emphasize that this is absolutely not the case with the (as
yet unimplemented) scheme I describe.  I accept the usual rules: the
adversary knows all about the system except the values of the keys.
There are a couple of subtle points to my suggestion which, I believe,
were not clear to John.

: John Kelsey <c445585@mizzou1.missouri.edu> commented:
:  
: >I guess I don't see the value in more than one level of duress codes
: >("giveaway messages".)  If you're seriously under duress, and you give up your
: >giveaway key, you may be okay.  But if you give away 2 keys, how can you prove
: >to the person who's extracting information from you that you've given him the
: >*last* key?
:  

My original thinking was a two-level scheme.  Setting up a duress
code would be optional.  If one was set up and you opened the file
system with it, it would reveal a perfectly valid volume on which the
duress option was turned off.  Even the designer of the system would
be unable to tell the duress code from a true key for a volume which
has no duress code.  The problem is that there is no reason to have a
two level system and only use one level.  The levels set up a
prisoner's dilemma.  You can make it even more general if you want,
putting the keys in a tree, or even a rooted DAG.

John is correct that one can not prove he gave the "last" (highest
level) key.  For a given size and content of the user files revealed
by a key, the evidence that it is the last key is independent of
whether it is the last key.

: This is the problem with this scheme:  All it does is hide the data under
: multiple levels of security [...]

No, it hides the existence of higher levels.  (It is the ability to
hide them that makes proving a level is the highest impossible.)

: The same would be true of the
: share-based scheme if it didn't use junk shares: An opponent could force you to
: decrypt all the shares present until they either had enough to reconstruct the
: secret, or could prove that there really weren't enough there to reconstruct
: it.  By adding junk shares, this problem is eliminated, and the question of
: whether you want to yield the secret or not is left entirely to the
: shareholder.

The junk shares in your scheme fulfill a similar purpose to the free
pages in mine.  Most of the duress resistance schemes proposed in
sci.crypt have involved including some filler which may be garbage or
may be ciphertext.  The problem is that there is no reason to waste
the space unless it actually is useful ciphertext.

What is the logical number of junk shares for the user to keep ?
Zero.  The possibility of keeping a junk share supports the claim that
valid shares are junk shares.  Actually storing a junk share doesn't
help at all.

The key to the plausibility of my system is that the filler does not
waste space.  It fills pages which are free (available for
allocation).  Disks, whether encrypted or not, normally contain
substantial and widely varying amounts of free space.  My system would
fill all free pages with random noise, and mark all pages which are
encrypted at higher levels as free in the lower levels.

: The multilevel scheme also has a somewhat nasty practical difficulty:
:  
: >First, the system can not be implemented simply as a block driver as SFS is.
: >It must be a file system.
:  

Granted.  The installable file system interface for OS/2 and WindowsNT
seems to be documented only in the folklore.  

Still, that's just a SMOP (simple matter of programming).


--Bryan
