Path: msuinfo!agate!howland.reston.ans.net!europa.eng.gtefsd.com!MathWorks.Com!blanket.mitre.org!linus.mitre.org!gauss.mitre.org!bs
From: bs@gauss.mitre.org (Robert D. Silverman)
Newsgroups: sci.crypt
Subject: Re: How safe is RSA?
Date: 23 Aug 1994 01:58:04 GMT
Organization: Research Computer Facility, MITRE Corporation, Bedford, MA
Lines: 116
Distribution: world
Message-ID: <33bl3c$jj@linus.mitre.org>
References: <33b5uh$mal@nntp.ucs.ubc.ca> <33b8cf$f4l@linus.mitre.org> <AVENGER.94Aug22185437@tern.acns.nwu.edu>
NNTP-Posting-Host: gauss.mitre.org

In article <AVENGER.94Aug22185437@tern.acns.nwu.edu> avenger@tern.acns.nwu.edu (Sam Pullara) writes:
:In article <33b8cf$f4l@linus.mitre.org> bs@gauss.mitre.org (Robert D. Silverman) writes:
:
:
:   In article <33b5uh$mal@nntp.ucs.ubc.ca> unruh@physics.ubc.ca (William Unruh) writes:
:   :trefor@flevel.demon.co.uk (Trefor Southwell) writes:
:
:   stuff deleted...
:
:   :>I sorry if the question was meaningless to YOU however you seem to have
:   :>understood it very well - unfortunatly you were unable to answer it :-)
:   :

stuff was deleted (not by me)

:   :>Do you happen to have for a formula for determining the probability of
:   :>cracking an n bit RSA within the time period t?
:   :
:   :Well I sent a formula to you by email but since you apparently either
:   :did not receive it or read it, here it is
:   :#operations is of order exp(1.9 (L)^(1/3)(ln(L))^(2/3) ) for the "best"
:   :the Number Field Sieve, for large numbers- L is the length in bits I
:   :believe.
 
	^^^^^^^^^^^I Did not write this ^^^^^^^^^^^^^^^^^^

:
:   This is incorrect. If L is the length in bits then N ~ 2^L.
:   The run time is
:
:   O((1.9 + o(1)) (log N)^1/3 (log log N)^2/3)
:
:   Your forgot the o(1) term [it is important for real problems]
:   and log(2^L)  does NOT equal L. It equals  L log 2. You are missing
:   two instances of log2 in your exponent. This is the natural logarithm.
:
:   Finally, this is (essentially) a deterministic run time and does
:   not answer the question about "probability of cracking in time t"
:   [which is basically gibberish. If t is fixed, then it either is 
:   or is not sufficient to factor a number of given size. There is no
:   "probability"]

   ^^^^^^^^^^^^^^^^^I did write this. Exactly what is insulting?

:First of all, I would like to point out that mean-spirited, insulting posts
:have no place in this newsgroup.  Secondly, since you are so up on what is
 
What insults? I merely pointed out that an answer was wrong and that a
question was not well posed. Please explain where the insult lies.
My answer explained where the answer was wrong and why the question was
not well posed.


:what isn't meaningless I suppose you can explain how your answer has any
:meaning what-so-ever.  Giving the order of the problem in no way tells
:anyone how long the algorithm is going to take.  Maybe with a sample time
 
This is unfair. If you would have read my *earlier* response, you would have 
read that I said the implied constant was implementation and machine dependent.
I posted the time-complexity function in a post separate from Mr. Unruh's.
Do I have to repeat myself everytime I post?
The only way to determine ACTUAL time is to code it and run it on a machine.
And this is true in ANY complexity analysis. 


I have discussed these issues and explained them at length many times
within this newsgroup. It gets a little tiring to keep seeing and correcting
erroneous posts from people who have neither studied the mathematics or
the algorithms involved nor who have implemented them.

:from an arbitrary machine, but not without any reference to a computer.
:Finally, the "probability of cracking in time t" has definite meaning for
:any algorithm that is not entirely deterministic.  I suppose you have never
:used a Monte Carlo method and have no knowledge of statistics.
 
Your supposition is incorrect. I suggest you start by reading some of
my papers. And cracking in time "t" has no meaning for the best factoring
algorithms. Given a number N, and a GNFS or QS implementation and a 
given machine and a time 't', you know in advance whether 't' will be
sufficient. Either you spend enough time to collect enough relations
to factor the number or you don't. The time is perfectly predictable
(to within a couple of percent).

 
Do you know how QS and NFS work? You construct a number of congruences
A_i ^2 = B_i ^2  mod N  and compute (A_i + B_i, N) and (A_i - B_i, N)
if A_i != +/- B_i mod N, then N is factored. The time it takes to 
construct these congruences is perfectly deterministic and constitutes
> 99.9999...% of the total run time. The only probabilistic part of the
algorithm is that if N has 2 factors there is at least a probability
of 1/2 that any given congruence does NOT have A_i = +/- B_i mod N.
The process that constructs ONE of these congruences gives you HUNDREDS
or THOUSANDS (at your whim) at once. I have never seen more than 9 such
congruences needed. And if the onces you have ALL fail to factor the
number it is trivial to find as many more as you need, once you have
the inital set. The time to construct the congruences, relative to the time
to gather the relations goes quickly to 0 as N --> oo. Asymptotically,
it is in the error term.


The key point is that the time to gather the data needed to construct the
congruences is perfectly deterministic. The time to compute the actual
congruences is just a few hours (at worst) compared to several thousand
MIPS-YEARS to collect the data for numbers than are within reach.

So. Given N and given 't', either 't' is sufficient to collect enough
relations or it is not. However, once you have them the algorithm
succeeds with as close a probability to 1 as you care to make it and
the time it takes to do so is trivial.


-- 
Bob Silverman
These are my opinions and not MITRE's.
Mitre Corporation, Bedford, MA 01730
"You can lead a horse's ass to knowledge, but you can't make him think"
