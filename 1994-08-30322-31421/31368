Path: msuinfo!news.mtu.edu!sol.ctr.columbia.edu!newsxfer.itd.umich.edu!gatech!news-feed-1.peachnet.edu!umn.edu!newsdist.tc.umn.edu!msus1.msus.edu!solar!mmorgan
Newsgroups: sci.crypt
Subject: Blowfish, speed, speed, speed.
Message-ID: <1994Aug30.002309.1637@msus1.msus.edu>
From: mmorgan@solar.ee.stcloud.msus.edu (Michael S. Morgan)
Date: 30 Aug 94 00:23:08 -0500
Reply-To: mmorgan@solar.ee.stcloud.msus.edu
Sender: mmorgan@solar (Michael S. Morgan)
Distribution: world
Organization: St. Cloud State University, EE Department
Nntp-Posting-Host: solar.ee.stcloud.msus.edu
Lines: 47

I was trying to optomize my implementation of the blowfish
algorithm, which I rewrote into a c++ module.

My implementation allows, except in the case of the 
unravelled loop, to define at _runtime_ the number of 
rounds used, from 2 to 222, in steps of 2.  The unravelled
loop version only allows 18 rounds.

For the following benchmarks, I used the standard 18
round blowfish (defined at runtime, except as noted
above).

To find these benchmarks, I re-encrypted a 4096 block of 
data 1024 times, for a throughput of 4 MBytes.  File
operations were _not_ included in this first benchmark; 
neither were any initialization operations for the password.  

PROG0.0:  Nothing unraveled, no macros
PROG0.1:  Blowfish_encrypt unraveled
PROG0.2:  F function replace with macro with arguments
PROG0.3:  Blowfish_encrypt unraveled, F function replaced with macro

		Time(Seconds) 	Mbytes	kBytes/Second
PROG0.0		185 		4	22
PROG0.1 	164 		4	25
PROG0.2 	131 		4	31
PROG0.3 	105 		4	39

The second test I performed, was to encrypt a file with a 17
byte key, using 18 rounds, and using the algorithm in used
in PROG0.2.  The file I encrypted was 592 kBytes long.  The
timing included all file operations (reading and writing), 
as well as blowfish initializations.

PROG1.0:  As described in the above paragraph.

		Time (Seconds)	kBytes	kBytes/Second
PROG1.0		42.5		592	13.9

I am sure that a normal c, instead of c++, implementation
would run quicker.  Also, this second benchmark doesn't
mean much, as I do not know the speed of my drive:(

Has anybody else out there benchmarked their implementations
on a similar platform?

Mike
