Newsgroups: sci.crypt
Path: msuinfo!netnews.upenn.edu!news.amherst.edu!news.mtholyoke.edu!uhog.mit.edu!news.kei.com!eff!news.umbc.edu!haven.umd.edu!ames!taligent!Dave.Engberg
From: snarflrd@leland.stanford.edu (David Engberg)
Subject: Re: Broadcastable authentification algorithm needed
Message-ID: <CuE7EE.J12@taligent.com>
X-Posted-From: InterNews 1.0@taligent.com.
Lines: 42
Sender: -Not-Authenticated-[7990]
Organization: Taligent, Inc.
References: <CuA908.5nK@taligent.com>  <phrCuCKBw.KKA@netcom.com>
Date: Thu, 11 Aug 1994 22:49:26 GMT
Xdisclaimer: No attempt was made to authenticate the sender's name.

phr@netcom.com (Paul Rubin) writes:

> David Engberg <snarflrd@leland.stanford.edu> wrote:

> >I'm designing a GPL-able distributed DB system which needs to be able
> >to resolve change requests between a large number of
> >not-necessarily-trusted hosts.  This means that a host must be able to
> >send out an object change which will only be carried out by others if
> >the original host knows the object's secret 'key'.

> 1) there are some DSA implementations floating around, somebody will
> probably point you at one.  But checking a DSA signature is very slow.

I've seen several requests for implementations, but no one has posted
an answer to this in the time I've been watching ... thankfully, you're
right that it's too slow and definitely overkill for the problem,
especially considering potential legal problems.

 
> 2) Is there some reason the object's secret key has to stay the same
> when the object changes?  If not, why not just use a simple one-way
> hash function?  I.e., create a random secret key K for each object and
> store H(K) in the object.  To change the object, prove you know K by
> simply sending it as part of the change request.  You also include a
> new hash H(K') to be stored in the changed version of the object and
> K' becomes the secret key for the next change.  Extensions for objects
> having more than one owner, safeguards against active attacks,
> etc. are left as exercises.

Multiple owners are necessary, and I believe you've lead me to a
solution that should work using only hashing function H():
Owners keep a single private key K for the object.  Every object has
two extra fields:  P (some random string) and R'
R' = H(R)  and R = H(K+P)  where K+P is a concatenation of K and P.

An owner of K can prove to anyone that she knows K by sending out a
message that includes R.  The owner would also have to include a new P
and R' in the message which would then be stored in the object.

I think some variation on this technique is precisely what I need, and
since it relies entirely on hashing, ludicrous US export/patent laws
shouldn't be a problem.  Thanks for your help!
