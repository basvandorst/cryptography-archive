Path: msuinfo!scss3.cl.msu.edu!mrr
From: mrr@scss3.cl.msu.edu (Mark Riordan)
Newsgroups: sci.crypt
Subject: Check digit challenge: solved
Date: 14 Aug 1994 01:21:36 GMT
Organization: Michigan State University
Lines: 195
Message-ID: <32jrj0$11ch@msuinfo.cl.msu.edu>
NNTP-Posting-Host: scss3.cl.msu.edu
X-Newsreader: TIN [version 1.2 PL1]

On 7 Aug 94, I posted the message below, challenging sci.crypt
to break a non-cryptographic but complex check digit algorithm.
Well, we have a winner!  Conrad Hughes <chughes@maths.tcd.ie>
broke it in a single night.  

I waited several weeks before issuing my challenge, because
I thought that the net had had a few too many challenges lately.
My fears seem to have been justified, because it appears that
only a half dozen or so people have tried yet.

Note that you can use "known plaintext" attacks to your
heart's content, courtesy of the email-based server.

I've asked Conrad to wait a couple of weeks before posting
his solution, to give others more time to work on the problem.

Congratulations to Conrad!

Mark R.
---------------------------------------------------------

Subject: Real-life Check Digit Challenge

This is a challenge to sci.crypt readers to see if you 
can determine the algorithm used to compute the check digit of
a customer number in a real-life application.

A while ago, I was coding a program which accepted as input
a customer number (amoung other things).  I wanted to provide
some sort of check for the validity of a customer number as
keyed by the operator.  It was not practical
for this application to have online access to the actual
database of live customer numbers.  Fortunately, I knew
that each customer number had a check digit as its last
digit.  I wished to provide a function to check this digit
as a mediocre way of validating the operator's input

I had a suspicion that the check digit algorithm might be
complex.  I did not even attempt to crack it myself.
I considered issuing a challenge to the net to help
me crack the checksum function.  But I decided against it
because it would have entailed posting a list of valid
customer numbers, which seemed dicey.

At any rate, after some delays, I was given a copy of a
COBOL program which computed the check digit.  I wrote a
C program to implement the algorithm, which is surprisingly
complex.  This solved the problem for me, and it also allows
me to issue this challenge without posting real customer numbers.

This algorithm takes as input a 10-digit decimal ASCII
number, and outputs an 11th digit used for error detection.
This check digit allows you to catch all single-digit errors,
and all adjoining-digit transpositions.  The algorithm
is apparently not intended to be cryptographic.
Still, I'll be impressed if anyone breaks it easily.

Below is a table of some (fake) 10-digit customer numbers,
plus the 11th digit, which is the check digit.
Additionally, you can mount a chosen-plaintext attack on this 
checksum function by using an email server I have set up.
Just create a file with an arbitrary number of 10-digit
decimal numbers, one per line, and mail it to:

   check-digits@ripem.msu.edu

You will receive a reply message in the same format as below.

By the way, I have a suspicion that this check digit function
may be well-known in some circles, though I had certainly never
heard of it.  No fair spilling the beans if you are acquainted
with this algorithm!

Have fun!  

Mark R.
---------------  cut here  ---------------
1111111111 0
2222222222 1
3333333333 5
4444444444 0
5555555555 1
6666666666 7
7777777777 1
8888888888 4
9999999999 4
0123456789 9
1234567890 3
2345678901 6
3456789012 9
4567890123 8
5678901234 1
6789012345 3
7890123456 6
8901234567 1
9012345678 3
0000000001 1
0000000002 5
0000000003 3
0000000004 4
0000000005 7
0000000006 6
0000000007 9
0000000008 2
0000000009 8
0000000010 4
0000000100 1
0000001000 4
0000010000 1
0000100000 4
0001000000 1
0010000000 4
0100000000 1
1000000000 4
0000000002 5
0000000020 8
0000000200 7
0000002000 2
0000020000 9
0000200000 5
0002000000 8
0020000000 7
0200000000 2
2000000000 9
0000000003 3
0000000030 6
0000000300 3
0000003000 6
0000030000 3
0000300000 6
0003000000 3
0030000000 6
0300000000 3
3000000000 6
0000000004 4
0000000040 1
0000000400 4
0000004000 1
0000040000 4
0000400000 1
0004000000 4
0040000000 1
0400000000 4
4000000000 1
0000000005 7
0000000050 2
0000000500 9
0000005000 5
0000050000 8
0000500000 7
0005000000 2
0050000000 9
0500000000 5
5000000000 8
0000000006 6
0000000060 3
0000000600 6
0000006000 3
0000060000 6
0000600000 3
0006000000 6
0060000000 3
0600000000 6
6000000000 3
0000000007 9
0000000070 5
0000000700 8
0000007000 7
0000070000 2
0000700000 9
0007000000 5
0070000000 8
0700000000 7
7000000000 2
0000000008 2
0000000080 9
0000000800 5
0000008000 8
0000080000 7
0000800000 2
0008000000 9
0080000000 5
0800000000 8
8000000000 7
0000000009 8
0000000090 7
0000000900 2
0000009000 9
0000090000 5
0000900000 8
0009000000 7
0090000000 2
0900000000 9
9000000000 5

