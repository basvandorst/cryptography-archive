Path: msuinfo!agate!ames!waikato!auckland.ac.nz!news
From: pgut1@cs.aukuni.ac.nz (Peter Gutmann)
Newsgroups: sci.crypt
Subject: Re: Key safeguarding/anti-duress measures in cryptosystems (Long)
Date: 18 Aug 1994 04:59:22 GMT
Organization: University of Auckland
Lines: 91
Sender: pgut1@cs.aukuni.ac.nz (Peter Gutmann)
Message-ID: <32upra$i5v@ccu2.auckland.ac.nz>
References: <317621$gkt@news.umbc.edu> <17002121B3S86.C445585@mizzou1.missouri.edu> <3221em$kdq@ccu2.auckland.ac.nz> <323dks$g44@news.umbc.edu>
NNTP-Posting-Host: cs13.cs.aukuni.ac.nz
X-Newsreader: NN version 6.5.0 #7 (NOV)




Bryan Olson <olson@umbc.edu> writes:
 
>Perhaps I misunderstood the types of attack against which you want to defend.
>This seems to defend only against adversaries who imposes strict limitations
>upon themselves, and must prove their case to a third party.  In cases such as
>"show me what's there or you're fired/divorced/dead" it doesn't help.
 
That's what I'm worried about, and possibly why anti-duress measures of this
form haven't been used much to date.  There are probably two main types of
attacker you need to defend against:
 
1. A civilized adversary with limited means.
2. An adversary who will use any means possible to get to the data.
 
My scheme is best for type 1, your scheme will withstand type 2.  The main
concern with type 1 is that this covers the kind of attack "the good guys" will
use, whereas "the bad guys" won't have any qualms about the second type of
attack.  As you say:
 
>I did not envision my formulation of duress codes solely, or even primarily to
>help criminals conceal evidence, although it would work well for that.
 
which is a major concern, and the main reason why my current efforts for SFS
only cover simple key distribution to allow later recovery if the keyholder
dies/is fired/forgets the key.
 
>The key to the plausibility of my system is that the filler does not waste
>space.  It fills pages which are free (available for allocation).  Disks,
>whether encrypted or not, normally contain substantial and widely varying
>amounts of free space.  My system would fill all free pages with random noise,
>and mark all pages which are encrypted at higher levels as free in the lower
>levels.
 
This sounds like something I looked at a while back, motivated by a either a
sci.crypt posting or some email I received from someone.  This idea is somewhat
DOS-specific because it was meant for SFS, you may want to keep a sick bag
handy:
 
  DOS uses a file allocation table (FAT) to keep track of what's where on the
  disk.  This is basically a map of free and used disk blocks, with files
  consisting of linked lists of blocks.
 
  Hidden data is stored in a meta-file which contains as many free blocks as
  you need (this is pretty much how Stacker, JAM, and Windoze swap files work).
  With the "unsafe" level of encryption, you mark these blocks as being free
  disk space.  With the "safe" level, you (transparently) change them to become
  proper FAT entries.
 
  This has the problem that empty FAT entries contain zeroes, whereas the above
  scheme would fill them with random data, even though to DOS they would still
  appear to be empty.  An attacker can therefore still see that there's
  something there.
 
  You could keep the block map truly empty by taking advantage of the fact that
  DOS disks contain two FAT's, of which only one is ever really used.  You
  therefore mirror the first FAT in software to make DOS think there are still
  two FAT's there, and use the second FAT to store random data which may or may
  not contain the "hidden" block map.
 
This solves the problem nicely, but requires translating logical->physical
values whenever you write new data to disk (for a better discussion of this,
read the section on disk defraggers in the docs for garbo.uwasa.fi:
/pc/arcers/jam119sw.zip.  The scheme used by this program to store information
on compressed data blocks could also be used to store information on hidden
data blocks, but it does introduce other problems).
 
The other problem is that you're going to destroy hidden data if you write to
the disk in "unsafe" mode, and you always need *some* way to get to the data
which will serve as a beacon for an attacker looking for evidence of concealed
information.
 
OK, the DOS stuff is over, you can open your eyes again.
 
It would appear that the only truly feasible anti-duress measure is to hide the
data in such a way that even an opponent with unlimited means can't find it. 
The two (or multilevel) scheme which hides data in "empty" disk sectors almost
covers this (you still need *some* way to get to it, and the presence of the
access information can't be hidden).  However the data-hiding requires a custom
filesystem which can't be implemented in any easy way for most commercial OS's,
which at best allow only for the creation of block device drivers (OS/2 has
installable filesystem (IFS) support, but I can't imagine anyone rewriting half
of HPFS386 just to offer a bit of data hiding).
 
Assuming the coding isn't a problem, is there any practical solution which
doesn't reveal any information (or have I just misunderstood your posting)?
 
Peter.

