Path: msuinfo!netnews.upenn.edu!dsinc!spool.mu.edu!howland.reston.ans.net!europa.eng.gtefsd.com!news.umbc.edu!olson
From: olson@umbc.edu (Bryan G. Olson; CMSC (G))
Newsgroups: sci.crypt
Subject: Re: Self-destructive encryption util
Date: 8 Aug 1994 22:29:54 GMT
Organization: University of Maryland, Baltimore County
Lines: 32
Message-ID: <326bl2$oll@news.umbc.edu>
References: <mpjCu80pJ.E3@netcom.com>
NNTP-Posting-Host: umbc7.umbc.edu
X-Newsreader: TIN [version 1.2 PL2]

Michael Paul Johnson (mpj@netcom.com) wrote:

: Make every block on the floppy a function 
: not only of the key, but of some value (a random initialization vector, 
: perhaps) on the disk.  To destroy the data in a hurry when the bad guys 
: (or cops, in your case) are breaking and entering, all your hot key 
: function has to do is to overwrite the initialization vector (which you 
: don't have memorized or copied elsewhere) with some garbage.  This 
: instantly makes all data on the disk unrecoverable, unless you can either 
: break the encryption algorithm or do a brute force search for the random 
: value.  This could be used to nearly instantly destroy the data on hard 
: disks, too.

And it's much more practical than the thermite.

Note that we can simply derive the key from this stored ivector (among
other things such as a pass-phrase) instead of using it along with a
key.  As in say:
          key = hash( ivector, hash(passphrase))

Practical encryption systems do a check on any user-entered key
material.  This check should be done on the complete key, that is
after combination with the ivector.  That way if Bob gives Eve a
pass-phrase, and Eve is unable to decrypt with it, she can't tell if
Bob overwrote the ivector or lied about the passphrase.  The mere
presence of a routine to overwrite the ivector gives Bob plausible
deniability.

( The system should choose ivectors and overwrite values randomly from
the same distribution.)

--Bryan
