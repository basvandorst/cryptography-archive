Newsgroups: sci.crypt
Path: msuinfo!agate!dog.ee.lbl.gov!ihnp4.ucsd.edu!mvb.saic.com!MathWorks.Com!news.duke.edu!news-feed-1.peachnet.edu!gatech!swrinde!elroy.jpl.nasa.gov!decwrl!netcomsv!netcom.com!phr
From: phr@netcom.com (Paul Rubin)
Subject: Re: **VERY FAST 1024BIT RSA**
Message-ID: <phrCvD1z4.7qD@netcom.com>
Organization: NETCOM On-line Communication Services (408 261-4700 guest)
References: <33s2f2$3p3@lucy.ee.und.ac.za> <33uhkc$fck@vanbc.wimsey.com>
Date: Tue, 30 Aug 1994 18:28:15 GMT
Lines: 53

In article <33uhkc$fck@vanbc.wimsey.com>,
Mark C. Henderson <markh@vanbc.wimsey.com> wrote:
>In article <33s2f2$3p3@lucy.ee.und.ac.za>,
>Other tricks and techniques include:
>1. Observe that squaring is easier than multiplying.

Why?  Because (a+b)^2 = a^2 + 2ab + b^2 gives three 1/2-size multiplies
instead of 4, or do you have something else in mind?

>2. Montgomery Multiplication. This is cool because you avoid doing
>   mod/division, which is really nasty.

For encryption where you square only a few times, you may not
win from this because of all the precomputation you need to do.
For decryption, it certainly seems like a win.

An alternative to Montgomery multiplication for decryption is a
speed-memory tradeoff: just precompute a table of multiples of powers
of 256 (or 16, or 2) mod N.  Then to compute X^2 mod N, first compute
X^2 using Karatsuba, then reduce it mod N by adding up the appropriate
residues.  On machines with very slow multiplication, this looks like
it might beat Montgomery at least for 512-bit modulus with CRT.  The
idea is that Montgomery replaces a multiplication and division with
two multiplications, while the residue table replaces it with one
multiplication and O(N^2) additions.

>3. Karatsuba (although you have to be very careful with this to
>   get an advantage with 1024 bit numbers).

It looks like quite a big win with numbers of this size on machines
with slow multiplication (Intel x86).

>5. FFT (can anyone make this an advantage over simpler methods with 
>   1024 bit numbers?) 

It would surprise me a lot.  Any other views?  You wouldn't want to
actually do an FFT, but rather use a fast convolution algorithm that
bypasses the FFT (see Knuth vol. 2. etc.).  This might be more worth
looking into for schemes like El-Gamal, where instead of computing x^s
mod N (where s is constant but x is different in every instance of the
problem), you are computing g^x mod P (where g is a fixed generator
so you can do as much precomputation on it as you want).

>For example, you can get a considerable speed up with the naive 
>algorithm in RSAREF if you can code the operation of multiplying two 
>unsigned words to get a double length unsigned word as a single 
>assembler instruction. You can do this on most modern processors: 
>e.g. RS6000, V8 Sparc, 80486. 

Yes but if you do Karatsuba in the obvious way, you actually
want unsigned results some of the time and signed results other
times.  Is there a way to avoid doing everything unsigned and
using compares and branches to sort things out?
