Path: msuinfo!agate!library.ucla.edu!csulb.edu!nic-nac.CSU.net!ctp.org!not-for-mail
From: jomcgow@eis.calstate.edu (John S. McGowan)
Newsgroups: sci.crypt
Subject: Re: RSA - Cracked ?
Date: 7 Aug 1994 15:50:44 -0700
Organization: California Technology Project of The Calif State Univ
Lines: 271
Message-ID: <323og4$nn3@eis.calstate.edu>
References: <776193204Stu.stu@nemesis.wimsey.com>
NNTP-Posting-Host: eis.calstate.edu

I had posted this to alt.security.pgp... can anyone tell me what is wrong 
with it? Or is RSA weak? (too many weak messages... that is ones for 
which the order of the message only has small prime factors) (this is a 
concatenation of two messages).

Two questions on the security of PGP/RSA:

(first a description of why I ask the questions)

What is the probability that a number of size (about equal to) b has no
prime factors greater than a?

Is it not (about) PRODUCT[(1-1/p):p primes from a to b]?

Replacing 1-1/p by exp(-k/p) where k is about one (for p ... that is,
a... sufficiently large) and taking (asymptotically) the exponent as
-1/p, we want exp(SUM[-1/p]) and replacing the sum with a Stieltjes
integral (N(x)=number of primes less than x), INTegral[(1/x)dN(x)] and
replacing (1/x is monotone and N(x)/x-->0) N(x) with integral
(asymptotically) INTEGral[from 1 to x:dt/ln(t)] does this not become
exp(-ln(ln(b)/ln(a))=ln(a)/ln(b)=log(a)/log(b) (logs to different bases
are proportional) (note... is [log(a)/log(b)]^r where r gets close to
one [asymptotical results only in the exponent]... and factors in the
exponent can have a great effect on the numerical value.

Example... if we pick a number of L bits (randomly), the prob. it has no
prime factor larger than 8096 (=2^13) is about 13/L (logs in base 2).

My worry about this is as follows... PGP... pick two primes p,q of
length L bits... n=pq

Note: x^j=x mod n for all x if and only if:

1) n is square free (not divisible by 4,9,16,25,etc.) and
2) j=1 mod L(n)

L (used for the greek Lambda... given n... let x be relatively prime to
n... consider x,x^2,x^3,.... mod n... sooner later one of these is
1 modulo n... let the first exponent for which x^exponent=1 mod n be
called o_n(x) (order of x mod n)... let the largest of these numbers
o_n(x) for all x relatively prime to n be called [L]ambda(n)

Note: L(n), being the largest, IS an order... second every o_x(n)
divides L(n) so L(n) is the LCM (least common multiple) of the o_x(n) as
well as just the largest. If m divides n, L(m) divides L(n). If a and b
are relatively prime L(a,b)=LCM(L(a),L(b)). For a prime p, L(p)=p-1.

Let me use F for greek letter PHI and let F(n)=number of numbers from 1
to n which are relatively prime to n. If m divides n, PHI(m) divides
PHI(n). If a and b are relatively prime F(ab)=F(a)*F(b). F(p)=p-1.
L(n) always divides F(n).]

Note: if n=pq, p and q primes, then the percentage of numbers from 1 to
n which are relatively prime to n is (1-1/p)(1-1/q) (almost all are
relatively prime... but, if n is square free, we need not worry about it
for RSA).

RSA: code secret message x by m=x^e mod n (n square free) and decode
(get x from m) by x=m^(1/e) where 1/e means the multiplicative
reciprocal of e modulo L(n).

NOTE: to do this we need to know L(n)=LCM(p-1,q-1)

Actually RSA takes two large primes, p,q and takes n=pq and takes d as
the multiplicative inverse modulo F(n), but if ed-1 is divisible by F(n)
it is a fortiori divisible by L(n) since L(n) divides F(n).

Example... if p,q are 520 bits in size (n around 1040 bits), then if we
assume that for random primes, p-1 is a random even number... the prob
is 13/520 that all the prime factors of L(p) are smaller than 8096...
same for L(q)... so it is about 0.06% that both L(p) and L(q) have all
its prime factors smaller than 8096. Small but not negligible.

Let me say a number n is "potentially weak" if all the prime factors of
L(n) are small... for moduli of around 1024 bits, I guess about 0.06% of
the RSA moduli are potentially weak... for a modulus of around 256 bits
(p and q of around 128 bits), 13/128=10.1% and I would guess that around
1% of the moduli are potentially weak (here I have taken 8096 as
"small")

Note that if the exponent is not exponentially large, one can fairly
easily calculate m^(3^exponent) the reason being that to calculate
m^anything, one only need do about log(anything) multiplications (eg. to
find 2^16 one does not do 16 multiplications but calculates a=2*2,
b=a*a=2^4, c=b*b=2^8 and d=c*c=2^16)... however this requires knowing
the exponent to which one wishes to raise something... to find m^j for
all j from 1 to 3^exponent will require doing about 3^exponent
multiplications.

The reason I mention the above is the following:

While the result above (for all x, x^j=x mod n if and only if...) is
correct, we have... if x is a particular number relatively prime to n
(almost all the numbers from 1 to n are if p,q are large), then
x^j=x mod n if and only if j=1 mod o_n(x)... further, if e is relatively
prime to L(n) and m=x^e mod n, then o_n(x)=o_n(m).

The problem is not weak moduli... but weak messages... some messages (x)
have order at least 2^L (L(n)=LCM(p-1,q-1) so is at least as large as
the larger... and these are L bits long). If the secret message is of
such order, no one will find its order by taking m=x^e and raising m to
each power from 1 to 2^L until he/she gets one. But SOME messages will
have shorter order... suppose some message has order 3... the
interceptor gets m... calculates m^2,m^3,m^4 etc, mod n... stops if he
does not get a "1 mod n" in 8096 tries... if he DOES, he has
o_n(m)=o_n(x)! Now he takes d the multiplicative reciprocal of e (the
public key) modulo o_n(x) and decrypts the message. If a message has
small order... it is weak... so the question.... what is (among the F(n)
numbers relatively prime to n):

Percentage of numbers x with o_n(x) <= n^(1/k)

as k=2,3,4,5,... etc. (k large means small order)... that is, what
percentage of the messages have order of certain degrees of "smallness"
(small order = crackable). Note that if someone finds a message which
he/she decodes this way, it only provides a factor of L(n)... it does
not factor n nor help for other messages, say of large order.

Suppose you have a potentially weak modulus... suppose you have found
messages with orders a,b,c say... let K=LCM(a,b,c). Let M=n/K... let
the primes in a,b,c be p,q,r,s,... consider the number S:

S=K*p^A*q^B*r^C... where p^A>M, q^B>M, etc.

IF you have found ALL the primes that divide L(n), S IS A MULTIPLE OF
L(n) and choosing d as the inverse of e modulo S will decode! (you did
not factor n, or find L(n) or F(n)... you found a multiple of L(n) by
finding all its prime factors).

Suppose you did NOT have all the prime factors of L(n) in S... consider
a message m=x^e... it may have order q^5*t where t is a different prime
(smaller than 8096, if n is potentially weak)... then raise m to the Sth
power... even if q^5*t>8096 (so you would never find the order by
looking at powers of m since you stop at 8096) the number m'=m^S has
order t, and you will find that order... and another prime factor of
L(n)! (finding some of the prime factors of L(n) permits you to modify
things to have a better chance of finding other prime factors of L(n)...
and once you have all the prime factors, the code is cracked).

So... among the potentially weak moduli, what is the percentage with
sufficiently many messages of low order that one can (without too much luck)
possibly discover all the prime factors of L(n) (by finding messages and
orders... the LCM of the orders being divisible by every prime factor of
L(n))?

So... weak messages are decryptable (what percentage of messages are
weak?). A potentially weak modulus is weak if there are sufficiently
many weak messages for someone to be able to find them (luckily) and use
this to find all the prime factors of L(n).

(finally... the two  questions:)

So... my two questions on the security of RSA/PGP are... how many weak
messages? Does this affect the security of potentially weak moduli (ones
for which L(n) has only small prime factors)?

(as an interceptor... I would simply take m's... raise first to my
current ESTIMATE (initial value of this being two... since p-1 and q-1
both are even) and call that m'. Raise m' to powers from 1
to 8096 modulo n... if I get a one, simply decode and update my ESTIMATE
to the LCM of orders I have so far found... What is the probability I
will ever decode a message... what is the probability I will ever get
all the prime factors of L(n)? Is it negligible?) (note... to find prime
factors, I could create my own m's by simply randomly taking numbers...
is there some way one can (from the bit pattern of n) pick messages of
low order and hence find prime factors of L(n)?)

(are the above concerns valid... or are the probabilities so small that
they can be ignored?)

   ----------------------------------------------------------------------
   ----------------------------------------------------------------------

A horrible thought just arose... consider S given by:

S=2^[log_2(n)]*3^[log_3(n)]...*p^[log_p(n)]*...

For primes p from 2 to the largest prime less than, say, 8192 which do
not divide the open key exponent, "e".

(take n=2*2^1024 and just calculate once! Then divide the result by the
 terms which are primes which divide the open key "e"... it should work!)

(1024 for a 1024 bit modulus in RSA)

[]=INTeger function... log_m(n)=base-m logarithm

Removing the integer parts, is this not just n^(number of primes under
8192)? (note... this is an upper bound... S should be calculated
using the []=INT() functions)

Raising an encoded message m^S takes about log_2(S) mulitiplications...
if n has 1024 bits of length, this is under 8 million multiplications
(log(n^8192)=8192*log(n) and there are fewer than 8 thousand primes up
to 8192)

Now... if n is potentially weak (Lambda(n) has small prime factors
only... say under 8192) is not S a multiple of Lambda(n)? Does not
taking d the inverse of e modulo S (decoding a message m=x^e mod n as
x=m^d mod n) (d<S, so we are talking of under 8 million multiplications)
break the code? (we need e to be relatively prime to S, so S does not
have terms corresponding to primes which divide e... knowing the public
exponent, "e" assures us that these primes are *not* factors of Lambda(n)).

Of course this is only for about .06% of the moduli (of 1024 bits
length) (at a guess)... for moduli which are not potentially weak
does not trying this method of decoding decode all messages except
those with order having a prime factor larger than 8192?
In fact, for moduli which are not potentially weak, what percentage of
the messages does this use of S permit one to decode (depends on the
number of large prime factors of Lambda(n) in some way). Does using this
(as per my prior message) help one in obtaining other prime factors of
Lambda(n) in the case of non potentially weak moduli? If there is only
one prime factor of Lambda(n) which is larger than 8192 (and it is not
repeated) does this help in finding it? (if m is a message, and m^S is
not 1 mod n, one knows that one need now only try powers greater than
8192 for the order of m^S... so try primes up to, say, 100000 for the
other prime factor of lambda(n)) help one to find it (using the
technique I mentioned in the prior message)? If so, what percentage
of moduli are then breakable? (m is almost surely relatively prime
to n, so m^S has an "order"). (note: as most m's=encoded messages are
relatively prime to n... one can do a test... is m^S=1 mod n? If n is a
modulus which is potentially weak, it will be! If not, one can try and
find the order of m^S for another prime factor of lambda(n)).

All sorts of questions...

Does this not imply that moduli for which Lambda(n) has only small prime
factors are subject to being broken? (if a hundred folks are sharing
info on say, overthrowing the government, or the plans for the new (and
*improved*?) model cars and their engineering using PGP with 256 bit
modulus, for which one might guess about 1% of the moduli are
potentially weak... are they not running a terrible risk... one would
only need to try each person's messages to find one which is based on a
potentially weak modulus... just read his/her messages).

Are my calculations in the prior message on the number of potentially
weak moduli valid?

[Note: I forgot my powers of two in my last post and used 8096 for 2^13
 rather than 8192... <sigh>]

Oh well... back to one time pads (at least for me... for stuff I want
to be really private... or plain IDEA instead of an open key system)

Is there anything to be done about the fact that if Lambda(n) has only
small prime factors, n is insecure? One could find all the prime factors
of lambda(n)=LCM(p-1,q-1) but that demands factoring L bit numbers...
and the difficulty of that is what makes PGP/RSA work (at least for some
messages if n is not potentially weak). What makes PGP/RSA work is just
why it cannot be easily tested. One thing one can do... calculate for
n=2*2^1024 say, S'=2^[log_2(n)]*...*p^[log_p(n)]... (all primes from 2
to 8192... do not drop the primes which divide "e" as we are not going
to use this to determine "d")... then take random numbers m from 1 to n
and see for what percentage m^(S'+1)=m mod n (or m^S'=1 mod n... the
difference is for the very few numbers which might have a factor of p or
q)... if it is large... then a large percentage of your messages are
decodeable... if n is potentially weak, it will happen for every
message... if you cannot find any message satisfying the equation, then
most of your messages will have orders which include a prime factor
larger than 8192 (now... what is the largest prime factor that the NSA
might try for?). But... the problem of factoring L bit numbers (which
makes PGP work in the first place) is what prevents one from being sure
that one's messages (moduli) are secure.

--
   John S. McGowan   |    jmcgowan@bigcat.missouri.edu [COIN] (preferred)
                     |    j.mcgowan15@genie.geis.com   [GEnie]
                     |    jomcgow@eis.calstate.edu     [CORE]
   ----------------------------------------------------------------------

