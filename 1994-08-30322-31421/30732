Path: msuinfo!agate!howland.reston.ans.net!news.cac.psu.edu!psuvm!wvnvm!c445585
Nntp-Posting-Host: 128.206.2.2
Date: Thu, 11 Aug 1994 01:49:10 -0400
From: C445585@mizzou1.missouri.edu
Newsgroups: sci.crypt
Subject: a generalkey checksum for encryption programs
Message-ID: <1700FBC5S86.C445585@mizzou1.missouri.edu>
Organization: University of Missouri, Columbia
Lines: 60

Subject:  A general method for checksumming a key.

     Some discussions that took place on sci.crypt a couple of months
back, along with a project of my own, have given me an interest in
finding a fast way to checksum a key that doesn't significantly weaken
the implementation of the cipher.  I've been able to come up with a
few ways, which I wanted to toss out for general discussion and
comment.

     First, let's try to define objectives:

1.   We don't want to leak any more information than one known
     plaintext would about the key.  Ideally, we'd like to leak even
     less information.

2.   We don't want anyone, including the algorithm's implementer, the
     user, or the checksum designer, to be able to choose inputs for
     the ciphers in question.

3.   Consistent with the first two goals, we'd like to minimize space
     and time requirements to checksum the key.

4.   We'd like the checksumming algorithm to work for virtually all
     ciphers.

5.   We'd like a variable length of key checksum, so our users or
     (or checksum implementers) can choose their acceptable
     probability of a mistyped passphrase getting past the checksum to
     destroy data.


     This is what I've come up with:

1.   Let PI[] be the bits in the binary expansion of pi, for as many
     bits as it takes to fill up two of the block length (or
     granularity) of the cipher, or 511 bits, whichever is longer.

2.   Encrypt PI[] under the key K and whatever IV has been selected to
     encrypt the file.

3.   Apply a cryptographic hash to the resulting ciphertext.  Use the
     low n bits from the result as the n-bit key checksum.

4.   Do not resynch ciphers that used an IV, and don't start over with
     the original IV--instead, continue encrypting as though the first
     block had gone away--the receiving end will duplicate the same
     calculation.

     Now, an attacker with the low 32 bits of this hash *can* use this
to apply a keysearch attack, but she has to do two encryptions per
candidate key, plus a hashing of the result.  Even if the hash
function leaks terribly, the best an opponent can do is to invert the
whole thing and get back 32 bits (or two blocks) of the known-plaintext
ciphertext.  In the worst case, an opponent gets less information
about the key than from a single known plaintext block, for greater
cost.

     Any comments?  Am I missing anything?

     --John Kelsey, c445585@mizzou1.missouri.edu

