Newsgroups: sci.crypt
Path: msuinfo!agate!ames!enews.sgi.com!wdl1!mail!are107.lds.loral.com!hahn
From: hahn@newshost.lds.loral.com  (Karl Hahn)
Subject: Rubic Encryption Algorithm (comments please)
Message-ID: <940808074752@are107.lds.loral.com>
Nntp-Software: PC/TCP NNTP
Lines: 138       
Sender: news@lds.loral.com
Reply-To: hahn@lds.loral.com
Organization: Loral Data Systems
Date: Mon, 8 Aug 1994 12:47:52 GMT

This post solicits comments on an algorithm I'll call the Rubic
encryption, due to its abstract resemblence to a Rubic Cube.  It
probably has another name, since I can't be the first to have thought
of it, but I have been unable to find it mentioned anywhere.  So, if
anybody knows a more accepted name for this, please post it.  Any
other comments or observations are welcome as well.

Contents:

1) Thumbnail Sketch of Rubic Encryption
2) Special Case: Rubic Cube Encryption
3) General Rubic Encryption of Order N
4) Practical Limitations and Known Weakness
5) Proposed Modifications to Strengthen Rubic

1) Thumbnail Sketch of Rubic Encryption
Rubic encryption uses an arbitrary subgroup of the symmetric group of
order N in order to encrypt a message composed from an N letter alphabet.
The subgroup is defined by a set of permutations of N letters that
generates the subgroup.

2) Special Case: Rubic Cube Encryption
We've all seen a Rubic Cube puzzle.  The cube has 54 colored stickers.  Now
peel off the colored stickers and replace them with stickers that say S_1
through S_54, S_n being the nth letter of a 54 letter alphabet.  Choose
some state of the cube to be the base state.  Now manipulate the
cube some number of times to arrive at a new state.  Each letter on the
cube will have a new position (though for some, the new position may be
the same as in the base state).  If we allow this to be the kth state
(and we will see shortly how states are indexed), then to convert the kth
plaintext letter M_k to ciphertext letter C_k, simply observe where M_k
appears on the kth state of the cube and set C_k to the letter that is
in that position when the cube is in its base state.

There are 9 operations that can be done on a Rubic Cube, which, if iterated
in the correct order, eventually arrive at any possible state of the
cube.  These are (and there are plenty of other such sets):  Rotate 90
degrees clockwise layer top, middle, or bottom; rotate 90 degrees toward
you layer left, center, or right; and rotate 90 degrees clockwise layer
front, inner, or back.  

We shall assume we have a key stream generator that generates numbers
1 through 9 in some cryptographically secure way.  Let X_k be the kth
such number.  Whatever the kth state of the cube is, we generate
the k+1st state by applying operation X_k to the kth state.

To encrypt, begin with the cube in some initial state (not necessarily
the base state).  Encrypt M_1 using that state.  Then move on to the
next state and encrypt M_2 using that, etc.

To decrypt, note that each of the 9 operations described above has a
trivially derived inverse.  That is, if an operation says rotate some
layer degrees clockwise, the inverse is rotating that same layer 90 degrees
counterclocwise.  The initial encryption state also has an inverse,
which, though not as easy to describe, nevertheless exists.  Begin in
the inverse initial state, decrypt C_1 with that, and then advance to
each new state by applying the inverse of X_k.

3) General Rubic Encryption of Order N

This is the generalization of the algorithm just described.  Let the
alphabet be N letters long.  Choose an initial permuation of N letters,
P_1.  Also choose M generator permutations, Q_1 through Q_M.  Both
P_1 and Q_1..M can be chosen using symbols from a cryptographically
secure key stream.  None of these permutations need be revealed to
anybody.

Encryption is done by applying P_k to M_k.  P_k+1 is derived by
indexing Q using X_k, and summing that to P_k in the usual way
of forming composite permuations.

Decryption is done by first generating the inverses of P_1
and of Q_1..M.  Apply inverse P_k to C_k to get M_k.  To get inverse
P_k+1 apply the appropriate inverse Q to inverse P_k (since permutation
composition is noncommutative, it is necessary to sum inverse Q
and inverse P_k in the opposite order as was done to Q and P_k during
encryption).

Clearly, Q_1..M generates some subgroup of the symmetric group of
order N, and P_1 defines some coset of that subgroup.  A ciphertext
only attack would have to guess both the subgroup generators and the
coset leader.

If X_k has a period of r, and the subgroup has a size of s, P_k
will very likely have a period of LCM(r,s).

4) Practical Limitations and Known Weakness

The practical limitation is alphabet size.  An alphbet size of 2^32,
for example, is clearly impractical because, storing Q_1..M, would
require M * 32 * 2^32 bits.  There is also the impracticality of
initializing that many bits.  Hence, Rubic encryption is limited
to small alphabets.  For example, I have coded this algorithm using
an alphabet size of 256 and M=256.

Since the alphabet must be small, Rubic is vulnerable to plaintext
attack.  If an attacker can acquire N-1 plaintext/ciphertext with
a different letter each in position k, the attacker would be able
to deduce P_k.  If the attacker can chose the plaintext/ciphertext
pairs, the attacker can deduce all P_k's in just N-1 rounds.  Each
time an attacker can deduce a P_k and P_k+1, he can derive an element
of Q.

Even with partial knowledge, the attacker could deduce part of the
Q array, and this would go a long way toward guessing P_k+1 if
P_k is known.

5) Proposed Modifications to Strengthen Rubic

A simple modification is to use a timecode as well as the user's
pass-phrase to initialize the key generator.  This will result in
a different P_1 and Q_1..M in each encryption.  Now an attacker has
the opportunity only to arrive at one out of N elements of
P_k, no matter how many plaintext/ciphertext pairs he can obtain
(this assumes again that the key stream used to generate P_1 and
Q_1..M is a secure function of both the timecode and the user's
pass-phrase).  The timecode would be appended to the ciphertext
before transmission, to be recovered by the decryptor.

Now take, as an example, Rubic with both N and M equal 256.  One can
derive a block cipher by doing the following (or something like it):
a) Divide the plaintext into 32 byte (256 bit) blocks.  b) Apply
Rubic to the first 16 bytes.  c) Apply P_k to shuffle the bits in
the block.  d) Apply Rubic to the remaining 16 bytes of the block.

Decrypting this is complicated by the fact that the decryptor must
apply P_k out of order, since the 2nd 16 bytes of each block must
be decrypted before the 1st 16 bytes.

--
|         (V)              |  "Tiger gotta hunt.  Bird gotta fly.
|   (^    (`>              |   Man gotta sit and wonder why, why, why.
|  ((\\__/ )               |   Tiger gotta sleep.  Bird gotta land.
|  (\\<   )   der Nethahn  |   Man gotta tell himself he understand."
|    \<  )                 |  
|     ( /                  |                Kurt Vonnegut Jr.
|      |                   |  
|      ^           hahn@lds.loral.com

