Path: msuinfo!uwm.edu!psuvax1!news.ecn.bgu.edu!usenet.ins.cwru.edu!eff!news.umbc.edu!olson
From: olson@umbc.edu (Bryan G. Olson; CMSC (G))
Newsgroups: sci.crypt
Subject: Re: Key safeguarding/anti-duress measures in cryptosystems (Long)
Date: 20 Aug 1994 20:16:14 GMT
Organization: University of Maryland, Baltimore County
Lines: 145
Message-ID: <335oae$mdj@news.umbc.edu>
References: <317621$gkt@news.umbc.edu> <17002121B3S86.C445585@mizzou1.missouri.edu> <3221em$kdq@ccu2.auckland.ac.nz> <323dks$g44@news.umbc.edu> <32upra$i5v@ccu2.auckland.ac.nz>
NNTP-Posting-Host: umbc7.umbc.edu
X-Newsreader: TIN [version 1.2 PL2]

Peter Gutmann (pgut1@cs.aukuni.ac.nz) wrote:

: Bryan Olson <olson@umbc.edu> writes:

[Peter]
: There are probably two main types of
: attacker you need to defend against:
:  
: 1. A civilized adversary with limited means.
: 2. An adversary who will use any means possible to get to the data.
:  
: My scheme is best for type 1, your scheme will withstand type 2.  The main
: concern with type 1 is that this covers the kind of attack "the good guys" will
: use, whereas "the bad guys" won't have any qualms about the second type of
: attack.  As you say:
:  
[Bryan]
: >I did not envision my formulation of duress codes solely, or even primarily to
: >help criminals conceal evidence, although it would work well for that.
:  

Into which category would you put an employer who will fire you unless
you show what's on the disk ?  Having a system which lets you argue
that you made the contents unavailable even to yourself is likely to
get you fired, but "any means possible" goes beyond what most bosses
are willing to dish out.

: which is a major concern, and the main reason why my current efforts for SFS
: only cover simple key distribution to allow later recovery if the keyholder
: dies/is fired/forgets the key.

I certainly think key escrow is important to an encrypted file store,
for reasons other than duress resistance.  Our suggestions are not
mutually exclusive, and given that there are two ways to get the
needed key, from the user and from the escrow agents, perhaps both
need some duress resistance.  (My system alone would allow one to
escrow the key to any level, thus trading off deniability for
recoverability.)

: This sounds like something I looked at a while back, motivated by a either a
: sci.crypt posting or some email I received from someone.

I probably saw some of the same posts.  Several people suggested ways
to hide encrypted data in unused pages.  The authors were assuming the
obscurity of the system: an adversary who knew how the system works
could determine that there is hidden data.

[Peter quotes DOS data-hiding scheme]
[...]
:   Hidden data is stored in a meta-file which contains as many free blocks as
:   you need
[...]
:   You could keep the block map truly empty by taking advantage of the fact that
:   DOS disks contain two FAT's, of which only one is ever really used.  You
:   therefore mirror the first FAT in software to make DOS think there are still
:   two FAT's there, and use the second FAT to store random data which may or may
:   not contain the "hidden" block map.
:  

: This solves the problem nicely, but requires translating logical->physical
: values whenever you write new data to disk

It has other problems.  The attacker can simply read both FATs.  All
this code which hides data is a dead giveaway that there is hidden
data.

: The other problem is that you're going to destroy hidden data if you write to
: the disk in "unsafe" mode, and you always need *some* way to get to the data
: which will serve as a beacon for an attacker looking for evidence of concealed
: information.
:  

My suggestion requires the user always to open the disk with the
highest level pass-phrase for normal operation.  The lower levels are
really for duress use only.  I believe this is normal for most forms
of duress codes.  (The "spread spectrum file system" could actually
get around this and make all views under different keys independent,
but it has other problems.)

There is no beacon for an attacker, since the system information which
reveals the existence of higher level files is all encrypted under the
higher level keys, and the space in which it is stored appears (in the
lower levels) to be empty and free for use.  Below is a note on how I
suggest it could be placed.

: It would appear that the only truly feasible anti-duress measure is to hide the
: data in such a way that even an opponent with unlimited means can't find it. 

I have to assume that the opponent can not distinguish random noise
from ciphertext.  That's the only limitation.

: The two (or multilevel) scheme which hides data in "empty" disk sectors almost
: covers this (you still need *some* way to get to it, and the presence of the
: access information can't be hidden).

Yes it can!  Each level has its own allocation table which is
encrypted under the level's key, and these are not at pre-set
addresses.

So how do we decide where to put the allocation table, and how do we
find it later ?  (Remember the requirement that the distribution of
pages be independent of the existence of higher levels.)  To decide
where to put the table, we hash the pass-phrase to get a sequence of,
say, 40 page addresses.  We then check which of these are unused, and
randomly select one to start the allocation table.  When a key is
entered, the system computes the same hash sequence and uses trial
decryption to find which of the 40 has the root of the allocation
table.

Let me say again that I don't think a two level scheme works, for the
simple reason that no one would use one without actually using both
levels.  Thus the existence of the higher level is exposed.  A system
with an arbitrary number of levels gets around this.

: However the data-hiding requires a custom
: filesystem 

Yup.

: Assuming the coding isn't a problem, is there any practical solution which
: doesn't reveal any information (or have I just misunderstood your posting)?
:  

Assuming coding isn't a problem (we can write a custom file-system),
yes.  Unfortunately I don't even have a computer of my own, so coding
is a problem.  I don't want to claim I've accomplished anything I have
not, so let me be clear that my system exists only in theory (while
Peter has actually given us SFS).


In case you didn't see it, in another thread I suggested a very simple
modification to a system like SFS which would allow a small measure of
duress resistance.  When you do the check for correct key entry, do it
on the combination of pass-phrase and disk-key.  Don't leave any way
for an adversary to tell if it is the pass-phrase or the disk-key
which is incorrect.  That way no one can tell if a user over-wrote the
disk key, or is lying about the pass-phrase.

Of course that also means that the user can not prove he's telling the
truth about the pass-phrase after over-writing the disk-key.
Provability when truthful or plausibility when lying - it's one or the
other.

--Bryan

