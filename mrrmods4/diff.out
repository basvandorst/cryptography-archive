Only in \winvn: $$MSVCIN.TXT
Only in \winvn: ANNOUNCE.TXT
Only in \winvn: CHANGELO
Only in \winvn: CLRFILE.CVW
Only in \winvn: CURRENT.STS
Only in \winvn: DISH.ICO
Only in \winvn: DIST.BAT
Only in \winvn: DOZIP.BAT
Only in \winvn: ERRNO.RC
Only in \winvn: HEADARRY.C
Only in \winvn: HEADARRY.OBJ
Only in \winvn: HEADARRY.SBR
Only in \winvn: INCVER.AWK
Only in \winvn: INI-INFO.TXT
Only in \winvn: INI_NEWS.C
Only in \winvn: INI_NEWS.OBJ
Only in \winvn: INI_NEWS.SBR
Only in \winvn: INSTALL.TXT
diff -wBbc .\J \winvn\J
*** .\J	Tue Jan 11 22:42:58 1994
--- \winvn\J	Tue Jan 11 22:18:32 1994
***************
*** 0 ****
--- 1,162 ----
+   a-----   1994 Jan 11   22:18        0  j
+   a-----   1994 Jan 11   22:16        0  winvn835.zip
+   a-----   1994 Jan 11   22:11   215660  winvnmrr.zip
+   a-----   1994 Jan 11   22:08      541  winvn.wsp
+   a-----   1994 Jan 11   21:47      421  winvn.vcw
+   a-----   1994 Jan 11   21:46        0  wvcncm.sbr
+   a-----   1994 Jan 11   21:46        0  wvart.sbr
+   a-----   1994 Jan 11   21:46        0  wvdebugc.sbr
+   a-----   1994 Jan 11   21:46        0  winvn.sbr
+   a-----   1994 Jan 11   21:46        0  wvheader.sbr
+   a-----   1994 Jan 11   21:46        0  wvlist.sbr
+   a-----   1994 Jan 11   21:46        0  shellsor.sbr
+   a-----   1994 Jan 11   21:46        0  ini_news.sbr
+   a-----   1994 Jan 11   21:46        0  wvmail.sbr
+   a-----   1994 Jan 11   21:46        0  headarry.sbr
+   a-----   1994 Jan 11   21:46        0  wvmapi.sbr
+   a-----   1994 Jan 11   21:46        0  wvusenet.sbr
+   a-----   1994 Jan 11   21:46        0  wvpost.sbr
+   a-----   1994 Jan 11   21:46        0  wvfile.sbr
+   a-----   1994 Jan 11   21:46        0  wvprint.sbr
+   a-----   1994 Jan 11   21:46        0  wvauth.sbr
+   a-----   1994 Jan 11   21:46   297880  winvn.bsc
+   a-----   1994 Jan 11   21:46        0  wvsckstd.sbr
+   a-----   1994 Jan 11   21:46        0  wvblock.sbr
+   a-----   1994 Jan 11   21:46        0  wvcrypt.sbr
+   a-----   1994 Jan 11   21:46        0  wvscreen.sbr
+   a-----   1994 Jan 11   21:46        0  wvgroup.sbr
+   a-----   1994 Jan 11   21:46        0  wvutil.sbr
+   a-----   1994 Jan 11   21:46   307672  winvn.exe
+   a-----   1994 Jan 11   21:45    19990  winvn.obj
+   a-----   1994 Jan 11   21:45    14878  winvn.pdb
+   a-----   1994 Jan 11   21:45    27816  winvn.c
+   a-----   1994 Jan 11   21:45     1505  winvnc.etr
+   a-----   1994 Jan 11    0:06    29321  winvnc.dbg
+   a-----   1994 Jan 10   23:56     7343  winvn.mak
+   a-----   1994 Jan 10   23:55     3233  wvdebugc.obj
+   a-----   1994 Jan 10   23:53     3415  wvdebugc.c
+   a-----   1994 Jan 10   23:46        0  $$msvcin.txt
+   a-----   1994 Jan 10   23:37    12752  winvn.res
+   a-----   1994 Jan 10   23:22      742  winvn.ini
+   a-----   1994 Jan 10   23:22   141623  winvnexe.zip
+   a-----   1994 Jan 10   23:21       87  dozip.bat
+   a-----   1994 Jan 10   23:21   207963  winvn0.zip
+   a-----   1994 Jan 10   23:12     4903  wvcrypt.obj
+   a-----   1994 Jan 10   23:11    32121  wvutil.obj
+   a-----   1994 Jan 10   23:11    28082  wvusenet.obj
+   a-----   1994 Jan 10   23:11     9990  wvscreen.obj
+   a-----   1994 Jan 10   23:11    13762  wvsckstd.obj
+   a-----   1994 Jan 10   23:11    12029  wvprint.obj
+   a-----   1994 Jan 10   23:11     4769  wvpost.obj
+   a-----   1994 Jan 10   23:11     6552  wvmapi.obj
+   a-----   1994 Jan 10   23:11     9151  wvmail.obj
+   a-----   1994 Jan 10   23:11    10154  wvlist.obj
+   a-----   1994 Jan 10   23:11    21994  wvheader.obj
+   a-----   1994 Jan 10   23:11    32215  wvgroup.obj
+   a-----   1994 Jan 10   23:10     5187  wvfile.obj
+   a-----   1994 Jan 10   23:10    15578  wvcncm.obj
+   a-----   1994 Jan 10   23:10    17316  wvblock.obj
+   a-----   1994 Jan 10   23:10    12033  wvart.obj
+   a-----   1994 Jan 10   23:10    15227  headarry.obj
+   a-----   1994 Jan 10   23:10    12752  winvnold.res
+   a-----   1994 Jan 10   23:10      973  winvnpwk.def
+   a-----   1994 Jan 10   23:09      825  winvnlwp.def
+   a-----   1994 Jan 10   23:09     1037  winvn.def
+   a-----   1994 Jan 10   23:09     1038  winvnstd.def
+   a-----   1994 Jan 10   23:08    17610  winvn.h
+   a-----   1994 Jan 10   23:06     1615  wvauth.obj
+   a-----   1994 Jan 10   23:06     1123  shellsor.obj
+   a-----   1994 Jan 10   23:06     7911  ini_news.obj
+   a-----   1994 Jan 10   23:01    23013  wvglob.h
+   a-----   1994 Jan 10   22:09    22868  winvn.rc
+   a-----   1994 Jan 10   22:09    35324  winvn.aps
+   a-----   1994 Jan 10   22:09      766  wvdebugc.ico
+   a-----   1994 Jan 10   22:08      529  resource.h
+   a-----   1994 Jan 10   21:09    18326  wvlist.c
+   a-----   1994 Jan 10   20:55   107493  newsrc
+   a-----   1994 Jan 10   20:37    48049  wvblock.c
+   a-----   1994 Jan  9   22:36    10088  wvfile.c
+   a-----   1994 Jan  9   22:23    46970  wvusenet.c
+   a-----   1994 Jan  9   21:45    19676  wvscreen.c
+   a-----   1994 Jan  9   20:20    24646  wvcncm.c
+   a-----   1994 Jan  9   17:57   107465  newsrc.tst
+   a-----   1994 Jan  9   17:57   107465  newsrc.old
+   a-----   1994 Jan  9   17:27    48281  wvutil.c
+   a-----   1994 Jan  9   17:04     4832  jj
+   a-----   1994 Jan  9   16:17    99886  winvn.map
+   a-----   1994 Jan  9   15:19      731  winvnini.tst
+   a-----   1994 Jan  6   17:19      846  linux
+   a-----   1994 Jan  5   22:59     3631  wvdlg.h
+   a-----   1994 Jan  5   17:37     1572  version.c
+   a-----   1994 Jan  5   17:37       38  version.h
+   a-----   1994 Jan  5   17:35      311  changelo
+   a-----   1993 Dec 27   17:28    12686  msvc.pdb
+   a-----   1993 Dec 27   15:25      431  msvc.bnd
+   a----r   1993 Dec 27   15:16    53422  wvgroup.c
+   a----r   1993 Dec 27   15:14    10345  wvcrypt.c
+   a----r   1993 Dec 27   15:04    19965  wvsckpwk.c
+   a-----   1993 Dec  8   17:23      529  winvnpwk.wsp
+   a-----   1993 Dec  8   17:23      235  winvnpwk.vcw
+   a-----   1993 Dec  8   15:39      493  dist.bat
+   a-----   1993 Dec  7   21:40     6376  makefile.std
+   a----r   1993 Dec  7   21:37    11489  winvn.dlg
+   a-----   1993 Dec  7   21:36     5972  winvnrc.org
+   a-----   1993 Dec  7   20:56     6360  makefile.pwk
+   a-----   1993 Dec  7   20:43     1815  makefile.nt
+   a----r   1993 Dec  7   20:30     4118  wvmapi.h
+   a----r   1993 Dec  7   20:30    22920  wvprint.c
+   a----r   1993 Dec  7   20:30     8398  wvmapi.c
+   a----r   1993 Dec  7   20:30     3602  shellsor.c
+   a----r   1993 Dec  7   20:30     2192  wvauth.c
+   a----r   1993 Dec  7   20:30    11769  wvmail.c
+   a----r   1993 Dec  7   20:30    17033  wvart.c
+   a----r   1993 Dec  7   20:30    14281  ini_news.c
+   a----r   1993 Dec  7   20:30    15976  wvsckstd.c
+   a----r   1993 Dec  7   20:30    34611  wvheader.c
+   a----r   1993 Dec  7   20:30    12297  headarry.c
+   a----r   1993 Dec  7   20:30     6154  wvpost.c
+   a-----   1993 Dec  7   19:51      155  incver.awk
+   a-----   1993 Dec  7   19:44     6408  winvnpwk.mak
+   a-----   1993 Dec  7   18:58       54  version.awk
+   a-----   1993 Oct 12   14:03    11305  winvn.prj
+   a-----   1993 Oct 12   13:29    19296  wvsckpwk.d
+   a-----   1993 Aug 17   17:18     5685  makefile.lwp
+   a----r   1993 Aug  5   16:08      344  wvprint.h
+   a-----   1993 Jul 11    1:30    46357  winvn.hlp
+   a-----   1993 Jul 11    1:29     4760  wvhlmain.rtf
+   a-----   1993 Jul 11    1:28    10356  wvhldef1.rtf
+   a-----   1993 Jul 11    1:01     6714  wvhlpro2.rtf
+   a-----   1993 Jul 11    0:44    11842  wvhlmwin.rtf
+   a-----   1993 Jul 10   23:58     6252  wvhluse.rtf
+   a-----   1993 Jul  8   14:48     3626  errno.rc
+   a-----   1993 Jun 14   15:46      203  clrfile.cvw
+   a-----   1993 Jun 14   15:46      704  current.sts
+   a-----   1993 Jun 14    9:57      621  todo.txt
+   a-----   1993 Jun 10   23:33     3288  readme.txt
+   a-----   1993 Jun 10   23:21     2947  announce.txt
+   a-----   1993 Mar 30   12:13    15019  wvdoc.txt
+   a----r   1993 Mar 18   16:52     7145  mapi.h
+   a-----   1993 Feb 25   14:24     1838  install.txt
+   a-----   1993 Feb 25   14:01       23  pathwork.bat
+   a-----   1993 Feb 25   14:01       23  winsock.bat
+   a-----   1993 Feb 25   13:43     6776  tags
+   a-----   1993 Feb 17   10:46     2984  ini-info.txt
+   a-----   1993 Feb 16   17:11    10010  makefile.old
+   a-----   1993 Feb  3   13:42     2831  todo.old
+   a-----   1992 Nov 16   15:23      766  dish.ico
+   a-----   1992 Nov 16   14:42      766  winvn.ico
+   a-----   1992 Nov 16   14:19      766  wvpost.ico
+   a-----   1992 Nov 16   14:10      766  wvgroup.ico
+   a-----   1992 Nov 16   13:53      766  wvart.ico
+   a----r   1992 Oct 26   10:47      203  winundoc.h
+   a-----   1991 Jul  1   13:37    26658  wvcontes.wp5
+   a-----   1991 Jun 30   23:01     7557  wvstatem.wp5
+   a-----   1991 Jun 30   21:33     7207  wvhlproc.rtf
+   a-----   1991 Jun 30   21:21      189  winvn.hpj
+   a-----   1991 Jun 30   20:43     4173  wvhlgen.rtf
+   a-----   1991 Jun 30    1:00     5526  wvhlawin.rtf
+   a-----   1991 Jun 30    0:50     5270  wvhlpwin.rtf
+   a-----   1991 Jun 29   23:06     4616  wvhlgwin.rtf
+   a-----   1990 Nov 11   21:27    16128  winvn.wri
+   a-----   1990 Nov  5    5:35     4372  wvlist.doc
+   a-----   1989 Sep 30   23:37     1038  wv.ico
Only in \winvn: JJ
Only in \winvn: LINUX
Only in \winvn: MAKEFILE.LWP
Only in \winvn: MAKEFILE.NT
Only in \winvn: MAKEFILE.OLD
Only in \winvn: MAKEFILE.PWK
Only in \winvn: MAKEFILE.STD
Only in \winvn: MAPI.H
Only in \winvn: MRRFILES.MOD
Only in \winvn: MSVC.BND
Only in \winvn: MSVC.PDB
Only in \winvn: NEWSRC
Only in \winvn: NEWSRC.OLD
Only in \winvn: NEWSRC.TST
Only in \winvn: PATHWORK.BAT
Only in \winvn: README.TXT
Only in \winvn: RESOURCE.H
Only in \winvn: SHELLSOR.C
Only in \winvn: SHELLSOR.OBJ
Only in \winvn: SHELLSOR.SBR
Only in \winvn: TAGS
Only in \winvn: TODO.OLD
Only in \winvn: TODO.TXT
Only in \winvn: VERSION.AWK
Only in \winvn: VERSION.C
Only in \winvn: VERSION.H
Only in \winvn: WINSOCK.BAT
Only in \winvn: WINUNDOC.H
Only in \winvn: WINVN.APS
Only in \winvn: WINVN.BSC
diff -wBbc .\WINVN.C \winvn\WINVN.C
*** .\WINVN.C	Tue Dec 07 20:30:08 1993
--- \winvn\WINVN.C	Tue Jan 11 21:45:28 1994
***************
*** 291,296 ****
--- 291,299 ----
    GetPrivateProfileString (szAppName, "MailLogFile" , "MAIL.LOG" , MailLogFile, MAXFILENAME, szAppProFile);
    PostLog = GetPrivateProfileInt (szAppName, "PostLog", 0 /* off */, szAppProFile);
    GetPrivateProfileString (szAppName, "PostLogFile" , "POST.LOG" , PostLogFile, MAXFILENAME, szAppProFile);
+   ShowUnsubscribed = GetPrivateProfileInt (szAppName,"ShowUnsubscribed",TRUE,szAppProFile); 
+   ShowReadArticles = GetPrivateProfileInt (szAppName,"ShowReadArticles",TRUE,szAppProFile);
+   DebugComm = GetPrivateProfileInt (szAppName, "DebugComm", FALSE, szAppProFile);
  
    /* internationalise winvn */
  
Only in \winvn: WINVN.DEF
Only in \winvn: WINVN.DLG
Only in \winvn: WINVN.EXE
diff -wBbc .\WINVN.H \winvn\WINVN.H
*** .\WINVN.H	Tue Dec 07 20:30:18 1993
--- \winvn\WINVN.H	Mon Jan 10 23:08:34 1994
***************
*** 110,139 ****
  BOOL FAR PASCAL WinVnThresholdDlg(HWND hDlg,unsigned iMessage,WORD wParam,LONG lParam);
  BOOL FAR PASCAL WinVnLogOptDlg(HWND hDlg,unsigned iMessage,WORD wParam,LONG lParam);
  
! BOOL WritePrivateProfileInt(char far *lpAppName,char far *lpKeyName,int intval, char far *lpProFile);
! 
! void ForAllLines(TypDoc *Doc,
!    void lpfnFunc(TypDoc *Doc, TypBlock far **BlockPtr, TypLine far **LinePtr, int wFlag, int wValue),
!    int wFlag, int wValue);
  void SetLineFlag(TypDoc *Doc, TypBlock far **BlockPtr, TypLine far **LinePtr, int wFlag, int wValue);
  void GroupAction(TypDoc *Doc, TypBlock far **BlockPtr, TypLine far **LinePtr, int wFlag, int wValue);
  
  
! VOID CheckView(HWND);
  long FileLength(HANDLE);
  BOOL MoreInit(void);
  BOOL MainLoopPass(void);
- void MakeHelpPathName(char * szFileName, int maxchars);
  
  void DoCommInput(void);
  int WinVnDoComm(char *szComm);
  char *CommStrtoID(char *CommStr,int *Port, int *Parity,char *szSpeed);
- int  ReadNewsrc(void);
- void WriteNewsrc(void);
- void SetNetDocTitle(void);
  void MoveCursor();
- BOOL CursorToTextLine(int X,int Y,TypDoc *DocPtr,TypBlock far **BlockPtr,
-   TypLine far **LinePtr);
  void ViewArticle(TypDoc *Doc, long artindex ,BOOL Reuse, BOOL showArt);
  void UnlinkArtsInGroup(TypDoc *GroupDoc);
  void UpdateSeenArts(TypDoc *Doc);
--- 110,142 ----
  BOOL FAR PASCAL WinVnThresholdDlg(HWND hDlg,unsigned iMessage,WORD wParam,LONG lParam);
  BOOL FAR PASCAL WinVnLogOptDlg(HWND hDlg,unsigned iMessage,WORD wParam,LONG lParam);
  
! /* in file WVUSENET.C */
! BOOL FAR PASCAL About(HWND, unsigned, WORD, LONG);
! VOID CheckView(HWND);
! BOOL CrackGroupLine(char *buf,TypLine *lineptr);
! BOOL CursorToTextLine(int X,int Y,TypDoc *DocPtr,TypBlock far **BlockPtr,
!   TypLine far **LinePtr);
! int  ReadNewsrc(void);
! void WriteNewsrc(void);
! void SetNetDocTitle(void);
  void SetLineFlag(TypDoc *Doc, TypBlock far **BlockPtr, TypLine far **LinePtr, int wFlag, int wValue);
  void GroupAction(TypDoc *Doc, TypBlock far **BlockPtr, TypLine far **LinePtr, int wFlag, int wValue);
+ void MakeHelpPathName(char * szFileName, int maxchars);
+ int cursor_to_char_number (int X, int Y,TypDoc *DocPtr,TypBlock far **BlockPtr,TypLine far **LinePtr);
+ void SetGroupActiveLines(void);
  
+ BOOL WritePrivateProfileInt(char far *lpAppName,char far *lpKeyName,int intval, char far *lpProFile);
  
! 
! 
  long FileLength(HANDLE);
  BOOL MoreInit(void);
  BOOL MainLoopPass(void);
  
  void DoCommInput(void);
  int WinVnDoComm(char *szComm);
  char *CommStrtoID(char *CommStr,int *Port, int *Parity,char *szSpeed);
  void MoveCursor();
  void ViewArticle(TypDoc *Doc, long artindex ,BOOL Reuse, BOOL showArt);
  void UnlinkArtsInGroup(TypDoc *GroupDoc);
  void UpdateSeenArts(TypDoc *Doc);
***************
*** 140,145 ****
--- 143,149 ----
  
  int CommIDtoStr(int Port, int Parity,char *szSpeed,char *CommStr);
  
+ /* in file WVBLOCK.C */
  int NewBlock(TypBlock far *CurBlockPtr, TypBlock far **NewBlockPtr);
  void SetupEmptyBlock(TypBlock far *BlockPtr,HANDLE hCur, HANDLE hPrev,
    HANDLE hNext,TypDoc *DocPtr);
***************
*** 151,157 ****
  int PrevLine(TypBlock far **BlockPtr,TypLine far **LinePtr);
  int FindString(BOOL StartAtTop);
  int NumBlocksInDoc(TypDoc *Doc);
! 
  BOOL FindLineOrd(TypDoc *Doc,unsigned int LineOrd,TypBlock far **BlockPtr,TypLine  far **LinePtr);
  int SearchLine(char *Line,int LineLen,char *Target,int TargLen);
  BOOL DoFind(BOOL StartAtTop);
--- 155,167 ----
  int PrevLine(TypBlock far **BlockPtr,TypLine far **LinePtr);
  int FindString(BOOL StartAtTop);
  int NumBlocksInDoc(TypDoc *Doc);
! void ForAllLines(TypDoc *Doc,
!    void lpfnFunc(TypDoc *Doc, TypBlock far **BlockPtr, TypLine far **LinePtr, int wFlag, int wValue),
!    int wFlag, int wValue);
! void ForAllBlocks (TypDoc *Doc, 
!    void lpfnFunc(TypDoc *Doc, TypBlock far ** BlockPtr, int wFlag, int wValue),
!    int wFlag, int wValue);
! void SetForBlock(TypDoc *Doc, TypBlock far ** BlockPtr, int wFlag, int wValue);
  BOOL FindLineOrd(TypDoc *Doc,unsigned int LineOrd,TypBlock far **BlockPtr,TypLine  far **LinePtr);
  int SearchLine(char *Line,int LineLen,char *Target,int TargLen);
  BOOL DoFind(BOOL StartAtTop);
***************
*** 170,177 ****
  int mylstrncmp(char far *ptr1,char far *ptr2,int len);
  char far *mylstrncpy(char far *ptr1,char far *ptr2, int len);
  
! BOOL CrackGroupLine(char *buf,TypLine *lineptr);
! 
  void ScreenDown(int nLines,int LinesOnScreen,TypBlock far **BlockPtr,
   TypLine far **LinePtr,int *LinesAdvanced);
  void ScreenUp(int nLines,TypBlock far **BlockPtr,TypLine far **LinePtr,
--- 180,186 ----
  int mylstrncmp(char far *ptr1,char far *ptr2,int len);
  char far *mylstrncpy(char far *ptr1,char far *ptr2, int len);
  
! /* in file WVSCREEN.C */
  void ScreenDown(int nLines,int LinesOnScreen,TypBlock far **BlockPtr,
   TypLine far **LinePtr,int *LinesAdvanced);
  void ScreenUp(int nLines,TypBlock far **BlockPtr,TypLine far **LinePtr,
***************
*** 182,187 ****
--- 191,197 ----
  void NextWindow(TypDoc *Doc);
  void AdjustTopSc(TypBlock far *BlockPtr,TypLine far *LinePtr);
  void ScreenToTop(TypDoc *Doc);
+ BOOL AdvanceToActive(TypBlock far **BlockPtr,TypLine far **LinePtr);
  
  HANDLE MRROpenFile(char *FileName,int Mode,TypMRRFile **MRRFile);
  void MRRCloseFile(TypMRRFile *MRRFile);
***************
*** 203,209 ****
  
  /* in file wvart.c */
  long find_article_by_subject (TypHeader huge *headers,long artindex,long num_headers);
- int cursor_to_char_number (int X, int Y,TypDoc *DocPtr,TypBlock far **BlockPtr,TypLine far **LinePtr);
  void view_article_by_message_id (TypDoc *Doc, char far *msg_id, long artindex);
  void SetArticleRot13Mode(HANDLE hWnd,BOOL RotMode) ;
  BOOL GetArticleRot13Mode(HANDLE hWnd);
--- 213,218 ----
***************
*** 237,243 ****
  void  prepareEditMenu(HWND parWnd,HWND hWndEdit);
  int DoEditCommands(HWND hWndEdit,WPARAM wParam,LPARAM lParam);
  void DoEditClose(HWND hWnd,int dirty) ;
! void WriteEditLog(HWND hWnd, char *fName , char *mBuf);
  
  /* In file WVPOST.C */
  long FAR PASCAL WinVnPostWndProc(HWND, UINT, WPARAM, LPARAM);
--- 246,252 ----
  void  prepareEditMenu(HWND parWnd,HWND hWndEdit);
  int DoEditCommands(HWND hWndEdit,WPARAM wParam,LPARAM lParam);
  void DoEditClose(HWND hWnd,int dirty) ;
! BOOL WriteEditLog(HWND hWnd, char *fName , char *mBuf);
  
  /* In file WVPOST.C */
  long FAR PASCAL WinVnPostWndProc(HWND, UINT, WPARAM, LPARAM);
***************
*** 317,322 ****
--- 326,334 ----
  void MRREncrypt(unsigned char *plainText,int len,char *cipherText);
  int MRRDecrypt(char *cipherText,unsigned char *plainText, int plainMax);      
  
+ /* In file WVDEBUGC.C */
+ long FAR PASCAL 
+ WinVnDebugCommWndProc (HWND hWnd,unsigned message,WPARAM wParam,LPARAM lParam);
  
  #if 0
  /* In file FASTQSRT.C */
Only in \winvn: WINVN.HLP
Only in \winvn: WINVN.HPJ
Only in \winvn: WINVN.ICO
Only in \winvn: WINVN.INI
Only in \winvn: WINVN.MAK
Only in \winvn: WINVN.MAP
Only in \winvn: WINVN.OBJ
Only in \winvn: WINVN.PDB
Only in \winvn: WINVN.PRJ
Only in \winvn: WINVN.RC
Only in \winvn: WINVN.RES
Only in \winvn: WINVN.SBR
Only in \winvn: WINVN.VCW
Only in \winvn: WINVN.WRI
Only in \winvn: WINVN.WSP
Only in \winvn: WINVN0.ZIP
Only in \winvn: WINVN835.ZIP
Only in \winvn: WINVNC.DBG
Only in \winvn: WINVNC.ETR
Only in \winvn: WINVNEXE.ZIP
Only in \winvn: WINVNINI.TST
Only in \winvn: WINVNLWP.DEF
Only in \winvn: WINVNMRR.ZIP
Only in \winvn: WINVNOLD.RES
Only in \winvn: WINVNPWK.DEF
Only in \winvn: WINVNPWK.MAK
Only in \winvn: WINVNPWK.VCW
Only in \winvn: WINVNPWK.WSP
Only in \winvn: WINVNRC.ORG
Only in \winvn: WINVNSTD.DEF
Only in \winvn: WV.ICO
Only in \winvn: WVART.C
Only in \winvn: WVART.ICO
Only in \winvn: WVART.OBJ
Only in \winvn: WVART.SBR
Only in \winvn: WVAUTH.C
Only in \winvn: WVAUTH.OBJ
Only in \winvn: WVAUTH.SBR
diff -wBbc .\WVBLOCK.C \winvn\WVBLOCK.C
*** .\WVBLOCK.C	Tue Dec 07 20:30:10 1993
--- \winvn\WVBLOCK.C	Mon Jan 10 20:37:10 1994
***************
*** 98,103 ****
--- 98,104 ----
    BlockPtr->hNextBlock = hNext;
    BlockPtr->LWAp1 = sizeof (TypBlock) + sizeof (TypLine);
    BlockPtr->NumLines = 0;
+   BlockPtr->NumActiveLines = 0;
    BlockPtr->eob = END_OF_BLOCK;
    ((TypLine far *) ((char far *) BlockPtr + sizeof (TypBlock)))->length = END_OF_BLOCK;
    ((TypLine far *) ((char far *) BlockPtr + sizeof (TypBlock)))->LineID = NextLineID++;
***************
*** 236,241 ****
--- 237,243 ----
        /* Adjust textblock counters.                                  */
        MyBlock->LWAp1 += LineToAdd->length;
        MyBlock->NumLines++;
+       if(LineToAdd->active) MyBlock->NumActiveLines++;
        IncPtr ((*CurAddPtr), LineToAdd->length);
        MyBlock->OwnerDoc->TotalLines++;
      }
***************
*** 873,878 ****
--- 875,884 ----
       TypBlock far *BlockPtr;
       TypLine far *LinePtr;
  {     
+ #if 0
+    /* This older code is faster, but ignores the distinction 
+     * between active and inactive lines.  /mrr
+     */
    unsigned int nLines = 0;
    TypBlock far *MyBlock;
    TypLine far *MyLine;
***************
*** 916,922 ****
--- 922,943 ----
        NextLine (&MyBlock, &MyLine);
        MyOffset = (char far *) MyLine - (char far *) MyBlock;
      }
+ #else
+   unsigned int nLines = 0;
+   TypBlock far *MyBlock;
+   TypLine far *MyLine;
+   TypDoc *MyDoc;
              
+    MyDoc = BlockPtr->OwnerDoc;
+    TopOfDoc(MyDoc,&MyBlock,&MyLine);
+    while(MyLine != LinePtr) {
+       if(MyLine->active) nLines++;
+       if(!NextLine(&MyBlock,&MyLine)) {
+          MessageBox (MyDoc->hDocWnd, "Hit end of document", "Error in WhatLine",
+             MB_OK | MB_ICONHAND);
+       }
+    }
+ #endif
    return (nLines);
  }
  
***************
*** 971,976 ****
--- 992,1001 ----
       TypBlock far **BlockPtr;
       TypLine far **LinePtr;
  {
+ #if 1
+    /* This old code is faster, but ignores the distinction between
+     * active and inactive lines.   /mrr
+     */
    unsigned int LinesSoFar = 0;
    TypBlock far *MyBlockPtr;
    TypLine far *MyLinePtr;
***************
*** 981,989 ****
    do
      {
        MyBlockPtr = (TypBlock far *) GlobalLock (hBlock);
!       if (LinesSoFar + MyBlockPtr->NumLines > LineOrd)
  	break;
!       LinesSoFar += MyBlockPtr->NumLines;
        hNextBlock = MyBlockPtr->hNextBlock;
        GlobalUnlock (hBlock);
        hBlock = hNextBlock;
--- 1006,1014 ----
    do
      {
        MyBlockPtr = (TypBlock far *) GlobalLock (hBlock);
!       if (LinesSoFar + MyBlockPtr->NumActiveLines > LineOrd)
     break;
!       LinesSoFar += MyBlockPtr->NumActiveLines;
        hNextBlock = MyBlockPtr->hNextBlock;
        GlobalUnlock (hBlock);
        hBlock = hNextBlock;
***************
*** 993,1008 ****
    if (hBlock)
      {
        MyLinePtr = (TypLine far *) ((char far *) MyBlockPtr + sizeof (TypBlock));
        while (LinesSoFar < LineOrd)
  	{
- 	  LinesSoFar++;
  	  if (!NextLine (&MyBlockPtr, &MyLinePtr))
  	    break;
  	}
        retcode = TRUE;
        *BlockPtr = MyBlockPtr;
        *LinePtr = MyLinePtr;
      }
    return (retcode);
  }
  
--- 1018,1056 ----
    if (hBlock)
      {
        MyLinePtr = (TypLine far *) ((char far *) MyBlockPtr + sizeof (TypBlock));
+       AdvanceToActive(&MyBlockPtr,&MyLinePtr);
        while (LinesSoFar < LineOrd)
     {
       if (!NextLine (&MyBlockPtr, &MyLinePtr))
         break;
+      if(MyLinePtr->active)LinesSoFar++;
     }
        retcode = TRUE;
        *BlockPtr = MyBlockPtr;
        *LinePtr = MyLinePtr;
      }
+ #else
+   TypBlock far *MyBlockPtr;
+   TypLine far *MyLinePtr;
+   HANDLE hMyBlock;
+   unsigned int MyOffset;
+   TypLineID MyLineID;
+   int retcode = FALSE;
+   
+   TopOfDoc(Doc,BlockPtr,LinePtr);
+   while(1) {
+       if((*LinePtr)->active) {
+          if(!LineOrd--) {
+             retcode = TRUE;
+             break;
+          } 
+       }
+       if(!NextLine(BlockPtr,LinePtr)) {
+          break;
+       }
+   }            
+   /*UnlockLine(BlockPtr,LinePtr,&hMyBlock,&MyOffset,&MyLineID); */
+ #endif
    return (retcode);
  }
  
***************
*** 1181,1186 ****
--- 1229,1289 ----
  
  }
  
+ /*--- function ForAllBlocks ---------------------------------------------
+  *
+  *  Perform an operation for all blocks in a document.  The operation
+  *  to be performed is specified by a C function argument.
+  *
+  *    Entry Doc            is the document.
+  *          lpfnFunc       is a pointer to the function to call for
+  *                         each block.
+  *          lFlag          is a flag that's passed to the function.
+  *
+  */
+ void
+ ForAllBlocks (TypDoc *Doc, 
+        void lpfnFunc(TypDoc *Doc, TypBlock far ** BlockPtr, int wFlag, int wValue),
+        int wFlag, int wValue)
+ {
+   TypBlock far *BlockPtr; 
+   HANDLE hMyBlock, hNewBlock;
+ 
+   if (!Doc)
+     return ;
+     
+   hMyBlock = Doc->hFirstBlock;
+   do
+     {
+       BlockPtr = (TypBlock far *) GlobalLock (hMyBlock);
+       lpfnFunc(Doc,&BlockPtr,wFlag,wValue);
+       hNewBlock = BlockPtr->hNextBlock;
+       GlobalUnlock (hMyBlock);
+       hMyBlock = hNewBlock;
+     }
+   while (hNewBlock);
+ 
+ }
+ 
+ /*--- function SetForBlock -----------------------------------
+  *
+  *  Perform a function for a block.
+  *  This is called by ForAllBlocks.
+  *
+  *  Entry:  Doc      points to a document
+  *          BlockPtr points to a block
+  *          wFlag    is a general-purpose flag. 
+  *          wValue   is a general-purpose value.
+  */
+ void
+ SetForBlock(TypDoc *Doc, TypBlock far ** BlockPtr, int wFlag, int wValue)
+ {
+    switch (wFlag) {
+       case BLOCK_ACTION_SET_ACTIVE:
+          (*BlockPtr)->NumActiveLines = wValue;
+          break;
+    }
+ }
+ 
  
  /*--- function FindString ----------------------------------------------
   *
***************
*** 1254,1259 ****
--- 1357,1363 ----
      {
        do
     { 
+     if(LinePtr->active) {
       orglineptr = (char far *) LinePtr + TextOffset;
       sourceptr = sourceline;
       for (SourceLen = 0; ch = *(orglineptr),
***************
*** 1261,1266 ****
--- 1365,1371 ----
         orglineptr++;
       found = SearchLine (sourceline, SourceLen, targline, TargLen);
      }
+    }
        while (found == -1 && NextLine (&BlockPtr, &LinePtr));
      }
    UnlockLine (BlockPtr, LinePtr,
Only in \winvn: WVBLOCK.OBJ
Only in \winvn: WVBLOCK.SBR
diff -wBbc .\WVCNCM.C \winvn\WVCNCM.C
*** .\WVCNCM.C	Tue Dec 07 20:30:10 1993
--- \winvn\WVCNCM.C	Sun Jan 09 20:20:32 1994
***************
*** 656,661 ****
--- 656,662 ----
    int write_ini = FALSE;
    int dialog_val;
    int item;
+   int temp;
    char threshold[5];
  
    switch (iMessage)
***************
*** 669,674 ****
--- 670,676 ----
        CheckDlgButton (hDlg, ID_CONFIG_ARTICLE_FIXED_FONT, ArticleFixedFont);
        CheckDlgButton (hDlg, ID_CONFIG_FULLNAMEFROM, FullNameFrom);
        CheckDlgButton (hDlg, ID_CONFIG_THREADS, threadp);  
+       CheckDlgButton (hDlg, ID_CONFIG_SHOWUNSUB, ShowUnsubscribed);
        sprintf (threshold, "%d", article_threshold);
        SetDlgItemText (hDlg, IDD_ART_THRESHOLD, threshold);
  
***************
*** 686,691 ****
--- 688,710 ----
       NewArticleWindow = (IsDlgButtonChecked (hDlg, ID_CONFIG_NEW_WND_ARTICLE) != 0);
       ArticleFixedFont = (IsDlgButtonChecked (hDlg, ID_CONFIG_ARTICLE_FIXED_FONT) != 0);
       FullNameFrom = (IsDlgButtonChecked (hDlg, ID_CONFIG_FULLNAMEFROM) != 0); 
+      
+      /* If the user has changed the ShowUnsubscribed option, we must
+       * recompute which lines are active and redisplay.  
+       * Reset the window to the top to make sure that everything
+       * will display OK.
+       * There is some question in my mind whether this code will
+       * work OK if the first screen's worth of groups are unsubscribed,
+       * but it *should* work.
+       */
+      temp = (IsDlgButtonChecked (hDlg,ID_CONFIG_SHOWUNSUB) != 0);
+      if(temp != ShowUnsubscribed) {
+       ShowUnsubscribed = temp;
+       SetGroupActiveLines();
+       ScreenToTop(&NetDoc);              
+       InvalidateRect(hWndConf,NULL,FALSE);
+      }
+      
       threadp = (IsDlgButtonChecked (hDlg, ID_CONFIG_THREADS) != 0);
       GetDlgItemText(hDlg,IDD_ART_THRESHOLD,threshold,5);
  
***************
*** 721,726 ****
--- 740,747 ----
  
           WritePrivateProfileInt
        (szAppName, "EnableThreading", threadp, szAppProFile);
+          WritePrivateProfileInt
+       (szAppName, "ShowUnsubscribed", ShowUnsubscribed, szAppProFile);
  
         }
       dialog_val = TRUE;
Only in \winvn: WVCNCM.OBJ
Only in \winvn: WVCNCM.SBR
Only in \winvn: WVCONTES.WP5
Only in \winvn: WVCRYPT.C
Only in \winvn: WVCRYPT.OBJ
Only in \winvn: WVCRYPT.SBR
Only in \winvn: WVDEBUGC.C
Only in \winvn: WVDEBUGC.ICO
Only in \winvn: WVDEBUGC.OBJ
Only in \winvn: WVDEBUGC.SBR
Only in \winvn: WVDLG.H
Only in \winvn: WVDOC.TXT
diff -wBbc .\WVFILE.C \winvn\WVFILE.C
*** .\WVFILE.C	Tue Dec 07 20:30:10 1993
--- \winvn\WVFILE.C	Sun Jan 09 22:36:46 1994
***************
*** 342,348 ****
   *   MBuf  - pointer to string to be written to file
   */
  
! void WriteEditLog(HWND hWnd, char *szFileName, char *mBuf)
  {
    TypMRRFile *MRRFile;
    HANDLE hFile;
--- 342,348 ----
   *   MBuf  - pointer to string to be written to file
   */
  
! BOOL WriteEditLog(HWND hWnd, char *szFileName, char *mBuf)
  {
    TypMRRFile *MRRFile;
    HANDLE hFile;
Only in \winvn: WVFILE.OBJ
Only in \winvn: WVFILE.SBR
diff -wBbc .\WVGLOB.H \winvn\WVGLOB.H
*** .\WVGLOB.H	Wed Jan 05 17:36:54 1994
--- \winvn\WVGLOB.H	Mon Jan 10 23:01:08 1994
***************
*** 126,136 ****
     unsigned int SplitSize;    /* textblock split point in bytes           */
     HANDLE hCurAddBlock;       /* hBlock to point at which to add lines.   */
     unsigned int AddOffset;    /* offset in bytes for point to add lines   */
!    TypLineID  AddLineID;      /* LineID of point to add lines.            */
     HANDLE hCurTopScBlock;     /* hBlock of current top line of window     */
     unsigned int TopScOffset;
     TypLineID  TopScLineID;
!    unsigned int TopLineOrd;   /* ordinal in doc of line line in window    */
     HANDLE hLastSeenBlock;
     unsigned int LastSeenOffset;
     TypLineID    LastSeenLineID;
--- 126,136 ----
     unsigned int SplitSize;    /* textblock split point in bytes           */
     HANDLE hCurAddBlock;       /* hBlock to point at which to add lines.   */
     unsigned int AddOffset;    /* offset in bytes for point to add lines   */
!    TypLineID  AddLineID;      /* LineID of place to add lines.            */
     HANDLE hCurTopScBlock;     /* hBlock of current top line of window     */
     unsigned int TopScOffset;
     TypLineID  TopScLineID;
!    unsigned int TopLineOrd;   /* ordinal in doc of top line in window     */
     HANDLE hLastSeenBlock;
     unsigned int LastSeenOffset;
     TypLineID    LastSeenLineID;
***************
*** 159,164 ****
--- 159,165 ----
     HANDLE hCurBlock;      /* handle of this block                         */
     int    LWAp1;          /* # of used data bytes in block, inc header    */
     int    NumLines;       /* # of lines in this block                     */
+    int    NumActiveLines; /* # of active lines in this block.             */
     TypDoc *OwnerDoc;      /* pointer to document this block is in.        */
     int    eob;            /* end-of-block; must be just before 1st line.  */
     /* Text lines */
***************
*** 168,173 ****
--- 169,175 ----
  typedef struct structline {
     int length;              /* Total # of bytes in line, all-inclusive    */
     TypLineID LineID;        /* Unique identifier for this line.           */
+    int active;              /* =1 if line should be displayed, else 0     */
     /* Bytes of text */
     /* Another copy of length */
  } TypLine;
***************
*** 283,288 ****
--- 285,291 ----
  #endif
  
  DEF TypDoc NetDoc;
+ DEF TypDoc DebugCommDoc;
  
  #define MRR_SCROLL_LINEUP    0
  #define MRR_SCROLL_LINEDOWN  1
***************
*** 445,450 ****
--- 448,454 ----
  DEF HWND   hWndConf;   /* handle to NetDoc window                             */
  DEF HWND   hWndSk;
  DEF HWND   hDosWnd;
+ DEF HWND   hWndDebugComm;  /*handle to Debug Comm window */
  
  DEF HANDLE hAccel;     /* handle to main accelerator table */
  DEF MSG MainMsg;       /* message returned from GetMessage */
***************
*** 486,491 ****
--- 490,498 ----
  DEF int arts_to_retrieve;
  DEF int savingArtIndex;
  DEF int numArtsSaved;  
+ DEF int ShowUnsubscribed;
+ DEF int ShowReadArticles;  
+ DEF int DebugComm;
  
  /* AskComm says whether to put up the communications dialog box
   * upon starting up.  Options are never, always, and yes, because
***************
*** 596,602 ****
--- 603,612 ----
  
  #define GROUP_ACTION_SUBSCRIBE    0
  #define GROUP_ACTION_UNSUBSCRIBE  1
+ #define GROUP_ACTION_CHECK_ACTIVE 2  
  
+ #define BLOCK_ACTION_SET_ACTIVE   0
+ 
  #define ARTICLE_ACTION_SAVE   0
  #define COMPARE         1
  #define NO_COMPARE      0
Only in \winvn: WVGROUP.ICO
Only in \winvn: WVGROUP.OBJ
Only in \winvn: WVGROUP.SBR
Only in \winvn: WVHEADER.C
Only in \winvn: WVHEADER.OBJ
Only in \winvn: WVHEADER.SBR
Only in \winvn: WVHLAWIN.RTF
Only in \winvn: WVHLDEF1.RTF
Only in \winvn: WVHLGEN.RTF
Only in \winvn: WVHLGWIN.RTF
Only in \winvn: WVHLMAIN.RTF
Only in \winvn: WVHLMWIN.RTF
Only in \winvn: WVHLPRO2.RTF
Only in \winvn: WVHLPROC.RTF
Only in \winvn: WVHLPWIN.RTF
Only in \winvn: WVHLUSE.RTF
diff -wBbc .\WVLIST.C \winvn\WVLIST.C
*** .\WVLIST.C	Tue Dec 07 20:30:16 1993
--- \winvn\WVLIST.C	Mon Jan 10 21:09:44 1994
***************
*** 361,366 ****
--- 361,368 ----
         * Unsubscribed groups go in the section below, in alphabetical order.
         */
        MergeGroups (ADD_SUBSCRIBED_END_OF_SUB);
+       SetGroupActiveLines();
+ 
      }
  
    /* Unlock and/or free memory in NetDoc and NewGroupTable.  */
***************
*** 566,571 ****
--- 568,574 ----
       /* This group has been selected and should be subscribed to.
             */
       MoveBytes (AllocPtr, myline, ((TypLine far *) AllocPtr)->length); 
+      LinePtr->active = TRUE;
       AddLine ((TypLine *) myline, &BlockPtr, &LinePtr);
       NetDoc.ActiveLines++;
       hLine = *((HANDLE far *) NewGroupTable[j]);
***************
*** 614,619 ****
--- 617,623 ----
  
       /* Now add the new group at this point */
       MoveBytes (AllocPtr, myline, ((TypLine far *) AllocPtr)->length); 
+      LinePtr->active = ShowUnsubscribed;
       AddLine ((TypLine *) myline, &BlockPtr, &LinePtr);
  
       /* Unlock and free this entry in NewGroupTable. */
Only in \winvn: WVLIST.DOC
Only in \winvn: WVLIST.OBJ
Only in \winvn: WVLIST.SBR
Only in \winvn: WVMAIL.C
Only in \winvn: WVMAIL.OBJ
Only in \winvn: WVMAIL.SBR
Only in \winvn: WVMAPI.C
Only in \winvn: WVMAPI.H
Only in \winvn: WVMAPI.OBJ
Only in \winvn: WVMAPI.SBR
Only in \winvn: WVPOST.C
Only in \winvn: WVPOST.ICO
Only in \winvn: WVPOST.OBJ
Only in \winvn: WVPOST.SBR
Only in \winvn: WVPRINT.C
Only in \winvn: WVPRINT.H
Only in \winvn: WVPRINT.OBJ
Only in \winvn: WVPRINT.SBR
Only in \winvn: WVSCKPWK.C
Only in \winvn: WVSCKPWK.D
Only in \winvn: WVSCKSTD.C
Only in \winvn: WVSCKSTD.OBJ
Only in \winvn: WVSCKSTD.SBR
diff -wBbc .\WVSCREEN.C \winvn\WVSCREEN.C
*** .\WVSCREEN.C	Tue Dec 07 20:30:14 1993
--- \winvn\WVSCREEN.C	Sun Jan 09 21:45:04 1994
***************
*** 69,76 ****
  
    PtrToOffset (MyBlock, MyLine, &hBlock, &Offset, &MyLineID);
    TestAdvance = nLines + LinesOnScreen - 1;
!   for (LinesGone = TestAdvance; LinesGone && NextLine (&MyBlock, &MyLine);
!        LinesGone--);
    UnlockLine (MyBlock, MyLine, &hBlockGarbage, &OffsetGarbage, &LineIDGarbage);
  
    nLines -= LinesGone;
--- 69,79 ----
  
    PtrToOffset (MyBlock, MyLine, &hBlock, &Offset, &MyLineID);
    TestAdvance = nLines + LinesOnScreen - 1;
!   for (LinesGone = TestAdvance; LinesGone ;) {
!       if(!NextLine (&MyBlock, &MyLine)) break;
!       /* Count only active lines. */
!       if(MyLine->active) LinesGone--;
!   }
    UnlockLine (MyBlock, MyLine, &hBlockGarbage, &OffsetGarbage, &LineIDGarbage);
  
    nLines -= LinesGone;
***************
*** 79,87 ****
    *LinesAdvanced = nLines;
  
    LockLine (hBlock, Offset, MyLineID, &MyBlock, &MyLine);
!   while (nLines--)
      {
        NextLine (BlockPtr, LinePtr);
      }
  }
  
--- 82,91 ----
    *LinesAdvanced = nLines;
  
    LockLine (hBlock, Offset, MyLineID, &MyBlock, &MyLine);
!   while (nLines)
      {
        NextLine (BlockPtr, LinePtr);
+       if((*LinePtr)->active) nLines--;
      }
  }
  
***************
*** 109,121 ****
  {
    *LinesBackedUp = 0;
  
!   while (nLines-- && PrevLine (BlockPtr, LinePtr))
      {
        (*LinesBackedUp)++;
      }
  }
  
! /*--- function ScrollIt ----------------------------------------------
   *
   *  Perform a scrolling action.
   *
--- 113,128 ----
  {
    *LinesBackedUp = 0;
  
!   while (nLines && PrevLine (BlockPtr, LinePtr))
      {          
+       if((*LinePtr)->active) {
+          nLines--;
           (*LinesBackedUp)++;
        }
      }
+ }
  
! /*--- function NewScrollIt ----------------------------------------------
   *
   *  Perform a scrolling action.
   *
***************
*** 171,178 ****
        break;
  
      case SB_LINEDOWN:
! 
!    if (Document->TopLineOrd < (Document->TotalLines - Document->ScYLines)) {
        LinesGone = 1;
      }
     else LinesGone = 0;
--- 178,188 ----
        break;
  
      case SB_LINEDOWN:
!       /* Should change TotalLines below to ActiveLines for 
!        * suppression of already-read articles, but it's not that simple.
!        *  /mrr
!        */
!    if (Document->TopLineOrd < (Document->ActiveLines - Document->ScYLines)) {
        LinesGone = 1;
      }
     else LinesGone = 0;
***************
*** 211,222 ****
  
   case SB_PAGEDOWN:
  
!    if (Document->TotalLines > Document->ScYLines) { /* do we even need to scroll? */
!      if ((Document->TotalLines -
  	  (Document->TopLineOrd + Document->ScYLines)) > Document->ScYLines)
         LinesGone = Document->ScYLines - 1;
       else
!        LinesGone = Document->TotalLines - (Document->TopLineOrd + Document->ScYLines );
  
       Document->TopLineOrd += LinesGone;
       InvalidateRect (Document->hDocWnd, NULL, FALSE);
--- 221,232 ----
  
   case SB_PAGEDOWN:
  
!    if (Document->ActiveLines > Document->ScYLines) { /* do we even need to scroll? */
!      if ((Document->ActiveLines -
       (Document->TopLineOrd + Document->ScYLines)) > Document->ScYLines)
         LinesGone = Document->ScYLines - 1;
       else
!        LinesGone = Document->ActiveLines - (Document->TopLineOrd + Document->ScYLines );
  
       Document->TopLineOrd += LinesGone;
       InvalidateRect (Document->hDocWnd, NULL, FALSE);
***************
*** 321,327 ****
        /* Move up a line by scrolling the window down one line     */
        /* and introducing 1 new line at the top.                   */
        LockLine (Document->hCurTopScBlock, Document->TopScOffset, Document->TopScLineID, &BlockPtr, &LinePtr); 
! 
        ScreenUp (1, &BlockPtr, &LinePtr, &LinesGone);
      doscrollup:;
        if (LinesGone)
--- 331,337 ----
        /* Move up a line by scrolling the window down one line     */
        /* and introducing 1 new line at the top.                   */
        LockLine (Document->hCurTopScBlock, Document->TopScOffset, Document->TopScLineID, &BlockPtr, &LinePtr); 
!       AdvanceToActive(&BlockPtr,&LinePtr);
        ScreenUp (1, &BlockPtr, &LinePtr, &LinesGone);
      doscrollup:;
        if (LinesGone)
***************
*** 344,349 ****
--- 354,360 ----
  
      case SB_LINEDOWN:
        LockLine (Document->hCurTopScBlock, Document->TopScOffset, Document->TopScLineID, &BlockPtr, &LinePtr);
+       AdvanceToActive(&BlockPtr,&LinePtr);
        ScreenDown (1, Document->ScYLines, &BlockPtr, &LinePtr, &LinesGone);
      doscrolldown:;
        if (LinesGone)
***************
*** 364,369 ****
--- 375,381 ----
  
      case SB_PAGEUP:
        LockLine (Document->hCurTopScBlock, Document->TopScOffset, Document->TopScLineID, &BlockPtr, &LinePtr);
+       AdvanceToActive(&BlockPtr,&LinePtr);
        ScreenUp (Document->ScYLines - 1, &BlockPtr, &LinePtr, &LinesGone);
        Document->TopLineOrd -= LinesGone;
        InvalidateRect (Document->hDocWnd, NULL, FALSE);
***************
*** 371,376 ****
--- 383,389 ----
  
      case SB_PAGEDOWN:
        LockLine (Document->hCurTopScBlock, Document->TopScOffset, Document->TopScLineID, &BlockPtr, &LinePtr);
+       AdvanceToActive(&BlockPtr,&LinePtr);
        ScreenDown (Document->ScYLines - 1, Document->ScYLines,
          &BlockPtr, &LinePtr, &LinesGone);
        Document->TopLineOrd += LinesGone;
***************
*** 464,470 ****
    TypBlock far *CurBlockPtr, far * TargBlockPtr;
    TypLine far *CurLinePtr, far * TargLinePtr;
    int iline;
!   BOOL found = FALSE;
    HANDLE hBlock;
    unsigned int Offset;
    TypLineID MyLineID;
--- 477,483 ----
    TypBlock far *CurBlockPtr, far * TargBlockPtr;
    TypLine far *CurLinePtr, far * TargLinePtr;
    int iline;
!   BOOL found = FALSE, gotnext=TRUE;
    HANDLE hBlock;
    unsigned int Offset;
    TypLineID MyLineID;
***************
*** 472,483 ****
    LockLine (Doc->hCurTopScBlock, Doc->TopScOffset, Doc->TopScLineID, &CurBlockPtr, &CurLinePtr);
    LockLine (hTargBlock, TargOffset, TargLineID, &TargBlockPtr, &TargLinePtr);
  
!   for (iline = 0; !found && (unsigned) iline < Doc->ScYLines; iline++)
      {
        found = (TargLinePtr == CurLinePtr);
        if (!found)
  	{
! 	  NextLine (&CurBlockPtr, &CurLinePtr);
  	}
      }
  
--- 485,497 ----
    LockLine (Doc->hCurTopScBlock, Doc->TopScOffset, Doc->TopScLineID, &CurBlockPtr, &CurLinePtr);
    LockLine (hTargBlock, TargOffset, TargLineID, &TargBlockPtr, &TargLinePtr);
  
!   for (iline = 0; gotnext && !found && (unsigned) iline < Doc->ScYLines;)
      {
        found = (TargLinePtr == CurLinePtr);
+       if(CurLinePtr->active) iline++;
        if (!found)
     {
!      gotnext = NextLine (&CurBlockPtr, &CurLinePtr);
     }
      }
  
***************
*** 597,607 ****
    TypLineID MyLineID;
  
    Doc = BlockPtr->OwnerDoc;
!   if (Doc->TotalLines > Doc->ScYLines)
      {
        lineord = WhatLine (BlockPtr, LinePtr);
  
!       while (lineord > Doc->TotalLines - Doc->ScYLines)
  	{
  	  PrevLine (&BlockPtr, &LinePtr);
  	  lineord--;
--- 611,621 ----
    TypLineID MyLineID;
  
    Doc = BlockPtr->OwnerDoc;
!   if (Doc->ActiveLines > Doc->ScYLines)
      {
        lineord = WhatLine (BlockPtr, LinePtr);
  
!       while (lineord > Doc->ActiveLines - Doc->ScYLines)
     {
       PrevLine (&BlockPtr, &LinePtr);
       lineord--;
***************
*** 629,639 ****
--- 643,688 ----
  void
  ScreenToTop (TypDoc * Doc)
  { 
+   TypBlock far *BlockPtr;
+   TypLine far *LinePtr;
+   
    Doc->hCurTopScBlock = Doc->hFirstBlock;
    Doc->TopScOffset = sizeof (TypBlock);
    Doc->TopScLineID = 0;
    Doc->TopLineOrd = 0;
    
+   LockLine(Doc->hFirstBlock,Doc->TopScOffset,Doc->TopScLineID,&BlockPtr,&LinePtr);
+   AdvanceToActive(&BlockPtr,&LinePtr);
+   UnlockLine(BlockPtr,LinePtr,&(Doc->hFirstBlock),&(Doc->TopScOffset),&(Doc->TopScLineID));
+ }   
+ 
+ /*--- function AdvanceToActive ---------------------------------------
+  *
+  *  Advances a block/line pointer pair to an active line.
+  *  The pointers are unchanged if the current line is active.
+  *
+  *  Entry:  BlockPtr, LinePtr points to a line.
+  *
+  *  Exit:   BlockPtr,LinePtr  points to an active line, if possible.
+  *          Returns TRUE if successful, else FALSE if no line from
+  *            this point to the end of the document was active.
+  */
+ BOOL
+ AdvanceToActive(BlockPtr, LinePtr)
+      TypBlock far **BlockPtr;
+      TypLine far **LinePtr;
+ {
+    BOOL ok=TRUE;
+    
+    while(!((*LinePtr)->active)) {
+       if(!NextLine(BlockPtr,LinePtr)) {
+          ok = FALSE;
+          break;
+       }
+    }   
+    
+    return ok;
  }
+  
  
  /*-- Last Line of WVSCREEN.C ----------------- */
Only in \winvn: WVSCREEN.OBJ
Only in \winvn: WVSCREEN.SBR
Only in \winvn: WVSTATEM.WP5
diff -wBbc .\WVUSENET.C \winvn\WVUSENET.C
*** .\WVUSENET.C	Tue Dec 07 21:39:44 1993
--- \winvn\WVUSENET.C	Sun Jan 09 22:23:58 1994
***************
*** 107,113 ****
--- 107,116 ----
  // groups read.  SMR 930224
  
  int started_with_no_dolist;            
+ 
  void show_version_strings(void);
+ void SetGroupActiveLines(void);
+ 
  
  /*--- FUNCTION: WinVnConfWndProc ---------------------------------------
   *
***************
*** 559,564 ****
--- 562,568 ----
       MergeGroups (ADD_SUBSCRIBED_END_OF_SUB);
       CleanUpGroupTable ();
       ForAllLines (&NetDoc, SetLineFlag, 0, FALSE);
+      SetGroupActiveLines();
       ScreenToTop (&NetDoc);
       InvalidateRect (hWnd, NULL, FALSE);
       break;
***************
*** 573,578 ****
--- 577,583 ----
       MergeGroups (ADD_SUBSCRIBED_END_OF_SUB);
       CleanUpGroupTable ();
       ForAllLines (&NetDoc, SetLineFlag, 0, FALSE);
+      SetGroupActiveLines();
       ScreenToTop (&NetDoc);
       InvalidateRect (hWnd, NULL, FALSE);
       break;
***************
*** 826,832 ****
  	    CurPos = NetDoc.TopLineOrd;
  	    if (CurPos < 0)
  	      CurPos = 0;
! 	    RangeHigh = NetDoc.TotalLines - VertLines;
  	    if (RangeHigh < 0)
  	      RangeHigh = 0;
  	    SetScrollRange (hWnd, SB_VERT, 0, RangeHigh, FALSE);
--- 831,837 ----
         CurPos = NetDoc.TopLineOrd;
         if (CurPos < 0)
           CurPos = 0;   
!        RangeHigh = NetDoc.ActiveLines - VertLines;;
         if (RangeHigh < 0)
           RangeHigh = 0;
         SetScrollRange (hWnd, SB_VERT, 0, RangeHigh, FALSE);
***************
*** 846,851 ****
--- 851,859 ----
          textptr = (char far *) LinePtr + sizeof (TypLine) +
            sizeof (TypGroup); 
            
+         /* Display this line only if it is active. */  
+         if(LinePtr->active) {
+ 
          /* Figure out the color of this line.                 */
  
          if (MyGroup->Subscribed)
***************
*** 908,915 ****
  		      PatBlt (hDC, RestX, Y, myRect.right - RestX, LineHeight, Rop);
  
  		  Y += LineHeight;
  		}
! 	      while (--VertLines > 0 && NextLine (&BlockPtr, &LinePtr));
  
  	    SetTextColor (hDC, MyColors[1]);
  	    SetBkColor (hDC, MyBack[1]);
--- 916,925 ----
              PatBlt (hDC, RestX, Y, myRect.right - RestX, LineHeight, Rop);
  
          Y += LineHeight;
+         --VertLines;
+       }  /* end if LinePtr->active */  
        }
!          while (VertLines > 0 && NextLine (&BlockPtr, &LinePtr));
  
         SetTextColor (hDC, MyColors[1]);
         SetBkColor (hDC, MyBack[1]);
***************
*** 1210,1222 ****
  
        LockLine (DocPtr->hCurTopScBlock, DocPtr->TopScOffset, DocPtr->TopScLineID,
  		BlockPtr, LinePtr);
  
!       for (found = TRUE, il = 0; il < SelLine; il++)
  	{
  	  if (!NextLine (BlockPtr, LinePtr))
  	    {
  	      found = FALSE;    /* ran off end of document */
  	      break;
  	    }
  	}
      }
--- 1220,1235 ----
  
        LockLine (DocPtr->hCurTopScBlock, DocPtr->TopScOffset, DocPtr->TopScLineID,
        BlockPtr, LinePtr);
+       AdvanceToActive(BlockPtr,LinePtr);
  
!       for (found = TRUE, il = 0; il < SelLine; )
     {
       if (!NextLine (BlockPtr, LinePtr))
         {
           found = FALSE;    /* ran off end of document */
           break;
+        } else if((*LinePtr)->active){
+          il++;
         }
     }
      }
***************
*** 1306,1311 ****
--- 1319,1326 ----
    NetDoc.TopScOffset = sizeof (TypBlock);
    NetDoc.TopScLineID = 0L;
    
+   /* Mark lines active or inactive according to ShowUnsubscribed. */                                        
+   SetGroupActiveLines();                                          
    // we'll check this during WriteNewsrc(). SMR 930224
    started_with_no_dolist = !DoList;
  
***************
*** 1501,1506 ****
--- 1516,1532 ----
     }
        break;
        
+       case GROUP_ACTION_CHECK_ACTIVE:
+          if(((TypGroup far *) (((char far *) *LinePtr) + sizeof (TypLine)))
+             ->Subscribed || ShowUnsubscribed ) {
+             (*LinePtr)->active = TRUE;
+             (*BlockPtr)->NumActiveLines++;
+             NetDoc.ActiveLines++;
+          } else {
+             (*LinePtr)->active = FALSE;
+          }
+          break;
+ 
      }
  }
  
***************
*** 1611,1616 ****
--- 1637,1662 ----
  
  }
  
+ /*--- function SetGroupActiveLines --------------------------------------
+  *
+  *  Go through all the lines in the Net document, marking each
+  *  as active or inactive according to whether the corresponding
+  *  group is subscribed and whether we are displaying unsubscribed
+  *  groups.
+  *
+  *  Entry:  NetDoc and ShowUnsubscribed are set properly.
+  *
+  *  Exit:   Each of the lines in NetDoc has had its "active" field
+  *          set properly.
+  */
+ void
+ SetGroupActiveLines() {
+    NetDoc.ActiveLines = 0;
+    ForAllBlocks (&NetDoc, SetForBlock, BLOCK_ACTION_SET_ACTIVE, 0);
+    ForAllLines (&NetDoc, GroupAction, GROUP_ACTION_CHECK_ACTIVE, 0);
+ }                 
+ 
+ 
  /* stuff for showing version numbers of the files */
  
  #include "version.h"
Only in \winvn: WVUSENET.OBJ
Only in \winvn: WVUSENET.SBR
diff -wBbc .\WVUTIL.C \winvn\WVUTIL.C
*** .\WVUTIL.C	Wed Jan 05 17:36:24 1994
--- \winvn\WVUTIL.C	Sun Jan 09 17:27:12 1994
***************
*** 1320,1325 ****
--- 1320,1326 ----
       (cdest-1) - (artline+sizeof(TypLine)+sizeof(TypText));
     ((TypLine *)artline)->length = mylen;
     ((TypLine *)artline)->LineID = NextLineID++;
+    ((TypLine *)artline)->active = TRUE;
     *( (int *) (artline+mylen-sizeof(int)) ) = mylen;
     LockLine(CommDoc->hCurAddBlock,CommDoc->AddOffset,CommDoc->AddLineID,&BlockPtr,&LinePtr);
     AddLine((TypLine *)artline,&BlockPtr,&LinePtr);
***************
*** 1600,1606 ****
    ReleaseCapture ();
  
    CommDoc->TotalLines = CommDoc->ActiveLines;
!   CommDoc->ActiveLines = 0;
    /* Fetch this group's line in NetDoc so we can get the
     * group's name for the window's title bar.
     */
--- 1601,1612 ----
    ReleaseCapture ();
  
    CommDoc->TotalLines = CommDoc->ActiveLines;
!   /* Disabled by MRR so that ActiveLines is the number of lines
!    * we should display in the Group window.  Eventually, will
!    * change it so that ActiveLines will count only unread articles
!    * if the user desires. 
!    */
!   /* CommDoc->ActiveLines = 0;*/
    /* Fetch this group's line in NetDoc so we can get the
     * group's name for the window's title bar.
     */
Only in \winvn: WVUTIL.OBJ
Only in \winvn: WVUTIL.SBR
