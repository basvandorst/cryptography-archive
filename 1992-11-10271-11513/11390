Xref: msuinfo sci.crypt:11390 sci.math:35723 comp.theory:5887
Path: msuinfo!uchinews!ux1.cso.uiuc.edu!sdd.hp.com!zaphod.mps.ohio-state.edu!cis.ohio-state.edu!news.sei.cmu.edu!drycas.club.cc.cmu.edu!cantaloupe.srv.cs.cmu.edu!GS35.SP.CS.CMU.EDU!sgall
Newsgroups: sci.crypt,sci.math,comp.theory
Subject: Re: Cryptography and P=NP
Message-ID: <BxzD1t.3xA.2@cs.cmu.edu>
From: sgall+@CS.CMU.EDU (Jiri Sgall)
Date: Thu, 19 Nov 1992 20:32:17 GMT
Sender: news@cs.cmu.edu (Usenet News System)
References: <1992Nov15.110945.19939@ringer.cs.utsa.edu>  <1992Nov18.193900.20199@rchland.ibm.com>
Distribution: inet
Organization: Carnegie Mellon University
Nntp-Posting-Host: gs35.sp.cs.cmu.edu
Lines: 48

|> >|> And remember, proving P=NP doesn't necessarily mean finding such an algorithm,
|> >|> merely proving it exists.
|> >|> 
|> 
|> >Once you have the proof, you can easily run a kind of universal algorithm,
|> >which will be guaranteed to be polynomial
|> 
|> OK, I don't know beans about P and NP.  So, an elementary question:
|> 
|> Do all programs of class P halt?  Your "universal algorithm" seems perilously
|> close to the "halting" problem and I have never been able to eliminate it
|> from far simpler cases than P or NP.  Or, is the halting issue kind of a
|> separate point/issue (ie, the solution is "P" when it works)?

First, a short answer. Yes, all algorithms in P halt by definition, in
polynomial time.

Second, I wasn't too precise and clear in my post. So I'd like to add a few 
details.

If you have a decision procedure for NP, you can use it to find
witnesses for NP problems. You can use selfreducibility of SAT - put
one variable equal to 0, ask if it is satisfiable, if not change it to
one; do this for all variables and you have a satisfying assignment.

So if you know that P=NP, you also have a polynomial algorithm for SAT that 
either answers NO or gives you an satisfying assignment. You can do the same 
for anything in NP.

Now by usual dovetailing you can run all algorithms, say run the first 
algorithm on all odd steps, the second on all steps divisible by 2 and not 4
and so on. So any particular algorithm runs with some constant frequency.
If any of them outputs an assignment, you check if it is correct. If yes,
you stop, if not, you go on. If P=NP, this stops for all satisfiable formulae
in polynomial time but runs forever otherwise.

This is not exactly ideal, but it for example would generate proof of any 
theorem in polynomial time in the shortest proof.

But if you take something in both NP and coNP like primality, you get an
algorithm that stops in polynomial time in both cases, because you have proofs
in both cases. So this gives you a polynomial time algorithm for factorization
if P=NP, which was the original issue of the thread.

I think these things are a folclore in the complexity community, unfortunately
you rarely learn them in a standard complexity class.

-- Jiri Sgall
