Newsgroups: sci.crypt
Path: msuinfo!caen!destroyer!gumby!wupost!news.utdallas.edu!corpgate!bnrgate!bnr.co.uk!pipex!pavo.csi.cam.ac.uk!rja14
From: rja14@cl.cam.ac.uk (Ross Anderson)
Subject: Public key challenge
Message-ID: <1992Nov14.153536.9930@infodev.cam.ac.uk>
Sender: news@infodev.cam.ac.uk (USENET news)
Nntp-Posting-Host: ely.cl.cam.ac.uk
Organization: U of Cambridge Computer Lab, UK
Date: Sat, 14 Nov 1992 15:35:36 GMT
Lines: 81

The various threads started off by Denning's NCSC paper suggest a new 
problem in public key crypto. It is motivated by the desire to protect
oneself from being forced to disclose a private key.

This is a real systems issue worldwide, not just a matter for debate on
US constitutional law. Bank officials routinely get their families 
kidnapped by mobsters who want the safe combination, and about the only
way to protect these officials is by using timelocks. 

In an electronic world, secret sharing schemes can give some protection,
as could a tamperproof time and key server in a satellite. However 
there's still more tools we need.

Call a public key cryptosystem coercion-resistant if an opponent who 
monitors the channel between two parties, and some time thereafter 
obtains the cooperation of one of these parties, cannot recover the 
session key.

If you have an online system, coercion-free designs are easy. Use 
Diffie-Hellman to set up a session key, and delete it once you're 
finished. 

It seems from the literature that some US government systems (such as 
STU-III) use this approach. This makes sense as diplomats and soldiers
may also have wives and children who could be kidnapped.

However it's a bit more difficult to make a store-and-forward system,
such as electronic mail, coercion-resistant.

You could publish a long list of public keys, say one per day; each day, 
you destroy your record of yesterday's private key (you might allow an 
extra day or so's grace in order to cope with mail from New Zealand but 
this is beside the point). You could even use `one-time' public keys; 
send out lists of these to `X.500' servers around the network with 
instructions that anyone wanting to communicate with you should get a 
fresh one.

All this is rather unwieldy though, and would take up a lot of bandwidth, 
storage and development effort. Can we not find an algorithm to do the job?

It would be nice if we could just take an RSA modulus N and say `On day k, 
encrypt m by raising it to the power 2k+1 (mod N)'; provided N were 
suitably chosen, you could calculate and store a list of decryption moduli 
d_k such that (2k+1)d_k = 1 (mod \phi(N)).

However, this system is rather weak: even if I throw away d_1 through d_k 
and the factors of N, the mob can use d_{k+1} and d_{k+2} to factor N and 
thus work out d_k.

First prize would be a public key system which, given an initial secret 
such as the factorisation of a modulus, would enable me to produce

(1)	a public encryption function c = f(i,m) where i is an integer, m
	is the message block to be encrypted and c is the resulting
	ciphertext.

(2)	a series of private decryption functions m = d_i(c) with the
	property that once I have thrown away d_1, d_2, ..., d_k, it is 
	not feasible to reconstruct any of these even given knowledge of
	d_{k+1}, d_{k+2}, ...

It is assumed that I will throw away my initial secret once I have 
calculated as many of the d_i as I intend to use. I am also not concerned 
about the local security of decrypted messages; let's assume that I just 
destroy anything sensitive after reading it.


CHALLENGE: devise a coercion-resistant public key system or show why it
can't be done.


REWARD: (1) fame 

	(2) might save lives 

	(3) might stop innocent people from going to jail 


Ross


