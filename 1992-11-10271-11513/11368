Xref: msuinfo sci.crypt:11368 sci.math:35702 comp.theory:5880
Path: msuinfo!uchinews!linac!uwm.edu!zaphod.mps.ohio-state.edu!sdd.hp.com!swrinde!cs.utexas.edu!sun-barr!rutgers!igor.rutgers.edu!zodiac.rutgers.edu!leichter
From: leichter@zodiac.rutgers.edu
Newsgroups: sci.crypt,sci.math,comp.theory
Subject: Re: Cryptography and P=NP
Message-ID: <1992Nov19.102822.1@zodiac.rutgers.edu>
Date: 19 Nov 92 15:28:22 GMT
References: <1992Nov15.110945.19939@ringer.cs.utsa.edu> <PHR.92Nov15203840@napa.telebit.com> <1e7fvdINN87s@iskut.ucs.ubc.ca> <1992Nov16.084503.10141@vax.oxford.ac.uk> <BxvEF3.Kqw.2@cs.cmu.edu> <1992Nov18.193900.20199@rchland.ibm.com>
Sender: news@igor.rutgers.edu
Followup-To: sci.crypt
Distribution: inet
Organization: Rutgers University Department of Computer Science
Lines: 45
Nntp-Posting-Host: cancer.rutgers.edu

In article <1992Nov18.193900.20199@rchland.ibm.com>,
lwloen@rchland.vnet.ibm.com (Larry Loen) writes:
> In article <BxvEF3.Kqw.2@cs.cmu.edu> Jiri Sgall writes:
| 
||(partial quote of James Annan):
| 
|||| And remember, proving P=NP doesn't necessarily mean finding such an
|||| algorithm, merely proving it exists.
|||| 
| 
||Once you have the proof, you can easily run a kind of universal algorithm,
||which will be guaranteed to be polynomial
| 
| OK, I don't know beans about P and NP.

WHAT?  An admission of lack of omniscience on Usenet?  Someone, call the
doctor; the man must have brain fever! :-)

|					  So, an elementary question:
| 
| Do all programs of class P halt?

Yes.  Programs in class P are defined as those for which, for any input of
length n, we can prove they halt after taking no more than p(n) steps, where
p is some polynomial.

You might imagine that one could have "partial class P" program, which
either deliver the result in this amount of time or run forever; but that's
not an interesting class - first, because EVERY program trivially has this
property; second, because in really class P is defined for PREDICATES, which
answer True in polynomial time for things they are supposed to accept.  If you
know the input, and you know p (which is fixed), you can compute the upper
bound on the run time.  If the program halts, take its answer; if it takes one
step beyond the bound, stop it and declare the answer to be False.  That turns
the "partial P" machine into a "full P" machine.

|				    Your "universal algorithm" seems
| perilously close to the "halting" problem and I have never been able to
| eliminate it from far simpler cases than P or NP.  Or, is the halting issue
| kind of a separate point/issue (ie, the solution is "P" when it works)?

The Halting Problem arises when we have no way of knowing that a machine has
"run too long".  Once we have a bound on the possible running times, we can
always stop a machine if it runs too long.
							-- Jerry
