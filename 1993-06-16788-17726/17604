Newsgroups: alt.privacy.clipper,sci.crypt,sci.skeptic
Path: msuinfo!uwm.edu!math.ohio-state.edu!magnus.acs.ohio-state.edu!csn!ub!acsu.buffalo.edu!boyd
From: boyd@acsu.buffalo.edu (Daniel F Boyd)
Subject: Re: Let's split sci.crypt and Re: Random numbers?
Message-ID: <C9B8FB.DE0@acsu.buffalo.edu>
Sender: nntp@acsu.buffalo.edu
Nntp-Posting-Host: autarch-14.acsu.buffalo.edu
Reply-To: boyd@acsu.buffalo.edu (Daniel F Boyd)
Organization: UB
References: <C91826.D5D.3@cs.cmu.edu> <818R6B3w165w@tanda.isis.org>
Date: Mon, 28 Jun 1993 02:33:10 GMT
Lines: 60
Xref: msuinfo alt.privacy.clipper:980 sci.crypt:17604 sci.skeptic:47277

In article <818R6B3w165w@tanda.isis.org> marc@tanda.isis.org 
>         Suppose we use a "sieve" algorithm to generate a number series
>         as follows:
> 
>         1.  Set up the half dozen or so most powerful tests of
>             randomness and combine them to produce an "Index of
>             Randomness" Ir, such that a high Ir would generally be
>             accepted as very convincing evidence of a noise source.

Without specifying what your tests for randomness are and how you're
combining them, this is meaningless.  You could end up with the same
sequence every time, or you could end up with a sequence that isn't
the same but is easily predictable, depending how you weight the
various tests.  Suppose you use the average test alone: the program
will select 128 128 128 128 128 128 128 128 for the random
byte-values.

>         2.  Starting with a many-number key as an initial series,
>             extend the series by selecting successive numbers so that
>             the series Ir is maximised.

Even leaving that unspecified: You have to calculate Ir 256 times for
each number in the sequence past the initial key.  This is way too
expensive.

>         Clearly, this could be used for cryptography, because anyone
>         with the many-number key could regenerate the entire series.

You are making the invalid assumption that only one number will
maximize Ir at each step -- during regeneration, what do you do if you
find that Ir will be maximized if the next number is any one of
230 possible choices, and no matter what number you choose, Ir is
pretty much the same?  

The longer the sequence gets, the worse this problem is -- suppose I
have a sequence that was totally random and was 5000 bytes long.  No
matter what I choose the next byte to be, Ir will be the same within
the limits of floating-point comparison.

> Pattern? What pattern? Nothing detectable as a pattern could get by
> the most powerful tests of randomness, 

This is not true.  You have no right to assume it as part of your
argument unless you are willing to say what tests for randomness
you're using.  For any randomness test, there is a sequence that
breaks it: easily predictable by a human, yet the test would say the
sequence is random.

> else we forgot one. Add it to
> the list.

How do you choose one?

Suppose you add so many tests that calculating the sequence is
computationally infeasible?

How do you deal with tests that take tuning parameters?



