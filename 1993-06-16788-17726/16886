Path: msuinfo!uwm.edu!cs.utexas.edu!uunet!math.fu-berlin.de!uni-paderborn.de!urmel.informatik.rwth-aachen.de!messua!klausf
From: klausf@messua.informatik.rwth-aachen.de (Klaus Frank)
Newsgroups: sci.crypt,alt.lang.intercal
Subject: Re: ROT-13
Date: 7 Jun 1993 07:03:25 GMT
Organization: stud. cs, RWTH Aachen
Lines: 148
Distribution: world
Message-ID: <1uup7t$tv@urmel.informatik.rwth-aachen.de>
References: <1uue87$4hj@DIALix.oz.au>
NNTP-Posting-Host: messua.informatik.rwth-aachen.de
Mime-Version: 1.0
Content-Type: text/plain; charset=US-ASCII
Content-Transfer-Encoding: 7bit
Xref: msuinfo sci.crypt:16886 alt.lang.intercal:31

shogun@DIALix.oz.au (Matthew Fitzgerald) writes:

>I am looking for the theory behind ROT-13 de/encryption so I can code a program
>on my _own_ computer that will do the job.  If anyone knows how it works, I'd
>be very happy if you could let me know!

You don't need to fiddle with the underlying mathematical theory.
Just unpack the shell archive, cd to rot13, type 'make', and you're done!
Besides, could you possibly port this to intercal?

Sincerely yours,
Klaus Frank

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of shell archive."
# Contents:  rot13 rot13/makefile rot13/encrypt rot13/hash12.c
#   rot13/decrypt.c
# Wrapped by klausf@hathi on Mon Jun  7 07:37:56 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test ! -d 'rot13' ; then
    echo shar: Creating directory \"'rot13'\"
    mkdir 'rot13'
fi
if test -f 'rot13/makefile' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'rot13/makefile'\"
else
echo shar: Extracting \"'rot13/makefile'\" \(156 characters\)
sed "s/^X//" >'rot13/makefile' <<'END_OF_FILE'
Xall: hash12 decrypt testmax
Xdecrypt: decrypt.c
X	cc -o decrypt decrypt.c
Xhash12: hash12.c
X	cc -o hash12 hash12.c
Xtestmax:
X	echo 99999999 | encrypt | decrypt
END_OF_FILE
if test 156 -ne `wc -c <'rot13/makefile'`; then
    echo shar: \"'rot13/makefile'\" unpacked with wrong size!
fi
# end of 'rot13/makefile'
fi
if test -f 'rot13/encrypt' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'rot13/encrypt'\"
else
echo shar: Extracting \"'rot13/encrypt'\" \(62 characters\)
sed "s/^X//" >'rot13/encrypt' <<'END_OF_FILE'
X#!/bin/sh
Xread plaintext
Xecho $plaintext '^ 13' | bc | hash12
END_OF_FILE
if test 62 -ne `wc -c <'rot13/encrypt'`; then
    echo shar: \"'rot13/encrypt'\" unpacked with wrong size!
fi
chmod +x 'rot13/encrypt'
# end of 'rot13/encrypt'
fi
if test -f 'rot13/hash12.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'rot13/hash12.c'\"
else
echo shar: Extracting \"'rot13/hash12.c'\" \(445 characters\)
sed "s/^X//" >'rot13/hash12.c' <<'END_OF_FILE'
Xmain()
X{
X  char sum_ring[12], c, last_digit;
X  int i, digits_processed = 0, scanned;
X  for(i=0; i<12; ++i) sum_ring[i] = 0;
X  scanned = scanf("%1c", &c);
X  while(scanned == 1 && isdigit(c) && digits_processed < 13 * 8) {
X    sum_ring[digits_processed++ %12] += last_digit = c - '0';
X    scanf("\\\n");
X    scanned = scanf("%c", &c);
X  }
X  for(i=0; i<12; ++i) printf("%c", sum_ring[digits_processed++ %12] + '0');
X  printf("%d\n", last_digit);
X}
END_OF_FILE
if test 445 -ne `wc -c <'rot13/hash12.c'`; then
    echo shar: \"'rot13/hash12.c'\" unpacked with wrong size!
fi
# end of 'rot13/hash12.c'
fi
if test -f 'rot13/decrypt.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'rot13/decrypt.c'\"
else
echo shar: Extracting \"'rot13/decrypt.c'\" \(1230 characters\)
sed "s/^X//" >'rot13/decrypt.c' <<'END_OF_FILE'
Xchar 
X  A[] = "a_\\O468\01%:\037\05\023\020X\030\031DNPQTWG$";
X  B[] = {1, 7, 10, 011, 12, 16, 26, 33, 34},
X  C[] = {3, 4, 5, 011};
X
Xint main()
X{
X  char s[13];
X  int _, i, j, k, l;
X  long int ll=0, l0l=0, lll=0, l00l=0, n=1;
X  if (scanf("%13s",s) != 1) exit(1); 
X  for(j=0;j<12;j++) 
X  { ll+=(k=s[(11-j)%12])*(j&1?-1:1);
X    l0l+=k*(j&1?012:1)*(j&2?-1:1);
X    lll+=k*=((l=j%3)?--l?100:012:1);
X    l00l+=k*(j/3&1?-1:1);
X  } 
X  _=lll%3;lll%='%';
X  for(i=1,j=0;j<2;j++,ll=(-ll)%11)
X    for(k=0;k<4;k++)
X      if (!((C[k]-ll)%11)&&i) {ll*=ll;i=0;}
X        for(i=1,j=0;j<4;j++)
X          for(k=0;k<011;k++,lll=(lll*6)%'%')
X            if (!((B[k]-lll)%'%')&&i){
X              for(l=0;l<6;l++)
X                n *= lll; 
X                lll*=n%'%';
X                i=0;
X              }
X  for(i=1,j=0;j<4;j++,l0l=(l0l*10)%101)
X    for(k=0;k<031;k++)
X      if (!((A[k]-l0l)%101)&&i){
X      l0l *= l0l;
X      i=0;
X     }
X  lll+='%'*(_-lll%3);
X  n  =      l00l;
X  n += '['*(4*(ll-n)%11)/*']'*/;
X  n +=      1001*(-'-'*(l0l-n)%101);
X  n +=     101101*('='*(lll-n)%111);
X  n +=    11222211*((s[12]-'0'-n)%012);
X  if ((n%=112222110)<0)
X       n+=112222110;
X           101101;
X            1001;
X  printf("%d\n",n); exit(0);
X            1001;
X}
END_OF_FILE
if test 1230 -ne `wc -c <'rot13/decrypt.c'`; then
    echo shar: \"'rot13/decrypt.c'\" unpacked with wrong size!
fi
# end of 'rot13/decrypt.c'
fi
echo shar: End of shell archive.
exit 0

