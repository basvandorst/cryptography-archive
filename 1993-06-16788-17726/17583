Path: msuinfo!agate!howland.reston.ans.net!gatech!destroyer!cs.ubc.ca!unixg.ubc.ca!unixg.ubc.ca!ramsay
From: ramsay@unixg.ubc.ca (Keith Ramsay)
Newsgroups: alt.privacy.clipper,sci.crypt,sci.skeptic
Subject: Re: Random numbers?
Date: 26 Jun 93 08:22:02 GMT
Organization: The University of British Columbia
Lines: 45
Message-ID: <ramsay.741082922@unixg.ubc.ca>
References: <22JUN93.12324416@vax.clarku.edu> <20734c$imv@uniwa.uwa.edu.au> <C93BI2.Mx@undergrad.math.uwaterloo.ca> <1993Jun24.002009.25209@husc3.harvard.edu> <C940GE.7Gz@blaze.cs.jhu.edu>
NNTP-Posting-Host: unixg.ubc.ca
Xref: msuinfo alt.privacy.clipper:977 sci.crypt:17583 sci.skeptic:47225

In <C940GE.7Gz@blaze.cs.jhu.edu> arromdee@jyusenkyou.cs.jhu.edu 
(Ken Arromdee) writes: 
|In article <1993Jun24.002009.25209@husc3.harvard.edu>
 kubo@zariski.harvard.edu (Tal Kubo) writes: 
|>arbitrary but fixed computing environment: a binary sequence is random if
|>the length of the shortest algorithm to generate the first  N bits is at
|>least N+c, for some constant c depending on the sequence.
|
|How can you tell whether or not a particular algorithm generates a particular
|series of N bits?  Isn't this undecideable?

You don't always tell. It's not Turing-computable, no.

Being random by this definition isn't, in general, decidable. One can
prove that a bit string is "random" by this definition only in a
formal system which is nearly as complex as the bit string is long, in
fact. So while relatively few strings are non-random, one can only
prove randomness for specific strings of limited length, in any
standard axiom system.

You can demonstrate this by using a diagonal argument. Write a program
which hunts exaustively for a proof in your formal axiom system
(Zermelo-Frankel set theory, what have you) that some string s is
random, where the length of s is >= some given N, and outputs the
first s which it finds, if any. If N is chosen large enough (>=the
length of the description of the formal system + some constant
overhead + log N bits to represent N), it is impossible that the
program will find such a proof and such an s. If it did, it would
itself be a program which generated s, and too short a one, implying s
is not in fact a random string. (Okay, it can happen. It would just
show that the original axiom system had to have been *incorrect*,
because there is a proof of a falsehood.)

This definition (by Kolmogoroff, wasn't it?) is considered pretty
"stern". Don't expect to base your cryptography on one-time pads using
provably Kolmogoroff-random strings. :-)

There's a cute result which says that there is an upper bound on how
many programs of minimal size there can be, which all generate the
same string!

Chaitin has some other cute stuff related to this.

Keith Ramsay
ramsay@unixg.ubc.ca
