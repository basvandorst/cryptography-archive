Newsgroups: sci.crypt
Path: msuinfo!uwm.edu!wupost!mont!mizzou1.missouri.edu!C445585
From: C445585@mizzou1.missouri.edu (John Kelsey)
Subject: Product ciphers with very weak round functions
Message-ID: <16BE5113FB.C445585@mizzou1.missouri.edu>
Sender: news@mont.cs.missouri.edu
Nntp-Posting-Host: mizzou1.missouri.edu
Organization: University of Missouri
Date: Sun, 06 Jun 93 19:37:30 CDT
Lines: 56

   I've been thinking of how it might be possible to come up with a proof
(or at least a good guess) of a minimum number of rounds needed for a
given product cipher (a cipher with multiple rounds) to be secure.  While
this seems pretty hard to do for something complex, like DES, FEAL-NX, or
IDEA, it may be possible for an encryption functions with a very weak
round function.
 
   I've been playing with this idea a bit, when I have time.  Three weak
round functions I've come up with:
 
A:  FLIP ONE BIT EACH TIME THROUGH THE ROUND FUNCTION
 
1.  Let Mask[] be a 32-element array of 32-bit masks, such that Mask[i]
    has only bit i set to one.
2.  Let Hash() be a hash function that reduces 33 bits to 5 bits in a
    nonlinear way.
 
For each encryption:
 
3.  Split the input into two halves, L and R.
4.  For i = 1 to NRounds:
    a.  L = L XOR Mask[Hash(R,K_i)    (Where , = concatenation, and K_i is
                                       the single-bit subkey for round i)
    b.  SWAP L,R
 
   This is the only one of these I've done much work on, and the minimum
number of rounds seems to be about 256 to get rid of any odd-looking
patterns.  However, I haven't done *lots* of testing on it.
 
B:  ADD and ROTATE LEFT for each round:
 
1.  Split the input block into L and R.
2.  For each round:               (K_i = 32-bit ith subkey)
    a.  L = L XOR (Rotate_Left_1( (R+K_i) mod 2**32 )
    b.  SWAP L,R
 
C:  INCREMENT ONE BIT AND ROTATE:
 
1.  Split the input block into L and R.
2.  Let Hash() be a function to hash 33 bits to one bit.
3.  For each round:               (K_i = 32-bit ith subkey)
    a.  L = Rotate_Left_1( (L+Hash(R XOR K_i)) mod 2**32)
    b.  SWAP L,R
 
   Can any of you see a reason why any of these is inherently weak or
patterned, no matter how many rounds there are?  I've really only spent
any time on the first one given, and I'm pretty sure that it can be secure
for a large enough number of rounds, and assuming the hash function used
is hard to predict/attack.  How about the other two?
 
   Again, I'd never recommend any of these as real encryption functions to
use, because they'd require so many rounds they'd be almost unusable, or
they'd be easily broken.  But I'm interested in comments about whether any
of them are inherently weak....
 
   --John Kelsey
