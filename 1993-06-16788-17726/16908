Path: msuinfo!agate!howland.reston.ans.net!xlink.net!sol.ctr.columbia.edu!news.kei.com!ddsw1!indep1!clifto
From: clifto@indep1.UUCP (Cliff Sharp)
Newsgroups: sci.crypt
Subject: Re: How to attack?
Message-ID: <2316@indep1.UUCP>
Date: 7 Jun 93 14:55:53 GMT
References: <2315@indep1.UUCP> <C87xy9.5E2@acsu.buffalo.edu>
Organization: as little as possible
Lines: 54

In article <C87xy9.5E2@acsu.buffalo.edu> boyd@acsu.buffalo.edu (Daniel F Boyd) writes:
>In article <2315@indep1.UUCP> clifto@indep1.UUCP (Cliff Sharp) writes:
>>    Also, just out of curiosity, can anyone point out the weaknesses (there
>> MUST be some) in the following algorithm...?
>[...]
>>      (Random number generator is "borrowed" and stands up to my meager
>>       tests as being VERY random.  64-bit number generated; I use the
>>       low-order 16 bits.)
>
>This is it.
>
>If the RNG is good enough, (say, DES in CFB mode with an IV that's
>derived from the key) then all you'd need to do would be to XOR the
>output with the plaintext.

   It's not THAT good (I think), but it seems to withstand any attack I can
think of against it.  (It's BDS C's "borrow" of an algorithm that was
implemented in hardware on an old CDC computer.)

>If the RNG is lousy, then the algorithm is lousy.

   Well, of course!  Just for fun I tried a really lousy RNG (something like
for (i = 0 to 10; randomnumber = string[i]; i++) ) and verified for myself
what I had suspected all along.  Obviously, all that produces is a
polyalphabetic cipher.

>If your RNG is a LFSR, it's going to be breakable.
>
>If you don't understand the acronyms I'm using, then you should get
>the Frequently-Asked-Questions list for this group and look in the
>bibliography; there are some good books there.  Most university
>libraries have a 'courtesy borrower' program, where you pay $50 for
>borrowing privileges.  You're apparently in Chicago; hardly a hick
>town.

   Watching for the faq to pass through here... (only missed LFSR)
   It's something like this:

1.  Get a key (7 to 127 chars, only ^X, ^M, ^H and ^? disallowed).
2.  Create a 64-bit seed using parts of the key and a few constants.
3.  For each RN:
	A.  Multiply a starting constant by the seed (64x64 bit).
	B.  Replace the starting constant with the high-order 64 bits
	     of the product, ORing it with 1 to ensure oddness (for
	     some reason, the BDS C comments said this is essential)
	C.  Return the low-order 16 bits of the new "constant" value.

   So far as I've been able to determine with my meager tests, it has a
period in the billions with a maximum repeated sequence of 5.
-- 
+------------------------------------------------------------------------------+
|   Cliff Sharp  |      clifto@indep1.chi.il.us   OR  clifto@indep1.uucp       |
|     WA9PDM     |                 Use whichever one works                     |
+------------------------------------------------------------------------------+
