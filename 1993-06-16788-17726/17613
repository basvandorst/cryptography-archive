Path: msuinfo!agate!howland.reston.ans.net!noc.near.net!uunet!think.com!enterpoop.mit.edu!eru.mt.luth.se!kth.se!hemul.nada.kth.se!md85-epi
From: md85-epi@hemul.nada.kth.se (Urban Koistinen)
Newsgroups: alt.security.pgp,sci.crypt
Subject: PRNG better than IDEA?
Message-ID: <1993Jun28.102332.19168@kth.se>
Date: 28 Jun 93 10:23:32 GMT
Sender: usenet@kth.se (Usenet)
Organization: Royal Institute of Technology, Stockholm, Sweden
Lines: 195
Nntp-Posting-Host: hemul.nada.kth.se
Xref: msuinfo alt.security.pgp:3401 sci.crypt:17613

Here is an implementation of the idea I posted earlier.
I think it could be useful in a commercial version of PGP as
the patent on IDEA might deter commercial use regardless of
validity on software.
One major bug has been fixed. (using the entire seed)
I believe it should be classified as a stream cipher.

If you have anything to say about this, please feel free to
post ot mail me.

Comments invited.

Enjoy!
/*
 * Copyright 1993 Urban Koistinen
 * I will release this under the GPL if anyone ask me to.
 *
 * jjcrypt - an example of a simple encryption algorithm that might
 * be very good if used properly.
 * Every key should be used only once or the result will be vulnerable
 * to the same attack as a OTP used more than once.
 * If you append a different word to the key each time you use it
 * the attack should be foiled. The appended word may be public, ie
 * added to the cyphertext.
 *
 * If the number of rounds is reduced to one, the strength is reduced
 * very much. If reduced to two, I don't know.
 * If the rounds are few, it might be good to use every other byte for
 * encryption rather than the first half as is done now.
 * With 64 rounds I think I can trust it.
 */

#include "stdio.h"

unsigned char table[128*128];
unsigned char buf[256];

void
init_tables(void)
{
  int i;

  i = 128;i=i*i;
  for (;i--;) table[i] = i&0xff;
  for (i=256;--i;)
   {
    buf[i] = "\
Buck Mulligan came from the stairhead, bearing a bowlof lather o\
n which a mirror and a razor lay crossed. A yellow dressinggown,\
 ungirdled, was sustained gently behind him by the mild morning \
air. He held the bowl aloft and intoned: -Introibo ad altare Dei\
"[i&0xff];
   }
}

void
round (void)
{
  unsigned int i;
  register unsigned int k;
  unsigned char a;

  k = 0x3ff&(buf[0] + (buf[1]<<8));

  for (i=256;i--;)
    {
      a = buf[i];
      a = (table[k]+a);
      buf[i] = a;
      k = a | (0x3f00 & (k<<8));
    }
  k = buf[0];
  for (i=256;i--;)
    {
      if (k!=i)
        {
	  k = (buf[i]+buf[k]) & 0xff;
          buf[i] = k;
	}
      else
        {
	  k = buf[i];
	}
    }
}

mix_table(void)
{
  int i,j;
  for (j=64;j--;)
  {
    printf ("\n%d:", j);
    for (i=128*128;i--;)
    {
      buf[i&0xff] += table[i];
      round();
      table[i] = buf[i&0xff];
      if ((i&0x3ff) == 0) printf("%d, ", i>>10);
    }
  }
}

void
load_key(unsigned char *key, int keysize)
{
  int i;
  int k;
  k= 0;
  for (i=256;i--;)
  {
    if (!k) k=keysize;
    --k;
    buf[i] = key[k];
  }
}

void
encrypt (FILE *in_file, FILE *out_file, int rounds)
{
  int c, i, k;
  for (;;)
  {
    for (i=rounds;i--;) round();
    for (i=128;i--;)
    {
      c = getc(in_file);
      if (c<0) return;
      c = (c^buf[i]) & 0xff;
      fputc(c, out_file);
    }
  }
}

main(int argc, char *argv[])
{
  FILE *f1, *f2;
  int i;

  init_tables();
#ifdef MSDOG
  f1 = fopen("jjcrypt.rnd","r+b");
#else
  f1 = fopen("jjcrypt.rnd","r");
#endif
  if (f1 == NULL)
  {
    printf ("Could not open \"jjcrypt.rnd\"\n");
    printf ("Recreating it\n");
    mix_table();
#ifdef MSDOG
    f1 = fopen("jjcrypt.rnd","w+b");
#else
    f1 = fopen("jjcrypt.rnd","w");
#endif
    for (i=128*128;i--;)
      fputc(table[i], f1);
    fclose (f1);
  }
  else
  {
    for (i=128*128;i--;)
      table[i] = getc(f1);
    fclose(f1);
  }
  if (argc != 4)
  {
    printf ("Usage: jjcrypt <key> <infile> <outfile>\n");
    exit (1);
  }
#ifdef MSDOG
  f1 = fopen (argv[2],"r+b");
#else
  f1 = fopen (argv[2],"r");
#endif
  if (f1 == NULL)
  {
    printf ("Couldn't open \"%s\" for reading.\n", argv[2]);
    exit (1);
  }
#ifdef MSDOG
  f2 = fopen (argv[3],"w+b");
#else
  f2 = fopen (argv[3],"w");
#endif
  if (f2 == NULL)
  {
    printf ("Couldn't open \"%s\" for writing.\n", argv[3]);
    exit (1);
  }
  load_key(argv[1], (strlen(argv[1])));
  encrypt(f1, f2, 64);
}
-- 
Urban Koistinen - md85-epi@nada.kth.se
Stop software patents, interface copyrights:  contact lpf@uunet.uu.net
