Path: msuinfo!uwm.edu!cs.utexas.edu!not-for-mail
From: boucher@csl.sri.com (Peter K. Boucher)
Newsgroups: sci.crypt
Subject: Big Block Cipher (256K blocks)
Date: 17 Jun 1993 16:32:05 -0500
Organization: UTexas Mail-to-News Gateway
Lines: 123
Sender: daemon@cs.utexas.edu
Message-ID: <9306172132.AA07770@hydra.csl.sri.com>
NNTP-Posting-Host: cs.utexas.edu

Following is an excerpt from the encryption subroutine of a module
I've been playing around with.  Please email comments to boucher@csl.sri.com
even if you post them, because our newsfeed is buggy.

Note: The three PRNGs are LFSR's based on three different irreducible
trinomials:
  X**1289 + X**242 + 1 -- combined with input using substitution tables
  X**1223 + X**588 + 1 -- combined with output of above using different tables
  X**431  + X**200 + 1 -- maintains tables and transposes output of above


/* 
 * ========================================================================
 * ========== Encryption Subroutine =======================================
 *
 * int bbc_crypt(infile, outfile, key1, key2, key3, ENCRYPT)
 *     FILE *infile, *outfile;
 *     long key1, key2, key3;
 *     int ENCRYPT;
 *
 * This subroutine is the encryption engine.  The routine reads blocks of
 * input that are 262144 bytes in size.  For each 256K block:
 *
 *   a) Each byte of the block is combined with the output of a PRNG,
 *      using a set of substitution tables, and using cipher-text feedback,
 *      in ASCENDING order, so that each output depends on all PREVIOUS
 *      input bytes of THE ENTIRE MESSAGE.
 *
 *   b) Each byte of the block is combined with the output of a second
 *      PRNG, using a second set of substitution tables, and using cipher-
 *      text feedback, in DESCENDING order, so that each output depends on
 *      all SUBSEQUENT input bytes of THIS BLOCK (and again, on all
 *      output bytes in all previous blocks).
 *
 *   c) The block is "shuffled" using a transposition algorithm posted
 *      to USENET by Carl Ellison (with a modified interface).
 *
 * Decryption reverses the process:  a) transposition, b) descending
 * PRNG combination and substitution, and c) ascending PRNG combination
 * and substitution.  Note: no brute-force mechanized clear-text recognizer
 * will work until the first two decryption passes are completed on an entire
 * 256K block, and the final pass is completed on at least a few bytes.
 *
 * A third PRNG is used to "randomize" the substitution tables, and to
 * perform the transpositions.  The key to this encryption algorithm
 * consists of three 32-bit seeds for the three PRNGs.  Thus, the
 * total key size is 96 bits.  Brute force attacks are hindered by
 * the large block size and the large key size.  Cryptanalysis is
 * hindered by the large block size, with every byte in the output
 * block depending on every byte in the input block (and all
 * previous input blocks), and also by the transposition.  The
 * cryptographic strength of the PRNGs is crucial to the strength
 * of this system.
 *
 * ======================================================================== */
int bbc_crypt(infile, outfile, key1, key2, key3, ENCRYPT)
FILE *infile, *outfile;
long key1, key2, key3;
int ENCRYPT;
{
  /* stuff gone
    .
    .
    . */

    while ((len = fread(io_buf,1,BLOCKSIZE,infile)) > 0) {
	refresh_sub_tab(e_sub_table_1a, d_sub_table_1a);
	refresh_sub_tab(e_sub_table_1b, d_sub_table_1b);
	refresh_sub_tab(e_sub_table_1c, d_sub_table_1c);
	refresh_sub_tab(e_sub_table_2a, d_sub_table_2a);
	refresh_sub_tab(e_sub_table_2b, d_sub_table_2b);
	refresh_sub_tab(e_sub_table_2c, d_sub_table_2c);
	refresh_repl_tab(repl_table_1a);
	refresh_repl_tab(repl_table_1b);
	refresh_repl_tab(repl_table_2a);
	refresh_repl_tab(repl_table_2b);
	if (ENCRYPT) {
	    for (i=0; i<len; i++) {
		feedback = cipher_text1;
		cipher_text1 = io_buf[i] =
		  e_sub_table_1a[repl_table_1a[crnd1()]^
		                 e_sub_table_1b[e_sub_table_1c[io_buf[i]]^
		                                repl_table_1b[feedback]]];
	    } 
	    for (i=len-1; i>=0; i--) {
		feedback = cipher_text2;
		cipher_text2 = io_buf[i] =
		  e_sub_table_2a[repl_table_2a[crnd2()]^
		                 e_sub_table_2b[e_sub_table_2c[io_buf[i]]^
		                                repl_table_2b[feedback]]];
	    }
	    transpose_buf(io_buf, len);
	} else { /* DECRYPT reverses the steps. */
	    transpose_buf(io_buf, len);
	    for (i=len-1; i>=0; i--) {
		feedback = cipher_text2;
		cipher_text2 = io_buf[i];
		io_buf[i] =
		  d_sub_table_2c[repl_table_2b[feedback]^
		                 d_sub_table_2b[d_sub_table_2a[io_buf[i]]^
		                                repl_table_2a[crnd2()]]];
	    }
	    for (i=0; i<len; i++) {
		feedback = cipher_text1;
		cipher_text1 = io_buf[i];
		io_buf[i] =
		  d_sub_table_1c[repl_table_1b[feedback]^
		                 d_sub_table_1b[d_sub_table_1a[io_buf[i]]^
		                                repl_table_1a[crnd1()]]];
	    }
	}
	if (fwrite(io_buf, 1, len, outfile) != len) {
	    fprintf(stderr, "Error writing output.  Abort.\n");
	    exit(1);
	}
    }

  /* stuff gone
    .
    .
    . */

}
