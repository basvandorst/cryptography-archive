Newsgroups: sci.crypt
Path: msuinfo!uwm.edu!spool.mu.edu!howland.reston.ans.net!europa.eng.gtefsd.com!emory!athena!groucho.dev.uga.edu!is
From: is@groucho.dev.uga.edu (Bob Stearns)
Subject: Re: Cryptoanalysis of Compressed Text
Message-ID: <C9GEEF.CAq@athena.cs.uga.edu>
Sender: usenet@athena.cs.uga.edu
Nntp-Posting-Host: groucho.dev.uga.edu
Organization: University of Georgia, Athens
References: <20sk9bINNkcv@twain.ucs.umass.edu> <jimn8C9GB3F.G98@netcom.com>
Date: Wed, 30 Jun 1993 21:30:14 GMT
Lines: 96

In article <jimn8C9GB3F.G98@netcom.com> jimn8@netcom.com (Jim Nitchals) writes:
>quilty@twain.ucs.umass.edu (Lulu of the lotus-eaters) writes:
>
>>Can someone give me a short sketch of the cryptoanalytic techniques
>>which could be used to break even simple encryptions of compressed
>>files.  The reason it occurs to me to ask is simply because it is
>>apparently the nature of compression like Lempel-Ziv to eliminate
>>recognizable plaintext features like character frequency distributions
>>and digram, trigram, etc frequencies.  If I understand things
>
>I recommend that you look at an LZ encoded file.  The compression
>doesn't kick in effectively until some amount of plaintext is
>encoded inefficiently.  The entropy of the first few bytes of an LZ
>file is very low for typical text.
>
>If you were designing a compression algorithm from scratch to cause
>the data to look random, even from the beginning, you might want to
>preload the dictionary with some known similar plaintext.
>
>Last but not least, the headers of standard compressed data formats
>are *VERY* predictable.  ZIP files will always begin with:
>[50] [4B] [03] [04].  If you're trying to break data you believe may
>have been encoded with ZIP, just look for those bytes.
>
>The key to using compression as a means of obscuring your data from
>an attack would be to design the format yourself, and do it right.
>Both LZ77 and LZ78 contain obvious redundancies in the initial output.
>
>Keep in mind that if an opponent has both encrypted file 'a', and
>unencrypted plaintext 'b' (even if 'b' is compressed in some cool
>format) then an attack doesn't require any cleverness.  A good
>encryption format should be able to withstand an attack when a
>sample of the encrypted data and plaintext are both available.
>
>[portions deleted]
>>
>>Yours, Lulu...
>>-- 
>>      _/_/_/ THIS MESSAGE WAS BROUGHT TO YOU BY: Postmodern Enterprises _/_/_/ 
>>     _/_/    ~~~~~~~~~~~~~~~~[quilty@philos.umass.edu]~~~~~~~~~~~~~~~~~  _/_/ 
>>    _/_/  The opinions expressed here must be those of my employer...   _/_/ 
>>   _/_/_/_/_/_/_/_/_/_/ Surely you don't think that *I* believe them!  _/_/ 
>-- 
>                                             
>-- Jim Nitchals <jimn8@netcom.com>

Actually, it appears that a couple of not necessarily cryptographically
strong pseudorandom number generators, whose seeds are in effect the
keys of the process, can be used in conjunction with an LZ compressor to
make a virtually invulnerable crypto system. The method answers all of
the objections indicated by Nitchals, and decrypting by brute force one
message does not help on decrypting any other message. 

There is available from the net a program which will input a text file,
compute its word-to-word(letter-to-letter) transition probability table 
and output a text with the same words(letters) and a similar transition 
table. It is commonly called TRAVESTY.

LZ compressors have a property such that any text prefixed by Z
compresses to a string with a prefix Z'; that is that nothing after a
character in the original text affects that character's representation
in the compressed text.

Let us assume that you and your correspondent have retained some subset
of your common traffic, say M_1, M_2, ..., M_k.

To encrypt a message M, use your random number with the known seed a
known number of times to select M_i.

Use TRAVESTY, using your other random number seed, to generate a pseudo
message M_s.

Compress M_s, giving P.

Append M to M_s and compress the result giving Q.

Remove P from the beginning of Q giving R.

If you desire, encrypt R with almost any method giving R'.

Transmit either R or R'.

The decoding proceeds in reverse, requires the knowledge of the randome
number generator seeds, their application in the algorithms, the entire
message base M_1-M_k, how it is maintained, and, if used, the final
encryption key (I recommend a simple PRNG-XOR scheme would be strong
enough).

All of the programs are small enough, easy enough to use, and commonly
available to make a totally uncrackable system for even small PCs.

-- 
Bob Stearns
University of Georgia
is@groucho.dev.uga.edu
(706)542-5110
