Newsgroups: sci.crypt
Path: msuinfo!agate!howland.reston.ans.net!xlink.net!math.fu-berlin.de!jiri
From: jiri@spider.chemie.fu-berlin.de (Jiri Pittner)
Subject: Re: Pseudo-Random number encryption - how secure?
Message-ID: <JQREB0VC@math.fu-berlin.de>
Sender: news@math.fu-berlin.de (Math Department)
Organization: Free University of Berlin, Germany
References: <207hg4$92p@donald.cc.utexas.edu> <208gmsINNici@umbc7.umbc.edu>
Date: Fri, 25 Jun 1993 10:30:44 GMT
Lines: 71

olson@umbc.edu (Bryan G. Olson) writes:


>In article <207hg4$92p@donald.cc.utexas.edu>, ifbb657@donald.cc.utexas.edu (Doug) writes:
>|> 
>|> I am planning to use this algorithm for sending stuff through to
>|> a friend of mine:
>|> 
>|> U(n+1)=pUn(1-Un) where p is near 4, and Un is a number between
>|> 0+ and 1. U(n+1) is the output of the function.
>|> 
>|> From what I know, this will give me a chaotic, nonrepeatable solution
>|> that when normalized between 0 and 255 and XORed with data, will
>|> be decent for encryption.  Am I deluding myself?  What is this algorithm's
>|> main weakness?


>Unless I'm missing something major, this is very simple to break.
>I'm assuming Un is U(n) and you compute each ouput from the previous
>output, and you encrypt one byte for each element of the sequence.

>The biggest problem is that small changes in Un result in small changes
>in U(n+1).

>Suppose the (normalized) output is 76.  The least n could be at this
>point is 76/256 and the most it could be is still less than  77/256.  
>The only possible values for the next output are 215 and 216,
>(and 216 is more likely).  If I can guess one byte I know the 
>next with less than one bit of uncertainty.  Dictionary attacks will
>easilly expose text encrypted this way.

>As I find bytes n+1 and n+2 ect, I can aproximate n more and more 
>accurately.  Once I have it to as many bits as you use, I can
>stop using the dictionary.

>There are some obvious things you might suggest to improve the system,
>like only use every twentieth n to encrypt a byte, but I don't think
>this sort of system is very promising.  Remember that you are never
>really working with real numbers.  If you are using 64 bit reals,
>then what you really have is some discrete function from 64 bit strings
>to 64 bit strings.  With a function like DES, the cryptanalyst has to
>attack it as a bunch of complicated operations on bits.  A function
>which aproximates a real to real function can be attacked the same way,
>but also has another mathematical interpretation which may be useful
>to the analyst, as it was here.

>Bryan Olson
>olson@umbc.edu

I think the chaotic systems are good for generation of one time pads - 
just it must not be 'normalized' but taken say one byte from the least
significant bits of double or better quadruple precission representation
of real number. Such generator could have long period and once the 'rest
of the number' is forgotten and only one byte from 8/16 ones is used
for the constructiuon of the OTP, it is not possible to predict next byte.
Also several such generators can run simultaneously, xoring the bytes
generated by them. 
But it is not useful to encryption with short password, because of
non-portability of real numbers representation and because of different
roundings in real arithmetics on different computers, which would very soon
due to the properties of chaotic generators generate completely different
sequences on different computers.

Do you agree?

Jiri Pittner

--
-------------------------------------------------------------------------------
Jiri Pittner
jiri@hpsiepsi.chemie.fu-berlin.de
