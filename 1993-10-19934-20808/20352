Path: msuinfo!uwm.edu!math.ohio-state.edu!usc!randvax!aja.rand.org!jim
From: jim@rand.org (Jim Gillogly)
Newsgroups: sci.crypt,alt.security.pgp
Subject: Re: PASSPHRASE FAQ
Message-ID: <29f1ch$6fd@aja.rand.org>
Date: 12 Oct 93 19:43:13 GMT
References: <13486.492.uupcb@grapevine.lrk.ar.us> <1993Oct12.182448.9893@ntg.com>
Organization: Banzai Institute
Lines: 33
NNTP-Posting-Host: mycroft.rand.org
Xref: msuinfo sci.crypt:20352 alt.security.pgp:5549

Regarding my implementation of the Secure Hash Algorithm:

In article <1993Oct12.182448.9893@ntg.com>, Dave Platt <dplatt@ntg.com> wrote:
>>#define S(n, X) ((X << n) | (X >> (32 - n)))    /* Barrel roll */
>
>Poor implementation.  C allows the >> operator to do _either_ a logical
>right shift (zero fill on the left) or an arithmetic shift (sign-extend
>on the left).  The choice of which shift is actually implemented is up
>to the compiler writer, and usually depends on the architecture of the
>target machine.

I quote from Kernighan and Ritchie's "The C Programming Language", App. A.

    The value of E1<<E2 is E1 (interpreted as a bit pattern) left-shifted
    E2 bits; vacated bits are 0-filled.  The value of E1>>E2 is E1
    right-shifted E2 bit positions.  The right shift is guaranteed to be
    logical (0-fill) if E1 is unsigned; otherwise it may be (and is, on
    the PDP-11) arithmetic (fill by a copy of the sign bit).

They make the same point in the text under "Bitwise Logical Operators",
section 2.9 in my edition:

    Right shifting an unsigned quantity fills vacated bits with 0.  Right
    shifting a signed quantity will fill with sign bits ("arithmetic shift")
    on some machines such as the PDP-11, and with 0-bits ("logical shift")
    on others.

Since my code invokes the S macro only with unsigned longs as values of X,
I'm guaranteed a 0 fill.  Any compiler that behaves as you describe for
unsigned values is non-compliant.
-- 
	Jim Gillogly
	Highday, 21 Winterfilth S.R. 1993, 19:43
