Path: msuinfo!agate!howland.reston.ans.net!pipex!uunet!munnari.oz.au!metro!atom.ansto.gov.au!teslab!andrew
From: andrew@teslab.lab.oz.au (Andrew Phillips)
Newsgroups: sci.crypt,comp.security.misc
Subject: Checking that code has not been modified?
Message-ID: <4795@teslab.lab.oz.au>
Date: 14 Oct 93 07:35:30 GMT
Followup-To: sci.crypt
Organization: Technology Services, Chief Secretary's Dept, Sydney
Lines: 48
Xref: msuinfo sci.crypt:20406 comp.security.misc:5681

We have a need to check that EPROMs in sensitive devices are not
modified for security reasons.  We are aware of a device that is made
in the US (called a Kobetron?) that is supposed to perform such a
task.  It works by generating a "signature" (of eight hex digits) for
an EPROM which if it is correct verifies that the EPROM has not been
tampered with.  I believe this device works using a CRC.

Although, a CRC is excellent for detecting noise, random errors etc,
I believe that if it was known how the Kobetron worked it would be
quite easy to generate an EPROM that had different contents but still
had the same signature.  For example, certain critical parts of the
EPROM could be modified and then other unused parts also changed to
give the same signature.

We need to develop software (plus possibly custom hardware) which
could be used to easily and confidently determine if an EPROM's
contents had been modified.  Someone here suggested the CRC idea
could be improved by using larger CRCs and generating both forward
and backward CRCs to create a "signature".

My gut feeling is that any signature using CRCs could be readily
faked.  I also had a gut feeling that public key cryptography could
be the solution and after reading the Cryptography FAQ of sci.crypt I
have a rough idea of how, as explained here.

Create a one-way hash of the (authentic) EPROM.  Use this to verify
EPROMs in the field.  From my understanding of the FAQ there are
one-way hash functions where it is impossible to create messages
which have the same hash value even if you know the original message
and the hash value.  But it seems to me that, at least for small hash
values (which would be best for practical reasons) a brute force
(trial and error) method could be used to produce a message with the
same hash as the original.

Also I am not sure whether it would be better to use digital
signatures which have (according to the FAQ) private hashing unlike
the above which uses public hashing.  (Actually I'm a bit vague on
the difference between one-way hash functions and digital signatures.)

Does anyone have any comments or suggestions on the feasibility of
the above?  I hope I have explained myself clearly.  I would be very
appreciative of any replies.

Andrew.

PS Followups to sci.crypt.
-- 
Andrew Phillips (Sys/News Admin)  andrew@teslab.lab.oz.au  (02) 287 6551
