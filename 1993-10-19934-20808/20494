Newsgroups: sci.crypt
Path: msuinfo!agate!howland.reston.ans.net!pipex!uknet!pavo.csi.cam.ac.uk!nmm
From: nmm@cl.cam.ac.uk (Nick Maclaren)
Subject: Re: What are the best random numbers for genetic algorithms (was: Re: GA random no. gen.
Message-ID: <1993Oct18.122228.24535@infodev.cam.ac.uk>
Sender: news@infodev.cam.ac.uk (USENET news)
Nntp-Posting-Host: ely.cl.cam.ac.uk
Organization: U of Cambridge Computer Lab, UK
References: <9310132045.AA27577@redwood.csl.sri.com> <CEyDr3.LwK@ryn.mro4.dec.com>
Date: Mon, 18 Oct 1993 12:22:28 GMT
Lines: 65

In article <CEyDr3.LwK@ryn.mro4.dec.com>, roth@3d.enet.dec.com (Jim Roth) writes:
|> 
|> In article <9310132045.AA27577@redwood.csl.sri.com>, boucher@csl.sri.com (Peter K. Boucher) writes...
|> >|> No way, I am afraid.  I have some papers and other in the pipeline that show
|> >|> this is not a safe combination.  All right, your chances of being badly
|> >|> caught are low, but there are some major flaws.  Also note that Marsaglia
|> >|> does not recommend additive congruential generators on their own, but adds
|> >|> them to something else (modulo 1).
|> 
|> >Hi.  I wrote an additive congruential generator that is based on an 
|> >irreducible trinomial (X^1361 + X^378 + 1).  It keeps 1361 longs worth 
|> >of state (plus a few pointers).  Could you please tell me what's wrong 
|> >with it, and where I can get something better?
|> 
|> The problem is after you've seen 1361 longs worth of the stream,
|> you can predict forwards and backwards in time.  Even just outputing
|> the high k bits of n bit internal state per array element doesn't
|> really solve the problem since the stream is still easy to predict.

No, that isn't the problem for genetic algorithms.  Remember that simulation
has an unintelligent opponent.  The problem is that the stream is partially
predictable by accident, and you get long streams of simple patterns with
this sort of generator.  If you hit one by accident, you can be in trouble.

|> Suggestions involving xoring the output of two streams with
|> relatively prime periods will help, as will shuffling the output
|> of one stream with another, but the problem is still that the
|> nonlinearity is only applied in a simple way.

Yes, quite, for both cryptanalysis and simulation.
 
|> Cryptographically strong generators should have a much higher degree
|> of nonlinearity with care taken that the bits are reasonably
|> unbiased, though I do not know of any general results of, say,
|> the difficulty of breaking the case of one generator shuffling the
|> output of another.

Nor do I, but I have one paper on some simulation aspects!  Shuffling helps
only if your problem is local predictability, and does not improve all
generators.  In particular, it helps with additive generators only if a
very large table is used.
 
|> In fact, I don't know if merely using one pseudo random bit stream to
|> decide on dropping bits output by another with relatively prime period
|> would be secure or not - I've heard of such jittering schemes being
|> suggested.  This would clearly be a really fast way to generate a good
|> bitstream if it was viable, though you'd need a fifo to handle the
|> somewhat unpredictable availability of the next bit...

Like shuffling, this helps only in some cases.  In particular, it will help
with additive generators only if a very large proportion of bits are dropped.
Exclusive ORing bits with another generator based on different principles
is a much better way of resolving this problem for simulation.

Also, my guess is that the 'data cleaning' people will know something of how
to decrypt data that has had bits dropped by jittering - it is certainly a
known problem in the communications area.

Nick Maclaren
University of Cambridge Computer Laboratory,
New Museums Site, Pembroke Street,
Cambridge CB2 3QG, England.
Email:  nmm@cl.cam.ac.uk
Tel.:   +44 223 334761
Fax:    +44 223 334679
