Newsgroups: sci.crypt
Path: msuinfo!agate!howland.reston.ans.net!math.ohio-state.edu!cs.utexas.edu!cactus.org!ritter
From: ritter@cactus.org (Terry Ritter)
Subject: Re: What are the best random numbers for genetic algorithms (was: Re: GA random no. gen.
Message-ID: <1993Oct17.073805.22511@cactus.org>
Organization: Capital Area Central Texas UNIX Society, Austin, Tx
References:   <9310132045.AA27577@redwood.csl.sri.com> <CEyDr3.LwK@ryn.mro4.dec.com>
Date: Sun, 17 Oct 1993 07:38:05 GMT
Lines: 153


 In <CEyDr3.LwK@ryn.mro4.dec.com> roth@3d.enet.dec.com (Jim Roth)
 writes:

      In <9310132045.AA27577@redwood.csl.sri.com>
      boucher@csl.sri.com (Peter K. Boucher) writes:

>>Hi.  I wrote an additive congruential generator that is based on an
>>irreducible trinomial (X^1361 + X^378 + 1).  It keeps 1361 longs worth
>>of state (plus a few pointers).  Could you please tell me what's wrong
>>with it, and where I can get something better?
>
>The problem is after you've seen 1361 longs worth of the stream,
>you can predict forwards and backwards in time.

 Yes.  Every cryptographic RNG should have a layer of isolation
 between the RNG and the use of the RNG.


>Even just outputing
>the high k bits of n bit internal state per array element doesn't
>really solve the problem since the stream is still easy to predict.

 I guess it depends upon the meaning of "easy."  Certainly the
 lower k-n bits do in fact frequently influence the upper k bits in
 an Additive RNG.  It seems to me that anyone attempting to solve
 the RNG will have to somehow develop those hidden values.  My
 guess is that this would multiply the solution effort by a factor
 of 2 for each hidden bit-column.  Not an overwhelming factor,
 perhaps.

 Of course, when used as the *only* isolation technique, we can't
 expect the "hidden" bits to be particularly effective.


>[...]
>In fact, I don't know if merely using one pseudo random bit stream to
>decide on dropping bits output by another with relatively prime period
>would be secure or not - I've heard of such jittering schemes being
>suggested.

 I implemented an "element drop" scheme in CLOAK and described it
 in my 1991 RNG paper; I call the mechanism a "Jitterizer" because
 it introduces "asynchronousness" into a previously synchronous
 process.  When this sort of thing is observed on an oscilloscope,
 the trace is said to "jitter."

 Basically, the idea is to generate a linear feedback sequence
 (thus having a mathematical basis for a huge--in fact unmeasurable--
 cycle-length), and then "drop" some values from the linear sequence
 at pseudo-random.

 My measurements detect no pattern in the resulting sequence, but
 I expect that these designs are far beyond what we can ask
 general statistics to do.  If we had some attack, statistics could
 indicate success, but without an attack, we can't hope for much.

 In the Jitterizer, I grab the first RNG value and use two bits to
 indicate how many elements (1..4) from the sequence to "skip," and
 six bits to indicate how many elements (1..64) to "take" in the
 next take-group.  Then I grab another value as an "offset" which
 is XORed with all elements of the next take group.

 Note that we can still make specific claims about the length of
 the resulting sequence, something which is very difficult with a
 fundamentally-nonlinear RNG design.  (The fact that we have any
 theoretical basis at all for strength is actually somewhat novel.)

 (Consider the Blum, Blum & Shub RNG, the X^2 mod N operation,
 which is provably secure only if X0--the original seed--is on a
 cycle of a specific theoretical length.  This means that the RNG
 cannot be initialized arbitrarily, and extensive pre-computation
 is required to find the relatively-rare cycles of the necessary
 length.  Implementations which do not do this are not BB&S.)

 Since all the RNG values are likely to have been changed by the
 changing Jitterizer offset, it seems clear the trivial attack is
 foiled completely, and that the result is a stronger design.  Since
 we cannot *measure* "strength," it would be inappropriate to ask
 "how *much* stronger," but we *can* consider whether any particular
 attack would be successful and if so how much work it would require.
 (I am not aware of any such attack.)

 It would be foolish to rely on the Jitterizer for main strength.
 In my view there *can be* no simple mechanism--in particular, no
 fast RNG--which can deliver values indefinitely without risk of
 external analysis.  On the other hand, we *can* work to maximize
 the ratio of the internal state to the generated sequence.

 In my stream ciphers the Jitterizer is perhaps the last wall of
 the overall fortress.  In CLOAK, for example, I have two levels of
 nonlinear combining for each data byte, and the second combiner is
 selected from among 16.  (Note that having multiple levels of
 linear combiner would be useless.)  Each 8-bit data byte is
 combined with 20 Jitterized bits.  Thus, no single byte (or small
 set of bytes, hopefully) can reveal their associated combining
 bytes because 8 ciphertext bits simply does not carry sufficient
 information to resolve 20 combining bits.  And 12 RNG bit-columns
 remain unused and hidden, resolvable only through deviations
 observed when the "exposed" RNG bit-columns would have otherwise
 been resolved.

 Of course the nonlinear combining does hide the pseudo-random
 sequence better than XOR because "known plaintext" does not
 immediately reveal the confusion sequence like it would with XOR.
 And without access to the Jitterizer stream it is going to be
 tough to develop the hidden RNG state no matter what.  (On the
 other hand, nonlinear combiners are no panacea; they are just
 much better tools.)

 In CLOAK, the combiners themselves are initialized under control
 of the Jitterizer; the RNG is initialized from a 124-byte message
 key, and the RNG can be degree-11213 9-nomial with 43KB of internal
 state.  Each message gets a new, random, 124-byte message key
 (thus, different combining state and different RNG state), which
 is the only thing enciphered under the User Key phrase.  So The
 Opponent has exactly one message to use in breaking a particular
 cipher with a particular 43K+ of internal state, and as long as
 they cannot develop the 124-byte message key cipher (which protects
 only random numbers) they get to do it all over again next time.

 The Jitterizer is but a small part of the story.



>This would clearly be a really fast way to generate a good
>bitstream if it was viable, though you'd need a fifo to handle the
>somewhat unpredictable availability of the next bit...

 Not unless you are into real-time stuff (voice? video?).  Normally,
 the Jitterizer stands as an intermediate level with some local
 state.  While "taking" it just calls the lower RNG for a value,
 XORs the result with the latest offset value, and returns.  When
 "skipping" it just calls the RNG the indicated number of times,
 then twice more for new skip and offset values, does the first
 "take" of the next group, and returns.

 As to the generation being "fast," clearly, the Jitterizer logic
 does introduce overhead:  Even though the logic is simple, the
 underlying RNG is fast, making the Jitterizer logic a
 significant overhead.

 On the other hand, the alternatives seem fairly grim:  If we do
 much processing between the RNG and combiner, we can easily lose
 the good distribution expected from the RNG, as well as speed.
 To do nothing is to leave the RNG open to trivial attack.  And
 I am not aware of a faster, better RNG with large state, long
 cycles and arbitrary initialization.


 ---
 Terry Ritter   ritter@cactus.org

