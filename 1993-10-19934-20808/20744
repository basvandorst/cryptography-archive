Path: msuinfo!agate!ucbvax!silverton.berkeley.edu!djb
From: djb@silverton.berkeley.edu (D. J. Bernstein)
Newsgroups: sci.crypt
Subject: Re: Computer Shopper Challenge
Message-ID: <20310.Oct2723.16.0893@silverton.berkeley.edu>
Date: 27 Oct 93 23:16:08 GMT
References: <1993Oct25.205136.27970@kth.se> <PCL.93Oct26173347@rhodium.ox.ac.uk> <CFJBDE.7Dt.3@cs.cmu.edu> <1993Oct27.083012.7668@kth.se>
Organization: IR
Lines: 63

In article <1993Oct27.083012.7668@kth.se> md85-epi@hemul.nada.kth.se (Urban Koistinen) writes:
> I guess there are more effiecient known plaintext attacks that are
> needed if the constants vary. (I won't do that this week)

For amusement value: Here's a known-plaintext attack on cipher.c with 
the given multiplier. It should be somewhat faster than brute force.
Knuth (exercise 3.6, as I recall) points out that a similar attack works 
even if the multiplier and adder are unknown.

(If someone did ``cipher key in out'', you do ``breakcipher in out''.)

---Dan

/* breakcipher.c */
#include <stdio.h>
/* i wrote this program in an hour. it's horrendous. don't even read it. */
/* tested, very briefly, under bsdi's bsd/386. */

#define M 0x015A4E35L
#define USE 0x00ffffffL
#define HID 0x00010000L /* better be able to make arrays this big! */
#define IN 10 /* way more than we need; 4 is always enough */

long minv; findminv()
{ long j; minv = 1; for (j = 2;j & USE;j += j) if ((M * minv) & j) minv += j; }

long y[IN]; long mz[HID]; long mzd[HID]; char ok[HID]; char oldok[HID];
char poss[256];

main(argc,argv) int argc; char **argv;
{
 long i; long j; long k; long t; FILE *fi1; FILE *fi2;

 if (!argv[1]) { printf("arg 1?!\n"); exit(1); }
 if (!argv[2]) { printf("arg 2?!\n"); exit(1); }
 fi1 = fopen(argv[1],"r"); if (!fi1) { printf("file 1?!\n"); exit(1); }
 fi2 = fopen(argv[2],"r"); if (!fi2) { printf("file 2?!\n"); exit(1); }

 for (i = 0;i < IN;++i) y[i] = (getc(fi1) ^ getc(fi2)) & 255;

 mz[0] = 0; for (i = 1;i < HID;++i) mz[i] = M + mz[i - 1];
 for (i = 0;i < HID;++i) mzd[i] = (mz[i] >> 16) & 255;
 for (i = 0;i < HID;++i) ok[i] = 1; for (i = 0;i < 256;++i) poss[i] = 0;
 poss[255] = 1; poss[0] = 1; poss[1] = 1;

 for (i = 0;i < IN - 1;++i)
  {
   t = (y[i + 1] - M * y[i]) & 255;
   for (j = 0;j < HID;++j) if (ok[j]) if (!poss[(mzd[j] - t) & 255]) ok[j] = 0;
   k = 0; for (j = 0;j < HID;++j) k += ok[j]; if (k == 1) break;
   for (j = 0;j < HID;++j) oldok[j] = ok[j];
   for (j = 0;j < HID;++j) ok[(mz[j] + 1) & 65535] = oldok[j];
  }

 if (i == IN - 1) { printf("i don't think any key will work\n"); exit(1); }

 for (k = 0;k < HID;++k) if (ok[k]) break; k += y[i] << 16;
 printf("given the first %d characters, ",i + 2);
 findminv(); while (i >= 0) { k = (k - 1) * minv; --i; }
 printf("i think key %d will work\n",k & USE);

 exit(0);
}
