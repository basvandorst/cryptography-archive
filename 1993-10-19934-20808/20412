Path: msuinfo!uwm.edu!caen!malgudi.oar.net!witch!cyberg!fb
Newsgroups: sci.crypt,sci.math
Message-ID: <15@cyberg.win.net>
References: <CErF0o.4nA@chinet.chinet.com><29fg2e$55o@news.delphi.com> <14@cyberg.win.net><29icje$3eu@news.delphi.com>
Reply-To: fb@cyberg.win.net (Francis Barrett)
From: fb@cyberg.win.net (Francis Barrett)
Date: Thu, 14 Oct 1993 15:21:53 GMT
Subject: Re: Digits of pi
Lines: 55
Xref: msuinfo sci.crypt:20412 sci.math:54701

 
In article <29icje$3eu@news.delphi.com>,
ANSPRING@DELPHI.COM (anspring@news.delphi.com) writes:

 > Do you know an FTP site that has a multi-precision _float_
 > package available?  All the ones I've seen have just integers.

I know of no FTP site offhand for such software.  The numbers are not
really floating point.  They are just very large multi-precision
scaled integers with an assumed decimal point in an appropriate
location.

 > I read about the scheme you just outlined in a Scientific
 > American article some years back

The experts on this particular method of Pi computation are Jonathan
and Peter Borwein at Dalhousie University in Halifax, Nova Scotia.  I
believe they wrote the Scientific American article on the subject.
They also authored a book titled "Pi and the AGM: A Study in Analytic
Number Theory and Computational Complexity" published by John Wiley
and Sons in 1987.

 > it also mentioned that FFT based arithmetic was very useful for
 > this type of calculation.

Yes.  The niave algorithm for multiplying multi-precision numbers has
complexity N^2.  Clearly this is unacceptable when one is working with
numbers of millions or even billions of decimal digits.  The FFT can
be interpreted as a transform between the coeficients of a polynomial
and the values it takes on primitive Nth roots of unity.  This allows
one to multiply polynomials by doing a forward FFT of the coeficients,
multiplying pointwise, and doing a reverse FFT.  Since any number can
be expressed as a polynomial whose coeficients are its digits, the
generalization to fast multi-precision integer multiplication is
obvious.

After optimizing wordsize and a few other things to make an optimal
algorithm, one ends up with something called a Schonhage-Strassen
multiplication which has complexity N*LOG(N)*LOG(LOG(N)).  This is
near-linear for big N.

Through an argument using Newton's Method, It can easily be shown that
multiplication, division, and Nth-root extraction all have the same
bit complexity.  It is therefore possible to design near-linear
multi-precision algorithms for all the arithmetic operations necessary
to calculate the value of Pi using the formula previously given.

 > Anybody have it available?  (This kind of stuff might also speed
 > up RSA caculations by the way).

I'm not sure the world is ready for million bit RSA keys. :)

If you can dig up an Email address for the Borwein brothers, perhaps
they might be persuaded to tell you where some code is available.


---------------------------------------------------------------
Francis Barrett, F.R.C. |  Thou canst not travel on the path  |
The Cybernetics Guild   |  before thou hast become the Path   |
fb@cyberg.win.net       |  itself.                            |
---------------------------------------------------------------

