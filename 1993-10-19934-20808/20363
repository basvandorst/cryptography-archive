Newsgroups: sci.crypt,alt.security.pgp
Path: msuinfo!uwm.edu!cs.utexas.edu!uunet!munnari.oz.au!cs.mu.OZ.AU!toora.acci.COM.AU!ggr
From: ggr@toora.acci.COM.AU (Greg Rose)
Subject: Re: PASSPHRASE FAQ
Message-ID: <9328618.23863@mulga.cs.mu.OZ.AU>
Sender: news@cs.mu.OZ.AU
Organization: Australian Computing and Communications Institute
References: <13486.492.uupcb@grapevine.lrk.ar.us> <1993Oct12.182448.9893@ntg.com>
Date: Wed, 13 Oct 1993 08:09:09 GMT
Lines: 35
Xref: msuinfo sci.crypt:20363 alt.security.pgp:5570

In article <1993Oct12.182448.9893@ntg.com> dplatt@ntg.com (Dave Platt) writes:
>In article <13486.492.uupcb@grapevine.lrk.ar.us> grady@netcom.com@grapevine.lrk.ar.us (Grady@Netcom.Com)  writes:
>
>>#define S(n, X) ((X << n) | (X >> (32 - n)))    /* Barrel roll */
>
>Poor implementation.  C allows the >> operator to do _either_ a logical
>right shift (zero fill on the left) or an arithmetic shift (sign-extend
>on the left).  The choice of which shift is actually implemented is up
>to the compiler writer, and usually depends on the architecture of the
>target machine.

I think most of the world stopped using those C
compilers a long time ago. Ever since the
introduction of the "unsigned" keyword into C
(well before ANSI C) it has been defined that a
shift of an unsigned quantity will zero fill, and
a shift of a signed quantity will sign extend.
So long as the type of "n" is unsigned, this
expression is fine.

Two nits to pick, though. It still assumes a 32
bit machine, although for most cryptographic
purposes the extra bits on a 64 bit machine will
be ignored anyway. Much more important is that the
expression should be much more severly
parenthesised; S(1?3:3, 0x12345678) (Boy I had to
think hard to find an operator with a lower
precedence than a shift :-) does NOT do what
it looks like it should. The #define should as a
matter of principle look like:
#define S(n, X) (((X) << (n)) | ((X) >> (32 - (n))))

--
Greg Rose
ggr@acci.com.au
