Path: msuinfo!agate!usenet.ins.cwru.edu!magnus.acs.ohio-state.edu!math.ohio-state.edu!news2.uunet.ca!apple.com!goofy.apple.com!mumbo.apple.com!R._Braithwaite-Lee@magic-bbs.corp.apple.com
Message-ID: <1993Oct07.002813.1538421@magic-bbs.corp.apple.com>
Newsgroups: sci.crypt
From: R._Braithwaite-Lee@magic-bbs.corp.apple.com
Distribution: world
Organization: M A G I C
Date: Thu, 07 Oct 1993 00:28:13 EST
Subject: Re: Secure identification of software versions
Lines: 58

Germano Caronni replied to Ken Hardy's post:

GC> In article <1706@racerx.bridge.com> ken@Bridge.COM (Ken Hardy) writes:
GC> >I'd like a means of verifying a file based on a digital signature
GC> >stored within it.  Unfortunately, I can think of no surefire way to
GC> >keep someone from simply re-signing it after modification.
GC> >
GC> >My particular situation involves scripts distributed in text form 
GC> that >can be easily hacked.  I wrote a utility that scans the file, 
GC> replacing >a template, normally in a comment line, with a digital 
GC> signature. A >second verification utility recalculates the signature 
GC> and compares it >to the one found in the file.
GC> >
GC> >Unfortunately, the only thing that stops someone from resigning a
GC> >modified file is the "secret" nature of the signature algorithm.  
GC> Since >I'd like to distribute the verifyer with the signed files (so 
GC> it's >there to do checking when trouble arises) someone could 
GC> disassemble it >to recreate my algorithm.  I guess this is an example 
GC> of "security >through obscurity"; obfuscation cannot be guaranteed.

GC> Well, if you distribute the verifyer with the signed files, how do you
GC> ensure nobody tampers with it ? Checking it first with the help of 
GC> another program, which is not publicly stored ?

GC> Well, how about this. Generate an RSA-keypair. Keep one of the keys as
GC> your secret key, and make the second one publicly readable.
GC> Encrypt the signature with the secret part of the key. Store this 
GC> encrypted signature in the file.
GC> Now you can easily check the signature by re-calculating it, 
GC> decrypting the stored signature with the public part of the key, and 
GC> comparing the two so won signatures.
GC> Hmmm, where are the weaknesses of that ?

If I understand your suggestion properly, here's what I (evil cracker) do:

1. Strip out the encrypted signature. Toss out the public key.
2. Modify the script, adding virii or whatever.
2. Generate my own keypair.
3. Proceed as per your suggestion above.

Now there's a false distribution which is internally consistent. It is
inconsistent with the true public key, but the only way to ensure that a
recipient can perform a proper verification is to have uncompromised
communication between you and the recipient to distribute the correct
public key. And if you have *that* you can skip all this and distribute the
correct plaintext!

Regards,
Reginald Braithwaite-Lee !:-)

Publishing Revenue Partners  1111-200 Dufferin Street
Toronto, ON Canada M6K 1Z4  (416) 538-3844
R_Braithwaite@magic-bbs.corp.apple.com  73114.2055@compuserve.com

"If only you could see what I've seen with your eyes"



