Newsgroups: sci.crypt
Path: msuinfo!uwm.edu!math.ohio-state.edu!darwin.sura.net!seismo!esosun.css.gov!mvb.saic.com!ast.saic.com!actd!agnew
From: agnew@actd.actd.saic.com (Bob Agnew)
Subject: Re: One-way Functions wanted
Message-ID: <1993Oct13.175610.11727@ast.saic.com>
Summary: Is this a "trap-door" function?
Keywords: trap-door,one-way
Sender: news@ast.saic.com
Reply-To: agnew@actd.actd.saic.com
Organization: Science Applications International Corporation
References: <1993Oct12.231054.210@ast.saic.com>
Date: Wed, 13 Oct 1993 17:56:10 GMT
Lines: 101

In article 210@ast.saic.com, agnew@actd.actd.saic.com (Bob Agnew) writes:
>In article 2Hs@chinet.chinet.com, schneier@chinet.chinet.com (Bruce Schneier) writes:
>>Greetings:
>>
>>I'm attempting an algorithm design, and I thought I'd probe the collective
>>mind for a clever solution to a problem that I am having.
>>
>>I am looking for a one-way function that maps 8-bit values onto 32-bit
>>values.  By one-way, I means that there is no more efficient way to figure
>>out which (if any) 8-bit value a given 32-bit value came from than through
>>brute-force.  I also require strict avalanche; every bit of the 32-bit value
>>must depend on every bit of the 8-bit input.  And that the 256 possible
>>32-bit values not be correlated in any way.
>>
>
>One way comes to mind. Use a 32 bit Galois Field GF(2^32) using a 32 bit SR
>with a dense primitive polynomial or the field of 32 bit unsigned integers.
..Deleted

The algorithm which I described is not a true "Trap Door" function.
i.e. given the Key, the inverse can not be found more efficiently then
by "brute force".  Here brute force means computing the forward
function for all possible arguments with the given key until a match is
found.

I believe that the following algorithm, in at least one of its flavors,
is a robust trap door function; however, I have often been wrong on
this newsgroup before and wait gracefully to be corrected on this. I
have written code for a PC which implements all the described
operations. The algorithm is simply this:

To transform an 8-bit byte, B8, to a 32-bit integer, C32, using 96+
bits of key consisting of K1 (64 bits) and K2 (32 bits) plus an
optional Key K3, simply compute:

B8 => C32

R64 = T{Phi[B8]^K1, K3)

C32 = U(R64) xor L(R64) xor K2

where U(R64) denotes the upper 32 bits of the 64 bit register R64, and
L(R64) denotes the lower 32 bits. T{x,K3} is an optional cryptographic
transform, possibly the identity mapping.

R64 is a 64 bit register formed by exponentiating Phi[B] to a 64 bit
power given by K1 where Phi[B8] is one of 256 "randomly" chosen
primitive elements of GF(2^64).  This operation takes an average of 12
microseconds on a 80486 33 Mhz. PC with a maximum of 24 microseconds. I
can provide assembler code for this.

Store a 256 element table of 64-bit primitive polonomials of GF(2^64)
choosen "randomly" (I also have Ada + assembler for this).  Either
publish this table or protect it. (It doesn't matter much). Call this
table Phi. Given a byte, B8, index the table by the byte to produce a
64 bit number Phi[B8]. Load Phi[B8] into a 64-bit register pair
(edx:eax). Using the suboptimal but fast Binary algorithm,  raise
Phi[B8] to the K1-th power. This maps B8 uniquely onto a 64-bit number
given K1.  The size of the search space for this mapping is 2^(8 + 64)
= 2^72 = 4722366482869645213696.

Now the algorithm comes in three flavors, depending on the choice of T{}.
These flavors are:

A) Cheap.
B) Pretty Cheap.
C) More expensive.

A) T{} is the identity mapping. Total key is 96 bits. (There is no K3)

B) T{R64,K3}: U(R64) <= rotate_right(U(R64),K3) ; Total key is 101 bits
    K3 specifies a 0..31 bit rotation on the upper half of R64.

C) T{R64,K3} is full cryptographic transformation. e.g. R64 <= DES{R64,K3}
   where K3 is 56 bits and total key is 64 + 56 = 120 bits. Note K2 is 
   not needed after DES encryption.

Although A) appears to be a trap door function, someone may be able to
mathematically relate the upper and lower halves of the exponentiation
to their sum modulo 2, thereby providing an inversion algorithm more
efficient than brute force.

Algorithm B) simply rotates one half of R64 by a 5 bit rotation code, thus
complicating the relationship between the two 32 bit halves and the resultant
32 bits. This operation takes only 90 nanoseconds on a 33 Mhz. 80486 PC and
is thus computationally insignificant. 

Algorithm C) certainly insures that there is no discernible
relationship that would allow an improvement over brute force. This
comfort comes at a considerable price in computational speed however.


I feel comfortable with Algorithm B) and think that it provides a reasonable
one way function unless someone can show that there could be an algorithm which
could invert the overall mapping more easily than a brute force search. 

---
"Those who cannot cope with mathematics are not fully human. At best they
are tolerable sub-humans who have been taught to bathe and not make messes
in the house."  From the Notebook of Lazarus Long (Robert Heinlein)

