Path: msuinfo!agate!apple.com!goofy.apple.com!mumbo.apple.com!R._Braithwaite-Lee@magic-bbs.corp.apple.com
Message-ID: <1993Oct28.032925.1621073@magic-bbs.corp.apple.com>
Newsgroups: sci.crypt
From: R._Braithwaite-Lee@magic-bbs.corp.apple.com
Distribution: world
Organization: M A G I C
Date: Thu, 28 Oct 1993 03:29:25 EST
Subject: Re: Checking that code has not been modified?
Lines: 65

To: Andrew Phillips,andrew@teslab.lab.oz.au,Internet

AP> We have a need to check that EPROMs in sensitive devices are not
AP> modified for security reasons.  We are aware of a device that is made
AP> in the US (called a Kobetron?) that is supposed to perform such a
AP> task.  It works by generating a "signature" (of eight hex digits) for
AP> an EPROM which if it is correct verifies that the EPROM has not been
AP> tampered with.  I believe this device works using a CRC.

AP> ...

AP> My gut feeling is that any signature using CRCs could be readily
AP> faked.  I also had a gut feeling that public key cryptography could
AP> be the solution and after reading the Cryptography FAQ of sci.crypt I
AP> have a rough idea of how, as explained here.

AP> Create a one-way hash of the (authentic) EPROM.  Use this to verify
AP> EPROMs in the field.  From my understanding of the FAQ there are
AP> one-way hash functions where it is impossible to create messages
AP> which have the same hash value even if you know the original message
AP> and the hash value.  But it seems to me that, at least for small hash
AP> values (which would be best for practical reasons) a brute force
AP> (trial and error) method could be used to produce a message with the
AP> same hash as the original.

I'm scratching my head here. Why not read the EPROM and compare to the
'ultimate signature',  your original code? I presume this is because you
need to test this under 'field conditions', a device which cannot
communicate securely with a verifying device.

So, you have some sort of signed chunk of code and some sort of verifying
device. You have no way of preventing whoever tampers with the code from
tampering with the signature built into the verifier!

Example: you 'sign' the EPROM with a secret key using PKC. Yes, you can
check that the EPROM has been signed by the appropriate key (say
'Humphrey'). Now a Hacker changes the EPROM and signs it with his own
signature (say 'Jim'). If the Hacker also changes the signature in the
verifier to 'Jim', the verifier will verify the EPROM with its code.

Obviously, verifiers are only as secure as their access to a secure key. If
you are merely checking devices manually, or randomly via modem, you can
use the method above.

AP> Also I am not sure whether it would be better to use digital
AP> signatures which have (according to the FAQ) private hashing unlike
AP> the above which uses public hashing.  (Actually I'm a bit vague on
AP> the difference between one-way hash functions and digital signatures.)

My suggestion is that the question is moot if your verifying procedure
involves a secure key, otherwise there are no secure verifiers.

Regards,
Reginald Braithwaite-Lee !:-)

Publishing Revenue Partners  1111-200 Dufferin Street
Toronto, ON Canada M6K 1Z4  (416) 538-3844
r._braithwaite@magic-bbs.corp.apple.com


-- "The light that burns twice as bright burns half as long... and you have
burned so very, very brightly"



