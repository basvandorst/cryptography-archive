Path: msuinfo!agate!doc.ic.ac.uk!pipex!uunet!noc.near.net!news.delphi.com!news.delphi.com!not-for-mail
From: anspring@news.delphi.com (ANSPRING@DELPHI.COM)
Newsgroups: sci.crypt
Subject: Random Bits from keyboard timings.
Date: 6 Oct 1993 00:58:56 -0400
Organization: General Videotex Corporation
Lines: 51
Message-ID: <28tjag$8c6@news.delphi.com>
NNTP-Posting-Host: news.delphi.com
Summary: A Scheme for generating random bits from keyboard timings.
Keywords: random , bits, keyboard

Encryption schemes have a huge appetite for random numbers.  
PC based encryptors have a hell of a time generating these, 
since PC's are very deterministic.  The carbon unit attacted 
to most PC's (sometimes referred to as the user), interacts 
randomly with the device, making it advantageous to use user 
inputs as a way of generating a pool of random numbers.  The 
time intervals between key strokes are often used for this.
 
Assumption:  the time interval t = t_key_hit-t_last_key_hit 
has a poisson density : 
    p(t) = 1/T * exp(-t/T) where T is the mean interval.
 
The transformation g = 1 - exp(-t/T) should have a uniform 
distribution over [0,1].
 
Of course if g is uniform, f = 1-g = exp(-t/T) should be just 
as uniform.
 
Transform f to a 32 bit integer i by multiplying 
i = f * 2^32.  Ideally the bits of i should be random.
 
In real life, of course, this won't be true.  The time 
measurement will be in discrete intervals dt.  In the scheme 
I'm working on now, dt will be "ticks", or 1/60 th seconds.  
That suggests that since
#ifdef HANDWAVING_MODE
    || df/f || = || dt/T ||, 
    if dt/T = 1/2, then only the topmost bit of f should be 
    usable. If dt/T = 1/2^n, then the top n-most bits should 
    be usable.
    A very fast typist on a word processor can crank out 145 
    5 character words a minute, or about 1 character in .083 
    second.  This means dt/T = 0.16 seconds, making only the 
    top 2 or 3 bits of f usable.  A hunt-and-peck typist (T
    =~ 1 second) will have the top 5 or 6 bits usable.
#endif HANDWAVING_MODE
 
So after computing f, compute n = INT(-log2(dt/T)) and save the topmost n
bits of f.
 
The above argument is based on intuition, and of course
intuition outside one's domain of expertise is very risky, 
but it seems reasonable.  Also, my poisson distribution 
assumption may be shaky.  Keystroke timings might be gaussian 
instead of poisson.  But the math for poisson sure is a lot 
easier to do!
Comments, criticisms, flames welcome. Will be testing this 
empirically in the near future.  Let me know if you're 
interested in the results.


