Newsgroups: sci.crypt
Path: msuinfo!agate!spool.mu.edu!sdd.hp.com!cs.utexas.edu!cactus.org!ritter
From: ritter@cactus.org (Terry Ritter)
Subject: Re: Privacy-Enhanced Mail: Crypto Problems
Message-ID: <1993Oct2.063744.4152@cactus.org>
Organization: Capital Area Central Texas UNIX Society, Austin, Tx
References: <1993Sep28.184747.28814@cactus.org> <CE6DGA.5Kx@informatik.uni-hamburg.de>
Date: Sat, 2 Oct 1993 06:37:44 GMT
Lines: 340


 In <CE6DGA.5Kx@informatik.uni-hamburg.de>
 bontchev@news.informatik.uni-hamburg.de (Vesselin Bontchev) writes:


 This message is one in a sequence which originated with my claims
 that the recent PEM RFC's could be improved with respect to
 cryptography, a claim based on these points:

 PROPOSITION I:  No cipher system should announce that the
      ciphertext is, in fact, ciphertext.

 PROPOSITION II:  No cipher system should announce what cipher is
      being employed.

 PROPOSITION III:  The mapping from enciphered binary to network-
      transportable ASCII may itself be part of a cipher.


 with another suggested by Vesselin:

 PROPOSITION IV: A public key encrypted message should not reveal who
      has signed it or who is able to decrypt it.


 The current discussion has wandered far afield, but generally
 appears to be concerned with Proposition II, above, apparently
 questioning whether implementation is possible.  However, in
 some cases, a review of the text which got us this far leads
 me--a direct participant--to wonder if we are talking about
 what I thought we were talking about.  I will do what I can.


 First, we continue a sub-discussion of what makes product ciphers
 strong:

>>>>  OK, but *why* is a product cipher strong?  I think the answer is
>>>>  that the individual techniques have *different kinds* of strength.

>>>I guess, the guys who
>>>have designed the S-boxes should have an idea of what makes the cypher
>>>strong, but AFAIK, this knowledge is classified.

>>  Classified or not, the general reason is what I said.
>
>How do you know? :-)

 Because that is what it must be.  The mechanism is fully exposed.
 There is nothing else there.  The only mystery is in the
 implications.  There can be ever finer discussion over these
 implications, but the general outline is obvious.

 One substitution is certainly "stronger" than no substitution,
 yet the simple product of two sequential substitutions is no
 stronger than one.  Since the product of simple substitutions does
 not produce strength, what is it about a product cipher which
 does?  The answer is that we must have some different *kind* of
 "strength" in the different levels.  By using various mechanisms
 in only two levels, we can easily run various tests which enquire
 about various aspects of strength.  I have been very pleased with
 "avalanche" tests.


>>  In the past
>>  few years there have been some very good papers on how one would
>
>BTW, a few references would be useful - and not only to me, I think.


    Ayoub, F.  1982.  Probabilistic completeness of substitution-
    permutation encryption networks.  IEE Proceedings, Part E.
    129(5): 195-199.

    Brown, L.  1989.  A Proposed Design for an Extended DES.
    Computer Security in the Age of Information.  W.J. Caelli, Ed.
    Elsevier.  9-22.

    Brown, L. and J. Seberry.  1989.  On the Design of Permutation
    P in DES Type Cryptosystems.  Advances in Cryptology--
    Eurocrypt '89.  696-705.

    Dawson, M. and S. Tavares.  1991.  An Expanded Set of S-Box
    Design Criteria Based on Information Theory and its Relation
    to Differential-Like Attacks.  Advances in Cryptology--
    Eurocrypt '91.  353-367.


>>  build strong Feistel ciphers.  But, in my opinion, no such cipher
>>  can be appropriate for new construction.
>
>I disagree. As far as I understand, the SkipJack algorithm is member
>of the same class of cyphers as DES, and is designed using the same
>(classified) knowledge. I believe it to be more secure than DES (the
>escrow nonsense apart) - and it is unlikely that the additional
>security is achieved only by increasing the key length and the number
>of rounds. There are again S-boxes and again something unknown to the
>general public is used in their design.

 Well, I assume the professional cipher designers at NSA are very
 familiar with Feistel technology, and especially its limitations.
 All techniques have limitations.  One advantage of using an older
 technique is that one can be pretty sure what those limitations
 are, and then use the tool in such a way that its limitations are
 convincingly obscured.  (And you get to do all the things you wish
 you had done the first time.)  Another advantage is that, since
 the cipher chip will be broadly distributed and the cipher itself
 thus exposed, having it be yet another Feistel design minimizes
 the disclosure of other cipher techniques.

 In my opinion, if there must be exactly one cipher for a given
 level of security, a Feistel design is not necessarily bad, but it
 does require a lot of engineering (testing or research-based design
 rules), is not particularly flexible, and is inherently slow as a
 software implementation.

 Feistel cipher technology was clearly designed for a storage-poor
 realization technology, a limitation which no longer applies.  The
 DES S-Boxes are very small.  And even though the data path is 64
 bits wide, each step operates on only 32 of those bits (and then
 combines them with the other 32).  So a Feistel cipher may need
 more rounds than some other construction.

 Worse, in the usual implementation, a Feistel cipher uses selected
 fixed tables.  This gives The Opponent those tables, before even
 starting analysis.  Any statistics as do exist in those tables
 can be used to work on opening up the cipher (e.g., differential
 cryptanalysis).  This means that there must be an increasingly
 arcane search for the "best" tables (and for rules *defining* the
 best tables), something which reminds me of the peculiar decades-
 long search for the "best" Linear Congruential Generator
 parameters in statistical RNG's.  But nowadays, the best RNG's
 are not built like that.


>>  The method I have suggested several times is that any first
>>  communication use DES.  Then, if there are to be other
>>  communications, the "negotiation" could be "piggybacked" on
>>  normal messages, still using DES.  This negotiation would be
>>  hidden inside the cipher envelope, automatic, and hidden from
>>  the user.  When agreement is reached (if computers can be said
>>  to "agree"), the cipher is changed.  The user need not notice.
>>  The key could be just the same old key, assuming that a
>>  substantial key (supporting the extra strength) had been
>>  transferred originally.
>
>Well, it seems that I am still not understanding you completely. You
>keep talking about "only the first communication", "negotiation", etc.
>I am insisting that it should be possible for the user to decrypt the
>message s/he has received, even if there has been no prior negotiation
>and this is the first and only message that s/he will receive.

 Sure.  Of course.  How could one think otherwise?  How could one
 think that someone else thinks otherwise without implying that
 that person is a blathering idiot?


>Therefore, all information about how to decrypt the message should be
>present in the message itself.

 No, not really.  What is also present is the *context* which is
 best known to the two correspondents only.  The correspondents
 themselves know better than anyone else whether this is their first
 communication, and whether they have previously negotiated the use
 of another cipher.  If they have not so negotiated, they can simply
 use DES-CBC (or triple-DES-CBC, or whatever is standardized as the
 cipher for initial contacts) until some other agreement is reached,
 or forever.

 One advantage of this is the ability to use an essentially unbounded
 set of ciphers, which do not necessarily need registration.  If a
 new cipher comes out with attractive features, we add it to the
 local list.  If new research shows that one of the old schemes was
 bad, we strike it from the local list.  There is no need for a
 technological upheaval and social turmoil simply because one design
 turns out to have problems.


>This said, I of course agree that it should be possible for this
>message to say: "OK, that were some initial headers, encrypted with
>DES-CBC. From now on we're going to use something else for the rest of
>the message, let's say, mmm... IDEA-CBC". That is, the message couls
>specify more than one cypher to decrypt the message.

 At the initial first-contact level, I would just suggest that there
 be a single cipher (DES-CBC?) covering both the negotiation field
 and the message.  Subsequent communications would continue to use
 that same cipher until another was agreed upon (and acknowledged).

 For example, the initial contact might include a list of identifiers
 for the ciphers which the sender most wishes to use.  The receiver
 might take that list, scan the available ciphers, and send the first
 found identifier back with the next message.  Or the receiver might
 propose its own list.  In general terms, when one end gets a length-
 one list (of cipher identifiers) and sends that same list back, the
 next message from the far end could be in the new cipher.  (This is
 not intended to be a detailed design of a final protocol :-).

 Clearly, if the negotiation or other fields are to be hidden in
 cipher, they must also be separated from the message itself.
 One way to do this is to use a particular byte-code to indicate
 an end-of-field, but this is not possible if we support binary
 messages (and we should).  The alternative is to start out with
 a 16-bit length-field which specifies the negotiation or non-
 message data size, with the message following through to the end.

 A higher-level alternative is to separate the fields at the
 network-ASCII level, where the data are inherently organized as
 "lines."  In this case, a blank line would make a fine EOF, and
 could indicate the start of the message area.  There may be
 advantages to both approaches.


>> >> When the agreed-upon cipher is used, the definition of that cipher
>> >> includes key processing which initializes a cryptographic RNG,
>> >> which then shuffles the desired substitution tables.  This produces
>> >> unique tables which are wholly dependent on the User Key; thus, the
>> >> tables have effectively been "sent" in the key itself.
>
>I read it several times, but fail to see how my comment is wrong. What
>do you mean by "User Key"? The public key of the recepient, or the
>session secret key used to encrypt the message? In the first case,
>there's no point to transmit any random substitution tables, because
>the public key is public info, and anybody could get the tables from
>it. Therefore, I must assume that you mean that the substitution
>tables are derived from the session key. Well, but the session key
>-is- sent with the message (encrypted with the public key of the
>recepient, of course), so I am right...

 Whatever you say.  :-)

 There are "keys" everywhere you look in cryptography.  First, I
 identify the "master key" which the user uses (or selects from an
 alias table) as the User Key.  Normally, a message will also
 include a "really-random" value which is protected by the User Key,
 and which is then used to cipher the rest of the data; this is
 normally called a "message key."  And, of course, stream ciphers
 also use a "running key," "keying sequence," or "confusion sequence"
 produced by a cryptographic RNG.  Then we have "public keys,"
 consisting of a public/private pair, which are used for signatures
 and so on, but in terms of the actual cipher, mainly for
 transporting the User Key.  And if the User Key is re-transported
 with every message, the distinction between User Key and message
 key is blurred.  This cannot happen, though, with a fully secret-
 key approach.

 Frankly, I am dubious about the worth of public-key technology in
 any environment which does not support certification of the keys.
 PEM does, supposedly, although those details are not my area.
 PGP apparently does not, and even though there has been a lot of
 talk about the PGP "trust" computation, I have not seen a formal
 treatment of it.  In fact, it is obvious that a single credulous
 user who is somewhat "trusted" by many people can deliver a bad key
 to them; they, in turn, can deliver that key to a user through many
 separate channels.  Even if each deliverer is trusted only somewhat,
 the result can be a highly-trusted key which is bad.  That is, the
 scheme is susceptible to a single-point fault.  The Opponent smiles.
 (Note that if each key-trust were accompanied by the path through
 which the key were acquired, the possibility of a single-point
 fault could be detected.)

 But in any case, for a cipher to work, a secret key must have
 somehow been transported.  I assume that it makes sense to deliver
 a sizable User Key, which can easily be used for multiple ciphers
 as long as each of the designs includes a hash on a sequence of
 bytes to set up the internal cipher state.  This is a very
 reasonable requirement in the complete set of things which make
 up a "cipher."  (We can standardize on hashes to do this, but the
 ciphers themselves could use vastly different amounts of internal
 state in very different organizations; consequently, the cipher
 itself should be responsible for setting up the internal state
 from the User Key or message key.)

 So, in this case, I mean "User Key" to be that secret key (or keys)
 which are somehow transported and made available at both ends for
 a "secret-key" or "symmetric" cipher, which actually handles the
 data.

 I assume I have now cleared that up.  :-)


>>  There is no need to be sending tables.
>
>You probably mean - because they can be derived from the session key
>in a straighforward way?

 Yes.


>Well, this means that they still have to be
>sent with the message (after all, the session key -is- sent with the
>message).

 No.  If there were a cipher which did not use a session key, the
 tables could still be regenerated from operations controlled by the
 "main key," or User Key (the secret key that both ends possess).
 The information in the key itself, *plus the context* of a "cipher"
 (which must inherently include a strategy to set up its internal
 state (in this case the tables)) is sufficient.


>No, wait, if the whole message is encoded, using some random
>substitution table (which can be obtained only by decrypting the
>session key) - then how do you convert into binary form the encrypted
>session key in order to RSA-decrypt it? At least -that- part must be
>encoded in some standard way, which is still no better than what I
>proposed - and its presence in the messages can be detected
>automatically too - which I think you are trying to avoid...

 The first message, and succeeding contacts use some known base
 cipher, for example DES, until agreement is achieved.  Then both
 ends must "remember" what they agreed upon, and, when a message
 is received, use the "stored" *context* to decide what cipher
 to use.  This extends the security context to include information
 which occurs transiently and simply is not available in each
 message.


>No, the inconvenience I had in mind was the need for PRIOR
>NEGOTIATION, in order to select that particular cypher. Maybe your
>selection of the word "negotiate" is misguiding me, but it makes me
>think that you are assuming some PRIOR and TWO-WAY communication
>between the sender and the recepient BEFORE the recepient is able to
>decrypt the message.

 That was not my intention.  The word "negotiate" is in common use
 to describe the automatic, mechanical process by which, for example,
 modems "agree" on a data rate, modulation mode, etc.

 I mean that a normal sequence of messages also may contain
 "negotiation" information which eventually can produce agreement
 on some other type of cipher.  Two-way communication is necessary,
 but only one way at a time, sequentially, just like that which
 occurs here.


 Whew!

 ---
 Terry Ritter   ritter@cactus.org

