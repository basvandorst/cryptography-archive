#patches for CFS 1.2.0
# these patches upgrade from CFS 1.1.2
# 12/2/94
diff -c ../cfs.1.1.2/Makefile ./Makefile
*** ../cfs.1.1.2/Makefile	Mon Aug 29 14:33:55 1994
--- ./Makefile	Fri Dec  2 14:28:10 1994
***************
*** 1,4 ****
! # Makefile for cfs 1.1.x
  #*
  #* The author of this software is Matt Blaze.
  #*              Copyright (c) 1992, 1993, 1994 by AT&T.
--- 1,4 ----
! # Makefile for cfs 1.2.x
  #*
  #* The author of this software is Matt Blaze.
  #*              Copyright (c) 1992, 1993, 1994 by AT&T.
***************
*** 26,55 ****
  # HP/UX, Irix, Linux and AIX ported by Mark Henderson (markh@wimsey.com)
  # Ultrix 4.2 ported by Ed Gould (ed@left.wing.org)
  # Solaris 2.3 ported by Mark Stein (Mark.Stein@Eng.Sun.COM)
  
  # edit these to customize for your local site.
! # note that I've tested only the 3 configurations listed
  # Good luck if you're using something weird like Solaris...
  BINDIR=/usr/local/bin
  ETCDIR=/usr/local/etc
! PRINTCMD=en
  
  ## use these for vanilla SUNOS
  CFLAGS=-O
  LIBS=
  COMPAT=
! #
  ## use these for Linux (Slackware 1.1.2)
! #CFLAGS=-O
  #LIBS=
  #COMPAT=
  
! # Irix 4.0 -- markh@wimsey.bc.ca
  #CFLAGS=-cckr -O -Dirix
  #LIBS=-lrpcsvc -lsun
  #COMPAT=
  
! # hpux 8.0 -- markh@wimsey.bc.ca
  # also thanks to Charles Henrich (henrich@crh.cl.msu.edu)
  # and Eric Ross (ericr@hpvclq.vcd.hp.com)
  #CFLAGS=-O -Dhpux -DNORLIMITS
--- 26,73 ----
  # HP/UX, Irix, Linux and AIX ported by Mark Henderson (markh@wimsey.com)
  # Ultrix 4.2 ported by Ed Gould (ed@left.wing.org)
  # Solaris 2.3 ported by Mark Stein (Mark.Stein@Eng.Sun.COM)
+ # More Solaris/Linux help by Christopher Oliver (oliver@fritz.co.traverse.com) 
  
  # edit these to customize for your local site.
! # note that I've tested only the SunOS and BSDI configurations.
  # Good luck if you're using something weird like Solaris...
+ 
+ # configuration options for all platforms
+ #
+ # pathnames:
+ CC=cc
  BINDIR=/usr/local/bin
  ETCDIR=/usr/local/etc
! PRINTCMD=enscript -Gr2
! # if you're a paranoid facist, you might want to configure
! # default timeouts on the attach command.  If you do,
! # just add definitions for TIMEOUT and IDLE with the default number
! # of minutes you want to the CFLAGS line.
! # So the CFLAGS line for the SUNOS configuration with a timeout
! # of 12 hours and an idle timer of 2 hours would look like:
! # CFLAGS=-O -DTIMEOUT=720 -DIDLE=120
! # If you leave them out the default timeouts are infinite.  You
! # can override them, of course, on the cattach command line.
! 
! # Now uncomment the options for the your local platform.
! # You'll need to figure out how to install man pages yourself.
  
  ## use these for vanilla SUNOS
  CFLAGS=-O
  LIBS=
  COMPAT=
! 
  ## use these for Linux (Slackware 1.1.2)
! #CFLAGS=-O -DREDO_ALRM
  #LIBS=
  #COMPAT=
  
! ## Irix 4.0 -- markh@wimsey.bc.ca
  #CFLAGS=-cckr -O -Dirix
  #LIBS=-lrpcsvc -lsun
  #COMPAT=
  
! ## hpux 8.0 -- markh@wimsey.bc.ca
  # also thanks to Charles Henrich (henrich@crh.cl.msu.edu)
  # and Eric Ross (ericr@hpvclq.vcd.hp.com)
  #CFLAGS=-O -Dhpux -DNORLIMITS
***************
*** 66,77 ****
  #LIBS=-lrpc
  #COMPAT=-lcompat
  
! # Ultrix 4.2a
  #CFLAGS=-O -DANYPORT
  #LIBS=
  #COMPAT=
  
! # use these for 4.4/BSD386 systems with CFS on the NFS port because of no
  # support for the port options in the mount syscall
  # BSDI support by mab
  # Also works under freeBSD, though you may want to use -static on the
--- 84,95 ----
  #LIBS=-lrpc
  #COMPAT=-lcompat
  
! ## Ultrix 4.2a
  #CFLAGS=-O -DANYPORT
  #LIBS=
  #COMPAT=
  
! ## use these for 4.4/BSD386 systems with CFS on the NFS port because of no
  # support for the port options in the mount syscall
  # BSDI support by mab
  # Also works under freeBSD, though you may want to use -static on the
***************
*** 80,87 ****
  #LIBS=-lrpc
  #COMPAT=-lcompat
  
  ## use these flags on Solaris 2.3
! #CFLAGS=-O -DSOLARIS2X -DPORTMAP
  #LIBS=-lsocket -lnsl
  #COMPAT=
  
--- 98,112 ----
  #LIBS=-lrpc
  #COMPAT=-lcompat
  
+ ##use these for NetBSD i386 1.0 (John Kohl)
+ # for mounting, you need to use a command like:
+ #	mount -o -P,-c localhost:/null /crypt
+ #CFLAGS=-O -DBSD44 -DANYPORT -DCFS_PORT=2049
+ #LIBS=
+ #COMPAT=-lcompat
+ 
  ## use these flags on Solaris 2.3
! #CFLAGS=-O -DSOLARIS2X -DPORTMAP -DREDO_ALRM
  #LIBS=-lsocket -lnsl
  #COMPAT=
  
***************
*** 91,127 ****
  
  # you shouldn't have to touch much below here
  
! SRCS=Makefile admproto.x mount.x nfsproto.x cfs.c cfs_adm.c cfs_nfs.c cfs.h cfs_fh.c cfs_des.c cfs_cipher.c cattach.c getpass.c cdetach.c cmkdir.c adm.c cname.c ccat.c ver.c i o ssh
  MANS=cattach.1 cdetach.1 cmkdir.1 ssh.1 cfsd.8 cname.8 ccat.8 README README.install README.history notes.ms
! OBJS= cfs.o nfsproto_xdr.o nfsproto_svr.o admproto_xdr.o admproto_svr.o cfs_adm.o cfs_nfs.o cfs_fh.o cfs_des.o cfs_cipher.o adm.o ver.o
! COBJS=admproto_clnt.o cfs_des.o cfs_cipher.o cattach.o getpass.o cmkdir.o cdetach.o ver.o cname.o ccat.o
  OTHERS = nfsproto.h nfsproto_svr.c nfsproto_xdr.c admproto.h admproto_svr.c admproto_xdr.c admproto_clnt.c
  
  all: cfsd cattach cmkdir cdetach cname ccat
  
  cfsd: $(OBJS)
! 	cc $(OBJS) $(LIBS) -o cfsd
  
! cattach: cattach.o admproto_clnt.o admproto_xdr.o getpass.o cfs_des.o cfs_cipher.o adm.o ver.o
! 	cc cattach.o admproto_clnt.o admproto_xdr.o cfs_des.o cfs_cipher.o getpass.o adm.o ver.o $(COMPAT) $(LIBS) -o cattach
  
  cdetach: cdetach.o admproto_clnt.o admproto_xdr.o adm.o ver.o
! 	cc cdetach.o adm.o admproto_clnt.o admproto_xdr.o ver.o $(LIBS) -o cdetach
! 
! cmkdir: getpass.o cfs_des.o cfs_cipher.o cmkdir.o adm.o ver.o
! 	cc cmkdir.o cfs_des.o cfs_cipher.o getpass.o adm.o ver.o $(COMPAT) -o cmkdir
  
! cname: cname.o getpass.o cfs_des.o cfs_cipher.o cfs_adm.o cfs_fh.o cfs_nfs.o ver.o
! 	cc cname.o getpass.o cfs_des.o cfs_cipher.o cfs_adm.o cfs_fh.o cfs_nfs.o ver.o $(LIBS) $(COMPAT) -o cname
  
! ccat: ccat.o getpass.o cfs_des.o cfs_cipher.o cfs_adm.o cfs_fh.o cfs_nfs.o ver.o
! 	cc ccat.o getpass.o cfs_des.o cfs_cipher.o cfs_adm.o cfs_fh.o cfs_nfs.o ver.o $(LIBS) $(COMPAT) -o ccat
  
  
  
! $(OBJS): nfsproto.h admproto.h cfs.h
  
! $(COBJS): nfsproto.h admproto.h cfs.h
  
  nfsproto_xdr.c: nfsproto.x
  	rpcgen -c -o nfsproto_xdr.c nfsproto.x 
--- 116,151 ----
  
  # you shouldn't have to touch much below here
  
! SRCS=Makefile admproto.x mount.x nfsproto.x cfs.c cfs_adm.c cfs_nfs.c cfs.h cfs_fh.c cfs_des.c cfs_cipher.c mcg.c mcgsbox.c mcg.h cattach.c getpass.c cdetach.c cmkdir.c adm.c cname.c ccat.c ver.c i o ssh
  MANS=cattach.1 cdetach.1 cmkdir.1 ssh.1 cfsd.8 cname.8 ccat.8 README README.install README.history notes.ms
! OBJS= cfs.o nfsproto_xdr.o nfsproto_svr.o admproto_xdr.o admproto_svr.o cfs_adm.o cfs_nfs.o cfs_fh.o cfs_des.o cfs_cipher.o adm.o ver.o mcgsbox.o mcg.o
! COBJS=admproto_clnt.o cfs_des.o cfs_cipher.o cattach.o getpass.o cmkdir.o cdetach.o ver.o cname.o ccat.o mcgsbox.o mcgsbox.o mcg.o 
  OTHERS = nfsproto.h nfsproto_svr.c nfsproto_xdr.c admproto.h admproto_svr.c admproto_xdr.c admproto_clnt.c
  
  all: cfsd cattach cmkdir cdetach cname ccat
  
  cfsd: $(OBJS)
! 	$(CC) $(OBJS) $(LIBS) -o cfsd
  
! cattach: cattach.o admproto_clnt.o admproto_xdr.o getpass.o cfs_des.o cfs_cipher.o adm.o ver.o mcg.o mcgsbox.o
! 	$(CC) cattach.o admproto_clnt.o admproto_xdr.o cfs_des.o cfs_cipher.o getpass.o adm.o ver.o mcg.o mcgsbox.o $(COMPAT) $(LIBS) -o cattach
  
  cdetach: cdetach.o admproto_clnt.o admproto_xdr.o adm.o ver.o
! 	$(CC) cdetach.o adm.o admproto_clnt.o admproto_xdr.o ver.o $(LIBS) -o cdetach
  
! cmkdir: getpass.o cfs_des.o cfs_cipher.o cmkdir.o adm.o ver.o mcg.o mcgsbox.o
! 	$(CC) cmkdir.o cfs_des.o cfs_cipher.o getpass.o adm.o ver.o mcg.o mcgsbox.o $(COMPAT) -o cmkdir
  
! cname: cname.o getpass.o cfs_des.o cfs_cipher.o cfs_adm.o cfs_fh.o cfs_nfs.o ver.o mcg.o mcgsbox.o
! 	$(CC) cname.o getpass.o cfs_des.o cfs_cipher.o cfs_adm.o cfs_fh.o cfs_nfs.o ver.o mcg.o mcgsbox.o $(LIBS) $(COMPAT) -o cname
  
+ ccat: ccat.o getpass.o cfs_des.o cfs_cipher.o cfs_adm.o cfs_fh.o cfs_nfs.o ver.o mcg.o mcgsbox.o
+ 	$(CC) ccat.o getpass.o cfs_des.o cfs_cipher.o cfs_adm.o cfs_fh.o cfs_nfs.o ver.o mcg.o mcgsbox.o $(LIBS) $(COMPAT) -o ccat
  
  
! $(OBJS): nfsproto.h admproto.h cfs.h mcg.h
  
! $(COBJS): nfsproto.h admproto.h cfs.h mcg.h
  
  nfsproto_xdr.c: nfsproto.x
  	rpcgen -c -o nfsproto_xdr.c nfsproto.x 
***************
*** 150,160 ****
  tarfile: $(SRCS) $(MANS)
  	tar -cvf cfs.tar $(SRCS) $(MANS)
  
! printout: $(SRCS) cfs.h admproto.h nfsproto.h
! 	$(PRINTCMD) $(SRCS) cfs.h admproto.h nfsproto.h
  
! labprint: $(SRCS) nfsproto.h cfs.h
! 	pr $(SRCS) cfs.h nfsproto.h | ipr -Pip7 -O -2 #-F
  	stroff -man $(MANS)
  
  install: all
--- 174,184 ----
  tarfile: $(SRCS) $(MANS)
  	tar -cvf cfs.tar $(SRCS) $(MANS)
  
! printout: $(SRCS) cfs.h mcg.h admproto.h nfsproto.h
! 	$(PRINTCMD) $(SRCS) cfs.h mcg.h admproto.h nfsproto.h
  
! labprint: $(SRCS) cfs.h mcg.h admproto.h nfsproto.h
! 	pr $(SRCS) cfs.h mcg.h admproto.h nfsproto.h | ipr -Pip7 -O -2 #-F
  	stroff -man $(MANS)
  
  install: all
***************
*** 163,166 ****
--- 187,191 ----
  #	install i o $(BINDIR)
  	@echo "Kill any running cfsd prior to restarting."
  	@echo "See the README file for more information."
+ 	@echo "Don't forget to install the man pages (*.[18])."
  
diff -c ../cfs.1.1.2/README ./README
*** ../cfs.1.1.2/README	Sun Aug 28 15:49:37 1994
--- ./README	Sun Nov 27 14:24:21 1994
***************
*** 1,4 ****
! This is version 1.1.2 of CFS, the Cryptographic File System.
  
  There is a mailing list, cfs-users, for discussion of topics of
  interest to CFS users and developers.  To subscribe:
--- 1,4 ----
! This is version 1.2.0 of CFS, the Cryptographic File System.
  
  There is a mailing list, cfs-users, for discussion of topics of
  interest to CFS users and developers.  To subscribe:
diff -c ../cfs.1.1.2/README.history ./README.history
*** ../cfs.1.1.2/README.history	Mon Aug 29 13:51:52 1994
--- ./README.history	Fri Dec  2 14:20:33 1994
***************
*** 1,5 ****
--- 1,8 ----
  CFS revision history:
  
+ 1.2.0 - Fixes various minor bugs.  Adds MacGuffin cipher.  Adds
+ timeout (-it) options to cattach.  DES ciphers compatible with 1.1.2.
+ 
  1.1.2 - Fixes hanging open on cdetach bug.  Bolsters security against
  portmapper bug.  Adds cname and ccat tools.  Compatible with 1.1.1.
  
diff -c ../cfs.1.1.2/README.install ./README.install
*** ../cfs.1.1.2/README.install	Mon Aug 29 09:20:59 1994
--- ./README.install	Fri Dec  2 14:20:39 1994
***************
*** 1,4 ****
! This is version 1.1.2 of CFS
  
   * The author of this software is Matt Blaze.
   *              Copyright (c) 1992, 1993, 1994 by AT&T.
--- 1,4 ----
! This is version 1.2.0 of CFS
  
   * The author of this software is Matt Blaze.
   *              Copyright (c) 1992, 1993, 1994 by AT&T.
diff -c ../cfs.1.1.2/admproto.x ./admproto.x
*** ../cfs.1.1.2/admproto.x	Thu Jul 14 16:12:15 1994
--- ./admproto.x	Thu Nov 24 15:51:46 1994
***************
*** 24,30 ****
  
  /*
   * cfs admin protocol RPC spec
!  *  new version, supporting multiple crypt modes.
   */
  
  /* error conditions */
--- 24,30 ----
  
  /*
   * cfs admin protocol RPC spec
!  *  1.2 version, supporting multiple crypt modes & new ciphers
   */
  
  /* error conditions */
***************
*** 42,50 ****
  enum ciphers {
  	CFS_STD_DES=0,		/* 2 key hybrid single DES */
  	CFS_THREE_DES=1,	/* 2 key hybrid 3DES */
! 	CFS_IDEA=2,		/* 2 key hybrid IDEA */
  	CFS_BLOWFISH=3,		/* 2 key hybrid BLOWFISH */
! 	CFS_SKIPJACK=4		/* 2 key hybrid SKIPJACK, (PCMCIA) */
  };
  
  const CFS_MAXCOMP=255;
--- 42,51 ----
  enum ciphers {
  	CFS_STD_DES=0,		/* 2 key hybrid single DES */
  	CFS_THREE_DES=1,	/* 2 key hybrid 3DES */
! 	CFS_IDEA=2,		/* 2 key hybrid IDEA (n/a) */
  	CFS_BLOWFISH=3,		/* 2 key hybrid BLOWFISH */
! 	CFS_SKIPJACK=4,		/* 2 key hybrid SKIPJACK, (PCMCIA) (n/a) */
! 	CFS_MACGUFFIN=5		/* 2 key hybrid MacGuffin */
  };
  
  const CFS_MAXCOMP=255;
***************
*** 66,79 ****
--- 67,97 ----
  	u_char secondary2[8];
  };
  
+ struct cfs_adm_blowkey {
+ 	long pl;		/* for 32 bit police */
+ 	u_char primary[16];
+ 	u_char secondary[16];	/* same as primary */
+ };
+ 
+ struct cfs_adm_mcgkey {
+ 	long pl;		/* for 32 bit align police */
+ 	u_char primary[16];
+ 	u_char secondary[16];	/* same as primary */
+ };
+ 
  union cfs_admkey switch (ciphers cipher) {
      case CFS_STD_DES:
  	cfs_adm_deskey deskey;
      case CFS_THREE_DES:
  	cfs_adm_3deskey des3key;
+     case CFS_BLOWFISH:
+ 	cfs_adm_blowkey blowkey;
+     case CFS_MACGUFFIN:
+ 	cfs_adm_mcgkey mcgkey;
      default:
  	void;
  };
+ 
  struct cfs_attachargs {
  	string dirname<CFS_MAXNAME>;	/* directory to attach to */
  	string name<CFS_MAXCOMP>;	/* instance name */
***************
*** 82,88 ****
--- 100,108 ----
  					   same as in rpc */
  	int highsec;			/* nonzero for highsec mode */
  	bool anon;			/* anonymousness */
+ 	/* for timeouts, zero indicates infinite */
  	int expire;			/* number of minutes to live */
+ 	int idle;			/* idle timeout */
  };
  
  struct cfs_detachargs {
***************
*** 91,120 ****
  };
  
  
- struct cfs_lsargs {
- 	int cookie;			/* enrty with which to start */
- };
- 
- struct lsok {
- 	string dirname<CFS_MAXCOMP>;	/* name (or .OPAQUE_*) */
- 	int owner;			/* owner */
- 	int iid;			/* instance id */
- 	string where<CFS_MAXNAME>;	/* where to */
- };
- 
- union cfs_lsrepl switch (cfsstat status) {
-     case CFS_OK:
- 	struct lsok ok;
-     default:
- 	void;
- };
- 
- 
  program ADM_PROGRAM {
  	version ADM_VERSION {
  		void ADMPROC_NULL(void) = 0;
  		cfsstat ADMPROC_ATTACH(cfs_attachargs) = 1;
  		cfsstat ADMPROC_DETACH(cfs_detachargs) = 2;
! 		cfs_lsrepl ADMPROC_LS(cfs_lsargs) = 3;
! 	} = 1;
  } = 0x21234567;
--- 111,123 ----
  };
  
  
  program ADM_PROGRAM {
  	version ADM_VERSION {
  		void ADMPROC_NULL(void) = 0;
  		cfsstat ADMPROC_ATTACH(cfs_attachargs) = 1;
  		cfsstat ADMPROC_DETACH(cfs_detachargs) = 2;
! 	} = 2;
  } = 0x21234567;
+ 
+ 
+ 
diff -c ../cfs.1.1.2/cattach.1 ./cattach.1
*** ../cfs.1.1.2/cattach.1	Thu Jul 14 22:11:37 1994
--- ./cattach.1	Sat Nov 26 17:03:23 1994
***************
*** 4,9 ****
--- 4,11 ----
  .SH SYNOPSIS
  .B cattach
  [ \-\fBl\fP ]
+ [ \-\fBt\fP \fIminutes\fP]
+ [ \-\fBi\fP \fIminutes\fP]
  \fIdirectory\fP
  \fIname\fP
  .SH DESCRIPTION
***************
*** 42,47 ****
--- 44,56 ----
  protection against attackers who can spoof the UID on the client
  machine.  See the \fBssh\fP(1) command for an example of this usage.
  .LP
+ The \fB-t\fP option causes the attach to automatically go away after
+ the specified number of minutes.  The \fB-i\fP option deletes the
+ attach after a specified number of minutes of inactivity.  Note that
+ these options, if used, should be chosen with some care; too short
+ timeouts may actually increase the risk of compromise of frequently
+ re-typed passphrases.
+ .LP
  Virtual directories should be removed with the \fBcdetach\fP(1)
  command when no longer in use.
  .SH EXAMPLES
***************
*** 78,85 ****
  protect against spoofing currently attached directories.  The .name
  hack is an ugly kludge.  In particular, it would be better to limit
  access to the process group of the user who issued the cattach
! command.  Unfortunately, that information is not passed to cfsd.  A
! timeout on the attach command would also be helpful here.
  .SH AUTHOR
! Matt Blaze; for information on cfs, email to
! cfs@research.att.com.
--- 87,95 ----
  protect against spoofing currently attached directories.  The .name
  hack is an ugly kludge.  In particular, it would be better to limit
  access to the process group of the user who issued the cattach
! command.  Unfortunately, that information is not passed to cfsd.
! .LP
! The timeout isn't perfect, and may occur a minute or two later than
! expected.
  .SH AUTHOR
! Matt Blaze; for information on cfs, email to cfs@research.att.com.
diff -c ../cfs.1.1.2/cattach.c ./cattach.c
*** ../cfs.1.1.2/cattach.c	Sat Jul 30 14:09:48 1994
--- ./cattach.c	Fri Nov 25 15:00:55 1994
***************
*** 23,29 ****
   */
  
  /*
!  * client side attach - 1.1
   */
  #include <stdio.h>
  #include <rpc/rpc.h>
--- 23,29 ----
   */
  
  /*
!  * client side attach - 1.2
   */
  #include <stdio.h>
  #include <rpc/rpc.h>
***************
*** 39,44 ****
--- 39,47 ----
  #include <sys/vfs.h>
  #endif	/* ultrix */
  #else
+ #ifndef MAXHOSTNAMELEN
+ #include <sys/param.h>
+ #endif
  #include <sys/mount.h>
  #endif	/* BSD44 */
  #endif
***************
*** 51,56 ****
--- 54,67 ----
  #define getwd(b)	getcwd(b, 1024)
  #endif
  
+ #ifndef TIMEOUT		/* default timeout; override in makefile */
+ #define TIMEOUT 0
+ #endif
+ 
+ #ifndef IDLE		/* default idle timer; override in makefile */
+ #define IDLE 0
+ #endif
+ 
  main(argc,argv)
       int argc;
       char **argv;
***************
*** 74,106 ****
  	char cname[1024];
  	static struct timeval tout = {60,0};
  	CLIENT *cln;
  
  	ap.highsec=1;
! 	while (--argc && (**++argv == '-')) {
  		for (flg= ++*argv; *flg; ++flg)
  			switch (*flg) {
  			    case 'l':
  				ap.highsec=0;
  				break;
  			    default:
! 				fprintf(stderr,"usage: cattach [-l] dir name\n");
  				exit(1);
  			}
  	}
! 	if (argc!=2) {
! 		fprintf(stderr,"Usage: cattach [-l] dir name\n");
  		exit(1);
  	}
! 	if (*argv[0]!='/') {
! 		if (getwd(buf) == NULL){
  			fprintf(stderr,"Can't stat current directory\n");
  			exit(1);
  		}
! 		sprintf(dir,"%s/%s",buf,argv[0]);
  	} else
! 		strcpy(dir,argv[0]);
  	if (chdir(dir)<0) {
! 		perror(argv[0]);
  		exit(1);
  	}
  #ifdef irix
--- 85,147 ----
  	char cname[1024];
  	static struct timeval tout = {60,0};
  	CLIENT *cln;
+ 	int timeout=TIMEOUT;
+ 	int idle=IDLE;
+ 	char *dirarg=NULL;
+ 	char *namearg=NULL;
  
  	ap.highsec=1;
! 	while (--argc) if (**++argv == '-') {
  		for (flg= ++*argv; *flg; ++flg)
  			switch (*flg) {
  			    case 'l':
  				ap.highsec=0;
  				break;
+ 			    case 't':	/* absolute timeout */
+ 			    case 'i':	/* idle timer */
+ 				enq(*flg);
+ 				break;
  			    default:
! 				fprintf(stderr,"usage: cattach [-l] [-t timeout] -i [idle] dir name\n");
! 				exit(1);
! 			}
! 	} else {
! 		switch (deq()) {
! 		    case -1:
! 			if (dirarg==NULL)
! 				dirarg = *argv;
! 			else if (namearg==NULL)
! 				namearg = *argv;
! 			else {
! 				fprintf(stderr,"usage: cattach [-l] [-t timeout] -i [idle] dir name\n");
  				exit(1);
  			}
+ 			break;
+ 		    case 't':
+ 			timeout = atoi(*argv);
+ 			break;
+ 		    case 'i':
+ 			idle = atoi(*argv);
+ 			break;
+ 		    default:	/* should never happen */
+ 			fprintf(stderr,"cattach: internal error\n");
+ 			exit(1);
+ 		}
  	}
! 	if ((dirarg==NULL) || (namearg==NULL)) {
! 		fprintf(stderr,"usage: cattach [-l] [-t timeout] [-i idle] dir name\n");
  		exit(1);
  	}
! 	if (*dirarg!='/') {
! 		if (getwd(buf) == NULL) {
  			fprintf(stderr,"Can't stat current directory\n");
  			exit(1);
  		}
! 		sprintf(dir,"%s/%s",buf,dirarg);
  	} else
! 		strcpy(dir,dirarg);
  	if (chdir(dir)<0) {
! 		perror(dirarg);
  		exit(1);
  	}
  #ifdef irix
***************
*** 116,123 ****
  	}
  #endif
  	ap.dirname=dir;
! 	strcpy(ins,argv[1]);
! 	*argv[1]='\0'; /* weak attempt to hide .instance in ps output */
  	ap.name=ins;
  	if ((pw=getpassword("Key:"))==NULL) {
  		fprintf(stderr,"Can't get key\n");
--- 157,164 ----
  	}
  #endif
  	ap.dirname=dir;
! 	strcpy(ins,namearg);
! 	*namearg='\0'; /* weak attempt to hide .instance in ps output */
  	ap.name=ins;
  	if ((pw=getpassword("Key:"))==NULL) {
  		fprintf(stderr,"Can't get key\n");
***************
*** 130,135 ****
--- 171,178 ----
  		fscanf(fp,"%d",&ciph);
  		fclose(fp);
  	}
+ 	ap.idle = idle;
+ 	ap.expire = timeout;
  	ap.key.cipher=ciph;
  	if (pwcrunch(pw,&ap.key)!=0) {
  		fprintf(stderr,"Invalid key\n");
***************
*** 151,154 ****
--- 194,225 ----
  	if (ret!=CFS_OK)
  		fprintf(stderr,"cattach: %s\n",admmsg(ret));
  	exit(ret);
+ }
+ 
+ #define QS 5
+ struct {
+         int data[QS];
+         int head;
+         int tail;
+ } argq = {{0},0,0};
+ 
+ enq(f)
+      char f;
+ {
+ 	argq.tail++;
+ 	argq.tail %= QS;
+ 	if (argq.head==argq.tail) {
+ 		fprintf(stderr,"Can't deal with this\n");
+ 		exit(-2);
+ 	}
+ 	argq.data[argq.tail]=f;
+ }
+ 
+ deq()
+ {
+ 	if (argq.head==argq.tail)
+ 		return -1;
+ 	argq.head++;
+ 	argq.head %= QS;
+ 	return(argq.data[argq.head]);
  }
diff -c ../cfs.1.1.2/ccat.8 ./ccat.8
*** ../cfs.1.1.2/ccat.8	Mon Aug 29 13:44:44 1994
--- ./ccat.8	Sat Nov 26 17:22:29 1994
***************
*** 3,9 ****
  ccat
  .SH SYNOPSIS
  .B ccat
! [ \-\fB3\fP ]
  \fIfile\fP
  [ ... ]
  .SH DESCRIPTION
--- 3,9 ----
  ccat
  .SH SYNOPSIS
  .B ccat
! [ \-\fB3m\fP ]
  \fIfile\fP
  [ ... ]
  .SH DESCRIPTION
***************
*** 12,18 ****
  file (.pvect_*) file exists in the same directory, it is used to
  perturb the file accordingly.  By default, files are decrypted using
  standard 2-key hybrid mode single-DES.  The \-\fB3\fP option specifies
! 2-key hybrid mode triple DES.
  .LP
  \fBccat\fP is intended to assist in emergency access to CFS
  directories when no machine running a CFS daemon is available.  It is
--- 12,19 ----
  file (.pvect_*) file exists in the same directory, it is used to
  perturb the file accordingly.  By default, files are decrypted using
  standard 2-key hybrid mode single-DES.  The \-\fB3\fP option specifies
! 2-key hybrid mode triple DES.  The \-\fBm\fP option specifies 2-key
! hybrid mode MacGuffin.
  .LP
  \fBccat\fP is intended to assist in emergency access to CFS
  directories when no machine running a CFS daemon is available.  It is
diff -c ../cfs.1.1.2/ccat.c ./ccat.c
*** ../cfs.1.1.2/ccat.c	Mon Aug 29 13:19:35 1994
--- ./ccat.c	Sun Nov 27 03:00:32 1994
***************
*** 23,36 ****
   */
  
  /*
!  * cfs ccat - 1.1
   */
  #include <stdio.h>
  #include <rpc/rpc.h>
  #include <sys/time.h>
  #include <sys/file.h>
  #include <sys/stat.h>
  #include <strings.h>
  #include "nfsproto.h"
  #include "admproto.h"
  #include "cfs.h"
--- 23,41 ----
   */
  
  /*
!  * cfs ccat - 1.2
   */
  #include <stdio.h>
  #include <rpc/rpc.h>
  #include <sys/time.h>
  #include <sys/file.h>
  #include <sys/stat.h>
+ #ifdef SOLARIS2X
+ #include <string.h>
+ #define rindex strrchr
+ #else
  #include <strings.h>
+ #endif
  #include "nfsproto.h"
  #include "admproto.h"
  #include "cfs.h"
***************
*** 38,43 ****
--- 43,49 ----
  /* following are never used - just so i can re-use the library */
  int validhost;
  char zerovect[]={0,0,0,0,0,0,0,0,0};
+ int cursecs=0;
  
  main(argc,argv)
       int argc;
***************
*** 67,79 ****
  			    case '3':
  				ciph=CFS_THREE_DES;
  				break;
  			    default:
! 				fprintf(stderr,"usage: ccat [-3] file ...\n");
  				exit(1);
  			}
  	}
  	if (argc<1) {
! 		fprintf(stderr,"Usage: ccat [-3] file ...\n");
  		exit(1);
  	}
  	if ((pw=getpassword("Key:"))==NULL) {
--- 73,88 ----
  			    case '3':
  				ciph=CFS_THREE_DES;
  				break;
+ 			    case 'm':
+ 				ciph=CFS_MACGUFFIN;
+ 				break;
  			    default:
! 				fprintf(stderr,"usage: ccat [-3m] file ...\n");
  				exit(1);
  			}
  	}
  	if (argc<1) {
! 		fprintf(stderr,"Usage: ccat [-3m] file ...\n");
  		exit(1);
  	}
  	if ((pw=getpassword("Key:"))==NULL) {
diff -c ../cfs.1.1.2/cfs.c ./cfs.c
*** ../cfs.1.1.2/cfs.c	Fri Jul 15 10:57:58 1994
--- ./cfs.c	Sun Nov 27 03:12:10 1994
***************
*** 24,32 ****
  
  /*
   * Crypto file system
!  *  main
   * mab - 11/30/92
   * mab - 01/11/94
   */
  
  #include <stdio.h>
--- 24,33 ----
  
  /*
   * Crypto file system
!  *  main 1.2
   * mab - 11/30/92
   * mab - 01/11/94
+  * mab - 11/10/94
   */
  
  #include <stdio.h>
***************
*** 50,69 ****
  
  #ifdef SOLARIS2X
  void nfs_program_2();
! void adm_program_1();
  #include <string.h>
  #else
  int nfs_program_2();
! int adm_program_1();
  #endif
  
  char zerovect[]={0,0,0,0,0,0,0,0,0};
  
  main(argc,argv)
       int argc;
       char **argv;
  {
  	int port=CFS_PORT;
  	struct hostent *hp;
  	struct sockaddr_in sin;
  	int svrsock;
--- 51,75 ----
  
  #ifdef SOLARIS2X
  void nfs_program_2();
! void adm_program_2();
  #include <string.h>
  #else
  int nfs_program_2();
! int adm_program_2();
  #endif
  
+ void grimreap();
+ 
  char zerovect[]={0,0,0,0,0,0,0,0,0};
+ int cursecs;
  
  main(argc,argv)
       int argc;
       char **argv;
  {
  	int port=CFS_PORT;
+ 
+ 	struct timeval tv;
  	struct hostent *hp;
  	struct sockaddr_in sin;
  	int svrsock;
***************
*** 159,165 ****
  		fprintf(stderr, "Can't init CFS ADM rpcbind mapping\n");
  		exit(1);
  	}
! 	if (!svc_reg(tp, ADM_PROGRAM, ADM_VERSION, adm_program_1, nc)) {
  		fprintf(stderr,"Can't register CFS ADM\n");
  		exit(1);
  	}
--- 165,171 ----
  		fprintf(stderr, "Can't init CFS ADM rpcbind mapping\n");
  		exit(1);
  	}
! 	if (!svc_reg(tp, ADM_PROGRAM, ADM_VERSION, adm_program_2, nc)) {
  		fprintf(stderr,"Can't register CFS ADM\n");
  		exit(1);
  	}
***************
*** 187,200 ****
  		exit(1);
  	}
  	pmap_unset(ADM_PROGRAM,ADM_VERSION);
! 	if (!svc_register(tp,ADM_PROGRAM,ADM_VERSION,adm_program_1,
  			  IPPROTO_UDP)) {
  		fprintf(stderr,"Can't register CFS ADM\n");
  		exit(1);
  	}
  #endif
  
- 	initstuff();
  #ifndef	DEBUG
  	if ((pid=fork())!=0) {
  		if (pid<0) {
--- 193,205 ----
  		exit(1);
  	}
  	pmap_unset(ADM_PROGRAM,ADM_VERSION);
! 	if (!svc_register(tp,ADM_PROGRAM,ADM_VERSION,adm_program_2,
  			  IPPROTO_UDP)) {
  		fprintf(stderr,"Can't register CFS ADM\n");
  		exit(1);
  	}
  #endif
  
  #ifndef	DEBUG
  	if ((pid=fork())!=0) {
  		if (pid<0) {
***************
*** 207,212 ****
--- 212,224 ----
  #else
  	printf("cfs running DEBUG (%d)\n", getpid());
  #endif
+ 	initstuff();
+ 	/* and lauch the timeout handler (which we have to do in child) */
+ 	gettimeofday(&tv,NULL);
+ 	cursecs=tv.tv_sec;
+ 	signal(SIGALRM,grimreap);
+ 	alarm(60); /* every 60 secs */
+ 
  	svc_run(); /* do it */
  	fprintf(stderr,"Huh??  Where the hell am I?\n");
  	exit(1);
***************
*** 248,251 ****
--- 260,294 ----
  	/* clear out the instances table */
  	for (i=0; i<NINSTANCES; i++)
  		instances[i]=NULL;
+ }
+ 
+ /* look for instances to kill */
+ void grimreap()
+ {
+ 	struct timeval tv;
+ 	int i;
+ 
+ 	gettimeofday(&tv,NULL);
+ 	cursecs=tv.tv_sec;
+ #ifdef DEBUG
+ 	fprintf(stderr,"grimly reaping\n");
+ #endif
+ 	for (i=0; i<NINSTANCES; i++)
+ 		if (instances[i] != NULL) {
+ 			if ((instances[i]->timeout)
+ 			    && (instances[i]->timeout < cursecs))
+ 					instances[i]->dead=1;
+ 			if ((instances[i]->idle)
+ 			    && ((instances[i]->access + instances[i]->idle)
+ 				< cursecs))
+ 					instances[i]->dead=1;
+ #ifdef DEBUG
+ 			if (instances[i]->dead)
+ 				fprintf(stderr,"killed %d\n",i);
+ #endif
+ 		}
+ #ifdef REDO_ALRM
+ 	signal(SIGALRM,grimreap);
+ #endif
+ 	alarm(60);
  }
diff -c ../cfs.1.1.2/cfs.h ./cfs.h
*** ../cfs.1.1.2/cfs.h	Fri Jul 15 10:55:25 1994
--- ./cfs.h	Fri Nov 25 13:40:34 1994
***************
*** 22,27 ****
--- 22,31 ----
   * OF THIS SOFTWARE OR ITS FITNESS FOR ANY PARTICULAR PURPOSE.
   */
  
+ /* include files specific to cipher modules go here */
+ /* (i don't normally like nested includes) */
+ #include "mcg.h"
+ 
  #define H_REG 0
  #define H_ATTACH 0	/* same as regular */
  #define H_ROOT 1
***************
*** 42,50 ****
  
  #define STD_DES 0	/* 2 key hybrid single DES */
  #define THREE_DES 1	/* 2 key hybrid 3DES */
! #define IDEA 2		/* 2 key hybrid IDEA */
! #define BLOWFISH 3	/* 2 key hybrid BLOWFISH */
! #define SKIPJACK 4	/* 2 key hybrid SKIPJACK, (PCMCIA) */
  
  typedef struct fhdata {
  	u_char magic[8];/* 0x0123456789abcdef */
--- 46,55 ----
  
  #define STD_DES 0	/* 2 key hybrid single DES */
  #define THREE_DES 1	/* 2 key hybrid 3DES */
! #define IDEA 2		/* 2 key hybrid IDEA (n/a) */
! #define BLOWFISH 3	/* 2 key hybrid BLOWFISH (n/a) */
! #define SKIPJACK 4	/* 2 key hybrid SKIPJACK (PCMCIA) (n/a) */
! #define MCG 5		/* 2 key hybrid MacGuffin */
  
  typedef struct fhdata {
  	u_char magic[8];/* 0x0123456789abcdef */
***************
*** 88,106 ****
  
  #define SMSIZE (32768*CFSBLOCK)
  
! typedef struct cfskey {
  	int cipher;
  	union {	
! 		struct {
  			u_char primary[8];
  			u_char secondary[8];
  		} des;
! 		struct {
  			u_char primary1[8];
  			u_char primary2[8];
  			u_char secondary1[8];
  			u_char secondary2[8];
  		} des3;
  	} var;
  	char primask[SMSIZE];
  	char secmask[SMSIZE];
--- 93,115 ----
  
  #define SMSIZE (32768*CFSBLOCK)
  
! typedef struct cfskey {  /* TODO: make these expanded keys for DES also */
  	int cipher;
  	union {	
! 		struct { /* DES */
  			u_char primary[8];
  			u_char secondary[8];
  		} des;
! 		struct { /* 3DES */
  			u_char primary1[8];
  			u_char primary2[8];
  			u_char secondary1[8];
  			u_char secondary2[8];
  		} des3;
+ 		struct { /* MacGuffin */
+ 			mcg_key primary;
+ 			mcg_key secondary;
+ 		} mcg;
  	} var;
  	char primask[SMSIZE];
  	char secmask[SMSIZE];
***************
*** 117,126 ****
--- 126,140 ----
  	int id;		/* same as its position in instances[] */
  	int highsec;	/* use perturbation vectors */
  	int anon;	/* invisability */
+ 	int timeout;	/* absolute timeout (0 is infinite) */
+ 	int idle;	/* idle timer (0 is infinite) */
+ 	int access;	/* last access time (for use by idle timer) */
+ 	int dead;	/* to be killed */
  } instance;
  
  extern int cfserrno;
  extern int errno;
+ extern int cursecs;
  
  extern char zerovect[];
  
diff -c ../cfs.1.1.2/cfs_adm.c ./cfs_adm.c
*** ../cfs.1.1.2/cfs_adm.c	Sun Aug 28 15:47:45 1994
--- ./cfs_adm.c	Fri Nov 25 03:10:16 1994
***************
*** 23,29 ****
   */
  
  /*
!  * server adm rpc handlers - ver 1.1
   */
  #include <sys/types.h>
  #include <stdio.h>
--- 23,29 ----
   */
  
  /*
!  * server adm rpc handlers - ver 1.2
   */
  #include <sys/types.h>
  #include <stdio.h>
***************
*** 38,55 ****
  
  int topinstance = 0;
  
- 
  cfs_adm()
  {
  }
  
  void *
! admproc_null_1()
  {
  }
  
  cfsstat *
! admproc_attach_1(ap,rp)
       cfs_attachargs *ap;
       SR *rp;
  {
--- 38,54 ----
  
  int topinstance = 0;
  
  cfs_adm()
  {
  }
  
  void *
! admproc_null_2()
  {
  }
  
  cfsstat *
! admproc_attach_2(ap,rp)
       cfs_attachargs *ap;
       SR *rp;
  {
***************
*** 106,116 ****
  	genmasks(&ins->key);
  	ins->uid=ap->uid;
  	ins->highsec=ap->highsec;
- 	ret=CFS_OK;
  	gettimeofday((struct timeval *)&roottime,NULL);
  	bzero(ins->check,8);
  	bcopy(&roottime,ins->check,sizeof(roottime));
  	cipher(&ins->key,ins->check,0);
  	return &ret;
  }
  
--- 105,122 ----
  	genmasks(&ins->key);
  	ins->uid=ap->uid;
  	ins->highsec=ap->highsec;
  	gettimeofday((struct timeval *)&roottime,NULL);
+ 	if (ap->expire !=0)
+ 		ins->timeout = roottime.seconds + (ap->expire*60);
+ 	else
+ 		ins->timeout = 0;
+ 	ins->access=roottime.seconds;
+ 	ins->idle=ap->idle * 60;
+ 	ins->dead=0;
  	bzero(ins->check,8);
  	bcopy(&roottime,ins->check,sizeof(roottime));
  	cipher(&ins->key,ins->check,0);
+ 	ret=CFS_OK;
  	return &ret;
  }
  
***************
*** 143,154 ****
  }
  
  cfsstat *
! admproc_detach_1(ap,rp)
       cfs_detachargs *ap;
       SR *rp;
  {
  	static cfsstat ret;
! 	int i,j;
  
  	if (strncmp(ap->name,".ANON_",6) == 0) {
  		i = atoi(&ap->name[6]);
--- 149,160 ----
  }
  
  cfsstat *
! admproc_detach_2(ap,rp)
       cfs_detachargs *ap;
       SR *rp;
  {
  	static cfsstat ret;
! 	int i;
  
  	if (strncmp(ap->name,".ANON_",6) == 0) {
  		i = atoi(&ap->name[6]);
***************
*** 163,168 ****
--- 169,185 ----
  		return &ret;
  	}
  found:
+ 	freeinstance(i);
+ 	ret=CFS_OK;
+ 	return &ret;
+ }
+ 
+ /* freeinstance is also called by geth if expired */
+ freeinstance(i)
+     int i;
+ {
+ 	int j;
+ 
  	for (j=0; j<HSIZE; j++) {
  		freelist(instances[i]->file[j]);
  		instances[i]->file[j]=NULL;
***************
*** 170,179 ****
  	bzero(instances[i],sizeof(instance));
  	free(instances[i]);
  	instances[i]=NULL;
- 	ret=CFS_OK;
  	gettimeofday((struct timeval *)&roottime,NULL);
  	closeall();
- 	return &ret;
  }
  
  freelist(f)
--- 187,194 ----
***************
*** 184,198 ****
  	freelist(f->next);
  	free(f->name);
  	free(f);
- }
- 
- cfs_lsrepl
- *admproc_ls_1()
- {
- 	cfs_lsrepl ret;
- 
- 	ret.status = CFSERR_EXIST;
- 	return &ret;
  }
  
  verify(path,k)
--- 199,204 ----
diff -c ../cfs.1.1.2/cfs_cipher.c ./cfs_cipher.c
*** ../cfs.1.1.2/cfs_cipher.c	Thu Jul 14 22:55:28 1994
--- ./cfs_cipher.c	Fri Nov 25 14:09:46 1994
***************
*** 44,49 ****
--- 44,55 ----
  		block_cipher(k->var.des3.primary2,s,1-d);
  		block_cipher(k->var.des3.primary1,s,d);
  		break;
+ 	    case MCG:
+ 		if (d)
+ 			mcg_block_decrypt(s,&k->var.mcg.primary);
+ 		else
+ 			mcg_block_encrypt(s,&k->var.mcg.primary);
+ 		break;
  	    default:	/* just does nothing */
  		break;
  	}
***************
*** 64,69 ****
--- 70,81 ----
  		block_cipher(k->var.des3.secondary2,s,1-d);
  		block_cipher(k->var.des3.secondary1,s,d);
  		break;
+ 	    case MCG:
+ 		if (d)
+ 			mcg_block_decrypt(s,&k->var.mcg.secondary);
+ 		else
+ 			mcg_block_encrypt(s,&k->var.mcg.secondary);
+ 		break;
  	    default:	/* just does nothing */
  		break;
  	}
***************
*** 93,98 ****
--- 105,117 ----
  		      k->var.des3.secondary1,8);
  		bcopy(key->cfs_admkey_u.des3key.secondary2,
  		      k->var.des3.secondary2,8);
+ 		break;
+ 	    case CFS_MACGUFFIN:
+ 		k->cipher=MCG;
+ 		mcg_keyset(key->cfs_admkey_u.mcgkey.primary,
+ 			   &k->var.mcg.primary);
+ 		mcg_keyset(key->cfs_admkey_u.mcgkey.secondary,
+ 			   &k->var.mcg.secondary);
  		break;
  	    default:
  		break;
diff -c ../cfs.1.1.2/cfs_fh.c ./cfs_fh.c
*** ../cfs.1.1.2/cfs_fh.c	Mon Aug 29 10:50:22 1994
--- ./cfs_fh.c	Sat Nov 26 07:50:13 1994
***************
*** 23,29 ****
   */
  
  /*
!  * cfs file handle support - 1.1
   *  local file system interface
   */
  
--- 23,29 ----
   */
  
  /*
!  * cfs file handle support - 1.2
   *  local file system interface
   */
  
***************
*** 408,413 ****
--- 408,419 ----
  	if (instances[h->instance] == NULL)
  		return NULL;	/* invalid/stale instance */
  	r=findh(h->fileid,h->instance);
+ 	/* instance may have timed out */
+ 	if ((r != NULL) && (r->ins->dead != 0)) {
+ 		/* if so, we GC it first */
+ 		freeinstance(h->instance);
+ 		r=NULL;
+ 	}
  	if ((r==NULL) || (bcmp(r->ins->check,h->check,8)!=0))
  		return NULL;	/* cheater */
  	return r;
***************
*** 488,493 ****
--- 494,501 ----
  		return 1;
  	if (f->fileid == 1)	/* special case */
  		return 1;
+ 	if (f->ins->idle && f->fileid) /* update idle timer */
+ 		f->ins->access=cursecs;
  	return (f->ins->uid==u);
  }
  
diff -c ../cfs.1.1.2/cfs_nfs.c ./cfs_nfs.c
*** ../cfs.1.1.2/cfs_nfs.c	Mon Aug 29 09:18:17 1994
--- ./cfs_nfs.c	Thu Nov 24 17:55:39 1994
***************
*** 1020,1027 ****
  	f->nlink=4;
  	f->uid=0;
  	f->gid=0;
! 	f->size=4096;
! 	f->blocksize=4096;
  	f->rdev= -1;
  	f->blocks=1;
  	f->fsid=0;
--- 1020,1027 ----
  	f->nlink=4;
  	f->uid=0;
  	f->gid=0;
! 	f->size=8192;
! 	f->blocksize=8192;
  	f->rdev= -1;
  	f->blocks=1;
  	f->fsid=0;
***************
*** 1035,1042 ****
  setstatfsokres(s)
  	statfsokres *s;
  {
! 	s->tsize=4096;
! 	s->bsize=4096;
  	s->blocks=0;
  	s->bfree=0;
  	s->bavail=0;
--- 1035,1042 ----
  setstatfsokres(s)
  	statfsokres *s;
  {
! 	s->tsize=8192;
! 	s->bsize=8192;
  	s->blocks=0;
  	s->bfree=0;
  	s->bavail=0;
diff -c ../cfs.1.1.2/cmkdir.1 ./cmkdir.1
*** ../cfs.1.1.2/cmkdir.1	Thu Jul 14 22:10:30 1994
--- ./cmkdir.1	Sat Nov 26 17:54:21 1994
***************
*** 1,9 ****
  .TH CMKDIR 1 ""
  .SH NAME
! cmkdir
  .SH SYNOPSIS
  .B cmkdir
! [ \-\fB3\fP ]
  \fIdirectory\fP
  .SH DESCRIPTION
  \fBcmkdir\fP creates \fIdirectory\fP and assigns to it cryptographic
--- 1,9 ----
  .TH CMKDIR 1 ""
  .SH NAME
! cmkdir - create encrypted directory for CFS
  .SH SYNOPSIS
  .B cmkdir
! [ \-\fB3m\fP ]
  \fIdirectory\fP
  .SH DESCRIPTION
  \fBcmkdir\fP creates \fIdirectory\fP and assigns to it cryptographic
***************
*** 21,29 ****
  .LP
  By default, \fBcmkdir\fP creates directories for 2-key hybrid mode
  single DES.  The \-\fB3\fP option specifies 2-key hybrid mode triple
! DES; this may be more secure, albiet at the expense of performance.
! Other ciphers may also be available, depending on the local
! configuration.
  .SH FILES
  .TP
  \fIdirectory\fP/...
--- 21,34 ----
  .LP
  By default, \fBcmkdir\fP creates directories for 2-key hybrid mode
  single DES.  The \-\fB3\fP option specifies 2-key hybrid mode triple
! DES; this is more secure, albiet at the expense of performance.  Other
! ciphers may also be available, depending on the local configuration.
! .LP
! A new experimental block cipher is included in the default
! distribution.  The \-\fBm\fP option specifies Blaze and Schneier's
! "MacGuffin" cipher.  It has 32 rounds, a 64 bit codebook size and a
! 128 bit nominal keyspace.  Use this cipher at your own risk; it may be
! much weaker than its keyspace suggests.
  .SH FILES
  .TP
  \fIdirectory\fP/...
***************
*** 33,38 ****
  identifies the cipher algorithm.
  .SH SEE ALSO
  cfsd(8), cattach(1)
  .SH AUTHOR
  Matt Blaze; for information on cfs, email to cfs@research.att.com.
- 
--- 38,46 ----
  identifies the cipher algorithm.
  .SH SEE ALSO
  cfsd(8), cattach(1)
+ .SH BUGS
+ The MacGuffin cipher isn't nearly as well-studied as DES.  It is
+ included primarly as an example.  The author's personal files remain
+ protected with DES.
  .SH AUTHOR
  Matt Blaze; for information on cfs, email to cfs@research.att.com.
diff -c ../cfs.1.1.2/cmkdir.c ./cmkdir.c
*** ../cfs.1.1.2/cmkdir.c	Thu Jul 14 22:58:11 1994
--- ./cmkdir.c	Fri Nov 25 14:04:53 1994
***************
*** 23,29 ****
   */
  
  /*
!  * client cfs mkdir - 1.1
   */
  #include <stdio.h>
  #include <rpc/rpc.h>
--- 23,29 ----
   */
  
  /*
!  * client cfs mkdir - 1.2
   */
  #include <stdio.h>
  #include <rpc/rpc.h>
***************
*** 56,67 ****
  			    case '3':
  				ciph=CFS_THREE_DES;
  				break;
  			    default:
! 				fprintf(stderr,"usage: cmkdir [-3] dir\n");                               exit(1);
  			}
  	}
  	if (argc!=1) {
! 		fprintf(stderr,"Usage: cmkdir [-3] dir\n");
  		exit(1);
  	}
  	if ((pw=getpassword("Key:"))==NULL) {
--- 56,70 ----
  			    case '3':
  				ciph=CFS_THREE_DES;
  				break;
+ 			    case 'm':
+ 				ciph=CFS_MACGUFFIN;
+ 				break;
  			    default:
! 				fprintf(stderr,"usage: cmkdir [-3m] dir\n");                               exit(1);
  			}
  	}
  	if (argc!=1) {
! 		fprintf(stderr,"Usage: cmkdir [-3m] dir\n");
  		exit(1);
  	}
  	if ((pw=getpassword("Key:"))==NULL) {
diff -c ../cfs.1.1.2/cname.8 ./cname.8
*** ../cfs.1.1.2/cname.8	Mon Aug 29 13:45:09 1994
--- ./cname.8	Sat Nov 26 17:20:54 1994
***************
*** 3,9 ****
  cname
  .SH SYNOPSIS
  .B cname
! [ \-\fB3\fP ]
  [ \-\fBv\fP ]
  .SH DESCRIPTION
  \fBcname\fP prompts for a passphrase and reads, from standard input, a
--- 3,9 ----
  cname
  .SH SYNOPSIS
  .B cname
! [ \-\fB3m\fP ]
  [ \-\fBv\fP ]
  .SH DESCRIPTION
  \fBcname\fP prompts for a passphrase and reads, from standard input, a
***************
*** 11,17 ****
  produces, on standard output, a corresponding list of cleartext names.
  By default, names are decrypted using standard 2-key hybrid mode
  single-DES.  The \-\fB3\fP option specifies 2-key hybrid mode triple
! DES.  The -v option includes the ciphertext names in the output.
  .LP
  All names must be specified one per input line, as individual path
  components (full path names are not accepted).  If a name cannot be
--- 11,18 ----
  produces, on standard output, a corresponding list of cleartext names.
  By default, names are decrypted using standard 2-key hybrid mode
  single-DES.  The \-\fB3\fP option specifies 2-key hybrid mode triple
! DES.  \-\fBm\fP specifies 2-key hybrid MacGuffin. The \-\fBv\fP option
! includes the ciphertext names in the output.
  .LP
  All names must be specified one per input line, as individual path
  components (full path names are not accepted).  If a name cannot be
diff -c ../cfs.1.1.2/cname.c ./cname.c
*** ../cfs.1.1.2/cname.c	Mon Aug 29 11:10:48 1994
--- ./cname.c	Fri Nov 25 14:03:57 1994
***************
*** 23,29 ****
   */
  
  /*
!  * cfs cname - 1.1
   */
  #include <stdio.h>
  #include <rpc/rpc.h>
--- 23,29 ----
   */
  
  /*
!  * cfs cname - 1.2
   */
  #include <stdio.h>
  #include <rpc/rpc.h>
***************
*** 36,41 ****
--- 36,44 ----
  /* following are never used - just so i can re-use the library */
  int validhost;
  char zerovect[]={0,0,0,0,0,0,0,0,0};
+ int cursecs=0;
+ 
+ char *gets();
  
  main(argc,argv)
       int argc;
***************
*** 47,53 ****
  	cfs_admkey k;
  	cfskey kt;
  	char *flg;
! 	char *estr[1024];
  	char *cstr;
  	int i;
  	int ciph=CFS_STD_DES;
--- 50,56 ----
  	cfs_admkey k;
  	cfskey kt;
  	char *flg;
! 	char estr[1024];
  	char *cstr;
  	int i;
  	int ciph=CFS_STD_DES;
***************
*** 62,74 ****
  			    case '3':
  				ciph=CFS_THREE_DES;
  				break;
  			    default:
! 				fprintf(stderr,"usage: cname [-3]\n");
  				exit(1);
  			}
  	}
  	if (argc!=0) {
! 		fprintf(stderr,"Usage: cname [-3]\n");
  		exit(1);
  	}
  	if ((pw=getpassword("Key:"))==NULL) {
--- 65,80 ----
  			    case '3':
  				ciph=CFS_THREE_DES;
  				break;
+ 			    case 'm':
+ 				ciph=CFS_MACGUFFIN;
+ 				break;
  			    default:
! 				fprintf(stderr,"usage: cname [-3m]\n");
  				exit(1);
  			}
  	}
  	if (argc!=0) {
! 		fprintf(stderr,"Usage: cname [-3m]\n");
  		exit(1);
  	}
  	if ((pw=getpassword("Key:"))==NULL) {
***************
*** 87,93 ****
  		cstr=decryptname(&kt,estr);
  		if (verb)
  			printf("%s -> ",estr);
! 		if (printable(cstr))
  			puts(cstr);
  		else
  			puts("???");
--- 93,99 ----
  		cstr=decryptname(&kt,estr);
  		if (verb)
  			printf("%s -> ",estr);
! 		if ((cstr!=NULL) && printable(cstr))
  			puts(cstr);
  		else
  			puts("???");
diff -c ../cfs.1.1.2/getpass.c ./getpass.c
*** ../cfs.1.1.2/getpass.c	Tue Jul 19 00:32:12 1994
--- ./getpass.c	Fri Nov 25 13:56:55 1994
***************
*** 105,110 ****
--- 105,115 ----
  
  	if ((l=strlen(b))<3)
  		return -1;
+ 	/* note that we always use the DES key crunch. */
+ 	/* that's not a significant weakness, since here DES */
+ 	/* is just being used as a non-cryptographic hash. */
+ 	/* note also that k1 and k2 are created from disjoint parts */
+ 	/* of the passphrase. */
  	key_crunch(&b[l/2],l-l/2,k1);
  	key_crunch(b,l/2,k2);
  	switch (k->cipher) {
***************
*** 117,122 ****
--- 122,133 ----
  		bcopy(k1,k->cfs_admkey_u.des3key.secondary1,8);
  		bcopy(k2,k->cfs_admkey_u.des3key.primary2,8);
  		bcopy(k2,k->cfs_admkey_u.des3key.secondary2,8);
+ 		break;
+ 	    case CFS_MACGUFFIN:
+ 		bcopy(k1,k->cfs_admkey_u.mcgkey.primary,8);
+ 		bcopy(k2,&(k->cfs_admkey_u.mcgkey.primary[8]),8);
+ 		bcopy(k1,k->cfs_admkey_u.mcgkey.secondary,8);
+ 		bcopy(k2,&(k->cfs_admkey_u.mcgkey.secondary[8]),8);
  		break;
  	    default:
  		break;
diff -c ../cfs.1.1.2/mcg.c ./mcg.c
*** ../cfs.1.1.2/mcg.c	Fri Nov 25 14:50:16 1994
--- ./mcg.c	Fri Nov 25 13:30:46 1994
***************
*** 0 ****
--- 1,222 ----
+ /*
+  * The author of this software is Matt Blaze.
+  *              Copyright (c) 1994 by AT&T.
+  * Permission to use, copy, and modify this software without fee
+  * is hereby granted, provided that this entire notice is included in
+  * all copies of any software which is or includes a copy or
+  * modification of this software and in all copies of the supporting
+  * documentation for such software.
+  *
+  * This software is subject to United States export controls.  You may
+  * not export it, in whole or in part, or cause or allow such export,
+  * through act or omission, without prior authorization from the United
+  * States government and written permission from AT&T.  In particular,
+  * you may not make any part of this software available for general or
+  * unrestricted distribution to others, nor may you disclose this software
+  * to persons other than citizens and permanent residents of the United
+  * States and Canada. 
+  *
+  * THIS SOFTWARE IS BEING PROVIDED "AS IS", WITHOUT ANY EXPRESS OR IMPLIED
+  * WARRANTY.  IN PARTICULAR, NEITHER THE AUTHORS NOR AT&T MAKE ANY
+  * REPRESENTATION OR WARRANTY OF ANY KIND CONCERNING THE MERCHANTABILITY
+  * OF THIS SOFTWARE OR ITS FITNESS FOR ANY PARTICULAR PURPOSE.
+  */
+ 
+ /*
+  * macguffin block encrypt/decrypt
+  * unrolled, constant mask (optimized) version
+  * 
+  * For a complete description of MacGuffin, see
+  * M. Blaze & B. Schneier, "The MacGuffin Block Cipher Algorithm",
+  * proc. 2nd Workshop on Cryptographic Algorithms, Leuven, Belgium, 1994.
+  *
+  * 10/4/94 matt blaze
+  */
+ 
+ #include "mcg.h"
+ 
+ /*
+  * codebook encrypt one block with given expanded key
+  */
+ mcg_block_encrypt(blk,key)
+      unsigned char *blk;
+      mcg_key *key;
+ 
+ {
+ 	unsigned short r0, r1, r2, r3, a, b, c;
+ 	int i;
+ 	unsigned short *ek;
+ 
+ 	r0=blk[0]|(blk[1]<<8);
+ 	r1=blk[2]|(blk[3]<<8);
+ 	r2=blk[4]|(blk[5]<<8);
+ 	r3=blk[6]|(blk[7]<<8);
+ 	
+ 	ek = &(key->val[0]);
+ 	/*
+ 	 * round loop, unrolled 4x
+ 	 */
+ 	for (i=0; i<8; i++) {
+ 		a = r1 ^ *(ek++);
+ 		b = r2 ^ *(ek++);
+ 		c = r3 ^ *(ek++);
+ 		r0 ^= ((OUT0 & stable[(a & LOOK00) |
+ 				      (b & LOOK01) |
+ 				      (c & LOOK02)])
+ 		       | (OUT1 & stable[(a & LOOK10) |
+ 					(b & LOOK11) |
+ 					(c & LOOK12)])
+ 		       | (OUT2 & stable[(a & LOOK20) |
+ 					(b & LOOK21) |
+ 					(c & LOOK22)])
+ 		       | (OUT3 & stable[(a & LOOK30) |
+ 					(b & LOOK31) |
+ 					(c & LOOK32)]));
+ 		a = r2 ^ *(ek++);
+ 		b = r3 ^ *(ek++);
+ 		c = r0 ^ *(ek++);
+ 		r1 ^= ((OUT0 & stable[(a & LOOK00) |
+ 				      (b & LOOK01) |
+ 				      (c & LOOK02)])
+ 		       | (OUT1 & stable[(a & LOOK10) |
+ 					(b & LOOK11) |
+ 					(c & LOOK12)])
+ 		       | (OUT2 & stable[(a & LOOK20) |
+ 					(b & LOOK21) |
+ 					(c & LOOK22)])
+ 		       | (OUT3 & stable[(a & LOOK30) |
+ 					(b & LOOK31) |
+ 					(c & LOOK32)]));
+ 		a = r3 ^ *(ek++);
+ 		b = r0 ^ *(ek++);
+ 		c = r1 ^ *(ek++);
+ 		r2 ^= ((OUT0 & stable[(a & LOOK00) |
+ 				      (b & LOOK01) |
+ 				      (c & LOOK02)])
+ 		       | (OUT1 & stable[(a & LOOK10) |
+ 					(b & LOOK11) |
+ 					(c & LOOK12)])
+ 		       | (OUT2 & stable[(a & LOOK20) |
+ 					(b & LOOK21) |
+ 					(c & LOOK22)])
+ 		       | (OUT3 & stable[(a & LOOK30) |
+ 					(b & LOOK31) |
+ 					(c & LOOK32)]));
+ 		a = r0 ^ *(ek++);
+ 		b = r1 ^ *(ek++);
+ 		c = r2 ^ *(ek++);
+ 		r3 ^= ((OUT0 & stable[(a & LOOK00) |
+ 				      (b & LOOK01) |
+ 				      (c & LOOK02)])
+ 		       | (OUT1 & stable[(a & LOOK10) |
+ 					(b & LOOK11) |
+ 					(c & LOOK12)])
+ 		       | (OUT2 & stable[(a & LOOK20) |
+ 					(b & LOOK21) |
+ 					(c & LOOK22)])
+ 		       | (OUT3 & stable[(a & LOOK30) |
+ 					(b & LOOK31) |
+ 					(c & LOOK32)]));
+ 	}
+ 	blk[0] = r0;
+ 	blk[1] = r0>>8;
+ 	blk[2] = r1;
+ 	blk[3] = r1>>8;
+ 	blk[4] = r2;
+ 	blk[5] = r2>>8;
+ 	blk[6] = r3;
+ 	blk[7] = r3>>8;
+ }
+ 
+ /*
+  * codebook decrypt one block with given expanded key
+  */
+ mcg_block_decrypt(blk,key)
+      unsigned char *blk;
+      mcg_key *key;
+ 
+ {
+ 	unsigned short r0, r1, r2, r3, a, b, c;
+ 	int i;
+ 	unsigned short *ek;
+ 
+ 	r0=blk[0]|(blk[1]<<8);
+ 	r1=blk[2]|(blk[3]<<8);
+ 	r2=blk[4]|(blk[5]<<8);
+ 	r3=blk[6]|(blk[7]<<8);
+ 
+ 	ek = &(key->val[KSIZE]);
+ 	/*
+ 	 * round loop, unrolled 4x
+ 	 */
+ 	for (i=0; i<8; ++i) {
+ 		c = r2 ^ *(--ek);
+ 		b = r1 ^ *(--ek);
+ 		a = r0 ^ *(--ek);
+ 		r3 ^= ((OUT0 & stable[(a & LOOK00) |
+ 				      (b & LOOK01) |
+ 				      (c & LOOK02)])
+ 		       | (OUT1 & stable[(a & LOOK10) |
+ 					(b & LOOK11) |
+ 					(c & LOOK12)])
+ 		       | (OUT2 & stable[(a & LOOK20) |
+ 					(b & LOOK21) |
+ 					(c & LOOK22)])
+ 		       | (OUT3 & stable[(a & LOOK30) |
+ 					(b & LOOK31) |
+ 					(c & LOOK32)]));
+ 		c = r1 ^ *(--ek);
+ 		b = r0 ^ *(--ek);
+ 		a = r3 ^ *(--ek);
+ 		r2 ^= ((OUT0 & stable[(a & LOOK00) |
+ 				      (b & LOOK01) |
+ 				      (c & LOOK02)])
+ 		       | (OUT1 & stable[(a & LOOK10) |
+ 					(b & LOOK11) |
+ 					(c & LOOK12)])
+ 		       | (OUT2 & stable[(a & LOOK20) |
+ 					(b & LOOK21) |
+ 					(c & LOOK22)])
+ 		       | (OUT3 & stable[(a & LOOK30) |
+ 					(b & LOOK31) |
+ 					(c & LOOK32)]));
+ 		c = r0 ^ *(--ek);
+ 		b = r3 ^ *(--ek);
+ 		a = r2 ^ *(--ek);
+ 		r1 ^= ((OUT0 & stable[(a & LOOK00) |
+ 				      (b & LOOK01) |
+ 				      (c & LOOK02)])
+ 		       | (OUT1 & stable[(a & LOOK10) |
+ 					(b & LOOK11) |
+ 					(c & LOOK12)])
+ 		       | (OUT2 & stable[(a & LOOK20) |
+ 					(b & LOOK21) |
+ 					(c & LOOK22)])
+ 		       | (OUT3 & stable[(a & LOOK30) |
+ 					(b & LOOK31) |
+ 					(c & LOOK32)]));
+ 		c = r3 ^ *(--ek);
+ 		b = r2 ^ *(--ek);
+ 		a = r1 ^ *(--ek);
+ 		r0 ^= ((OUT0 & stable[(a & LOOK00) |
+ 				      (b & LOOK01) |
+ 				      (c & LOOK02)])
+ 		       | (OUT1 & stable[(a & LOOK10) |
+ 					(b & LOOK11) |
+ 					(c & LOOK12)])
+ 		       | (OUT2 & stable[(a & LOOK20) |
+ 					(b & LOOK21) |
+ 					(c & LOOK22)])
+ 		       | (OUT3 & stable[(a & LOOK30) |
+ 					(b & LOOK31) |
+ 					(c & LOOK32)]));
+ 	}
+ 	blk[0] = r0;
+ 	blk[1] = r0>>8;
+ 	blk[2] = r1;
+ 	blk[3] = r1>>8;
+ 	blk[4] = r2;
+ 	blk[5] = r2>>8;
+ 	blk[6] = r3;
+ 	blk[7] = r3>>8;
+ }
diff -c ../cfs.1.1.2/mcg.h ./mcg.h
*** ../cfs.1.1.2/mcg.h	Fri Nov 25 14:50:17 1994
--- ./mcg.h	Fri Nov 25 13:29:29 1994
***************
*** 0 ****
--- 1,65 ----
+ /*
+  * The author of this software is Matt Blaze.
+  *              Copyright (c) 1994 by AT&T.
+  * Permission to use, copy, and modify this software without fee
+  * is hereby granted, provided that this entire notice is included in
+  * all copies of any software which is or includes a copy or
+  * modification of this software and in all copies of the supporting
+  * documentation for such software.
+  *
+  * This software is subject to United States export controls.  You may
+  * not export it, in whole or in part, or cause or allow such export,
+  * through act or omission, without prior authorization from the United
+  * States government and written permission from AT&T.  In particular,
+  * you may not make any part of this software available for general or
+  * unrestricted distribution to others, nor may you disclose this software
+  * to persons other than citizens and permanent residents of the United
+  * States and Canada. 
+  *
+  * THIS SOFTWARE IS BEING PROVIDED "AS IS", WITHOUT ANY EXPRESS OR IMPLIED
+  * WARRANTY.  IN PARTICULAR, NEITHER THE AUTHORS NOR AT&T MAKE ANY
+  * REPRESENTATION OR WARRANTY OF ANY KIND CONCERNING THE MERCHANTABILITY
+  * OF THIS SOFTWARE OR ITS FITNESS FOR ANY PARTICULAR PURPOSE.
+  */
+ 
+ /* MacGuffin Constants */
+ 
+ #define SIZE (1<<16)
+ extern unsigned short stable[SIZE];
+ extern unsigned short lookupmasks[4][3];
+ extern unsigned short outputmasks[4];
+ 
+ /*
+  * input and output lookup masks
+  */
+ 
+ /* s1+s2 */
+ #define LOOK00	0x0036
+ #define LOOK01	0x06c0
+ #define LOOK02	0x6900
+ #define OUT0	0x000f
+ 
+ /* s3+s4 */
+ #define LOOK10	0x5048
+ #define LOOK11	0x2106
+ #define LOOK12	0x8411
+ #define OUT1	0x00f0
+ 
+ /* s5+s7 */
+ #define LOOK20	0x8601
+ #define LOOK21	0x4828
+ #define LOOK22	0x10c4
+ #define OUT2	0x3300
+ 
+ /* s6+s8 */
+ #define LOOK30	0x2980
+ #define LOOK31	0x9011
+ #define LOOK32	0x022a
+ #define OUT3	0xcc00
+ 
+ #define ROUNDS 32
+ #define KSIZE (ROUNDS*3)
+ typedef struct mcg_key {
+ 	unsigned short val[KSIZE];
+ } mcg_key;
+ 
diff -c ../cfs.1.1.2/mcgsbox.c ./mcgsbox.c
*** ../cfs.1.1.2/mcgsbox.c	Fri Nov 25 14:50:20 1994
--- ./mcgsbox.c	Sun Nov 27 03:00:32 1994
***************
*** 0 ****
--- 1,221 ----
+ /*
+  * The author of this software is Matt Blaze.
+  *              Copyright (c) 1992, 1993, 1994 by AT&T.
+  * Permission to use, copy, and modify this software without fee
+  * is hereby granted, provided that this entire notice is included in
+  * all copies of any software which is or includes a copy or
+  * modification of this software and in all copies of the supporting
+  * documentation for such software.
+  *
+  * This software is subject to United States export controls.  You may
+  * not export it, in whole or in part, or cause or allow such export,
+  * through act or omission, without prior authorization from the United
+  * States government and written permission from AT&T.  In particular,
+  * you may not make any part of this software available for general or
+  * unrestricted distribution to others, nor may you disclose this software
+  * to persons other than citizens and permanent residents of the United
+  * States and Canada. 
+  *
+  * THIS SOFTWARE IS BEING PROVIDED "AS IS", WITHOUT ANY EXPRESS OR IMPLIED
+  * WARRANTY.  IN PARTICULAR, NEITHER THE AUTHORS NOR AT&T MAKE ANY
+  * REPRESENTATION OR WARRANTY OF ANY KIND CONCERNING THE MERCHANTABILITY
+  * OF THIS SOFTWARE OR ITS FITNESS FOR ANY PARTICULAR PURPOSE.
+  */
+ 
+ /*
+  * MacGuffin optimized table initialization and key setup
+  *
+  * 10/3/94 matt blaze
+  */
+ 
+ 
+ #include "mcg.h"
+ 
+ /*
+  * the 8 s-boxes, expanded to put the output bits in the right
+  * places.  note that these are the des s-boxes (in left-right,
+  * not cannonical, order), but with only the "outer" two output
+  * bits.
+  */
+ unsigned short sboxes[8][64] = {
+ /* 0 (S1) */
+ 	{0x0002, 0x0000, 0x0000, 0x0003, 0x0003, 0x0001, 0x0001, 0x0000,
+ 	 0x0000, 0x0002, 0x0003, 0x0000, 0x0003, 0x0003, 0x0002, 0x0001,
+ 	 0x0001, 0x0002, 0x0002, 0x0000, 0x0000, 0x0002, 0x0002, 0x0003,
+ 	 0x0001, 0x0003, 0x0003, 0x0001, 0x0000, 0x0001, 0x0001, 0x0002,
+ 	 0x0000, 0x0003, 0x0001, 0x0002, 0x0002, 0x0002, 0x0002, 0x0000,
+ 	 0x0003, 0x0000, 0x0000, 0x0003, 0x0000, 0x0001, 0x0003, 0x0001,
+ 	 0x0003, 0x0001, 0x0002, 0x0003, 0x0003, 0x0001, 0x0001, 0x0002,
+ 	 0x0001, 0x0002, 0x0002, 0x0000, 0x0001, 0x0000, 0x0000, 0x0003},
+ /* 1 (S2) */
+ 	{0x000c, 0x0004, 0x0004, 0x000c, 0x0008, 0x0000, 0x0008, 0x0004,
+ 	 0x0000, 0x000c, 0x000c, 0x0000, 0x0004, 0x0008, 0x0000, 0x0008,
+ 	 0x000c, 0x0008, 0x0004, 0x0000, 0x0000, 0x0004, 0x000c, 0x0008,
+ 	 0x0008, 0x0000, 0x0000, 0x000c, 0x0004, 0x000c, 0x0008, 0x0004,
+ 	 0x0000, 0x000c, 0x0008, 0x0008, 0x0004, 0x0008, 0x000c, 0x0004,
+ 	 0x0008, 0x0004, 0x0000, 0x000c, 0x000c, 0x0000, 0x0004, 0x0000,
+ 	 0x0004, 0x000c, 0x0008, 0x0000, 0x0008, 0x0004, 0x0000, 0x0008,
+ 	 0x000c, 0x0000, 0x0004, 0x0004, 0x0000, 0x0008, 0x000c, 0x000c},
+ /* 2 (S3) */
+ 	{0x0020, 0x0030, 0x0000, 0x0010, 0x0030, 0x0000, 0x0020, 0x0030,
+ 	 0x0000, 0x0010, 0x0010, 0x0000, 0x0030, 0x0000, 0x0010, 0x0020,
+ 	 0x0010, 0x0000, 0x0030, 0x0020, 0x0020, 0x0010, 0x0010, 0x0020,
+ 	 0x0030, 0x0020, 0x0000, 0x0030, 0x0000, 0x0030, 0x0020, 0x0010,
+ 	 0x0030, 0x0010, 0x0000, 0x0020, 0x0000, 0x0030, 0x0030, 0x0000,
+ 	 0x0020, 0x0000, 0x0030, 0x0030, 0x0010, 0x0020, 0x0000, 0x0010,
+ 	 0x0030, 0x0000, 0x0010, 0x0030, 0x0000, 0x0020, 0x0020, 0x0010,
+ 	 0x0010, 0x0030, 0x0020, 0x0010, 0x0020, 0x0000, 0x0010, 0x0020},
+ /* 3 (S4) */
+ 	{0x0040, 0x00c0, 0x00c0, 0x0080, 0x0080, 0x00c0, 0x0040, 0x0040,
+ 	 0x0000, 0x0000, 0x0000, 0x00c0, 0x00c0, 0x0000, 0x0080, 0x0040,
+ 	 0x0040, 0x0000, 0x0000, 0x0040, 0x0080, 0x0000, 0x0040, 0x0080,
+ 	 0x00c0, 0x0040, 0x0080, 0x0080, 0x0000, 0x0080, 0x00c0, 0x00c0,
+ 	 0x0080, 0x0040, 0x0000, 0x00c0, 0x00c0, 0x0000, 0x0000, 0x0000,
+ 	 0x0080, 0x0080, 0x00c0, 0x0040, 0x0040, 0x00c0, 0x00c0, 0x0080,
+ 	 0x00c0, 0x00c0, 0x0040, 0x0000, 0x0040, 0x0040, 0x0080, 0x00c0,
+ 	 0x0040, 0x0080, 0x0000, 0x0040, 0x0080, 0x0000, 0x0000, 0x0080},
+ /* 4 (S5) */
+ 	{0x0000, 0x0200, 0x0200, 0x0300, 0x0000, 0x0000, 0x0100, 0x0200,
+ 	 0x0100, 0x0000, 0x0200, 0x0100, 0x0300, 0x0300, 0x0000, 0x0100,
+ 	 0x0200, 0x0100, 0x0100, 0x0000, 0x0100, 0x0300, 0x0300, 0x0200,
+ 	 0x0300, 0x0100, 0x0000, 0x0300, 0x0200, 0x0200, 0x0300, 0x0000,
+ 	 0x0000, 0x0300, 0x0000, 0x0200, 0x0100, 0x0200, 0x0300, 0x0100,
+ 	 0x0200, 0x0100, 0x0300, 0x0200, 0x0100, 0x0000, 0x0200, 0x0300,
+ 	 0x0300, 0x0000, 0x0300, 0x0300, 0x0200, 0x0000, 0x0100, 0x0300,
+ 	 0x0000, 0x0200, 0x0100, 0x0000, 0x0000, 0x0100, 0x0200, 0x0100},
+ /* 5 (S6) */
+ 	{0x0800, 0x0800, 0x0400, 0x0c00, 0x0800, 0x0000, 0x0c00, 0x0000,
+ 	 0x0c00, 0x0400, 0x0000, 0x0800, 0x0000, 0x0c00, 0x0800, 0x0400,
+ 	 0x0000, 0x0000, 0x0c00, 0x0400, 0x0400, 0x0c00, 0x0000, 0x0800,
+ 	 0x0800, 0x0000, 0x0400, 0x0c00, 0x0400, 0x0400, 0x0c00, 0x0800,
+ 	 0x0c00, 0x0000, 0x0800, 0x0400, 0x0c00, 0x0000, 0x0400, 0x0800,
+ 	 0x0000, 0x0c00, 0x0800, 0x0400, 0x0800, 0x0c00, 0x0400, 0x0800,
+ 	 0x0400, 0x0c00, 0x0000, 0x0800, 0x0000, 0x0400, 0x0800, 0x0400,
+ 	 0x0400, 0x0000, 0x0c00, 0x0000, 0x0c00, 0x0800, 0x0000, 0x0c00},
+ /* 6 (S7) */
+ 	{0x0000, 0x3000, 0x3000, 0x0000, 0x0000, 0x3000, 0x2000, 0x1000,
+ 	 0x3000, 0x0000, 0x0000, 0x3000, 0x2000, 0x1000, 0x3000, 0x2000,
+ 	 0x1000, 0x2000, 0x2000, 0x1000, 0x3000, 0x1000, 0x1000, 0x2000,
+ 	 0x1000, 0x0000, 0x2000, 0x3000, 0x0000, 0x2000, 0x1000, 0x0000,
+ 	 0x1000, 0x0000, 0x0000, 0x3000, 0x3000, 0x3000, 0x3000, 0x2000,
+ 	 0x2000, 0x1000, 0x1000, 0x0000, 0x1000, 0x2000, 0x2000, 0x1000,
+ 	 0x2000, 0x3000, 0x3000, 0x1000, 0x0000, 0x0000, 0x2000, 0x3000,
+ 	 0x0000, 0x2000, 0x1000, 0x0000, 0x3000, 0x1000, 0x0000, 0x2000},
+ /* 7 (S8) */
+ 	{0xc000, 0x4000, 0x0000, 0xc000, 0x8000, 0xc000, 0x0000, 0x8000,
+ 	 0x0000, 0x8000, 0xc000, 0x4000, 0xc000, 0x4000, 0x4000, 0x0000,
+ 	 0x8000, 0x8000, 0xc000, 0x4000, 0x4000, 0x0000, 0x8000, 0xc000,
+ 	 0x4000, 0x0000, 0x0000, 0x8000, 0x8000, 0xc000, 0x4000, 0x0000,
+ 	 0x4000, 0x0000, 0xc000, 0x4000, 0x0000, 0x8000, 0x4000, 0x4000,
+ 	 0xc000, 0x0000, 0x8000, 0x8000, 0x8000, 0x8000, 0x0000, 0xc000,
+ 	 0x0000, 0xc000, 0x0000, 0x8000, 0x8000, 0xc000, 0xc000, 0x0000,
+ 	 0xc000, 0x4000, 0x4000, 0x4000, 0x4000, 0x0000, 0x8000, 0xc000}};
+ 
+ /*
+  * table s-box outputs, expanded for 16 bit input
+  * this one table includes all 8 sboxes - just mask off
+  * the output bits not in use
+  */
+ unsigned short stable[SIZE];
+ 
+ /*
+  * we can exploit two features of the s-box input and output
+  * permutations - first, each s-box uses as input two different bits
+  * from each of the three registers in the right side, and, second,
+  * for each s-box there is another-sbox with no common input bits
+  * between them.  therefore we can lookup two s-box outputs in one
+  * probe of the table.  just mask off the approprate input bits
+  * in the table below for each of the three registers and or
+  * together for the table lookup index.
+  *
+  * These are also available in #defines, for better lookup 
+  * speed in unrolled loops.
+  */
+ unsigned short lookupmasks[4][3] = {
+ 	/* a   ,   b   ,   c    */
+ 	{0x0036, 0x06c0, 0x6900},	/* s1+s2 */
+ 	{0x5048, 0x2106, 0x8411},	/* s3+s4 */
+ 	{0x8601, 0x4828, 0x10c4},	/* s5+s7 */
+ 	{0x2980, 0x9011, 0x022a}};	/* s6+s8 */
+ 
+ /*
+  * this table contains the corresponding output masks for the table
+  * lookup procedure mentioned above.
+  *
+  * similarly available in #defines.
+  */
+ unsigned short outputmasks[4] = {
+ 	0x000f,	 /* s1+s2 */
+ 	0x00f0,	 /* s3+s4 */
+ 	0x3300,	 /* s5+s7 */
+ 	0xcc00}; /* s6+s8 */
+ 
+ 
+ 
+ /*
+  * initialize the macguffin s-box tables.
+  * this takes a while, but is only done once.
+  */
+ mcg_init()
+ {
+ 	unsigned int i,j,k;
+ 	int b;
+ 	/*
+ 	 * input permutation for the 8 s-boxes.
+ 	 * each row entry is a bit position from
+ 	 * one of the three right hand registers,
+ 	 * as follows:
+ 	 *   a,a,b,b,c,c
+ 	 */
+ 	static int sbits[8][6] = {
+ 		{2,5,6,9,11,13},
+ 		{1,4,7,10,8,14},
+ 		{3,6,8,13,0,15},
+ 		{12,14,1,2,4,10},
+ 		{0,10,3,14,6,12},
+ 		{7,8,12,15,1,5},
+ 		{9,15,5,11,2,7},
+ 		{11,13,0,4,3,9}};
+ 
+ 	/* fill the table */
+ 	if ((stable[0]==0xc86e) && (stable[0xffff]==0xedaf))
+ 		return 0;
+ 	for (i=0; i<SIZE; i++) {
+ 		stable[i]=0;
+ 		for (j=0; j<8; j++)
+ 			stable[i] |=
+ 				sboxes[j][((i>>sbits[j][0])&1)
+ 					  |(((i>>sbits[j][1])&1)<<1)
+ 					  |(((i>>sbits[j][2])&1)<<2)
+ 					  |(((i>>sbits[j][3])&1)<<3)
+ 					  |(((i>>sbits[j][4])&1)<<4)
+ 					  |(((i>>sbits[j][5])&1)<<5)];
+ 		
+ 	}
+ 	return 1;
+ }
+ 
+ #ifdef SOLARIS2X
+ #define bcopy(s,d,l) memcpy(d,s,l)
+ #endif
+ 
+ mcg_keyset(key,ek)
+      unsigned char *key;
+      mcg_key *ek;
+ {
+ 	int i,j;
+ 	unsigned char k[2][8];
+ 
+ 	mcg_init();
+ 	bcopy(&key[0],k[0],8);
+ 	bcopy(&key[8],k[1],8);
+ 	for (i=0; i<KSIZE; i++)
+ 		ek->val[i]=0;
+ 	for (i=0; i<2; i++)
+ 		for (j=0; j<32; j++) {
+ 			mcg_block_encrypt(k[i],ek);
+ 			ek->val[j*3] ^= k[i][0] | (k[i][1]<<8);
+ 			ek->val[j*3+1] ^= k[i][2] | (k[i][3]<<8);
+ 			ek->val[j*3+2] ^= k[i][4] | (k[i][5]<<8);
+ 		}
+ }	
diff -c ../cfs.1.1.2/notes.ms ./notes.ms
*** ../cfs.1.1.2/notes.ms	Mon Aug 29 13:46:25 1994
--- ./notes.ms	Fri Nov 25 14:44:00 1994
***************
*** 1,5 ****
  .TL
! CFS Version 1.1
  Installation and Operation
  .AU
  Matt Blaze
--- 1,5 ----
  .TL
! CFS Version 1.2
  Installation and Operation
  .AU
  Matt Blaze
***************
*** 58,74 ****
  .IP
  Matt Blaze, "A Cryptographic File System for Unix."
  .I
! Proc. 1st ACM
! Conference on Computer and Communications Security,
  .R
  Fairfax, VA, November 1993.
  .PP
! This paper is available for anonymous ftp from research.att.com, in
! the file /dist/mab/cfs.ps.  You should read this paper before
! attempting to install and use CFS.  Details on the usage of each of
! the CFS commands (cattach, etc.) can be found in the man pages
! included in this distribution.  You can print them with troff -man,
! and should install them wherever local manpages go on your system.
  .PP
  Basically, CFS provides a mechanism to associate "real" directories
  (on other file systems) that contain encrypted data with temporary
--- 58,82 ----
  .IP
  Matt Blaze, "A Cryptographic File System for Unix."
  .I
! Proc. 1st ACM Conference on Computer and Communications Security,
  .R
  Fairfax, VA, November 1993.
  .PP
! Another paper describes a key management scheme for CFS that, while
! not included in this distribution, may be of interest.
! .IP
! Matt Blaze, "Key Management in an Encrypting File System."
! .I
! Proc. USENIX Summer 1994 Technical Conference,
! .R
! Boston, MA, June 1994.
! .PP
! These papers are available for anonymous ftp from research.att.com, in
! the file /dist/mab/cfs*.ps.  You should read them before attempting to
! install and use CFS.  Details on the usage of each of the CFS commands
! (cattach, etc.) can be found in the man pages included in this
! distribution.  You can print them with troff -man, and should install
! them wherever local man pages go on your system.
  .PP
  Basically, CFS provides a mechanism to associate "real" directories
  (on other file systems) that contain encrypted data with temporary
***************
*** 285,290 ****
--- 293,303 ----
  make sure all of the appropriate options are there.  If you get
  "permission denied" when you try to ls /crypt, you probably need
  -DANYPORT in CFLAGS.
+ .PP
+ A "timeout" feature is available to automatically detach directories,
+ either after being attached for longer than some period or after a
+ specified period of inactivity.  The absolute and inactivity timeouts
+ are specified with the "-t" and "-i" options to cattach, respectively.
  
  .NH
  Internals	
***************
*** 329,334 ****
--- 342,361 ----
  user-selected key passphrases represents a much greater practical
  threat than a direct attack against even single DES.
  .PP
+ A new experimental block cipher, called "MacGuffin" and designed by
+ Bruce Schneier and I, is also included in this release.  You can use
+ it by including the "-m" option to cmkdir.  This cipher is strictly
+ experimental, and I do not yet suggest its use for protecting
+ sensitive data.  It is included only to encourage analysis and
+ testing.  The cipher has a nominal keyspace of 128 bits, 32 rounds and
+ a standard 64 bit codebook interface.  It is described in:
+ .IP
+ Matt Blaze and Bruce Schneier, "The MacGuffin Block Cipher Algorithm."
+ .I
+ Proc. 2nd Workshop on Cryptographic Algorithms,
+ .R
+ Leuven, Belgium, December 1994.
+ .PP
  CFS semantics should be roughly the same as those of any other
  NFS-mounted file system, with a couple of minor differences.  Because
  of the encoding of pathnames as hex strings, path components are
***************
*** 408,411 ****
  (Mark.Stein@Eng.Sun.COM).  Several other users contributed bug
  reports, suggestions, and advice.  Thanks!
  .LP
! August 28, 1994
--- 435,438 ----
  (Mark.Stein@Eng.Sun.COM).  Several other users contributed bug
  reports, suggestions, and advice.  Thanks!
  .LP
! November 22, 1994
diff -c ../cfs.1.1.2/ver.c ./ver.c
*** ../cfs.1.1.2/ver.c	Sun Aug 28 15:49:11 1994
--- ./ver.c	Fri Dec  2 14:23:14 1994
***************
*** 1 ****
! static char version[]="CFS 1.1.2 - cryptlevel: DES=3, 3DES=1";
--- 1 ----
! static char version[]="CFS 1.2.0 - cryptlevel: DES=3, 3DES=1, MCG=1";

--===_0_Mon_Jul_24_14:25:25_BST_1995
Content-Type: message/rfc822
Content-Description: 1.2.0 -> 1.2.1 patch

Date: Mon, 24 Jul 95 09:14:28 EDT
Message-ID: <9507241314.AA21628@merckx.info.att.com>
To: chris@rivers.dra.hmg.gb
From: cfs-users-request@research.att.com
Subject: Majordomo file: list 'cfs-users' file 'cfs.1.2.1.patch'
Reply-To: cfs-users-request@research.att.com

--

#patches for CFS 1.2.1
# these patches upgrade from CFS 1.2.0
# 4/12/95
diff -c ../cfs.120/Makefile ./Makefile
*** ../cfs.120/Makefile	Fri Dec  2 14:28:10 1994
--- ./Makefile	Thu Apr 13 00:20:56 1995
***************
*** 58,64 ****
  COMPAT=
  
  ## use these for Linux (Slackware 1.1.2)
! #CFLAGS=-O -DREDO_ALRM
  #LIBS=
  #COMPAT=
  
--- 58,64 ----
  COMPAT=
  
  ## use these for Linux (Slackware 1.1.2)
! #CFLAGS=-O
  #LIBS=
  #COMPAT=
  
***************
*** 106,112 ****
  #COMPAT=-lcompat
  
  ## use these flags on Solaris 2.3
! #CFLAGS=-O -DSOLARIS2X -DPORTMAP -DREDO_ALRM
  #LIBS=-lsocket -lnsl
  #COMPAT=
  
--- 106,112 ----
  #COMPAT=-lcompat
  
  ## use these flags on Solaris 2.3
! #CFLAGS=-O -DSOLARIS2X -DPORTMAP
  #LIBS=-lsocket -lnsl
  #COMPAT=
  
***************
*** 117,123 ****
  # you shouldn't have to touch much below here
  
  SRCS=Makefile admproto.x mount.x nfsproto.x cfs.c cfs_adm.c cfs_nfs.c cfs.h cfs_fh.c cfs_des.c cfs_cipher.c mcg.c mcgsbox.c mcg.h cattach.c getpass.c cdetach.c cmkdir.c adm.c cname.c ccat.c ver.c i o ssh
! MANS=cattach.1 cdetach.1 cmkdir.1 ssh.1 cfsd.8 cname.8 ccat.8 README README.install README.history notes.ms
  OBJS= cfs.o nfsproto_xdr.o nfsproto_svr.o admproto_xdr.o admproto_svr.o cfs_adm.o cfs_nfs.o cfs_fh.o cfs_des.o cfs_cipher.o adm.o ver.o mcgsbox.o mcg.o
  COBJS=admproto_clnt.o cfs_des.o cfs_cipher.o cattach.o getpass.o cmkdir.o cdetach.o ver.o cname.o ccat.o mcgsbox.o mcgsbox.o mcg.o 
  OTHERS = nfsproto.h nfsproto_svr.c nfsproto_xdr.c admproto.h admproto_svr.c admproto_xdr.c admproto_clnt.c
--- 117,123 ----
  # you shouldn't have to touch much below here
  
  SRCS=Makefile admproto.x mount.x nfsproto.x cfs.c cfs_adm.c cfs_nfs.c cfs.h cfs_fh.c cfs_des.c cfs_cipher.c mcg.c mcgsbox.c mcg.h cattach.c getpass.c cdetach.c cmkdir.c adm.c cname.c ccat.c ver.c i o ssh
! MANS=cattach.1 cdetach.1 cmkdir.1 ssh.1 cfsd.8 cname.8 ccat.8 README README.install README.history notes.ms README.linux
  OBJS= cfs.o nfsproto_xdr.o nfsproto_svr.o admproto_xdr.o admproto_svr.o cfs_adm.o cfs_nfs.o cfs_fh.o cfs_des.o cfs_cipher.o adm.o ver.o mcgsbox.o mcg.o
  COBJS=admproto_clnt.o cfs_des.o cfs_cipher.o cattach.o getpass.o cmkdir.o cdetach.o ver.o cname.o ccat.o mcgsbox.o mcgsbox.o mcg.o 
  OTHERS = nfsproto.h nfsproto_svr.c nfsproto_xdr.c admproto.h admproto_svr.c admproto_xdr.c admproto_clnt.c
diff -c ../cfs.120/README ./README
*** ../cfs.120/README	Sun Nov 27 14:24:21 1994
--- ./README	Thu Apr 13 00:20:56 1995
***************
*** 1,4 ****
! This is version 1.2.0 of CFS, the Cryptographic File System.
  
  There is a mailing list, cfs-users, for discussion of topics of
  interest to CFS users and developers.  To subscribe:
--- 1,4 ----
! This is version 1.2.1 of CFS, the Cryptographic File System.
  
  There is a mailing list, cfs-users, for discussion of topics of
  interest to CFS users and developers.  To subscribe:
diff -c ../cfs.120/README.history ./README.history
*** ../cfs.120/README.history	Fri Dec  2 14:20:33 1994
--- ./README.history	Thu Apr 13 00:20:57 1995
***************
*** 1,5 ****
--- 1,8 ----
  CFS revision history:
  
+ 1.2.1 - Fixes 3DES to make key caching work properly.  Fixed a few
+ things to make porting easier.  Compatible with 1.2.0.
+ 
  1.2.0 - Fixes various minor bugs.  Adds MacGuffin cipher.  Adds
  timeout (-it) options to cattach.  DES ciphers compatible with 1.1.2.
  
diff -c ../cfs.120/README.install ./README.install
*** ../cfs.120/README.install	Fri Dec  2 14:20:39 1994
--- ./README.install	Thu Apr 13 00:28:10 1995
***************
*** 1,4 ****
! This is version 1.2.0 of CFS
  
   * The author of this software is Matt Blaze.
   *              Copyright (c) 1992, 1993, 1994 by AT&T.
--- 1,4 ----
! This is version 1.2.1 of CFS
  
   * The author of this software is Matt Blaze.
   *              Copyright (c) 1992, 1993, 1994 by AT&T.
***************
*** 59,64 ****
--- 59,72 ----
  	/usr/local/etc/cfsd && \
  		/etc/mount -o port=3049,intr localhost:/null /crypt
  fi
+ 
+ 7a) on some platforms (especially BSDI), you may get better CFS
+ performance with a smaller mount blocksize:
+ if [ -x /usr/local/etc/cfsd ]; then
+    /usr/local/etc/cfsd && \
+       /etc/mount -o port=3049,intr,rsize=2048,wsize=2048 localhost:/null /crypt
+ fi
+ 
  
  8) run the commands in step 7 by hand to get it started now.  you may have to
  do an "exportfs -a" and/or /etc/rpc.mountd first if you aren't already running
diff -c ../cfs.120/README.linux ./README.linux
*** ../cfs.120/README.linux	Thu Apr 13 00:29:15 1995
--- ./README.linux	Thu Apr 13 00:20:57 1995
***************
*** 0 ****
--- 1,58 ----
+ From owner-cfs-users  Wed Mar  8 18:22:15 1995
+ Received: by merckx.info.att.com (4.1/4.7)
+         id AA15369; Wed, 8 Mar 95 18:22:15 EST
+ Posted-Date: Wed, 08 Mar 1995 15:17:01 -0800
+ Message-Id: <199503082317.PAA02390@gwarn.versant.com>
+ To: root <root@esprit.topaz.com>
+ From: strick@techwood.org
+ Reply-To: strick@techwood.org
+ Cc: cfs-users@research.att.com
+ Subject: Re: linux problems 
+ In-Reply-To: Your message of "Wed, 08 Mar 1995 02:51:09 EST."
+              <199503080751.CAA23174@esprit.topaz.com> 
+ Date: Wed, 08 Mar 1995 15:17:01 -0800
+ 
+ THUS SPAKE owner-cfs-users@research.att.com:
+ #       I'm still having problems getting CFS to compile under the newest
+ # version of slackware.  I was told that it worked on previous versions of
+ 
+ What I had to do in slackware 2.1.0 (Linux 1.1.59) is delete the _svc suffices 
+ on the global names in the .c files that are generated from the .x files.
+ (I'm not enough of a SUNRPC GOD to know why.)
+ 
+ Then it would link okay.  (Was linking your problem?)
+ 
+ Oh, and you need -Dd_fileno=d_ino  ... see below
+ 
+                                         strick
+ 
+ p.s.   ESM is fantastic, too.
+ 
+ 
+ 
+         make CC="cc -traditional -Dd_fileno=d_ino  \
+         -Dnfsproc_null_2_svc=nfsproc_null_2     \
+         -Dnfsproc_getattr_2_svc=nfsproc_getattr_2       \
+         -Dnfsproc_setattr_2_svc=nfsproc_setattr_2       \
+         -Dnfsproc_root_2_svc=nfsproc_root_2     \
+         -Dnfsproc_lookup_2_svc=nfsproc_lookup_2 \
+         -Dnfsproc_readlink_2_svc=nfsproc_readlink_2     \
+         -Dnfsproc_read_2_svc=nfsproc_read_2     \
+         -Dnfsproc_writecache_2_svc=nfsproc_writecache_2 \
+         -Dnfsproc_write_2_svc=nfsproc_write_2   \
+         -Dnfsproc_create_2_svc=nfsproc_create_2 \
+         -Dnfsproc_remove_2_svc=nfsproc_remove_2 \
+         -Dnfsproc_rename_2_svc=nfsproc_rename_2 \
+         -Dnfsproc_link_2_svc=nfsproc_link_2     \
+         -Dnfsproc_symlink_2_svc=nfsproc_symlink_2       \
+         -Dnfsproc_mkdir_2_svc=nfsproc_mkdir_2   \
+         -Dnfsproc_rmdir_2_svc=nfsproc_rmdir_2   \
+         -Dnfsproc_readdir_2_svc=nfsproc_readdir_2       \
+         -Dnfsproc_statfs_2_svc=nfsproc_statfs_2 \
+         -Dadmproc_null_1_svc=admproc_null_1     \
+         -Dadmproc_attach_1_svc=admproc_attach_1 \
+         -Dadmproc_detach_1_svc=admproc_detach_1 \
+         -Dadmproc_ls_1_svc=admproc_ls_1 \
+                 "
+ 
+ 
diff -c ../cfs.120/cfs.c ./cfs.c
*** ../cfs.120/cfs.c	Sun Nov 27 03:12:10 1994
--- ./cfs.c	Thu Apr 13 00:20:58 1995
***************
*** 275,294 ****
  #endif
  	for (i=0; i<NINSTANCES; i++)
  		if (instances[i] != NULL) {
! 			if ((instances[i]->timeout)
  			    && (instances[i]->timeout < cursecs))
! 					instances[i]->dead=1;
! 			if ((instances[i]->idle)
  			    && ((instances[i]->access + instances[i]->idle)
  				< cursecs))
! 					instances[i]->dead=1;
! #ifdef DEBUG
! 			if (instances[i]->dead)
! 				fprintf(stderr,"killed %d\n",i);
! #endif
  		}
- #ifdef REDO_ALRM
  	signal(SIGALRM,grimreap);
- #endif
  	alarm(60);
  }
--- 275,290 ----
  #endif
  	for (i=0; i<NINSTANCES; i++)
  		if (instances[i] != NULL) {
! 			if (instances[i]->dead > 4)
! 				freeinstance(i);
! 			else if ((instances[i]->timeout)
  			    && (instances[i]->timeout < cursecs))
! 					instances[i]->dead++;
! 			else if ((instances[i]->idle)
  			    && ((instances[i]->access + instances[i]->idle)
  				< cursecs))
! 					instances[i]->dead++;
  		}
  	signal(SIGALRM,grimreap);
  	alarm(60);
  }
diff -c ../cfs.120/cfs_des.c ./cfs_des.c
*** ../cfs.120/cfs_des.c	Fri Jul 15 10:55:27 1994
--- ./cfs_des.c	Thu Apr 13 00:20:58 1995
***************
*** 152,158 ****
  	/* now caches 4 session keys.  drops least recently added  */
  	k= -1;
  	for (j=0; j<4; j++) {
! 		if (bcmp(short_key,lastkey,8)==0) {
  			k=j;
  			break;
  		}
--- 152,158 ----
  	/* now caches 4 session keys.  drops least recently added  */
  	k= -1;
  	for (j=0; j<4; j++) {
! 		if (bcmp(short_key,lastkey[j],8)==0) {
  			k=j;
  			break;
  		}
diff -c ../cfs.120/notes.ms ./notes.ms
*** ../cfs.120/notes.ms	Fri Nov 25 14:44:00 1994
--- ./notes.ms	Thu Apr 13 00:20:59 1995
***************
*** 276,283 ****
  time after mountd is started up.  I use:
  .DS
  if [ -x /usr/local/etc/cfsd ]; then
!         /usr/local/etc/cfsd && \\
!                 /etc/mount -o port=3049,intr localhost:/null /crypt
  fi
  .DE
  Note that if you are using a system that does not allow ports other
--- 276,283 ----
  time after mountd is started up.  I use:
  .DS
  if [ -x /usr/local/etc/cfsd ]; then
!    /usr/local/etc/cfsd && \\
!       /etc/mount -o port=3049,intr localhost:/null /crypt
  fi
  .DE
  Note that if you are using a system that does not allow ports other
***************
*** 289,294 ****
--- 289,304 ----
  mountd and nfsd if it's there; you'll have to edit out any lines that
  try to start up nfsd on such systems.
  .PP
+ On some platforms (especially BSDI), you may find that CFS performance
+ improves dramatically if you set the NFS mount block size to a smaller
+ value than the default.  2048 is usually about right:
+ .DS
+ if [ -x /usr/local/etc/cfsd ]; then
+    /usr/local/etc/cfsd && \\
+       /etc/mount -o port=3049,intr,rsize=2048,wsize=2048 localhost:/null /crypt
+ fi
+ .DE
+ .PP
  If any of this fails, recheck the configuration in the Makefile and
  make sure all of the appropriate options are there.  If you get
  "permission denied" when you try to ls /crypt, you probably need
***************
*** 435,438 ****
  (Mark.Stein@Eng.Sun.COM).  Several other users contributed bug
  reports, suggestions, and advice.  Thanks!
  .LP
! November 22, 1994
--- 445,448 ----
  (Mark.Stein@Eng.Sun.COM).  Several other users contributed bug
  reports, suggestions, and advice.  Thanks!
  .LP
! April 9, 1995
diff -c ../cfs.120/ver.c ./ver.c
*** ../cfs.120/ver.c	Fri Dec  2 14:23:14 1994
--- ./ver.c	Thu Apr 13 00:20:59 1995
***************
*** 1 ****
! static char version[]="CFS 1.2.0 - cryptlevel: DES=3, 3DES=1, MCG=1";
--- 1 ----
! static char version[]="CFS 1.2.1 - cryptlevel: DES=3, 3DES=1, MCG=1";




