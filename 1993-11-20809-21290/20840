Newsgroups: sci.crypt
Path: msuinfo!uwm.edu!math.ohio-state.edu!cs.utexas.edu!swrinde!gatech!europa.eng.gtefsd.com!news.ans.net!newsgate.watson.ibm.com!hawnews.watson.ibm.com!yktnews.watson.ibm.com!c1smolin
From: c1smolin@watson.ibm.com (John Smolin)
Subject: Re: Computer Shopper Challenge 
Sender: news@yktnews.watson.ibm.com (NNTP News Poster)
Message-ID: <CFvE23.J95@yktnews.watson.ibm.com>
Date: Tue, 2 Nov 1993 15:08:26 GMT
References: <5828@wet.UUCP> <752202485snx@NetAcsys.com>
Nntp-Posting-Host: yktclust.watson.ibm.com
Organization: IBM T.J. Watson Research Center
Lines: 70





In article <752202485snx@NetAcsys.com>, mycal@NetAcsys.com (Mycal) writes:
|> 
|> In article <5828@wet.UUCP> naga@wet.COM writes:
|>   > In <1993Oct30.033130.1576@integrity.uucp>
|>   > edr@mpd.tandem.com (Ed Rupp) writes:
|>   >  
|>   > Conclusion:  SECRT1 and SECRT2 were not produced by the encryption
|>   > algorithm given in CIPHER.C.
|>   >  
|> yes, not even close.  They may use the same RNG but thats about it.
|> 
|> It is strange that the cyphertext has a close to asc distribution while
|> it has a weight of 125 (secrt2) or 126(secrt1) which is very close to a pure
|> RNG weight of 128, but a little on the low side.  So it would seem to me
|> that given the asc like distribution that they are not encripting all
|> the plaintext, just most of it.  If you were not to encrypt about 1/10th
|> of the plaintext it might account for this distribution and weight.  There
|> could be some rule like if the random number is between 90 and 115 then
|> don't do the xor.  i don't know I'm just speculating.
|> 
|> cypher.c produces cyphertext consistantly that has a weight of 127
|> or 128.
|> 
|> weight is the total value of all the characters divided by the number of
|> characters.
|> 
|> mycal


I think something like this could be what is going on.   This uses the
top 4 bits of the current number from the sequence to decide which 8
bits to use as the XOR mask for the encryption.   I have designed it so
that when the top 4 bits are 0, 1/16 of the time, it will output a 0,
therefore leaving the input alone and producing a frequency table similar
to the one of secret1, secret2 when given ascii text (though it doesn't
get all the 0xd0's and such??).  I haven't chekced the weight function,
but it should be about right.


  int GetRandomNumber( int Range )
  {
  RandomSeed = MULTIPLIER * RandomSeed + INCREMENT;
  return( ((RandomSeed >> (28-((RandomSeed & 0xf0000000)>>28) )  ) & 0xff));
  }

The bug, BTW, is that the first 28 really should be a 24.  That's the kind
of mistake one might expect, but there are other similar schemes that could
work.  The other problem is I assume a 32 bit key space and all 32 bits of
the multiplier and increment matter I think.  So if he isn't using the
same ones as in cipher.c we have a problem.  I am running a check for
7 bit ascii over the full keyspace now, but I doubt it will turn up
anything because of the 0xd0's and so on.  I have to change my code
to try to predict the spaces since by my guessword 2/3 of them are
the same as they would be in the plaintext.  This will slow down my
search a bit though, and I don't really have the time to play with the
program right now.  If anyone figures anything out, please post or
email me at

smolin@vesta.physics.ucla.edu

not at whatever the header says.  I don't seem to receive any mail at
the IBM address yet for some reason.....

John
 

