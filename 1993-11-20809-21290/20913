Path: msuinfo!uwm.edu!math.ohio-state.edu!sol.ctr.columbia.edu!news.kei.com!bloom-beacon.mit.edu!senator-bedfellow.mit.edu!athena.mit.edu!fuellen
From: fuellen@athena.mit.edu (Georg Fuellen)
Newsgroups: comp.ai.genetic,sci.crypt
Subject: Re: Strong random number generators?
Date: 6 Nov 1993 22:12:33 GMT
Organization: Massachusetts Institute of Technology
Lines: 106
Distribution: world
Message-ID: <2bh7gh$qfs@senator-bedfellow.MIT.EDU>
References: <1993Nov5.183248.29604@cs.tcd.ie>
NNTP-Posting-Host: milanese.mit.edu
Xref: msuinfo comp.ai.genetic:1662 sci.crypt:20913

In article <1993Nov5.183248.29604@cs.tcd.ie>, rwallace@cs.tcd.ie 
(Russell Wallace) writes:
|> Could someone explain just what test a 'cryptographically strong' random
|> number generator (e.g. Blum-Blum-Shub) passes, that an LCG fails? 

A 'cryptographically strong' random number generator passes ANY polynomial time
statistical test asymptotically. (I call such a generator "unpredictable",
but that's just an equivalent concept)

Even the Genetic Algorithm some of you are running right now 
can be viewed as such a test for the random number generator !!!

That's because a statistical test is formally just a family of functions,
mapping a bitstring input to a test result, i.e.

         poly(k)             t
C : {0,1}         -->  {0.1}      (with fixed t, take  t=1  w.l.o.g.)
 k

and "passing all polynomial time tests" means that

  any polynomial time algorithm which can be viewed as computing such a function
  WILL  NOT  EXHIBIT DIFFERENT BEHAVIOUR IF IT IS GIVEN A TRULY RANDOM STRING
  INSTEAD OF A STRONG RANDOM NUMBER GENERATOR'S OUTPUT, at least asymptotically.

(I'll formalize this below.)

|> To be
|> sure, in principle the LCG is not random, but then neither is any
|> algorithm for generating random numbers; 

Of course, the algorithms are all deterministic. That's why you need all this 
"asymptotic" crap.

It's the same thing with "polynomial time".
This can also be defined in an asymptotic way only. (Remember that O(k) 
notation ?) You cannot say in a clean way that an algorithm using 20 
microseconds on your PC is "fast", just as it is difficult to say that
1010010001 is more random than 1111111111. What you need is the  asymptotic 
scaling behaviour of your algorithm. (Ok, ok, the fastest way to multiply uses
Fourier Transforms and its good scaling behaviour doesnt really pay off in 
current applications ;-) 

Vaillant's "PAC"-learning is just another example how useful (though  sometimes
doubtful) this framework is. 


In our case  good  asymptotic scaling behaviour means that G (x), 
                                                            k
a bitstring taken according to the probability distribution of the generator's 
output bitstrings, which you get by feeding it with uniformly distributed seeds,
*is indistinguishable* from a random string x' (again uniformly distributed)
for all polynomial time tests C  and for all but a finite number of k :
                               k

|                                    |      1 
| Pr(C (G (x)) = 1) - Pr(C (x') = 1) | < -------
|     k  k                k          |   poly(k)


where the generator itself is a family of functions

         k            poly(k)
G : {0,1}  -->  {0.1}      
 k

and poly(k) indicates values polynomial in k.

                                                  k
This is a strong property because there are only 2  different G (x),
                                                               k
     poly(k)                                 45                
but 2       different x' and poly(k) may be k   !


In most cases this "passing all polynomial time tests" is proven 
starting with a "plausible" assumption, e.g. "Large Numbers are hard to factor",
or "The RSA crypto function cannot be broken". I know one generator which
does not even rely on such an assumption [ZMI89], but it is only 
"locally strong".

|> and LCG passes every test I've
|> ever heard about.

LCG's are not random asymptotically, see, among others, [Stern87].

A general reference is [Kranakis85], but I'm still looking for something
better. 

[Kranakis85] E. Kranakis, Primality and Cryptography, 1985.
[Stern87]  J. Stern, Secret Linear Congruential Generators are
   not Cryptographically secure. Proc. of IEEE STOC, 1987, pp. 421-426
[ZMI89]    Y. Zheng, T. Matsumoto, H. Imai, On the Construction of Block Ciphers
   Provably Secure and Not Relying on Any Unproved Hypothesis,
   Proc. of CRYPTO 89, Springer Verlag, pp.461-480.


Corrections welcome, as always.
I'll probably post some more stuff in a month.

  regards,

georg
fuellen@mit.edu
The convex hull of all disclaimers made on usenet last year applies to this mess

