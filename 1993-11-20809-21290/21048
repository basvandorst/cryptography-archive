Path: msuinfo!uwm.edu!math.ohio-state.edu!sdd.hp.com!hplabs!unix.sri.com!csl.sri.com!boucher
From: boucher@csl.sri.com (Peter K. Boucher)
Newsgroups: comp.ai.genetic,sci.crypt
Subject: Re: Strong random number generators?
Date: 12 Nov 1993 02:13:57 GMT
Organization: Computer Science Lab, SRI International
Lines: 205
Distribution: world
Message-ID: <2burh5INN9pj@roche.csl.sri.com>
References: <1993Nov5.183248.29604@cs.tcd.ie> <2bfl7tINN3ne@redwood.csl.sri.com> <16C83F0BF.RAHNJ@vm1.ulaval.ca>
NNTP-Posting-Host: redwood.csl.sri.com
Xref: msuinfo comp.ai.genetic:1723 sci.crypt:21048

If this shows up thrice (shouldn't -- I cancelled the other TWO),
sorry, ignore the other TWO -- grrr.

RAHNJ@vm1.ulaval.ca (Joel Rahn) writes:
|> OK, I didn't compile the code and I only scanned it rapidly so maybe this
|> is right out-to-lunch, but doesn't the above text describe a test of
|> simple uniformity and a 'runs up' (or 'runs down') test with run-length
|> equal to two? An LCG that is even worth considering passes these two
|> tests easily, no?

New, and improved anal.c, uses chi-square.

Does the 'runs up' (or 'runs down') test with run-length equal to two
get me anything over the standard chi-square test?  I left it in.

BTW, the  buf[i] = (((seed = (1103515245*seed +12345)) >> 16) & 0xff);
test fails this test.  It's too evenly distributed.

-Peter

/* ***************************************************************
 * anal.c --
 *
 * Copyright 1993 Peter K. Boucher
 * Permission to use, copy, modify, and distribute this
 * software and its documentation for any purpose and without
 * fee is hereby granted, provided that the above copyright
 * notice appear in all copies.
 *
 * Usage:  anal [input_file [output_file]]
 *
 * This program counts the occurances of each character in a file
 * and notifies the user when a the distribution is too ragged or
 * too even.
 *
 * Because the chance of getting byte B after byte A should be 1:256
 * (for all A's and B's), the program also checks that the successors
 * to each byte are randomly distributed.  This means that for each byte
 * value (0 - 255) that occurs in the text, a count is kept of the
 * byte value that followed in the text, and the frequency distribution
 * of these succeeding bytes is also checked.
 *
 */

#include <stdio.h>

#define BYTESIZE 256
#define BUFSIZE 8192
#ifdef DEBUG
#define PASSED_OFNAME "/tmp/analocc.pss"
#define PASSED_SFNAME "/tmp/analsuc.pss"
#define FAILED_OFNAME "/tmp/analocc.fld"
#define FAILED_SFNAME "/tmp/analsuc.fld"
#endif

#define	V01	(205.33) /*  1% chance it's less */
#define V25	(239.39) /* 25% chance it's less */
#define V75	(269.88) /* 75% chance it's less */
#define V99	(310.57) /* 99% chance it's less */

#define min_nps 5

#define SHOW_RESULT(F,s) \
     fprintf(F, "n = %10ld, V = %.2lf\n", \
		     s,         V);

unsigned long cnt[BYTESIZE] = {0}; /* should be all zeros. */
unsigned long succeed[BYTESIZE][BYTESIZE] = {{0}}; /* should be all zeros. */

static unsigned char buf[BUFSIZE];
static FILE *ifp, *ofp;

FILE *
my_fopen(file, type)
char *file, *type;
{
  FILE *fp;

  if ((fp = fopen(file, type)) == NULL) {
      (void)fprintf(stderr, "Can't open '%s' for '%s'\n", file, type);
      exit(1);
  }
  return(fp);
}

double
get_V(N,Y)
unsigned long N;
unsigned long *Y;
{
#define k (BYTESIZE)
#define p (1.0/k)
    double sum = 0.0;
    double n = N;
    int i;

    for (i=0; i<k; i++) {
	sum += ((Y[i]*Y[i])/p)/n;
    }
    return( sum - n );
}

unsigned long
fill_arrays()
{
   unsigned long size=0L;
   int ch,next,l,i;

   if ((ch = getc(ifp)) != EOF) { /* prime the pump */
       cnt[ch] = size = 1L;
       while ((l = fread(buf, 1, BUFSIZE, ifp)) > 0) {
	   for (i=0; i<l; i++) {
	       size++;
	       next = buf[i];
	       cnt[next]++;
	       succeed[ch][next]++;
	       ch = next;
	   }
       }
   }
   fclose(ifp);
   return( size );
}

void
anal_ize_text()
{
   int   	  i;
   int   	  suc_good=0;
   double         V;
   unsigned long  size;
#ifdef DEBUG
   FILE *oexcell=my_fopen(PASSED_OFNAME, "a");
   FILE *sexcell=my_fopen(PASSED_SFNAME, "a");
   FILE *ofailed=my_fopen(FAILED_OFNAME, "a");
   FILE *sfailed=my_fopen(FAILED_SFNAME, "a");
#endif

   if ((size = fill_arrays()) < (BYTESIZE*min_nps)) {
       fprintf(stderr, "File too small (%ld) to meaningfully analyze\n",
	       size);
       exit(0);
   }

   V = get_V(size,cnt);
   SHOW_RESULT(ofp, size);
   if ((V < V01) || (V > V99)) {
#ifdef DEBUG
       SHOW_RESULT(ofailed, size);
#endif
       fprintf(stderr, "Character occurances non-random\n");
   } else if ((V > V25) && (V < V75)) {
#ifdef DEBUG
       SHOW_RESULT(oexcell, size);
#endif
       fprintf(ofp,
"================ Occurances randomness excellent! =====================\n");
   }

   if (size >= (BYTESIZE*BYTESIZE*min_nps)) {
       for (i=0; i<BYTESIZE; i++) {
	   V = get_V(cnt[i],succeed[i]);
	   if ((V < V01) || (V > V99)) {
#ifdef DEBUG
	       SHOW_RESULT(sfailed, cnt[i]);
#endif
	       suc_good -= 25;  /* (weighted) 2% chance of this happening */
	   } else if ((V > V25) && (V < V75)) {
#ifdef DEBUG
	       SHOW_RESULT(sexcell, cnt[i]);
#endif
	       suc_good++;     /* (weighted) 50% chance of this happening */
	   }
       }
       if (suc_good > 75) {
	   fprintf(ofp,
"================= Successor randomness excellent! (%.3d) ===============\n",
		   suc_good);
       } else if (suc_good < -75) {
	   fprintf(ofp, "Character successions non-random (%d)\n", suc_good);
       } else {
	   fprintf(ofp, "Successor randomness acceptible\n");
       }
   }

#ifdef DEBUG
   fclose(oexcell);
   fclose(sexcell);
   fclose(ofailed);
   fclose(sfailed);
#endif
}  

int
main (int argc, char* argv[])
{
   ifp = (argc > 1) ? my_fopen(argv[1],"r") : stdin;
   ofp = (argc > 2) ? my_fopen(argv[2],"w") : stdout;
   anal_ize_text();

   return(0);
}



