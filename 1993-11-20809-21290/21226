Path: msuinfo!agate!usenet.ins.cwru.edu!eff!linus!linus.mitre.org!linus!mbunix!eachus
From: eachus@spectre.mitre.org (Robert I. Eachus)
Newsgroups: sci.crypt
Subject: Re: Strong random number generators?
Date: 17 Nov 93 15:17:07
Organization: The Mitre Corp., Bedford, MA.
Lines: 50
Message-ID: <EACHUS.93Nov17151707@spectre.mitre.org>
References: <EACHUS.93Nov8102336@spectre.mitre.org> <1993Nov11.142332.8223@vedge.com>
	<EACHUS.93Nov15195553@spectre.mitre.org>
	<2cckh1$em3@agate.berkeley.edu>
NNTP-Posting-Host: spectre.mitre.org
In-reply-to: shirriff@sprite.berkeley.edu's message of 17 Nov 1993 07:40:17 GMT

In article <2cckh1$em3@agate.berkeley.edu> shirriff@sprite.berkeley.edu (Ken Shirriff) writes:

   I said:

   >>Incidently, the prime factors of N! are relatively easy to find...

   > Cool.  Can you factor (2^1024+1)! for me?

   Sure, do you have enough space to store the result? It starts out
2*2*2*2*2*2*2*2*2*2... Or did you only want the unique prime factors:
2,3,5,7,11,13,17,19,23... (Remember that the "rules of the game"
either allow me time proportional to the number of bits in
(2^1024+1)!, or the number of bits in the answer.  But I can also use
a compact notation for the answer: For any N, N factorial is divisible
by all primes less than or equal to N, and is not divisible by any
prime larger than N.  How's that?  Or... once upon a time I wrote an
APL program 16 characters long which would print out all primes less
than or equal to N.  Combining that with N (1+2*1024 in this case)
gives me a 24 character program that should keep your printer running
for a long time. The funny thing is that my algorithm depends on
Wilson's theorem: A number N is prime iff N! is congruent to -1 mod
N-1.  So my algorithm will require space exactly propotional to your
challenge number. Or you might prefer Iverson's 18 character program
program for finding primes, or possibly one that is more conservative
of space.  ;-)

   Somewhat more seriously, the hard part of factoring large composite
numbers is finding divisors.  In this case it is easy to come up with
an algorithm in which more than half the attempted divisions have no
remainder.  Technically, we can come up with an algorithm that takes
time proportional to the length of the answer times the length of the
problem (the number of bits in (2^1024+1)! in this case.)  Sounds
polynomial to me. (Actually some effort is also required to find all
the primes less than 2*1024+1, but that will be dominated by cranking
out the factors.)

  Or, if you prefer, you can do it all in your head or a symbolic math
package.  Two divides our huge number 2^1023+2^1022+2^1021... = 2^1024
- 1 times.  We can ignore the 2^1024 + 1 term since it is not
divisible by two.  Three divides it |_ 2^1024/3 _| + |_ 2^1024/9 _| +
|_ 2^1024/27 _| ... times. We can ignore the 2^1024 + 1 term since it
is not divisible by three, etc. ;-)

--

					Robert I. Eachus

with Standard_Disclaimer;
use  Standard_Disclaimer;
function Message (Text: in Clever_Ideas) return Better_Ideas is...
