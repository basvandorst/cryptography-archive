Path: msuinfo!agate!linus!linus.mitre.org!linus!mbunix!eachus
From: eachus@spectre.mitre.org (Robert I. Eachus)
Newsgroups: comp.ai.genetic,sci.crypt
Subject: Re: Strong random number generators?
Date: 8 Nov 93 10:23:36
Organization: The Mitre Corp., Bedford, MA.
Lines: 50
Distribution: world
Message-ID: <EACHUS.93Nov8102336@spectre.mitre.org>
References: <1993Nov5.183248.29604@cs.tcd.ie> <1993Nov8.010817.1@mcclb0>
NNTP-Posting-Host: spectre.mitre.org
In-reply-to: huff@mcclb0.med.nyu.edu's message of 8 Nov 93 01:08:17 EST
Xref: msuinfo comp.ai.genetic:1670 sci.crypt:20944

In article <1993Nov8.010817.1@mcclb0> huff@mcclb0.med.nyu.edu (Edward J. Huff) writes:

  > Ok, I'll take a guess.

  Please don't guess.  There is already too much misinformation on the net.

  > Assume for the sake of argument that the multiplier is not secret
  > (after all, you can't change it easily if the key is compromised).
  > Then one problem with using xor against the LCG (especially if no
  > decimation is done) is that a known plaintext attack may reveal
  > the key with less work than trying all possible keys.

  For an LCG, or a 1/P generator, assume the multiplier is secret.  It
still takes only a few values to calculate the multiplier, modulus and
seed for the generator.  See the literature.

  > This clearly has nothing to do with randomness, it has to do with
  > resistance to known plaintext.

  A probable word attack can be considered "known-plaintext", but
usually that phrase is restricted to knowing all, or the leading
portion of a message.

   > Just off the top of my head, but even if this isn't quite exactly
   > right, the weakness is something like this.  If the _entire_
   > random number were used in the XOR, then the complete internal
   > state of the LCG (which is after all only 32 or 64 bits) could be
   > determined from just a few bytes of known plaintext.  Then the
   > cypher is broken.

   Again go read the literature to see how much of the sequence is
needed to recover the generator, even if only a few bits are used from
each iteration.  Now for BBS, say I give you the modulus N, and the
number of bits used from each iteration*, and just for grins the first
few words of the plaintext.  If you can recover the message, you have
enough information to find the prime factors of N!  So if factoring is
hard, the BBS generator is cryptographically secure.  Similarly, any
test which shows that the ouput of the generator is not random can be
used to factor N.

    * This number is usually less than log2(log2(modulus)) for BBS.
For example using 8 bits from a 512-bit modulus.

--

					Robert I. Eachus

with Standard_Disclaimer;
use  Standard_Disclaimer;
function Message (Text: in Clever_Ideas) return Better_Ideas is...
