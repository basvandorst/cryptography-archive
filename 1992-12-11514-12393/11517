Newsgroups: sci.crypt
Path: msuinfo!caen!sol.ctr.columbia.edu!ira.uka.de!math.fu-berlin.de!news.th-darmstadt.de!minnie!usenet
From: pom@anke.imsd.uni-mainz.DE (Prof. Dr. Klaus Pommerening)
Subject: Re: URNG
Message-ID: <9WD91AR@minnie.zdv.uni-mainz.de>
Sender: usenet@minnie.zdv.uni-mainz.de (USENET News System)
Nntp-Posting-Host: anke.imsd.uni-mainz.de
Organization: Johannes Gutenberg Universitaet Mainz
References: <1992Nov24.215013.610@cactus.org>
Date: Mon, 30 Nov 1992 14:30:54 GMT
Lines: 58

In article <1992Nov24.215013.610@cactus.org> ritter@cactus.org (Terry Ritter) 
made some critical remarks on the Blum/Blum/Shub generator in the form that I  
posted here (Blum, Blum and Shub: please forgive me!). In fact there are some  
unclear points, and I'd like to see some further discussion. Here a few  
remarks:

1.) The unpredictability of the BBS generator relies on the unproven Quadratic  
Residuosity Assumption. If QRA is true then factoring is hard - the converse is  
not known.

2.) The BBS generator (like similar algorithms, e.g. RSA encryption) has a  
theoretical and a practical aspect. From the theoretical point of view the  
algorithm depends on the bitsize n of the modulus m. Unpredictability means  
that there is no algorithm, polynomial in n, that predicts the generator's  
output bits, as long as
 - you output only O(log n) bits per internally generated sequence member x_i  
(this is the result of Vazirani/Vazirani and Alexi/Chor/Goldreich/Schnorr) [by  
the way, Terry, V & V use N for the modulus and n for its bitsize],
 - you output no more than `poly(n)' bits for a chosen modulus and seed (I  
think this is also proven in Kranakis' book).
I don't think (but have not time to check this now) that you need to use  
`special' primes for this result. And there is no need to throw away the  
modulus before you have used poly(n) bits.

3.) On the practical side, since we don't know anything additional on QRA, we  
have to choose the modulus m such that m is (practically) hard to factor. This  
means:
 - choose m large enough,
 - choose m in such a way that known fast factoring algorithms for numbers of  
special types don't apply.
Whence the practical requirements: Choose p and q such that p-1 and q-1 have a  
large factor, p and q are at least 2^{256}, and p-q is not small. No doubt  
there are further requirements along this line. But there is also an empirical  
rule/evidence/hope that when you choose p and q at random, your m = pq will be  
good. All this is not exact mathematics, of course.

3a.) A reference on how to choose primes (from the practical side) is the FAQ  
on cryptography that is available by anonymous FTP from rsa.com.

3b.) How many bits are the O(log n) output bits per number and the poly(n)  
output bits per modulus and seed? Here we need similar empirical standards; I  
don't know of any. How secure are log n bits per number and n^4 bits per  
modulus? This would give 9*2^{36} secure bits for n = 512.

4.) Now there is the problem of choosing a suitable seed x_0. But since our  
modulus is astronomically large, the period of the x_i-sequence is also  
astronomically large, for `almost all' x_0 [the expected value of the period  
should grow as O(sqrt(m)) - as a first guess]. Does this not follow from the  
unpredictability result as proven in Kranakis' book? If you have a short cycle,  
you can predict, and if you can predict for a significant number of seeds, then  
QRA is false. (In particular if gcd(x_0,m) > 1 you even have factored m by  
chance.) If this reasoning turns out to be correct there is no need of taking  
special care in choosing the seed (and no need of `special' primes).
--
Prof. Dr. Klaus Pommerening
Institut fuer Medizinische Statistik und Dokumentation
der Johannes-Gutenberg-Universitaet
Obere Zahlbacher Strasse 69, W-6500 Mainz, Germany
