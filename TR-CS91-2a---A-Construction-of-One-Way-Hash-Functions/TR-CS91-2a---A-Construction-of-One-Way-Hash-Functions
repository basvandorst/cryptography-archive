
                          A Construction for
                      One Way Hash Functions
                                 and
                    Pseudorandom Bit Generators
                         (Extended Abstract)



                Babak Sadeghiyan and Josef Pieprzyk


                  Department of Computer Science,
                          University College,
                   University of New South Wales,
                 Australian Defence Force Academy,
                       Canberra, A.C.T. 2600,
                              Australia.


                            June 21, 1992
                                i


                            A Construction for
                        One Way Hash Functions
                                   and
                      Pseudorandom Bit Generators

                                Abstract

          We prove that if f is a n-bit one-way permutation, i.e., it
      has some hard bits, a one-way permutation with n - k
      provably simultaneous hard bits can be constructed with it.
      We apply this construction to improve the efficiency of
      Blum-Micali pseudo-random bit generator. Then, we apply
      the construction to propose a new approach for building
      universal one-way hash functions. This approach merges
      Damgard's design principle (or Merkle's meta-method) and
      the method proposed by Zheng, Matsumoto and Imai for the
      construction of hash functions for long messages.


1   Introduction


The current trend in cryptography is to provide the construction of basic
primitives with general cryptographic assumptions that are also as weak
as possible (it is theoretically important to base cryptographic primitives
and basic tools on reduced complexity assumptions). It is also practically
important to give efficient implementation of such constructions [9].
Naor and Yung [8] showed that a secure signature scheme reduces to the
existence of Universal One Way Hash Functions (UOWHF). They
constructed a family of UOWHF from any one-way permutation and a
family of strongly universal  2 hash functions, which was introduced in
[3],[11 ], with collision accessibility property. In their construction, the
one-way permutation provides the one-wayness of the UOWHF, and the
strongly universal  2 family of hash functions performs the mapping to
the small length output. When a member is chosen randomly and
uniformly from the family, the output is distributed randomly and
uniformly over the output space.
In this area, each successive paper has assumed weaker conditions for the
one-way function and has made hashing and additional procedures more
complicated, such that Rompel's scheme [9] can be constructed from any
one-way function but needs too many additional procedures. In contrast,
in this paper we make a one-way permutation with some stronger
properties but we apply a simple hashing procedure, simply chopping or
selecting arbitrarily some bits of the output.
On the other hand, for the construction of pseudo-random bit generators
(PBG), Blum and Micali [2] discovered hard-core predicates b of
functions f. Such b(x) cannot be efficiently obtained, given f(x). They



                                     1


applied this notion to construct a PBG based on the intractability of the
discrete logarithm problem.
In this paper, we present a method such that given an n-bit one-way
permutation, i.e., it has some hard bits, a one-way permutation with n
hard bits can be constructed, which we call it a strong permutation. We
apply this strong permutation to present a construction for
pseudo-random bit generators with maximum efficiency, based on the
Blum-Micali pseudo-random bit generator. We also present a method to
build a universal one-way hash function from the strong permutation.
Hence, given a one-way permutation, we can construct both an efficient
pseudo-random generator and a universal one-way hash function. Zheng,
Matsumoto and Imai [13 ] revealed a duality between pseudo-random bit
generators and UOWHF. Applying the revealed duality, they presented a
construction for UOWHF which is a dual of the construction of
Blum-Micali PBG. We show that by the application of the strong
permutation, Zheng et al.'s scheme and Damgard's design principle for
construction of hash functions merge with each other and would yield the
same result. As the result, our proposal yields an algorithm that can be
used for both generating pseudorandom bits and hashing long messages.
This has a practical significance, since it would not be necessary to use
two different algorithms for implementing these two cryptographic tools.


2   Notations


The notation we use here is similar to [13 ]. The set of all integers is
denoted by N. Let   = {0; 1} be the alphabet we consider. For n 2 N ,
 n is the set of all binary strings of length n. The concatenation of two
binary strings x; y is denoted by x k y.
Let l be a monotone increasingSfunction from N toSN and f a function
from D to R, where D =   nDn , Dn    n and R =   nRn , Rn    l(n).
D is called the domain and R the range of f. Denote by fn the
restriction of f on  n . f is a permutation if each fn is a 1 to 1 and onto
function. f is polynomial time computable if there is a polynomial time
algorithm computing f(x) for all x 2 D. The composition of two
functions f and g is defined as f O g(x) = f(g(x)). The i-fold
composition of f is denoted by f(i).
A (probability) ensemble E, with length l(n), is a family of probability
distributions {En | En :  l(n)! [0; 1]; n 2 N }. The uniform ensemble U
with length l(n) is the family of uniform probability distributions Un ,
where each Un is defined as Un (x) = __1_2l(n), for all x 2  l(n). By
x 2E  l(n)we mean that x is randomly selected from  l(n)according to
En , and in particular by x 2r S we mean that x is chosen from the set S
uniformly at random. E is samplable if there is an algorithm M that on
                                     2


input n, outputs an x 2E  l(n), and polynomially samplable if the
running time of M is also polynomially bounded.


3   Preliminaries


Definition 1    A statistical_test____ is a probabilistic algorithm
T  that on an input x, where x is an n-bit string, halts in
O(nt) and outputs a bit 0=1, where t is some fixed positive
integer.


Definition 2    Let l  be a polynomial, and E1  and E2  be
ensembles both with length l(n).   E1  and E2  are called
indistinguishable____ from each other, if for each statistical
test T , for each polynomial Q, for all sufficiently large
n,

             | P rob{T (x1) = 1} - P rob{T (x2) = 1} |< __1___Q(n)


where x1 2E1  l(n), x2 2E2  l(n).


Definition 3    A polynomially samplable ensemble E  is
pseudorandom___ if it is indistinguishable from the uniform
ensemble U  with the same length.

                                         S              S
Definition 4    Let f : D ! R, where D =   n n  and R =   n l(n),
be a polynomial time computable function.   We say that f  is
one-way__ if for each probabilistic polynomial time algorithm
M , for each polynomial Q and for all sufficiently large n,


                  P rob{fn (M (fn (x))) = fn (x)} < __1___Q(n)


where x 2U Dn .


Note that the one-way property of a function is relative to a specific
model of computation with a specific amount of computing resources.


Definition 5    We say we have a computing_resource_for_k__bits______
if given the output of a one-way function and n - k  bits of
the input string, one can define the remaining k  bits of the
input string by exhaustive search.


For the remaining of this paper we assume that we have a computing
resource for at most k bits.


                                     3


4   Hard Bits


If a function f is one-way then given f(x) the argument x must be
unpredictable. If every bit of the argument x were easily computable
from f(x), then f would not be a one-way function. Therefore, some
specific bits of the argument are unpredictable, and we cannot guess
them better than by flipping a coin. We call these bits hard bits of f.

DefinitionS6    LetSf : D ! R be a one-way function, where
R =   n n  and D =   n l(n).   Let i(n) be a function from N  to
N  with 1   i(n)   n.   If for each probabilistic polynomial
time algorithm M , for each Q and for all sufficiently large
n,

                  P rob{M (fn (x)) = x0i(n)} < 1_2+ __1___Q(n)


where x 2r  n  and x0i(n)is the i(n)-th bit of an x0 2  n
satisfying f(x) = f(x0), then i(n)-th bit is a hard_bit__ of f
[13 ].

Note that the definition of hard bits implies that a hard bit depends on
all bits of f(x) under f-1 , where f-1  is a hard problem.

Lemma 1   The number of hard bits defines the difficulty of
inverting a one-way function.

Intuitively, a one-way function should have at least k + 1 hard bits.

Lemma 2   All the hard bits are independent of one another.

(Proofs of lemma 1 and lemma 2 will be given in the full paper.)
>From the above lemma we draw the following corollary.

CorollaryS1    Let fS: D ! R be a one-way function, where
D =   n n  and R =   n l(n).   Assume f  has t hard bits,
t < n - k, and j  of them and f(x) are given, we cannot predict
any of the remaining t - j  hard bits with a probability better
than  1_2+ __1__Q(n).

Definition 7    Let l  be a polynomial, and E  be an ensemble
with length l(n).   We say that E  passes the next_bit_test___  if
for each statistical test T , for each polynomial Q, for all
sufficiently large n, the probability that on input the
first i bits of a sequence x randomly selected according to
E  and i < l(n), T  outputs the (i + 1)th bit of x is:


                  P rob{T (x1; : :;:xi) = 1} < 1_2+ __1___Q(n)


where x 2E  l(n).



                                     4


The following theorem is derived from (Yao 82 [12 ]) and has been stated
in [2],[1],[5] in different terms.


Theorem 1   Let E  be an polynomially samplable ensemble, the
following statements are equivalent:
(i)  E  passes the next bit test.
(ii) E  is indistinguishable from the uniform ensemble U .


In other words, the indistinguishability test is equivalent to the
unpredictability test.


Corollary 2S   Assume thatSf : D ! R is a one-way function,
where D =   n n  and R =   n l(n).   Also assume that
i1; i2; : :;:it are functions from N  to N , with 1   ij(n)   n for
each 1   j   t, t < n - k  and each ij denotes a hard bit of f.
Denote by E1n and E2n the probability distributions defined by
the random variables xit(n): :x:i2(n)xi1(n)k f(x) and rt: : :r2
r1 k f(x) respectively, where x 2r  n , xij(n) is the ij(n)-th bit
of x and rj 2r  .   Let E1 = {E1n| n 2 N } and E2 = {E2n| n 2 N },
then E1  and E2  are indistinguishable from each other.


Proof sketch: Combine corollary 1 and theorem 1.
In other words, given f(x), the string of t < n - k hard bits is
indistinguishable from random strings. They are called
simultaneous_hard_bits__of f.
Blum and Micali discovered the notion of hard core predicates of
functions and applied it to construct pseudorandom bit generators
(PBG).


Definition 8    Let l  be a polynomial with l(n) > n.   A
pseudorandom_bit_generator______ is a deterministic polynomial
time function g  that upon receiving a random n-bit input,
extends it into a sequence of l(n)-bit pseudorandom bits
b1; b2; : :;:bl(n) as the output.


In other words:

   1. Each bit bk is easy to compute.

   2. The output bits are unpredictable, in other words the output string
      passes the next bit test, i.e., given the generator g and the first s
      output bits b1; : :;:bs, but not the input string, it is
      computationally infeasible to predict the (s + 1)th bit in the
      sequence [2].

The following theorem describes Blum-Micali PBG [2].



                                     5


Theorem 2   Let l  be a polynomialSwith l(n) > n, and let f  be a
one-way permutation on D =   n n  and i(n)-th bit is proven to
be a hard bit of f.   Let gn  be a function defined as
follows:

  1.  Generate the sequence f(1)n(x); f(2)n(x); : :;:f(l(n))n(x), where
      x 2  n .

  2.  From right to left (!), extract i-th bit from each
      element in the above sequence and output that bit.

so, gn (x) = bl(n)(x) : :b:2(x) b1(x) where x 2  n  and bj(x) = (the

i-th bit of f(j)n(x)).   The g = {gn | n 2 N } is a pseudorandom
bit generator extending n-bit into l(n)-bit output strings.


If i1(n), : :,:it(n)-th bits are simultaneous hard bits of f, then the
efficiency of g can be improved by defining the bj(x) to be a function
which extracts all known simultaneous hard bits of f(j)(x).
In [1], it has been proved that the log2(n) least significant bits of RSA
and Rabin encryption functions are simultaneously hard. Hence, if we
use RSA or Rabin functions as the one-way permutation, with each
iteration of the function we can extract log2(n) bits. For example, if n is
equal to 512 and we would like to produce a 512 bit pseudorandom
string, we should iterate the one-way function for
d _l(n)_log2(n)e = d __512___log2(512)e = 57 times. If a one-way permutation ha*
 *s more
known hard bits, we can use it instead of RSA or Rabin function and
obtain a better efficiency.


5   A Strong One Way Permutation


In this section we construct a strong one-way permutation which can be
used for the construction of both the Blum-Micali pseudorandom bit
generator and one-way hash functions. Before describing the
construction some preliminary definitions are given.


Definition 9    A transformation is called complete__ if each
output bit depends on all input bits.   In other words, the
simplest Boolean expression for each output bit contains all
the input bits.


Definition 10    If the inverse of a complete transformation is
also complete, it is described as being two_way_complete____.
In other words, each output bit depends on all the input
bits and vice-versa.

                                     6


Lemma 3   If a permutation is complete, then it is also two way
complete.


Definition 11    If the correlation between two binary variables
is zero, they are called independent_variables_____.


(See [10 ], for the definition of correlation.)

Definition 12    Let v  be a complete permutation and all the
output bits be pairwise independent.   We call v  a
perfect_permutation_____.

For the following theorems, we use a two way complete permutation such
that only k + 1 output bits are independent of other bits and we call it a
k + 1-bit perfect permutation, which has much looser requirements than
a perfect permutation. If we consider k = 63, a k + 1-bit perfect
permutation can easily be constructed with the Kam and Davida's
method [6], plus a single DES block.


Theorem 3   Let f  be an n-bit one-way permutation.   Let v  be a
permutation then m = f O v O f  is also a one-way permutation.


Proof: Both f and v are permutations and f is a one-way permutation,
so the result of their composition would be a one-way permutation.


TheoremS4   Let m : D ! D  be a one-way permutation where
D =   n n  and m = f O v O f, where f is a one-way permutation,
i.e., it has at least k + 1 hard bits, and v  is a k + 1-bit
perfect permutation where the positions of independent
output bits comply with the position of hard bits of f.   For
each probabilistic polynomial time algorithm M , for each Q
and for all sufficiently large n,


                    P rob{M (m(x)) = xi} < 1_2+ __1___Q(n)


where x 2r  n  and xi is the i-th bit of the x, and 1   i   n.
In other words, each bit of x is a hard bit of m.


Proof sketch: (By contradiction)
We show that if an algorithm could find xi, it would be able to invert f.
For the simplicity of notations, we indicate the first one-way function
with f1 and the second one with f2, so m = f2 O v O f1. Assume that M
is an algorithm that given m(x), can predict xi with a probability bigger
than 1_2+ __1__Q(n). Two situations may arise.
(a) when the i-th bit is not a hard bit of f1:



                                     7


Since the i-th bit is not a hard bit of f1, then given f1(x), there exists an
algorithm that can find the i-th bit with a probability bigger than
 1_ __1__
 2+ Q(n). Due to the two way completeness property of v, all bits of
v O f1(x) depend on all bits of f1(x) and vice-versa. Moreover, since the
k + 1 independent bits of v comply with hard bits of f2, knowing some
other bits (other than independent output bits of v) of v O f1(x) and v,
we cannot calculate all its bits. So, to obtain f1(x), we need to know all
bits of v O f1(x). If v is an invertible function in polynomial time, then
given v O f1(x), it is possible to find the i-th bit of x,


                 P rob{M 0(v O f1(x)) = xi} > 1_2+ __1___Q0(n)


the probability equation simply says that we can predict xi by tossing a
coin with probability 1=2 or estimating it given v O f1(x) with a
probability better than 1=Q0(n), then


                P rob{estimating    xi | v O f1(x)} > __1___Q0(n)


According to the assumption, we also know that:

 _1____ <   P rob{estimating    x  | f  O v O f (x)}
 Q(n)                            i    2        1

        =   P rob{estimating    xi | v O f1(x)}:P rob{obtaining    v O f1(x) | *
 *f2 O v O f1(x)}


Since the multiplication of two polynomial expressions is another
polynomial expression, then for some polynomial Q00, the following holds:


           P rob{obtaining    v O f1(x) | f2 O v O f1(x)} > ___1___Q00(n)


This is equivalent to iverting f2 and contradicts our assumption that f2
is a one-way permutation.
(b) when the i-th bit is a hard bit of f1; it is obvious that the i-th bit
should also be a hard bit of m.
The theorem 3 simply suggested a construction for a one-way
permutation m such that each bit of x is a hard bit of m. We call such a
permutation m a strong_one-way_permutation______or simply a
strong_permutation____. The following corollary can be drawn from
theorem 3.


Corollary 3    Assume thatSm : D ! D  is a strong one-way
permutation, where D =   n n .   Also assume that i1; i2; : :;:it
are functions from N  to N , with 1   ij(n)   n for each
1   j   t, t < n - k.   Denote by E1n and E2n the probability



                                     8


distributions defined by the random variables xit(n): :x:i2(n)
xi1(n)k m(x) and rt: : :r2  r1 k m(x) respectively, where x 2r  n ,
xij(n) is the ij(n)-th bit of x and rj 2r  .   Let
E1 = {E1n| n 2 N } and E2 = {E2n| n 2 N }, then E1  and E2  are
indistinguishable from each other.


In other words, any string of t < n - k bits of x is indistinguishable from
random strings.
We can now construct the efficient Blum-Micali pseudo-random bit
generator with the strong one-way permutation suggested in theorem 4.


Theorem 5   Let l  be a polynomial with l(n) > n and m be a
strong one-way permutation.   Let g be a function defined as
follows:

  1.  Generate the sequence m(1)n(x); m(2)n(x); : :;:m(l(n))n(x), where
      x 2  n .

  2.  From right to left, extract n - k - 1 bits from each
      element in the above sequence and output them.

Then g  is a pseudorandom bit generator extending n-bit into
(n - k - 1)l(n) bit output strings.


Since we have a computing resource for k bits then the above scheme
yields the maximum possible efficiency. If k = 128 (!) and n is 512, then
with 2 iterations of m, or 4 iterations of f, we can extract 766
pseudorandom bits. This yields nearly 192 pseudo-random bits per
iteration of f, which is 21 times more efficient than using RSA or Rabin
function with the scheme described in theorem 2.
Note that since the output string is pseudorandom, we can also draw the
following corollary.


Corollary 4    The n - k - 1 extracted bits of each iteration is
distributed uniformly and randomly in  n-k-1 .


6   UOWHF Construction and PBG


There are two kinds of one-way hash functions, i.e., universal one way
hash functions, or weak one-way hash functions, and collision free hash
functions, or strong one-way hash functions. The main property of the
former is that given a random initial string x, it is computationally
infeasible to find a different string y that collides with x, i.e.,
h(x) = h(y). The main property of the latter is that it is computationally
difficult to find a pair (x; y) of strings, x 6= y, that collide with each
other. In universal one-way hash functions, there is no guarantee that it



                                     9


is computationally infeasible to find pairs of input that map onto the
same output and for some inputs z 6= z0 might h(z) = h(z0). However,
there should not be too many z; z0 pairs. So, choosing x randomly should
make it unlikely that anyone can find an x0 such that h(x) = h(x0) [7].
Another problem with universal one-way hash functions is that repeated
use weakens them. To deal with this problem, we can simply define a
family of one-way hash functions with the property that each member hi
of the family is different from all other members, so any information
about how to break hi will provide no help in breaking hj for i 6= j (see
[7]). If the system is designed so that every use of a universal one-way
hash function is parametrized by a different parameter, then the overall
system security can be kept high. Naor and Yung [8] constructed such a
family of functions with a one-way permutation and a strongly
universal  2 family of hash functions. The precise definition of UOWHF
is given in definition 13 below.


6.1   Preliminaries

Let l be a polynomialSwith l(n) > n, H is a family of hash functions
defined by H =   nHn , where Hn is a set of functions from  l(n)to  n .
For two strings x; y 2  l(n)with x 6= y, we say that x and y collide under
h 2 Hn or (x; y) is a collision pair for h, if h(x) = h(y). H is polynomial
time computable if there is a polynomial time algorithm computing all
h 2 H, and accessible if there is a probabilistic polynomial time
algorithm that on input n 2 N outputs uniformly at random a
description of h 2 Hn . Let F be a collision finder. F is a probabilistic
polynomial time algorithm such that on input x 2  l(n)and h 2 Hn
outputs either ? (cannot find) or a string y 2  l(n)such that x 6= y and
h(x) = h(y).

Definition 13    Let H  be a computable and accessible hash
function compressing l(n)-bit input into n-bit output strings
and F  a collision string finder.   H  is a
universal_one-way_hash_____ function__ if for each F , for each Q
and for all sufficiently large n,


                        P rob{F (x; h) 6=?} < __1___Q(n)


where x 2  l(n) and h 2r Hn .   The probability is computed over
all h 2r Hn , x 2  l(n) and the random choice of F .


6.2   UOWHF Based on the Strong One-Way Permutation

Theorem 6   Assume thatSm : D ! D  is a strong one-way
permutation, where D =   n n , and chop 1 :  n !  n-1  simply



                                    10


chops the last bit, then h = chop 1O m is a universal one-way
hash function.


Proof: (By contradiction), assume that there is a probabilistic
algorithm F that can find a collision, then we show that we can make an
algorithm that can invert m. Consider that we first choose an x at
random, then run m on x to get m(x), then we obtained
h(x) = chop 1(m(x)). There is only one element that can collide with
m(x) under chop 1. This element differs with m(x) in one bit. Let us
notate this element m(y). If a collision finder can find an y such that
collides with x under h with probability bigger than __1__Q(n), then it can
obtain y from m(y) with the same probability. This contradicts our
assumption that m is a one-way permutation.


Lemma 4   If we define 1chop  :  n !  n-1  simply to chop one bit
and the position of chopped bit is defined in the
description of the function and can be any bit, then
h = 1chop (m(x)) is also a universal one-way hash function.


Proof sketch: repeat a procedure similar to the proof of the theorem 6.
Note that the problem of finding a collision for h, defined in the lemma
4, can be reformulated to finding x; y and x 6= y, such that m(x) and
m(y) match at all bits except at the one defined in the definition of
1chop  function. Since according to corollary 3 and corollary 4 the output
of m is distributed uniformly and randomly in  n , then for finding y
with exhaustive search, we need to perform 2n-1  operations on the
average. If this much computation is bigger than 2k, then it is infeasible
to find the collision.
If we chop t bits of m(x), then there are (2t - 1) elements which collide
with x under h. If these elements are distributed randomly in 2n
elements; then, on the average, we need to do 2n-t search operations to
find a collision for x. Since our computational resource can do at most
2k search operations then t should be less than n - k.


Corollary 5    Let chop t :  n !  n-t  simply to chop t last bits
and t < n - k, then h = chop tO m is a universal one-way hash
function.


Note that the scheme described in the above corollary increases the
efficiency of the hash function scheme, so for hashing long messages, we
need to do less iterations. We can also generalise the above scheme by
introducing tchop  to be a function which chops t bits of the output. In
this case, we need (n - k - 1) log2n bits to specify the positions of the
chopped bits.
                                    11

